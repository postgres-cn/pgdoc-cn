<!-- doc/src/sgml/ecpg.sgml -->

<chapter id="ecpg"> 
<!-- 
 <title><application>ECPG</application> - Embedded <acronym>SQL</acronym> in C</title>
-->
  <title><application>ECPG</application> - 在C中嵌入<acronym>SQL</acronym></title>
 
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <!--
<para>
  This chapter describes the embedded <acronym>SQL</acronym> package
  for <productname>PostgreSQL</productname>. It was written by
  Linus Tolke (<email>linus@epact.se</email>) and Michael Meskes
  (<email>meskes@postgresql.org</email>). Originally it was written to work with
  <acronym>C</acronym>. It also works with <acronym>C++</acronym>, but
  it does not recognize all <acronym>C++</acronym> constructs yet.
 </para>
-->
<para>
   这章描写一种用于<productname>PostgreSQL</productname>的嵌入<acronym>SQL</acronym>包。
   它是由Linus Tolke(<email>linus@epact.se</email>)和 
   Michael Meskes(<email>meskes@postgresql.org</email>)写的。
   最初它是为了在<acronym>C</acronym>里面使用书写的。它也可以用于<acronym>C++</acronym>， 
   但是它还不能识别所有<acronym>C++</acronym>构造。
</para>

 <!--
<para>
  This documentation is quite incomplete.  But since this
  interface is standardized, additional information can be found in
  many resources about SQL.
 </para>
-->
<para>
   这份文档相当不完整。但是因为这个接口是标准，
   所以我们可以在有关SQL的资源里找到许多额外的信息。  
</para>

 <sect1 id="ecpg-concept">
 <!--
  <title>The Concept</title>
 -->
   <title>概念</title>

  <!--
<para>
   An embedded SQL program consists of code written in an ordinary
   programming language, in this case C, mixed with SQL commands in
   specially marked sections.  To build the program, the source code (<filename>*.pgc</filename>)
   is first passed through the embedded SQL preprocessor, which converts it
   to an ordinary C program (<filename>*.c</filename>), and afterwards it can be processed by a C
   compiler.  (For details about the compiling and linking see <xref linkend="ecpg-process">).
   Converted ECPG applications call functions in the libpq library
   through the embedded SQL library (ecpglib), and communicate with
   the PostgreSQL server using the normal frontend-backend protocol.
  </para>
-->
<para>
   嵌入SQL程序主要由一种普通的编程语言代码组成，
   在我们这个场合中是C，并且在其中与一些特殊标记的段混合。
   要制作这样的程序，源代码(<filename>*.pgc</filename>)
   首先经过嵌入的SQL预处理器处理，
   它把源代码转换成普通的C程序(<filename>*.c</filename>)， 
   然后这个程序可以用C编译器进行处理。
   关于编译和链接的细节参阅<xref linkend="ecpg-process">。
   转变的ECPG应用在libpq库中通过嵌入的SQL库（ecpglib）调用函数。
   并且使用正常的前后端协议与PostgreSQL服务器通信。
   
</para>

  <!--
<para>
   Embedded <acronym>SQL</acronym> has advantages over other methods
   for handling <acronym>SQL</acronym> commands from C code. First, it
   takes care of the tedious passing of information to and from
   variables in your <acronym>C</acronym> program.  Second, the SQL
   code in the program is checked at build time for syntactical
   correctness.  Third, embedded <acronym>SQL</acronym> in C is
   specified in the <acronym>SQL</acronym> standard and supported by
   many other <acronym>SQL</acronym> database systems.  The
   <productname>PostgreSQL</> implementation is designed to match this
   standard as much as possible, and it is usually possible to port
   embedded <acronym>SQL</acronym> programs written for other SQL
   databases to <productname>PostgreSQL</productname> with relative
   ease.
  </para>
-->
<para>
   嵌入的<acronym>SQL</acronym>相比于其它的从
   C代码中处理<acronym>SQL</acronym>命令的优点有几条。
   首先，它照看那些从你的<acronym>C</acronym>
   程序中的变量中传来传去数值的事情。 
   第二，在编译时检查程序中SQL代码句法正确性。
   第三，在C代码里嵌入<acronym>SQL</acronym>是定义
   在<acronym>SQL</acronym>标准里的，
   并且被许多其它的<acronym>SQL</acronym>数据库支持。 
   <productname>PostgreSQL</>的实现被设计成尽可能匹配这个标准， 
   并且通常可以把为其它SQL数据库书写的<acronym>SQL</acronym>移植到
   <productname>PostgreSQL</productname>中来，反之亦然。 
</para>

  
<para>
<!--
   As already stated, programs written for the embedded
   <acronym>SQL</acronym> interface are normal C programs with special
   code inserted to perform database-related actions.  This special
   code always has the form:
-->
   如上所述，为嵌入<acronym>SQL</acronym>
   接口写的程序通常是带着插入进来的特殊代码的C程序， 
   这些特殊代码用于执行与数据库相关的动作。
   这些特殊代码通常的形式是下面这样：
   
<programlisting>
EXEC SQL ...;
</programlisting>
   <!--
   These statements syntactically take the place of a C statement.
   Depending on the particular statement, they can appear at the
   global level or within a function.  Embedded
   <acronym>SQL</acronym> statements follow the case-sensitivity rules of
   normal <acronym>SQL</acronym> code, and not those of C. Also they allow nested
   C-style comments that are part of the SQL standard. The C part of the
   program, however, follows the C standard of not accepting nested comments.
   -->
   这些语句语法上占据C语句的位置。根据具体语句的不同，
   它们可以出现在全局环境中或者出现在一个函数里。 
   嵌入的<acronym>SQL</acronym>语句遵循普通<acronym>SQL</acronym>
   代码的大小写敏感规则，而不是遵循C代码的。
   它们也允许SQL标准部分中嵌套的C风格注释。不过程序中的C部分，
   遵守C标准，不接受嵌套的注释。   
  </para>
 
  <!--
<para>
   The following sections explain all the embedded SQL statements.
  </para>
-->
<para>
   下面的小节都是用来解释所有的嵌入SQL语句的。 
</para>
 </sect1>

 <sect1 id="ecpg-connect">
 <!--
  <title>Managing Database Connections</title>
 -->
   <title>管理数据库连接</title>

  <!--
<para>
   This section describes how to open, close, and switch database
   connections.
  </para>
-->
<para>
  本节描述了如何打开，关闭，以及切换数据库连接。
</para>

  <sect2 id="ecpg-connecting">
  <!--
   <title>Connecting to the Database Server</title>
  -->
    <title>与数据库服务器连接</title>

 
<para>
    <!--
   One connects to a database using the following statement:
   -->
   用下面的语句与一个数据库连接：
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   <!--
   The <replaceable>target</replaceable> can be specified in the
   following ways:
   -->
   <replaceable>target</replaceable>可以通过下面的方法声明：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</><optional>@<replaceable>hostname</></optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
 <!--
      an SQL string literal containing one of the above forms
  -->
  一个包含上面形式的SQL字串文本
     </simpara>
    </listitem>

    <listitem>
     <simpara>
 <!--
      a reference to a character variable containing one of the above forms (see examples)
     -->
 一个对包含上面的形式之一的字符串变量的引用 
 </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>
   <!--
   If you specify the connection target literally (that is, not
   through a variable reference) and you don't quote the value, then
   the case-insensitivity rules of normal SQL are applied.  In that
   case you can also double-quote the individual parameters separately
   as needed.  In practice, it is probably less error-prone to use a
   (single-quoted) string literal or a variable reference.  The
   connection target <literal>DEFAULT</literal> initiates a connection
   to the default database under the default user name.  No separate
   user name or connection name can be specified in that case.
   -->
   如果你用文本声明连接目标（也就是说，不是通过一个变量引用），
   而且你也不引用这个数值，那么使用普通SQL的大小写无关的规则。
   这种情况下，你也可以根据需要独立地对参数使用双引号包围。
   实际上，可能用一个（单引号包围）的
   字串文本或者变量引用作为连接目标可能更结实一些。 
   连接目标<literal>DEFAULT</literal>发起一个用缺省用户名对缺省数据库地连接。
   这个时候不应该声明用户名或连接名。
  </para>
  
<para>
  <!--
   There are also different ways to specify the user name:
   -->
   声明用户名的方法也有几种不同方式：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>
   <!--
   As above, the parameters <replaceable>username</replaceable> and
   <replaceable>password</replaceable> can be an SQL identifier, an
   SQL string literal, or a reference to a character variable.
   -->
   正如上面的一样，参数用户名和密码可以是一个SQL标识，
   一个字符变量，或者一个字符串。
  </para>

  <!--
<para>
   The <replaceable>connection-name</replaceable> is used to handle
   multiple connections in one program.  It can be omitted if a
   program uses only one connection.  The most recently opened
   connection becomes the current connection, which is used by default
   when an SQL statement is to be executed (see later in this
   chapter).
  </para>
-->
<para>
<replaceable>连接名</replaceable>用于处理一个程序里的多个连接。 
如果一个程序只使用一个连接，则可以省略它。
最近打开的连接成为当前连接， 
在准备执行SQL语句的时候，缺省时会使用这个连接（参阅本章稍后部分）。
</para>


<para>
   <!--
   Here are some examples of <command>CONNECT</command> statements:
   -->
   这里是一些<command>CONNECT</command>语句的例子：
   
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* or EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   <!--
   The last form makes use of the variant referred to above as
   character variable reference.  You will see in later sections how C
   variables can be used in SQL statements when you prefix them with a
   colon.
   -->
   最后的一个形式使用了上面说过的变量引用的方法。
   在后面的小节里你会看到在SQL语句里如何使用前缀了冒号的C变量。 
  </para>
  <!--
<para>
   Be advised that the format of the connection target is not
   specified in the SQL standard.  So if you want to develop portable
   applications, you might want to use something based on the last
   example above to encapsulate the connection target string
   somewhere.
  </para>
-->
<para>
   请注意连接目标的格式没有在SQL标准里说明。所以，
   如果你想开发可以移植的应用，
   你可能会想使用类似上面的最后一个例子这样的方法来把连接目标字串封装在某处。
</para>
  </sect2>

  <sect2 id="ecpg-set-connection">
  <!--
   <title>Choosing a Connection</title>
  -->
    <title>选择一个连接</title>

  <!--
<para>
   SQL statements in embedded SQL programs are by default executed on
   the current connection, that is, the most recently opened one.  If
   an application needs to manage multiple connections, then there are
   two ways to handle this.
  </para>
-->
<para>
   在当前连接中缺省执行嵌入SQL程序的SQL语句，也就是说，最近打开的。
   如果应用需要管理多个连接，那么有两种处理方法。
</para>

  
<para>
   <!--
   The first option is to explicitly choose a connection for each SQL
   statement, for example:
   -->
   第一个选项是为每个SQL语句明确选择一个连接，比如:
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   <!--
   This option is particularly suitable if the application needs to
   use several connections in mixed order.
   -->
   如果在混合顺序中应用程序需要使用若干个连接时，这个选项特别适合。
  </para>

  <!--
<para>
   If your application uses multiple threads of execution, they cannot share a
   connection concurrently. You must either explicitly control access to the connection
   (using mutexes) or use a connection for each thread. If each thread uses its own connection,
   you will need to use the AT clause to specify which connection the thread will use.
  </para>
-->
<para>
   如果你的应用程序使用多个执行线程，他们不能同时共享连接。
   你要么明确控制访问连接（使用互斥锁）或者为每个线程使用一个连接。
   如果每个线程使用自己的连接，你将需要使用AT子句指定线程将使用哪个连接。
</para>

  
<para>
   <!--
   The second option is to execute a statement to switch the current
   connection.  That statement is:
   -->
   第二个选项是执行语句切换当前连接。语句是：
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   <!--
   This option is particularly convenient if many statements are to be
   executed on the same connection.  It is not thread-aware.
   -->
   如果在同一个连接上执行许多语句，那么这种选择很方便。它不是线程感知的。
  </para>


<para>
   <!--
   Here is an example program managing multiple database connections:
   -->
   这里有一个管理多个数据库连接的例子程序：

<!--   
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;
   
    /* This query would be executed in the last opened database "testdb3". */

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);
    
    /* Using "AT" to run a query in "testdb2" */

    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* Switch the current connection to "testdb1". */

    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
-->

<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;
   
/*在最后打开的数据库"testdb3"中执行该查询*/
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);
    

/*在"testdb2"中使用"AT"运行查询*/

    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

/*切换当前连接到"testdb1" */

    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>



 
   <!--
   This example would produce this output:
   -->
   这个例子可能产生这样的输出:
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>

  </sect2>

  <sect2 id="ecpg-disconnect">
  <!--
   <title>Closing a Connection</title>
  -->
   <title>关闭一个连接</title>
    
   
  
<para>
   <!--
   To close a connection, use the following statement:
   -->
   使用下面的语句关闭连接：
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   <!--
   The <replaceable>connection</replaceable> can be specified
   in the following ways:
   -->
   通过下面的方法声明<replaceable>连接</replaceable>:
   <itemizedlist>
    <listitem>
     <simpara>
  <!--
      <literal><replaceable>connection-name</replaceable></literal>
  -->
      <literal><replaceable>连接名</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
  <!--
      <literal>DEFAULT</literal>
  -->
  <literal>缺省</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
  <!--
      <literal>CURRENT</literal>
  -->
  <literal>当前</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
  <!--
      <literal>ALL</literal>
  -->
  <literal>所有</literal>
     </simpara>
    </listitem>
   </itemizedlist>
   <!--
   If no connection name is specified, the current connection is
   closed.
   -->
   如果没有声明连接名，那么关闭当前连接。
  </para>
  <!--
<para>
   It is good style that an application always explicitly disconnect
   from every connection it opened.
  </para>
-->
<para>
   应用保持明确关闭每次打开的连接是一个很好的习惯。 
</para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
 <!--
  <title>Running SQL Commands</title>
 -->
    <title>运行SQL命令</title>
  <!--
<para>
   Any SQL command can be run from within an embedded SQL application.
   Below are some examples of how to do that.
  </para>
-->
<para>
   在嵌入的SQL应用中可以运行任何SQL命令。下面是一些如何使用它们的例子。
</para>

  <sect2 id="ecpg-executing">
  <!--
   <title>Executing SQL Statements</title>
  -->
   <title>执行SQL语句</title>
   
  
<para>
   <!--
   Creating a table:
   -->
   创建一个表：
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>
  
 
<para>
    <!--
   Inserting rows:
   -->
   插入一行：
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>
  
<para>
  <!--
   Deleting rows:
  -->
   删除一行：
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  
<para>
   <!--
   Updates:
   -->
   更新：
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <!--
<para>
   <literal>SELECT</literal> statements that return a single result
   row can also be executed using
   <literal>EXEC SQL</literal> directly.  To handle result sets with
   multiple rows, an application has to use a cursor;
   see <xref linkend="ecpg-cursors"> below.  (As a special case, an
   application can fetch multiple rows at once into an array host
   variable; see <xref linkend="ecpg-variables-arrays">.)
  </para>
-->
<para>
    可以通过<literal>EXEC SQL</literal>直接执行返回一个结果行的<literal>SELECT</literal>
语句。为了处理多行结果集，应用程序必须使用游标；
参阅<xref linkend="ecpg-cursors">。（特殊情况下，应用程序可以一次读取多行到数组宿主变量中；
参阅<xref linkend="ecpg-variables-arrays">。）
</para>

  
<para>
   <!--
   Single-row select:
   -->
   单行select:
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>
  
<para>
   <!--
   Also, a configuration parameter can be retrieved with the
   <literal>SHOW</literal> command:
   -->
   同时，可以使用<literal>SHOW</literal>命令检索配置参数：
   
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>

  <!--
<para>
   The tokens of the form
   <literal>:<replaceable>something</replaceable></literal> are
   <firstterm>host variables</firstterm>, that is, they refer to
   variables in the C program.  They are explained in <xref
   linkend="ecpg-variables">.
  </para>
-->
<para>
   形如<literal>:<replaceable>something</replaceable></literal>
   这样的记号是<firstterm>宿主变量</firstterm>，也就是说，他们指向C程序中的变量。
   在<xref linkend="ecpg-variables">中有解释。
</para>
  </sect2>

  <sect2 id="ecpg-cursors">
  <!--
   <title>Using Cursors</title>
   -->
   <title>使用游标</title>

  <!--
<para>
   To retrieve a result set holding multiple rows, an application has
   to declare a cursor and fetch each row from the cursor.  The steps
   to use a cursor are the following: declare a cursor, open it, fetch
   a row from the cursor, repeat, and finally close it.
  </para>
-->
<para>
   为了检索出多行的结果集，应用程序必须声明一个游标并且从游标中抓取每一行。
   使用游标的步骤如下：声明一个游标，打开它，从游标中抓取一行，重复，最后关闭它。
</para>

  
<para>
  <!--
   Select using cursors:
   -->
   使用游标选择：
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <!--
<para>
   For more details about declaration of the cursor,
   see <xref linkend="ecpg-sql-declare">, and
   see <xref linkend="sql-fetch"> for <literal>FETCH</literal> command
   details.
  </para>
-->
<para>
  关于游标声明的更多细节，请参阅<xref linkend="ecpg-sql-declare">，关于
  <literal>FETCH</literal>命令的细节请参阅<xref linkend="sql-fetch">。
</para>

   <note>
    <!--
<para>
     The ECPG <command>DECLARE</command> command does not actually
     cause a statement to be sent to the PostgreSQL backend.  The
     cursor is opened in the backend (using the
     backend's <command>DECLARE</command> command) at the point when
     the <command>OPEN</command> command is executed.
    </para>
-->
<para>
     ECPG <command>DECLARE</command>命令实际上不会造成语句被发送到PostgreSQL后端。
 当执行<command>OPEN</command>命令时，
 在后端(使用后端的<command>DECLARE</command>命令)打开游标。
</para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
  <!--
   <title>Managing Transactions</title>
  -->
   <title>管理事务</title>

  <!--
<para>
   In the default mode, statements are committed only when
   <command>EXEC SQL COMMIT</command> is issued. The embedded SQL
   interface also supports autocommit of transactions (similar to
   <application>libpq</> behavior) via the <option>-t</option>
   command-line option to <command>ecpg</command> (see <xref
   linkend="app-ecpg">) or via the <literal>EXEC SQL SET AUTOCOMMIT TO
   ON</literal> statement. In autocommit mode, each command is
   automatically committed unless it is inside an explicit transaction
   block. This mode can be explicitly turned off using <literal>EXEC
   SQL SET AUTOCOMMIT TO OFF</literal>.
  </para>
-->
<para>
   在缺省模式下，语句只有在<command>EXEC SQL COMMIT</command>
   发出的时候才提交，
   嵌入的SQL接口也支持事务的自动提交（类似<application>libpq</>的行为），
   方法是通过给<command>ecpg</command>（见<xref linkend="app-ecpg">）
   增加命令行选项<option>-t</option>，
   或者是通过<literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>语句。
   在自动提交模式里，每条命令都是自动提交的，
   除非它们包围在一个明确的事务块里。 
   这个模式可以用<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>明确地关闭。
</para>

   
<para>
    <!--
    The following transaction management commands are available:
    -->
有以下事务管理命令可用：
    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
    <!--
        Commit an in-progress transaction.
-->
提交正在进行的事务。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <!--
<para>
        Roll back an in-progress transaction.
       </para>
-->
<para>
      回滚正在进行的事务。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <!--
<para>
        Enable autocommit mode.
       </para>
-->
<para>
      启动自动提交模式。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <!--
<para>
        Disable autocommit mode.  This is the default.
       </para>
-->
<para>
     禁用自动提交模式。这是缺省的。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-prepared">
  <!--
   <title>Prepared Statements</title>
   -->
   <title>预备语句</title>

   <!--
<para>
    When the values to be passed to an SQL statement are not known at
    compile time, or the same statement is going to be used many
    times, then prepared statements can be useful.
   </para>
-->
<para>
    当编译时间不知道该值已被传递给SQL语句，或者同一语句将使用多次，
那么预备语句是有帮助的。
</para>

   
<para>
    <!--
    The statement is prepared using the
    command <literal>PREPARE</literal>.  For the values that are not
    known yet, use the
    placeholder <quote><literal>?</literal></quote>:
-->
使用命令<literal>PREPARE</literal>准备语句。对于不知道的值，
使用占位符<quote><literal>?</literal></quote>:

<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>


   
<para>
   <!--
    If a statement returns a single row, the application can
    call <literal>EXECUTE</literal> after
    <literal>PREPARE</literal> to execute the statement, supplying the
    actual values for the placeholders with a <literal>USING</literal>
    clause:
-->
如果一个语句返回单行，应用程序可以在<literal>PREPARE</literal>
执行语句之后调用<literal>EXECUTE</literal>，
使用<literal>USING</literal>子句为占位符提供实际值：

<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>


   
<para>
    <!--
    If a statement returns multiple rows, the application can use a
    cursor declared based on the prepared statement.  To bind input
    parameters, the cursor must be opened with
    a <literal>USING</literal> clause:
-->
如果一个语句返回多行，应用程序可以使用基于预备语句声明的游标。
为了结合输入参数，必须使用<literal>USING</literal>子句打开游标：


<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

<!--
/* when end of result set reached, break out of while loop */
-->
/* 当结果集达到最后时，打破while循环 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>

  
<para>
    <!--
    When you don't need the prepared statement anymore, you should
    deallocate it:
-->
当你不再需要预备语句的时候，你应该重新分配它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>

   <!--
<para>
    For more details about <literal>PREPARE</literal>,
    see <xref linkend="ecpg-sql-prepare">. Also
    see <xref linkend="ecpg-dynamic"> for more details about using
    placeholders and input parameters.
   </para>
-->
<para>
   为获得关于<literal>PREPARE</literal>的更多详情，
   请参阅<xref linkend="ecpg-sql-prepare">。同时参阅<xref linkend="ecpg-dynamic">
   获得关于占位符和输入参数的更多详情。
</para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
 <!--
  <title>Using Host Variables</title>
 -->
   <title>使用宿主变量</title>

  <!--
<para>
   In <xref linkend="ecpg-commands"> you saw how you can execute SQL
   statements from an embedded SQL program.  Some of those statements
   only used fixed values and did not provide a way to insert
   user-supplied values into statements or have the program process
   the values returned by the query.  Those kinds of statements are
   not really useful in real applications.  This section explains in
   detail how you can pass data between your C program and the
   embedded SQL statements using a simple mechanism called
   <firstterm>host variables</firstterm>. In an embedded SQL program  we
   consider the SQL statements to be <firstterm>guests</firstterm> in the C
   program code which is the <firstterm>host language</firstterm>. Therefore
   the variables of the C program are called <firstterm>host
   variables</firstterm>.
  </para>
-->
<para>
  在<xref linkend="ecpg-commands">
  里你看到了如何从嵌入的SQL程序里执行SQL语句。 
  那些语句有些只使用了固定的数值，
  并没有提供一个插入用户提供的数值到语句中的方法，
  也没有提供让程序访问查询返回的数值的方法。
  这种类型的语句在实际应用中并不是很有用。
  本节详细解释如何在你的C程序和嵌入的SQL语句之间使用
  一种被称作<firstterm>宿主变量</firstterm>的机制传递数据。在嵌入SQL程序中，
  我们将SQL语句认为是<firstterm>宿主语言</firstterm>C程序编码的<firstterm>客人</firstterm>。
  因此C程序变量称为<firstterm>宿主变量</firstterm>。 
</para>

  <!--
<para>
   Another way to exchange values between PostgreSQL backends and ECPG
   applications is the use of SQL descriptors, described
   in <xref linkend="ecpg-descriptors">.
  </para>
-->
<para>
   在PostgreSQL后端和ECPG应用程序之间改变值的另一种方式是使用SQL描述符，
   参见<xref linkend="ecpg-descriptors">中的描述。
</para>

  <sect2 id="ecpg-variables-overview">
  <!--
   <title>Overview</title>
   -->
      <title>概述</title>

   
<para>
    <!--
    Passing data between the C program and the SQL statements is
    particularly simple in embedded SQL.  Instead of having the
    program paste the data into the statement, which entails various
    complications, such as properly quoting the value, you can simply
    write the name of a C variable into the SQL statement, prefixed by
    a colon.  For example:
-->
在C程序和SQL语句之间传递数据在嵌入的 SQL 里是特别简单的。
我们不用把数据粘贴到语句中，这样必然会有各种复杂事情需要处理，
比如正确地给数值加引号等等，我们只需要在SQL语句里写上C变量的名字，
前缀一个冒号即可。比如：
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    
<!--
    This statements refers to two C variables named
    <varname>v1</varname> and <varname>v2</varname> and also uses a
    regular SQL string literal, to illustrate that you are not
    restricted to use one kind of data or the other.
-->
这个语句引用了两个变量,一个叫<varname>v1</varname>，另一个叫<varname>v2</varname>，
并且也使用一个普通的SQL字串文本，这样表明你并不局限于只使用某一种数据或者其他。
   </para>
   <!--
<para>
    This style of inserting C variables in SQL statements works
    anywhere a value expression is expected in an SQL statement.
   </para>
-->
<para>
   这种在SQL语句里插入C变量的方式在SQL语句里任何需要表达式的地方都可用。
</para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
  <!--
   <title>Declare Sections</title>
  -->
   <title>声明段</title>
   <!--
<para>
    To pass data from the program to the database, for example as
    parameters in a query, or to pass data from the database back to
    the program, the C variables that are intended to contain this
    data need to be declared in specially marked sections, so the
    embedded SQL preprocessor is made aware of them.
   </para>
-->
<para>
   要从程序向数据库传递数据，比如，查询中的参数，
   或者从数据库里向程序传回的数据，想包含这类数据的 
   C变量必须在一个特殊的标记段里面声明，
   这样嵌入的SQL预处理器就会明白要做什么。
</para>

 
<para>
    <!--
    This section starts with:
-->
这个段以下面的代码开头：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>

   <!--
    and ends with:
   -->
以下面的代码结束:
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    <!--
    Between those lines, there must be normal C variable declarations,
    such as:
-->
在这些行之间，有普通的C变量声明，比如：
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>

    <!--
    As you can see, you can optionally assign an initial value to the variable.
    The variable's scope is determined by the location of its declaring
    section within the program.
    You can also declare variables with the following syntax which implicitly
    creates a declare section:
-->
正如你所看到的，你可以随意指定一个初始值给变量。
变量的范围是在程序中通过其声明部分的位置确定。
你也可以用下面的语法，隐式地创建一个声明段声明变量：

<programlisting>
EXEC SQL int i = 4;
</programlisting>
    <!--
    You can have as many declare sections in a program as you like.
-->
在程序里你可以有任意多个声明段。
   </para>

   <!--
<para>
    The declarations are also echoed to the output file as normal C
    variables, so there's no need to declare them again.  Variables
    that are not intended to be used in SQL commands can be declared
    normally outside these special sections.
   </para>
-->
<para>
    这些声明也同时以普通C变量的形式回显到输出文件中，
因此，我们不必再声明他们。
那些不准备在SQL命令里使用的变量通常可以在这些特殊的段外面声明。
</para>

   <!--
<para>
    The definition of a structure or union also must be listed inside
    a <literal>DECLARE</> section. Otherwise the preprocessor cannot
    handle these types since it does not know the definition.
   </para>
-->
<para>
   结构或者联合的定义也必须在<literal>DECLARE</>段中列出。 
   否则，预处理器就无法处理这些类型，因为它不知道定义。 
</para>
  </sect2>

  <sect2 id="ecpg-retrieving">
    <!--
   <title>Retrieving Query Results</title>
    -->
<title>检索查询结果</title>
   <!--
<para>
    Now you should be able to pass data generated by your program into
    an SQL command.  But how do you retrieve the results of a query?
    For that purpose, embedded SQL provides special variants of the
    usual commands <command>SELECT</command> and
    <command>FETCH</command>.  These commands have a special
    <literal>INTO</literal> clause that specifies which host variables
    the retrieved values are to be stored in.
    <command>SELECT</command> is used for a query that returns only
    single row, and <command>FETCH</command> is used for a query that
    returns multiple rows, using a cursor.
   </para>
-->
<para>
    现在你应该能把你的程序生成的数据传递到SQL命令里面去了。
但是你如何检索一个查询的结果呢？为了这个目的，
嵌入的SQL提供了常用命令<command>SELECT</command>和
    <command>FETCH</command>的特殊变体。
这些命令有了特殊的<literal>INTO</literal>子句，
声明检索出来的数值存储在哪个宿主变量里。
<command>SELECT</command>用于返回单行的查询，同时<command>FETCH</command>
用于使用游标返回多行的查询。
</para>

   
<para>
    <!--
    Here is an example:
-->
下面是一个例子：
<programlisting>

<!--
/*
 * assume this table:
 * CREATE TABLE test1 (a int, b varchar(50));
 */
-->

/*
 * 假设表是这个:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
   
    <!--
    So the <literal>INTO</literal> clause appears between the select
    list and the <literal>FROM</literal> clause.  The number of
    elements in the select list and the list after
    <literal>INTO</literal> (also called the target list) must be
    equal.
-->
所以<literal>INTO</literal>子句出现在选择列表和<literal>FROM</literal>子句之间。
选择列表和<literal>INTO</literal>后面的列表的元素
（也叫目标列表）个数必须相同。

   </para>
   
<para>
    <!--
    Here is an example using the command <command>FETCH</command>:
-->
下面是使用<command>FETCH</command>命令的例子： 

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    <!--
    Here the <literal>INTO</literal> clause appears after all the
    normal clauses.
-->
这里的<literal>INTO</literal>子句出现在所有正常的子句后面。
   </para>

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
  <!--
   <title>Type Mapping</title>
   -->
   <title>类型映射</title>

   <!--
<para>
    When ECPG applications exchange values between the PostgreSQL
    server and the C application, such as when retrieving query
    results from the server or executing SQL statements with input
    parameters, the values need to be converted between PostgreSQL
    data types and host language variable types (C language data
    types, concretely).  One of the main points of ECPG is that it
    takes care of this automatically in most cases.
   </para>
-->
<para>
   当ECPG应用程序改变PostgreSQL服务器和C应用程序之间的值的时候，
   比如检索来自服务器的查询结果或者执行带有输入参数的SQL语句，
在PostgreSQL数据类型和宿主语言变量类型（具体地C语言数据
类型）之间需要改变值。ECPG的一个主要点之一是
在大多数情况下自动的关注这个。
</para>

   <!--
<para>
    In this respect, there are two kinds of data types: Some simple
    PostgreSQL data types, such as <type>integer</type>
    and <type>text</type>, can be read and written by the application
    directly.  Other PostgreSQL data types, such
    as <type>timestamp</type> and <type>numeric</type> can only be
    accessed through special library functions; see
    <xref linkend="ecpg-special-types">.
   </para>
-->
<para>
   在这方面，有两种数据类型：一些简单的
PostgreSQL数据类型，如<type>integer</type>和<type>text</type>，
可以直接通过应用程序读取和写入。
其他PostgreSQL数据类型，如
<type>timestamp</type>和<type>numeric</type>只能
通过特殊库函数进行访问；参阅<xref linkend="ecpg-special-types">。
</para>

   <!--
<para>
    <xref linkend="ecpg-datatype-hostvars-table"> shows which PostgreSQL
    data types correspond to which C data types.  When you wish to
    send or receive a value of a given PostgreSQL data type, you
    should declare a C variable of the corresponding C data type in
    the declare section.
   </para>
-->
<para>
   <xref linkend="ecpg-datatype-hostvars-table">显示了哪个PostgreSQL
数据类型对应哪个C数据类型。当你希望
发送或接收一个给定PostgreSQL数据类型的值时，你应该
在声明部分声明一个对应C数据类型的C变量。
</para>

   <table id="ecpg-datatype-hostvars-table">
   <!--
    <title>Mapping Between PostgreSQL Data Types and C Variable Types</title>
-->
<title>PostgreSQL数据类型和C变量类型之间的映射</title>
    <tgroup cols="2">
     <thead>
      <row>
  <!--
       <entry>PostgreSQL data type</entry>
       <entry>Host variable type</entry>
   -->
    <entry>PostgreSQL数据类型</entry>
       <entry>宿主变量类型</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><!--
<para>This type can only be accessed through special library functions; see <xref linkend="ecpg-special-types">.</para>
-->
<para>
   这种类型可以通过特殊库函数访问；参阅<xref linkend="ecpg-special-types">。
</para></footnote></entry>
      </row>

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><!--
<para>declared in <filename>ecpglib.h</filename></para>
-->
<para>
 在<filename>ecpglib.h</filename>中声明
</para></footnote></entry>
      </row>

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><!--
<para>declared in <filename>ecpglib.h</filename> if not native</para>
-->
<para>
   如果不是本地的，在<filename>ecpglib.h</filename>中声明
</para></footnote></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
   <!--
    <title>Handling Character Strings</title>
   -->
    <title>处理字符串</title>


    <!--
<para>
     To handle SQL character string data types, such
     as <type>varchar</type> and <type>text</type>, there are two
     possible ways to declare the host variables.
    </para>
-->
<para>
   为了处理SQL字符串数据类型，比如<type>varchar</type>和<type>text</type>，
   有两种可能方式声明宿主变量。
</para>

    
<para>
     <!--
     One way is using <type>char[]</type>, an array
     of <type>char</type>, which is the most common way to handle
     character data in C.
 -->
 一种方式是使用<type>char[]</type>，<type>char</type>数组是在C中处理字符数据
 最常见方式。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     <!--
     Note that you have to take care of the length yourself.  If you
     use this host variable as the target variable of a query which
     returns a string with more than 49 characters, a buffer overflow
     occurs.
 -->
 请注意，你必须关注自身长度。
 如果你使用这个宿主变量
 作为查询返回一个具有多于49个字符的字符串的目标变量，
 那么发生缓冲区溢出。
    </para>

    
<para> 
    <!--
     The other way is using the <type>VARCHAR</type> type, which is a
     special type provided by ECPG.  The definition on an array of
     type <type>VARCHAR</type> is converted into a
     named <type>struct</> for every variable. A declaration like:
 -->
 另一种方法是使用<type>VARCHAR</type>类型，这是一个由ECPG提供的
特殊类型。<type>VARCHAR</type>类型的数组定义被转换为
每个变量的命名<type>结构</>。声明如：

<programlisting>
VARCHAR var[180];
</programlisting>
     <!--
     is converted into:
 -->
 转换成：
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
    <!--
     The member <structfield>arr</structfield> hosts the string
     including a terminating zero byte.  Thus, to store a string in
     a <type>VARCHAR</type> host variable, the host variable has to be
     declared with the length including the zero byte terminator.  The
     member <structfield>len</structfield> holds the length of the
     string stored in the <structfield>arr</structfield> without the
     terminating zero byte.  When a host variable is used as input for
     a query, if <literal>strlen(arr)</literal>
     and <structfield>len</structfield> are different, the shorter one
     is used.
 -->
 <structfield>arr</structfield>有一个终止零字节的字符串。

 因此，为了在<type>VARCHAR</type>宿主变量中存储字符串，
     宿主变量必须声明为包含零字节终结符的长度。
 <structfield>len</structfield>持有
 存储在<structfield>arr</structfield>中而没有
终止零字节的字符串长度。当一个宿主变量作为一个查询输入时
，如果<literal>strlen(arr)</literal>
和<structfield>len</structfield>是不同的，那么使用稍短的。
 
    </para>
    <!--
<para>
     <type>VARCHAR</type> can be written in upper or lower case, but
     not in mixed case.
    </para>
-->
<para>
  <type>VARCHAR</type>可以使用大写或小写，但是在不混淆的情况下。
</para>

    <!--
<para>
     <type>char</type> and <type>VARCHAR</type> host variables can
     also hold values of other SQL types, which will be stored in
     their string forms.
    </para>
-->
<para>
    <type>char</type>和<type>VARCHAR</type>宿主变量可以持有其它SQL类型的值，
这将被存储在它们的字符串形式中。
</para>
   </sect3>

   <sect3 id="ecpg-special-types">
   <!--
    <title>Accessing Special Data Types</title>
-->
<title>访问特定数据类型</title>

    <!--
<para>
     ECPG contains some special types that help you to interact easily
     with some special data types from the PostgreSQL server. In
     particular, it has implemented support for the
     <type>numeric</>, <type>decimal</type>, <type>date</>, <type>timestamp</>,
     and <type>interval</> types.  These data types cannot usefully be
     mapped to primitive host variable types (such
     as <type>int</>, <type>long long int</type>,
     or <type>char[]</type>), because they have a complex internal
     structure.  Applications deal with these types by declaring host
     variables in special types and accessing them using functions in
     the pgtypes library.  The pgtypes library, described in detail
     in <xref linkend="ecpg-pgtypes"> contains basic functions to deal
     with those types, such that you do not need to send a query to
     the SQL server just for adding an interval to a time stamp for
     example.
    </para>
-->
<para>
    ECPG含有一些特定类型帮助你
与来自PostgreSQL服务器的一些特殊数据类型进行轻松互动。
特别是，它已经实现支持<type>numeric</>, <type>decimal</type>, <type>date</>, 
<type>timestamp</>和<type>interval</>类型。
这些数据类型不能有效地映射到原始主机变量类型（例如
<type>int</>, <type>long long int</type>或者<type>char[]</type>），
因为他们有一个复杂的内部结构。
应用程序通过声明特殊类型的主机变量处理这些类型，并且在pgtypes库中使用函数访问他们。
该pgtypes库包含处理这些类型的基本函数的
详细描述参阅<xref linkend="ecpg-pgtypes">，
这样你就不需要发送一个查询到SQL服务器，仅仅为了添加间隔时间戳例子。
</para>

    <!--
<para>
     The follow subsections describe these special data types. For
     more details about pgtypes library functions,
     see <xref linkend="ecpg-pgtypes">.
    </para>
-->
<para>
   以下小节描述了这些特殊数据类型。为了获得关于pgtypes库函数的更多细节，
   参阅<xref linkend="ecpg-pgtypes">。
</para>

    <sect4>

     <title id="ecpg-type-timestamp-date">timestamp, date</title>

     <!--
<para>
      Here is a pattern for handling <type>timestamp</type> variables
      in the ECPG host application.
     </para>
-->
<para>
   这是在ECPG宿主应用程序中处理<type>timestamp</type>变量的模式。
</para>

     
<para>
      <!--
      First, the program has to include the header file for the
      <type>timestamp</type> type:
  -->
  首先，程序必须包含<type>timestamp</type>类型的头文件：
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>

    
<para>
       <!--
      Next, declare a host variable as type <type>timestamp</type> in
      the declare section:
  -->
  接下来，在声明部分声明作为类型<type>timestamp</type>的宿主变量：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>


     
<para>
     <!--
      And after reading a value into the host variable, process it
      using pgtypes library functions. In following example, the
      <type>timestamp</type> value is converted into text (ASCII) form
      with the <function>PGTYPEStimestamp_to_asc()</function>
      function:
 -->
 并且读取值到宿主变量之后，
使用pgtypes库函数处理它。在下面的例子中，
使用<function>PGTYPEStimestamp_to_asc()</function>函数该
<type>timestamp</type>值转换成文本（ASCII）形式：

<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      <!--
      This example will show some result like following:
  -->
  这个例子将显示如下一些结果：
  
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>


     <!--
<para>
      In addition, the DATE type can be handled in the same way. The
      program has to include <filename>pgtypes_date.h</filename>, declare a host variable
      as the date type and convert a DATE value into a text form using
      <function>PGTYPESdate_to_asc()</function> function. For more details about the
      pgtypes library functions, see <xref linkend="ecpg-pgtypes">.
     </para>
-->
<para>
    此外，日期类型可以用同样的方式处理。
程序必须包括<filename>pgtypes_date.h</filename>，
作为日期类型声明一个宿主变量并且使用
<function>PGTYPESdate_to_asc()</function>函数转换日期值为文本形式。
关于pgtypes库函数的更多详情，请参阅<xref linkend="ecpg-pgtypes">。
</para>
    </sect4>

    <sect4 id="ecpg-type-interval">
     <title>interval</title>

     <!--
<para>
      The handling of the <type>interval</type> type is also similar
      to the <type>timestamp</type> and <type>date</type> types.  It
      is required, however, to allocate memory for
      an <type>interval</type> type value explicitly.  In other words,
      the memory space for the variable has to be allocated in the
      heap memory, not in the stack memory.
     </para>
-->
<para>
   <type>interval</type>类型
   的处理也与<type>timestamp</type>和<type>date</type>
   类型类似。然而，为了<type>interval</type>类型值显式分配内存是必需的。换句话说，
该变量的存储空间在堆内存中被分配，而不是在堆栈存储器中。
</para>

     
<para>
    <!--
      Here is an example program:
-->
 下面是一个示例程序：
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>

    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
     <title>numeric, decimal</title>

     <!--
<para>
      The handling of the <type>numeric</type>
      and <type>decimal</type> types is similar to the
      <type>interval</type> type: It requires defining a pointer,
      allocating some memory space on the heap, and accessing the
      variable using the pgtypes library functions.  For more details
      about the pgtypes library functions,
      see <xref linkend="ecpg-pgtypes">.
     </para>
-->
<para>
    <type>numeric</type>和<type>decimal</type>类型的处理类似于
<type>interval</type>类型：它需要定义一个指针，
在堆上分配一些内存空间，并且使用pgtypes库函数访问
变量。关于pgtypes库函数的更多细节，参阅<xref linkend="ecpg-pgtypes">。
</para>

     <!--
<para>
      No functions are provided specifically for
      the <type>decimal</type> type.  An application has to convert it
      to a <type>numeric</type> variable using a pgtypes library
      function to do further processing.
     </para>
-->
<para>
    对于<type>decimal</type>类型没有提供专门的函数。
    应用程序使用pgtypes库函数做进一步的处理
将其转换成<type>numeric</type>变量。
</para>

     
<para>
      <!--
      Here is an example program handling <type>numeric</type>
      and <type>decimal</type> type variables.
  -->
  这里有一个处理<type>numeric</type>和<type>decimal</type>类型变量的示例程序。
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    <!--
    /* Convert decimal to numeric to show a decimal value. */
-->
/*转换十进制到数值型以显示十进制值*/
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>

    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
   <!--
    <title>Host Variables with Nonprimitive Types</title>
   -->
   <title>使用非初级类型的宿主变量</title>

    <!--
<para>
     As a host variable you can also use arrays, typedefs, structs, and
     pointers.
    </para>
-->
<para>
    作为一个宿主变量你也可以使用数组，typedefs，结构和指针。
</para>

    <sect4 id="ecpg-variables-arrays">
     <title>Arrays</title>

     <!--
<para>
      There are two use cases for arrays as host variables.  The first
      is a way to store some text string in <type>char[]</type>
      or <type>VARCHAR[]</type>, as
      explained <xref linkend="ecpg-char">.  The second use case is to
      retrieve multiple rows from a query result without using a
      cursor.  Without an array, to process a query result consisting
      of multiple rows, it is required to use a cursor and
      the <command>FETCH</command> command.  But with array host
      variables, multiple rows can be received at once.  The length of
      the array has to be defined to be able to accommodate all rows,
      otherwise a buffer overflow will likely occur.
     </para>
-->
<para>
     有两个作为宿主变量的数组用例。
 最先的一种方式是在<type>char[]</type>
     或者<type>VARCHAR[]</type>中存储一些文本字符串，
 正如<xref linkend="ecpg-char">解释的。
 第二个用例是不使用游标从查询结果检索多行。
 没有一个数组处理包括多行的一个查询结果，
 它需要使用一个游标和<command>FETCH</command>命令。
 但使用数组宿主变量，一次可以检索多行。
 数组长度被定义为能够容纳所有行，否则可能会发生缓冲区溢出。
</para>

     
<para>
     <!--
      Following example scans the <literal>pg_database</literal>
      system table and shows all OIDs and names of the available
      databases:
  -->
  下面的示例扫描<literal>pg_database</literal>
  系统表并且显示所有OID和可用数据库的名字：

<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    <!--
    /* Retrieve multiple rows into arrays at once. */
-->
/*同时检索多行到数组中*/
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
    <!--
    This example shows following result. (The exact values depend on
    local circumstances.)
-->
这个例子显示了如下结果。（精确值取决于区域环境）
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>

     </para>

    </sect4>

    <sect4 id="ecpg-variables-struct">
<!--
     <title>Structures</title>
-->
 <title>结构</title>

     <!--
<para>
      A structure whose member names match the column names of a query
      result, can be used to retrieve multiple columns at once.  The
      structure enables handling multiple column values in a single
      host variable.
     </para>
-->
<para>
    一个成员名称匹配查询结果列名称的结构，
可用于一次检索多个列。该结构可以在单一的宿主变量中处理多个列的值。
</para>

     
<para>
     <!--
      The following example retrieves OIDs, names, and sizes of the
      available databases from the <literal>pg_database</literal>
      system table and using
      the <function>pg_database_size()</function> function.  In this
      example, a structure variable <varname>dbinfo_t</varname> with
      members whose names match each column in
      the <literal>SELECT</literal> result is used to retrieve one
      result row without putting multiple host variables in
      the <literal>FETCH</literal> statement.
-->
下面的示例检索OID，名称，和
来自<literal>pg_database</literal>
系统表可用数据库的大小，并且使用
<function>pg_database_size()</function>函数。在这个例子中，
一个结构变量<varname>dbinfo_t</varname>和
名称匹配<literal>SELECT</literal>结果的每一列的成员是用来检索一个
结果行，而没有把多个宿主变量放在<literal>FETCH</literal>声明中。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;
    
<!--
    /* when end of result set reached, break out of while loop */
-->
/*当结果集到达末尾时，打破while循环*/
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
    <!--
        /* Fetch multiple columns into one structure. */
-->
/*抓取多列到一个结构中*/
        EXEC SQL FETCH FROM cur1 INTO :dbval;

<!--
        /* Print members of the structure. */
-->
/*打印结构成员*/
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>

     
<para>
     <!--
      This example shows following result. (The exact values depend on
      local circumstances.)
 -->
  这个例子显示了下面结果。（精确值取决于区域环境）
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>

     
<para>
     <!--
      Structure host variables <quote>absorb</quote> as many columns
      as the structure as fields.  Additional columns can be assigned
      to other host variables. For example, the above program could
      also be restructured like this, with the <varname>size</varname>
      variable outside the structure:
 -->
 
  结构宿主变量<quote>合并</quote>和结构一样的许多列
作为结构域。附加的列可以被分配
给其他宿主变量。例如，上述程序可能
也会像这样被重组，使用外部结构<varname>size</varname>变量。
  
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;
    <!--
    /* when end of result set reached, break out of while loop */
-->
    /*当结果集到达末尾时，打破while循环*/
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
    <!--
        /* Fetch multiple columns into one structure. */
-->

/*抓取多列到一个结构中*/
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;
 
        <!--
        /* Print members of the structure. */
-->
/*打印结构成员*/ 
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>

    </sect4>

    <sect4>
     <title>Typedefs</title>

     
<para>
    <!--
      Use the <literal>typedef</literal> keyword to map new types to already
      existing types.
-->
 使用<literal>typedef</literal>关键字映射新类型到已有类型。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      <!--
      Note that you could also use:
  -->
  注意，你也可以使用：
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      <!--
      This declaration does not need to be part of a declare section.
  -->
  这种声明并不需要声明部分。
     </para>
    </sect4>

    <sect4>
<!--
     <title>Pointers</title>
 -->
 <title>指针</title>

     <!--
<para>
      You can declare pointers to the most common types. Note however
      that you cannot use pointers as target variables of queries
      without auto-allocation. See <xref linkend="ecpg-descriptors">
      for more information on auto-allocation.
     </para>
-->
<para>
     你可以声明最常见类型的指针。
 然而注意你不能作为没有自动分配的查询目标变量
 而使用指针。参阅<xref linkend="ecpg-descriptors">获取更多自动配置的信息。
</para>

    
<para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>

 
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
  <!--
   <title>Handling Nonprimitive SQL Data Types</title>
  -->
    <title>处理非初级的SQL数据类型</title>

   <!--
<para>
    This section contains information on how to handle nonscalar and
    user-defined SQL-level data types in ECPG applications.  Note that
    this is distinct from the handling of host variables of
    nonprimitive types, described in the previous section.
   </para>
-->
<para>
   本节包含了如何处理nonscalar和ECPG应用程序中用户自定义的SQL级别数据类型的相关信息。
   请注意这不同于非初级类型宿主变量的处理，在前面的章节中有描述。
</para>

   <sect3>
   <!--
    <title>Arrays</title>
    -->
<title>数组</title>

    <!--
<para>
     Multi-dimensional SQL-level arrays are not directly supported in ECPG.
     One-dimensional SQL-level arrays can be mapped into C array host
     variables and vice-versa.  However, when creating a statement ecpg does
     not know the types of the columns, so that it cannot check if a C array
     is input into a corresponding SQL-level array.  When processing the
     output of a SQL statement, ecpg has the necessary information and thus
     checks if both are arrays.
    </para>
-->
<para>
ECPG中不直接支持多维SQL级别数组。一维SQL级别数组可以映射成C数组变量，反之亦然。
不过，当创建一个ecpg不知道的字段类型的声明时，
它不能检查一个C数组是否输入到对应的SQL级别数组。当处理SQL语句的输出时，
ecpg有必需的信息并且因此检查两者是否都是数组。
</para>

    <!--
<para>
     If a query accesses <emphasis>elements</emphasis> of an array
     separately, then this avoids the use of arrays in ECPG.  Then, a
     host variable with a type that can be mapped to the element type
     should be used.  For example, if a column type is array of
     <type>integer</type>, a host variable of type <type>int</type>
     can be used.  Also if the element type is <type>varchar</type>
     or <type>text</type>, a host variable of type <type>char[]</type>
     or <type>VARCHAR[]</type> can be used.
    </para>
-->
<para>
    如果查询分别访问数组<emphasis>元素</emphasis>，那么这可以避免在ECPG中使用数组。
然后，应该使用可以映射到元素类型的宿主变量。比如，
如果列类型是<type>integer</type>数组，那么使用<type>int</type>类型宿主变量。
如果元素类型是<type>varchar</type>或者<type>text</type>，
则可以使用<type>char[]</type>或者<type>VARCHAR[]</type>类型宿主变量。
</para>

    
<para>
     <!--
     Here is an example.  Assume the following table:
 -->
 下面是一个例子。假设下列表:
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=> SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

     <!--
     The following example program retrieves the 4th element of the
     array and stores it into a host variable of
     type <type>int</type>:
 -->
 下面示例程序检索了数组的第四个元素，并且将它存储在<type>int</type>类型
 的宿主变量中：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>
     <!--
     This example shows the following result:
 -->
 该例子显示了下面结果：
<screen>
ii=4
</screen>
    </para>


    
<para>
    <!--
     To map multiple array elements to the multiple elements in an
     array type host variables each element of array column and each
     element of the host variable array have to be managed separately,
     for example:
 -->
 为了映射多个数组元素到数组列的数组类型宿主变量每个元素的多个元组，并且
 宿主变量数组的每个元素必须分别被管理，比如：
 
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>


    
<para>
    <!--
     Note again that
-->
 请再次注意
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* WRONG */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
    <!--
     would not work correctly in this case, because you cannot map an
     array type column to an array host variable directly.
 -->
 不会在这种情况下正确工作，因为你不能映射一个数组类型列直接到数组宿主变量。
    </para>

    <!--
<para>
     Another workaround is to store arrays in their external string
     representation in host variables of type <type>char[]</type>
     or <type>VARCHAR[]</type>.  For more details about this
     representation, see <xref linkend="arrays-input">.  Note that
     this means that the array cannot be accessed naturally as an
     array in the host program (without further processing that parses
     the text representation).
    </para>
-->
<para>
    另外一种方法是在<type>char[]</type>
     或者<type>VARCHAR[]</type>类型宿主变量的外部字符串形式中存储数组。
 更多关于该形式的详细信息，请参阅<xref linkend="arrays-input">。
 注意这意味着在主程序（没有对分析文本表示的进一步处理）中数组自然不能作为数组被访问。
</para>
   </sect3>

   <sect3>
   <!--
    <title>Composite Types</title>
   -->
    <title>复合类型</title>

    <!--
<para>
     Composite types are not directly supported in ECPG, but an easy workaround is possible.
  The
     available workarounds are similar to the ones described for
     arrays above: Either access each attribute separately or use the
     external string representation.
    </para>
-->
<para>
    在ECPG中不直接支持复合类型，但是简单解决方法是可能的。
可用的方法与上面数组描述的那个是类似的：
要么分别访问每个属性，要么使用外部字符串表示形式。
</para>

    
<para>
     <!--
     For the following examples, assume the following type and table:
 -->
 下面列子中，假设下面类型和表：
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>
     <!--
     The most obvious solution is to access each attribute separately.
     The following program retrieves data from the example table by
     selecting each attribute of the type <type>comp_t</type>
     separately:
 -->
 最明显的解决方法是分别访问每个属性。下面程序通过分别选择类型<type>comp_t</type>
 的每个属性的示例表中检索数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

<!--
/* Put each element of the composite type column in the SELECT list. */
-->
/*将复合类型列的每个元素放在SELECT列表中*/

EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    <!--
/* Fetch each element of the composite type column into host variables. */
-->
/*抓取复合类型列的每个元素给宿主变量*/
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>


   
<para>
     <!--
     To enhance this example, the host variables to store values in
     the <command>FETCH</command> command can be gathered into one
     structure.  For more details about the host variable in the
     structure form, see <xref linkend="ecpg-variables-struct">.
     To switch to the structure, the example can be modified as below.
     The two host variables, <varname>intval</varname>
     and <varname>textval</varname>, become members of
     the <structname>comp_t</structname> structure, and the structure
     is specified on the <command>FETCH</command> command.
 -->
 为了加强这个例子，在<command>FETCH</command>命令中存储值的宿主变量
 可以收集在一个结构中。
关于结构形式中宿主变量的更多细节，参阅<xref linkend="ecpg-variables-struct">。
为了切换到结构，例子可以做如下修改。
两个宿主变量<varname>intval</varname>和<varname>textval</varname>，
是<structname>comp_t</structname>结构成员，并且在<command>FETCH</command>命令上
指定结构。
 
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

<!--
/* Put each element of the composite type column in the SELECT list. */
-->
/*将复合类型列的每个元素放在SELECT列表中*/

EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    <!--
    /* Put all values in the SELECT list into one structure. */
-->
/*将SELECT列表中所有值放到结构中*/

    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
     <!--
     Although a structure is used in the <command>FETCH</command>
     command, the attribute names in the <command>SELECT</command>
     clause are specified one by one.  This can be enhanced by using
     a <literal>*</literal> to ask for all attributes of the composite
     type value.
 -->
 虽然结构用于<command>FETCH</command>命令，逐一指定<command>SELECT</command>
子句中的属性名，这可以通过使用
<literal>*</literal>请求复合类型值的所有属性获得提高。  

<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    <!--
    /* Put all values in the SELECT list into one structure. */
-->
/*将SELECT列表中的所有值放到结构中*/
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     <!--
     This way, composite types can be mapped into structures almost
     seamlessly, even though ECPG does not understand the composite
     type itself.
 -->
 这种方式，可以无缝的将复合类型映射到结构中，尽管ECPG并不了解该复合类型。
    </para>


    <!--
<para>
     Finally, it is also possible to store composite type values in
     their external string representation in host variables of
     type <type>char[]</type> or <type>VARCHAR[]</type>.  But that
     way, it is not easily possible to access the fields of the value
     from the host program.
    </para>
-->
<para>
    最后，在类型<type>char[]</type>或者<type>VARCHAR[]</type>宿主变量中的外部字符串表示形式中
存储复合类型是可能的。但是那种方式，不容易从主程序中访问值的字段。
</para>
   </sect3>

   <sect3>
   <!--
    <title>User-defined Base Types</title>
     -->
 <title>用户自定义基本类型</title>

    <!--
<para>
     New user-defined base types are not directly supported by ECPG.
     You can use the external string representation and host variables
     of type <type>char[]</type> or <type>VARCHAR[]</type>, and this
     solution is indeed appropriate and sufficient for many types.
    </para>
-->
<para>
    ECPG不直接支持新用户自定义基础类型。你可以使用外部字符串表示形式和
类型<type>char[]</type>或者<type>VARCHAR[]</type>的宿主变量，并且该方法
对于许多类型的确是合适的并且充分的。
</para>

    
<para>
     <!--
     Here is an example using the data type <type>complex</type> from
     the example in <xref linkend="xtypes">.  The external string
     representation of that type is <literal>(%lf,%lf)</literal>,
     which is defined in the
     functions <function>complex_in()</function>
     and <function>complex_out()</function> functions
     in <xref linkend="xtypes">.  The following example inserts the
     complex type values <literal>(1,1)</literal>
     and <literal>(3,3)</literal> into the
     columns <literal>a</literal> and <literal>b</literal>, and select
     them from the table after that.
     -->
 这是一个使用<xref linkend="xtypes">中<type>复合</type>数据类型的例子。
 该类型的外部字符串表示形式是<literal>(%lf,%lf)</literal>，
 定义在<xref linkend="xtypes">中的<function>complex_in()</function>
     和<function>complex_out()</function>函数中。
 下面例子将复合类型值<literal>(1,1)</literal>
     和<literal>(3,3)</literal>插入到列<literal>a</literal>和<literal>b</literal>中，
 并且之后从表中选择它们。
 
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     <!--
     This example shows following result:
 -->
 这个例子显示了如下结果:
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>


    <!--
<para>
     Another workaround is avoiding the direct use of the user-defined
     types in ECPG and instead create a function or cast that converts
     between the user-defined type and a primitive type that ECPG can
     handle.  Note, however, that type casts, especially implicit
     ones, should be introduced into the type system very carefully.
    </para>
-->
<para>
    另一种方法是避免ECPG中用户自定义类型的直接使用，并且创建一个函数或者计算在
用户自定义类型和ECPG处理的原始类型之间的转换。
注意，然而那个类型计算，特别是隐式的那个，应该小心引入类型系统中。
</para>

    
<para>
     <!--
     For example,
 -->
 比如，
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
   <!--
    After this definition, the following
-->
这个定义之后，下面
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    <!--
    has the same effect as
-->
具有相同效果正如
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    </para>

   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
  <!--
   <title>Indicators</title>
  -->
    <title>指示器</title>

   
<para>
    <!--
    The examples above do not handle null values.  In fact, the
    retrieval examples will raise an error if they fetch a null value
    from the database.  To be able to pass null values to the database
    or retrieve null values from the database, you need to append a
    second host variable specification to each host variable that
    contains data.  This second host variable is called the
    <firstterm>indicator</firstterm> and contains a flag that tells
    whether the datum is null, in which case the value of the real
    host variable is ignored.  Here is an example that handles the
    retrieval of null values correctly:
-->
上面的例子不能处理空值。实际上，如果从数据库中抓到一条空值，
那么上面的检索例子会抛出一个错误。
要能够向数据库中传递空值，或者从数据库中检索空值，
你需要给每个包含数据的宿主变量后面附加一个额外的宿主变量。
这第二个宿主变量叫<firstterm>指示器</firstterm>，里面包含一个标志，
告诉我们数据是否为空，如果为空，那么真正的宿主变量的数值就可以忽略。
下面是一个能正确检索空值的例子:

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    <!--
    The indicator variable <varname>val_ind</varname> will be zero if
    the value was not null, and it will be negative if the value was
    null.
-->
如果数值不是空，那么指示器变量<varname>val_ind</varname>将是零，
如果值是空，那么它将是负数。
   </para>

   <!--
<para>
    The indicator has another function: if the indicator value is
    positive, it means that the value is not null, but it was
    truncated when it was stored in the host variable.
   </para>
-->
<para>
    指示器还有另外的一个用途，如果指示器值是正数，
则意味着值不空，但是在数值存储到宿主变量里的时候被截断了。
</para>

   <!--
<para>
    If the argument <literal>-r no_indicator</literal> is passed to
    the preprocessor <command>ecpg</command>, it works in
    <quote>no-indicator</quote> mode. In no-indicator mode, if no
    indicator variable is specified, null values are signaled (on
    input and output) for character string types as empty string and
    for integer types as the lowest possible value for type (for
    example, <symbol>INT_MIN</symbol> for <type>int</type>).
   </para>
-->
<para>
    如果参数<literal>-r no_indicator</literal>被传递给预处理器<command>ecpg</command>，
那么它在<quote>no-indicator</quote>模式下工作。在非指示器模式下，
如果没有声明可用指示器，那么为了将字符串类型作为空字符串以及
整数类型作为类型的最小可能值（比如，<type>int</type>最小为<symbol>INT_MIN</symbol>），则使用空值（在输入和输出上）。
</para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
 <!--
  <title>Dynamic SQL</title>
 -->
    <title>动态SQL</title>

  <!--
<para>
   In many cases, the particular SQL statements that an application
   has to execute are known at the time the application is written.
   In some cases, however, the SQL statements are composed at run time
   or provided by an external source.  In these cases you cannot embed
   the SQL statements directly into the C source code, but there is a
   facility that allows you to call arbitrary SQL statements that you
   provide in a string variable.
  </para>
-->
<para>
   在许多情况下，应用要执行的具体的SQL语句在书写应用的时候就已经知道了。
   不过，在某些情况下，SQL语句是在运行时或者由外部的数据提供的。
   在这种情况下，我们不能直接在C代码嵌入SQL语句，
   但是有个机制可以允许你调用放在一个字串变量里的任何SQL语句。
   
</para>

  <sect2 id="ecpg-dynamic-without-result">
  <!--
   <title>Executing Statements without a Result Set</title>
  -->
   <title>执行没有结果集的语句</title> 

   
<para>
    <!--
    The simplest way to execute an arbitrary SQL statement is to use
    the command <command>EXECUTE IMMEDIATE</command>.  For example:
-->
执行任意SQL语句最简单的方法是使用<command>EXECUTE IMMEDIATE</command>命令。
比如:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <!--
<command>EXECUTE IMMEDIATE</command> can be used for SQL
    statements that do not return a result set (e.g.,
    DDL, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>).  You cannot execute statements that
    retrieve data (e.g., <command>SELECT</command>) this way.  The
    next section describes how to do that.
-->
 <command>EXECUTE IMMEDIATE</command>可以用于不返回结果集
 （比如，DDL, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>）的SQL语句。
你不能用这种方式执行检索数据（比如<command>SELECT</command>）的语句。
下一节将描述该如何做。
   </para>

  </sect2>

  <sect2 id="ecpg-dynamic-input">
  <!--
   <title>Executing a Statement with Input Parameters</title>
  -->
    <title>执行具有输入参数的语句</title>

   
<para>
    <!--
    A more powerful way to execute arbitrary SQL statements is to
    prepare them once and execute the prepared statement as often as
    you like.  It is also possible to prepare a generalized version of
    a statement and then execute specific versions of it by
    substituting parameters.  When preparing the statement, write
    question marks where you want to substitute parameters later.  For
    example:
-->
执行任意SQL语句的更强大的方法是准备这些语句一次，
并且执行这些准备好的语句任意多次。
我们也可以准备一个普遍的语句版本，然后通过替换一些参数，
执行一个特定的版本。在准备语句的时候，
在你稍后需要替换参数的地方书写一个问号。比如：

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>

   
<para>
    <!--
    When you don't need the prepared statement anymore, you should
    deallocate it:
-->
当你不再需要预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>

  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
  <!--
   <title>Executing a Statement with a Result Set</title>
  -->
   <title>执行带有结果集的语句</title>

   
<para>
    <!--
    To execute an SQL statement with a single result row,
    <command>EXECUTE</command> can be used.  To save the result, add
    an <literal>INTO</literal> clause.
-->
为了执行具有单独结果集的SQL语句，可以使用<command>EXECUTE</command>。
为了保存结果，增加<literal>INTO</literal>子句。

<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    <!--
    An <command>EXECUTE</command> command can have an
    <literal>INTO</literal> clause, a <literal>USING</literal> clause,
    both, or neither.
-->
一个<command>EXECUTE</command>命令可以有一个<literal>INTO</literal>子句，
一个<literal>USING</literal>子句，也可以两个都有或者两个都没有。
   </para>

   
<para>
   <!--
    If a query is expected to return more than one result row, a
    cursor should be used, as in the following example.
    (See <xref linkend="ecpg-cursors"> for more details about the
    cursor.)
-->
如果查询希望返回多个结果行，那么使用游标，正如下面例子。
参阅<xref linkend="ecpg-cursors">获取更多关于游标的信息。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>

  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
 <!--
  <title>pgtypes Library</title>
 -->
  <title>pgtypes 库</title>

  
<para>
  <!--
   The pgtypes library maps <productname>PostgreSQL</productname> database
   types to C equivalents that can be used in C programs. It also offers
   functions to do basic calculations with those types within C, i.e., without
   the help of the <productname>PostgreSQL</productname> server. See the
   following example:
  -->
  Pgtypes库映射<productname>PostgreSQL</productname>数据库类型到C等值，
  它可用于C程序。没有<productname>PostgreSQL</productname>服务器的帮助下，
  它也提供一些函数在C中用这些类型做基本的运算。
  请看下面的例子：
  
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting>
  </para>


  <sect2 id="ecpg-pgtypes-numeric">
  <!--
   <title>The numeric Type</title>
   -->
   <title>数值类型</title>
   <!--
<para>
    The numeric type offers to do calculations with arbitrary precision. See
    <xref linkend="datatype-numeric"> for the equivalent type in the
    <productname>PostgreSQL</> server. Because of the arbitrary precision this
    variable needs to be able to expand and shrink dynamically. That's why you
    can only create numeric variables on the heap, by means of the
    <function>PGTYPESnumeric_new</> and <function>PGTYPESnumeric_free</>
    functions. The decimal type, which is similar but limited in precision,
    can be created on the stack as well as on the heap.
   </para>
-->
<para>
   数值类型提供任意精度的计算。
   参见<xref linkend="datatype-numeric">
   获取<productname>PostgreSQL</>服务器等价类型。
   由于任意精度这一变量需要能够扩展和动态收缩。
   那就是你只能在堆上创建数值变量的原因，
   通过<function>PGTYPESnumeric_new</>和<function>PGTYPESnumeric_free</>函数。
   和十进制类型类似但精确度有限，可以在栈中创建也可以在堆上创建。
</para>
   
<para>
   <!--
   The following functions can be used to work with the numeric type:
   -->
   下列函数用于处理数值类型：
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
  <!--
      Request a pointer to a newly allocated numeric variable.
  -->
  请求一个新分配的数值变量的指针。
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      
<para>
     <!--
      Free a numeric type, release all of its memory.
 --> 
 任意数值类型释放所有内存。
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>


     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      
<para>
      <!--
       Parse a numeric type from its string notation.
   -->
   从字符串标号解析数值类型。
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       <!--
       Valid formats are for example:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
       If the value could be parsed successfully, a valid pointer is returned,
       else the NULL pointer. At the moment ECPG always parses the complete
       string and so it currently does not support to store the address of the
       first invalid character in <literal>*endptr</literal>. You can safely
       set <literal>endptr</literal> to NULL.
   -->
   有效格式比如：<literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal>或者
        <literal>-32.84e-4</literal>。
   如果值解析不成功，返回一个有效指针，否则空指针。
   此刻ECPG总是解析完整的字符串，
   所以目前不支持存储在<literal>*endptr</literal>第一无效字符的地址。
   你可以安全地设置<literal>endptr</literal>为空。
   
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      
<para>
      <!--
       Returns a pointer to a string allocated by <function>malloc</function> that contains the string
       representation of the numeric type <literal>num</literal>.
  -->
  返回一个指向字符串的指针，
  该字符串是通过<function>malloc</function>包
  含数值类型<literal>num</literal>的字符串表示形式分配的。
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       <!--
       The numeric value will be printed with <literal>dscale</literal> decimal
       digits, with rounding applied if necessary.
   -->
   如果必要的话，数值类型的值将带有<literal>dscale</literal>小数位数舍入。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      
<para>
      <!--
       Add two numeric variables into a third one.
   -->
   添加两个数值变量到三分之一。
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       <!--
       The function adds the variables <literal>var1</literal> and
       <literal>var2</literal> into the result variable
       <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
   -->
   函数添加变量<literal>var1</literal>和
       <literal>var2</literal>到结果变量<literal>result</literal>中。
   函数成功时返回0，错误情况下返回-1。
      </para>


     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      
<para>
      <!--
       Subtract two numeric variables and return the result in a third one.
   -->
   减去两个数值变量并且返回三分之一结果。
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       <!--
       The function subtracts the variable <literal>var2</literal> from
       the variable <literal>var1</literal>. The result of the operation is
       stored in the variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
   -->
   
   函数从变量<literal>var1</literal>中减去变量<literal>var2</literal>。
   操作的结果被存储在变量<literal>result</literal>中。
   函数成功时返回0，并且错误的情况下返回-1。
   
      </para>


     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      
<para>
      <!--
       Multiply two numeric variables and return the result in a third one.
  -->
  两个数值变量相乘，并且返回三分之一结果。
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       <!--
       The function multiplies the variables <literal>var1</literal> and
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
   -->
   函数将变量<literal>var1</literal>和
       <literal>var2</literal>相乘。操作的结果被存储在变量<literal>result</literal>中。
   函数成功时返回0，并且错误的情况下返回-1。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      
<para>
      <!--
       Divide two numeric variables and return the result in a third one.
  -->
  两个数值变量相除并且返回三分之一结果。
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       <!--
       The function divides the variables <literal>var1</literal> by
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
   -->
   函数将变量<literal>var1</literal>除以变量<literal>var2</literal>。
   操作的结果被存储在变量<literal>result</literal>中。
   函数成功时返回0并且错误的情况下返回-1。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      
<para>
      <!--
       Compare two numeric variables.
  -->
  比较两个数值变量。
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
      <!--
       This function compares two numeric variables. In case of error,
       <literal>INT_MAX</literal> is returned. On success, the function
       returns one of three possible results:
   -->
   这个函数比较两个数值变量。在错误的情况下，返回<literal>INT_MAX</literal>。
   成功，函数返回三个可能结果之一：
       <itemizedlist>
        <listitem>
         <para>
  <!--
          1, if <literal>var1</> is bigger than <literal>var2</>
  -->
  如果<literal>var1</>大于<literal>var2</>,则返回1。
         </para>

        </listitem>
        <listitem>
         <!--
<para>
          -1, if <literal>var1</> is smaller than <literal>var2</>
         </para>
-->
<para>
   如果<literal>var1</>小于<literal>var2</>,则返回-1。
</para>
        </listitem>
        <listitem>
         <!--
<para>
          0, if <literal>var1</> and <literal>var2</> are equal
         </para>
-->
<para>
    如果<literal>var1</>等于<literal>var2</>,则返回0。
</para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      
<para>
      <!--
       Convert an int variable to a numeric variable.
  -->
  转换一个int变量到数值变量。
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       <!--
       This function accepts a variable of type signed int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
   -->
   这个函数接受有符号整型变量并将其存储在数值变量<literal>var</>中，
   成功时，则返回0。在失败的情况下，返回-1。
   
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      
<para>
      <!--
       Convert a long int variable to a numeric variable.
  -->
  转换长整型变量到数值变量。
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       <!--
       This function accepts a variable of type signed long int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
   -->
   这个函数接受有符号长整型变量并将其存储在数值变量<literal>var</>中，成功时，
   则返回0。在失败的情况下，返回-1。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      
<para>
      <!--
       Copy over one numeric variable into another one.
  -->
  拷贝一个数值变量为另一个变量。
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       <!--
       This function copies over the value of the variable that
       <literal>src</literal> points to into the variable that <literal>dst</>
       points to. It returns 0 on success and -1 if an error occurs.
   -->
   这个函数拷贝变量的值，这个变量是<literal>src</literal>指向<literal>dst</>指向的变量，
   成功时返回0，错误的情况下返回-1。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      
<para>
      <!--
       Convert a variable of type double to a numeric.
  -->
   将double类型的变量转换成数值类型的。 
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       <!--
       This function accepts a variable of type double and stores the result
       in the variable that <literal>dst</> points to. It returns 0 on success
       and -1 if an error occurs.
   -->
   这个函数接受double变量并将其结果存储在<literal>dst</>指向的变量中，
   成功时，则返回0。在失败的情况下，返回-1。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      
<para>
       <!--
       Convert a variable of type numeric to double.
   -->
   将数值类型变量转换成double类型的。
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       <!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the double variable that <literal>dp</> points
       to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
   -->
   这个函数从变量中转换数值类型的值，
   这个变量是<literal>nv</>指向的<literal>dp</>指向的double变量，
   成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
   全局变量<literal>errno</>将额外设置<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      
<para>
      <!--
       Convert a variable of type numeric to int.
  -->
  将数值类型变量转化成整型。
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       <!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the integer variable that <literal>ip</>
       points to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
   -->
   这个函数从变量中转换数值类型的值，这个变量是<literal>nv</>指向的<literal>ip</>指向的整型变量，
   成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
   全局变量<literal>errno</>将额外设置<literal>PGTYPES_NUM_OVERFLOW</>。
   
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      
<para>
      <!--
       Convert a variable of type numeric to long.
  -->
  将数值类型的变量转换成long类型。
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       <!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the long integer variable that
       <literal>lp</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
   -->
   这个函数从变量中转换数值类型的值，这个变量是<literal>nv</>指向的<literal>lp</>指向的长整型变量，
   成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
   全局变量<literal>errno</>将额外设置<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>


     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      
<para>
       <!--
       Convert a variable of type numeric to decimal.
   -->
   将数值类型的变量转换成十进制类型。
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       <!--
       The function converts the numeric value from the variable that
       <literal>src</> points to into the decimal variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
   -->
   这个函数从变量中转换数值类型的值，这个变量是<literal>src</>指向的
   <literal>dst</>指向的十进制变量，
   成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
   全局变量<literal>errno</>将额外设置<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      
<para>
      <!--
       Convert a variable of type decimal to numeric.
  -->
  将十进制类型的变量转换成数值类型。
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       <!--
       The function converts the decimal value from the variable that
       <literal>src</> points to into the numeric variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs. Since the decimal type is implemented as a limited version of
       the numeric type, overflow cannot occur with this conversion.
   -->
   这个函数从变量中转换十进制值，这个变量是<literal>src</>指向的<literal>dst</>指向的数值变量，
   成功时返回0，错误的情况下返回-1，包括溢出。
   由于十进制类型作为数值类型的有限版本实现的，不会发生这种转换溢出。
   
      </para>

     </listitem>
    </varlistentry>
   </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
  <!--
   <title>The date Type</title>
  -->
   <title>日期类型</title>
   <!--
<para>
    The date type in C enables your programs to deal with data of the SQL type
    date. See <xref linkend="datatype-datetime"> for the equivalent type in the
    <productname>PostgreSQL</> server.
   </para>
-->
<para>
   C中的日期类型允许你的程序处理SQL类型的数据。参见<xref linkend="datatype-datetime">
   获得<productname>PostgreSQL</>服务器的等价类型。
</para>
   
<para>
    <!--
    The following functions can be used to work with the date type:
-->
下面的函数可以适用于日期类型：
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
     <!--
        Extract the date part from a timestamp.
    -->
从一个时间戳中提取日期部分。
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        <!--
        The function receives a timestamp as its only argument and returns the
        extracted date part from this timestamp.
-->
这个函数接受一个时间戳作为其唯一的参数,并且从时间戳返回提取日期部分。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       
<para>
       <!--
       Parse a date from its textual representation.
   -->
   从文本表示解析日期。
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
       <!--
        The function receives a C char* string <literal>str</> and a pointer to
        a C char* string <literal>endptr</>. At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->
函数接收C char*字符串<literal>str</>和指向C char*字符串<literal>endptr</>的指针。
此刻ECPG总是解析完整的字符串，
所以目前不支持存储在<literal>*endptr</literal>中的第一无效字符的地址。
你可以安全地设置<literal>endptr</literal>无效。
       </para>

       <!--
<para>
        Note that the function always assumes MDY-formatted dates and there is
        currently no variable to change that within ECPG.
       </para>
-->
<para>
    注意，函数始终假定MDY格式化日期目前在ECPG还没有改变。
</para>
       <!--
<para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table"> shows the allowed input formats.
       </para>
-->
<para>
    <xref linkend="ecpg-pgtypesdate-from-asc-table">显示了允许输入格式。
</para>
        <table id="ecpg-pgtypesdate-from-asc-table">
<!--
         <title>Valid Input Formats for <function>PGTYPESdate_from_asc</function></title>
-->
<title><function>PGTYPESdate_from_asc</function>有效输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
   <!--
            <entry>Input</entry>
            <entry>Result</entry>
    -->
<entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>year and day of year</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>Julian day</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>year 99 before the Common Era</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       
<para>  
      <!--
        Return the textual representation of a date variable.
  -->
   返回一个数据变量的文本表示。
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        <!--
        The function receives the date <literal>dDate</> as its only parameter.
        It will output the date in the form <literal>1999-01-18</>, i.e., in the
        <literal>YYYY-MM-DD</> format.
-->
函数接收日期<literal>dDate</>作为它唯一参数。
输出数据的形式<literal>1999-01-18</>，即<literal>YYYY-MM-DD</>格式。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       
<para>
        <!--
        Extract the values for the day, the month and the year from a variable
        of type date.
-->
从一个日期型的变量中提取一天、本月和一年的值。
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
    <!--
        The function receives the date <literal>d</> and a pointer to an array
        of 3 integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
-->

函数接收日期<literal>d</>和一个指向3个整型值<literal>mdy</>数组的指针。
变量名称显示顺序：<literal>mdy[0]</>设置为包含的几个月份，
<literal>mdy[1]</>设置为一天的值，<literal>mdy[2]</>包含一年的值。

       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
      
<para>
        <!--
        Create a date value from an array of 3 integers that specify the
        day, the month and the year of the date.
-->
从指定日期的年、月、日的3个整型值数组中创建一个日期值。
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        <!--
        The function receives the array of the 3 integers (<literal>mdy</>) as
        its first argument and as its second argument a pointer to a variable
        of type date that should hold the result of the operation.
-->
函数接收3个整型(<literal>mdy</>)的数组作为第一个参数，
第二个参数是指向保留运算结果的日期型变量的指针。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       
<para>
       <!--
        Return a number representing the day of the week for a date value.
    -->
返回表示日期值的一个星期数。
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        <!--
        The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
-->
函数接收日期变量<literal>d</>作为其唯一的参数，
并返回一个整数，表示这个日期的本周的一天。

        <itemizedlist>
         <listitem>
          <para>
   <!--
           0 - Sunday
   -->
   0 - 星期日
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           1 - Monday
          </para>
-->
<para>
    1 - 星期一
</para>
         </listitem>
         <listitem>
          <!--
<para>
           2 - Tuesday
          </para>
-->
<para>
     2 - 星期二
</para>
         </listitem>
         <listitem>
          <!--
<para>
           3 - Wednesday
          </para>
-->
<para>
      3 - 星期三
</para>
         </listitem>
         <listitem>
          <!--
<para>
           4 - Thursday
          </para>
-->
<para>
        4 - 星期四
</para>
         </listitem>
         <listitem>
          <!--
<para>
           5 - Friday
          </para>
-->
<para>
        5 – 星期五
</para>
         </listitem>
         <listitem>
          <!--
<para>
           6 - Saturday
          </para>
-->
<para>
        6 – 星期六
</para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       
<para>
       <!--
        Get the current date.
    -->
得到当前日期。
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
       <!--
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
-->
函数接收指向日期变量(<literal>d</>)的一个指针，它设置当前的日期。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       
<para>
        <!--
        Convert a variable of type date to its textual representation using a
        format mask.
-->
将日期类型变量转换成使用格式掩码的文本表示形式。
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        <!--
        The function receives the date to convert (<literal>dDate</>), the
        format mask (<literal>fmtstring</>) and the string that will hold the
        textual representation of the date (<literal>outbuf</>).
-->
函数接收一个转换(<literal>dDate</>)日期，
格式掩码(<literal>fmtstring</>)以及保持日期(<literal>outbuf</>)文本表示形式的字符串。
       </para>
       <!--
<para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
-->
<para>
        成功的时候返回0，如果产生错误则返回负数。
</para>
       
<para>
       <!--
        The following literals are the field specifiers you can use:
    -->
下列是你可以使用的字段分类符：
        <itemizedlist>
         <listitem>
          <para>
   <!--
           <literal>dd</literal> - The number of the day of the month.
   -->
   <literal>dd</literal> - 某月的天数。
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           <literal>mm</literal> - The number of the month of the year.
          </para>
-->
<para>
            <literal>mm</literal> -某年的月数。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>yy</literal> - The number of the year as a two digit number.
          </para>
-->
<para>
         <literal>yy</literal> - 2位数的年数。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>yyyy</literal> - The number of the year as a four digit number.
          </para>
-->
<para>
           <literal>yyyy</literal> -4位数的年数。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>ddd</literal> - The name of the day (abbreviated).
          </para>
-->
<para>
         <literal>ddd</literal> - 某天的名字（缩略）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>mmm</literal> - The name of the month (abbreviated).
          </para>
-->
<para>
         <literal>mmm</literal> - 某月份名字（缩略）。
</para>
         </listitem>
        </itemizedlist>
<!--
        All other characters are copied 1:1 to the output string.
-->
所有其它的字符按1:1复制到输出字符串中。
       </para>
       <!--
<para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function. All output lines are based on
        the same date: November 23, 1959.
       </para>
-->
<para>
      <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table">表示一些可能的格式。
  这将让你知道如何使用这些功能。所有输出行基于相同的日期：1959年11月23号。
</para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
<!--
         <title>Valid Input Formats for <function>PGTYPESdate_fmt_asc</function></title>
 -->
 <title><function>PGTYPESdate_fmt_asc</function>有效输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
   <!--
            <entry>Format</entry>
            <entry>Result</entry>
   -->
   <entry>格式</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       
<para>
       <!--
        Use a format mask to convert a C <type>char*</type> string to a value of type
        date.
   -->
   使用格式掩码转换C <type>char*</type>到日期类型的值。
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-- same description as rdefmtdate -->
       <!--       
   The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
-->
函数接收一个指向保持操作(<literal>d</>)结果的日期值的指针，
解析日期(<literal>fmt</>)的格式掩码以及包含日期(<literal>str</>)文本表示的C char*字符串。
希望文本表示匹配格式掩码。但是你不需要字符串1:1映射到格式掩码。
这个函数仅分析相继顺序，
并且查找<literal>yy</literal>或者<literal>yyyy</literal>显示年的位置，
<literal>mm</literal>显示月的位置，<literal>dd</literal>显示一天的位置。

       </para>

       <!--
<para>
        <xref linkend="ecpg-rdefmtdate-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function.
       </para>
-->
<para>
       <xref linkend="ecpg-rdefmtdate-example-table">表明一些可能的格式。
   这将让你知道如果使用这个函数。
</para>
        <table id="ecpg-rdefmtdate-example-table">
<!--
         <title>Valid Input Formats for <function>rdefmtdate</function></title>
-->
<title><function>rdefmtdate</function>有效输入格式</title>
         <tgroup cols="3">
          <thead>
           <row>
   <!--
            <entry>Format</entry>
            <entry>String</entry>
            <entry>Result</entry>
   -->
     <entry>格式</entry>
            <entry>字符串</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
<!--
            <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
            -->
<entry><literal>在2525年，7月28号人类仍存活。</literal></entry>
<entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
<!--
            <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
-->
<entry><literal>2525年7月28号</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
  <!--
   <title>The timestamp Type</title>
  -->
    <title>时间戳类型</title>
   <!--
<para>
    The timestamp type in C enables your programs to deal with data of the SQL
    type timestamp. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
   </para>
-->
<para>
    C中时间戳类型允许你的程序处理SQL类型时间戳数据。
参见<xref linkend="datatype-datetime">
获取关于<productname>PostgreSQL</>服务器的等价类型。
</para>
   
<para>
    <!--
    The following functions can be used to work with the timestamp type:
-->
下面的函数可以用于时间戳类型。
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
   <!--
        Parse a timestamp from its textual representation into a timestamp
        variable.
-->
将文本表示的时间戳解析成一个时间戳变量。
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
       <!--
        The function receives the string to parse (<literal>str</>) and a
        pointer to a C char* (<literal>endptr</>).
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->
函数接收一个解析(<literal>str</>)字符串和指向C char*(<literal>endptr</>)指针。
此刻ECPG总是解析完整字符串，
因此它目前不支持存储<literal>*endptr</literal>中第一无效字符地址。
你可以安全地设置<literal>endptr</literal>为空。
       </para>

       <!--
<para>
        The function returns the parsed timestamp on success. On error,
        <literal>PGTYPESInvalidTimestamp</literal> is returned and <varname>errno</> is
        set to <literal>PGTYPES_TS_BAD_TIMESTAMP</>. See <xref linkend="PGTYPESInvalidTimestamp"> for important notes on this value.
       </para>
-->
<para>
   成功时函数返回解析的时间戳，产生错误时返回<literal>PGTYPESInvalidTimestamp</literal>，
   并且设置<varname>errno</>为<literal>PGTYPES_TS_BAD_TIMESTAMP</>。
   参见<xref linkend="PGTYPESInvalidTimestamp">获取这个值的重要注释。
</para>
       <!--
<para>
        In general, the input string can contain any combination of an allowed
        date specification, a whitespace character and an allowed time
        specification. Note that time zones are not supported by ECPG. It can
        parse them but does not apply any calculation as the
        <productname>PostgreSQL</> server does for example. Timezone
        specifiers are silently discarded.
       </para>
-->
<para>
     一般情况下，输入的字符串可以包含一个所允许日期规范、
 一个空格字符和允许的时间规范的任意组合。请注意，ECPG不支持时区。
 它可以解析它们，但不适用于任何计算比如<productname>PostgreSQL</>服务器。
 时区说明符默认是省略的。
</para>
       <!--
<para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"> contains a few examples for input strings.
       </para>
-->
<para>
     <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table">包含输入字符串的一些例子。
</para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
<!--
         <title>Valid Input Formats for <function>PGTYPEStimestamp_from_asc</function></title>
         -->
 <title><function>PGTYPEStimestamp_from_asc</function>有效输入格式</title>
 <tgroup cols="2">
          <thead>
           <row>
   <!--
            <entry>Input</entry>
            <entry>Result</entry>
   -->
   <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
<!--
            <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
            -->
<entry><literal>1999-01-08 04:05:06.789 (忽略时区说明符)</literal></entry>
   </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <!--
<entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
            -->
<entry><literal>1999-01-08 04:05:00 (忽略时区说明符)</literal></entry>
   </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       
<para>
      <!--
        Converts a date to a C char* string.
   -->
    将日期转换成C char*字符串。
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
       <!--
        The function receives the timestamp <literal>tstamp</> as
        its only argument and returns an allocated string that contains the
        textual representation of the timestamp.
   -->
   函数接收时间戳<literal>tstamp</>作为其唯一的参数
   并返回一个包含时间戳的文本表示的分配的字符串。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       
<para>
       <!--
        Retrieve the current timestamp.
    -->
获取当前时间戳。
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        <!--
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
-->
该函数获取当前时间戳，并且将它保存到<literal>ts</>指向
的时间戳变量中。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       
<para>
        <!--
        Convert a timestamp variable to a C char* using a format mask.
-->
使用格式掩码将时间戳变量转换为C char*。
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        <!--
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
        -->
这个函数接受一个指向时间戳转换为它的第一个参数(<literal>ts</>)的指针，
一个指向缓冲输出(<literal>output</>)，
最大长度已为输出缓冲区(<literal>str_len</literal>)分配，
并且为转换(<literal>fmtstr</literal>)设置掩码格式的指针。

   </para>
       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
    一旦成功，该函数返回0，如果产生错误，则返回负值。
</para>
       
<para>
       <!--
        You can use the following format specifiers for the format mask. The
        format specifiers are the same ones that are used in the
        <function>strftime</> function in <productname>libc</productname>. Any
        non-format specifier will be copied into the output buffer.
-->
你可以为格式掩码使用以下的格式分类符。
格式分类符是和<productname>libc</productname>的<function>strftime</>
函数中使用的相同的。
任何非格式分类符将被复制到输出缓冲区。

        <!-- This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
          <para>
   <!--
           <literal>%A</literal> - is replaced by national representation of
           the full weekday name.
   -->
   <literal>%A</literal> - 是由工作日全称的国家表示形式替换。
   
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           <literal>%a</literal> - is replaced by national representation of
           the abbreviated weekday name.
          </para>
-->
<para>
      <literal>%a</literal> - 是由工作日名称缩写的国家表示形式替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%B</literal> - is replaced by national representation of
           the full month name.
          </para>
-->
<para>
       <literal>%B</literal> - 是由月份名的全称的国家表示形式替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%b</literal> - is replaced by national representation of
           the abbreviated month name.
          </para>
-->
<para>
            <literal>%b</literal> - 是由月份名称缩写的国家表示形式替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%C</literal> - is replaced by (year / 100) as decimal
           number; single digits are preceded by a zero.
          </para>
-->
<para>
            <literal>%C</literal> - 通过（年/100）作为十进制数替换；单位数前边加零。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%c</literal> - is replaced by national representation of
           time and date.
          </para>
-->
<para>
           <literal>%c</literal> - 由时间和日期的国家表示形式替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%D</literal> - is equivalent to
           <literal>%m/%d/%y</literal>.
          </para>
-->
<para>
            <literal>%D</literal> - 等同于<literal>%m/%d/%y</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%d</literal> - is replaced by the day of the month as a
           decimal number (01-31).
          </para>
-->
<para>
           <literal>%d</literal> - 作为十进制数（01-31）按当月的一天替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX locale
           extensions. The sequences
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           are supposed to provide alternative representations.
          </para>
-->
<para>
          <literal>%E*</literal> <literal>%O*</literal> - POSIX区域扩展。
  序列<literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>应该提供替代表示形式。
</para>
          <!--
<para>
           Additionally <literal>%OB</literal> implemented to represent
           alternative months names (used standalone, without day mentioned).
          </para>
-->
<para>
        此外，实现的<literal>%OB</literal>代表可选月份名字
（独立使用，没有提及天）。 
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%e</literal> - is replaced by the day of month as a decimal
           number (1-31); single digits are preceded by a blank.
          </para>
-->
<para>
          <literal>%e</literal> -作为十进制数（1-31）按当月的一天替换；
  单位数前面有空格。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>.
          </para>
-->
<para>
            <literal>%F</literal> - 等同于<literal>%Y-%m-%d</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%G</literal> - is replaced by a year as a decimal number
           with century. This year is the one that contains the greater part of
           the week (Monday as the first day of the week).
          </para>
-->
<para>
           <literal>%G</literal> - 以每年作为一个世纪的十进制数替换。
   今年是包含一周的大部分中的一个（星期一作为一周的第一天）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%g</literal> - is replaced by the same year as in
           <literal>%G</literal>, but as a decimal number without century
           (00-99).
          </para>
-->
<para>
           <literal>%g</literal> - 由<literal>%G</literal>中的同一年替换，
   但作为一个没有世纪（00-99）的十进制数。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%H</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (00-23).
          </para>
-->
<para>
          <literal>%H</literal> - 作为十进制数（00-23）按小时（24小时）进行替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%h</literal> - the same as <literal>%b</literal>.
          </para>
-->
<para>
           <literal>%h</literal> -等同于<literal>%b</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%I</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (01-12).
          </para>
-->
<para>
           <literal>%I</literal> - 作为十进制数（01-12）按小时（12小时）进行替换。  
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%j</literal> - is replaced by the day of the year as a
           decimal number (001-366).
          </para>
-->
<para>
           <literal>%j</literal> - 作为十进制数（001-366）按一年的一天来替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%k</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (0-23); single digits are preceded by a blank.
          </para>
-->
<para>
          <literal>%k</literal> - 作为十进制数（0-23）按小时（24小时）替换；
  单位数前面有空格。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%l</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (1-12); single digits are preceded by a blank.
          </para>
-->
<para>
          <literal>%l</literal> - 作为十进制数（1-12）按小时（12小时）替换；
  单位数前面有空格。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%M</literal> - is replaced by the minute as a decimal
           number (00-59).
          </para>
-->
<para>
           <literal>%M</literal> - 作为十进制数（00-59）按分钟来替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%m</literal> - is replaced by the month as a decimal number
           (01-12).
          </para>
-->
<para>
          <literal>%m</literal> - 作为十进制数（01-12）按月替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
          <literal>%n</literal> - is replaced by a newline.
          </para>
-->
<para>
          <literal>%n</literal> - 通过换行符替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%O*</literal> - the same as <literal>%E*</literal>.
          </para>
-->
<para>
          <literal>%O*</literal> - 等同于<literal>%E*</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%p</literal> - is replaced by national representation of
           either <quote>ante meridiem</quote> or <quote>post meridiem</quote> as appropriate.
          </para>
-->
<para>
           <literal>%p</literal> - 由合适的<quote>午前</quote>或<quote>午后</quote>的国家表示形式进行替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%R</literal> - is equivalent to <literal>%H:%M</literal>.
          </para>
-->
<para>
         <literal>%R</literal> - 等同于<literal>%H:%M</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%r</literal> - is equivalent to <literal>%I:%M:%S
           %p</literal>.
          </para>
-->
<para>
            <literal>%r</literal> - 等同于<literal>%I:%M:%S%p</literal>
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%S</literal> - is replaced by the second as a decimal
           number (00-60).
          </para>
-->
<para>
           <literal>%S</literal> - 作为十进制数（00-60）按秒进行替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%s</literal> - is replaced by the number of seconds since
           the Epoch, UTC.
          </para>
-->
<para>
            <literal>%s</literal> -通过Epoch, UTC以来的秒数替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>
          </para>
-->
<para>
            <literal>%T</literal> - 等同于<literal>%H:%M:%S</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%t</literal> - is replaced by a tab.
          </para>
-->
<para>
            <literal>%t</literal> -通过制表符替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%U</literal> - is replaced by the week number of the year
           (Sunday as the first day of the week) as a decimal number (00-53).
          </para>
-->
<para>
           <literal>%U</literal> -按照十进制数（00-53）一年中的
   周数取代（星期日作为一周的第一天）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%u</literal> - is replaced by the weekday (Monday as the
           first day of the week) as a decimal number (1-7).
          </para>
-->
<para>
          <literal>%u</literal> - 按照十进制数（1-7）工
  作日取代（星期一作为一周的第一天）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%V</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (01-53).
           If the week containing January 1 has four or more days in the new
           year, then it is week 1; otherwise it is the last week of the
           previous year, and the next week is week 1.
          </para>
-->
<para>
          <literal>%V</literal> - 通过十进制数（01-53）一年
  中的周数取代（星期一作为一周的第一天）。
  如果在新的一年中包含一月一日的工作日有四天以上，
  那么它是第1周；否则它是去年的最后一周，并且下一周是第1周。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%v</literal> - is equivalent to
           <literal>%e-%b-%Y</literal>.
          </para>
-->
<para>
           <literal>%v</literal> - 等同于<literal>%e-%b-%Y</literal>。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%W</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (00-53).
          </para>
-->
<para>
           <literal>%W</literal> - 通过十进制数（00-53）
   一年的周数取代（星期一作为一周的第一天）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%w</literal> - is replaced by the weekday (Sunday as the
           first day of the week) as a decimal number (0-6).
          </para>
-->
<para>
           <literal>%w</literal> - 通过十进制数（0-6）
   工作日取代（星期日作为一周的第一天）。  
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%X</literal> - is replaced by national representation of
           the time.
          </para>
-->
<para>
          <literal>%X</literal> - 通过时间的国家表示形式取代。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%x</literal> - is replaced by national representation of
           the date.
          </para>
-->
<para>
           <literal>%x</literal> - 通过日期的国家表示形式取代。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%Y</literal> - is replaced by the year with century as a
           decimal number.
          </para>
-->
<para>
          <literal>%Y</literal> - 通过十进制数世纪年来取代。 
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%y</literal> - is replaced by the year without century as a
           decimal number (00-99).
          </para>
-->
<para>
           <literal>%y</literal> - 通过十进制数（00-99）没有世纪的年来取代。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%Z</literal> - is replaced by the time zone name.
          </para>
-->
<para>
            <literal>%Z</literal> - 由时区名称替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%z</literal> - is replaced by the time zone offset from
           UTC; a leading plus sign stands for east of UTC, a minus sign for
           west of UTC, hours and minutes follow with two digits each and no
           delimiter between them (common form for RFC 822 date headers).
          </para>
-->
<para>
         <literal>%z</literal> -通过UTC时区偏移量取代；
 前导加号为UTC东部，减号为UTC西部，
 小时和分钟各跟随着两位数，它们之间没有分隔符
 （常见的形式为RFC 822日期标题）。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%+</literal> - is replaced by national representation of
           the date and time.
          </para>
-->
<para>
             <literal>%+</literal> - 通过日期和时间的国家表示形式替换。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%-*</literal> - GNU libc extension. Do not do any padding
           when performing numerical outputs.
          </para>
-->
<para>
         <literal>%-*</literal> - GNU libc扩展。当执行数值输出时不要做任何填充。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           $_* - GNU libc extension.    Explicitly specify space for padding.
          </para>
-->
<para>
            $_* - GNU libc扩展。明确声明空格填充。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%0*</literal> - GNU libc extension. Explicitly specify zero
           for padding.
          </para>
-->
<para>
           <literal>%0*</literal> - GNU libc扩展。明确声明零填充。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>%%</literal> - is replaced by <literal>%</literal>.
          </para>
-->
<para>
           <literal>%%</literal> - 通过<literal>%</literal>替换。
</para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       
<para>
        <!--
        Subtract one timestamp from another one and save the result in a
        variable of type interval.
-->
从另外一个中减去一个时间戳，并且将结果保存在interval类型的变量中。

<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        <!--
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
-->
该函数将减去时间戳变量，这个变量是<literal>ts2</>
指向的<literal>ts1</>指向的时间戳的变量，
并将结果存储在<literal>iv</>指向的时间戳变量中。 

       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
       成功时，函数返回0。如果发生错误则返回一个负值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       
<para>
       <!--
        Parse a timestamp value from its textual representation using a
        formatting mask.
   -->
   
从使用格式掩码的文本表示中分析一个时间戳值。
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        <!--
        The function receives the textual representation of a timestamp in the
        variable <literal>str</> as well as the formatting mask to use in the
        variable <literal>fmt</>. The result will be stored in the variable
        that <literal>d</> points to.
-->
这个函数接受变量<literal>str</>时间戳的文本表示
以及格式掩码中使用的变量<literal>fmt</>。
结果将存储在<literal>d</>指向的变量中。
       </para>
       <!--
<para>
        If the formatting mask <literal>fmt</> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
       </para>
-->
<para>
       如果格式掩码<literal>fmt</>是空，
   该函数将回落到缺省格式掩码<literal>%Y-%m-%d%H:%M:%S</literal>。
</para>
       <!--
<para>
        This is the reverse function to <xref
        linkend="PGTYPEStimestampfmtasc">.  See the documentation there in
        order to find out about the possible formatting mask entries.
       </para>
-->
<para>
       这是<xref linkend="PGTYPEStimestampfmtasc">的反向函数。
   参见文档找出可能的格式掩码项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       
<para>
       <!--
        Add an interval variable to a timestamp variable.
-->
增加interval变量到timestamp变量。
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        <!--
        The function receives a pointer to a timestamp variable <literal>tin</>
        and a pointer to an interval variable <literal>span</>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</> points to.
-->
这个函数接受一个指向timestamp变量<literal>tin</>的指针，
一个指向interval变量<literal>span</>的指针。
它增加interval到timestamp，
并且将结果timestamp保存在<literal>tout</>指向的变量中。
       </para>
       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
       成功时，这个函数返回0，如果产生错误，则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       
<para>
       <!--
        Subtract an interval variable from a timestamp variable.
  -->
   从一个timestamp变量中减去interval变量。
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        <!--
        The function subtracts the interval variable that <literal>span</>
        points to from the timestamp variable that <literal>tin</> points to
        and saves the result into the variable that <literal>tout</> points
        to.
-->
这个函数减去interval变量，这个变量是<literal>span</>
指向的<literal>tin</>指向的timestamp变量，
并且将结果存储在<literal>tout</>指向的变量中。
       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
        成功时，这个函数返回0。当产生错误的时候，返回负数。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
  <!--
   <title>The interval Type</title>
  -->
    <title>区间类型</title>
   <!--
<para>
    The interval type in C enables your programs to deal with data of the SQL
    type interval. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
   </para>
-->
<para>
    C中区间类型允许你的程序处理SQL类型区间的数据。
参见<xref linkend="datatype-datetime">获取
<productname>PostgreSQL</>服务器的等价类型。
</para>
   
<para>
    <!--
    The following functions can be used to work with the interval type:
-->
下面的函数可以用于区间类型：
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
   <!--
        Return a pointer to a newly allocated interval variable.
   -->
   返回一个已分配的区间变量的指针。
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       
<para>
       <!--
        Release the memory of a previously allocated interval variable.
    -->
释放已经分配区间变量的内存。
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       
<para>
       <!--
        Parse an interval from its textual representation.
   -->
    解析文本表示的区间。
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        <!--
        The function parses the input string <literal>str</> and returns a
        pointer to an allocated interval variable.
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->

该函数解析输入的字符串<literal>str</>并返回分配区间变量的指针。
此刻ECPG总是解析完整的字符串，所以目
前不支持存储在<literal>*endptr</literal>中的第一无效字符的地址。
你可以安全地设置<literal>endptr</literal>为空。 

       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       
<para>
       <!--
        Convert a variable of type interval to its textual representation.
   -->
     将类型区间的变量转换成它的文本表示。
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        <!--
        The function converts the interval variable that <literal>span</>
        points to into a C char*. The output looks like this example:
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
-->
该函数将转换<literal>span</>指向C char*的区间变量，
输出看起来像这样的例子：<literal>@ 1 day 12 hours 59 mins 10 secs</literal>。

       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       
<para>
        <!--
        Copy a variable of type interval.
-->
复制区间类型的变量。
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis> 
        <!--
        The function copies the interval variable that <literal>intvlsrc</>
        points to into the variable that <literal>intvldest</> points to. Note
        that you need to allocate the memory for the destination variable
        before.
-->

该函数复制<literal>intvlsrc</>指向<literal>intvldest</>指向的区间变量，注意，
你需要在目标变量前分配内存。

       </para>

      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
  <!--
   <title>The decimal Type</title>
  -->
   <title>十进制类型</title>
   <!--
<para>
     The decimal type is similar to the numeric type. However it is limited to
     a maximum precision of 30 significant digits. In contrast to the numeric
     type which can be created on the heap only, the decimal type can be
     created either on the stack or on the heap (by means of the functions
     <function>PGTYPESdecimal_new</> and
     <function>PGTYPESdecimal_free</>).
     There are a lot of other functions that deal with the decimal type in the
     <productname>Informix</productname> compatibility mode described in <xref
     linkend="ecpg-informix-compat">.
   </para>
-->
<para>
    decimal类型和numeric类型是类似的。然而，
它仅仅是一个30位数的最大精度。相反，
numeric类型只能在堆上创建，decimal类型可以在栈或堆上创建
（通过函数<function>PGTYPESdecimal_new</>和
     <function>PGTYPESdecimal_free</>）。
<xref linkend="ecpg-informix-compat">中描述的
<productname>Informix</productname>兼容模式还有很多处
理decimal类型的其他函数。
</para>
   
<para>
    <!--
    The following functions can be used to work with the decimal type and are
    not only contained in the <literal>libcompat</> library.
-->
下面的函数可以用于decimal类型，不仅包含在<literal>libcompat</>库中。
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
   <!--
       Request a pointer to a newly allocated decimal variable.
   -->
   请求一个新分配的decimal变量的指针。
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       
<para>
      <!--
       Free a decimal type, release all of its memory.
  -->
   任意decimal类型，释放所有内存。
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>

      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
   <!--
    <title>errno Values of pgtypeslib</title>
   -->
     <title>pgtypeslib的errno值</title>
   
<para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
    <!--
        An argument should contain a numeric variable (or point to a numeric
        variable) but in fact its in-memory representation was invalid.
-->
参数应该包含一个数值变量（或者指向一个数值变量）
但事实上内存中表示是无效的。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <!--
<para>
        An overflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause overflow.
       </para>
-->
<para>
       发生溢出。因为numeric类型可以处理几乎任意精度，
   将一个numeric变量转换为其它类型可能导致溢出。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <!--
<para>
        An underflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause underflow.
       </para>
-->
<para>
       发生下溢。因为numeric类型可以处理几乎任意精度，
   将一个numeric变量转换为其它类型可能导致下溢。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <!--
<para>
        A division by zero has been attempted.
       </para>
-->
<para>
      尝试除以零。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <!--
<para>
        An invalid date string was passed to
        the <function>PGTYPESdate_from_asc</function> function.
       </para>
-->
<para>
        无效的日期字符串被传递给<function>PGTYPESdate_from_asc</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <!--
<para>
        Invalid arguments were passed to the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
-->
<para>
        无效参数被传递给<function>PGTYPESdate_defmt_asc</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <!--
<para>
        An invalid token in the input string was found by the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
-->
<para>
      通过<function>PGTYPESdate_defmt_asc</function>函数发现输入字符串中的无效标记。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <!--
<para>
        An invalid interval string was passed to the
        <function>PGTYPESinterval_from_asc</function> function, or an
        invalid interval value was passed to the
        <function>PGTYPESinterval_to_asc</function> function.
       </para>
-->
<para>
        无效区间字符串被传递给<function>PGTYPESinterval_from_asc</function>函数，
或者无效区间值被传递给<function>PGTYPESinterval_to_asc</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <!--
<para>
        There was a mismatch in the day/month/year assignment in the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
-->
<para>
      在<function>PGTYPESdate_defmt_asc</function>函数中日/月/年分配不匹配。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <!--
<para>
        An invalid day of the month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
-->
<para>
       通过<function>PGTYPESdate_defmt_asc</function>函数发现某月值的无效天数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <!--
<para>
        An invalid month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
-->
<para>
        通过<function>PGTYPESdate_defmt_asc</function>函数发现无效月数值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <!--
<para>
        An invalid timestamp string pass passed to
        the <function>PGTYPEStimestamp_from_asc</function> function,
        or an invalid timestamp value was passed to
        the <function>PGTYPEStimestamp_to_asc</function> function.
       </para>
-->
<para>
      无效的timestamp字符串被传递给<function>PGTYPEStimestamp_from_asc</function>函数，
  或者无效timestamp值被传递给<function>PGTYPEStimestamp_to_asc</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <!--
<para>
        An infinite timestamp value was encountered in a context that
        cannot handle it.
       </para>
-->
<para>
        在环境中遇到的无限timestamp值不能处理它。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
   <!--
    <title>Special Constants of pgtypeslib</title>
   -->
     <title>pgtypeslib的特殊常量</title>
   
<para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
   <!--
        A value of type timestamp representing an invalid time stamp. This is
        returned by the function <function>PGTYPEStimestamp_from_asc</> on
        parse error.
        Note that due to the internal representation of the <type>timestamp</type> data type,
        <literal>PGTYPESInvalidTimestamp</literal> is also a valid timestamp at
        the same time. It is set to <literal>1899-12-31 23:59:59</>. In order
        to detect errors, make sure that your application does not only test
        for <literal>PGTYPESInvalidTimestamp</literal> but also for
        <literal>errno != 0</> after each call to
        <function>PGTYPEStimestamp_from_asc</>.
-->
 代表一个无效的时间戳的timestamp类型的值。
 这是通过函数<function>PGTYPEStimestamp_from_asc</>返回解析错误。
 请注意，由于该<type>timestamp</type>数据类型的内部表示，
 同时<literal>PGTYPESInvalidTimestamp</literal>也是一个有效的timestamp。
 它设置<literal>1899-12-31 23:59:59</>。为了检测错误，
 确保你的应用每次调用<function>PGTYPEStimestamp_from_asc</>后
 不仅测试<literal>PGTYPESInvalidTimestamp</literal>也能检测<literal>errno != 0</>。

       </para>

      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
 <!--
  <title>Using Descriptor Areas</title>
 -->
    <title>使用描述符范围</title>

  <!--
<para>
   An SQL descriptor area is a more sophisticated method for processing
   the result of a <command>SELECT</command>, <command>FETCH</command> or
   a <command>DESCRIBE</command> statement. An SQL descriptor area groups
   the data of one row of data together with metadata items into one
   data structure.  The metadata is particularly useful when executing
   dynamic SQL statements, where the nature of the result columns might
   not be known ahead of time. PostgreSQL provides two ways to use
   Descriptor Areas: the named SQL Descriptor Areas and the C-structure
   SQLDAs.
  </para>
-->
<para>
一个SQL描述符范围是处理<command>SELECT</command>, <command>FETCH</command>或者
<command>DESCRIBE</command>语句结果的更复杂的方法。
一个SQL描述符范围把一行数据里的数据和元数据项组合到一个数据结构中。
 元数据在执行动态SQL语句时特别有用，那里的结果列的属性可能不能提前知道。
 PostgreSQL提供了两种使用描述符范围的方法：
 命名的SQL描述符范围和C结构SQLDAs。
</para>

  <sect2 id="ecpg-named-descriptors">
  <!--
   <title>Named SQL Descriptor Areas</title>
  -->
   <title>命名SQL描述符范围</title>
   <!--
<para>
    A named SQL descriptor area consists of a header, which contains
    information concerning the entire descriptor, and one or more item
    descriptor areas, which basically each describe one column in the
    result row.
   </para>
-->
<para>
一个命名SQL描述符范围由一个头组成，
包含有关整个描述符的信息，一个或多个项描述符范围，
基本上每个描述结果行中的一个字段。
</para>

   
<para>
    <!--
    Before you can use an SQL descriptor area, you need to allocate one:
-->
在你使用SQL描述符范围之前，你需要分配一个：
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    <!--
    The identifier serves as the <quote>variable name</quote> of the
    descriptor area.  <remark>The scope of the allocated descriptor is WHAT?.</remark>
    When you don't need the descriptor anymore, you should deallocate
    it:
-->
标示符用作描述符范围的<quote>变量名</quote>。<remark>所分配的描述符范围是什么?</remark>
当你不再需要这个描述符，你应该释放它：

<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>


   
<para>
    <!--
    To use a descriptor area, specify it as the storage target in an
    <literal>INTO</literal> clause, instead of listing host variables:
-->
要使用一个描述符范围，在一个<literal>INTO</literal>子句的存储目标里声明它，
而不是列出宿主变量：
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    <!--
    If the result set is empty, the Descriptor Area will still contain
    the metadata from the query, i.e. the field names.
-->
如果结果集是空，描述符范围将包含来自查询的元数据，即字段名称。
   </para>


   
<para>
    <!--
    For not yet executed prepared queries, the <command>DESCRIBE</command>
    statement can be used to get the metadata of the result set:
-->
为了尚未执行的预备查询，<command>DESCRIBE</command>语句可用于获得结果集的元数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>

   <!--
<para>
    Before PostgreSQL 9.0, the <literal>SQL</literal> keyword was optional,
    so using <literal>DESCRIPTOR</literal> and <literal>SQL DESCRIPTOR</literal>
    produced named SQL Descriptor Areas. Now it is mandatory, omitting
    the <literal>SQL</literal> keyword produces SQLDA Descriptor Areas,
    see <xref linkend="ecpg-sqlda-descriptors">.
   </para>
-->
<para>
    PostgreSQL 9.0之前，<literal>SQL</literal>关键字是可选的，
所以使用<literal>DESCRIPTOR</literal>和<literal>SQL DESCRIPTOR</literal>
产生命名SQL描述符范围。
现在，它是强制性的，
省略<literal>SQL</literal>关键词产生SQLDA描述符范围，
参阅<xref linkend="ecpg-sqlda-descriptors">。
</para>

   <!--
<para>
    In <command>DESCRIBE</command> and <command>FETCH</command> statements,
    the <literal>INTO</literal> and <literal>USING</literal> keywords can be
    used to similarly: they produce the result set and the metadata in a
    Descriptor Area.
   </para>
-->
<para>
    在<command>DESCRIBE</command>和<command>FETCH</command>语句中，
<literal>INTO</literal>和<literal>USING</literal>关键字使用类似：
它们产生结果集合和描述符范围的元数据。
</para>

   
<para>
    <!--
    Now how do you get the data out of the descriptor area?  You can
    think of the descriptor area as a structure with named fields.  To
    retrieve the value of a field from the header and store it into a
    host variable, use the following command:
-->
现在，我们应该如何从描述符范围里获取数据？
你可以把描述符范围看作是一个有着命名字段的结构。
要从头检索字段数值并且把它存储到一个宿主变量里，使用下面的命令：

<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <!--
    Currently, there is only one header field defined:
    <replaceable>COUNT</replaceable>, which tells how many item
    descriptor areas exist (that is, how many columns are contained in
    the result).  The host variable needs to be of an integer type.  To
    get a field from the item descriptor area, use the following
    command:
-->
目前只定义了一个头字段：<replaceable>COUNT</replaceable>，
这个字段告诉我们有几个项描述符范围存在（也就是说，在结果里包含多少个字段）。 
宿主变量需要是一个整数类型。要从项描述符范围里获取一个字段，
使用下面的命令：

<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>

    <!--
    <replaceable>num</replaceable> can be a literal integer or a host
    variable containing an integer. Possible fields are:
    -->
<replaceable>num</replaceable>可以是一个字符整数或者一个包含整数的宿主变量。
可能的字段有:

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> (integer)</term>
      <listitem>
       <para>
    <!--
        number of rows in the result set
-->
结果集中的行数
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <!--
<para>
        actual data item (therefore, the data type of this field
        depends on the query)
       </para>
-->
<para>
实际数据项（因此，这个字段的数据类型依赖于这个查询）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
      <listitem>
       <!--
<para>
        When <literal>TYPE</literal> is <literal>9</literal>,
        <literal>DATETIME_INTERVAL_CODE</literal> will have a value of
        <literal>1</literal> for <literal>DATE</literal>,
        <literal>2</literal> for <literal>TIME</literal>,
        <literal>3</literal> for <literal>TIMESTAMP</literal>,
        <literal>4</literal> for <literal>TIME WITH TIME ZONE</literal>, or
        <literal>5</literal> for <literal>TIMESTAMP WITH TIME ZONE</literal>.
       </para>
-->
<para>
       当<literal>TYPE</literal>是<literal>9</literal>的时候，那么
   <literal>DATETIME_INTERVAL_CODE</literal>将有<literal>DATE</literal>的<literal>1</literal>值，
    <literal>TIME</literal>的<literal>2</literal>值，
        <literal>TIMESTAMP</literal>的<literal>3</literal>值，
        <literal>TIME WITH TIME ZONE</literal>的<literal>4</literal>值或者
        <literal>TIMESTAMP WITH TIME ZONE</literal>的<literal>5</literal>值。
      
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
      <listitem>
       <!--
<para>
        not implemented
       </para>
-->
<para>
        未实现。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> (integer)</term>
      <listitem>
       <!--
<para>
        the indicator (indicating a null value or a value truncation)
       </para>
-->
<para>
      描述符（标识一个空值或者一个截断的值）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> (integer)</term>
      <listitem>
       <!--
<para>
        not implemented
       </para>
-->
<para>
         未实现
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> (integer)</term>
      <listitem>
       <!--
<para>
        length of the datum in characters
       </para>
-->
<para>
       字符中数据长度
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <!--
<para>
        name of the column
       </para>
-->
<para>
        字段名称
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> (integer)</term>
      <listitem>
       <!--
<para>
        not implemented
       </para>
-->
<para>
        未实现
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <!--
<para>
        length of the character representation of the datum in bytes
       </para>
-->
<para>
        字节数据的字符表示的长度
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> (integer)</term>
      <listitem>
       <!--
<para>
        precision (for type <type>numeric</type>)
       </para>
-->
<para>
       精度（类型<type>numeric</type>）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> (integer)</term>
      <listitem>
       <!--
<para>
        length of the datum in characters
       </para>
-->
<para>
         字符中数据长度 
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <!--
<para>
        length of the character representation of the datum in bytes
       </para>
-->
<para>
         字节数据的字符表示的长度
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> (integer)</term>
      <listitem>
       <!--
<para>
        scale (for type <type>numeric</type>)
       </para>
-->
<para>
        比例（类型<type>numeric</type>）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> (integer)</term>
      <listitem>
       <!--
<para>
        numeric code of the data type of the column
       </para>
-->
<para>
        字段数据类型的数值代码 
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  
<para>
    <!--
    In <command>EXECUTE</command>, <command>DECLARE</command> and <command>OPEN</command>
    statements, the effect of the <literal>INTO</literal> and <literal>USING</literal>
    keywords are different. A Descriptor Area can also be manually built to
    provide the input parameters for a query or a cursor and
    <literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>
    is the way to pass the input parameters into a parametrized query. The statement
    to build a named SQL Descriptor Area is below:
-->
在<command>EXECUTE</command>, <command>DECLARE</command>和<command>OPEN</command>
语句中，<literal>INTO</literal>和<literal>USING</literal>关键字的作用是不同的。
描述符范围可以手动的编译，为一个查询或者游标提供输入参数，
并且<literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>是传递输入参数给一个参数化查询的一种方式。
编译命名SQL描述符范围的语句如下：

<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>

  
<para>
     <!--
    PostgreSQL supports retrieving more that one record in one <command>FETCH</command>
    statement and storing the data in host variables in this case assumes that the
    variable is an array. E.g.:
-->
PostgreSQL支持检索更多的在一个<command>FETCH</command>语句中的记录和存储在宿主变量中的数据，
在这种情况下假设变量是一个数组。例如：

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
  <!--
   <title>SQLDA Descriptor Areas</title>
  -->
   <title>SQLDA描述符范围</title>

   
<para>
    <!--
    An SQLDA Descriptor Area is a C language structure which can be also used
    to get the result set and the metadata of a query. One structure stores one
    record from the result set.
-->
SQLDA描述符范围是一个C语言结构，
它过去常常获取结果集和查询的元数据。
一个结构存储来自结果集中的一条记录。

<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    <!--
    Note that the <literal>SQL</literal> keyword is omitted. The paragraphs about
    the use cases of the <literal>INTO</literal> and <literal>USING</literal>
    keywords in <xref linkend="ecpg-named-descriptors"> also apply here with an addition.
    In a <command>DESCRIBE</command> statement the <literal>DESCRIPTOR</literal>
    keyword can be completely omitted if the <literal>INTO</literal> keyword is used:
    -->
注意省略<literal>SQL</literal>关键字。
<xref linkend="ecpg-named-descriptors">中的<literal>INTO</literal>和<literal>USING</literal>关键字的
使用情况的段落有个例外，
也能适用于这里。在<command>DESCRIBE</command>语句中，如果使用了<literal>INTO</literal>关键字，
则<literal>DESCRIPTOR</literal>关键字完全省略。

<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>

    <procedure>
     <!--
<para>
      The general flow of a program that uses SQLDA is:
     </para>
-->
<para> 
      使用SQLDA程序流是：
</para>
     <!--
     <step><simpara>Prepare a query, and declare a cursor for it.</simpara></step>
     <step><simpara>Declare an SQLDA for the result rows.</simpara></step>
     <step><simpara>Declare an SQLDA for the input parameters, and initialize them (memory allocation, parameter settings).</simpara></step>
     <step><simpara>Open a cursor with the input SQLDA.</simpara></step>
     <step><simpara>Fetch rows from the cursor, and store them into an output SQLDA.</simpara></step>
     <step><simpara>Read values from the output SQLDA into the host variables (with conversion if necessary).</simpara></step>
     <step><simpara>Close the cursor.</simpara></step>
     <step><simpara>Free the memory area allocated for the input SQLDA.</simpara></step>
     -->
 <step><simpara>准备一个查询，并且为它声明一个游标。</simpara></step>
     <step><simpara>为结果行声明SQLDA。</simpara></step>
     <step><simpara>为输入参数声明SQLDA，并且初始化它们(内存分配，参数设置)。</simpara></step>
     <step><simpara>打开具有输入SQLDA的游标</simpara></step>
     <step><simpara>从游标中抓取行，并且将它们存储到输出SQLDA中。</simpara></step>
     <step><simpara>从输出SQLDA中读取值到宿主变量中 (如果有必要使用转换)。</simpara></step>
     <step><simpara>关闭游标。</simpara></step>
     <step><simpara>自由内存区域分配给输入SQLDA。</simpara></step>
</procedure>

   <sect3>
   <!--
    <title>SQLDA Data Structure</title>
   -->
     <title>SQLDA数据结构</title>

    <!--
<para>
     SQLDA uses three data structure
     types: <type>sqlda_t</type>, <type>sqlvar_t</type>,
     and <type>struct sqlname</type>.
    </para>
-->
<para>
    SQLDA使用三个数据结构类型：<type>sqlda_t</type>，<type>sqlvar_t</type>,
    和<type>struct sqlname</type>。
</para>

    <tip>
     <!--
<para>
      PostgreSQL's SQLDA has a similar data structure to the one in
      IBM DB2 Universal Database, so some technical information on
      DB2's SQLDA could help understanding PostgreSQL's one better.
     </para>
-->
<para>
    PostgreSQL的SQLDA与IBM DB2通用数据库中的一个有类似的数据结构。
所以DB2的SQLDA上的一些技术信息可以更好的帮助理解PostgreSQL的。
</para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
<!--
     <title>sqlda_t Structure</title>
 -->
 <title>sqlda_t 结构</title>

     <!--
<para>
      The structure type <type>sqlda_t</type> is the type of the
      actual SQLDA.  It holds one record.  And two or
      more <type>sqlda_t</type> structures can be connected in a
      linked list with the pointer in
      the <structfield>desc_next</structfield> field, thus
      representing an ordered collection of rows.  So, when two or
      more rows are fetched, the application can read them by
      following the <structfield>desc_next</structfield> pointer in
      each <type>sqlda_t</type> node.
     </para>
-->
<para>
      结构类型<type>sqlda_t</type>是实际SQLDA的类型。
  它拥有一条记录。并且在链表中使用<structfield>desc_next</structfield>
  字段指针可以连接两个或更多个<type>sqlda_t</type>结构，
  因此代表行的有序集合。因此，当抓取两个或更多行时，
  应用程序通过每个<type>sqlda_t</type>节点
  随后<structfield>desc_next</structfield>指针可以读取它们。
  
</para>

     
<para>
     <!--
      The definition of <type>sqlda_t</type> is:
 -->
   <type>sqlda_t</type>的定义是：
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

     <!--
      The meaning of the fields is:
 -->
  该字段的意思是：

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</></term>
      <listitem>
       <para>
    <!--
        It contains the literal string <literal>"SQLDA  "</literal>.
-->
它包含文本字符串<literal>"SQLDA  "</literal>。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</></term>
      <listitem>
       <!--
<para>
        It contains the size of the allocated space in bytes.
       </para>
-->
<para>
       它包含字节中分配空间的大小。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</></term>
      <listitem>
       <!--
<para>
        It contains the number of input parameters for a parametrized query
        case it's passed into <command>OPEN</command>, <command>DECLARE</command> or
        <command>EXECUTE</command> statements using the <literal>USING</literal>
        keyword. In case it's used as output of <command>SELECT</command>,
        <command>EXECUTE</command> or <command>FETCH</command> statements,
        its value is the same as <literal>sqld</literal>
        statement
       </para>
-->
<para>
      它包含一个参数化查询的情况下的输入参数数，
  使用<literal>USING</literal>关键字被传递给<command>OPEN</command>, <command>DECLARE</command>或者
       <command>EXECUTE</command>语句。
  在这种情况下它被作为<command>SELECT</command>,
        <command>EXECUTE</command>或者<command>FETCH</command>语句的输出使用。
  它的值和<literal>sqld</literal>语句是一样的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</></term>
      <listitem>
       <!--
<para>
        It contains the number of fields in a result set.
       </para>
-->
<para>
        它包含结果集中的字段数量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</></term>
      <listitem>
       <!--
<para>
        If the query returns more than one record, multiple linked
        SQLDA structures are returned, and <literal>desc_next</> holds
        a pointer to the next entry in the list.
       </para>
-->
<para>
       如果查询返回多条记录，那么返回多个链接SQLDA结构，
   并且<literal>desc_next</>持有指向列表中下一项的指针。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</></term>
      <listitem>
       <!--
<para>
        This is the array of the columns in the result set.
       </para>
-->
<para>
        这是结构集中列数组。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
<!--
     <title>sqlvar_t Structure</title>
-->
  <title>sqlvar_t结构</title>

     
<para>
     <!--
      The structure type <type>sqlvar_t</type> holds a column value
      and metadata such as type and length. The definition of the type
      is:
     -->
 结构类型<type>sqlvar_t</type>持有列值和元数据比如类型和长度。
 该类型的定义是：
<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>
      <!--
      The meaning of the fields is:
      -->
  该字段的含义是：
        <variablelist>
         <varlistentry>
         <term><literal>sqltype</></term>
          <listitem>
           <para>
    <!--
            Contains the type identifier of the field. For values,
            see <literal>enum ECPGttype</literal> in <literal>ecpgtype.h</literal>.
            -->
包含该字段的类型标识符。
对于该值，参阅<literal>ecpgtype.h</literal>中的<literal>enum ECPGttype</literal>。
   </para>

          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</></term>
          <listitem>
           <!--
<para>
            Contains the binary length of the field. e.g. 4 bytes for <type>ECPGt_int</type>.
           </para>
-->
<para>
           包含该字段的二进制长度。比如4字节的<type>ECPGt_int</type>。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</></term>
          <listitem>
           <!--
<para>
            Points to the data.  The format of the data is described
            in <xref linkend="ecpg-variables-type-mapping">.
           </para>
-->
<para>
        指向该数据。关于数据的格式在<xref linkend="ecpg-variables-type-mapping">
中描述。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</></term>
          <listitem>
           <!--
<para>
            Points to the null indicator.  0 means not null, -1 means
            null.
           </para>
-->
<para>
           指向空指示器。0表示非空，-1表示空。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</></term>
          <listitem>
           <!--
<para>
            The name of the field.
           </para>
-->
<para>
            该字段名称。
</para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
<!--
     <title>struct sqlname Structure</title>
    -->
   <title>struct sqlname结构</title>
     
<para>
      <!--
      A <type>struct sqlname</type> structure holds a column name.  It
      is used as a member of the <type>sqlvar_t</type> structure.  The
      definition of the structure is:
  -->
  <type>struct sqlname</type>结构持有列名。
  它作为<type>sqlvar_t</type>结构成员被使用。
  该结构定义是：
  
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      <!--
      The meaning of the fields is:
  -->
  该字段含义是：
            <variablelist>
             <varlistentry>
              <term><literal>length</></term>
               <listitem>
                <para>
                 <!--
                 Contains the length of the field name.
 -->
 包含该字段名长度。
                </para>

               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</></term>
               <listitem>
                <!--
<para>
                 Contains the actual field name.
                </para>
-->
<para>
         包含实际字段名。 
</para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
   <!--
    <title>Retrieving a Result Set Using an SQLDA</title>
   -->
    <title>使用SQLDA检索结果集</title>
    <procedure>
     <!--
<para>
      The general steps to retrieve a query result set through an
      SQLDA are:
     </para>
-->
<para>
     通过SQLDA检索查询结果集的一般步骤是：
</para>
     <!--
     <step><simpara>Declare an <type>sqlda_t</type> structure to receive the result set.</simpara></step>
     <step><simpara>Execute <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> commands to process a query specifying the declared SQLDA.</simpara></step>
     <step><simpara>Check the number of records in the result set by looking at <structfield>sqln</>, a member of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Get the values of each column from <literal>sqlvar[0]</>, <literal>sqlvar[1]</>, etc., members of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Go to next row (<type>sqlda_t</type> structure) by following the <structfield>desc_next</> pointer, a member of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Repeat above as you need.</simpara></step>
 -->
 
 <step><simpara>声明<type>sqlda_t</type>结构用来接收结果集。</simpara></step>
     <step><simpara>执行<command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</>命令用来处理指定已声明SQLDA的查询。</simpara></step>
     <step><simpara>通过查看<structfield>sqln</>检查结果集中的记录数，<type>sqlda_t</type>结构成员。</simpara></step>
     <step><simpara>从<literal>sqlvar[0]</>, <literal>sqlvar[1]</>等中获得每列的值，<type>sqlda_t</type>结构成员</simpara></step>
     <step><simpara>通过<structfield>desc_next</>指针转到下一行(<type>sqlda_t</type>结构)，<type>sqlda_t</type>结构成员。</simpara></step>
     <step><simpara>你需要重复以上步骤</simpara></step>
 
    </procedure>

    <!--
<para>
     Here is an example retrieving a result set through an SQLDA.
    </para>
-->
<para>
     这是一个通过SQLDA检索结果集的例子。
</para>

    
<para>
     <!--
     First, declare a <type>sqlda_t</type> structure to receive the result set.
     -->
 首先，声明一个<type>sqlda_t</type>结构以接收结果集。
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>

    
<para>
    <!--
     Next, specify the SQLDA in a command.  This is
     a <command>FETCH</> command example.
-->
 接下来，在命令中声明SQLDA。这是<command>FETCH</>命令实例。
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

   
<para>
      <!--
     Run a loop following the linked list to retrieve the rows.
 -->
 在链接表后运行循环以检索行。
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>

    
<para>
    <!--
     Inside the loop, run another loop to retrieve each column data
     (<type>sqlvar_t</type> structure) of the row.
-->
 在循环中，运行另外一个循环以检索行中的每列数据（<type>sqlvar_t</type>结构）。
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
} 
</programlisting>
    </para>

    
<para>
    <!--
     To get a column value, check the <structfield>sqltype</> value,
     a member of the <type>sqlvar_t</type> structure.  Then, switch
     to an appropriate way, depending on the column type, to copy
     data from the <structfield>sqlvar</> field to a host variable.
-->
为了得到列值，检查<structfield>sqltype</>值，<type>sqlvar_t</type>结构成员。然后，
切换适当方式，依赖于列类型，从宿主变量<structfield>sqlvar</>字段拷贝数据。

<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
   <!--
    <title>Passing Query Parameters Using an SQLDA</title>
   -->
     <title>使用SQLDA传递查询参数</title>
 
    <procedure>
     <!--
<para>
      The general steps to use an SQLDA to pass input
      parameters to a prepared query are:
     </para>
-->
<para>
     使用SQLDA传递输入参数给预备查询的一般步骤是：
</para>
     <!--
     <step><simpara>Create a prepared query (prepared statement)</simpara></step>
     <step><simpara>Declare a sqlda_t structure as an input SQLDA.</simpara></step>
     <step><simpara>Allocate memory area (as sqlda_t structure) for the input SQLDA.</simpara></step>
     <step><simpara>Set (copy) input values in the allocated memory.</simpara></step>
     <step><simpara>Open a cursor with specifying the input SQLDA.</simpara></step>
     -->
 
 <step><simpara>创建预备查询(预备语句)</simpara></step>
     <step><simpara>作为输入SQLDA声明sqlda_t结构。</simpara></step>
     <step><simpara>为了输入SQLDA分配内存区域(作为sqlda_t结构)。</simpara></step>
     <step><simpara>在已分配内存中设置（拷贝）输入值。</simpara></step>
     <step><simpara>打开具有声明输入SQLDA的游标。</simpara></step>
 
</procedure>

    <!--
<para>
     Here is an example.
    </para>
-->
<para>
     这有个例子。
</para>

    
<para>
    <!--
     First, create a prepared statement.
-->
 首先，创建一个预备语句。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>


    
<para>
    <!--
     Next, allocate memory for an SQLDA, and set the number of input
     parameters in <structfield>sqln</>, a member variable of
     the <type>sqlda_t</type> structure.  When two or more input
     parameters are required for the prepared query, the application
     has to allocate additional memory space which is calculated by
     (nr. of params - 1) * sizeof(sqlvar_t).  The example shown here
     allocates memory space for two input parameters.
-->
下一步，为SQLDA分配内存，并且在<structfield>sqln</>中设置输入参数数，
<type>sqlda_t</type>结构成员变量。
当预备查询需要两个或更多个输入参数的时候，应用程序必须分配额外内存空间，它
是通过(nr. of params - 1) * sizeof(sqlvar_t)计算的。
这里显示的是为两个输入参数分配内存空间的例子。

<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* number of input variables */
</programlisting>
    </para>

   
<para>
      <!--
     After memory allocation, store the parameter values into the
     <literal>sqlvar[]</literal> array.  (This is same array used for
     retrieving column values when the SQLDA is receiving a result
     set.)  In this example, the input parameters
     are <literal>"postgres"</literal>, having a string type,
     and <literal>1</literal>, having an integer type.
 -->
 内存分配后，存储参数值到<literal>sqlvar[]</literal>数组。
 （当该SQLDA正在接收结果集时，这是用于检索列值的相同数组。）
 在这个例子中，输入参数是有字符串类型的<literal>"postgres"</literal>，
 以及有整数类型的<literal>1</literal>。
 
 
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

    
<para>
    <!--
     By opening a cursor and specifying the SQLDA that was set up
     beforehand, the input parameters are passed to the prepared
     statement.
-->
打开游标并且声明事先准备的SQLDA，将输入参数传递给预备语句。
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>


    
<para>
     <!--
     Finally, after using input SQLDAs, the allocated memory space
     must be freed explicitly, unlike SQLDAs used for receiving query
     results.
 -->
 最后，使用输入SQLDA之后，必须显式释放已分配内存空间，不像用于接收查询
 结果的SQLDA。
<programlisting>
free(sqlda2);
</programlisting>
    </para>

   </sect3>

   <sect3 id="ecpg-sqlda-example">
   <!--
    <title>A Sample Application Using SQLDA</title>
   -->
    <title>使用SQLDA示例应用程序</title>

    <!--
<para>
     Here is an example program, which describes how to fetch access
     statistics of the databases, specified by the input parameters,
     from the system catalogs.
    </para>
-->
<para>
    这是一个示例程序，描述了如何获取数据库访问统计，通过输入参数声明，来自系统表。
</para>

    <!--
<para>
     This application joins two system tables, pg_database and
     pg_stat_database on the database OID, and also fetches and shows
     the database statistics which are retrieved by two input
     parameters (a database <literal>postgres</literal>, and OID <literal>1</literal>).
    </para>
-->
<para>
    这个应用程序连接两个系统表，数据库OID上的pg_database和
    pg_stat_database，并且读取、显示由两个输入参数（<literal>postgres</literal>和OID <literal>1</literal>）检索的数据库统计。
</para>

    
<para>
     <!--
     First, declare an SQLDA for input and an SQLDA for output.
 -->
 首先，为输入声明SQLDA，以及为输出声明SQLDA。
<programlisting>
EXEC SQL include sqlda.h;

<!--
sqlda_t *sqlda1; /* an output descriptor */
sqlda_t *sqlda2; /* an input descriptor  */
-->

sqlda_t *sqlda1; /*输出描述符*/
sqlda_t *sqlda2; /*输入描述符*/

</programlisting>
    </para>

    
<para>
     <!--
     Next, connect to the database, prepare a statement, and declare a
     cursor for the prepared statement.
 -->
 下一步，连接数据库，准备语句，并且为预备语句声明游标。
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>


    
<para>
    <!--
     Next, put some values in the input SQLDA for the input
     parameters.  Allocate memory for the input SQLDA, and set the
     number of input parameters to <literal>sqln</literal>.  Store
     type, value, and value length into <literal>sqltype</literal>,
     <literal>sqldata</literal>, and <literal>sqllen</literal> in the
     <literal>sqlvar</literal> structure.
    -->
接下来，为输入参数将一些值放在输入SQLDA中。为输入SQLDA分配内存，并且设置
输入参数数到<literal>sqln</literal>。存储类型，值以及值长度到<literal>sqltype</literal>，<literal>sqldata</literal>中，
    并且将<literal>sqllen</literal>放在<literal>sqlvar</literal>结构中。
<programlisting>
    <!--
    /* Create SQLDA structure for input parameters. */
-->
/*为输入参数创建SQLDA结构 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

<!--
    sqlda2->sqln = 2; /* number of input variables */
-->
sqlda2->sqln = 2; /*输入变量数*/

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>


    
<para>
     <!--
     After setting up the input SQLDA, open a cursor with the input
     SQLDA.
    -->
 在建立输入SQLDA后，打开具有输入SQLDA的一个游标。
<programlisting>
    <!--
    /* Open a cursor with input parameters. */
-->

/*打开具有输入参数的游标。*/

    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

</programlisting>
    </para>


    
<para>
    <!--
     Fetch rows into the output SQLDA from the opened cursor.
     (Generally, you have to call <command>FETCH</command> repeatedly
     in the loop, to fetch all rows in the result set.)
-->
从已打开的游标中读取行到输出SQLDA。（一般来说，你必须在循环中反复调用<command>FETCH</command>，
为了读取结果集中的所有行。）
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

<!--
        /* Assign descriptor to the cursor  */
-->
/*分配描述符给游标*/

        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

    
<para>
     <!--
     Next, retrieve the fetched records from the SQLDA, by following
     the linked list of the <type>sqlda_t</type> structure.
 -->
 接下来，从SQLDA中检索已读取记录，通过下面<type>sqlda_t</type>结构中
 的连接表。
 
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>


    
<para>
    <!--
     Read each columns in the first record.  The number of columns is
     stored in <structfield>sqld</>, the actual data of the first
     column is stored in <literal>sqlvar[0]</>, both members of
     the <type>sqlda_t</type> structure.
    -->
 读取第一条记录中的每一列。列数被存储在<structfield>sqld</>中，
 第一列的实际数据被存储在<literal>sqlvar[0]</>，<type>sqlda_t</type>结构的两个
 成员中。
<programlisting>
   
        <!--
        /* Print every column in a row. */
-->
/* 输出行中每一列*/
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>

    
<para>
    <!--
     Now, the column data is stored in the variable <varname>v</>.
     Copy every datum into host variables, looking
     at <literal>v.sqltype</> for the type of the column.
-->
 目前，该列数据被存储在变量<varname>v</>中。拷贝每个数据到宿主变量，
 为了列类型查看<literal>v.sqltype</>。
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>


    
<para>
     <!--
     Close the cursor after processing all of records, and disconnect
     from the database.
 -->
 在处理完所有记录之后关闭游标，并且断开数据库连接。
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>


    <!--
<para>
     The whole program is shown
     in <xref linkend="ecpg-sqlda-example-example">.
    </para>
-->
<para>
    在<xref linkend="ecpg-sqlda-example-example">中显示了整个程序。
</para>

    <example id="ecpg-sqlda-example-example">
<!--
     <title>Example SQLDA Program</title>
 -->
 <title>SQLDA程序示例</title>
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

<!--
sqlda_t *sqlda1; /* descriptor for output */
sqlda_t *sqlda2; /* descriptor for input */
-->

sqlda_t *sqlda1; /*输出描述符*/
sqlda_t *sqlda2; /*输入描述符*/

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

<!--
    /* Create a SQLDA structure for an input parameter */
-->
/*为输入参数创建SQLDA结构*/

    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* a number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

<!--
    /* Open a cursor with input parameters. */
-->
/*打开具有输入参数的游标*/

    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

<!--
        /* Assign descriptor to the cursor  */
-->
/*分配描述符给游标*/ 
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

<!--
            /* Print every column in a row. */
-->
/*输出行中每一列*/
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>

     <!--
<para>
      The output of this example should look something like the
      following (some numbers will vary).
     </para>
-->
<para>
     该例子输出应该看起来像下面这样（一些数字有所不同）。
</para>

<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
 <!--
  <title>Error Handling</title>
 -->
   <title>错误处理</title>

  
<para>
   <!--
   This section describes how you can handle exceptional conditions
   and warnings in an embedded SQL program.  There are two
   nonexclusive facilities for this.
   -->
   本节描述了如何处理异常情况以及嵌入SQL程序的警告。有两个非排他性功能可以解决。
   <itemizedlist>
    <listitem>
     <simpara>
  <!--
      Callbacks can be configured to handle warning and error
      conditions using the <literal>WHENEVER</literal> command.
  -->
  配置回调用来处理警告以及使用<literal>WHENEVER</literal>命令处理错误条件。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
 <!--
      Detailed information about the error or warning can be obtained
      from the <varname>sqlca</varname> variable.
 -->
  关于错误或者警告的详细信息可以从<varname>sqlca</varname>变量中获得。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>


  <sect2 id="ecpg-whenever">
  <!--
   <title>Setting Callbacks</title>
  -->
   <title>设置回调</title>

   
<para>
    <!--
    One simple method to catch errors and warnings is to set a
    specific action to be executed whenever a particular condition
    occurs.  In general:
-->
当产生特定条件时，捕获错误和警告的一个简单方法是设置一个要执行的具体操作。通常：

<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>


   
<para>
    <!--
    <replaceable>condition</replaceable> can be one of the following:
    -->
<replaceable>condition</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
    <!--
        The specified action is called whenever an error occurs during
        the execution of an SQL statement.
-->
当在SQL语句执行期间发生错误时，调用指定操作。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <!--
<para>
        The specified action is called whenever a warning occurs
        during the execution of an SQL statement.
       </para>
-->
<para>
       当在SQL语句执行期间发生警告时，调用指定操作。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <!--
<para>
        The specified action is called whenever an SQL statement
        retrieves or affects zero rows.  (This condition is not an
        error, but you might be interested in handling it specially.)
       </para>
-->
<para>
      当SQL语句检索或者影响零行，则调用指定操作。（这个条件不是错误，
  但是你可能对特意处理它感兴趣。）
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   
<para>
    <!--
    <replaceable>action</replaceable> can be one of the following:
-->
<replaceable>action</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
    <!--
        This effectively means that the condition is ignored.  This is
        the default.
-->
这实际上意味着该条件被忽略。这是缺省的。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <!--
<para>
        Jump to the specified label (using a C <literal>goto</literal>
        statement).
       </para>
-->
<para>
      跳转到指定标签（使用C <literal>goto</literal>语句）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <!--
<para>
        Print a message to standard error.  This is useful for simple
        programs or during prototyping.  The details of the message
        cannot be configured.
       </para>
-->
<para>
     输出消息到标准错误。这对于简单程度或者原型期间非常有用。
 不能配置该消息的详细信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <!--
<para>
        Call <literal>exit(1)</literal>, which will terminate the
        program.
       </para>
-->
<para>
        调用<literal>exit(1)</literal>，这将终止程序。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <!--
<para>
        Execute the C statement <literal>break</literal>.  This should
        only be used in loops or <literal>switch</literal> statements.
       </para>
-->
<para>
       执行C语句<literal>break</literal>。这只有在循环中或者<literal>switch</literal>
   语句中使用。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <!--
<para>
        Call the specified C functions with the specified arguments.
       </para>
-->
<para>
       调用具有指定参数的指定C函数。
</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <!--
    The SQL standard only provides for the actions
    <literal>CONTINUE</literal> and <literal>GOTO</literal> (and
    <literal>GO TO</literal>).
-->
SQL标准仅仅提供<literal>CONTINUE</literal>和<literal>GOTO</literal> 
(和<literal>GO TO</literal>）操作。
   </para>

   
<para>
    <!--
    Here is an example that you might want to use in a simple program.
    It prints a simple message when a warning occurs and aborts the
    program when an error happens:
-->
    下面是一个你可能想在简单程序中使用的例子。当发生警告以及发生错误终止程序时，
它输出一个简单消息：

<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>


   
<para>
    <!--
    The statement <literal>EXEC SQL WHENEVER</literal> is a directive
    of the SQL preprocessor, not a C statement.  The error or warning
    actions that it sets apply to all embedded SQL statements that
    appear below the point where the handler is set, unless a
    different action was set for the same condition between the first
    <literal>EXEC SQL WHENEVER</literal> and the SQL statement causing
    the condition, regardless of the flow of control in the C program.
    So neither of the two following C program excerpts will have the
    desired effect:
-->
语句<literal>EXEC SQL WHENEVER</literal>是SQL预处理器的指令。
而不是C语句。
错误或者警告操作设置处理器出现的地方中适用的所有嵌入SQL语句。
除非在第一个<literal>EXEC SQL WHENEVER</literal>和产生条件的SQL语句之间
为同一条件设置不同的操作，不管C程序中的控制流。
所以下面两个C程序片段都不会产生期望效果：
<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>

  </sect2>

  <sect2 id="ecpg-sqlca">
   <title>sqlca</title>

   
<para>
    <!--
    For more powerful error handling, the embedded SQL interface
    provides a global variable with the name <varname>sqlca</varname>
    (SQL communication area)
    that has the following structure:
-->
为了更强大的错误处理，
嵌入SQL接口提供了使用下列结构的名字<varname>sqlca</varname>（SQL通信区）
的全局变量。

<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
     <!--
    (In a multithreaded program, every thread automatically gets its
    own copy of <varname>sqlca</varname>.  This works similarly to the
    handling of the standard C global variable
    <varname>errno</varname>.)
-->
（在一个多线程程序中，每一个线程自动获取<varname>sqlca</varname>
的拷贝。该工作类似于标准C全局变量<varname>errno</varname>的处理。）
   </para>

   <!--
<para>
    <varname>sqlca</varname> covers both warnings and errors.  If
    multiple warnings or errors occur during the execution of a
    statement, then <varname>sqlca</varname> will only contain
    information about the last one.
   </para>
-->
<para>
    <varname>sqlca</varname>涵盖警告和错误。如果在语句执行期间发生
多个警告和错误，那么<varname>sqlca</varname>将只包含最后一个信息。
</para>

   <!--
<para>
    If no error occurred in the last <acronym>SQL</acronym> statement,
    <literal>sqlca.sqlcode</literal> will be 0 and
    <literal>sqlca.sqlstate</literal> will be
    <literal>"00000"</literal>.  If a warning or error occurred, then
    <literal>sqlca.sqlcode</literal> will be negative and
    <literal>sqlca.sqlstate</literal> will be different from
    <literal>"00000"</literal>.  A positive
    <literal>sqlca.sqlcode</literal> indicates a harmless condition,
    such as that the last query returned zero rows.
    <literal>sqlcode</literal> and <literal>sqlstate</literal> are two
    different error code schemes; details appear below.
   </para>
-->
<para>
    如果在最后<acronym>SQL</acronym>语句没有发生错误，则<literal>sqlca.sqlcode</literal>为0，
<literal>sqlca.sqlstate</literal>是
    <literal>"00000"</literal>。如果发生了警告或者错误，那么
 <literal>sqlca.sqlcode</literal>是负数并且
    <literal>sqlca.sqlstate</literal>不同于
    <literal>"00000"</literal>。正数<literal>sqlca.sqlcode</literal>
表示无害条件，比如最后查询返回零行。
<literal>sqlcode</literal>和<literal>sqlstate</literal>是两个
不同的错误编码方案；详情如下。
</para>

   <!--
<para>
    If the last SQL statement was successful, then
    <literal>sqlca.sqlerrd[1]</literal> contains the OID of the
    processed row, if applicable, and
    <literal>sqlca.sqlerrd[2]</literal> contains the number of
    processed or returned rows, if applicable to the command.
   </para>
-->
<para>
   如果最后一个SQL语句成功了，那么<literal>sqlca.sqlerrd[1]</literal>
   包含处理行的OID，如果适用，则<literal>sqlca.sqlerrd[2]</literal>
   包含处理或返回行的行数，如果适用该命令。
</para>

   <!--
<para>
    In case of an error or warning,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> will contain a string
    that describes the error.  The field
    <literal>sqlca.sqlerrm.sqlerrml</literal> contains the length of
    the error message that is stored in
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (the result of
    <function>strlen()</function>, not really interesting for a C
    programmer).  Note that some messages are too long to fit in the
    fixed-size <literal>sqlerrmc</literal> array; they will be truncated.
   </para>
-->
<para>
    在错误或警告的情况下，<literal>sqlca.sqlerrm.sqlerrmc</literal>
将包含描述错误的字符串。字段<literal>sqlca.sqlerrm.sqlerrml</literal>
包含存储在<literal>sqlca.sqlerrm.sqlerrmc</literal>
（<function>strlen()</function>的结果，C程序员不感兴趣）中的错误消息。
注意一些消息太长而不适合固定大小的<literal>sqlerrmc</literal>数组；
它们将被截断。
</para>

   <!--
<para>
    In case of a warning, <literal>sqlca.sqlwarn[2]</literal> is set
    to <literal>W</literal>.  (In all other cases, it is set to
    something different from <literal>W</literal>.)  If
    <literal>sqlca.sqlwarn[1]</literal> is set to
    <literal>W</literal>, then a value was truncated when it was
    stored in a host variable.  <literal>sqlca.sqlwarn[0]</literal> is
    set to <literal>W</literal> if any of the other elements are set
    to indicate a warning.
   </para>
-->
<para>
    在一个警告的情况下，<literal>sqlca.sqlwarn[2]</literal>设置为
<literal>W</literal>。（在所有其他情况下，它被设置为不同于<literal>W</literal>
的东西。）如果<literal>sqlca.sqlwarn[1]</literal>被设置为
    <literal>W</literal>，那么一个值被存储在宿主变量的时候，截断它。
如果任何其他元素设置为显示一个警告，则<literal>sqlca.sqlwarn[0]</literal>
设置为<literal>W</literal>。 
</para>

   <!--
<para>
    The fields <structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>, and the remaining elements of
    <structfield>sqlerrd</structfield> and
    <structfield>sqlwarn</structfield> currently contain no useful
    information.
   </para>
-->
<para>
    字段<structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>，以及
    <structfield>sqlerrd</structfield>和
    <structfield>sqlwarn</structfield>的剩余元素
目前没有任何有用信息。
</para>

   <!--
<para>
    The structure <varname>sqlca</varname> is not defined in the SQL
    standard, but is implemented in several other SQL database
    systems.  The definitions are similar at the core, but if you want
    to write portable applications, then you should investigate the
    different implementations carefully.
   </para>
-->
<para>
   在SQL标准中没有定义结构<varname>sqlca</varname>，
   但是在其他几个SQL数据库系统中实现了。定义核心是相似的，但是如果你想要
   编写可移植应用程序，那么你应该仔细调查不同的实现。
   
</para>

   
<para>
    <!--
    Here is one example that combines the use of <literal>WHENEVER</>
    and <varname>sqlca</varname>, printing out the contents
    of <varname>sqlca</varname> when an error occurs.  This is perhaps
    useful for debugging or prototyping applications, before
    installing a more <quote>user-friendly</quote> error handler.
    -->
这是一个结合<literal>WHENEVER</>和<varname>sqlca</varname>的使用的例子，
当发生错误时，输出<varname>sqlca</varname>的内容。
在安装更多<quote>user-friendly</quote>错误处理程序之前，
这可能用于调试或者原型应用。

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>
    
<!--
    The result could look as follows (here an error due to a
    misspelled table name):
-->
结果可能如下所示（这里错误归因于表名字拼写错误）：

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>

  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
   <title><literal>SQLSTATE</literal> vs. <literal>SQLCODE</literal></title>

   <!--
<para>
    The fields <literal>sqlca.sqlstate</literal> and
    <literal>sqlca.sqlcode</literal> are two different schemes that
    provide error codes.  Both are derived from the SQL standard, but
    <literal>SQLCODE</literal> has been marked deprecated in the SQL-92
    edition of the standard and has been dropped in later editions.
    Therefore, new applications are strongly encouraged to use
    <literal>SQLSTATE</literal>.
   </para>
-->
<para>
    字段<literal>sqlca.sqlstate</literal>和
    <literal>sqlca.sqlcode</literal>是提供错误码的两个不同模式。
两者来自SQL标准，但是<literal>SQLCODE</literal>在标准SQL-92
版本中已经过时，并且在后期版本中已经废除。因此，
强烈建议新应用使用<literal>SQLSTATE</literal>。
</para>

   <!--
<para>
    <literal>SQLSTATE</literal> is a five-character array.  The five
    characters contain digits or upper-case letters that represent
    codes of various error and warning conditions.
    <literal>SQLSTATE</literal> has a hierarchical scheme: the first
    two characters indicate the general class of the condition, the
    last three characters indicate a subclass of the general
    condition.  A successful state is indicated by the code
    <literal>00000</literal>.  The <literal>SQLSTATE</literal> codes are for
    the most part defined in the SQL standard.  The
    <productname>PostgreSQL</productname> server natively supports
    <literal>SQLSTATE</literal> error codes; therefore a high degree
    of consistency can be achieved by using this error code scheme
    throughout all applications.  For further information see
    <xref linkend="errcodes-appendix">.
   </para>
-->
<para>
    <literal>SQLSTATE</literal>是五字符数组。
    五字符包含数字或者表示不同错误和警告条件代码的大写字母。
<literal>SQLSTATE</literal>有一个分层模式：
前两个字符表示条件的一般类，最后三个字符表示一般条件的子类。
通过代码<literal>00000</literal>表示成功状态。
<literal>SQLSTATE</literal>代码是SQL标准中定义最多部分。
<productname>PostgreSQL</productname>服务器本地支持
    <literal>SQLSTATE</literal>错误代码；因此通过在所有应用程序中
使用该错误代码方案实现高度一致性。
更多信息参阅<xref linkend="errcodes-appendix">。
</para>

   <!--
<para>
    <literal>SQLCODE</literal>, the deprecated error code scheme, is a
    simple integer.  A value of 0 indicates success, a positive value
    indicates success with additional information, a negative value
    indicates an error.  The SQL standard only defines the positive
    value +100, which indicates that the last command returned or
    affected zero rows, and no specific negative values.  Therefore,
    this scheme can only achieve poor portability and does not have a
    hierarchical code assignment.  Historically, the embedded SQL
    processor for <productname>PostgreSQL</productname> has assigned
    some specific <literal>SQLCODE</literal> values for its use, which
    are listed below with their numeric value and their symbolic name.
    Remember that these are not portable to other SQL implementations.
    To simplify the porting of applications to the
    <literal>SQLSTATE</literal> scheme, the corresponding
    <literal>SQLSTATE</literal> is also listed.  There is, however, no
    one-to-one or one-to-many mapping between the two schemes (indeed
    it is many-to-many), so you should consult the global
    <literal>SQLSTATE</literal> listing in <xref linkend="errcodes-appendix">
    in each case.
   </para>
-->
<para>
     <literal>SQLCODE</literal>，已废弃的错误编码方案，是一个简单的integer。
 0值表示成功，正值表示附带额外信息的成功，负值表示错误。
 SQL标准仅仅定义正值+100，这表示返回最后命令或者影响零行，并且
 没有明确负值。因此，该方案实现差的移植性，而且没有分层编码安排。
 从历史角度，<productname>PostgreSQL</productname>嵌入的SQL预处理器
 为它的使用分配了一些指定<literal>SQLCODE</literal>。
 使用数值和符号名称将它列在下面。记住这些是不能移植到其他SQL实现的。
 为了简化应用程序移植到<literal>SQLSTATE</literal>方案，相应的
 <literal>SQLSTATE</literal>也被列出来。然而，
 在两个方案（实际上是多对多）之间没有一对一或者一对多映射，
 因此在每种情况下你应该咨询列在<xref linkend="errcodes-appendix">中的全球<literal>SQLSTATE</literal>。
</para>

   
<para> 
    <!--
    These are the assigned <literal>SQLCODE</literal> values:
    -->
这些是已分配的<literal>SQLCODE</literal>值：
    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
   <!--
        Indicates no error. (SQLSTATE 00000)
   -->
     表明没有错误。(SQLSTATE 00000)
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <!--
<para>
       This is a harmless condition indicating that the last command
       retrieved or processed zero rows, or that you are at the end of
       the cursor.  (SQLSTATE 02000)
      </para>
-->
<para>
     这是无害条件表明检索最后一条命令或者处理零行，或者你在游标结尾。(SQLSTATE 02000)
</para>

      
<para>
     <!--
       When processing a cursor in a loop, you could use this code as
       a way to detect when to abort the loop, like this:
 -->
   当在循环中处理游标时，你可以使用该代码作为检测什么时候终止循环的方式，像这样：
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
      <!--
       But <literal>WHENEVER NOT FOUND DO BREAK</literal> effectively
       does this internally, so there is usually no advantage in
       writing this out explicitly.
  -->
   但是<literal>WHENEVER NOT FOUND DO BREAK</literal>有效的内部执行这个，因此
   在明确写这个时通常没有优势。 
      </para>

     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <!--
<para>
        Indicates that your virtual memory is exhausted.  The numeric
        value is defined as <literal>-ENOMEM</literal>.  (SQLSTATE
        YE001)
      </para>
-->
<para>
     表明耗尽了你的虚拟内存。作为<literal>-ENOMEM</literal>定义该数值。
 (SQLSTATE YE001)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <!--
<para>
       Indicates the preprocessor has generated something that the
       library does not know about.  Perhaps you are running
       incompatible versions of the preprocessor and the
       library. (SQLSTATE YE002)
      </para>
-->
<para>
     表明预处理器产生了该库不知道的一些东西。可能你正在该预处理器和该库不兼容版本上运行。(SQLSTATE YE002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <!--
<para>
       This means that the command specified more host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
-->
<para>
     这意味着指定命令比期望命令宿主变量更多。(SQLSTATE 07001或者07002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <!--
<para>
       This means that the command specified fewer host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
-->
<para>
     这意味着指定命令比期望命令宿主变量更少。(SQLSTATE 07001或者07002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <!--
<para>
       This means a query has returned multiple rows but the statement
       was only prepared to store one result row (for example, because
       the specified variables are not arrays).  (SQLSTATE 21000)
      </para>
-->
<para>
      这意味着查询返还多行但是语句只准备存储一个结果行（比如，
  因为指定变量不是数组）。(SQLSTATE 21000)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>int</type> and the datum in
       the database is of a different type and contains a value that
       cannot be interpreted as an <type>int</type>.  The library uses
       <function>strtol()</function> for this conversion.  (SQLSTATE
       42804)
      </para>
-->
<para>
     宿主变量是类型<type>int</type>，并且数据库中数据是不同类型，而且
  包含不能解释为<type>int</type>类型的值。 
  为这种转换该库使用<function>strtol()</function>。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>unsigned int</type> and the
       datum in the database is of a different type and contains a
       value that cannot be interpreted as an <type>unsigned
       int</type>.  The library uses <function>strtoul()</function>
       for this conversion.  (SQLSTATE 42804)
      </para>
-->
<para>
     宿主变量是类型<type>无符号int</type>，并且数据库中数据是不同类型，而且
  包含不能解释为<type>无符号int</type>类型的值。 
  为这种转换该库使用<function>strtoul()</function>。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>float</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>float</type>.  The library
       uses <function>strtod()</function> for this conversion.
       (SQLSTATE 42804)
      </para>
-->
<para>
     宿主变量是类型<type>float</type>，并且数据库中数据是另一种类型，而且
  包含不能解释为<type>float</type>类型的值。
  为这种转换该库使用<function>strtod()</function>。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>numeric</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>numeric</type> value.
       (SQLSTATE 42804)
      </para>
-->
<para>
      宿主变量是类型<type>numeric</type>，并且数据库中数据是另一种类型，而且
  包含不能解释为<type>numeric</type>类型的值。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>interval</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as an <type>interval</type> value.
       (SQLSTATE 42804)
      </para>
-->
<para>
      宿主变量是类型<type>interval</type>，并且数据库中数据是另一种类型，而且
  包含不能解释为<type>interval</type>类型的值。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>date</type> and the datum in
       the database is of another type and contains a value that
       cannot be interpreted as a <type>date</type> value.
       (SQLSTATE 42804)
      </para>
-->
<para>
      宿主变量是类型<type>date</type>，并且数据库中数据是另一种类型，而且
  包含不能解释为<type>date</type>类型的值。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <!--
<para>
       The host variable is of type <type>timestamp</type> and the
       datum in the database is of another type and contains a value
       that cannot be interpreted as a <type>timestamp</type> value.
       (SQLSTATE 42804)
      </para>
-->
<para>
      宿主变量是类型<type>timestamp</type>，并且数据库中数据是另一种类型，而且
  包含不能解释为<type>timestamp</type>类型的值。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <!--
<para>
       This means the host variable is of type <type>bool</type> and
       the datum in the database is neither <literal>'t'</> nor
       <literal>'f'</>.  (SQLSTATE 42804)
      </para>
-->
<para>
      这意味着宿主变量是类型<type>bool</type>，
  并且数据库中数据既不是<literal>'t'</>也不是
       <literal>'f'</>。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <!--
<para>
       The statement sent to the <productname>PostgreSQL</productname>
       server was empty.  (This cannot normally happen in an embedded
       SQL program, so it might point to an internal error.)  (SQLSTATE
       YE002)
      </para>
-->
<para>
    发送到<productname>PostgreSQL</productname>服务器的语句是空的。
（这通常不会发生在嵌入SQL程序中，因此它可能指向一个内部错误。）
(SQLSTATE YE002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <!--
<para>
       A null value was returned and no null indicator variable was
       supplied.  (SQLSTATE 22002)
      </para>
-->
<para>
      返回一个空值，而且没有提供空指示符变量。(SQLSTATE 22002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <!--
<para>
       An ordinary variable was used in a place that requires an
       array.  (SQLSTATE 42804)
      </para>
-->
<para>
      一个普通变量被用于需要数组的地方。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <!--
<para>
       The database returned an ordinary variable in a place that
       requires array value.  (SQLSTATE 42804)
      </para>
-->
<para>
     数据库返回需要数组值位置的普通变量。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- disabled by #if 0 in ecpglib -->
    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <!--
<para>
       The value could not be inserted into the array.  (SQLSTATE
       42804)
      </para>
-->
<para>
       该值不能插入到数组中。(SQLSTATE 42804)
</para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <!--
<para>
       The program tried to access a connection that does not exist.
       (SQLSTATE 08003)
      </para>
-->
<para>
      该程序试图访问一个不存在的连接。(SQLSTATE 08003)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <!--
<para>
       The program tried to access a connection that does exist but is
       not open.  (This is an internal error.)  (SQLSTATE YE002)
      </para>
-->
<para>
      该程序试图访问一个存在但无法打开的连接。（这是一个内部错误。）(SQLSTATE YE002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <!--
<para>
       The statement you are trying to use has not been prepared.
       (SQLSTATE 26000)
      </para>
-->
<para>
      你正尝试使用的语句未准备好。(SQLSTATE 26000)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <!--
<para>
       Duplicate key error, violation of unique constraint (Informix
       compatibility mode).  (SQLSTATE 23505)
      </para>
-->
<para>
      重复键错误，违反唯一约束（Informix兼容模式）。(SQLSTATE 23505)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <!--
<para>
       The descriptor specified was not found.  The statement you are
       trying to use has not been prepared.  (SQLSTATE 33000)
      </para>
-->
<para>
      未找到指定描述符。你尝试使用的语句未准备好。(SQLSTATE 33000)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <!--
<para>
       The descriptor index specified was out of range.  (SQLSTATE
       07009)
      </para>
-->
<para>
      指定的描述符索引超出了范围。(SQLSTATE 07009)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <!--
<para>
       An invalid descriptor item was requested.  (This is an internal
       error.)  (SQLSTATE YE002)
      </para>
-->
<para>
       请求无效描述符项。（这是个内部错误。） (SQLSTATE YE002)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <!--
<para>
       During the execution of a dynamic statement, the database
       returned a numeric value and the host variable was not numeric.
       (SQLSTATE 07006)
      </para>
-->
<para>
      在动态语句执行的过程中，数据库返回一个数值，但宿主变量不是数字的。 (SQLSTATE 07006)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <!--
<para>
       During the execution of a dynamic statement, the database
       returned a non-numeric value and the host variable was numeric.
       (SQLSTATE 07006)
      </para>
-->
<para>
     在动态语句执行的过程中，数据库返回一个非数值，
 但宿主变量是数字的。 (SQLSTATE 07006)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <!--
<para>
       A result of the subquery is not single row (Informix
       compatibility mode).  (SQLSTATE 21000)
      </para>
-->
<para>
     子查询结果不是单行（Informix兼容模式）。(SQLSTATE 21000)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <!--
<para>
       Some error caused by the <productname>PostgreSQL</productname>
       server.  The message contains the error message from the
       <productname>PostgreSQL</productname> server.
      </para>
-->
<para>
     <productname>PostgreSQL</productname>服务器产生一些错误。
 包含的错误消息来自<productname>PostgreSQL</productname>服务器。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <!--
<para>
       The <productname>PostgreSQL</productname> server signaled that
       we cannot start, commit, or rollback the transaction.
       (SQLSTATE 08007)
      </para>
-->
<para>
      <productname>PostgreSQL</productname>发出信号我们不能启动，提交，或者回滚事务。
  (SQLSTATE 08007)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <!--
<para>
       The connection attempt to the database did not succeed.
       (SQLSTATE 08001)
      </para>
-->
<para>
      尝试与数据库的连接没有成功。(SQLSTATE 08001)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <!--
<para>
       Duplicate key error, violation of unique constraint.  (SQLSTATE
       23505)
      </para>
-->
<para>
      重复键错误，违反唯一约束。(SQLSTATE 23505)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <!--
<para>
       A result for the subquery is not single row. (SQLSTATE 21000)
      </para>
-->
<para>
       子查询结果不是单行。(SQLSTATE 21000)
</para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- currently not used by the code -->
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <!--
<para>
       An unrecognized warning was received from the server.
      </para>
-->
<para>
      来自服务器无法识别的警告。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <!--
<para>
       Current transaction is aborted.  Queries are ignored until the
       end of the transaction block.
      </para>
-->
<para>
      终止当前事务。忽略查询直到事务块结束。
</para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <!--
<para>
       An invalid cursor name was specified. (SQLSTATE 34000)
      </para>
-->
<para>
      指定一个无效游标名。(SQLSTATE 34000)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <!--
<para>
       Transaction is in progress. (SQLSTATE 25001)
      </para>
-->
<para>
      事务正在进行中。(SQLSTATE 25001)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <!--
<para>
       There is no active (in-progress) transaction. (SQLSTATE 25P01)
      </para>
-->
<para>
      这是一个非活跃（进行中）事务。(SQLSTATE 25P01)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <!--
<para>
       An existing cursor name was specified. (SQLSTATE 42P03)
      </para>
-->
<para>
      指定一个已经存在游标名。(SQLSTATE 42P03)
</para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
 <!--
  <title>Preprocessor Directives</title>
 -->
 <title>预处理器指令</title>

  <!--
<para>
   Several preprocessor directives are available that modify how
   the <command>ecpg</command> preprocessor parses and processes a
   file.
  </para>
-->
<para>
    可用的几种预处理器指令，
它修改<command>ecpg</command>预处理器分析方式以及处理文件方式。
</para>

  <sect2 id="ecpg-include">
  <!--
   <title>Including Files</title>
  -->
   <title>包含文件</title>

   
<para>
    <!--
    To include an external file into your embedded SQL program, use:
-->
为了包含一个外部文件到你的嵌入SQL程序中，使用：

<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    <!--
    The embedded SQL preprocessor will look for a file named
    <literal><replaceable>filename</replaceable>.h</literal>,
    preprocess it, and include it in the resulting C output.  Thus,
    embedded SQL statements in the included file are handled correctly.
-->
嵌入的SQL预处理器将寻找名为<literal><replaceable>filename</replaceable>.h</literal>的文件，
处理它，并且将它包含在产生的C输出中。因此，正确处理包含文件中的嵌入SQL语句。

   </para>


   
<para>
    <!--
    The <command>ecpg</command> preprocessor will search a file at
    several directories in following order:
    -->
<command>ecpg</command>预处理器将按照下面顺序在几个目录中
搜索文件：

    <itemizedlist>
 <!--
     <listitem><simpara>current directory</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL include directory, defined at build time (e.g., <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
     -->
 
 <listitem><simpara>当前目录</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL包含目录，在编译时定义 (比如<filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
 
</itemizedlist>
    
<!--
    But when <literal>EXEC SQL INCLUDE
    "<replaceable>filename</replaceable>"</literal> is used, only the
    current directory is searched.
-->
但是当使用<literal>EXEC SQL INCLUDE
    "<replaceable>filename</replaceable>"</literal>时，仅仅搜索当前目录。
   </para>


   <!--
<para>
    In each directory, the preprocessor will first look for the file
    name as given, and if not found will append <literal>.h</literal>
    to the file name and try again (unless the specified file name
    already has that suffix).
   </para>
-->
<para>
    在每个目录中，预处理器将首先寻找给定的文件名，如果没有找到将追加
<literal>.h</literal>到文件名然后再次尝试（除非指定文件名已经有这种后缀）。
</para>

   
<para>
    <!--
    Note that <command>EXEC SQL INCLUDE</command> is <emphasis>not</emphasis> the same as:
    -->
注意<command>EXEC SQL INCLUDE</command>是<emphasis>不</emphasis>一样的：

<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    <!--
    because this file would not be subject to SQL command preprocessing.
    Naturally, you can continue to use the C
    <literal>#include</literal> directive to include other header
    files.
-->
因为这个文件不受SQL命令预处理的影响。当然，你可以继续使用
包含其他头文件的C <literal>#include</literal>
指令。
   </para>


   <note>
    <!--
<para>
     The include file name is case-sensitive, even though the rest of
     the <literal>EXEC SQL INCLUDE</literal> command follows the normal
     SQL case-sensitivity rules.
    </para>
-->
<para>
     包含文件名大小写敏感，即使其余的<literal>EXEC SQL INCLUDE</literal>
 命令遵循正常的SQL大小写敏感规则。
</para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
  <!--
   <title>The define and undef Directives</title>
  -->
   <title>define和undef指令</title>
   
<para>
    <!--
    Similar to the directive <literal>#define</literal> that is known from C,
    embedded SQL has a similar concept:
-->
类似于C中<literal>#define</literal>指令，嵌入的SQL有一个类似概念：

<programlisting>
EXEC SQL DEFINE <replaceable>name</>;
EXEC SQL DEFINE <replaceable>name</> <replaceable>value</>;
</programlisting>
    <!--
    So you can define a name:
-->
所以你可以定义一个名字：
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
   <!--
    And you can also define constants:
-->
你也可以定义常数：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    <!--
    Use <literal>undef</> to remove a previous definition:
-->
使用<literal>undef</>删除以前的定义：
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>

   
<para>
    <!--
    Of course you can continue to use the C versions <literal>#define</literal>
    and <literal>#undef</literal> in your embedded SQL program. The difference
    is where your defined values get evaluated. If you use <literal>EXEC SQL
    DEFINE</> then the <command>ecpg</> preprocessor evaluates the defines and substitutes
    the values. For example if you write:
-->
当然你可以继续在你的嵌入SQL程序中使用C版本<literal>#define</literal>
    和<literal>#undef</literal>。不同的是你定义值的评估不同。如果
你使用<literal>EXEC SQL DEFINE</>，
那么<command>ecpg</>预处理器评估定义且替换该值。比如如果你写：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    <!--
    then <command>ecpg</> will already do the substitution and your C compiler will never
    see any name or identifier <literal>MYNUMBER</>. Note that you cannot use
    <literal>#define</literal> for a constant that you are going to use in an
    embedded SQL query because in this case the embedded SQL precompiler is not
    able to see this declaration.
-->
那么<command>ecpg</>将执行替换，
而且你的C编译器不会看到任何名字或者标示符<literal>MYNUMBER</>。
注意你不能为打算用在嵌入SQL查询中的常数使用<literal>#define</literal>，
因为在这种情况下嵌入的SQL预编译器不能看到这个声明。
   </para>

  </sect2>

  <sect2 id="ecpg-ifdef">
  <!--
   <title>ifdef, ifndef, else, elif, and endif Directives</title>
  -->
  <title>ifdef，ifndef，else，elif和endif指令</title>
  
   
<para>
   <!--
   You can use the following directives to compile code sections conditionally:
   -->
   你可以使用下面指令有条件地编译代码段：
   
   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
  <!--
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
  -->
  如果<replaceable>name</>已经和<literal>EXEC SQL define
      <replaceable>name</></literal>被创建，那么检查<replaceable>name</>并处理
  随后行。
  
     </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</>;</literal></term>
     <listitem>
     <!--
<para>
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has <emphasis>not</emphasis> been created with
      <literal>EXEC SQL define <replaceable>name</></literal>.
     </para>
-->
<para>
     如果<replaceable>name</>和<literal>EXEC SQL define
      <replaceable>name</></literal> <emphasis>没有</emphasis>被创建，
  那么检查<replaceable>name</>并处理
  随后行。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <!--
<para>
      Starts processing an alternative section to a section introduced by
      either <literal>EXEC SQL ifdef <replaceable>name</></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</></literal>.
     </para>
-->
<para>
     开始处理另一部分到
 <literal>EXEC SQL ifdef <replaceable>name</></literal>或者
      <literal>EXEC SQL ifndef <replaceable>name</></literal>介绍的部分。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</>;</literal></term>
     <listitem>
     <!--
<para>
      Checks <replaceable>name</> and starts an alternative section if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
     </para>
-->
<para>
     如果<replaceable>name</>和<literal>EXEC SQL define
      <replaceable>name</></literal>已经被创建，
  那么检查<replaceable>name</>并且开始另一部分。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <!--
<para>
      Ends an alternative section.
     </para>
-->
<para>
     结束另一部分。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>

   
<para>
   <!--
    Example:
    -->
例子：
<programlisting>
EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;
</programlisting>
   </para>


  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
  <!--
  <title>Processing Embedded SQL Programs</title>
  -->
   <title>处理嵌入的SQL程序</title>

  <!--
<para>
   Now that you have an idea how to form embedded SQL C programs, you
   probably want to know how to compile them.  Before compiling you
   run the file through the embedded <acronym>SQL</acronym>
   <acronym>C</acronym> preprocessor, which converts the
   <acronym>SQL</acronym> statements you used to special function
   calls.  After compiling, you must link with a special library that
   contains the needed functions. These functions fetch information
   from the arguments, perform the <acronym>SQL</acronym> command using
   the <application>libpq</application> interface, and put the result
   in the arguments specified for output.
  </para>
-->
<para>
   现在你已知道如何形成嵌入SQL C程序，你可能想要知道如何编译它们。
   编译之前你通过嵌入的<acronym>SQL</acronym>
   <acronym>C</acronym>预处理器运行文件，这将转换你用于特定函数调用的 <acronym>SQL</acronym>
   语句。编译完之后，你必须连接包含所需函数的特殊库。这些函数
   从参数中抓取信息，使用<application>libpq</application>接口执行<acronym>SQL</acronym>
   命令，将结果放在输出指定的参数中。
</para>

  
<para>
   <!--
   The preprocessor program is called <filename>ecpg</filename> and is
   included in a normal <productname>PostgreSQL</> installation.
   Embedded SQL programs are typically named with an extension
   <filename>.pgc</filename>.  If you have a program file called
   <filename>prog1.pgc</filename>, you can preprocess it by simply
   calling:
   -->
   预处理程序被称为<filename>ecpg</filename>，包含在正常<productname>PostgreSQL</>安装中。
   嵌入的SQL程序通常以扩展名<filename>.pgc</filename>命名。
   如果你有<filename>prog1.pgc</filename>程序文件，你可以通过简单调用处理它。
<programlisting>
ecpg prog1.pgc
</programlisting>
   <!--
   This will create a file called <filename>prog1.c</filename>.  If
   your input files do not follow the suggested naming pattern, you
   can specify the output file explicitly using the
   <option>-o</option> option.
   -->
   这将创建名为<filename>prog1.c</filename>的文件。如果你的输入文件
   不遵循建议的命名模式，你可以使用<option>-o</option>选项明确的指定输出文件。
  </para>
  
<para>
   <!--
   The preprocessed file can be compiled normally, for example:
   -->
   预处理文件可以正常编译，比如：
<programlisting>
cc -c prog1.c
</programlisting>
   <!--
   The generated C source files include header files from the
   <productname>PostgreSQL</> installation, so if you installed
   <productname>PostgreSQL</> in a location that is not searched by
   default, you have to add an option such as
   <literal>-I/usr/local/pgsql/include</literal> to the compilation
   command line.
   -->
   生成的C源文件包含来自<productname>PostgreSQL</>安装的头文件，因此
   如果你在缺省不被搜索的地方安装<productname>PostgreSQL</>，那么
   你必须添加选项比如<literal>-I/usr/local/pgsql/include</literal>到
   编译命令行。
  </para>


  
<para>
   <!--
   To link an embedded SQL program, you need to include the
   <filename>libecpg</filename> library, like so:
   -->
   为了连接嵌入式SQL程序，你需要包含<filename>libecpg</filename>库，像这样：
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>

   <!--
   Again, you might have to add an option like
   <literal>-L/usr/local/pgsql/lib</literal> to that command line.
   -->
   再次，你可能需要添加像<literal>-L/usr/local/pgsql/lib</literal>
   到该命令行的选项。
  </para>


  <!--
<para>
   You can
   use <command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   or <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> with package name <literal>libecpg</literal> to
   get the paths for your installation.
  </para>
-->
<para>
   你可以使用<command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">和
   ecpg</secondary></indexterm>
   或者<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">和
   ecpg</secondary></indexterm>以及包名<literal>libecpg</literal>以
   获得安装目录。
</para>

  
<para>
   <!--
   If you manage the build process of a larger project using
   <application>make</application>, it might be convenient to include
   the following implicit rule to your makefiles:
   -->
   如果你使用<application>make</application>管理大对象编译过程，
   它可能方便地包含下面你的makefiles中的隐式规则：
   
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>


  <!--
<para>
   The complete syntax of the <command>ecpg</command> command is
   detailed in <xref linkend="app-ecpg">.
  </para>
-->
<para>
    <command>ecpg</command>命令完整语法在<xref linkend="app-ecpg">中有详细描述。
</para>

  <!--
<para>
   The <application>ecpg</application> library is thread-safe by
   default.  However, you might need to use some threading
   command-line options to compile your client code.
  </para>
-->
<para>
    <application>ecpg</application>库缺省是线程安全的。然而，你可能需要
使用一些线程命令行选项来编译你的客户端代码。

</para>
 </sect1>

 <sect1 id="ecpg-library">
 <!--
  <title>Library Functions</title>
 -->
    <title>库函数</title>

  <!--
<para>
   The <filename>libecpg</filename> library primarily contains
   <quote>hidden</quote> functions that are used to implement the
   functionality expressed by the embedded SQL commands.  But there
   are some functions that can usefully be called directly.  Note that
   this makes your code unportable.
  </para>
-->
<para>
    <filename>libecpg</filename>库主要包含<quote>隐藏的</quote>函数，
它用于实现嵌入SQL命令表达的功能。但是有一些可以直接调用的函数。
注意这使得您的代码可移植。
</para>

  <itemizedlist>
   <listitem>
    <!--
<para>
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>stream</replaceable>)</function> turns on debug
     logging if called with the first argument non-zero. Debug logging
     is done on <replaceable>stream</replaceable>.  The log contains
     all <acronym>SQL</acronym> statements with all the input
     variables inserted, and the results from the
     <productname>PostgreSQL</productname> server. This can be very
     useful when searching for errors in your <acronym>SQL</acronym>
     statements.
    </para>
-->
<para>
     如果调用第一个非零参数，<function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>stream</replaceable>)</function>打开调试日志。
 调试日志在<replaceable>stream</replaceable>上执行。
 日志包含带有插入的所有输入变量的<acronym>SQL</acronym>语句，以及
 来自<productname>PostgreSQL</productname>服务器的结果。
 当搜索<acronym>SQL</acronym>语句中的错误时，这是非常有用的。
 
</para>
    <note>
    <!--
<para>
    On Windows, if the <application>ecpg</> libraries and an application are
    compiled with different flags, this function call will crash the
    application because the internal representation of the
    <literal>FILE</> pointers differ.  Specifically,
    multithreaded/single-threaded, release/debug, and static/dynamic
    flags should be the same for the library and all applications using
    that library.
    </para>
-->
<para>
    在Windows上，如果<application>ecpg</>库和应用程序是以不同标识被编译，那么
该函数调用将崩溃，因为<literal>FILE</>指针内部表示形式不同。
特别是，多线程/单线程，释放/调试，以及静态/动态信号
对于该库以及使用该库的所有应用程序是一样的。
</para>
    </note>
   </listitem>

   <listitem>
     <!--
<para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function> returns the library database connection handle identified by the given name.
       If <replaceable>connection_name</replaceable> is set to <literal>NULL</literal>, the current
       connection handle is returned. If no connection handle can be identified, the function returns
       <literal>NULL</literal>. The returned connection handle can be used to call any other functions
       from <application>libpq</application>, if necessary.
     </para>
-->
<para>
   <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)</function>返回由给定名称标识的数据库连接句柄。
    如果<replaceable>connection_name</replaceable>设置为<literal>NULL</literal>，
则返回当前连接句柄。如果没有连接句柄可以被识别，
则该函数返回<literal>NULL</literal>。如果必要的话，返回的连接句柄可以用于
从<application>libpq</application>调用任何其他函数。 
</para>
     <note>
     <!--
<para>
       It is a bad idea to manipulate database connection handles made from <application>ecpg</application> directly
       with <application>libpq</application> routines.
     </para>
--> 
<para>
    操作随着<application>libpq</application>例程由<application>ecpg</application>直接组成的数据库连接句柄是个坏主意。
</para>
     </note>
   </listitem>

   <listitem>
     <!--
<para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>
       returns the current transaction status of the given connection identified by <replaceable>connection_name</replaceable>.
       See <xref linkend="libpq-status"> and libpq's <function>PQtransactionStatus()</function> for details about the returned status codes.
     </para>
-->
<para>
    <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>
返回通过<replaceable>connection_name</replaceable>标识的给定连接的当前事务状态。   
参阅<xref linkend="libpq-status">和libpq的<function>PQtransactionStatus()</function>获取关于返回状态码的详细信息。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     <function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>
     returns true if you are connected to a database and false if not.
     <replaceable>connection_name</replaceable> can be <literal>NULL</>
     if a single connection is being used.
    </para>
-->
<para>
    如果你连接到一个数据库，则<function>ECPGstatus(int <replaceable>lineno</replaceable>,
    const char* <replaceable>connection_name</replaceable>)</function>返回真，否则返回假。
如果正在使用一个连接，则<replaceable>connection_name</replaceable>是<literal>NULL</>。
</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
  <!--
  <title>Large Objects</title>
  -->
  <title>大对象</title>

  <!--
<para>
   Large objects are not directly supported by ECPG, but ECPG
   application can manipulate large objects through the libpq large
   object functions, obtaining the necessary <type>PGconn</type>
   object by calling the <function>ECPGget_PGconn()</function>
   function.  (However, use of
   the <function>ECPGget_PGconn()</function> function and touching
   <type>PGconn</type> objects directly should be done very carefully
   and ideally not mixed with other ECPG database access calls.)
  </para>
-->
<para>
    ECPG不直接支持大对象，但是ECPG应用可以通过libpq大对象函数操作大对象，
通过调用<function>ECPGget_PGconn()</function>函数获取必要的<type>PGconn</type>对象。
（然而，应该小心使用<function>ECPGget_PGconn()</function>函数
以及直接接触<type>PGconn</type>对象，理想情况下不与其他ECPG数据库访问调用混合）。
</para>

  <!--
<para>
   For more details about the <function>ECPGget_PGconn()</function>, see
   <xref linkend="ecpg-library">.  For information about the large
   object function interface, see <xref linkend="largeObjects">.
  </para>
-->
<para>
    参阅<xref linkend="ecpg-library">获取关于<function>ECPGget_PGconn()</function>的更多信息。
关于大对象函数接口的更多信息，参阅<xref linkend="largeObjects">。
</para>

  <!--
<para>
   Large object functions have to be called in a transaction block, so
   when autocommit is off, <command>BEGIN</command> commands have to
   be issued explicitly.
  </para>
-->
<para>
   在事务块中必须调用大对象函数，因此当关闭自动提交时，那么必须明确发出
   <command>BEGIN</command>命令。
</para>

  <!--
<para>
   <xref linkend="ecpg-lo-example"> shows an example program that
   illustrates how to create, write, and read a large object in an
   ECPG application.
  </para>
-->
<para>
    <xref linkend="ecpg-lo-example">显示了在ECPG应用中如何创建，写，读取大对象的示例程序。
</para>

  <example id="ecpg-lo-example">
  <!--
   <title>ECPG Program Accessing Large Objects</title>
  -->
   <title>ECPG程序访问大对象</title>
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* create */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* write test */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* read test */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* check */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* cleanup */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
 <!--
  <title><acronym>C++</acronym> Applications</title>
 -->
  <title><acronym>C++</acronym>应用程序</title>

  <!--
<para>
   ECPG has some limited support for C++ applications.  This section
   describes some caveats.
  </para>
-->
<para>
   ECPG对C++应用程序有一些有限的支持。本节介绍一些注意事项。
</para>

  <!--
<para>
   The <command>ecpg</command> preprocessor takes an input file
   written in C (or something like C) and embedded SQL commands,
   converts the embedded SQL commands into C language chunks, and
   finally generates a <filename>.c</filename> file.  The header file
   declarations of the library functions used by the C language chunks
   that <command>ecpg</command> generates are wrapped
   in <literal>extern "C" { ... }</literal> blocks when used under
   C++, so they should work seamlessly in C++.
  </para>
-->
<para>
   <command>ecpg</command>预处理程序采取写入C（或者类似C）的输入文件，并且
   嵌入SQL命令，将嵌入SQL命令转换为C语言块，
   最后生成<filename>.c</filename>文件。
   当在C++中使用时，
   通过<command>ecpg</command>产生的C语言块使用的库函数的头文件声明 
   被包裹在<literal>extern "C" { ... }</literal>块中。
   因此他们应该在C++中无缝工作。
</para>

  <!--
<para>
   In general, however, the <command>ecpg</command> preprocessor only
   understands C; it does not handle the special syntax and reserved
   words of the C++ language.  So, some embedded SQL code written in
   C++ application code that uses complicated features specific to C++
   might fail to be preprocessed correctly or might not work as
   expected.
  </para>
-->
<para>
    一般情况下，然而，<command>ecpg</command>预处理器仅仅了解C；它
不处理特殊语法并且保留C++语言关键字。因此，
写入使用复杂特定C++功能的C++应用程序代码的一些嵌入SQL代码可能
不能正确地被预处理或者可能不会按预期的工作。

</para>

  <!--
<para>
   A safe way to use the embedded SQL code in a C++ application is
   hiding the ECPG calls in a C module, which the C++ application code
   calls into to access the database, and linking that together with
   the rest of the C++ code.  See <xref linkend="ecpg-cpp-and-c">
   about that.
  </para>
-->
<para>
    在C++应用程序中使用嵌入SQL代码的安全方式是在C模块中隐藏ECPG调用，
其中C++应用程序代码调用访问数据库，并且连同C++代码其余部分一起连接。
参阅<xref linkend="ecpg-cpp-and-c">获取关于它的更多信息。

</para>

  <sect2 id="ecpg-cpp-scope">
  <!--
   <title>Scope for Host Variables</title>
  -->
   <title>宿主变量范围</title> 

   <!--
<para>
    The <command>ecpg</command> preprocessor understands the scope of
    variables in C.  In the C language, this is rather simple because
    the scopes of variables is based on their code blocks.  In C++,
    however, the class member variables are referenced in a different
    code block from the declared position, so
    the <command>ecpg</command> preprocessor will not understand the
    scope of the class member variables.
   </para>
-->
<para>
    <command>ecpg</command>预处理器理解C中变量范围。在C语言中，
这是简单地因为变量范围基于他们的代码块。在C++中，
然而，类成员变量参考来自声明位置的不同代码块。
因此<command>ecpg</command>预处理程序不理解类成员变量的范围。

</para>

   
<para>
    <!--
    For example, in the following case, the <command>ecpg</command>
    preprocessor cannot find any declaration for the
    variable <literal>dbname</literal> in the <literal>test</literal>
    method, so an error will occur.
    -->
比如，在下面情况下，<command>ecpg</command>预处理器无法找到
<literal>test</literal>方法中变量<literal>dbname</literal>的任何声明，
因此产生错误。
<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
    <!--
    This code will result in an error like this:
-->
这个代码将产生类似这样的错误。
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>

   
<para>
    <!--
    To avoid this scope issue, the <literal>test</literal> method
    could be modified to use a local variable as intermediate storage.
    But this approach is only a poor workaround, because it uglifies
    the code and reduces performance.
    -->
为了避免这个范围问题，<literal>test</literal>方法可以改为使用局部变量作为
中间存储器。但是这个方法仅仅是一个低劣的解决办法，因为
它丑化代码并且降低性能。
<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>

  </sect2>

  <sect2 id="ecpg-cpp-and-c">
  <!--
   <title>C++ Application Development with External C Module</title>
  -->
  <title>C++应用程序开发与外部C模块</title>
  
  
   <!--
<para>
    If you understand these technical limitations of
    the <command>ecpg</command> preprocessor in C++, you might come to
    the conclusion that linking C objects and C++ objects at the link
    stage to enable C++ applications to use ECPG features could be
    better than writing some embedded SQL commands in C++ code
    directly.  This section describes a way to separate some embedded
    SQL commands from C++ application code with a simple example.  In
    this example, the application is implemented in C++, while C and
    ECPG is used to connect to the PostgreSQL server.
   </para>
-->
<para>
    如果你理解C++中<command>ecpg</command>预处理器的这些技术局限性，
你可能得到这样的结论在链接阶段链接中C对象与C++对象使得C++应用程序
使用ECPG功能可能好于在C++代码中直接写一些嵌入SQL命令。
</para>

   
<para>
    <!--
    Three kinds of files have to be created: a C file
    (<filename>*.pgc</filename>), a header file, and a C++ file:
    -->
已经创建三种文件：一个C文件(<filename>*.pgc</filename>)，
头文件和C++文件：

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
   
   <!--
        A sub-routine module to execute SQL commands embedded in C.
        It is going to be converted
        into <filename>test_mod.c</filename> by the preprocessor.
       -->
   执行SQL命令的子程序模块嵌入C中。它将通过预处理器被转换为
   <filename>test_mod.c</filename>。
   
<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
      
<para>
       <!--
        A header file with declarations of the functions in the C
        module (<filename>test_mod.pgc</filename>).  It is included by
        <filename>test_cpp.cpp</filename>.  This file has to have an
        <literal>extern "C"</literal> block around the declarations,
        because it will be linked from the C++ module.
       -->
   C模块中(<filename>test_mod.pgc</filename>)使用函数声明的头文件通过
   <filename>test_cpp.cpp</filename>被包含。
   这个文件在声明周围有一个<literal>extern "C"</literal>块，因为
   它将从C++模块链接。
   
<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>

   
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
      
<para>
        <!--
        The main code for the application, including
        the <function>main</function> routine, and in this example a
        C++ class.
        -->
该应用程序主要代码，包含<function>main</function>程序和例子中C++类。
<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>

      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   
<para>
    <!--
    To build the application, proceed as follows.  Convert
    <filename>test_mod.pgc</> into <filename>test_mod.c</> by
    running <command>ecpg</command>, and generate
    <filename>test_mod.o</> by compiling
    <filename>test_mod.c</> with the C compiler:
-->
为了编译应用程序，如下进行。
通过运行<command>ecpg</command>，
转换<filename>test_mod.pgc</>到<filename>test_mod.c</>，
使用C编译器通过编译<filename>test_mod.c</>产生<filename>test_mod.o</>。
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>

   
<para>
    <!--
    Next, generate <filename>test_cpp.o</> by compiling
    <filename>test_cpp.cpp</> with the C++ compiler:.
-->
下一步，使用C++编译器通过编译<filename>test_cpp.cpp</>、
生成<filename>test_cpp.o</>。
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>

   
<para>
    <!--
    Finally, link these object files, <filename>test_cpp.o</>
    and <filename>test_mod.o</>, into one executable, using the C++
    compiler driver:
-->
最后，链接这些对象文件，<filename>test_cpp.o</>
    和<filename>test_mod.o</>到一个可执行文件中，使用C++编译器驱动：
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>

  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
 <!--
  <title>Embedded SQL Commands</title>
 -->
   <title>嵌入的SQL命令</title>
   
  <!--
<para>
   This section describes all SQL commands that are specific to
   embedded SQL.  Also refer to the SQL commands listed
   in <xref linkend="sql-commands">, which can also be used in
   embedded SQL, unless stated otherwise.
  </para>
-->
<para>
   本节描述的所有SQL命令仅限于嵌入的SQL。参阅
   列在<xref linkend="sql-commands">中的SQL命令，
   这也可以用于嵌入的SQL，除非另有说明。
</para>

  <refentry id="ecpg-sql-allocate-descriptor">
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
<!--
    <refpurpose>allocate an SQL descriptor area</refpurpose>
-->
<refpurpose>分配一个SQL描述区</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
    <title>描述</title>
    <!--
<para>
     <command>ALLOCATE DESCRIPTOR</command> allocates a new named SQL
     descriptor area, which can be used to exchange data between the
     PostgreSQL server and the host program.
    </para>
-->
<para>
    <command>ALLOCATE DESCRIPTOR</command>分配一个新命名SQL描述符区域，
可以用于改变PostgreSQL服务器和主机程序之间的数据。
</para>

    <!--
<para>
     Descriptor areas should be freed after use using
     the <command>DEALLOCATE DESCRIPTOR</command> command.
    </para>
-->
<para>
    使用<command>DEALLOCATE DESCRIPTOR</command>命令之后应该
释放描述符区域。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <!--
<para>
        A name of SQL descriptor, case sensitive.  This can be an SQL
        identifier or a host variable.
       </para>
-->
<para>
      SQL描述符名字区分大小写。这可以是SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>ALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
-->
<para>
    在SQL标准中声明<command>ALLOCATE DESCRIPTOR</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
   <refnamediv>
    <refname>CONNECT</refname>
<!--
    <refpurpose>establish a database connection</refpurpose>
-->
<refpurpose>建立数据库连接</refpurpose> 
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user_name</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user_name</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
    -->
 <title>描述</title>

    <!--
<para>
     The <command>CONNECT</command> command establishes a connection
     between the client and the PostgreSQL server.
    </para>
-->
<para>
    <command>CONNECT</command>命令在客户端和PostgreSQL服务器之间
创建了连接。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_target</replaceable></term>
      <listitem>
       
<para>
        <!--
        <replaceable class="PARAMETER">connection_target</replaceable>
        specifies the target server of the connection on one of
        several forms.
        -->
<replaceable class="PARAMETER">connection_target</replaceable>
在几种形式之一上指定了连接的目标服务器。

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
    <!--
            Connect over TCP/IP
-->
TCP/IP连接
           </para>

          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <!--
<para>
            Connect over Unix-domain sockets
           </para>
-->
<para>
       连接Unix-域套接字
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <!--
<para>
            Connect over TCP/IP
           </para>
-->
<para>
        TCP/IP连接
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
 <!--
          <term>SQL string constant</term>
 -->
  <term>SQL字符串常量</term>
  
          <listitem>
           <!--
<para>
            containing a value in one of the above forms
           </para>
-->
<para>
        在上述形式之一中包含一个值
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
 <!--
          <term>host variable</term>
 -->
   <term>宿主变量</term>
          <listitem>
           <!--
<para>
            host variable of type <type>char[]</type>
            or <type>VARCHAR[]</type> containing a value in one of the
            above forms
           </para>
-->
<para>
     类型<type>char[]</type>
     或者<type>VARCHAR[]</type>的宿主变量包含上述形式之一的值。
</para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_object</replaceable></term>
      <listitem>
       <!--
<para>
        An optional identifier for the connection, so that it can be
        referred to in other commands.  This can be an SQL identifier
        or a host variable.
       </para>
-->
<para>
       用于连接可选标识符，这样就可以指向其他命令。
   这可以是一个SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_user</replaceable></term>
      <listitem>
       <!--
<para>
        The user name for the database connection.
       </para>
-->
<para>
     用于数据库连接的用户名。
</para>

       <!--
<para>
        This parameter can also specify user name and password, using one the forms
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>, or
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
       </para>
-->
<para>
        该参数可以指定用户名和密码，使用下面形式之一
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>或者
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
</para>

       <!--
<para>
        User name and password can be SQL identifiers, string
        constants, or host variables.
       </para>
-->
<para>
       用户名和密码可以是SQL标识符，字符串常量，或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <!--
<para>
        Use all default connection parameters, as defined by libpq.
       </para>
-->
<para>
      使用所有缺省连接参数，正如通过libpq定义的。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

    
<para>
     <!--
     Here a several variants for specifying connection parameters:
 -->
 指定连接参数的几种变形：
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>

    
<para>
    <!--
     Here is an example program that illustrates the use of host
     variables to specify connection parameters:
 -->
 这里有一个例子程序阐述了使用宿主变量指定连接参数：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;

    <!--
    char *dbname     = "testdb";    /* database name */
    char *user       = "testuser";  /* connection user name */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* connection string */
    char ver[256];                  /* buffer to store the version string */
EXEC SQL END DECLARE SECTION;
    -->

char *dbname     = "testdb";    /*数据库名称*/
    char *user       = "testuser";  /*连接用户名*/
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* 连接字符串 */
    char ver[256];                  /*存储版本字符串的缓冲区*/
EXEC SQL END DECLARE SECTION;


    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>CONNECT</command> is specified in the SQL standard, but
     the format of the connection parameters is
     implementation-specific.
    </para>
-->
<para>
     在SQL标准中声明<command>CONNECT</command>，但是
 连接参数的格式是具体实施的。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
<!--
    <refpurpose>deallocate an SQL descriptor area</refpurpose>
-->
<refpurpose>重新分配SQL描述符区域</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
    -->
 <title>描述</title>

    <!--
<para>
     <command>DEALLOCATE DESCRIPTOR</command> deallocates a named SQL
     descriptor area.
    </para>
-->
<para>
      <command>DEALLOCATE DESCRIPTOR</command>重新分配命名的SQL描述符区域。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of the descriptor which is going to be deallocated.
        It is case sensitive.  This can be an SQL identifier or a host
        variable.
       </para>
-->
<para>
      描述符名字将重新被分配。它对大小写敏感。这可以是一个SQL标识符
  或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>DEALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
-->
<para>
      在SQL标准中声明<command>DEALLOCATE DESCRIPTOR</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
   <refnamediv>
   <!--
    <refname>DECLARE</refname>
    <refpurpose>define a cursor</refpurpose>
   -->
    <refname>DECLARE</refname>
    <refpurpose>定义游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">prepared_name</replaceable>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">query</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <!--
    <title>Description</title>
-->
<title>描述</title>

    <!--
<para>
     <command>DECLARE</command> declares a cursor for iterating over
     the result set of a prepared statement.  This command has
     slightly different semantics from the direct SQL
     command <command>DECLARE</command>: Whereas the latter executes a
     query and prepares the result set for retrieval, this embedded
     SQL command merely declares a name as a <quote>loop
     variable</quote> for iterating over the result set of a query;
     the actual execution happens when the cursor is opened with
     the <command>OPEN</command> command.
    </para>
-->
<para>
    <command>DECLARE</command>为了迭代预备语句结果集声明了游标。
该命令与直接SQL命令<command>DECLARE</command>略微有些不同语法：
后者执行查询并且为检索准备结果集，这个嵌入SQL命令只为迭代查询结果集
声明作为<quote>循环变量</quote>的名字；
当使用<command>OPEN</command>命令打开游标时，发生实际执行情况。

</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>
    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <!--
<para>
        A cursor name, case sensitive.  This can be an SQL identifier
        or a host variable.
       </para>
-->
<para>
       游标名大小写敏感。这可以是一个SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of a prepared query, either as an SQL identifier or a
        host variable.
       </para>
-->
<para>
       一个准备好查询的名字，要么作为SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
       <!--
<para>
        A <xref linkend="sql-select"> or
        <xref linkend="sql-values"> command which will provide the
        rows to be returned by the cursor.
       </para>
-->
<para>
     <xref linkend="sql-select">或者<xref linkend="sql-values">命令
 将提供通过游标返回的行。
</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <!--
<para>
     For the meaning of the cursor options,
     see <xref linkend="sql-declare">.
    </para>
-->
<para>
     关于游标选项的含义，参阅<xref linkend="sql-declare">。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

    
<para>
     <!--
     Examples declaring a cursor for a query:
 -->
 为查询声明游标的例子：
 
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>


    
<para>
    <!--
     An example declaring a cursor for a prepared statement:
-->
为预备语句声明游标的例子：
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>DECLARE</command> is specified in the SQL standard.
    </para>
-->
<para>
    在SQL标准中声明<command>DECLARE</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"></member>
     <member><xref linkend="sql-close"></member>
     <member><xref linkend="sql-declare"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
   <refnamediv>
    <refname>DESCRIBE</refname>
<!--
    <refpurpose>obtain information about a prepared statement or result set</refpurpose>
-->
<refpurpose>获得关于预备语句或者结果集的信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO <replaceable class="PARAMETER">sqlda_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
     <title>描述</title>

    <!--
<para>
     <command>DESCRIBE</command> retrieves metadata information about
     the result columns contained in a prepared statement, without
     actually fetching a row.
    </para>
-->
<para>
    <command>DESCRIBE</command>将检索关于在预备语句中包含的结果列的元数据信息，
实际上没有读取行。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of a prepared statement.  This can be an SQL
        identifier or a host variable.
       </para>
-->
<para>
      预备语句名字可以是一个SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <!--
<para>
        A descriptor name. It is case sensitive.  It can be an SQL
        identifier or a host variable.
       </para>
-->
<para>
       描述符名字大小写敏感。可以是SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">sqlda_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of an SQLDA variable.
       </para>
-->
<para>
       SQLDA变量名字。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>DESCRIBE</command> is specified in the SQL standard.
    </para>
-->
<para>
       在SQL标准中声明<command>DESCRIBE</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
   <refnamediv>
    <refname>DISCONNECT</refname>
<!--
    <refpurpose>terminate a database connection</refpurpose>
-->
<refpurpose>终止数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DISCONNECT <replaceable class="PARAMETER">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
    -->
 <title>描述</title>

    <!--
<para>
     <command>DISCONNECT</command> closes a connection (or all
     connections) to the database.
    </para>
-->
<para>
      <command>DISCONNECT</command>关闭与数据库的连接（或者所有连接）。   
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <!--
<para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
-->
<para>
    通过<command>CONNECT</command>命令建立数据库连接名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
       <!--
<para>
        Close the <quote>current</quote> connection, which is either
        the most recently opened connection, or the connection set by
        the <command>SET CONNECTION</command> command.  This is also
        the default if no argument is given to
        the <command>DISCONNECT</command> command.
       </para>
-->
<para>
       关闭<quote>当前</quote>连接，它要么是最近打开的连接，或者是通过
   <command>SET CONNECTION</command>命令设置的连接。
   如果没有给出参数到<command>DISCONNECT</command>命令中，那么这也是缺省的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <!--
<para>
        Close the default connection.
       </para>
-->
<para>
       关闭缺省连接。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <!--
<para>
        Close all open connections.
       </para>
-->
<para>
      关闭所有打开连接。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* close DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */

    return 0;
}
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>DISCONNECT</command> is specified in the SQL standard.
    </para>
-->
<para>
     在SQL标准中声明<command>DISCONNECT</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
<!--
    <refpurpose>dynamically prepare and execute a statement</refpurpose>
-->
<refpurpose>动态准备和执行语句</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
EXECUTE IMMEDIATE <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
     <title>描述</title>

    <!--
<para>
     <command>EXECUTE IMMEDIATE</command> immediately prepares and
     executes a dynamically specified SQL statement, without
     retrieving result rows.
    </para>
-->
<para>
    <command>EXECUTE IMMEDIATE</command>立即准备并且执行动态声明的SQL语句，而
没有检索结果行。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <!--
<para>
        A literal C string or a host variable containing the SQL
        statement to be executed.
       </para>
-->
<para>
        包含要执行的SQL语句文本C字符串或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

    
<para>
     <!--
     Here is an example that executes an <command>INSERT</command>
     statement using <command>EXECUTE IMMEDIATE</command> and a host
     variable named <varname>command</varname>:
 -->
 这是一个使用<command>EXECUTE IMMEDIATE</command>和
 命名<varname>command</varname>宿主变量执行<command>INSERT</command>
 语句的例子：
 
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>EXECUTE IMMEDIATE</command> is specified in the SQL standard.
    </para>
-->
<para>
      在SQL标准中声明<command>EXECUTE IMMEDIATE</command>。
</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
<!--
    <refpurpose>get information from an SQL descriptor area</refpurpose>
-->
<refpurpose>从SQL标识符区域获得信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">column_number</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_item</replaceable> [, ... ]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <!--
    <title>Description</title>
-->
<title>描述</title>

    <!--
<para>
     <command>GET DESCRIPTOR</command> retrieves information about a
     query result set from an SQL descriptor area and stores it into
     host variables.  A descriptor area is typically populated
     using <command>FETCH</command> or <command>SELECT</command>
     before using this command to transfer the information into host
     language variables.
    </para>
-->
<para>
     <command>GET DESCRIPTOR</command>从SQL描述符区域检索关于查询结果集的信息，
 并且将它存储到宿主变量中。在使用该命令将信息传递给宿主语言变量之前
 通常使用<command>FETCH</command>或者<command>SELECT</command>
 填充标识符区域。
</para>

    <!--
<para>
     This command has two forms: The first form retrieves
     descriptor <quote>header</quote> items, which apply to the result
     set in its entirety.  One example is the row count.  The second
     form, which requires the column number as additional parameter,
     retrieves information about a particular column.  Examples are
     the column name and the actual column value.
    </para>
-->
<para>
     该命令有两种形式：第一个形式检索描述符<quote>头部</quote>项，
 适用于作为整体的结果集。
 第二个形式需要作为额外参数的列数检索关于特定列的信息。
 例子是列名和实际列值。
  
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <!--
<para>
        A descriptor name.
       </para>
-->
<para>
      描述符名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <!--
<para>
        A token identifying which header information item to retrieve.
        Only <literal>COUNT</literal>, to get the number of columns in the
        result set, is currently supported.
       </para>
-->
<para>
      一个标记识别检索的头部信息项。目前仅仅支持<literal>COUNT</literal>
  可以获取结果集中的列数。
  
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column_number</replaceable></term>
      <listitem>
       <!--
<para>
        The number of the column about which information is to be
        retrieved.  The count starts at 1.
       </para>
-->
<para>
      关于被检索的列数信息。计数从1开始。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <!--
<para>
        A token identifying which item of information about a column
        to retrieve.  See <xref linkend="ecpg-named-descriptors"> for
        a list of supported items.
       </para>
-->
<para>
       一个标记识别检索列的信息项。参阅<xref linkend="ecpg-named-descriptors">
   获取可支持项的列数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">cvariable</replaceable></term>
      <listitem>
       <!--
<para>
        A host variable that will receive the data retrieved from the
        descriptor area.
       </para>
-->
<para>
         宿主变量将接收从描述符区域检索的数据。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

    
<para>
    <!--
     An example to retrieve the number of columns in a result set:
-->
 检索结果集中列数的例子：
 
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>

    
<para>
    <!--
     An example to retrieve a data length in the first column:
-->
在第一列中检索数据长度的例子：

<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>

    
<para>
     <!--
     An example to retrieve the data body of the second column as a
     string:
 -->
 检索作为字符串第二列的数据主体的例子：
 
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>

    
<para>
     <!--
     Here is an example for a whole procedure of
     executing <literal>SELECT current_database();</> and showing the number of
     columns, the column data length, and the column data:
 -->
 这是一个执行<literal>SELECT current_database();</>的整个程序的例子，
 并且显示了列数，列数据长度和列数据：
 
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

<!--
    /* Declare, open a cursor, and assign a descriptor to the cursor  */
-->
/*声明，打开游标，并且分配描述符给游标 */

    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

<!--
    /* Get a number of total columns */
-->
/*得到总列数*/

    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    <!--
/* Get length of a returned column */
-->
/* 得到返回列的长度 */

    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

<!--
    /* Fetch the returned column as a string */
-->
/*读取返回列作为字符串*/

    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

<!--
    /* Closing */
-->
 /*关闭*/
 
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     <!--
     When the example is executed, the result will look like this:
 -->
 当执行该例子的时候，结果看起来像这样：
 
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>GET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
-->
<para>
     在SQL标准中指定<command>GET DESCRIPTOR</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
   <refnamediv>
    <refname>OPEN</refname>
<!--
    <refpurpose>open a dynamic cursor</refpurpose>
-->
<refpurpose>打开一个动态游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING <replaceable class="PARAMETER">value</replaceable> [, ... ]
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
    <title>描述</title>

    <!--
<para>
     <command>OPEN</command> opens a cursor and optionally binds
     actual values to the placeholders in the cursor's declaration.
     The cursor must previously have been declared with
     the <command>DECLARE</command> command.  The execution
     of <command>OPEN</command> causes the query to start executing on
     the server.
    </para>
-->
<para>
     <command>OPEN</command>打开游标并且任意地绑定实际值到
 游标声明中的占位符。游标必须预先使用<command>DECLARE</command>命令被声明。
 <command>OPEN</command>的执行导致查询在服务器上开始执行。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of the cursor to be opened.  This can be an SQL
        identifier or a host variable.
       </para>
-->
<para>
         要打开的游标名字。可以是SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <!--
<para>
        A value to be bound to a placeholder in the cursor.  This can
        be an SQL constant, a host variable, or a host variable with
        indicator.
       </para>
-->
<para>
       一个绑定到游标中占位符的值。可以是SQL常数，
   宿主变量或者使用指示器的宿主变量。
   
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name of a descriptor containing values to be bound to the
        placeholders in the cursor.  This can be an SQL identifier or
        a host variable.
       </para>
-->
<para>
       描述符名字包含绑定到游标中占位符的值。
   可以是SQL标识符或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>OPEN</command> is specified in the SQL standard.
    </para>
-->
<para>
     在SQL标准中指定<command>OPEN</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"></member>
     <member><xref linkend="sql-close"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
   <refnamediv>
    <refname>PREPARE</refname>
<!--
    <refpurpose>prepare a statement for execution</refpurpose>
-->
 <refpurpose>准备一个执行语句</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
PREPARE <replaceable class="PARAMETER">name</replaceable> FROM <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
-->
 <title>描述</title>

    <!--
<para>
     <command>PREPARE</command> prepares a statement dynamically
     specified as a string for execution.  This is different from the
     direct SQL statement <xref linkend="sql-prepare">, which can also
     be used in embedded programs.  The <xref linkend="sql-execute">
     command is used to execute either kind of prepared statement.
    </para>
-->
<para>
    <command>PREPARE</command>动态准备指定作为字符串执行的语句。
这不同于直接SQL语句<xref linkend="sql-prepare">，
也可以作为嵌入程序使用。
 <xref linkend="sql-execute">命令用来执行
 两种预备语句。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <!--
<para>
        An identifier for the prepared query.
       </para>
-->
<para>
      预备查询标识符。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <!--
<para>
        A literal C string or a host variable containing a preparable
        statement, one of the SELECT, INSERT, UPDATE, or
        DELETE.
       </para>
-->
<para>
      包含一个预备语句，SELECT，INSERT，UPDATE或者DELETE之一的文本C字符串或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>PREPARE</command> is specified in the SQL standard.
    </para>
-->
<para>
     在SQL标准中指定<command>PREPARE</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="sql-execute"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
<!--
    <refpurpose>set the autocommit behavior of the current session</refpurpose>
-->
 <refpurpose>设置当前会话自动提交操作</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
      <title>描述</title>
   
    <!--
<para>
     <command>SET AUTOCOMMIT</command> sets the autocommit behavior of
     the current database session.  By default, embedded SQL programs
     are <emphasis>not</emphasis> in autocommit mode,
     so <command>COMMIT</command> needs to be issued explicitly when
     desired.  This command can change the session to autocommit mode,
     where each individual statement is committed implicitly.
    </para>
-->
<para>
    <command>SET AUTOCOMMIT</command>设置当前数据库会话自动提交操作。
缺省，嵌入SQL程序<emphasis>不</emphasis>在自动提交模式，因此
当需要的时候，需要明确发布<command>COMMIT</command>。
该命令可以改变会话自动提交模式，则隐式提交每个单独语句。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>SET AUTOCOMMIT</command> is an extension of PostgreSQL ECPG.
    </para>
-->
<para>
      <command>SET AUTOCOMMIT</command>是PostgreSQL ECPG的一个扩展。
</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
   <refnamediv>
    <refname>SET CONNECTION</refname>
<!--
    <refpurpose>select a database connection</refpurpose>
-->
<refpurpose>选择一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="PARAMETER">connection_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <!--
    <title>Description</title>
-->
<title>描述</title>

    <!--
<para>
     <command>SET CONNECTION</command> sets the <quote>current</quote>
     database connection, which is the one that all commands use
     unless overridden.
    </para>
-->
<para>
      <command>SET CONNECTION</command>设置<quote>当前</quote>数据库连接，
  这是所有命令使用的一个，除非重写。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <!--
<para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
-->
<para>
       通过<command>CONNECT</command>命令创建数据库连接名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <!--
<para>
        Set the connection to the default connection.
       </para>
-->
<para>
      设置连接为缺省连接。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>SET CONNECTION</command> is specified in the SQL standard.
    </para>
-->
<para>
      在SQL标准中指定<command>SET CONNECTION</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-disconnect"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
<!--
    <refpurpose>set information in an SQL descriptor area</refpurpose>
-->
 <refpurpose>设置SQL描述符区域信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">number</replaceable> <replaceable class="PARAMETER">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
-->
<title>描述</title>

    <!--
<para>
     <command>SET DESCRIPTOR</command> populates an SQL descriptor
     area with values.  The descriptor area is then typically used to
     bind parameters in a prepared query execution.
    </para>
-->
<para>
     <command>SET DESCRIPTOR</command>使用值填充SQL描述符区域。
 描述符区域通常用于绑定预备查询执行中的参数。
</para>

    <!--
<para>
     This command has two forms: The first form applies to the
     descriptor <quote>header</quote>, which is independent of a
     particular datum.  The second form assigns values to particular
     datums, identified by number.
    </para>
-->
<para>
     该参数有两种形式：第一种形式适用于描述符<quote>头部</quote>，
 它不受特定数据影响。第二中形式将值分配给特定数据，通过数字标识。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <!--
<para>
        A descriptor name.
       </para>
-->
<para>
      描述符名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <!--
<para>
        A token identifying which header information item to set.
        Only <literal>COUNT</literal>, to set the number of descriptor
        items, is currently supported.
       </para>
-->
<para>
      标记识别设置的头部信息项。目前仅仅支持<literal>COUNT</literal>
  设置描述符项数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">number</replaceable></term>
      <listitem>
       <!--
<para>
        The number of the descriptor item to set.  The count starts at
        1.
       </para>
-->
<para>
       设置的描述符项数。计数从1开始。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <!--
<para>
        A token identifying which item of information to set in the
        descriptor.  See <xref linkend="ecpg-named-descriptors"> for a
        list of supported items.
       </para>
-->
<para>
       标记识别在描述符中的项信息。参阅<xref linkend="ecpg-named-descriptors">
   获取可支持项的列表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <!--
<para>
        A value to store into the descriptor item.  This can be an SQL
        constant or a host variable.
       </para>
-->
<para>
      存储到描述符项中的值。可以是SQl常量或者宿主变量。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>SET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
-->
<para>
      在SQL标准中指定<command>SET DESCRIPTOR</command>。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>See Also</title>
-->
<title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
   <refnamediv>
    <!--
    <refname>TYPE</refname>
    <refpurpose>define a new data type</refpurpose>
-->

<refname>TYPE</refname>
    <refpurpose>定义新的数据类型</refpurpose>

   </refnamediv>

   <refsynopsisdiv>
<synopsis>
TYPE <replaceable class="PARAMETER">type_name</replaceable> IS <replaceable class="PARAMETER">ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
   -->
      <title>描述</title>
   
    <!--
<para>
     The <command>TYPE</command> command defines a new C type.  It is
     equivalent to putting a <literal>typedef</literal> into a declare
     section.
    </para>
-->
<para>
     <command>TYPE</command>命令定义一个新的C类型。
 它相当于将<literal>typedef</literal>放到声明段中。
</para>

    <!--
<para>
     This command is only recognized when <command>ecpg</command> is
     run with the <option>-c</option> option.
    </para>
-->
<para>
      当运行带有<option>-c</option>选项的<command>ecpg</command>的时候，
  仅仅标识该命令。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">type_name</replaceable></term>
      <listitem>
       <!--
<para>
        The name for the new type.  It must be a valid C type name.
       </para>
-->
<para>
       新类型名字。它必须是一个有效的C类型名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <!--
<para>
        A C type specification.
       </para>
-->
<para>
       C类型说明。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>

    
<para>
     <!--
     Here is an example program that uses <command>EXEC SQL
     TYPE</command>:
 -->
 这里是使用<command>EXEC SQL TYPE</command>的例子程序：
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>
     <!--
     The output from this program looks like this:
 -->
 该程序的输出看起来像这样：
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     The <command>TYPE</command> command is a PostgreSQL extension.
    </para>
-->
<para>
      <command>TYPE</command>命令是PostgreSQL的扩展。
</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
   <refnamediv>
    <refname>VAR</refname>
<!--
    <refpurpose>define a variable</refpurpose>
-->
<refpurpose>定义一个变量</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
-->
 <title>描述</title>

    <!--
<para>
     The <command>VAR</command> command assigns a new C data type
     to a host variable.  The host variable must be previously
     declared in a declare section.
    </para>
-->
<para>
     <command>VAR</command>命令将新的C数据类型分配给宿主变量。
 宿主变量必须预先在声明段声明。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">varname</replaceable></term>
      <listitem>
       <!--
<para>
        A C variable name.
       </para>
-->
<para>
       C变量名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <!--
<para>
        A C type specification.
       </para>
-->
<para>
      C类型说明。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     The <command>VAR</command> command is a PostgreSQL extension.
    </para>
-->
<para>
     <command>VAR</command>命令是PostgreSQL扩展。
</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
   <refnamediv>
    <refname>WHENEVER</refname>
<!--
    <refpurpose>specify the action to be taken when an SQL statement causes a specific class condition to be raised</refpurpose>
     -->
  <refpurpose>当SQL语句导致一个要发生的特定类条件时，
  则指定要采取的行动</refpurpose>
  </refnamediv>

   <refsynopsisdiv>
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="PARAMETER">action</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
   <!--
    <title>Description</title>
-->
 <title>描述</title>

    <!--
<para>
     Define a behavior which is called on the special cases (Rows not
     found, SQL warnings or errors) in the result of SQL execution.
    </para>
-->
<para>
    定义在SQL执行结果中特殊情况下（没有发现行，SQL警告或者错误）调用的操作。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Parameters</title>
-->
<title>参数</title>

    <!--
<para>
     See <xref linkend="ecpg-whenever"> for a description of the
     parameters.
    </para>
-->
<para>
     参阅<xref linkend="ecpg-whenever">获取该参数的描述。
</para>
   </refsect1>

   <refsect1>
    <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>

    
<para>
     <!--
     A typical application is the use of <literal>WHENEVER NOT FOUND
     BREAK</literal> to handle looping through result sets:
 -->
 一个典型应用是通过结果集处理循环的
 <literal>WHENEVER NOT FOUND BREAK</literal>的使用：
 
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

<!--
    /* when end of result set reached, break out of while loop */
-->
/*当到达结果集终端时，打破while循环*/

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>

   </refsect1>

   <refsect1>
    <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

    <!--
<para>
     <command>WHENEVER</command> is specified in the SQL standard, but
     most of the actions are PostgreSQL extensions.
    </para>
-->
<para>
      在SQL标准中指定<command>WHENEVER</command>，但是大多数操作是PostgreSQL扩展。
</para>
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
 <!--
  <title><productname>Informix</productname> Compatibility Mode</title>
  -->
   <title><productname>Informix</productname>兼容模式</title>
  
<para>
   <!--
   <command>ecpg</command> can be run in a so-called <firstterm>Informix compatibility mode</>. If
   this mode is active, it tries to behave as if it were the <productname>Informix</productname>
   precompiler for <productname>Informix</productname> E/SQL. Generally spoken this will allow you to use
   the dollar sign instead of the <literal>EXEC SQL</> primitive to introduce
   embedded SQL commands.:
   -->
   <command>ecpg</command>可以在所谓的 <firstterm>Informix兼容模式</>下运行。
   如果这种模式是活跃的，它试图表现得好像<productname>Informix</productname> E/SQL的<productname>Informix</productname>预编译器。
   通常所说的这将允许你使用美元符号，
   而不是<literal>EXEC SQL</>原始的引入嵌入式的SQL命令。
   
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>


  <note>
   <!--
<para>
    There must not be any white space between the <literal>$</literal>
    and a following preprocessor directive, that is,
    <literal>include</literal>, <literal>define</literal>, <literal>ifdef</literal>,
    etc.  Otherwise, the preprocessor will parse the token as a host
    variable.
   </para>
-->
<para>
     在<literal>$</literal>之间不能有任何空格和下面的预处理指令，
 即<literal>include</literal>，<literal>define</literal>，
 <literal>ifdef</literal>等等。否则，预处理器将解析令牌作为宿主变量。
</para>
  </note>

  <!--
<para>
   There are two compatibility modes: <literal>INFORMIX</>, <literal>INFORMIX_SE</>
  </para>
-->
<para>
    有两种兼容模式：<literal>INFORMIX</>, <literal>INFORMIX_SE</>。
</para>
  <!--
<para>
   When linking programs that use this compatibility mode, remember to link
   against <literal>libcompat</> that is shipped with ECPG.
  </para>
-->
<para>
   当使用这些兼容模式连接程序时，记得要链接<literal>libcompat</>前内置于ECPG中。
</para>
  <!--
<para>
   Besides the previously explained syntactic sugar, the <productname>Informix</productname> compatibility
   mode ports some functions for input, output and transformation of data as
   well as embedded SQL statements known from E/SQL to ECPG.
  </para>
-->
<para>
   除了前面所说的语法块，
<productname>Informix</productname>兼容模式为输入输出和数据转换功能，
以及从E/SQL到ECPG嵌入式SQL语句提供一些函数。
</para>
  <!--
<para>
   <productname>Informix</productname> compatibility mode is closely connected to the pgtypeslib library
   of ECPG. pgtypeslib maps SQL data types to data types within the C host
   program and most of the additional functions of the <productname>Informix</productname> compatibility
   mode allow you to operate on those C host program types. Note however that
   the extent of the compatibility is limited. It does not try to copy <productname>Informix</productname>
   behavior; it allows you to do more or less the same operations and gives
   you functions that have the same name and the same basic behavior but it is
   no drop-in replacement if you are using <productname>Informix</productname> at the moment. Moreover,
   some of the data types are different. For example,
   <productname>PostgreSQL's</productname> datetime and interval types do not
   know about ranges like for example <literal>YEAR TO MINUTE</> so you won't
   find support in ECPG for that either.
  </para>
-->
<para>
   <productname>Informix</productname>兼容模式紧密联系ECPG的pgtypeslib库。
pgtypeslib在C主机程序映射SQL数据类型到数据类型，并且
<productname>Informix</productname> 兼容模式的大部分附加函数允许你在那些C主机程序类型上进行操作。
但值得注意的是，兼容性的程度是有限的。它并不试图复制<productname>Informix</productname>的操作；它允许你做或多或少相同的操作，使你具有相同的名称和相同的基本行为功能，但如果你现在使用<productname>Informix</productname>，它没有下拉式功能表位置。
此外，一些数据类型是不同的。比如，<productname>PostgreSQL的</productname> datetime和
区间类型不知道范围比如<literal>YEAR TO MINUTE</>，
因此你在ECPG的这两种类型中不会找到支持。
</para>

  <sect2 id="ecpg-informix-types">
  <!--
   <title>Additional Types</title>
   -->
    <title>附加类型</title>

  
<para>
     <!--
    The Informix-special "string" pseudo-type for storing right-trimmed character string data is now
    supported in Informix-mode without using <literal>typedef</literal>. In fact, in Informix-mode,
    ECPG refuses to process source files that contain <literal>typedef sometype string;</literal>
-->
在不使用<literal>typedef</literal>的Informix模式中
现在支持为存储正确修剪字符串数据 Informix特殊"字符串"伪类型。
实际上，在Informix模式中，ECPG拒绝包含<literal>typedef sometype string;</literal>的过程源文件。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;

<!--
string userid; /* this variable will contain trimmed data */
-->

string userid; /* 这个变量将包含修剪的数据 */

EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>

  </sect2>

  <sect2 id="ecpg-informix-statements">
  <!--
   <title>Additional/Missing Embedded SQL Statements</title>
   -->
   <title>附加的/失踪的嵌入的SQL语句</title>
   
   
<para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</></term>
      <listitem>
       <para>
    <!--
        This statement closes the current connection. In fact, this is a
        synonym for ECPG's <literal>DISCONNECT CURRENT</>.:
-->
这个语句关闭当前连接。事实上，这是ECPG的
<literal>DISCONNECT CURRENT</>的同义词：
<programlisting>
<!--
$CLOSE DATABASE;                /* close the current connection */
-->
$CLOSE DATABASE;                /* 关闭当前连接 */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>

      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</></term>
      <listitem>
       <!--
<para>
        Due to the differences how ECPG works compared to Informix's ESQL/C (i.e. which steps
        are purely grammar transformations and which steps rely on the underlying run-time library)
        there is no <literal>FREE cursor_name</> statement in ECPG. This is because in ECPG,
        <literal>DECLARE CURSOR</literal> doesn't translate to a function call into
        the run-time library that uses to the cursor name. This means that there's no run-time
        bookkeeping of SQL cursors in the ECPG run-time library, only in the PostgreSQL server.
       </para>
-->
<para>
   由于ECPG与Informix的ESQL/C如何运行的不同（即这个步骤是纯粹的语法转换并且依赖于底层运行时的库）在ECPG中没有
   <literal>FREE cursor_name</>声明。
   这是因为在ECPG中，<literal>DECLARE CURSOR</literal>不转化为使用游标名称调用运行时库的一个函数。
这意味着，在ECPG中运行时库中SQL游标没有运行时的记录，只有在PostgreSQL服务器上。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</></term>
      <listitem>
       <!--
<para>
        <literal>FREE statement_name</> is a synonym for <literal>DEALLOCATE PREPARE statement_name</>.
       </para>
-->
<para>
     <literal>FREE statement_name</>是
 <literal>DEALLOCATE PREPARE statement_name</>的同义词。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
  <!--
   <title>Informix-compatible SQLDA Descriptor Areas</title>
  -->
   <title>Informix兼容SQLDA描述符区域</title>
   
   
<para>
    <!--
    Informix-compatible mode supports a different structure than the one described in
    <xref linkend="ecpg-sqlda-descriptors">. See below:
-->
Informix兼容模式支持一个
比<xref linkend="ecpg-sqlda-descriptors">描述中的不同的结构。见下文：
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>


   
<para>
    <!--
    The global properties are:
-->
全局属性是：

    <variablelist>

     <varlistentry>
     <term><literal>sqld</></term>
      <listitem>
       <para>
     <!--
        The number of fields in the <literal>SQLDA</> descriptor.
-->
在<literal>SQLDA</>描述符中的字段的数目。
       </para>


      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</></term>
      <listitem>
       <!--
<para>
        Pointer to the per-field properties.
       </para>
-->
<para>
      每个字段属性的指针。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</></term>
      <listitem>
       <!--
<para>
        Unused, filled with zero-bytes.
       </para>
-->
<para>
      未使用的，填充零字节。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</></term>
      <listitem>
       <!--
<para>
        Size of the allocated structure.
       </para>
-->
<para>
     分配的结构大小。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</></term>
      <listitem>
       <!--
<para>
        Pointer to the next SQLDA structure if the result set contains more than one record.
       </para>
-->
<para>
     如果结果集中包含1个以上的记录，指向下一个SQLDA结构的指针。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</></term>
      <listitem>
       <!--
<para>
        Unused pointer, contains NULL. Kept for Informix-compatibility.
       </para>
-->
<para>
     未使用指针，包含空。保持Informix兼容。
</para>
      </listitem>
     </varlistentry>

    </variablelist>
     <!--
    The per-field properties are below, they are stored in the <literal>sqlvar</literal> array:
    -->
下面每个字段属性，它们被存储在<literal>sqlvar</literal>数组中：

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</></term>
      <listitem>
       <!--
<para>
        Type of the field. Constants are in <literal>sqltypes.h</literal>
       </para>
-->
<para>
       字段类型。常量在<literal>sqltypes.h</literal>中。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</></term>
      <listitem>
       <!--
<para>
        Length of the field data.
       </para>
-->
<para>
       字段数据的长度。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</></term>
      <listitem>
       
<para>
        <!--
        Pointer to the field data. The pointer is of <literal>char *</literal> type,
        the data pointed by it is in a binary format. Example:
-->
指向字段数据的指针。指针是<literal>char *</literal>类型，
通过它指出的数据是二进制格式。例子:

<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</></term>
      <listitem>
       
<para>
       <!--
        Pointer to the NULL indicator. If returned by DESCRIBE or FETCH then it's always a valid pointer.
        If used as input for <literal>EXECUTE ... USING sqlda;</literal> then NULL-pointer value means
        that the value for this field is non-NULL. Otherwise a valid pointer and <literal>sqlitype</literal>
        has to be properly set. Example:
-->
指向空指针。如果通过DESCRIBE或取回后，那么它总是一个有效的指针。
如果使用<literal>EXECUTE ... USING sqlda;</literal> 作为输入，然后空指针值意味着该字段的值为非空。否则，一个有效的指针
和<literal>sqlitype</literal>必须正确设置。例子:

<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</></term>
      <listitem>
       <!--
<para>
        Name of the field. 0-terminated string.
       </para>
-->
<para>
      字段名称。0终止字符串。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</></term>
      <listitem>
       <!--
<para>
        Reserved in Informix, value of <function>PQfformat()</> for the field.
       </para>
-->
<para>
     保留在Informix中，<function>PQfformat()</>的值为字段的值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</></term>
      <listitem>
       <!--
<para>
        Type of the NULL indicator data. It's always SQLSMINT when returning data from the server.
        When the <literal>SQLDA</literal> is used for a parametrized query, the data is treated
        according to the set type.
       </para>
-->
<para>
      空指针的数据类型。当从服务器返回数据时，它总是SQLSMINT。
  当<literal>SQLDA</literal>用于参数化查询时，
  数据是根据设定的类型来处理的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</></term>
      <listitem>
       <!--
<para>
        Length of the NULL indicator data.
       </para>
-->
<para>
     空指针数据的长度。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</></term>
      <listitem>
       <!--
<para>
        Extended type of the field, result of <function>PQftype()</>.
       </para>
-->
<para>
       字段的扩展类型，结果<function>PQftype()</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</></term>
     <term><literal>sqltypelen</></term>
     <term><literal>sqlownerlen</></term>
     <term><literal>sqlsourcetype</></term>
     <term><literal>sqlownername</></term>
     <term><literal>sqlsourceid</></term>
     <term><literal>sqlflags</></term>
     <term><literal>sqlreserved</></term>
      <listitem>
       <!--
<para>
        Unused.
       </para>
-->
<para>
      未使用。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</></term>
      <listitem>
       <!--
<para>
        It equals to <literal>sqldata</literal> if <literal>sqllen</literal> is larger than 32KB.
       </para>
-->
<para>
       如果<literal>sqllen</literal>大于32KB。它等于<literal>sqldata</literal>。
</para>
      </listitem>
     </varlistentry>

    </variablelist>
    
<!--
    Example:
-->
例子：
<programlisting>
EXEC SQL INCLUDE sqlda.h;
     <!--
    sqlda_t        *sqlda; /* This doesn't need to be under embedded DECLARE SECTION */
-->
sqlda_t        *sqlda; /* 这个不需要在嵌入DECLARE SECTION的下面 */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;
 
    <!--
    free(sqlda); /* The main structure is all to be free(),
                  * sqlda and sqlda-&gt;sqlvar is in one allocated area */
-->
free(sqlda); /* 主结构被free()， sqlda和sqlda-&gt;sqlvar在分配区域中*/

</programlisting>
    <!--
    For more information, see the <literal>sqlda.h</> header and the
    <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal> regression test.
-->
获取更多信息，参见<literal>sqlda.h</>头文件和 <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>
回归测试。
   </para>
  </sect2>

  <sect2 id="ecpg-informix-functions">
  <!--
   <title>Additional Functions</title>
  -->
  <title>附加函数</title>
  
   
<para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</></term>
      <listitem>
       <para>
     <!--
        Add two decimal type values.
-->
增加2个decimal类型值。
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        <!--
        The function receives a pointer to the first operand of type decimal
        (<literal>arg1</>), a pointer to the second operand of type decimal
        (<literal>arg2</>) and a pointer to a value of type decimal that will
        contain the sum (<literal>sum</>). On success, the function returns 0.
        <symbol>ECPG_INFORMIX_NUM_OVERFLOW</> is returned in case of overflow and
        <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</> in case of underflow. -1 is returned for
        other failures and <varname>errno</> is set to the respective <varname>errno</> number of the
        pgtypeslib.
-->
这个函数接受一个指向类型decimal(<literal>arg1</>)的第一个操作数的指针，
类型decimal (<literal>arg2</>)的第二个操作数的指针和包含sum (<literal>sum</>)类型decimal值的指针。成功时，函数返回0。
以免溢出返回<symbol>ECPG_INFORMIX_NUM_OVERFLOW</>和在下溢的情况下返回 <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</>。其他错误返回-1，
<varname>errno</>设置为pgtypeslib的各自的<varname>errno</>数。

       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</></term>
      <listitem>
       
<para>
        <!--
        Compare two variables of type decimal.
-->
比较decimal类型的2个变量。
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        <!--
        The function receives a pointer to the first decimal value
        (<literal>arg1</>), a pointer to the second decimal value
        (<literal>arg2</>) and returns an integer value that indicates which is
        the bigger value.
-->
这个函数接受一个指向第一个decimal值(<literal>arg1</>)的指针，
一个指向第二个decimal值(<literal>arg2</>)的指针并返回
一个表示这是更大值的整数值。
        <itemizedlist>
         <listitem>
          <para>
   <!--
           1, if the value that <literal>arg1</> points to is bigger than the
           value that <literal>var2</> points to
   -->
   如果<literal>arg1</>指向比<literal>var2</>指向的值更大，则为1。
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           -1, if the value that <literal>arg1</> points to is smaller than the
           value that <literal>arg2</> points to </para>
-->
<para>
             如果<literal>arg1</>指向比<literal>arg2</>指向的值更小，则为-1。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           0, if the value that <literal>arg1</> points to and the value that
           <literal>arg2</> points to are equal
          </para>
-->
<para>
           如果<literal>arg1</>指向和<literal>arg2</>指向的值相等，则为0。
</para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</></term>
      <listitem>
       
<para>
        <!--
        Copy a decimal value.
-->
复制一个decimal值。
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        <!--
        The function receives a pointer to the decimal value that should be
        copied as the first argument (<literal>src</>) and a pointer to the
        target structure of type decimal (<literal>target</>) as the second
        argument.
-->
这个函数接受一个指向复制为第一个参数(<literal>src</>)
的decimal值的指针和
一个指向decimal(<literal>target</>)的目标结构作为第二个参数的指针。
       </para>


      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</></term>
      <listitem>
      
<para>
        <!--
        Convert a value from its ASCII representation into a decimal type.
-->
将一个值从ASCII表示转换为decimal类型。

<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
       <!--
        The function receives a pointer to string that contains the string
        representation of the number to be converted (<literal>cp</>) as well
        as its length <literal>len</>. <literal>np</> is a pointer to the
        decimal value that saves the result of the operation.
-->

这个函数接受一个指向字符串的指针，
这个字符串包含转换成和其长度一样为<literal>len</>
的(<literal>cp</>)数字的字符串表示形式。
<literal>np</>是一个指向decimal值的指针，节省了运算的结果。

       </para>


       <!--
<para>
        Valid formats are for example:
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal> or
         <literal>-32.84e-4</literal>.
       </para>
-->
<para>
         有效格式比如：<literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal>或者
         <literal>-32.84e-4</literal>。
</para>
       <!--
<para>
        The function returns 0 on success. If overflow or underflow occurred,
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> is returned. If the ASCII
        representation could not be parsed,
        <literal>ECPG_INFORMIX_BAD_NUMERIC</> is returned or
        <literal>ECPG_INFORMIX_BAD_EXPONENT</> if this problem occurred while
        parsing the exponent.
       </para>
-->
<para>
       函数成功时返回0。如果发生溢出或下溢，
   返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者   <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。如果ASCII表示不能被解析，
   返回<literal>ECPG_INFORMIX_BAD_NUMERIC</>，
   如果解析指数发生此问题时返回<literal>ECPG_INFORMIX_BAD_EXPONENT</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</></term>
      <listitem>
       
<para>
        <!--
        Convert a value of type double to a value of type decimal.
-->

转换double类型的值到一个decimal类型的值。
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        <!--
        The function receives the variable of type double that should be
        converted as its first argument (<literal>dbl</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
函数接收一个被作为第一个参数(<literal>dbl</>)转换的double类型的变量。
作为第二个参数(<literal>np</>)，
函数接收一个指向保持操作结果的decimal变量的指针。
       </para>


       <!--
<para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
-->
<para>
         成功时函数返回0，如果转换失败则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</></term>
      <listitem>
       
<para>
       <!--
        Convert a value of type int to a value of type decimal.
   -->
   转换一个int类型的值到一个decimal类型的值。
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        <!--
        The function receives the variable of type int that should be
        converted as its first argument (<literal>in</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
函数接收应作为第一个参数(<literal>in</>)转换的int类型的变量。作为第二个参数(<literal>np</>)，函数接收一个指向保持操作结果的decimal变量的指针。
       </para>

       <!--
<para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
-->
<para>
       成功时函数返回0，如果转换失败则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</></term>
      <listitem>
       
<para>
      <!--
        Convert a value of type long to a value of type decimal.
  -->
   转换一个long类型的值到一个decimal类型的值。
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        <!--
        The function receives the variable of type long that should be
        converted as its first argument (<literal>lng</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
函数接收应作为第一个参数(<literal>lng</>)转换的long类型的变量。
作为第二个参数(<literal>np</>)，函数接收一个指向保持操作
结果的decimal变量的指针。
       </para>

       <!--
<para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
-->
<para>
       成功时函数返回0，如果转换失败则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</></term>
      <listitem>
       
<para>
       <!--
        Divide two variables of type decimal.
   -->
   decimal类型的两个变量相除。
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        <!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>/<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
函数接收一个指向第一个(<literal>n1</>)和第二个(<literal>n2</>)操作数变量的指针并且计算<literal>n1</>/<literal>n2</>。
<literal>result</>是指向保持操作结果的变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the division fails.
        If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively. If an attempt to
        divide by zero is observed, the function returns
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.
       </para>
-->
<para>
      成功则返回0，如果除法运算失败则返回一个负数。如果产生溢出或者下溢，函数各自返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者  <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
  如果观察到尝试除以0，
  函数返回<literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</></term>
      <listitem>
       
<para>
       <!--
        Multiply two decimal values.
   -->
    两个decimal值相乘。
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        <!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>*<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
函数接收指向第一个(<literal>n1</>)和第二个(<literal>n2</>)操作数变量的指针并且计算<literal>n1</>*<literal>n2</>。
<literal>result</>是指向保持操作结果的变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the multiplication
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
       </para>
-->
<para>
       成功则返回0，如果乘法运算失败则返回一个负数。如果发生溢出或者下溢，函数各自返回 <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</></term>
      <listitem>
       
<para>
        <!--
        Subtract one decimal value from another.
-->
一个decimal值与另一个值相减。
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        <!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>-<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
函数接收指向第一个(<literal>n1</>)和第二个(<literal>n2</>)操作数变量的指针并且计算<literal>n1</>-<literal>n2</>。
<literal>result</>是指向保持操作结果的变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the subtraction
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
       </para>
-->
<para>
      成功则返回0，如果减法运算失败则返回一个负数。如果发生溢出或者下溢，函数各自返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</></term>
      <listitem>
       
<para>
       <!--
        Convert a variable of type decimal to its ASCII representation in a C
        char* string.
   -->
   转换一个decimal类型变量到C char*字符串中ASCII表示。
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        <!--
        The function receives a pointer to a variable of type decimal
        (<literal>np</>) that it converts to its textual representation.
        <literal>cp</> is the buffer that should hold the result of the
        operation. The parameter <literal>right</> specifies, how many digits
        right of the decimal point should be included in the output. The result
        will be rounded to this number of decimal digits. Setting
        <literal>right</> to -1 indicates that all available decimal digits
        should be included in the output. If the length of the output buffer,
        which is indicated by <literal>len</> is not sufficient to hold the
        textual representation including the trailing zero byte, only a
        single <literal>*</> character is stored in the result and -1 is
        returned.
-->
函数接收一个指向decimal(<literal>np</>)类型文本表示的变量的指针。
<literal>cp</>是保存操作结果的缓冲区。参数<literal>right</>指明小数点右边有多少位数字应该包含在输出中。结果将四舍五入小数数字位数。设置<literal>right</>到-1表明所有可用的小数位数应包含在输出中。如果由<literal>len</> 指明的输出缓冲区的长度不足以保持包含尾随NUL字符的文本表示，仅仅在结果中存储一个单一的<literal>*</>字符并且返回-1。
       </para>

       <!--
<para>
        The function returns either -1 if the buffer <literal>cp</> was too
        small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</> if memory was
        exhausted.
       </para>
-->
<para>
       如果缓冲区<literal>cp</>太小，函数则返回-1，如果内存耗尽，
   则返回<literal>ECPG_INFORMIX_OUT_OF_MEMORY</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</></term>
      <listitem>
       
<para>
       <!--
        Convert a variable of type decimal to a double.
   -->
   转换一个decimal类型的变量到一个double类型。
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        <!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the double variable that
        should hold the result of the operation (<literal>dblp</>).
-->
函数接受一个指向decimal值转换（<literal>np</>）和
一个指向应保持操作结果(<literal>dblp</>)的double变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the conversion
        failed.
       </para>
-->
<para>
        成功则返回0，如果转换失败则返回一个负数。   
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</></term>
      <listitem>
       
<para>
       <!--
        Convert a variable to type decimal to an integer.
   -->
   转化一个decimal类型到一个integer类型的变量。
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        <!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the integer variable that
        should hold the result of the operation (<literal>ip</>).
-->
函数接受一个指向decimal值转换(<literal>np</>)和
指向应保持操作结果（<literal>ip</>）的integer变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
       </para>
-->
<para>
       成功则返回0，如果转换失败则返回一个负数。如果发生溢出，
   则返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
</para>
       <!--
<para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits an integer to the range from -32767 to
        32767, while the limits in the ECPG implementation depend on the
        architecture (<literal>-INT_MAX .. INT_MAX</>).
       </para>
-->
<para>
       注意ECPG应用不同于<productname>Informix</productname>应用。
   当ECPG应用中的限制取决于(<literal>-INT_MAX .. INT_MAX</>)的结构，<productname>Informix</productname> 限制integer的范围从-32767到32767。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</></term>
      <listitem>
       
<para>
        <!--
        Convert a variable to type decimal to a long integer.
-->
转换一个decimal类型的变量到一个long integer类型。
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        <!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the long variable that
        should hold the result of the operation (<literal>lngp</>).
-->
函数接受一个decimal值转换(<literal>np</>)和
一个应保持操作结果(<literal>lngp</>)的long变量的指针。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
       </para>
-->
<para>
       成功则返回0，如果转换失败则返回一个负数。
   如果发生溢出，则返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
</para>
       <!--
<para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits a long integer to the range from
        -2,147,483,647 to 2,147,483,647, while the limits in the ECPG
        implementation depend on the architecture (<literal>-LONG_MAX ..
        LONG_MAX</>).
       </para>
-->
<para>
     注意ECPG应用不同于<productname>Informix</productname>应用。当ECPG应用中的限制取决于(<literal>-LONG_MAX ..LONG_MAX</>)的结构，<productname>Informix</productname>限制long integer的范围从-2,147,483,647到2,147,483,647。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</></term>
      <listitem>
       
<para>
        <!--
        Converts a date to a C char* string.
-->
转换一个date类型到C char*字符串。
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        <!--
        The function receives two arguments, the first one is the date to
        convert (<literal>d</> and the second one is a pointer to the target
        string. The output format is always <literal>yyyy-mm-dd</>, so you need
        to allocate at least 11 bytes (including the zero-byte terminator) for the
        string.
-->
这个函数接收2个参数，第一个是日期转换（<literal>d</>和第二个参数是一个指向目标字符串的指针。输出格式总是<literal>yyyy-mm-dd</>，因此你需要为字符串至少分配11个字节（包含0字节终止符）。
       </para>

       <!--
<para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
-->
<para>
       成功函数则返回0，出错时则返回一个负数。
</para>
       <!--
<para>
        Note that ECPG's implementation differs from the <productname>Informix</productname>
        implementation. In <productname>Informix</productname> the format can be influenced by setting
        environment variables. In ECPG however, you cannot change the output
        format.
       </para>
-->
<para>
      注意ECPG应用不同于<productname>Informix</productname>应用。
  <productname>Informix</productname>中格式受到环境变量设置的影响。
  然而在ECPG中，你不能改变输出格式。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</></term>
      <listitem>
      
<para>
         <!--
        Parse the textual representation of a date.
-->
解析日期的文本表示。
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
         <!--
        The function receives the textual representation of the date to convert
        (<literal>str</>) and a pointer to a variable of type date
        (<literal>d</>). This function does not allow you to specify a format
        mask. It uses the default format mask of <productname>Informix</productname> which is
        <literal>mm/dd/yyyy</>. Internally, this function is implemented by
        means of <function>rdefmtdate</>. Therefore, <function>rstrdate</> is
        not faster and if you have the choice you should opt for
        <function>rdefmtdate</> which allows you to specify the format mask
        explicitly.
-->
这个函数接受日期转换(<literal>str</>)的文本表示形式和指向类型date(<literal>d</>)的变量的指针。这个函数不允许你指明格式掩码。它使用<productname>Informix</productname>缺省格式掩码<literal>mm/dd/yyyy</>。实质上，它通过<function>rdefmtdate</>实现的。因此，<function>rstrdate</>不是很快，如果你有选择了，你应该选择<function>rdefmtdate</>，它允许你明确指定掩码格式。
       </para>

       <!--
<para>
        The function returns the same values as <function>rdefmtdate</>.
       </para>
-->
<para>
       函数返回和<function>rdefmtdate</>一样的值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</></term>
      <listitem>
       
<para>
       <!--
        Get the current date.
    -->

获取当前日期。
<synopsis>
void rtoday(date *d);
</synopsis>
        <!--
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
-->
函数接受一个设置当前日期的日期变量(<literal>d</>)的指针。
       </para>

       <!--
<para>
        Internally this function uses the <xref linkend="PGTYPESdatetoday">
        function.
       </para>
-->
<para>
        实质上这个函数使用<xref linkend="PGTYPESdatetoday">函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</></term>
      <listitem>
       
<para>
       <!--
        Extract the values for the day, the month and the year from a variable
        of type date.
   -->
   从date类型的变量中提取一天，一个月，一年中的值。
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        <!--
        The function receives the date <literal>d</> and a pointer to an array
        of 3 short integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
-->
这个函数接受日期<literal>d</>和一个指向3个短整型数值<literal>mdy</>数组的指针，变量名表明了相继顺序：<literal>mdy[0]</> 的设置包含了月数，<literal>mdy[1]</>的设置是一天的值，
<literal>mdy[2]</>包含年的值。
       </para>

       <!--
<para>
        The function always returns 0 at the moment.
       </para>
-->
<para>
        函数此时总是返回0。
</para>
       <!--
<para>
        Internally the function uses the <xref linkend="PGTYPESdatejulmdy">
        function.
       </para>
-->
<para>
       实质上函数使用<xref linkend="PGTYPESdatejulmdy">函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</></term>
      <listitem>
       
<para>
       <!--
        Use a format mask to convert a character string to a value of type
        date.
   -->
   使用格式掩码转换字符串到一个date类型的值。
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        <!--
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
-->
函数接受一个保持操作(<literal>d</>)结果日期值的指针。
格式掩码用于解析日期(<literal>fmt</>)和包含date(<literal>str</>)文本表示形式的C char*字符串。文本表示形式期望匹配格式掩码。然而你不需要有一个1:1字符串映射格式掩码。它仅分析相继顺序并且查找<literal>yy</literal>或者 <literal>yyyy</literal>表明年的位置，<literal>mm</literal>表示月份
和<literal>dd</literal>表示一天的位置。
       </para>

       
<para>
        <!--
        The function returns the following values:
-->
函数返回下列值:

        <itemizedlist>
         <listitem>
          <para>
  <!--
           0 - The function terminated successfully.
  -->
   0 - 函数成功终止。
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</> - The date does not contain
           delimiters between day, month and year. In this case the input
           string must be exactly 6 or 8 bytes long but isn't.
          </para>
-->
<para>
         <literal>ECPG_INFORMIX_ENOSHORTDATE</> - 在日，月和年之间日期不包含定界符。
 在这种情况下输入字符串必须确切地6或8个字节但是不是这样的。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>ECPG_INFORMIX_ENOTDMY</> - The format string did not
           correctly indicate the sequential order of year, month and day.
          </para>
-->
<para>
          <literal>ECPG_INFORMIX_ENOTDMY</> - 格式字符串不能正确显示年，月，日的相继顺序。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>ECPG_INFORMIX_BAD_DAY</> - The input string does not
           contain a valid day.
          </para>
-->
<para>
          <literal>ECPG_INFORMIX_BAD_DAY</> - 输入字符串不包含一个有效的天数。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>ECPG_INFORMIX_BAD_MONTH</> - The input string does not
           contain a valid month.
          </para>
-->
<para>
         <literal>ECPG_INFORMIX_BAD_MONTH</> - 输入字符串不包含一个有效的月份。 
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>ECPG_INFORMIX_BAD_YEAR</> - The input string does not
           contain a valid year.
          </para>
-->
<para>
         <literal>ECPG_INFORMIX_BAD_YEAR</> - 输入字符串不包含一个有效的年份。  
</para>
         </listitem>
        </itemizedlist>
       </para>
       <!--
<para>
        Internally this function is implemented to use the <xref
        linkend="PGTYPESdatedefmtasc"> function. See the reference there for a
        table of example input.
       </para>
-->
<para>
      实质上这个函数使用<xref linkend="PGTYPESdatedefmtasc">函数来实现。
  请参阅这儿的实例输入的表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</></term>
      <listitem>
       
<para>
       <!--
        Convert a variable of type date to its textual representation using a
        format mask.
   -->
   转换一个date类型变量到它的一个格式掩码的文本表示。
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        <!--
        The function receives the date to convert (<literal>d</>), the format
        mask (<literal>fmt</>) and the string that will hold the textual
        representation of the date (<literal>str</>).
-->
这个函数接收一个日期转换(<literal>d</>)，
格式掩码(<literal>fmt</>)和将保持日期(<literal>str</>)的文本表示形式
的字符串。
       </para>

       <!--
<para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
-->
<para>
        成功返回0，如果产生错误则返回一个负值。
</para>
       <!--
<para>
        Internally this function uses the <xref linkend="PGTYPESdatefmtasc">
        function, see the reference there for examples.
       </para>
-->
<para>
      实质上这个函数
  使用<xref linkend="PGTYPESdatefmtasc">函数。请参阅这儿的例子。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</></term>
      <listitem>
      
<para>
        <!--
        Create a date value from an array of 3 short integers that specify the
        day, the month and the year of the date.
-->
从指明日期中的年，月，日的3维短整型数组中创建一个日期值。
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        <!--
        The function receives the array of the 3 short integers
        (<literal>mdy</>) and a pointer to a variable of type date that should
        hold the result of the operation.
-->
这个函数接收一个3维短整型(<literal>mdy</>)数组
和一个指向应保持操作结果的日期类型变量的指针。
       </para>

       <!--
<para>
        Currently the function returns always 0.
       </para>
-->
<para>
       当前这个函数总是返回0。
</para>
       <!--
<para>
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatemdyjul">.
       </para>
-->
<para>
         实质上这个函数使用<xref linkend="PGTYPESdatemdyjul">来实现。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</></term>
      <listitem>
       
<para>
       <!--
        Return a number representing the day of the week for a date value.
-->
返回一个数字表示的一个日期值中某一周的某一天。
<synopsis>
int rdayofweek(date d);
</synopsis>
        <!--
The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
-->
函数接收日期变量<literal>d</>作为其唯一的参数并返回一个整数，
表示这一天是星期几。
        <itemizedlist>
         <listitem>
          <para>
   <!--
           0 - Sunday
   -->
   0 - 星期日
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           1 - Monday
          </para>
-->
<para>
          1 - 星期一
</para>
         </listitem>
         <listitem>
          <!--
<para>
           2 - Tuesday
          </para>
-->
<para>
          2 -  星期二
</para>
         </listitem>
         <listitem>
          <!--
<para>
           3 - Wednesday
          </para>
-->
<para>
            3 - 星期三
</para>
         </listitem>
         <listitem>
          <!--
<para>
           4 - Thursday
          </para>
-->
<para>
           4 -  星期四
</para>
         </listitem>
         <listitem>
          <!--
<para>
           5 - Friday
          </para>
-->
<para>
          5 -  星期五
</para>
         </listitem>
         <listitem>
          <!--
<para>
           6 - Saturday
          </para>
-->
<para>
          6 - 星期六
</para>
         </listitem>
        </itemizedlist>
       </para>
       <!--
<para>
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatedayofweek">.
       </para>
-->
<para>
         实质上这个函数使用<xref linkend="PGTYPESdatedayofweek">来实现。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</></term>
      <listitem>
       
<para>
        <!--
        Retrieve the current timestamp.
-->

检索当前的timestamp。
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        <!--
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
-->
这个函数检索当前timestamp并且保存
它到<literal>ts</>指向的timestamp变量中。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</></term>
      <listitem>
       
<para>
       <!--
        Parses a timestamp from its textual representation
        into a timestamp variable.
    -->
解析一个文本表示的timestamp到一个timestamp变量。
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        <!--
        The function receives the string to parse (<literal>str</>) and a
        pointer to the timestamp variable that should hold the result of the
        operation (<literal>ts</>).
-->
这个函数接收解析字符串（<literal>str</>）
和一个指向应保持操作结果（<literal>ts</>）的timestamp变量的指针。
       </para>

       <!--
<para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
-->
<para>
       成功时函数返回0，发生错误的时候返回负数。
</para>
       <!--
<para>
        Internally this function uses the <xref
        linkend="PGTYPEStimestampfromasc"> function. See the reference there
        for a table with example inputs.
       </para>
-->
<para>
      实质上这个函数使用
  <xref linkend="PGTYPEStimestampfromasc">函数。
  请参见这儿的实例输入的表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</></term>
      <listitem>
       
<para>
       <!--
        Parses a timestamp from its textual representation
        using a format mask into a timestamp variable.
    -->
使用格式掩码解析文本表示的timestamp为timestamp变量。
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        <!--
        The function receives the string to parse (<literal>inbuf</>), the
        format mask to use (<literal>fmtstr</>) and a pointer to the timestamp
        variable that should hold the result of the operation
        (<literal>dtvalue</>).
-->
这个函数接收解析(<literal>inbuf</>)字符串，
使用(<literal>fmtstr</>)格式掩码，
以及一个指向保持操作(<literal>dtvalue</>)结果的timestamp变量的指针。

       </para>


       <!--
<para>
        This function is implemented by means of the 
<xref linkend="PGTYPEStimestampdefmtasc"> function. See the documentation
        there for a list of format specifiers that can be used.
       </para>
-->
<para>
       这个函数
   通过<xref linkend="PGTYPEStimestampdefmtasc"> 函数来实现。参见文档中使用的格式说明符列表。
</para>
       <!--
<para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
-->
<para>
       成功时函数返回0，发生错误的时候则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</></term>
      <listitem>
       
<para>
       <!--
        Subtract one timestamp from another and return a variable of type
        interval.
-->
一个timestamp与另一个相减，并且返回一个区间类型变量。
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        <!--
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
-->
该函数将时间戳变量相减，
其中<literal>ts2</>指向<literal>ts1</>指向的时间戳变量，
并将结果存储在<literal>iv</>指向的区间变量中。
       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
        成功时函数返回0，如果发生错误则返回一个负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</></term>
      <listitem>
       
<para>
         <!--
        Convert a timestamp variable to a C char* string.
-->
转换一个timestamp变量到C char*字符串。
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        <!--
        The function receives a pointer to the timestamp variable to convert
        (<literal>ts</>) and the string that should hold the result of the
        operation <literal>output</>). It converts <literal>ts</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
-->
这个函数接收一个指向timestamp变量转换(<literal>ts</>）
的指针和保持操作<literal>output</>结果的字符串。
根据SQL标准，转换<literal>ts</>到它的一个文本表示形式，
即<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
        成功函数返回0，如果产生错误则返回负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</></term>
      <listitem>
       
<para>
       <!--
        Convert a timestamp variable to a C char* using a format mask.
   -->
   使用格式掩码将timestamp变量转换成C char*。
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        <!--
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
-->
这个函数接收一个指向作为第一个参数(<literal>ts</>)转换的timestamp的指针，以及指向输出缓存（<literal>output</>）的指针，
已经分配给输出缓存(<literal>str_len</literal>)的
最大长度和用于转换（<literal>fmtstr</literal>）的格式掩码。
       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
       成功时函数返回0，如果产生错误则返回一个负数。
</para>
       <!--
<para>
        Internally, this function uses the <xref
        linkend="PGTYPEStimestampfmtasc"> function. See the reference there for
        information on what format mask specifiers can be used.
       </para>
-->
<para>
        实质上，这个函数
使用<xref linkend="PGTYPEStimestampfmtasc">函数。
请参阅有关格式掩码说明的使用获取更多信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</></term>
      <listitem>
       
<para>
        <!--
        Convert an interval variable to a C char* string.
-->
将区间变量转换成C char*字符串。
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        <!--
        The function receives a pointer to the interval variable to convert
        (<literal>i</>) and the string that should hold the result of the
        operation <literal>str</>). It converts <literal>i</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
-->
这个函数接收一个指向区间 变量转换(<literal>i</>)的指针和
保持操作(<literal>str</>)结果的字符串。
它依照SQL标准将<literal>i</>转换成文本表示形式，
即<literal>YYYY-MM-DD HH:MM:SS</literal>。

       </para>

       <!--
<para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
-->
<para>
         成功时函数返回0，如果产生错误则返回负数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</></term>
      <listitem>
       
<para>
        <!--
        Convert a long integer value to its textual representation using a
        format mask.
-->
将长整型数值转换成使用格式掩码的文本表示形式。
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
       <!--
        The function receives the long value <literal>lng_val</>, the format
        mask <literal>fmt</> and a pointer to the output buffer
        <literal>outbuf</>. It converts the long value according to the format
        mask to its textual representation.
-->
这个函数接收长值<literal>lng_val</>，
格式掩码<literal>fmt</>和指向输出缓存<literal>outbuf</>的指针。
它依照格式掩码将长值转换成文本表示形式。
       </para>

       
<para>
        <!--
        The format mask can be composed of the following format specifying
        characters:
-->
格式掩码由下面格式指定字符组成。

        <itemizedlist>
         <listitem>
          <para>
   <!--
           <literal>*</literal> (asterisk) - if this position would be blank
           otherwise, fill it with an asterisk.
   -->
   <literal>*</literal>(星号) – 如果这个位置是空白的，否则，用星号填充。
   
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           <literal>&amp;</literal> (ampersand) - if this position would be
           blank otherwise, fill it with a zero.
          </para>
-->
<para>
        <literal>&amp;</literal>(&符号) -如果这个位置是空白的，否则，用零填充。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>#</literal> - turn leading zeroes into blanks.
          </para>
-->
<para>
           <literal>#</literal> - 将前导零转换成空格。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>&lt;</literal> - left-justify the number in the string.
          </para>
-->
<para>
           <literal>&lt;</literal> -字符串中左对齐数字。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>,</literal> (comma) - group numbers of four or more digits
           into groups of three digits separated by a comma.
          </para>
-->
<para>
         <literal>,</literal>(逗号)–将四个或更多数字分成由逗号分隔的三个数字一组。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>.</literal> (period) - this character separates the
           whole-number part of the number from the fractional part.
          </para>
-->
<para>
       <literal>.</literal>(句号) – 这个字符将从小数部分分离出数的整数部分。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>-</literal> (minus) - the minus sign appears if the number
           is a negative value.
          </para>
-->
<para>
          <literal>-</literal> (减号) – 如果数是负值，则出现负号。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>+</literal> (plus) - the plus sign appears if the number is
           a positive value.
          </para>
-->
<para>
          <literal>+</literal>(加号) -如果数是正值，则出现加号。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>(</literal> - this replaces the minus sign in front of the
           negative number. The minus sign will not appear.
          </para>
-->
<para>
             <literal>(</literal> -这将替代负数前面的减号。减号将不会出现。 
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>)</literal> - this character replaces the minus and is
           printed behind the negative value.
          </para>
-->
<para>
         <literal>)</literal> -这个字符替代减号，并且在负数后面输出。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>$</literal> - the currency symbol.
          </para>
-->
<para>
          <literal>$</literal> - 货币符号。
</para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</></term>
      <listitem>
       
<para>
       <!--
        Convert a string to upper case.
   -->
   将字符串转换为大写。
<synopsis>
void rupshift(char *str);
</synopsis>
        <!--
        The function receives a pointer to the string and transforms every
        lower case character to upper case.
-->
这个函数接收一个指向字符串的指针，并且将每个小写字符转换成大写字符。

       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</></term>
      <listitem>
      
<para>
        <!--
        Return the number of characters in a string without counting trailing
        blanks.
-->
返回没有计算空格的字符串中字符的数量。
<synopsis>
int byleng(char *str, int len);
</synopsis>
         <!--
        The function expects a fixed-length string as its first argument
        (<literal>str</>) and its length as its second argument
        (<literal>len</>). It returns the number of significant characters,
        that is the length of the string without trailing blanks.
-->
这个函数期望固定长度字符串作为它第一个参数(<literal>str</>)，
并且其长度作为第二个参数(<literal>len</>)。
它返回重要字符数，它是没有空格的字符串的长度。
       </para>


      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</></term>
      <listitem>
       
<para>
       <!--
        Copy a fixed-length string into a null-terminated string.
   -->
   复制一个固定长度字符串到空终止符字符串中。
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        <!--
        The function receives the fixed-length string to copy
        (<literal>src</>), its length (<literal>len</>) and a pointer to the
        destination memory (<literal>dest</>). Note that you need to reserve at
        least <literal>len+1</> bytes for the string that <literal>dest</>
        points to. The function copies at most <literal>len</> bytes to the new
        location (less if the source string has trailing blanks) and adds the
        null-terminator.
-->
函数接收固定长度的字符串复制（<literal>src</>），
其长度（<literal>len</>）和一个指向目标内存（<literal>dest</>）的指针。
注意，你需要为<literal>dest</>指向的字符串至少储备<literal>len+1</>字节。
函数复制最多<literal>len</>字节到新的位置（至少如果源字符串有尾随空格）
和添加空终止符。
       </para>


      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</></term>
      <listitem>
       
<para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        <!--
        This function exists but is not implemented at the moment!
-->
这个函数存在但此刻不能实现。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</></term>
      <listitem>
       
<para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        <!--
        This function exists but is not implemented at the moment!
-->
这个函数存在但此刻不能实现。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</></term>
      <listitem>
       
<para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        <!--
        This function exists but is not implemented at the moment!
-->
这个函数存在但此刻不能实现。
       </para>


      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</></term>
      <listitem>
      
<para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
         <!--
        This function exists but is not implemented at the moment!
-->
这个函数存在但此刻不能实现。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</></term>
      <listitem>
       
<para>
       <!--
        Set a variable to NULL.
   -->
   设置一个变量为空。
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        <!--
        The function receives an integer that indicates the type of the
        variable and a pointer to the variable itself that is cast to a C
        char* pointer.
-->
这个函数接收一个表明变量类型的整数和一个指向映射到C char*指针的变量自身的指针。
       </para>

       
<para>
        <!--
        The following types exist:
-->
存在下面类型:
        <itemizedlist>
         <listitem>
          <para>
   <!--
           <literal>CCHARTYPE</literal> - For a variable of type <type>char</type> or <type>char*</type>
   -->
   <literal>CCHARTYPE</literal> - 为了类型<type>char</type> 或者<type>char*</type>的变量
          </para>

         </listitem>
         <listitem>
          <!--
<para>
           <literal>CSHORTTYPE</literal> - For a variable of type <type>short int</type>
          </para>
-->
<para>
         <literal>CSHORTTYPE</literal> - 为了类型<type>short int</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CINTTYPE</literal> - For a variable of type <type>int</type>
          </para>
-->
<para>
           <literal>CINTTYPE</literal> -为了类型为<type>int</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CBOOLTYPE</literal> - For a variable of type <type>boolean</type>
          </para>
-->
<para>
            <literal>CBOOLTYPE</literal> -为了类型<type>boolean</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CFLOATTYPE</literal> - For a variable of type <type>float</type>
          </para>
-->
<para>
            <literal>CFLOATTYPE</literal> - 为了类型<type>float</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CLONGTYPE</literal> - For a variable of type <type>long</type>
          </para>
-->
<para>
          <literal>CLONGTYPE</literal> - 为了类型<type>long</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CDOUBLETYPE</literal> - For a variable of type <type>double</type>
          </para>
-->
<para>
        <literal>CDOUBLETYPE</literal> - 为了类型<type>double</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CDECIMALTYPE</literal> - For a variable of type <type>decimal</type>
          </para>
-->
<para>
          <literal>CDECIMALTYPE</literal> - 为了类型<type>decimal</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CDATETYPE</literal> - For a variable of type <type>date</type>
          </para>
-->
<para>
        <literal>CDATETYPE</literal> - 为了类型<type>date</type>的变量
</para>
         </listitem>
         <listitem>
          <!--
<para>
           <literal>CDTIMETYPE</literal> - For a variable of type <type>timestamp</type>
          </para>
-->
<para>
       <literal>CDTIMETYPE</literal> - 为了类型<type>timestamp</type>的变量
</para>
         </listitem>
        </itemizedlist>
       </para>

       
<para>
        <!--
        Here is an example of a call to this function:
-->

下面是调用这个函数的一个例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</></term>
      <listitem>
       
<para>
        <!--
        Test if a variable is NULL.
-->
如果变量是空，测试：
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        <!--
        The function receives the type of the variable to test (<literal>t</>)
        as well a pointer to this variable (<literal>ptr</>). Note that the
        latter needs to be cast to a char*. See the function <xref
        linkend="rsetnull"> for a list of possible variable types.
-->
这个函数接收测试（<literal>t</>）变量的类型以及
一个指向这个变量（<literal>ptr</>）的指针。
注意后者需要映射到一个char*。
参见函数<xref linkend="rsetnull">获取可能变量类型的列表。
       </para>


       
<para>
        <!--
        Here is an example of how to use this function:
-->
这儿是如何使用这个函数的一个例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>

      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
  <!--
   <title>Additional Constants</title>
  -->
    <title>附加常量</title>
   
<para>
    <!--
    Note that all constants here describe errors and all of them are defined
    to represent negative values. In the descriptions of the different
    constants you can also find the value that the constants represent in the
    current implementation. However you should not rely on this number. You can
    however rely on the fact all of them are defined to represent negative
    values.
-->
注意，这里所有的常量描述错误，他们都被定义为代表负数。
不同常量的描述中，你还可以发现，目前的应用中表示常量的值。
然而你不应该依赖于数量。但是你可以依靠它们被定义为表示负数的事实。

    <variablelist>
     <varlistentry> 
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</></term>
      <listitem>
       <para>
    <!--
        Functions return this value if an overflow occurred in a
        calculation. Internally it is defined as -1200 (the <productname>Informix</productname>
        definition).
-->
如果在计算中发生溢出，函数返回这个值。
实质上它被定义为-1200（<productname>Informix</productname>定义）。

       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</></term>
      <listitem>
       <!--
<para>
        Functions return this value if an underflow occurred in a calculation.
        Internally it is defined as -1201 (the <productname>Informix</productname> definition).
       </para>
-->
<para>
        如果在计算中发生下溢，函数返回这个值。
实质上它被定义为-1201(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</></term>
      <listitem>
       <!--
<para>
        Functions return this value if an attempt to divide by zero is
        observed. Internally it is defined as -1202 (the <productname>Informix</productname> definition).
       </para>
-->
<para>
      如果观察到尝试除以零，函数返回这个值。实质上它被定义为 -1202（<productname>Informix</productname>定义）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a bad value for a year was found while
        parsing a date. Internally it is defined as -1204 (the <productname>Informix</productname>
        definition).
       </para>
-->
<para>
        如果当解析一个日期时，发现某年的一个错误值，函数返回这个值。实质上它被定义为-1204(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a bad value for a month was found while
        parsing a date. Internally it is defined as -1205 (the <productname>Informix</productname>
        definition).
       </para>
-->
<para>
       如果当解析一个日期时，发现某月的一个错误值，函数返回这个值。实质上它被定义为-1205(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a bad value for a day was found while
        parsing a date. Internally it is defined as -1206 (the <productname>Informix</productname>
        definition).
       </para>
-->
<para>
       如果解析一个日期的时候，发现某天的错误值，函数返回这个值，实质上它被定义为-1206(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a parsing routine needs a short date
        representation but did not get the date string in the right length.
        Internally it is defined as -1209 (the <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果解析程序需要一个短日期表示形式而没有获得正确长度的日期字符串，函数则返回这个数值。
   实质上它被定义为-1209(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</></term>
      <listitem>
       <!--
<para>
        Functions return this value if an error occurred during date
        formatting.  Internally it is defined as -1210 (the
        <productname>Informix</productname> definition).
       </para>
-->
<para>
      如果在日期格式之间发生错误，那么函数返回该值。
  实质上它被定义为-1210(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</></term>
      <listitem>
       <!--
<para>
        Functions return this value if memory was exhausted during
        their operation.  Internally it is defined as -1211 (the
        <productname>Informix</productname> definition).
       </para>
-->
<para>
      如果在操作期间内存耗尽，那么函数返回该值。实质上
  它被定义为-1211（<productname>Informix</productname>定义）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a parsing routine was supposed to get a
        format mask (like <literal>mmddyy</>) but not all fields were listed
        correctly. Internally it is defined as -1212 (the <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果解析程序应该得到一个掩码格式
   （如<literal>mmddyy</>）但不是所有的字段都被正确地列出来，函数返回该值。
   实质上它被定义为-1212(<productname>Informix</productname>定义)。
</para>
      </listitem> 
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</></term>
      <listitem>
       <!--
<para>
        Functions return this value either if a parsing routine cannot parse
        the textual representation for a numeric value because it contains
        errors or if a routine cannot complete a calculation involving numeric
        variables because at least one of the numeric variables is invalid.
        Internally it is defined as -1213 (the <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果一个解析程序无法解析为数字值的文本表示，
   因为它包含错误，或者如果程序不能完成涉及数值变量的计算，
   因为至少这些数值变量之一是无效的。那么该函数返回这个值。 
   实质上它被定义为-1213(<productname>Informix</productname>定义)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a parsing routine cannot parse
        an exponent.  Internally it is defined as -1216 (the
        <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果解析程序无法解析指数，那么该函数返回此值。
   实质地被定义为-1216
   （<productname>Informix</productname>定义）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a parsing routine cannot parse
        a date.  Internally it is defined as -1218 (the
        <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果解析程序不能解析日期，那么该函数返回此值。
   实质上它被定义为-1218（<productname>Informix</productname>定义）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</></term>
      <listitem>
       <!--
<para>
        Functions return this value if a parsing routine is passed extra
        characters it cannot parse.  Internally it is defined as -1264 (the
        <productname>Informix</productname> definition).
       </para>
-->
<para>
       如果不能解析的多余字符被传递给解析程序，那么该函数返回这个值。
   实质上它被定义为-1264（<productname>Informix</productname>定义）。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-develop">
 <!--
  <title>Internals</title>
  -->
  <title>内部</title>

  <!--
<para>
   This section explains how <application>ECPG</application> works
   internally. This information can occasionally be useful to help
   users understand how to use <application>ECPG</application>.
  </para>
-->
<para>
    这一节解释<application>ECPG</application>在内部是如何运转的。
这些信息有时候可以帮助用户理解如何使用<application>ECPG</application>。
</para>

   <!--
<para>
    The first four lines written by <command>ecpg</command> to the
    output are fixed lines.  Two are comments and two are include
    lines necessary to interface to the library.  Then the
    preprocessor reads through the file and writes output.  Normally
    it just echoes everything to the output.
   </para>
-->
<para>
     <command>ecpg</command>写到输出里的头四行是固定的行。两行是注释，
 另外两行是与库接口的必要行。
 然后预处理器读取文件并且写输出流。
 通常它只是把所有东西都回显到输出中去。
</para>

   <!--
<para>
    When it sees an <command>EXEC SQL</command> statement, it
    intervenes and changes it. The command starts with <command>EXEC
    SQL</command> and ends with <command>;</command>. Everything in
    between is treated as an <acronym>SQL</acronym> statement and
    parsed for variable substitution.
   </para>
-->
<para>
     如果它看到一个<command>EXEC SQL</command>语句，
 它就变换并且修改它。命令以<command>EXEC SQL</command>开头，以<command>;</command>结尾。
 所有在中间的东西都被当
 作一个<acronym>SQL</acronym>语句并且进行变量代换的解析。
</para>

   <!--
<para>
    Variable substitution occurs when a symbol starts with a colon
    (<literal>:</literal>). The variable with that name is looked up
    among the variables that were previously declared within a
    <literal>EXEC SQL DECLARE</> section.
   </para>
-->
<para>
    如果一个符号以一个冒号（<literal>:</literal>）开头，则发生变量代换。 
在<literal>EXEC SQL DECLARE</>段里预先声明的变量中找出该名字的变量。
</para>

   <!--
<para>
    The most important function in the library is
    <function>ECPGdo</function>, which takes care of executing most
    commands. It takes a variable number of arguments. This can easily
    add up to 50 or so arguments, and we hope this will not be a
    problem on any platform.
   </para>
-->
<para>
  库里面最重要的函数是<function>ECPGdo</function>，它负责执行大多数命令。
  它接受变量的参数个数。
  这些参数的个数可能很容易达到50个或者更多，
  我们希望在任何平台上这都不是问题。
</para>

   
<para>
    <!--
    The arguments are:
    -->
参数是：
    <variablelist>
     <varlistentry>
 <!--
      <term>A line number</term>
 -->
   <term>行号</term>
      <listitem>
       <para>
    <!--
        This is the line number of the original line; used in error
        messages only.
-->
这是原始行的行号；只是在错误消息中使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
 <!--
      <term>A string</term>
 -->
   <term>字符串</term>
      <listitem>
       <!--
<para>
        This is the <acronym>SQL</acronym> command that is to be issued.
        It is modified by the input variables, i.e., the variables that
        where not known at compile time but are to be entered in the
        command. Where the variables should go the string contains
        <literal>?</literal>.
       </para>
-->
<para>
        这是要发出的<acronym>SQL</acronym>命令。
它被输入变量修改，也就是说，在编译时未知的，
但是需要输入到命令中的变量。
此处变量应该包含字符串<literal>?</literal>。

</para>
      </listitem>
     </varlistentry>

     <varlistentry>
 <!--
      <term>Input variables</term>
 -->
   <term>输入变量</term>
      <listitem>
       <!--
<para>
        Every input variable causes ten arguments to be created.  (See below.)
       </para>
-->
<para>
     每个输入变量都导致十个参数的生成。（见下文） 
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <!--
<para>
        An <type>enum</> telling that there are no more input
        variables.
       </para>
-->
<para>
       一个<type>enum</>告诉没有更多输入变量了。 
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
  <!--
      <term>Output variables</term>
  -->
  <term>输出变量</term>
      <listitem>
       <!--
<para>
        Every output variable causes ten arguments to be created.
        (See below.)  These variables are filled by the function.
       </para>
-->
<para>
        每个输出变量导致十个参数的创建。（见下文）
这些变量被这些函数填充。 
</para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <!--
<para>
        An <type>enum</> telling that there are no more variables.
       </para>
-->
<para>
       一个指出没有更多变量的<type>enum</>。 
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   
<para>
    <!--
    For every variable that is part of the <acronym>SQL</acronym>
    command, the function gets ten arguments:
    -->
对于每个属于<acronym>SQL</acronym>命令一部分的变量，
函数可以得到十个参数：
    <orderedlist>
     <listitem>
      <para>
   <!--
       The type as a special symbol.
   -->
   作为特殊符号的类型。
      </para>

     </listitem>

     <listitem>
      <!--
<para>
       A pointer to the value or a pointer to the pointer.
      </para>
-->
<para>
       一个指向其数值的指针，或者一个指向指针的指针。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The size of the variable if it is a <type>char</type> or <type>varchar</type>.
      </para>
-->
<para>
       如果变量大小是<type>char</type>或者<type>varchar</type>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The number of elements in the array (for array fetches).
      </para>
-->
<para>
        数组中元素的个数（用于抓取数组）。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The offset to the next element in the array (for array fetches).
      </para>
-->
<para>
     指向数组中下一个元素的偏移量（用于抓取数组）。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The type of the indicator variable as a special symbol.
      </para>
-->
<para>
      作为一种特殊符号的指示器变量的类型。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       A pointer to the indicator variable.
      </para>
-->
<para>
       一个指向指示器变量的指针。
</para>
     </listitem>

     <listitem>
      
<para>
       0
      </para>

     </listitem>

     <listitem>
      <!--
<para>
       The number of elements in the indicator array (for array fetches).
      </para>
-->
<para>
     指示器数组中的元素个数（用于抓取数组）。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The offset to the next element in the indicator array (for
       array fetches).
      </para>
-->
<para>
       指向指示器数组的下一个元素的偏移量（用于抓取数组）。
</para>
     </listitem>
    </orderedlist>
   </para>

   
<para>
    <!--
    Note that not all SQL commands are treated in this way.  For
    instance, an open cursor statement like:
-->
    请注意，不是所有SQL命令都这么被对待。
比如，一个像下面这样的打开游标的语句。

<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    <!--
    is not copied to the output. Instead, the cursor's
    <command>DECLARE</> command is used at the position of the <command>OPEN</> command
    because it indeed opens the cursor.
-->
不会被拷贝到输出中。
而是在<command>OPEN</>命令的位置使用游标的<command>DECLARE</>命令， 因为它同样也打开游标。
   </para>

   
<para>
   <!--
    Here is a complete example describing the output of the
    preprocessor of a file <filename>foo.pgc</filename> (details might
    change with each particular version of the preprocessor):
-->
下面是一个完整的例子，描述了文件<filename>foo.pgc</filename> 的预处理后的输出（细节可能随着每个不同的预处理器版本而变化）： 
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    <!--
    is translated into:
-->
被翻译成：

<!--
<programlisting><![CDATA[

/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */

#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
 
/* exec sql end declare section */

...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
-->

<programlisting><![CDATA[

/* 通过ecpg (2.6.0)处理，通过预处理器添加2个include文件*/

#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql开始声明段 */

#line 1 "foo.pgc"

 int index;
 int result;
 
/* exec sql结束声明段 */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>


    <!--
    (The indentation here is added for readability and not
    something the preprocessor does.)
-->
(这里的凹进是为了增强可读性加的，可不是预处理器能干的事情。)
   </para>

 </sect1>
</chapter>
