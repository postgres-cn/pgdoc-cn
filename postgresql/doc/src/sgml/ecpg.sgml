<!-- doc/src/sgml/ecpg.sgml -->

<chapter id="ecpg">
<!--==========================orignal english content==========================
 <title><application>ECPG</application> - Embedded <acronym>SQL</acronym> in C</title>
____________________________________________________________________________-->
 <title><application>ECPG</application> - C 中的嵌入式 <acronym>SQL</acronym></title>

<!--==========================orignal english content==========================
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
<!--==========================orignal english content==========================
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

<!--==========================orignal english content==========================
 <para>
  This chapter describes the embedded <acronym>SQL</acronym> package
  for <productname>PostgreSQL</productname>. It was written by
  Linus Tolke (<email>linus@epact.se</email>) and Michael Meskes
  (<email>meskes@postgresql.org</email>). Originally it was written to work with
  <acronym>C</acronym>. It also works with <acronym>C++</acronym>, but
  it does not recognize all <acronym>C++</acronym> constructs yet.
 </para>
____________________________________________________________________________-->
 <para>
  这一章描述了用于<productname>PostgreSQL</productname>的嵌入式<acronym>SQL</acronym>包。它由 Linus Tolke（<email>linus@epact.se</email>）和 Michael Meskes（<email>meskes@postgresql.org</email>）编写。最初它是为了与<acronym>C</acronym>一起工作而编写的。它也能与<acronym>C++</acronym>配合，但是它还不识别所有的<acronym>C++</acronym>结构。
 </para>

<!--==========================orignal english content==========================
 <para>
  This documentation is quite incomplete.  But since this
  interface is standardized, additional information can be found in
  many resources about SQL.
 </para>
____________________________________________________________________________-->
 <para>
  这份文档还远没有完成。但是因为这个结构是标准化的，额外的信息可以在有关 SQL 的很多资源中找到。
 </para>

 <sect1 id="ecpg-concept">
<!--==========================orignal english content==========================
  <title>The Concept</title>
____________________________________________________________________________-->
  <title>概念</title>

<!--==========================orignal english content==========================
  <para>
   An embedded SQL program consists of code written in an ordinary
   programming language, in this case C, mixed with SQL commands in
   specially marked sections.  To build the program, the source code (<filename>*.pgc</filename>)
   is first passed through the embedded SQL preprocessor, which converts it
   to an ordinary C program (<filename>*.c</filename>), and afterwards it can be processed by a C
   compiler.  (For details about the compiling and linking see <xref linkend="ecpg-process">).
   Converted ECPG applications call functions in the libpq library
   through the embedded SQL library (ecpglib), and communicate with
   the PostgreSQL server using the normal frontend-backend protocol.
  </para>
____________________________________________________________________________-->
  <para>
   一个嵌入式 SQL 程序由一种普通编程语言编写的代码（在这里是 C）和位于特殊标记的小节中的 SQL 命令混合组成。要构建该程序，源代码（<filename>*.pgc</filename>）首先会通过嵌入式 SQL 预处理器，它会将源代码转换成一个普通 C 程序（<filename>*.c</filename>），并且后来它能够被一个 C 编译器所处理（编译和链接详见<xref linkend="ecpg-process">）。转换过的 ECPG 应用会通过嵌入式 SQL 库（ecpglib）调用 libpq 库中的函数，并且与 PostgreSQL 服务器使用普通的前端/后端协议通信。
  </para>

<!--==========================orignal english content==========================
  <para>
   Embedded <acronym>SQL</acronym> has advantages over other methods
   for handling <acronym>SQL</acronym> commands from C code. First, it
   takes care of the tedious passing of information to and from
   variables in your <acronym>C</acronym> program.  Second, the SQL
   code in the program is checked at build time for syntactical
   correctness.  Third, embedded <acronym>SQL</acronym> in C is
   specified in the <acronym>SQL</acronym> standard and supported by
   many other <acronym>SQL</acronym> database systems.  The
   <productname>PostgreSQL</> implementation is designed to match this
   standard as much as possible, and it is usually possible to port
   embedded <acronym>SQL</acronym> programs written for other SQL
   databases to <productname>PostgreSQL</productname> with relative
   ease.
  </para>
____________________________________________________________________________-->
  <para>
   嵌入式<acronym>SQL</acronym>在为 C 代码处理<acronym>SQL</acronym>命令方面比起其他方法来具有优势。首先，它会搞定向你的<acronym>C</acronym>程序变量传递或者读取信息时的繁文缛节。其次，程序中的 SQL 代码在编译时就会被检查以保证语法正确性。第三，C 中的嵌入式<acronym>SQL</acronym>是在<acronym>SQL</acronym>标准中指定的并且受到很多其他<acronym>SQL</acronym>数据库系统的支持。<productname>PostgreSQL</>实现被设计为尽可能匹配这个标准，并且通常可以相对容易地把为其他 SQL 数据库编写的<acronym>SQL</acronym>程序移植到<productname>PostgreSQL</productname>。
  </para>

<!--==========================orignal english content==========================
  <para>
   As already stated, programs written for the embedded
   <acronym>SQL</acronym> interface are normal C programs with special
   code inserted to perform database-related actions.  This special
   code always has the form:
<programlisting>
EXEC SQL ...;
</programlisting>
   These statements syntactically take the place of a C statement.
   Depending on the particular statement, they can appear at the
   global level or within a function.  Embedded
   <acronym>SQL</acronym> statements follow the case-sensitivity rules of
   normal <acronym>SQL</acronym> code, and not those of C. Also they allow nested
   C-style comments that are part of the SQL standard. The C part of the
   program, however, follows the C standard of not accepting nested comments.
  </para>
____________________________________________________________________________-->
  <para>
   正如已经支出的，为嵌入式<acronym>SQL</acronym>接口编写的程序是插入了用于执行数据库相关动作的特殊代码的普通的 C 程序。这种特殊代码总是具有这样的形式：
<programlisting>
EXEC SQL ...;
</programlisting>
   这些语句在语法上取代了一个 C 语句。取决于特定的语句，它们可以出现在全局层面或者是一个函数中。嵌入式
   <acronym>SQL</acronym>语句遵循普通<acronym>SQL</acronym>代码的大小写敏感性规则，
   而不是 C 的大小写敏感性规则。它们也允许嵌套的 C 风格注释（SQL 标准的一部分）。
   不过，程序的 C 部分遵循 C 的标准不接受嵌套注释。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following sections explain all the embedded SQL statements.
  </para>
____________________________________________________________________________-->
  <para>
   下列小节解释了所有嵌入式 SQL 语句。
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
<!--==========================orignal english content==========================
  <title>Managing Database Connections</title>
____________________________________________________________________________-->
  <title>管理数据库连接</title>

<!--==========================orignal english content==========================
  <para>
   This section describes how to open, close, and switch database
   connections.
  </para>
____________________________________________________________________________-->
  <para>
   这一节描述如何打开、关闭以及切换数据库连接。
  </para>

  <sect2 id="ecpg-connecting">
<!--==========================orignal english content==========================
   <title>Connecting to the Database Server</title>
____________________________________________________________________________-->
   <title>连接到数据库服务器</title>

<!--==========================orignal english content==========================
  <para>
   One connects to a database using the following statement:
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   The <replaceable>target</replaceable> can be specified in the
   following ways:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</><optional>@<replaceable>hostname</></optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      an SQL string literal containing one of the above forms
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      a reference to a character variable containing one of the above forms (see examples)
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   If you specify the connection target literally (that is, not
   through a variable reference) and you don't quote the value, then
   the case-insensitivity rules of normal SQL are applied.  In that
   case you can also double-quote the individual parameters separately
   as needed.  In practice, it is probably less error-prone to use a
   (single-quoted) string literal or a variable reference.  The
   connection target <literal>DEFAULT</literal> initiates a connection
   to the default database under the default user name.  No separate
   user name or connection name can be specified in that case.
  </para>
____________________________________________________________________________-->
  <para>
   我们可以使用下列语句连接到一个数据库：
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   <replaceable>target</replaceable>可以用下列方法指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</><optional>@<replaceable>hostname</></optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      一个包含上述形式之一的 SQL 字符串
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      到一个包含上述形式之一（参见例子）的字符变量的引用
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如果你用字面（也就是不通过一个变量引用）指定连接目标并且你没有引用该值，那么将会应用普通 SQL 的大小写不敏感性规则。在那种情况中，你也能够按照需要单独将个体参数放置在双引号中。实际上，使用一个（单引号引用）的字符串或一个变量引用出错的可能性更小。连接目标<literal>DEFAULT</literal>会以默认用户名发起一个到默认数据库的连接。在那种情况中不能指定单独的用户名或连接名。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are also different ways to specify the user name:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   As above, the parameters <replaceable>username</replaceable> and
   <replaceable>password</replaceable> can be an SQL identifier, an
   SQL string literal, or a reference to a character variable.
  </para>
____________________________________________________________________________-->
  <para>
   也有不同的方法来指定用户名：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如上所述，参数<replaceable>username</replaceable>以及<replaceable>password</replaceable>可以是一个 SQL 标识符、一个 SQL 字符串或者一个对字符变量的引用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable>connection-name</replaceable> is used to handle
   multiple connections in one program.  It can be omitted if a
   program uses only one connection.  The most recently opened
   connection becomes the current connection, which is used by default
   when an SQL statement is to be executed (see later in this
   chapter).
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable>connection-name</replaceable>被用来在一个程序中处理多个连接。如果一个程序只使用一个连接，它可以被忽略。最近被打开的连接将成为当前连接，当一个 SQL 语句要被执行时，将默认使用它（见这一章稍后的部分）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here are some examples of <command>CONNECT</command> statements:
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* or EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   The last form makes use of the variant referred to above as
   character variable reference.  You will see in later sections how C
   variables can be used in SQL statements when you prefix them with a
   colon.
  </para>
____________________________________________________________________________-->
  <para>
   这里有一些<command>CONNECT</command>语句的例子：
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* 或者 EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   最后一种形式利用被上文成为字符变量引用的变体。你将在后面的小节中看到当你把 C 变量前放上一个冒号时，它们是怎样被用于 SQL 语句的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Be advised that the format of the connection target is not
   specified in the SQL standard.  So if you want to develop portable
   applications, you might want to use something based on the last
   example above to encapsulate the connection target string
   somewhere.
  </para>
____________________________________________________________________________-->
  <para>
   注意连接目标的格式没有在 SQL 标准中说明。因此如果你想要开发可移植的应用，你可能想要使用某种基于上述最后一个例子的方法来把连接目标字符串封装在某个地方。
  </para>
  </sect2>

  <sect2 id="ecpg-set-connection">
<!--==========================orignal english content==========================
   <title>Choosing a Connection</title>
____________________________________________________________________________-->
   <title>选择一个连接</title>

<!--==========================orignal english content==========================
  <para>
   SQL statements in embedded SQL programs are by default executed on
   the current connection, that is, the most recently opened one.  If
   an application needs to manage multiple connections, then there are
   two ways to handle this.
  </para>
____________________________________________________________________________-->
  <para>
   嵌入式 SQL 程序中的 SQL 语句默认是在当前连接（也就是最近打开的那一个）上执行的。如果一个应用需要管理多个连接，那么有两种方法来处理这种需求。
  </para>

<!--==========================orignal english content==========================
  <para>
   The first option is to explicitly choose a connection for each SQL
   statement, for example:
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   This option is particularly suitable if the application needs to
   use several connections in mixed order.
  </para>
____________________________________________________________________________-->
  <para>
   第一个选项是显式地为每一个 SQL 语句选择一个连接，例如：
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   如果应用需要以混合的顺序使用多个连接，这个选项特别合适。
  </para>

<!--==========================orignal english content==========================
  <para>
   If your application uses multiple threads of execution, they cannot share a
   connection concurrently. You must either explicitly control access to the connection
   (using mutexes) or use a connection for each thread.
  </para>
____________________________________________________________________________-->
  <para>
   如果你的应用使用多个线程执行，它们不能并发地共享一个连接。你必须显式地控制对连接的访问（使用互斥量）或者为每个线程使用一个连接。
  </para>

<!--==========================orignal english content==========================
  <para>
   The second option is to execute a statement to switch the current
   connection.  That statement is:
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   This option is particularly convenient if many statements are to be
   executed on the same connection.
  </para>
____________________________________________________________________________-->
  <para>
   第二个选项是执行一个语句来切换当前的连接。该语句是：
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   如果很多语句要被在同一个连接上执行，这个选项特别方便。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example program managing multiple database connections:
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;

    /* This query would be executed in the last opened database "testdb3". */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* Using "AT" to run a query in "testdb2" */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* Switch the current connection to "testdb1". */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   This example would produce this output:
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   这里有一个管理多个数据库连接的例子程序：
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;

    /* 这个查询将在最近打开的数据库 "testdb3" 中执行 */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* 使用 "AT" 在 "testdb2" 中运行一个查询 */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* 切换当前连接到 "testdb1" */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   这个例子将产生这样的输出：
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
  </sect2>

  <sect2 id="ecpg-disconnect">
<!--==========================orignal english content==========================
   <title>Closing a Connection</title>
____________________________________________________________________________-->
   <title>关闭一个连接</title>

<!--==========================orignal english content==========================
  <para>
   To close a connection, use the following statement:
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   The <replaceable>connection</replaceable> can be specified
   in the following ways:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   If no connection name is specified, the current connection is
   closed.
  </para>
____________________________________________________________________________-->
  <para>
   要关闭一个连接，使用下列语句：
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   <replaceable>connection</replaceable>可以用下列方法指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如果没有指定连接名，当前连接将被关闭。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is good style that an application always explicitly disconnect
   from every connection it opened.
  </para>
____________________________________________________________________________-->
  <para>
   在一个应用中总是显式地从它打开的每一个连接断开是一种好的风格。
  </para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
<!--==========================orignal english content==========================
  <title>Running SQL Commands</title>
____________________________________________________________________________-->
  <title>运行 SQL 命令</title>

<!--==========================orignal english content==========================
  <para>
   Any SQL command can be run from within an embedded SQL application.
   Below are some examples of how to do that.
  </para>
____________________________________________________________________________-->
  <para>
   任何 SQL 命令都可以在一个嵌入式 SQL 应用中被运行。下面是一些在嵌入式 SQL 应用中运行 SQL 命令的例子。
  </para>

  <sect2 id="ecpg-executing">
<!--==========================orignal english content==========================
   <title>Executing SQL Statements</title>
____________________________________________________________________________-->
   <title>执行 SQL 语句</title>

<!--==========================orignal english content==========================
  <para>
   Creating a table:
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个表：
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Inserting rows:
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   插入行：
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Deleting rows:
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   删除行：
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Updates:
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   更新：
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>SELECT</literal> statements that return a single result
   row can also be executed using
   <literal>EXEC SQL</literal> directly.  To handle result sets with
   multiple rows, an application has to use a cursor;
   see <xref linkend="ecpg-cursors"> below.  (As a special case, an
   application can fetch multiple rows at once into an array host
   variable; see <xref linkend="ecpg-variables-arrays">.)
  </para>
____________________________________________________________________________-->
  <para>
   返回一个单一结果行的<literal>SELECT</literal>语句也可以直接使用<literal>EXEC SQL</literal>执行。要处理有多行的结果集，一个应用必须使用一个游标，可参考下面的<xref linkend="ecpg-cursors">（作为一种特殊情况，一个应用可以一次取出多行到一个数组主变量中，参考<xref linkend="ecpg-variables-arrays">）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Single-row select:
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   单行选择：
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Also, a configuration parameter can be retrieved with the
   <literal>SHOW</literal> command:
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   还有，一个配置参数可以用<literal>SHOW</literal>命令检索：
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The tokens of the form
   <literal>:<replaceable>something</replaceable></literal> are
   <firstterm>host variables</firstterm>, that is, they refer to
   variables in the C program.  They are explained in <xref
   linkend="ecpg-variables">.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>:<replaceable>something</replaceable></literal>形式的记号是<firstterm>主变量</firstterm>，即它们指向 C 程序中的变量。它们在<xref linkend="ecpg-variables">中解释。
  </para>
  </sect2>

  <sect2 id="ecpg-cursors">
<!--==========================orignal english content==========================
   <title>Using Cursors</title>
____________________________________________________________________________-->
   <title>使用游标</title>

<!--==========================orignal english content==========================
  <para>
   To retrieve a result set holding multiple rows, an application has
   to declare a cursor and fetch each row from the cursor.  The steps
   to use a cursor are the following: declare a cursor, open it, fetch
   a row from the cursor, repeat, and finally close it.
  </para>
____________________________________________________________________________-->
  <para>
   要检索一个保持多行的结果集，一个应用必须声明一个游标并且从该游标中取得每一行。使用一个游标的步骤如下：声明一个游标、打开它、从该游标取得一行、重复并且最终关闭它。
  </para>

<!--==========================orignal english content==========================
  <para>
   Select using cursors:
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   使用游标选择：
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   For more details about declaration of the cursor,
   see <xref linkend="ecpg-sql-declare">, and
   see <xref linkend="sql-fetch"> for <literal>FETCH</literal> command
   details.
  </para>
____________________________________________________________________________-->
  <para>
   有关声明游标的更多细节，可参考<xref linkend="ecpg-sql-declare">；<literal>FETCH</literal>命令的细节则可以参考<xref linkend="sql-fetch">。
  </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The ECPG <command>DECLARE</command> command does not actually
     cause a statement to be sent to the PostgreSQL backend.  The
     cursor is opened in the backend (using the
     backend's <command>DECLARE</command> command) at the point when
     the <command>OPEN</command> command is executed.
    </para>
____________________________________________________________________________-->
    <para>
     ECPG <command>DECLARE</command>命令实际上不会导致一个语句被发送到 PostgreSQL 后端。在<command>OPEN</command>命令被执行时，游标会在后端被打开（使用后端的<command>DECLARE</command>命令）。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
<!--==========================orignal english content==========================
   <title>Managing Transactions</title>
____________________________________________________________________________-->
   <title>管理事务</title>

<!--==========================orignal english content==========================
  <para>
   In the default mode, statements are committed only when
   <command>EXEC SQL COMMIT</command> is issued. The embedded SQL
   interface also supports autocommit of transactions (similar to
   <application>psql</>'s default behavior) via the <option>-t</option>
   command-line option to <command>ecpg</command> (see <xref
   linkend="app-ecpg">) or via the <literal>EXEC SQL SET AUTOCOMMIT TO
   ON</literal> statement. In autocommit mode, each command is
   automatically committed unless it is inside an explicit transaction
   block. This mode can be explicitly turned off using <literal>EXEC
   SQL SET AUTOCOMMIT TO OFF</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   在默认模式中，只有当<command>EXEC SQL COMMIT</command>被发出时才会提交命令。嵌入式 SQL 接口也通过<command>ecpg</command>的<option>-t</option>命令行选项（见<xref linkend="app-ecpg">）或者通过<literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>语句支持事务的自动提交（类似于<application>psql</>的默认行为）。在自动提交模式中，除非位于一个显式事务块内，每一个命令都会被自动提交。这种模式可以使用<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>显式地关闭。
  </para>

<!--==========================orignal english content==========================
   <para>
    The following transaction management commands are available:

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        Commit an in-progress transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        Roll back an in-progress transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL PREPARE TRANSACTION </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        Prepare the current transaction for two-phase commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL COMMIT PREPARED </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        Commit a transaction that is in prepared state.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK PREPARED </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        Roll back a transaction that is in prepared state.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        Enable autocommit mode.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        Disable autocommit mode.  This is the default.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    可以使用下列事务管理命令：

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        提交一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        回滚一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL PREPARE TRANSACTION </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        准备两阶段提交的当前事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL COMMIT PREPARED </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        提交处于准备状态的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK PREPARED </literal><replaceable class="PARAMETER">transaction_id</></term>
      <listitem>
       <para>
        回滚处于准备状态的事务。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
	 <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        启用自动提交模式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        禁用自动提交模式。这是默认值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-prepared">
<!--==========================orignal english content==========================
   <title>Prepared Statements</title>
____________________________________________________________________________-->
   <title>预备语句</title>

<!--==========================orignal english content==========================
   <para>
    When the values to be passed to an SQL statement are not known at
    compile time, or the same statement is going to be used many
    times, then prepared statements can be useful.
   </para>
____________________________________________________________________________-->
   <para>
    当传递给 SQL 语句的值在编译时未知或者同一个语句要被使用多次时，那么预备语句就有用武之地了。
   </para>

<!--==========================orignal english content==========================
   <para>
    The statement is prepared using the
    command <literal>PREPARE</literal>.  For the values that are not
    known yet, use the
    placeholder <quote><literal>?</literal></quote>:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    语句使用命令<literal>PREPARE</literal>进行预备。对于还未知的值，使用占位符<quote><literal>?</literal></quote>：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If a statement returns a single row, the application can
    call <literal>EXECUTE</literal> after
    <literal>PREPARE</literal> to execute the statement, supplying the
    actual values for the placeholders with a <literal>USING</literal>
    clause:
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果一个语句返回一个单一行，应用可以在<literal>PREPARE</literal>之后调用<literal>EXECUTE</literal>来执行该语句，同时要用一个<literal>USING</literal>子句为占位符提供真实的值：
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If a statement returns multiple rows, the application can use a
    cursor declared based on the prepared statement.  To bind input
    parameters, the cursor must be opened with
    a <literal>USING</literal> clause:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* when end of result set reached, break out of while loop */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果一个语句返回多行，应用可以使用一个基于该预备语句声明的游标。要绑定输入参数，该游标必须用一个<literal>USING</literal>子句打开：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* 当到达结果集末尾时，跳出 while 循环 */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    When you don't need the prepared statement anymore, you should
    deallocate it:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    当你不再需要该预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    For more details about <literal>PREPARE</literal>,
    see <xref linkend="ecpg-sql-prepare">. Also
    see <xref linkend="ecpg-dynamic"> for more details about using
    placeholders and input parameters.
   </para>
____________________________________________________________________________-->
   <para>
    更多有关<literal>PREPARE</literal>的细节，可参考<xref linkend="ecpg-sql-prepare">。关于使用占位符和输入参数的细节，可参考<xref linkend="ecpg-dynamic">。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
<!--==========================orignal english content==========================
  <title>Using Host Variables</title>
____________________________________________________________________________-->
  <title>使用主变量</title>

<!--==========================orignal english content==========================
  <para>
   In <xref linkend="ecpg-commands"> you saw how you can execute SQL
   statements from an embedded SQL program.  Some of those statements
   only used fixed values and did not provide a way to insert
   user-supplied values into statements or have the program process
   the values returned by the query.  Those kinds of statements are
   not really useful in real applications.  This section explains in
   detail how you can pass data between your C program and the
   embedded SQL statements using a simple mechanism called
   <firstterm>host variables</firstterm>. In an embedded SQL program  we
   consider the SQL statements to be <firstterm>guests</firstterm> in the C
   program code which is the <firstterm>host language</firstterm>. Therefore
   the variables of the C program are called <firstterm>host
   variables</firstterm>.
  </para>
____________________________________________________________________________-->
  <para>
   在<xref linkend="ecpg-commands">中，你了解了如何从一个嵌入式 SQL 程序执行 SQL 语句。某些那种语句只使用固定值并且没有提供方法来插入用户提供的值到语句中或者让程序处理查询返回的值。那种语句在实际应用中其实没有什么用处。这一节详细解释了如何使用一种简单的机制（<firstterm>主变量</firstterm>）在 C 程序和嵌入式 SQL 语句之间传递数据。在一个嵌入式 SQL 程序中，我们认为 SQL 语句是 C 程序代码中的<firstterm>客人</firstterm>，而 C 代码是<firstterm>主语言</firstterm>。因此 C 程序的变量被称为<firstterm>主变量</firstterm>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another way to exchange values between PostgreSQL backends and ECPG
   applications is the use of SQL descriptors, described
   in <xref linkend="ecpg-descriptors">.
  </para>
____________________________________________________________________________-->
  <para>
   另一种在 PostgreSQL 后端和 ECPG 应用之间交换值的方式是使用 SQL 描述符，它在<xref linkend="ecpg-descriptors">中介绍。
  </para>

  <sect2 id="ecpg-variables-overview">
<!--==========================orignal english content==========================
   <title>Overview</title>
____________________________________________________________________________-->
   <title>概述</title>

<!--==========================orignal english content==========================
   <para>
    Passing data between the C program and the SQL statements is
    particularly simple in embedded SQL.  Instead of having the
    program paste the data into the statement, which entails various
    complications, such as properly quoting the value, you can simply
    write the name of a C variable into the SQL statement, prefixed by
    a colon.  For example:
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    This statement refers to two C variables named
    <varname>v1</varname> and <varname>v2</varname> and also uses a
    regular SQL string literal, to illustrate that you are not
    restricted to use one kind of data or the other.
   </para>
____________________________________________________________________________-->
   <para>
    在嵌入式 SQL 中进行 C 程序和 SQL 语句见的数据传递特别简单。我们不需要让程序把数据粘贴到语句（这会导致很多复杂性，例如正确地引用值），我们可以简单地在 SQL 语句中写 C 变量的名称，只要在它前面放上一个冒号。例如：
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    这个语句引用了两个 C 变量（名为<varname>v1</varname>和<varname>v2</varname>）并且还使用了一个常规的 SQL 字符串来说明你没有被限制于使用某一种数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    This style of inserting C variables in SQL statements works
    anywhere a value expression is expected in an SQL statement.
   </para>
____________________________________________________________________________-->
   <para>
    这种在 SQL 语句中插入 C 变量的风格可以用在 SQL 语句中每一个应该出现值表达式的地方。
   </para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
<!--==========================orignal english content==========================
   <title>Declare Sections</title>
____________________________________________________________________________-->
   <title>声明小节</title>

<!--==========================orignal english content==========================
   <para>
    To pass data from the program to the database, for example as
    parameters in a query, or to pass data from the database back to
    the program, the C variables that are intended to contain this
    data need to be declared in specially marked sections, so the
    embedded SQL preprocessor is made aware of them.
   </para>
____________________________________________________________________________-->
   <para>
    要从程序传递数据给数据库（例如作为一个查询的参数）或者从数据库传数据回程序，用于包含这些数据的 C 变量必须在特别标记的节中被声明，这样嵌入式 SQL 预处理器才会注意它们。
   </para>

<!--==========================orignal english content==========================
   <para>
    This section starts with:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    and ends with:
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    Between those lines, there must be normal C variable declarations,
    such as:
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
    As you can see, you can optionally assign an initial value to the variable.
    The variable's scope is determined by the location of its declaring
    section within the program.
    You can also declare variables with the following syntax which implicitly
    creates a declare section:
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    You can have as many declare sections in a program as you like.
   </para>
____________________________________________________________________________-->
   <para>
    这个节开始于：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    并且结束于：
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    在这两行之间，必须是正常的 C 变量声明，例如：
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
    如你所见，你可以选择为变量赋一个初始值。变量的可见范围由定义它的节在程序中的位置决定。你也可以使用下面的语法声明变量，这种语法将会隐式地创建一个声明节：
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    你可以按照你的意愿在一个程序中放上多个声明节。
   </para>

<!--==========================orignal english content==========================
   <para>
    The declarations are also echoed to the output file as normal C
    variables, so there's no need to declare them again.  Variables
    that are not intended to be used in SQL commands can be declared
    normally outside these special sections.
   </para>
____________________________________________________________________________-->
   <para>
    这些声明也会作为 C 变量被重复在输出文件中，因此无需再次声明它们。不准备在 SQL 命令中使用的变量可以正常地在这些特殊节之外声明。
   </para>

<!--==========================orignal english content==========================
   <para>
    The definition of a structure or union also must be listed inside
    a <literal>DECLARE</> section. Otherwise the preprocessor cannot
    handle these types since it does not know the definition.
   </para>
____________________________________________________________________________-->
   <para>
    一个结构或联合的定义也必须被列在一个<literal>DECLARE</>节中。否则预处理器无法处理这些类型，因为它不知道它们的定义。
   </para>
  </sect2>

  <sect2 id="ecpg-retrieving">
<!--==========================orignal english content==========================
   <title>Retrieving Query Results</title>
____________________________________________________________________________-->
   <title>检索查询结果</title>

<!--==========================orignal english content==========================
   <para>
    Now you should be able to pass data generated by your program into
    an SQL command.  But how do you retrieve the results of a query?
    For that purpose, embedded SQL provides special variants of the
    usual commands <command>SELECT</command> and
    <command>FETCH</command>.  These commands have a special
    <literal>INTO</literal> clause that specifies which host variables
    the retrieved values are to be stored in.
    <command>SELECT</command> is used for a query that returns only
    single row, and <command>FETCH</command> is used for a query that
    returns multiple rows, using a cursor.
   </para>
____________________________________________________________________________-->
   <para>
    现在你应该能够把程序产生的数据传递到一个 SQL 命令中了。但是怎么检索一个查询的结果呢？为此，嵌入式  SQL 提供了常规命令<command>SELECT</command>和<command>FETCH</command>的特殊变体。这些命令有一个特殊的<literal>INTO</literal>子句，它指定被检索到的值要被存储在哪些主变量中。<command>SELECT</command>被用于只返回单一行的查询，而<command>FETCH</command>被用于使用一个游标返回多行的查询。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example:
<programlisting>
/*
 * assume this table:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    So the <literal>INTO</literal> clause appears between the select
    list and the <literal>FROM</literal> clause.  The number of
    elements in the select list and the list after
    <literal>INTO</literal> (also called the target list) must be
    equal.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个例子：
<programlisting>
/*
 * 假定有这个表：
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    那么<literal>INTO</literal>子句出现在选择列表和<literal>FROM</literal>子句之间。选择列表中的元素数量必须和<literal>INTO</literal>后面列表（也被称为目标列表）的元素数量相等。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example using the command <command>FETCH</command>:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    Here the <literal>INTO</literal> clause appears after all the
    normal clauses.
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个使用命令<command>FETCH</command>的例子：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    这里<literal>INTO</literal>子句出现在所有正常子句的后面。
   </para>

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
<!--==========================orignal english content==========================
   <title>Type Mapping</title>
____________________________________________________________________________-->
   <title>类型映射</title>

<!--==========================orignal english content==========================
   <para>
    When ECPG applications exchange values between the PostgreSQL
    server and the C application, such as when retrieving query
    results from the server or executing SQL statements with input
    parameters, the values need to be converted between PostgreSQL
    data types and host language variable types (C language data
    types, concretely).  One of the main points of ECPG is that it
    takes care of this automatically in most cases.
   </para>
____________________________________________________________________________-->
   <para>
    当 ECPG 应用在 PostgreSQL 服务器和 C 应用之间交换值时（例如从服务器检索查询结果时或者用输入参数执行 SQL 语句时），值需要在 PostgreSQL 数据类型和主语言变量类型（具体来说是 C 语言数据类型）之间转换。ECPG 的要点之一就是它会在大多数情况下自动搞定这种转换。
   </para>

<!--==========================orignal english content==========================
   <para>
    In this respect, there are two kinds of data types: Some simple
    PostgreSQL data types, such as <type>integer</type>
    and <type>text</type>, can be read and written by the application
    directly.  Other PostgreSQL data types, such
    as <type>timestamp</type> and <type>numeric</type> can only be
    accessed through special library functions; see
    <xref linkend="ecpg-special-types">.
   </para>
____________________________________________________________________________-->
   <para>
    在这方面有两类数据类型：一些简单 PostgreSQL 数据类型（例如<type>integer</type>和<type>text</type>）可以被应用直接读取和写入。其他 PostgreSQL 数据类型（例如<type>timestamp</type>和<type>numeric</type>）只能通过特殊库函数访问，见<xref linkend="ecpg-special-types">。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="ecpg-datatype-hostvars-table"> shows which PostgreSQL
    data types correspond to which C data types.  When you wish to
    send or receive a value of a given PostgreSQL data type, you
    should declare a C variable of the corresponding C data type in
    the declare section.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="ecpg-datatype-hostvars-table">展示了哪种 PostgreSQL 数据类型对应于哪一种 C 数据类型。当你希望发送或接收一种给定 PostgreSQL 数据类型的值时，你应该在声明节中声明一个具有相应 C 数据类型的 C 变量。
   </para>

   <table id="ecpg-datatype-hostvars-table">
<!--==========================orignal english content==========================
    <title>Mapping Between PostgreSQL Data Types and C Variable Types</title>
____________________________________________________________________________-->
    <title>在 PostgreSQL 数据类型和 C 变量类型之间映射</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>PostgreSQL data type</entry>
       <entry>Host variable type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>PostgreSQL 数据类型</entry>
       <entry>主变量类型</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>This type can only be accessed through special library functions; see <xref linkend="ecpg-special-types">.</para></footnote></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>这种类型只能通过特殊的库函数访问，见<xref linkend="ecpg-special-types">。</para></footnote></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>character(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><para>declared in <filename>ecpglib.h</filename></para></footnote></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>character(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><para> 在<filename>ecpglib.h</filename>中声明</para></footnote></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>declared in <filename>ecpglib.h</filename> if not native</para></footnote></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>如果不是本地化类型，则声明在<filename>ecpglib.h</filename>中</para></footnote></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bytea</type></entry>
       <entry><type>char *</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry><type>char *</type></entry>
      </row>
	  </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
<!--==========================orignal english content==========================
    <title>Handling Character Strings</title>
____________________________________________________________________________-->
    <title>处理字符串</title>

<!--==========================orignal english content==========================
    <para>
     To handle SQL character string data types, such
     as <type>varchar</type> and <type>text</type>, there are two
     possible ways to declare the host variables.
    </para>
____________________________________________________________________________-->
    <para>
     要处理 SQL 字符串数据类型（例如<type>varchar</type>以及<type>text</type>），有两种可能的方式来声明主变量。
    </para>

<!--==========================orignal english content==========================
    <para>
     One way is using <type>char[]</type>, an array
     of <type>char</type>, which is the most common way to handle
     character data in C.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     Note that you have to take care of the length yourself.  If you
     use this host variable as the target variable of a query which
     returns a string with more than 49 characters, a buffer overflow
     occurs.
    </para>
____________________________________________________________________________-->
    <para>
     一种方式是使用<type>char[]</type>（一个<type>char</type>字符串），这是在 C 中处理字符数据最常见的方式。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     注意你必须自己照看长度。如果你把这个主变量用作一个查询的目标变量并且该查询返回超过 49 个字符的字符串，那么将会发生缓冲区溢出。
    </para>

<!--==========================orignal english content==========================
    <para>
     The other way is using the <type>VARCHAR</type> type, which is a
     special type provided by ECPG.  The definition on an array of
     type <type>VARCHAR</type> is converted into a
     named <type>struct</> for every variable. A declaration like:
<programlisting>
VARCHAR var[180];
</programlisting>
     is converted into:
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
     The member <structfield>arr</structfield> hosts the string
     including a terminating zero byte.  Thus, to store a string in
     a <type>VARCHAR</type> host variable, the host variable has to be
     declared with the length including the zero byte terminator.  The
     member <structfield>len</structfield> holds the length of the
     string stored in the <structfield>arr</structfield> without the
     terminating zero byte.  When a host variable is used as input for
     a query, if <literal>strlen(arr)</literal>
     and <structfield>len</structfield> are different, the shorter one
     is used.
    </para>
____________________________________________________________________________-->
    <para>
     另一种方式是使用<type>VARCHAR</type>类型，它是 ECPG 提供的一种特殊类型。在一个<type>VARCHAR</type>类型数组上的定义会被转变成一个命名的<type>struct</>。这样一个声明：
<programlisting>
VARCHAR var[180];
</programlisting>
     会被转变成：
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
     成员<structfield>arr</structfield>容纳包含一个终止零字节的字符串。因此，要在一个<type>VARCHAR</type>主变量中存储一个字符串，该主变量必须被声明为具有包括零字节终止符的长度。成员<structfield>len</structfield>保存存储在<structfield>arr</structfield>中的字符串的长度，不包括终止零字节。当一个主变量被用做一个查询的输入时，如果<literal>strlen(arr)</literal>和<structfield>len</structfield>不同，将使用短的那一个。
    </para>

<!--==========================orignal english content==========================
    <para>
     <type>VARCHAR</type> can be written in upper or lower case, but
     not in mixed case.
    </para>
____________________________________________________________________________-->
    <para>
     <type>VARCHAR</type>可以被写成大写或小写形式，但是不能大小写混合。
    </para>

<!--==========================orignal english content==========================
    <para>
     <type>char</type> and <type>VARCHAR</type> host variables can
     also hold values of other SQL types, which will be stored in
     their string forms.
    </para>
____________________________________________________________________________-->
    <para>
     <type>char</type>和<type>VARCHAR</type>主变量也可以保存其他 SQL 类型的值，它们将被存储为字符串形式。
    </para>
   </sect3>

   <sect3 id="ecpg-special-types">
<!--==========================orignal english content==========================
    <title>Accessing Special Data Types</title>
____________________________________________________________________________-->
    <title>访问特殊数据类型</title>

<!--==========================orignal english content==========================
    <para>
     ECPG contains some special types that help you to interact easily
     with some special data types from the PostgreSQL server. In
     particular, it has implemented support for the
     <type>numeric</>, <type>decimal</type>, <type>date</>, <type>timestamp</>,
     and <type>interval</> types.  These data types cannot usefully be
     mapped to primitive host variable types (such
     as <type>int</>, <type>long long int</type>,
     or <type>char[]</type>), because they have a complex internal
     structure.  Applications deal with these types by declaring host
     variables in special types and accessing them using functions in
     the pgtypes library.  The pgtypes library, described in detail
     in <xref linkend="ecpg-pgtypes"> contains basic functions to deal
     with those types, such that you do not need to send a query to
     the SQL server just for adding an interval to a time stamp for
     example.
    </para>
____________________________________________________________________________-->
    <para>
     ECPG 包含一些特殊类型帮助你容易地与来自 PostgreSQL 服务器的一些特殊数据类型交互。特别地，它已经实现了对于<type>numeric</>、<type>decimal</type>、<type>date</>、<type>timestamp</>以及<type>interval</>类型的支持。这些数据类型无法有效地被映射到原始的主变量类型（例如<type>int</>、<type>long long int</type>或者<type>char[]</type>），因为它们有一种复杂的内部结构。应用通过声明特殊类型的主变量以及使用 pgtypes 库中的函数来处理这些类型。pgtypes 库（在<xref linkend="ecpg-pgtypes">中详细描述）包含了处理这些类型的基本函数，这样你不需要仅仅为了给一个时间戳增加一个时段而发送一个查询给 SQL 服务器。
    </para>

<!--==========================orignal english content==========================
    <para>
     The follow subsections describe these special data types. For
     more details about pgtypes library functions,
     see <xref linkend="ecpg-pgtypes">.
    </para>
____________________________________________________________________________-->
    <para>
     下面的小节描述了这些特殊数据类型。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
    </para>

    <sect4>
<!--==========================orignal english content==========================
     <title id="ecpg-type-timestamp-date">timestamp, date</title>
____________________________________________________________________________-->
     <title id="ecpg-type-timestamp-date">timestamp, date</title>

<!--==========================orignal english content==========================
     <para>
      Here is a pattern for handling <type>timestamp</type> variables
      in the ECPG host application.
     </para>
____________________________________________________________________________-->
     <para>
      这里有一种在 ECPG 主应用中处理<type>timestamp</type>变量的模式。
     </para>

<!--==========================orignal english content==========================
     <para>
      First, the program has to include the header file for the
      <type>timestamp</type> type:
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      首先，程序必须包括用于<type>timestamp</type>类型的头文件：
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Next, declare a host variable as type <type>timestamp</type> in
      the declare section:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      接着，在声明节中声明一个主变量为类型<type>timestamp</type>：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      And after reading a value into the host variable, process it
      using pgtypes library functions. In following example, the
      <type>timestamp</type> value is converted into text (ASCII) form
      with the <function>PGTYPEStimestamp_to_asc()</function>
      function:
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      This example will show some result like following:
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      并且在读入一个值到该主变量中之后，使用 pgtypes 库函数处理它。在下面的例子中，<type>timestamp</type>值被<function>PGTYPEStimestamp_to_asc()</function>函数转变成文本（ASCII）形式：
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      这个例子将展示像下面形式的一些结果：
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>

<!--==========================orignal english content==========================
     <para>
      In addition, the DATE type can be handled in the same way. The
      program has to include <filename>pgtypes_date.h</filename>, declare a host variable
      as the date type and convert a DATE value into a text form using
      <function>PGTYPESdate_to_asc()</function> function. For more details about the
      pgtypes library functions, see <xref linkend="ecpg-pgtypes">.
     </para>
____________________________________________________________________________-->
     <para>
      另外，DATE 类型可以用相同的方式处理。程序必须包括<filename>pgtypes_date.h</filename>，声明一个主变量为日期类型并且将一个 DATE 值使用<function>PGTYPESdate_to_asc()</function>函数转变成一种文本形式。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
     </para>
    </sect4>

    <sect4 id="ecpg-type-interval">
<!--==========================orignal english content==========================
     <title>interval</title>
____________________________________________________________________________-->
     <title>interval</title>

<!--==========================orignal english content==========================
     <para>
      The handling of the <type>interval</type> type is also similar
      to the <type>timestamp</type> and <type>date</type> types.  It
      is required, however, to allocate memory for
      an <type>interval</type> type value explicitly.  In other words,
      the memory space for the variable has to be allocated in the
      heap memory, not in the stack memory.
     </para>
____________________________________________________________________________-->
     <para>
      对<type>interval</type>类型的处理也类似于<type>timestamp</type>和<type>date</type>类型。不过，必须显式为一个<type>interval</type>类型分配内存。换句话说，该变量的内存空间必须在堆内存中分配，而不是在栈内存中分配。
     </para>

<!--==========================orignal english content==========================
     <para>
      Here is an example program:
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      这里是一个例子程序：
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
<!--==========================orignal english content==========================
     <title>numeric, decimal</title>
____________________________________________________________________________-->
     <title>numeric, decimal</title>

<!--==========================orignal english content==========================
     <para>
      The handling of the <type>numeric</type>
      and <type>decimal</type> types is similar to the
      <type>interval</type> type: It requires defining a pointer,
      allocating some memory space on the heap, and accessing the
      variable using the pgtypes library functions.  For more details
      about the pgtypes library functions,
      see <xref linkend="ecpg-pgtypes">.
     </para>
____________________________________________________________________________-->
     <para>
      <type>numeric</type>和<type>decimal</type>类型的处理类似于<type>interval</type>类型：需要定义一个指针、在堆上分配一些内存空间并且使用 pgtypes 库函数访问该变量。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
     </para>

<!--==========================orignal english content==========================
     <para>
      No functions are provided specifically for
      the <type>decimal</type> type.  An application has to convert it
      to a <type>numeric</type> variable using a pgtypes library
      function to do further processing.
     </para>
____________________________________________________________________________-->
     <para>
      pgtypes 库没有特别为<type>decimal</type>类型提供函数。一个应用必须使用一个 pgtypes 库函数把它转变成一个<type>numeric</type>变量以便进一步处理。
     </para>

<!--==========================orignal english content==========================
     <para>
      Here is an example program handling <type>numeric</type>
      and <type>decimal</type> type variables.
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* Convert decimal to numeric to show a decimal value. */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      这里是一个处理<type>numeric</type>和<type>decimal</type>类型变量的例子程序。
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* 将一个decimal转变成numeric以显示一个decimal值。 */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
<!--==========================orignal english content==========================
    <title>Host Variables with Nonprimitive Types</title>
____________________________________________________________________________-->
    <title>非简单类型的主变量</title>

<!--==========================orignal english content==========================
    <para>
     As a host variable you can also use arrays, typedefs, structs, and
     pointers.
    </para>
____________________________________________________________________________-->
    <para>
     你也可以把数组、typedefs、结构和指针用作主变量。
    </para>

    <sect4 id="ecpg-variables-arrays">
<!--==========================orignal english content==========================
     <title>Arrays</title>
____________________________________________________________________________-->
     <title>数组</title>

<!--==========================orignal english content==========================
     <para>
      There are two use cases for arrays as host variables.  The first
      is a way to store some text string in <type>char[]</type>
      or <type>VARCHAR[]</type>, as
      explained in <xref linkend="ecpg-char">.  The second use case is to
      retrieve multiple rows from a query result without using a
      cursor.  Without an array, to process a query result consisting
      of multiple rows, it is required to use a cursor and
      the <command>FETCH</command> command.  But with array host
      variables, multiple rows can be received at once.  The length of
      the array has to be defined to be able to accommodate all rows,
      otherwise a buffer overflow will likely occur.
     </para>
____________________________________________________________________________-->
     <para>
      将数组用作主变量有两种情况。第一种如<xref linkend="ecpg-char">所述，是一种将一些文本字符串存储在<type>char[]</type>或<type>VARCHAR[]</type>中的方法。第二种是不用一个游标从一个查询结果中检索多行。如果没有一个数组，要处理由多个行组成的查询结果，我们需要使用一个游标以及<command>FETCH</command>命令。但是使用数组主变量，多个行可以被一次收取。该数组的长度必须被定义成足以容纳所有的行，否则很可能会发生一次缓冲区溢出。
     </para>

<!--==========================orignal english content==========================
     <para>
      Following example scans the <literal>pg_database</literal>
      system table and shows all OIDs and names of the available
      databases:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    /* Retrieve multiple rows into arrays at once. */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

    This example shows following result. (The exact values depend on
    local circumstances.)
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      下面的例子扫描<literal>pg_database</literal>系统表并且显示所有可用数据库的 OID 和名称：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    /* 一次检索多行到数组中。 */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

    这个例子显示下面的结果（确切的值取决于本地环境）。
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
    </sect4>

    <sect4 id="ecpg-variables-struct">
<!--==========================orignal english content==========================
     <title>Structures</title>
____________________________________________________________________________-->
     <title>结构</title>

<!--==========================orignal english content==========================
     <para>
      A structure whose member names match the column names of a query
      result, can be used to retrieve multiple columns at once.  The
      structure enables handling multiple column values in a single
      host variable.
     </para>
____________________________________________________________________________-->
     <para>
      一个成员名称匹配查询结果列名的结构可以被用来一次检索多列。该结构使得我们能够在一个单一主变量中处理多列值。
     </para>

<!--==========================orignal english content==========================
     <para>
      The following example retrieves OIDs, names, and sizes of the
      available databases from the <literal>pg_database</literal>
      system table and using
      the <function>pg_database_size()</function> function.  In this
      example, a structure variable <varname>dbinfo_t</varname> with
      members whose names match each column in
      the <literal>SELECT</literal> result is used to retrieve one
      result row without putting multiple host variables in
      the <literal>FETCH</literal> statement.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Fetch multiple columns into one structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* Print members of the structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      下面的例子从<literal>pg_database</literal>系统表以及使用<function>pg_database_size()</function>函数检索可用数据库的 OID、名称和尺寸。在这个例子中，一个成员名匹配<literal>SELECT</literal>结果的每一列的结构变量<varname>dbinfo_t</varname>被用来检索结果行，而不需要把多个主变量放在<literal>FETCH</literal>语句中。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      This example shows following result. (The exact values depend on
      local circumstances.)
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      这个例子会显示下列结果（确切的值取决于本地环境）。
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>

<!--==========================orignal english content==========================
     <para>
      Structure host variables <quote>absorb</quote> as many columns
      as the structure as fields.  Additional columns can be assigned
      to other host variables. For example, the above program could
      also be restructured like this, with the <varname>size</varname>
      variable outside the structure:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Fetch multiple columns into one structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* Print members of the structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      结构主变量将列尽数<quote>吸收</quote>成结构的域。额外的列可以被分配给其他主变量。例如，上面的程序也可以使用结构外部的<varname>size</varname>变量重新构造：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
    </sect4>

    <sect4>
<!--==========================orignal english content==========================
     <title>Typedefs</title>
____________________________________________________________________________-->
     <title>Typedefs</title>

<!--==========================orignal english content==========================
     <para>
      Use the <literal>typedef</literal> keyword to map new types to already
      existing types.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      Note that you could also use:
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      This declaration does not need to be part of a declare section.
     </para>
____________________________________________________________________________-->
     <para>
      使用<literal>typedef</literal>关键词可以把新类型映射到已经存在的类型。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      注意你也可以使用：
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      这种声明不需要位于一个声明节之中。
     </para>
    </sect4>

    <sect4>
<!--==========================orignal english content==========================
     <title>Pointers</title>
____________________________________________________________________________-->
     <title>指针</title>

<!--==========================orignal english content==========================
     <para>
      You can declare pointers to the most common types. Note however
      that you cannot use pointers as target variables of queries
      without auto-allocation. See <xref linkend="ecpg-descriptors">
      for more information on auto-allocation.
     </para>
____________________________________________________________________________-->
     <para>
      你可以声明最常见类型的指针。不过注意，你不能使用指针作为不带自动分配内存的查询的目标变量。关于自动分配内存的详情请参考<xref linkend="ecpg-descriptors">。
     </para>

<!--==========================orignal english content==========================
     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
<!--==========================orignal english content==========================
   <title>Handling Nonprimitive SQL Data Types</title>
____________________________________________________________________________-->
   <title>处理非简单 SQL 数据类型</title>

<!--==========================orignal english content==========================
   <para>
    This section contains information on how to handle nonscalar and
    user-defined SQL-level data types in ECPG applications.  Note that
    this is distinct from the handling of host variables of
    nonprimitive types, described in the previous section.
   </para>
____________________________________________________________________________-->
   <para>
    这一节包含关于如何处理 ECPG 应用中非标量以及用户定义的 SQL 级别数据类型。注意这和上一节中描述的简单类型主变量的处理有所不同。
   </para>

   <sect3>
<!--==========================orignal english content==========================
    <title>Arrays</title>
____________________________________________________________________________-->
    <title>数组</title>

<!--==========================orignal english content==========================
    <para>
     Multi-dimensional SQL-level arrays are not directly supported in ECPG.
     One-dimensional SQL-level arrays can be mapped into C array host
     variables and vice-versa.  However, when creating a statement ecpg does
     not know the types of the columns, so that it cannot check if a C array
     is input into a corresponding SQL-level array.  When processing the
     output of a SQL statement, ecpg has the necessary information and thus
     checks if both are arrays.
    </para>
____________________________________________________________________________-->
    <para>
     ECPG 中不直接支持 SQL 级别的多维数组。一维 SQL 数组可以被映射到 C 数组主机变量，反之
     亦然。不过，在创建一个语句时，ecpg并不知道列的类型，因此它无法检查一个 C 数组否是一个
     SQL 数组的输入。在处理一个 SQL 语句的输出时，ecpg 有必需的信息并且进而检查是否两者都是
     数组。
    </para>

<!--==========================orignal english content==========================
    <para>
     If a query accesses <emphasis>elements</emphasis> of an array
     separately, then this avoids the use of arrays in ECPG.  Then, a
     host variable with a type that can be mapped to the element type
     should be used.  For example, if a column type is array of
     <type>integer</type>, a host variable of type <type>int</type>
     can be used.  Also if the element type is <type>varchar</type>
     or <type>text</type>, a host variable of type <type>char[]</type>
     or <type>VARCHAR[]</type> can be used.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个查询个别地访问一个数组的<emphasis>元素</emphasis>，那么这可以避免使用 ECPG 中的数组。然后，应该使用一个能被映射到该元素类型的类型的主变量。例如，如果一个列类型是<type>integer</type>数组，可以使用一个类型<type>int</type>的主变量。还有如果元素类型是<type>varchar</type>或<type>text</type>，可以使用一个类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example.  Assume the following table:
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4,5}
(1 row)
</programlisting>

     The following example program retrieves the 4th element of the
     array and stores it into a host variable of
     type <type>int</type>:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

     This example shows the following result:
<screen>
ii=4
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子。假定有下面的表：
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

     下面的例子程序检索数组的第四个元素并且把它存储到一个类型为<type>int</type>的主变量中：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下面的结果：
<screen>
ii=4
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     To map multiple array elements to the multiple elements in an
     array type host variables each element of array column and each
     element of the host variable array have to be managed separately,
     for example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要把多个数组元素映射到一个数组类型主变量中的多个元素，数组列的每一个元素以及主变量数组的每一个元素都必须被单独管理，例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Note again that
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* WRONG */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
     would not work correctly in this case, because you cannot map an
     array type column to an array host variable directly.
    </para>
____________________________________________________________________________-->
    <para>
     注意
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 错误 */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
     在这种情况中不会正确工作，因为你无法把一个数组类型列直接映射到一个数组主变量。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another workaround is to store arrays in their external string
     representation in host variables of type <type>char[]</type>
     or <type>VARCHAR[]</type>.  For more details about this
     representation, see <xref linkend="arrays-input">.  Note that
     this means that the array cannot be accessed naturally as an
     array in the host program (without further processing that parses
     the text representation).
    </para>
____________________________________________________________________________-->
    <para>
     另一种变通方案是在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中存储数组的外部字符串表达。关于这种表达的详情请见<xref linkend="arrays-input">。注意这意味着该数组无法作为一个主程序中的数组被自然地访问（没有解析文本表达的进一步处理）。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title>Composite Types</title>
____________________________________________________________________________-->
    <title>组合类型</title>

<!--==========================orignal english content==========================
    <para>
     Composite types are not directly supported in ECPG, but an easy workaround is possible.
  The
     available workarounds are similar to the ones described for
     arrays above: Either access each attribute separately or use the
     external string representation.
    </para>
____________________________________________________________________________-->
    <para>
     ECPG 中并不直接支持组合类型，但是有一种可能的简单变通方案。可用的变通方案和上述用于数组的方案相似：要么单独访问每一个属性或者使用外部字符串表达。
    </para>

<!--==========================orignal english content==========================
    <para>
     For the following examples, assume the following type and table:
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

     The most obvious solution is to access each attribute separately.
     The following program retrieves data from the example table by
     selecting each attribute of the type <type>comp_t</type>
     separately:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* Put each element of the composite type column in the SELECT list. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Fetch each element of the composite type column into host variables. */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     对于下列例子，假定有下面的类型和表：
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

     最显而易见的解决方案是单独访问每一个属性。下面的程序通过单独选择类型<type>comp_t</type>的每一个属性从例子表中检索数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将组合类型列的每一个元素取到主变量中。 */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     To enhance this example, the host variables to store values in
     the <command>FETCH</command> command can be gathered into one
     structure.  For more details about the host variable in the
     structure form, see <xref linkend="ecpg-variables-struct">.
     To switch to the structure, the example can be modified as below.
     The two host variables, <varname>intval</varname>
     and <varname>textval</varname>, become members of
     the <structname>comp_t</structname> structure, and the structure
     is specified on the <command>FETCH</command> command.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* Put each element of the composite type column in the SELECT list. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Put all values in the SELECT list into one structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

     Although a structure is used in the <command>FETCH</command>
     command, the attribute names in the <command>SELECT</command>
     clause are specified one by one.  This can be enhanced by using
     a <literal>*</literal> to ask for all attributes of the composite
     type value.
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Put all values in the SELECT list into one structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     This way, composite types can be mapped into structures almost
     seamlessly, even though ECPG does not understand the composite
     type itself.
    </para>
____________________________________________________________________________-->
    <para>
     为了加强这个例子，在<command>FETCH</command>命令中存储值的主变量可以被集中在一个结构中。结构形式的主变量的详情可见<xref linkend="ecpg-variables-struct">。要切换到结构形式，该例子可以被改成下面的样子。两个主变量<varname>intval</varname>和<varname>textval</varname>变成<structname>comp_t</structname>结构的成员，并且该结构在<command>FETCH</command>命令中指定。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

     尽管在<command>FETCH</command>命令中使用了一个结构，<command>SELECT</command>子句中的属性名还是要一个一个指定。可以通过使用一个<literal>*</literal>来要求该组合类型值的所有属性来改进。
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     通过这种方法，即便 ECPG 不理解组合类型本身，组合类型也能够几乎无缝地被映射到结构。
    </para>

<!--==========================orignal english content==========================
    <para>
     Finally, it is also possible to store composite type values in
     their external string representation in host variables of
     type <type>char[]</type> or <type>VARCHAR[]</type>.  But that
     way, it is not easily possible to access the fields of the value
     from the host program.
    </para>
____________________________________________________________________________-->
    <para>
     最后，也可以在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中把组合类型值存储成它们的外部字符串表达。但是如果使用那种方法，就不太可能从主程序中访问该值的各个域了。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title>User-defined Base Types</title>
____________________________________________________________________________-->
    <title>用户定义的基础类型</title>

<!--==========================orignal english content==========================
    <para>
     New user-defined base types are not directly supported by ECPG.
     You can use the external string representation and host variables
     of type <type>char[]</type> or <type>VARCHAR[]</type>, and this
     solution is indeed appropriate and sufficient for many types.
    </para>
____________________________________________________________________________-->
    <para>
     ECPG 并不直接支持新的用户定义的基本类型。你可以使用外部字符串表达以及类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，并且这种方案事实上对很多类型都是合适和足够的。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example using the data type <type>complex</type> from
     the example in <xref linkend="xtypes">.  The external string
     representation of that type is <literal>(%lf,%lf)</literal>,
     which is defined in the
     functions <function>complex_in()</function>
     and <function>complex_out()</function> functions
     in <xref linkend="xtypes">.  The following example inserts the
     complex type values <literal>(1,1)</literal>
     and <literal>(3,3)</literal> into the
     columns <literal>a</literal> and <literal>b</literal>, and select
     them from the table after that.

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

     This example shows following result:
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>
____________________________________________________________________________-->
    <para>
     这里有一个使用来自<xref linkend="xtypes">中例子里的数据类型<type>complex</type>的例子。该类型的外部字符串表达是<literal>(%lf,%lf)</literal>，它被定义在函数<function>complex_in()</function>以及<xref linkend="xtypes">中的<function>complex_out()</function>函数内。下面的例子把复杂类型值<literal>(1,1)</literal>和<literal>(3,3)</literal>插入到列<literal>a</literal>和<literal>b</literal>，并且之后把它们从表中选择出来。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下列结果：
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>

<!--==========================orignal english content==========================
    <para>
     Another workaround is avoiding the direct use of the user-defined
     types in ECPG and instead create a function or cast that converts
     between the user-defined type and a primitive type that ECPG can
     handle.  Note, however, that type casts, especially implicit
     ones, should be introduced into the type system very carefully.
    </para>
____________________________________________________________________________-->
    <para>
     另一种变通方案是避免在 ECPG 中直接使用用户定义的类型，而是创建一个在用户定义的类型和 ECPG 能处理的简单类型之间转换的函数或者造型。不过要注意，在类型系统中引入类型造型（特别是隐式造型）要非常小心。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example,
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
    After this definition, the following
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    has the same effect as
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     例如，
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
    在这个定义之后 ，下面的语句
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    具有和
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    相同的效果。
    </para>
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
<!--==========================orignal english content==========================
   <title>Indicators</title>
____________________________________________________________________________-->
   <title>指示符</title>

<!--==========================orignal english content==========================
   <para>
    The examples above do not handle null values.  In fact, the
    retrieval examples will raise an error if they fetch a null value
    from the database.  To be able to pass null values to the database
    or retrieve null values from the database, you need to append a
    second host variable specification to each host variable that
    contains data.  This second host variable is called the
    <firstterm>indicator</firstterm> and contains a flag that tells
    whether the datum is null, in which case the value of the real
    host variable is ignored.  Here is an example that handles the
    retrieval of null values correctly:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    The indicator variable <varname>val_ind</varname> will be zero if
    the value was not null, and it will be negative if the value was
    null.
   </para>
____________________________________________________________________________-->
   <para>
    上述例子并没有处理空值。事实上，如果检索的例子从数据库取到了一个空值，它们将会产生一个错误。要能够向数据库传递空值或者从数据库检索空值，你需要对每一个包含数据的主变量追加一个次要主变量说明。这个次要主变量被称为<firstterm>指示符</firstterm>并且包含一个说明数据是否为空的标志，如果为空真正的主变量中的值就应该被忽略。这里有一个能正确处理检索空值的例子：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    如果值不为空，指示符变量<varname>val_ind</varname>将为零；否则它将为负值。
   </para>

<!--==========================orignal english content==========================
   <para>
    The indicator has another function: if the indicator value is
    positive, it means that the value is not null, but it was
    truncated when it was stored in the host variable.
   </para>
____________________________________________________________________________-->
   <para>
    指示符有另一种功能：如果指示符值为正，它表示值不为空，但是当它被存储在主变量中时已被截断。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the argument <literal>-r no_indicator</literal> is passed to
    the preprocessor <command>ecpg</command>, it works in
    <quote>no-indicator</quote> mode. In no-indicator mode, if no
    indicator variable is specified, null values are signaled (on
    input and output) for character string types as empty string and
    for integer types as the lowest possible value for type (for
    example, <symbol>INT_MIN</symbol> for <type>int</type>).
   </para>
____________________________________________________________________________-->
   <para>
    如果参数<literal>-r no_indicator</literal>被传递给预处理器<command>ecpg</command>，它会工作在<quote>无指示符</quote>模式。在无指示符模式中，如果没有指定指示符变量，对于字符串类型空值被标志（在输入和输出上）为空串，对于整数类型空值被标志为类型的最低可能值（例如，<type>int</type>的是<symbol>INT_MIN</symbol>）。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
<!--==========================orignal english content==========================
  <title>Dynamic SQL</title>
____________________________________________________________________________-->
  <title>动态 SQL</title>

<!--==========================orignal english content==========================
  <para>
   In many cases, the particular SQL statements that an application
   has to execute are known at the time the application is written.
   In some cases, however, the SQL statements are composed at run time
   or provided by an external source.  In these cases you cannot embed
   the SQL statements directly into the C source code, but there is a
   facility that allows you to call arbitrary SQL statements that you
   provide in a string variable.
  </para>
____________________________________________________________________________-->
  <para>
   在很多情况中，一个应用必须要执行的特定 SQL 语句在编写该应用时就已知。不过在某些情况中，SQL 语句在运行时构造或者由一个外部来源提供。这样你就不能直接把 SQL 语句嵌入到 C 源代码，不过有一种功能允许你调用在一个字符串变量中提供的任意 SQL 语句。
  </para>

  <sect2 id="ecpg-dynamic-without-result">
<!--==========================orignal english content==========================
   <title>Executing Statements without a Result Set</title>
____________________________________________________________________________-->
   <title>执行没有结果集的语句</title>

<!--==========================orignal english content==========================
   <para>
    The simplest way to execute an arbitrary SQL statement is to use
    the command <command>EXECUTE IMMEDIATE</command>.  For example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <command>EXECUTE IMMEDIATE</command> can be used for SQL
    statements that do not return a result set (e.g.,
    DDL, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>).  You cannot execute statements that
    retrieve data (e.g., <command>SELECT</command>) this way.  The
    next section describes how to do that.
   </para>
____________________________________________________________________________-->
   <para>
    执行一个任意 SQL 语句的最简单方法是使用命令<command>EXECUTE IMMEDIATE</command>。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <command>EXECUTE IMMEDIATE</command>可以被用于不返回结果集的 SQL 语句（例如 DDL、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）。你不能用这种方法执行检索数据的语句（例如<command>SELECT</command>）。下一节将描述如何执行这一种语句。
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-input">
<!--==========================orignal english content==========================
   <title>Executing a Statement with Input Parameters</title>
____________________________________________________________________________-->
   <title>执行一个有输入参数的语句</title>

<!--==========================orignal english content==========================
   <para>
    A more powerful way to execute arbitrary SQL statements is to
    prepare them once and execute the prepared statement as often as
    you like.  It is also possible to prepare a generalized version of
    a statement and then execute specific versions of it by
    substituting parameters.  When preparing the statement, write
    question marks where you want to substitute parameters later.  For
    example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    执行任意 SQL 语句的一种更强大的方法是准备它们一次并且在每次需要时执行该预备语句。也可以准备一个一般化的语句，然后通过替换参数执行它的特定版本。在准备语句时，在你想要稍后替换参数的地方写上问号。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    When you don't need the prepared statement anymore, you should
    deallocate it:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    当你不再需要预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
<!--==========================orignal english content==========================
   <title>Executing a Statement with a Result Set</title>
____________________________________________________________________________-->
   <title>执行一个有结果集的语句</title>

<!--==========================orignal english content==========================
   <para>
    To execute an SQL statement with a single result row,
    <command>EXECUTE</command> can be used.  To save the result, add
    an <literal>INTO</literal> clause.
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    An <command>EXECUTE</command> command can have an
    <literal>INTO</literal> clause, a <literal>USING</literal> clause,
    both, or neither.
   </para>
____________________________________________________________________________-->
   <para>
    要执行一个只有单一结果行的 SQL 语句，可以使用<command>EXECUTE</command>。要保存结果，在其中增加一个<literal>INTO</literal>子句。
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    一个<command>EXECUTE</command>命令可以有一个<literal>INTO</literal>子句、一个<literal>USING</literal>子句，可以同时有这两个子句，也可以不带这两个子句。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a query is expected to return more than one result row, a
    cursor should be used, as in the following example.
    (See <xref linkend="ecpg-cursors"> for more details about the
    cursor.)
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果一个查询被期望返回多于一个结果行，应该如下列例子所示使用一个游标（关于游标详见<xref linkend="ecpg-cursors">）。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
<!--==========================orignal english content==========================
  <title>pgtypes Library</title>
____________________________________________________________________________-->
  <title>pgtypes 库</title>

<!--==========================orignal english content==========================
  <para>
   The pgtypes library maps <productname>PostgreSQL</productname> database
   types to C equivalents that can be used in C programs. It also offers
   functions to do basic calculations with those types within C, i.e., without
   the help of the <productname>PostgreSQL</productname> server. See the
   following example:
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   pgtypes 库将<productname>PostgreSQL</productname>数据库类型映射到 C 中等价的类型以便在 C 程序中使用。它还提供在 C 中对这些类型进行基本计算的函数，即不依赖<productname>PostgreSQL</productname>服务器进行计算。请看下面的例子：
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting>
  </para>

  <sect2 id="ecpg-pgtypes-numeric">
<!--==========================orignal english content==========================
   <title>The numeric Type</title>
____________________________________________________________________________-->
   <title>numeric类型</title>
<!--==========================orignal english content==========================
   <para>
    The numeric type offers to do calculations with arbitrary precision. See
    <xref linkend="datatype-numeric"> for the equivalent type in the
    <productname>PostgreSQL</> server. Because of the arbitrary precision this
    variable needs to be able to expand and shrink dynamically. That's why you
    can only create numeric variables on the heap, by means of the
    <function>PGTYPESnumeric_new</> and <function>PGTYPESnumeric_free</>
    functions. The decimal type, which is similar but limited in precision,
    can be created on the stack as well as on the heap.
   </para>
____________________________________________________________________________-->
   <para>
    numeric类型用来完成对任意精度的计算。<productname>PostgreSQL</>服务器中等效的类型请见<xref linkend="datatype-numeric">。因为要用于任意精度，这种变量需要能够动态地扩展和收缩。这也是为什么你只能用<function>PGTYPESnumeric_new</>和<function>PGTYPESnumeric_free</>函数在堆上创建numeric变量。decimal类型与numeric类型相似但是在精度上有限制，decimal类型可以在堆上创建也可以在栈上创建。
   </para>
<!--==========================orignal english content==========================
   <para>
   The following functions can be used to work with the numeric type:
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      Request a pointer to a newly allocated numeric variable.
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      Free a numeric type, release all of its memory.
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       Parse a numeric type from its string notation.
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       Valid formats are for example:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
       If the value could be parsed successfully, a valid pointer is returned,
       else the NULL pointer. At the moment ECPG always parses the complete
       string and so it currently does not support to store the address of the
       first invalid character in <literal>*endptr</literal>. You can safely
       set <literal>endptr</literal> to NULL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       Returns a pointer to a string allocated by <function>malloc</function> that contains the string
       representation of the numeric type <literal>num</literal>.
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       The numeric value will be printed with <literal>dscale</literal> decimal
       digits, with rounding applied if necessary.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       Add two numeric variables into a third one.
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function adds the variables <literal>var1</literal> and
       <literal>var2</literal> into the result variable
       <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       Subtract two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function subtracts the variable <literal>var2</literal> from
       the variable <literal>var1</literal>. The result of the operation is
       stored in the variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       Multiply two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function multiplies the variables <literal>var1</literal> and
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       Divide two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function divides the variables <literal>var1</literal> by
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       Compare two numeric variables.
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       This function compares two numeric variables. In case of error,
       <literal>INT_MAX</literal> is returned. On success, the function
       returns one of three possible results:
       <itemizedlist>
        <listitem>
         <para>
          1, if <literal>var1</> is bigger than <literal>var2</>
         </para>
        </listitem>
        <listitem>
         <para>
          -1, if <literal>var1</> is smaller than <literal>var2</>
         </para>
        </listitem>
        <listitem>
         <para>
          0, if <literal>var1</> and <literal>var2</> are equal
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       Convert an int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       Convert a long int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed long int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       Copy over one numeric variable into another one.
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       This function copies over the value of the variable that
       <literal>src</literal> points to into the variable that <literal>dst</>
       points to. It returns 0 on success and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       Convert a variable of type double to a numeric.
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       This function accepts a variable of type double and stores the result
       in the variable that <literal>dst</> points to. It returns 0 on success
       and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to double.
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the double variable that <literal>dp</> points
       to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to int.
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the integer variable that <literal>ip</>
       points to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to long.
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the long integer variable that
       <literal>lp</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to decimal.
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>src</> points to into the decimal variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type decimal to numeric.
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       The function converts the decimal value from the variable that
       <literal>src</> points to into the numeric variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs. Since the decimal type is implemented as a limited version of
       the numeric type, overflow cannot occur with this conversion.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
   下列函数可以用于numeric类型：
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      请求一个指向新分配的numeric变量的指针。
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      释放一个numeric类型，释放它所有的内存。
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       从字符串记号中解析一个numeric类型。
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       例如，可用的格式是：
        <literal>-2</literal>、
        <literal>.794</literal>、
        <literal>+3.44</literal>、
        <literal>592.49E07</literal>或者
        <literal>-32.84e-4</literal>。
       如果值能被成功地解析，将返回一个有效的指针，否则返回 NULL 指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       返回由<function>malloc</function>分配的字符串的指针，它包含numeric类型<literal>num</literal>的字符串表达。
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       numeric值将被使用<literal>dscale</literal>小数位打印，必要时会圆整。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       把两个numeric变量相加放到第三个numeric变量中。
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相加放到结果变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       把两个numeric变量相减并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var2</literal>从变量<literal>var1</literal>中减除。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       把两个numeric变量相乘并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相乘。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       把两个numeric变量相除并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数用变量<literal>var2</literal>除变量<literal>var1</literal>。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       比较两个numeric变量。
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       这个函数比较两个numeric变量。错误时会返回<literal>INT_MAX</literal>。成功时，该函数返回三种可能结果之一：
       <itemizedlist>
        <listitem>
         <para>
          <literal>var1</>大于<literal>var2</>则返回 1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</>小于<literal>var2</>则返回 -1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</>和<literal>var2</>相等则返回 0
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       把一个整数变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       这个函数接受一个有符号整型变量并且把它存储在numeric变量<literal>var</>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       把一个长整型变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       这个函数接受一个有符号长整型变量并且把它存储在numeric变量<literal>var</>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       把一个numeric变量复制到另一个中。
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       这个函数把<literal>src</literal>指向的变量的值复制到<literal>dst</>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       把一个双精度类型的变量转换成一个numeric变量。
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       这个函数接受一个双精度类型的变量并且把结果存储在<literal>dst</>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成双精度。
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       这个函数将<literal>nv</>指向的变量中的numeric值转换成<literal>dp</>指向的双精度变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成整数。
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的整数变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成长整型。
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的长整型变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成decimal。
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的decimal变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       将一个decimal类型的变量转换成numeric。
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       该函数将<literal>nv</>指向的变量的decimal值转换成<literal>ip</>指向的numeric变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。因为decimal类型被实现为numeric类型的一个有限的版本，在这个转换上不会发生溢出。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
<!--==========================orignal english content==========================
   <title>The date Type</title>
____________________________________________________________________________-->
   <title>日期类型</title>
<!--==========================orignal english content==========================
   <para>
    The date type in C enables your programs to deal with data of the SQL type
    date. See <xref linkend="datatype-datetime"> for the equivalent type in the
    <productname>PostgreSQL</> server.
   </para>
____________________________________________________________________________-->
   <para>
    C 中的日期类型允许你的程序处理 SQL 日期类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
<!--==========================orignal english content==========================
   <para>
    The following functions can be used to work with the date type:
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        Extract the date part from a timestamp.
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        The function receives a timestamp as its only argument and returns the
        extracted date part from this timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       Parse a date from its textual representation.
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
        The function receives a C char* string <literal>str</> and a pointer to
        a C char* string <literal>endptr</>. At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
       <para>
        Note that the function always assumes MDY-formatted dates and there is
        currently no variable to change that within ECPG.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table"> shows the allowed input formats.
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title>Valid Input Formats for <function>PGTYPESdate_from_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Input</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>year and day of year</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>Julian day</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>year 99 before the Common Era</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        Return the textual representation of a date variable.
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        The function receives the date <literal>dDate</> as its only parameter.
        It will output the date in the form <literal>1999-01-18</>, i.e., in the
        <literal>YYYY-MM-DD</> format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        Extract the values for the day, the month and the year from a variable
        of type date.
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-&minus; almost same description as for rjulmdy() -&minus;>
        The function receives the date <literal>d</> and a pointer to an array
        of 3 integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        Create a date value from an array of 3 integers that specify the
        day, the month and the year of the date.
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        The function receives the array of the 3 integers (<literal>mdy</>) as
        its first argument and as its second argument a pointer to a variable
        of type date that should hold the result of the operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
        <itemizedlist>
         <listitem>
          <para>
           0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
           1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
           2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
           3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
           4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
           5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
           6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        Get the current date.
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        Convert a variable of type date to its textual representation using a
        format mask.
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        The function receives the date to convert (<literal>dDate</>), the
        format mask (<literal>fmtstring</>) and the string that will hold the
        textual representation of the date (<literal>outbuf</>).
       </para>
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
       <para>
        The following literals are the field specifiers you can use:
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - The number of the day of the month.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - The number of the month of the year.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - The number of the year as a two digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - The number of the year as a four digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - The name of the day (abbreviated).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - The name of the month (abbreviated).
          </para>
         </listitem>
        </itemizedlist>
        All other characters are copied 1:1 to the output string.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function. All output lines are based on
        the same date: November 23, 1959.
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title>Valid Input Formats for <function>PGTYPESdate_fmt_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Format</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        Use a format mask to convert a C <type>char*</type> string to a value of type
        date.
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-&minus; same description as rdefmtdate -&minus;>
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function.
       </para>
        <table id="ecpg-rdefmtdate-example-table">
         <title>Valid Input Formats for <function>rdefmtdate</function></title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>Format</entry>
            <entry>String</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列函数可以被用于日期类型：
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        从一个时间戳中抽取日期部分。
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        该函数接收一个时间戳作为它的唯一参数并且从这个时间戳返回抽取的日期部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       从日期的文本表达解析一个日期。
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
        该函数接收一个 C 的字符串<literal>str</>以及一个指向 C 字符串的指针<literal>endptr</>。当前 ECPG 总是解析完整的字符串并且因此当前不支持将第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
       <para>
        注意该函数总是假定格式按照 MDY 格式化并且当前在 ECPG 中没有变体可以改变这种格式。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table">展示了所有允许的输入格式。
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title><function>PGTYPESdate_from_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>年以及积日</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>儒略日</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>公元前 99 年</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        返回一个日期变量的文本表达。
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        该函数接收日期<literal>dDate</>作为它的唯一参数。它将以形式<literal>1999-01-18</>输出该日期，即以<literal>YYYY-MM-DD</>格式输出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        从一个日期类型变量中抽取日、月和年的值。
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
        该函数接收日期<literal>d</>以及一个指向有 3 个整数值的数组<literal>mdy</>的指针。变量名就表明了顺序：<literal>mdy[0]</>将被设置为包含月份，<literal>mdy[1]</>将被设置为日的值，而<literal>mdy[2]</>将包含年。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        从一个由 3 个整数构成的数组创建一个日期值，3 个整数分别指定日、月和年。
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        这个函数接收 3 个整数（<literal>mdy</>）组成的数组作为其第一个参数，其第二个参数是一个指向日期类型变量的指针，它被用来保存操作的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        为一个日期值返回表示它是星期几的数字。
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        这个函数接收日期变量<literal>d</>作为它唯一的参数并且返回一个整数说明这个日期是星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 星期日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 星期一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 星期二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 星期三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 星期四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 星期五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 星期六
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        得到当前日期。
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
        该函数接收一个指向一个日期变量（<literal>d</>）的指针并且把该参数设置为当前日期。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码将一个日期类型的变量转换成它的文本表达。
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        该函数接收要转换的日期（<literal>dDate</>）、格式掩码（<literal>fmtstring</>）以及将要保存日期的文本表达的字符串（<literal>outbuf</>）。
       </para>
       <para>
        成功时，返回 0；如果发生错误，则返回一个负值。
       </para>
       <para>
        下面是你可以使用的域指示符：
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - 一个月中的第几天。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - 一年中的第几个月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - 两位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - 四位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - 星期几的名称（简写）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - 月份的名称（简写）。
          </para>
         </listitem>
        </itemizedlist>
        所有其他字符会被原封不动地复制到输出字符串中。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table">指出了一些可能的格式。这将给你一些线索如何使用这个函数。所有输出都是基于同一个日期：1959年11月23日。
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title><function>PGTYPESdate_fmt_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码把一个 C 的 <type>char*</type>子返回串转换成一个日期类型的值。
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-- same description as rdefmtdate -->
        该函数接收一个用来保存操作结果的指向日期值的指针（<literal>d</>）、用于解析日期的格式掩码（<literal>fmt</>）以及包含日期文本表达的 C char* 串（<literal>str</>）。该函数期望文本表达匹配格式掩码。不过你不需要字符串和格式掩码的一一映射。该函数只分析相继顺序并且查找表示年份位置的文字<literal>yy</literal>或者<literal>yyyy</literal>、表示月份位置的<literal>mm</literal>以及表示日位置的<literal>dd</literal>。
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table">给出了一些可能的格式。这将给你一些线索如何使用这个函数。
       </para>
        <table id="ecpg-rdefmtdate-example-table">
         <title><function>rdefmtdate</function>的合法输入格式</title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>字符串</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>在 2525 年的七月二十八日，人类还将存在</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>也是 2525 年七月的二十八日</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
<!--==========================orignal english content==========================
   <title>The timestamp Type</title>
____________________________________________________________________________-->
   <title>时间戳类型</title>
<!--==========================orignal english content==========================
   <para>
    The timestamp type in C enables your programs to deal with data of the SQL
    type timestamp. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
   </para>
____________________________________________________________________________-->
   <para>
    C 中的时间戳类型允许你的程序处理 SQL 时间戳类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
<!--==========================orignal english content==========================
   <para>
    The following functions can be used to work with the timestamp type:
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
        Parse a timestamp from its textual representation into a timestamp
        variable.
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
        The function receives the string to parse (<literal>str</>) and a
        pointer to a C char* (<literal>endptr</>).
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
       <para>
        The function returns the parsed timestamp on success. On error,
        <literal>PGTYPESInvalidTimestamp</literal> is returned and <varname>errno</> is
        set to <literal>PGTYPES_TS_BAD_TIMESTAMP</>. See <xref linkend="PGTYPESInvalidTimestamp"> for important notes on this value.
       </para>
       <para>
        In general, the input string can contain any combination of an allowed
        date specification, a whitespace character and an allowed time
        specification. Note that time zones are not supported by ECPG. It can
        parse them but does not apply any calculation as the
        <productname>PostgreSQL</> server does for example. Timezone
        specifiers are silently discarded.
       </para>
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"> contains a few examples for input strings.
       </para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
         <title>Valid Input Formats for <function>PGTYPEStimestamp_from_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Input</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
            <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
        Converts a date to a C char* string.
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
        The function receives the timestamp <literal>tstamp</> as
        its only argument and returns an allocated string that contains the
        textual representation of the timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
        Retrieve the current timestamp.
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
       <para>
        You can use the following format specifiers for the format mask. The
        format specifiers are the same ones that are used in the
        <function>strftime</> function in <productname>libc</productname>. Any
        non-format specifier will be copied into the output buffer.
        <!-&minus; This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -&minus;>
        <itemizedlist>
         <listitem>
          <para>
           <literal>%A</literal> - is replaced by national representation of
           the full weekday name.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%a</literal> - is replaced by national representation of
           the abbreviated weekday name.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%B</literal> - is replaced by national representation of
           the full month name.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%b</literal> - is replaced by national representation of
           the abbreviated month name.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%C</literal> - is replaced by (year / 100) as decimal
           number; single digits are preceded by a zero.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%c</literal> - is replaced by national representation of
           time and date.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%D</literal> - is equivalent to
           <literal>%m/%d/%y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%d</literal> - is replaced by the day of the month as a
           decimal number (01-31).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX locale
           extensions. The sequences
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           are supposed to provide alternative representations.
          </para>
          <para>
           Additionally <literal>%OB</literal> implemented to represent
           alternative months names (used standalone, without day mentioned).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%e</literal> - is replaced by the day of month as a decimal
           number (1-31); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%G</literal> - is replaced by a year as a decimal number
           with century. This year is the one that contains the greater part of
           the week (Monday as the first day of the week).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%g</literal> - is replaced by the same year as in
           <literal>%G</literal>, but as a decimal number without century
           (00-99).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%H</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (00-23).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%h</literal> - the same as <literal>%b</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%I</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (01-12).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%j</literal> - is replaced by the day of the year as a
           decimal number (001-366).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%k</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (0-23); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%l</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (1-12); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%M</literal> - is replaced by the minute as a decimal
           number (00-59).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%m</literal> - is replaced by the month as a decimal number
           (01-12).
          </para>
         </listitem>
         <listitem>
          <para>
          <literal>%n</literal> - is replaced by a newline.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%O*</literal> - the same as <literal>%E*</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%p</literal> - is replaced by national representation of
           either <quote>ante meridiem</quote> or <quote>post meridiem</quote> as appropriate.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%R</literal> - is equivalent to <literal>%H:%M</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%r</literal> - is equivalent to <literal>%I:%M:%S
           %p</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%S</literal> - is replaced by the second as a decimal
           number (00-60).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%s</literal> - is replaced by the number of seconds since
           the Epoch, UTC.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%t</literal> - is replaced by a tab.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%U</literal> - is replaced by the week number of the year
           (Sunday as the first day of the week) as a decimal number (00-53).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%u</literal> - is replaced by the weekday (Monday as the
           first day of the week) as a decimal number (1-7).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%V</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (01-53).
           If the week containing January 1 has four or more days in the new
           year, then it is week 1; otherwise it is the last week of the
           previous year, and the next week is week 1.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%v</literal> - is equivalent to
           <literal>%e-%b-%Y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%W</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (00-53).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%w</literal> - is replaced by the weekday (Sunday as the
           first day of the week) as a decimal number (0-6).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%X</literal> - is replaced by national representation of
           the time.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%x</literal> - is replaced by national representation of
           the date.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Y</literal> - is replaced by the year with century as a
           decimal number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%y</literal> - is replaced by the year without century as a
           decimal number (00-99).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Z</literal> - is replaced by the time zone name.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%z</literal> - is replaced by the time zone offset from
           UTC; a leading plus sign stands for east of UTC, a minus sign for
           west of UTC, hours and minutes follow with two digits each and no
           delimiter between them (common form for RFC 822 date headers).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%+</literal> - is replaced by national representation of
           the date and time.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%-*</literal> - GNU libc extension. Do not do any padding
           when performing numerical outputs.
          </para>
         </listitem>
         <listitem>
          <para>
           $_* - GNU libc extension.    Explicitly specify space for padding.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%0*</literal> - GNU libc extension. Explicitly specify zero
           for padding.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%%</literal> - is replaced by <literal>%</literal>.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
        Subtract one timestamp from another one and save the result in a
        variable of type interval.
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
        Parse a timestamp value from its textual representation using a
        formatting mask.
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        The function receives the textual representation of a timestamp in the
        variable <literal>str</> as well as the formatting mask to use in the
        variable <literal>fmt</>. The result will be stored in the variable
        that <literal>d</> points to.
       </para>
       <para>
        If the formatting mask <literal>fmt</> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
       </para>
       <para>
        This is the reverse function to <xref
        linkend="PGTYPEStimestampfmtasc">.  See the documentation there in
        order to find out about the possible formatting mask entries.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
        Add an interval variable to a timestamp variable.
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function receives a pointer to a timestamp variable <literal>tin</>
        and a pointer to an interval variable <literal>span</>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</> points to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
        Subtract an interval variable from a timestamp variable.
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function subtracts the interval variable that <literal>span</>
        points to from the timestamp variable that <literal>tin</> points to
        and saves the result into the variable that <literal>tout</> points
        to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列函数可用于时间戳类型：
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
        从文本表达解析一个时间戳并放到一个时间戳变量中。
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
        这个函数接收一个要解析的字符串（<literal>str</>）以及一个 C char* 的指针（<literal>endptr</>）。当前 ECPG 总是解析完整的字符串并且因此当前不支持将第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
       <para>
        成功时该函数返回解析到的时间戳。错误时，会返回<literal>PGTYPESInvalidTimestamp</literal>并且<varname>errno</>会被设置为<literal>PGTYPES_TS_BAD_TIMESTAMP</>。关于这个值的重要提示请见<xref linkend="PGTYPESInvalidTimestamp">。
       </para>
       <para>
        通常，该输入字符串能够包含一个允许的日期说明、一个空格字符和一个允许的时间说明的任意组合。注意 ECPG 不支持时区。它能够解析时区但是不会应用任何计算（例如<productname>PostgreSQL</>服务器所作的事情）。时区指示符会被无声无息地丢弃。
       </para>
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table">包含输入字符串的一些例子。
       </para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
         <title><function>PGTYPEStimestamp_from_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
            <entry><literal>1999-01-08 04:05:06.789 （忽略了时区指示符）</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <entry><literal>1999-01-08 04:05:00 （忽略了时区指示符）</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
        将一个日期转换成一个 C char* 字符串。
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
        该函数接收时间戳<literal>tstamp</>作为它的唯一参数并且返回一个分配好的包含该时间戳文本表达的字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
        检索当前的时间戳。
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        该函数检索当前的时间戳并且将它保存在<literal>ts</>指向的时间戳变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码将一个时间戳变量转换成一个 C char* 。
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个指向时间戳的指针作为它的第一个参数（<literal>ts</>）、一个指向输出缓冲区的指针（<literal>output</>）、为输出缓冲区分配的最大长度（<literal>str_len</literal>）以及用于转换的格式掩码（<literal>fmtstr</literal>）。
       </para>
       <para>
        成功时，该函数返回 0；如果有错误发生，则返回一个负值。
       </para>
       <para>
        你可以为格式掩码使用下列格式指示符。格式指示符就是用在<productname>libc</productname>的<function>strftime</>函数中的那一些。任何非格式指示符将被复制到输出缓冲区。
        <!-- This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
          <para>
           <literal>%A</literal> - 被完整的星期几名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%a</literal> - 被简写星期几名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%B</literal> - 被完整的月份名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%b</literal> - 被简写月份名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%C</literal> - 被十进制数（年份/100）所替换，单一数字会被前置一个零。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%c</literal> - 被时间和日期的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%D</literal> - 等效于<literal>%m/%d/%y</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%d</literal> - 被十进制数（01-31）的日所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX 区域扩展。序列
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           被假定提供可供选择的表达。
          </para>
          <para>
           此外还实现了<literal>%OB</literal>来表达可供选择的月份名称（单独使用，不用提过的日）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%e</literal> - 被十进制数（01-31）的日所替换，单一数字被前置一个空格。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%F</literal> - 等效于<literal>%Y-%m-%d</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%G</literal> - 被替换为一个带有世纪的十进制数年份。这个年份是包含这一周大部分的年份（星期一作为这一周的第一天）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%g</literal> - 被替换为与<literal>%G</literal>中相同的年份，但是作为一个不带世纪的十进制数（00-99）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%H</literal> - 被替换为一个十进制数的小时（24 小时制，00-23）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%h</literal> - 和<literal>%b</literal>相同。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%I</literal> - 被替换为一个十进制数的小时（12 小时制，01-12）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%j</literal> - 被替换为一个十进制数的积日（001-366）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%k</literal> - 被替换为一个十进制数的小时（24 小时制，00-23），单一数字被前置一个空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%l</literal> - 被替换为一个十进制数的小时（12 小时制，01-12），单一数字被前置一个空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%M</literal> - 被替换为一个十进制数的分钟（00-59）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%m</literal> - 被替换为一个十进制数的月份（01-12）。
          </para>
         </listitem>
         <listitem>
          <para>
          <literal>%n</literal> - 被替换为一个新行。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%O*</literal> - 和<literal>%E*</literal>相同。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%p</literal> - 根据情况被替换为<quote>午前</quote>或<quote>午后</quote>的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%R</literal> - 等效于<literal>%H:%M</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%r</literal> - 等效于<literal>%I:%M:%S%p</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%S</literal> - 被替换为十进制数的秒（00-60）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%s</literal> - 被替换为从 UTC 新纪元以来的秒数。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%T</literal> - 等效于<literal>%H:%M:%S</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%t</literal> - 被替换为一个制表符。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%U</literal> - 被替换为十进制数的周数（周日作为一周的第一天，00-53）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%u</literal> - 被替换为十进制数的星期几（周一作为一周的第一天，1-7）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%V</literal> - 被替换为十进制数的周数（周一作为一周的第一天，01-53）。如果包含 1 月 1 日的周在新年中有 4 天或更多天，那么它是第一周。否则它是前一年的最后一周，并且下一周是第一周。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%v</literal> - 等效于<literal>%e-%b-%Y</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%W</literal> - 被替换为十进制数的周数（周一作为一周的第一天，00-53）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%w</literal> - 被替换为十进制数的星期几（0-6，周日作为一周的第一天）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%X</literal> - 被替换为时间的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%x</literal> - 被替换为日期的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Y</literal> - 被替换为十进制数的带世纪的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%y</literal> - 被替换为十进制数的不带世纪的年份（00-99）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Z</literal> - 被替换为时区名称。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%z</literal> - 被替换为相对于 UTC 的时区偏移；一个前导的加号表示 UTC 东部，一个负号表示 UTC 西部，接着是分别有两个数字的小时和分钟并且它们之间没有定界符（RFC 822 日期头部的一般形式）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%+</literal> - 被替换为日期和时间的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%-*</literal> - GNU libc 扩展。在执行数值输出时不做任何填充。
          </para>
         </listitem>
         <listitem>
          <para>
           $_* - GNU libc 扩展。显式地指定用空格填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%0*</literal> - GNU libc 扩展。显式地指定用零填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%%</literal> - 被替换为<literal>%</literal>。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
        从一个时间戳中减去另一个时间戳并且把结果保存在一个区间类型的变量中。
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从<literal>ts1</>指向的时间戳变量中减去<literal>ts2</>指向的时间戳变量，并且将把结果存储在<literal>iv</>指向的区间变量中。
       </para>
       <para>
        成功时，该函数返回 0；发生错误时则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
        Parse a timestamp value from its textual representation using a
        formatting mask.
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        The function receives the textual representation of a timestamp in the
        variable <literal>str</> as well as the formatting mask to use in the
        variable <literal>fmt</>. The result will be stored in the variable
        that <literal>d</> points to.
       </para>
       <para>
        If the formatting mask <literal>fmt</> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
       </para>
       <para>
        This is the reverse function to <xref
        linkend="PGTYPEStimestampfmtasc">.  See the documentation there in
        order to find out about the possible formatting mask entries.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
        Add an interval variable to a timestamp variable.
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function receives a pointer to a timestamp variable <literal>tin</>
        and a pointer to an interval variable <literal>span</>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</> points to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
        Subtract an interval variable from a timestamp variable.
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function subtracts the interval variable that <literal>span</>
        points to from the timestamp variable that <literal>tin</> points to
        and saves the result into the variable that <literal>tout</> points
        to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
<!--==========================orignal english content==========================
   <title>The interval Type</title>
____________________________________________________________________________-->
   <title>区间类型</title>
<!--==========================orignal english content==========================
   <para>
    The interval type in C enables your programs to deal with data of the SQL
    type interval. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
   </para>
____________________________________________________________________________-->
   <para>
    C 中的区间类型允许你的程序处理 SQL 区间类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
<!--==========================orignal english content==========================
   <para>
    The following functions can be used to work with the interval type:
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        Return a pointer to a newly allocated interval variable.
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        Release the memory of a previously allocated interval variable.
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        Parse an interval from its textual representation.
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        The function parses the input string <literal>str</> and returns a
        pointer to an allocated interval variable.
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        Convert a variable of type interval to its textual representation.
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        The function converts the interval variable that <literal>span</>
        points to into a C char*. The output looks like this example:
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        Copy a variable of type interval.
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
        The function copies the interval variable that <literal>intvlsrc</>
        points to into the variable that <literal>intvldest</> points to. Note
        that you need to allocate the memory for the destination variable
        before.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列函数可以用于区间类型：
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        返回一个指向新分配的区间变量的指针。
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        释放先前分配的区间变量的内存。
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        从文本表达解析一个区间。
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        该函数解析输入字符串<literal>str</>并且返回一个已分配的区间变量的指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        将一个区间类型的变量转换成它的文本表达。
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        该函数将<literal>span</>指向的区间变量转换成一个 C char*。输出看起来像这个例子：
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        复制一个区间类型的变量。
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
        该函数将<literal>intvlsrc</>指向的区间变量复制到<literal>intvldest</>指向的区间变量。注意你需要现为目标变量分配好内存。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
<!--==========================orignal english content==========================
   <title>The decimal Type</title>
____________________________________________________________________________-->
   <title>decimal类型</title>
<!--==========================orignal english content==========================
   <para>
     The decimal type is similar to the numeric type. However it is limited to
     a maximum precision of 30 significant digits. In contrast to the numeric
     type which can be created on the heap only, the decimal type can be
     created either on the stack or on the heap (by means of the functions
     <function>PGTYPESdecimal_new</> and
     <function>PGTYPESdecimal_free</>).
     There are a lot of other functions that deal with the decimal type in the
     <productname>Informix</productname> compatibility mode described in <xref
     linkend="ecpg-informix-compat">.
   </para>
____________________________________________________________________________-->
   <para>
     decimal类型和numeric类型相似。不过，它被限制为最大精度是 30 个有效位。与numeric类型只能在堆上创建相反，decimal类型既可以在栈上也可以在堆上创建（使用函数<function>PGTYPESdecimal_new</> 和<function>PGTYPESdecimal_free</>）。在<xref linkend="ecpg-informix-compat">中描述的<productname>Informix</productname>兼容模式中有很多其它函数可以处理decimal类型。
   </para>
<!--==========================orignal english content==========================
   <para>
    The following functions can be used to work with the decimal type and are
    not only contained in the <literal>libcompat</> library.
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       Request a pointer to a newly allocated decimal variable.
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       Free a decimal type, release all of its memory.
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列函数可以被用于decimal类型并且不仅被包含于<literal>libcompat</>库中。
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       要求一个指向新分配的decimal变量的指针。
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       释放一个decimal类型，释放它的所有内存。
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
<!--==========================orignal english content==========================
    <title>errno Values of pgtypeslib</title>
____________________________________________________________________________-->
    <title>pgtypeslib 的 errno 值</title>
<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        An argument should contain a numeric variable (or point to a numeric
        variable) but in fact its in-memory representation was invalid.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        An overflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause overflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        An underflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause underflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        A division by zero has been attempted.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        An invalid date string was passed to
        the <function>PGTYPESdate_from_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        Invalid arguments were passed to the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        An invalid token in the input string was found by the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        An invalid interval string was passed to the
        <function>PGTYPESinterval_from_asc</function> function, or an
        invalid interval value was passed to the
        <function>PGTYPESinterval_to_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        There was a mismatch in the day/month/year assignment in the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        An invalid day of the month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        An invalid month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        An invalid timestamp string pass passed to
        the <function>PGTYPEStimestamp_from_asc</function> function,
        or an invalid timestamp value was passed to
        the <function>PGTYPEStimestamp_to_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        An infinite timestamp value was encountered in a context that
        cannot handle it.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        一个参数应该包含一个numeric变量（或者指向一个numeric变量），但是实际上它的内存表达非法。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        发生一次溢出。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致溢出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        发生一次下溢。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致下溢。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        尝试了一次除零。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        一个非法的日期字符串被传给了<function>PGTYPESdate_from_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        非法参数被传给了<function>PGTYPESdate_defmt_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数在输入字符串中发现了一个非法记号。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        一个非法的区间字符串被传给了<function>PGTYPESinterval_from_asc</function>函数，或者一个非法的区间值被传给了<function>PGTYPESinterval_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        在<function>PGTYPESdate_defmt_asc</function>函数中有日/月/年不匹配的赋值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了月中的一个非法日值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了一个非法的月值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        一个非法的时间戳字符串被传给了<function>PGTYPEStimestamp_from_asc</function>函数，或者一个非法的时间戳值被传给了<function>PGTYPEStimestamp_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        在一个无法处理无限时间戳值的环境中遇到了这样一个值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
<!--==========================orignal english content==========================
    <title>Special Constants of pgtypeslib</title>
____________________________________________________________________________-->
    <title>pgtypeslib 的特殊常量</title>
<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        A value of type timestamp representing an invalid time stamp. This is
        returned by the function <function>PGTYPEStimestamp_from_asc</> on
        parse error.
        Note that due to the internal representation of the <type>timestamp</type> data type,
        <literal>PGTYPESInvalidTimestamp</literal> is also a valid timestamp at
        the same time. It is set to <literal>1899-12-31 23:59:59</>. In order
        to detect errors, make sure that your application does not only test
        for <literal>PGTYPESInvalidTimestamp</literal> but also for
        <literal>errno != 0</> after each call to
        <function>PGTYPEStimestamp_from_asc</>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        表示一个非法时间戳的时间戳类型值。在解析错误时，函数<function>PGTYPEStimestamp_from_asc</>会返回这个值。注意由于<type>timestamp</type>数据类型的内部表达，<literal>PGTYPESInvalidTimestamp</literal>在同时也是一个合法的时间戳。它被设置为<literal>1899-12-31 23:59:59</>。为了检测到错误，确认你的应用在每次调用<function>PGTYPEStimestamp_from_asc</>后不仅仅测试<literal>PGTYPESInvalidTimestamp</literal>，还应该测试<literal>errno != 0</>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
<!--==========================orignal english content==========================
  <title>Using Descriptor Areas</title>
____________________________________________________________________________-->
  <title>使用描述符区域</title>

<!--==========================orignal english content==========================
  <para>
   An SQL descriptor area is a more sophisticated method for processing
   the result of a <command>SELECT</command>, <command>FETCH</command> or
   a <command>DESCRIBE</command> statement. An SQL descriptor area groups
   the data of one row of data together with metadata items into one
   data structure.  The metadata is particularly useful when executing
   dynamic SQL statements, where the nature of the result columns might
   not be known ahead of time. PostgreSQL provides two ways to use
   Descriptor Areas: the named SQL Descriptor Areas and the C-structure
   SQLDAs.
  </para>
____________________________________________________________________________-->
  <para>
   一个 SQL 描述符区域是一种处理<command>SELECT</command>、<command>FETCH</command>或者<command>DESCRIBE</command>语句结果的高级方法。一个 SQL 描述符区域把数据中一行的数据及元数据项组合到一个数据结构中。在执行动态 SQL 语句时（结果行的性质无法提前预知），元数据特别有用。PostgreSQL 提供两种方法来使用描述符区域：命名 SQL 描述符区域和 C 结构 SQLDA。
  </para>

  <sect2 id="ecpg-named-descriptors">
<!--==========================orignal english content==========================
   <title>Named SQL Descriptor Areas</title>
____________________________________________________________________________-->
   <title>命名 SQL 描述符区域</title>

<!--==========================orignal english content==========================
   <para>
    A named SQL descriptor area consists of a header, which contains
    information concerning the entire descriptor, and one or more item
    descriptor areas, which basically each describe one column in the
    result row.
   </para>
____________________________________________________________________________-->
   <para>
    一个命名 SQL 描述符区域由一个头部以及一个或多个条目描述符区域构成，头部包含与整个描述符相关的信息，而条目描述符区域则描述结果行中的每一列。
   </para>

<!--==========================orignal english content==========================
   <para>
    Before you can use an SQL descriptor area, you need to allocate one:
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    The identifier serves as the <quote>variable name</quote> of the
    descriptor area.  <!-&minus; The scope of the allocated descriptor is WHAT?. -&minus;>
    When you don't need the descriptor anymore, you should deallocate
    it:
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在使用 SQL 描述符区域之前，需要先分配一个：
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    identifier 会作为该描述符区域的<quote>变量名</quote>。<remark>分配的描述符的范围有多大？</remark>当不再需要该描述符时，应当释放它：
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    To use a descriptor area, specify it as the storage target in an
    <literal>INTO</literal> clause, instead of listing host variables:
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    If the result set is empty, the Descriptor Area will still contain
    the metadata from the query, i.e. the field names.
   </para>
____________________________________________________________________________-->
   <para>
    要使用一个描述符区域，把它指定为<literal>INTO</literal>子句的存储目标（而不是列出主变量）：
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    如果结果集为空，该描述符区域仍然会包含查询的元数据，即域的名称。
   </para>

<!--==========================orignal english content==========================
   <para>
    For not yet executed prepared queries, the <command>DESCRIBE</command>
    statement can be used to get the metadata of the result set:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    对于还没有执行的预备查询，<command>DESCRIBE</command>可以被用来得到其结果集的元数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Before PostgreSQL 9.0, the <literal>SQL</literal> keyword was optional,
    so using <literal>DESCRIPTOR</literal> and <literal>SQL DESCRIPTOR</literal>
    produced named SQL Descriptor Areas. Now it is mandatory, omitting
    the <literal>SQL</literal> keyword produces SQLDA Descriptor Areas,
    see <xref linkend="ecpg-sqlda-descriptors">.
   </para>
____________________________________________________________________________-->
   <para>
    在 PostgreSQL 9.0 之前，<literal>SQL</literal>关键词是可选的，因此使用<literal>DESCRIPTOR</literal>和<literal>SQL DESCRIPTOR</literal>都会产生命名 SQL 描述符区域。现在该关键词是强制性的，省略<literal>SQL</literal>关键词会产生 SQLDA 描述符区域（见<xref linkend="ecpg-sqlda-descriptors">）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In <command>DESCRIBE</command> and <command>FETCH</command> statements,
    the <literal>INTO</literal> and <literal>USING</literal> keywords can be
    used to similarly: they produce the result set and the metadata in a
    Descriptor Area.
   </para>
____________________________________________________________________________-->
   <para>
    在<command>DESCRIBE</command>和<command>FETCH</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的使用相似：它们产生结果集以及一个描述符区域中的元数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    Now how do you get the data out of the descriptor area?  You can
    think of the descriptor area as a structure with named fields.  To
    retrieve the value of a field from the header and store it into a
    host variable, use the following command:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    Currently, there is only one header field defined:
    <replaceable>COUNT</replaceable>, which tells how many item
    descriptor areas exist (that is, how many columns are contained in
    the result).  The host variable needs to be of an integer type.  To
    get a field from the item descriptor area, use the following
    command:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <replaceable>num</replaceable> can be a literal integer or a host
    variable containing an integer. Possible fields are:

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> (integer)</term>
      <listitem>
       <para>
        number of rows in the result set
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        actual data item (therefore, the data type of this field
        depends on the query)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
      <listitem>
       <para>
        When <literal>TYPE</literal> is <literal>9</literal>,
        <literal>DATETIME_INTERVAL_CODE</literal> will have a value of
        <literal>1</literal> for <literal>DATE</literal>,
        <literal>2</literal> for <literal>TIME</literal>,
        <literal>3</literal> for <literal>TIMESTAMP</literal>,
        <literal>4</literal> for <literal>TIME WITH TIME ZONE</literal>, or
        <literal>5</literal> for <literal>TIMESTAMP WITH TIME ZONE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> (integer)</term>
      <listitem>
       <para>
        the indicator (indicating a null value or a value truncation)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the datum in characters
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        name of the column
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the character representation of the datum in bytes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        precision (for type <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the datum in characters
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the character representation of the datum in bytes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> (integer)</term>
      <listitem>
       <para>
        scale (for type <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> (integer)</term>
      <listitem>
       <para>
        numeric code of the data type of the column
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    现在我们如何从描述符区域得到数据呢？你可以把描述符区域看成是一个具有命名域的结构。要从头部检索一个域的值并且把它存储到一个主变量中，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    当前，只定义了一个头部域：<replaceable>COUNT</replaceable>，它告诉我们有多少个条目描述符区域（也就是，结果中包含多少列）。主变量需要是一个整数类型。要从条目描述符区域中得到一个域，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <replaceable>num</replaceable>可以是一个字面整数或者包含一个整数的主变量。可能的域有：

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> （整数）</term>
      <listitem>
       <para>
        结果集中的行数
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        实际的数据项（因此，这个域的数据类型取决于查询）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> （整数）</term>
      <listitem>
       <para>
        当<literal>TYPE</literal>是<literal>9</literal>时，
        <literal>DATETIME_INTERVAL_CODE</literal>将具有以下值之一：
        <literal>1</literal> 表示 <literal>DATE</literal>，
        <literal>2</literal> 表示 <literal>TIME</literal>，
        <literal>3</literal> 表示 <literal>TIMESTAMP</literal>，
        <literal>4</literal> 表示 <literal>TIME WITH TIME ZONE</literal>，
        <literal>5</literal> 表示 <literal>TIMESTAMP WITH TIME ZONE</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> （整数）</term>
      <listitem>
       <para>
        指示符（表示一个空值或者一个值截断）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        列名
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        精度（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> （整数）</term>
      <listitem>
       <para>
        比例（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> （整数）</term>
      <listitem>
       <para>
        列的数据类型的数字编码
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    In <command>EXECUTE</command>, <command>DECLARE</command> and <command>OPEN</command>
    statements, the effect of the <literal>INTO</literal> and <literal>USING</literal>
    keywords are different. A Descriptor Area can also be manually built to
    provide the input parameters for a query or a cursor and
    <literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>
    is the way to pass the input parameters into a parameterized query. The statement
    to build a named SQL Descriptor Area is below:
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在<command>EXECUTE</command>、<command>DECLARE</command>以及<command>OPEN</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的效果不同。也可以手工建立一个描述符区域来为一个查询或者游标提供输入参数，并且<literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>是用来传递输入参数给参数化查询的方法。建立一个命名 SQL 描述符区域的语句如下：
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    PostgreSQL supports retrieving more that one record in one <command>FETCH</command>
    statement and storing the data in host variables in this case assumes that the
    variable is an array. E.g.:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>
____________________________________________________________________________-->
   <para>
    PostgreSQL 支持在一个<command>FETCH</command>语句中检索多于一个记录并且在这种情况下把主变量假定为一个数组来存储数据。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
<!--==========================orignal english content==========================
   <title>SQLDA Descriptor Areas</title>
____________________________________________________________________________-->
   <title>SQLDA 描述符区域</title>

<!--==========================orignal english content==========================
   <para>
    An SQLDA Descriptor Area is a C language structure which can be also used
    to get the result set and the metadata of a query. One structure stores one
    record from the result set.
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    Note that the <literal>SQL</literal> keyword is omitted. The paragraphs about
    the use cases of the <literal>INTO</literal> and <literal>USING</literal>
    keywords in <xref linkend="ecpg-named-descriptors"> also apply here with an addition.
    In a <command>DESCRIBE</command> statement the <literal>DESCRIPTOR</literal>
    keyword can be completely omitted if the <literal>INTO</literal> keyword is used:
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    SQLDA 描述符区域是一个 C 语言结构，它也能被用来得到一个查询的结果集和元数据。一个结构存储一个来自结果集的记录。
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    注意<literal>SQL</literal>关键词被省略了。<xref linkend="ecpg-named-descriptors">中关于<literal>INTO</literal>和<literal>USING</literal>关键词用例的段落在一定条件下也适用于这里。在一个<command>DESCRIBE</command>语句中，如果使用了<literal>INTO</literal>关键词，则<literal>DESCRIPTOR</literal>关键词可以完全被省略：
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>

    <procedure>
<!--==========================orignal english content==========================
     <para>
      The general flow of a program that uses SQLDA is:
     </para>
____________________________________________________________________________-->
     <para>
      使用 SQLDA 的程序的一般流程是：
     </para>
     <step><!--==========================orignal english content==========================
<simpara>Prepare a query, and declare a cursor for it.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Prepare a query, and declare a cursor for it.</simpara>
____________________________________________________________________________-->
<simpara>准备一个查询，并且为它声明一个游标。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Declare an SQLDA for the result rows.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Declare an SQLDA for the result rows.</simpara>
____________________________________________________________________________-->
<simpara>为结果行声明一个 SQLDA 。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Declare an SQLDA for the input parameters, and initialize them (memory allocation, parameter settings).</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Declare an SQLDA for the input parameters, and initialize them (memory allocation, parameter settings).</simpara>
____________________________________________________________________________-->
<simpara>为输入参数声明一个 SQLDA，并且初始化它们（内存分配、参数设置）。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Open a cursor with the input SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Open a cursor with the input SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>用输入 SQLDA 打开一个游标。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Fetch rows from the cursor, and store them into an output SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Fetch rows from the cursor, and store them into an output SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>从游标中取得行，并且把它们存储到一个输出 SQLDA。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Read values from the output SQLDA into the host variables (with conversion if necessary).</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Read values from the output SQLDA into the host variables (with conversion if necessary).</simpara>
____________________________________________________________________________-->
<simpara>从输出 SQLDA 读取值到主变量中（必要时使用转换）。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Close the cursor.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Close the cursor.</simpara>
____________________________________________________________________________-->
<simpara>关闭游标。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Free the memory area allocated for the input SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Free the memory area allocated for the input SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>关闭为输入 SQLDA 分配的内存区域。</simpara></step>
    </procedure>

   <sect3>
<!--==========================orignal english content==========================
    <title>SQLDA Data Structure</title>
____________________________________________________________________________-->
    <title>SQLDA 数据结构</title>

<!--==========================orignal english content==========================
    <para>
     SQLDA uses three data structure
     types: <type>sqlda_t</type>, <type>sqlvar_t</type>,
     and <type>struct sqlname</type>.
    </para>
____________________________________________________________________________-->
    <para>
     SQLDA 使用三种数据结构类型：<type>sqlda_t</type>、<type>sqlvar_t</type>以及<type>struct sqlname</type>。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      PostgreSQL's SQLDA has a similar data structure to the one in
      IBM DB2 Universal Database, so some technical information on
      DB2's SQLDA could help understanding PostgreSQL's one better.
     </para>
____________________________________________________________________________-->
     <para>
      PostgreSQL 的 SQLDA 与 IBM DB2 Unversal 数据库中相似的数据结构，因此一些 DB2 的 SQLDA 的技术信息有助于更好地理解 PostgreSQL 的 SQLDA。
     </para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
<!--==========================orignal english content==========================
     <title>sqlda_t Structure</title>
____________________________________________________________________________-->
     <title>sqlda_t 结构</title>

<!--==========================orignal english content==========================
     <para>
      The structure type <type>sqlda_t</type> is the type of the
      actual SQLDA.  It holds one record.  And two or
      more <type>sqlda_t</type> structures can be connected in a
      linked list with the pointer in
      the <structfield>desc_next</structfield> field, thus
      representing an ordered collection of rows.  So, when two or
      more rows are fetched, the application can read them by
      following the <structfield>desc_next</structfield> pointer in
      each <type>sqlda_t</type> node.
     </para>
____________________________________________________________________________-->
     <para>
      结构类型<type>sqlda_t</type>是实际 SQLDA 的类型。它保存一个记录。并且两个或者更多个<type>sqlda_t</type>结构能够以<structfield>desc_next</structfield>域中的指针连接成一个链表，这样可以表示一个有序的行集合。因此，当两个或多个行被取得时，应用可以通过沿着每一个<type>sqlda_t</type>节点中的<structfield>desc_next</structfield>指针读取它们。
     </para>

<!--==========================orignal english content==========================
     <para>
      The definition of <type>sqlda_t</type> is:
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

      The meaning of the fields is:

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</></term>
      <listitem>
       <para>
        It contains the literal string <literal>"SQLDA  "</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</></term>
      <listitem>
       <para>
        It contains the size of the allocated space in bytes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</></term>
      <listitem>
       <para>
        It contains the number of input parameters for a parameterized query in
        case it's passed into <command>OPEN</command>, <command>DECLARE</command> or
        <command>EXECUTE</command> statements using the <literal>USING</literal>
        keyword. In case it's used as output of <command>SELECT</command>,
        <command>EXECUTE</command> or <command>FETCH</command> statements,
        its value is the same as <literal>sqld</literal>
        statement
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</></term>
      <listitem>
       <para>
        It contains the number of fields in a result set.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</></term>
      <listitem>
       <para>
        If the query returns more than one record, multiple linked
        SQLDA structures are returned, and <literal>desc_next</> holds
        a pointer to the next entry in the list.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</></term>
      <listitem>
       <para>
        This is the array of the columns in the result set.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      <type>sqlda_t</type>的定义是：
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

      域的含义是：

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</></term>
      <listitem>
       <para>
        它包含一个字符串<literal>"SQLDA  "</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</></term>
      <listitem>
       <para>
        它包含已分配空间的尺寸（以字节计）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</></term>
      <listitem>
       <para>
        当它被传递给使用<literal>USING</literal>关键词的<command>OPEN</command>、<command>DECLARE</command>或者<command>EXECUTE</command>语句时，它包含用于一个参数化查询实例的输入参数的数目。在它被用作<command>SELECT</command>、<command>EXECUTE</command>或<command>FETCH</command>语句的输出时，它的值和<literal>sqld</literal>一样
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</></term>
      <listitem>
       <para>
        它包含一个结果集中的域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</></term>
      <listitem>
       <para>
        如果查询返回不止一个记录，会返回多个链接在一起的 SQLDA 结构，并且<literal>desc_next</>保存一个指向下一个项的指针。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</></term>
      <listitem>
       <para>
        这是结果集中列的数组。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
<!--==========================orignal english content==========================
     <title>sqlvar_t Structure</title>
____________________________________________________________________________-->
     <title>sqlvar_t 结构</title>

<!--==========================orignal english content==========================
     <para>
      The structure type <type>sqlvar_t</type> holds a column value
      and metadata such as type and length. The definition of the type
      is:

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

      The meaning of the fields is:

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</></term>
          <listitem>
           <para>
            Contains the type identifier of the field. For values,
            see <literal>enum ECPGttype</literal> in <literal>ecpgtype.h</literal>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</></term>
          <listitem>
           <para>
            Contains the binary length of the field. e.g. 4 bytes for <type>ECPGt_int</type>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</></term>
          <listitem>
           <para>
            Points to the data.  The format of the data is described
            in <xref linkend="ecpg-variables-type-mapping">.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</></term>
          <listitem>
           <para>
            Points to the null indicator.  0 means not null, -1 means
            null.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</></term>
          <listitem>
           <para>
            The name of the field.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      结构类型<type>sqlvar_t</type>保存一个列值和元数据（例如类型和长度）。该类型的定义是：

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

      各个域的含义是：

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</></term>
          <listitem>
           <para>
            包含该域的类型标识符。值可以参考<literal>ecpgtype.h</literal>中的<literal>enum ECPGttype</literal>。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</></term>
          <listitem>
           <para>
            包含域的二进制长度，例如<type>ECPGt_int</type>是 4 字节。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</></term>
          <listitem>
           <para>
            指向数据。数据的格式在<xref linkend="ecpg-variables-type-mapping">中描述。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</></term>
          <listitem>
           <para>
            指向空指示符。0 表示非空，-1 表示空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</></term>
          <listitem>
           <para>
            域的名称。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
<!--==========================orignal english content==========================
     <title>struct sqlname Structure</title>
____________________________________________________________________________-->
     <title>struct sqlname 结构</title>

<!--==========================orignal english content==========================
     <para>
      A <type>struct sqlname</type> structure holds a column name.  It
      is used as a member of the <type>sqlvar_t</type> structure.  The
      definition of the structure is:
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      The meaning of the fields is:
            <variablelist>
             <varlistentry>
              <term><literal>length</></term>
               <listitem>
                <para>
                 Contains the length of the field name.
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</></term>
               <listitem>
                <para>
                 Contains the actual field name.
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      一个<type>struct sqlname</type>结构保持一个列名。它被用作<type>sqlvar_t</type>结构的一个成员。该结构的定义是：
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      各个域的含义是：
            <variablelist>
             <varlistentry>
              <term><literal>length</></term>
               <listitem>
                <para>
                 包含域名称的长度。
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</></term>
               <listitem>
                <para>
                 包含实际的域名称。
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
<!--==========================orignal english content==========================
    <title>Retrieving a Result Set Using an SQLDA</title>
____________________________________________________________________________-->
    <title>使用一个 SQLDA 检索一个结果集</title>

    <procedure>
<!--==========================orignal english content==========================
     <para>
      The general steps to retrieve a query result set through an
      SQLDA are:
     </para>
____________________________________________________________________________-->
     <para>
      通过一个 SQLDA 检索一个查询结果集的一般步骤是：
     </para>
     <step><!--==========================orignal english content==========================
<simpara>Declare an <type>sqlda_t</type> structure to receive the result set.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Declare an <type>sqlda_t</type> structure to receive the result set.</simpara>
____________________________________________________________________________-->
<simpara>声明一个<type>sqlda_t</type>结构来接收结果集。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Execute <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> commands to process a query specifying the declared SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Execute <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> commands to process a query specifying the declared SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>执行 <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> 命令来处理一个指定已声明 SQLDA 的查询。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Check the number of records in the result set by looking at <structfield>sqln</>, a member of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Check the number of records in the result set by looking at <structfield>sqln</>, a member of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<simpara>通过查看<type>sqlda_t</type>结构的成员<structfield>sqln</>来检查结果集中记录的数量。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Get the values of each column from <literal>sqlvar[0]</>, <literal>sqlvar[1]</>, etc., members of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Get the values of each column from <literal>sqlvar[0]</>, <literal>sqlvar[1]</>, etc., members of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<simpara>从<type>sqlda_t</type>结构的成员<literal>sqlvar[0]</>、<literal>sqlvar[1]</>等中得到每一列的值。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Go to next row (<type>sqlda_t</type> structure) by following the <structfield>desc_next</> pointer, a member of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Go to next row (<type>sqlda_t</type> structure) by following the <structfield>desc_next</> pointer, a member of the <type>sqlda_t</type> structure.</simpara>
____________________________________________________________________________-->
<simpara>沿着<type>sqlda_t</type>结构的成员<structfield>desc_next</>指针到达下一行（<type>sqlda_t</type>）。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Repeat above as you need.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Repeat above as you need.</simpara>
____________________________________________________________________________-->
<simpara>根据你的需要重复上述步骤。</simpara></step>
    </procedure>

<!--==========================orignal english content==========================
    <para>
     Here is an example retrieving a result set through an SQLDA.
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个通过 SQLDA 检索结果集的例子。
    </para>

<!--==========================orignal english content==========================
    <para>
     First, declare a <type>sqlda_t</type> structure to receive the result set.
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     首先，声明一个<type>sqlda_t</type>结构来接收结果集。
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Next, specify the SQLDA in a command.  This is
     a <command>FETCH</> command example.
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     接下来，指定一个命令中的 SQLDA。这是一个<command>FETCH</>命令的例子。
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Run a loop following the linked list to retrieve the rows.
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     运行一个循环顺着链表来检索行。
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Inside the loop, run another loop to retrieve each column data
     (<type>sqlvar_t</type> structure) of the row.
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在循环内部，运行另一个循环来检索行中每一列的数据（<type>sqlvar_t</type>结构）。
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     To get a column value, check the <structfield>sqltype</> value,
     a member of the <type>sqlvar_t</type> structure.  Then, switch
     to an appropriate way, depending on the column type, to copy
     data from the <structfield>sqlvar</> field to a host variable.
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要得到一列的值，应检查<type>sqlvar_t</type>结构的成员<structfield>sqltype</>的值。然后，根据列类型切换到一种合适的方法从<structfield>sqlvar</>域中复制数据到一个主变量。
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
<!--==========================orignal english content==========================
    <title>Passing Query Parameters Using an SQLDA</title>
____________________________________________________________________________-->
    <title>使用一个 SQLDA 传递查询参数</title>

    <procedure>
<!--==========================orignal english content==========================
     <para>
      The general steps to use an SQLDA to pass input
      parameters to a prepared query are:
     </para>
____________________________________________________________________________-->
     <para>
      使用一个 SQLDA 传递输入参数给一个预备查询的一般步骤是：
     </para>
     <step><!--==========================orignal english content==========================
<simpara>Create a prepared query (prepared statement)</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Create a prepared query (prepared statement)</simpara>
____________________________________________________________________________-->
<simpara>创建一个预备查询（预备语句）。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Declare a sqlda_t structure as an input SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Declare a sqlda_t structure as an input SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>声明一个 sqlda_t 结构作为输入 SQLDA。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Allocate memory area (as sqlda_t structure) for the input SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Allocate memory area (as sqlda_t structure) for the input SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>为输入 SQLDA 分配内存区域（作为 sqlda_t 结构）。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Set (copy) input values in the allocated memory.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Set (copy) input values in the allocated memory.</simpara>
____________________________________________________________________________-->
<simpara>在分配好的内存中设置（复制）输入值。</simpara></step>
     <step><!--==========================orignal english content==========================
<simpara>Open a cursor with specifying the input SQLDA.</simpara>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<simpara>Open a cursor with specifying the input SQLDA.</simpara>
____________________________________________________________________________-->
<simpara>打开一个说明了输入 SQLDA 的游标。</simpara></step>
    </procedure>

<!--==========================orignal english content==========================
    <para>
     Here is an example.
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子。
    </para>

<!--==========================orignal english content==========================
    <para>
     First, create a prepared statement.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     首先，创建一个预备语句。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Next, allocate memory for an SQLDA, and set the number of input
     parameters in <structfield>sqln</>, a member variable of
     the <type>sqlda_t</type> structure.  When two or more input
     parameters are required for the prepared query, the application
     has to allocate additional memory space which is calculated by
     (nr. of params - 1) * sizeof(sqlvar_t).  The example shown here
     allocates memory space for two input parameters.
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* number of input variables */
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     接下来为一个 SQLDA 分配内存，并且在<type>sqlda_t</type>结构的<structfield>sqln</>成员变量中设置输入参数的数量。当预备查询要求两个或多个输入参数时，应用必须分配额外的内存空间，空间的大小为 (参数数目 - 1) * sizeof(sqlvar_t)。这里的例子展示了为两个输入参数分配内存空间。
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* 输入变量的数目 */
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     After memory allocation, store the parameter values into the
     <literal>sqlvar[]</literal> array.  (This is same array used for
     retrieving column values when the SQLDA is receiving a result
     set.)  In this example, the input parameters
     are <literal>"postgres"</literal>, having a string type,
     and <literal>1</literal>, having an integer type.
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     内存分配之后，把参数值存储到<literal>sqlvar[]</literal>数组（当 SQLDA 在接收结果集时，这也是用来检索列值的数组）。在这个例子中，输入参数是<literal>"postgres"</literal>（字符串类型）和<literal>1</literal>（整数类型）。
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     By opening a cursor and specifying the SQLDA that was set up
     beforehand, the input parameters are passed to the prepared
     statement.
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     通过打开一个游标并且说明之前已经建立好的 SQLDA，输入参数被传递给预备语句。
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Finally, after using input SQLDAs, the allocated memory space
     must be freed explicitly, unlike SQLDAs used for receiving query
     results.
<programlisting>
free(sqlda2);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     最后，用完输入 SQLDA 后必须显式地释放已分配的内存空间，这与用于接收查询结果的 SQLDA 不同。
<programlisting>
free(sqlda2);
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-example">
<!--==========================orignal english content==========================
    <title>A Sample Application Using SQLDA</title>
____________________________________________________________________________-->
    <title>一个使用 SQLDA 的应用例子</title>

<!--==========================orignal english content==========================
    <para>
     Here is an example program, which describes how to fetch access
     statistics of the databases, specified by the input parameters,
     from the system catalogs.
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子程序，它描述了如何按照输入参数的指定从系统目录中取得数据库的访问统计。
    </para>

<!--==========================orignal english content==========================
    <para>
     This application joins two system tables, pg_database and
     pg_stat_database on the database OID, and also fetches and shows
     the database statistics which are retrieved by two input
     parameters (a database <literal>postgres</literal>, and OID <literal>1</literal>).
    </para>
____________________________________________________________________________-->
    <para>
     这个应用在数据库 OID 上连接两个系统表（pg_database 和 pg_stat_database），并且还取得和显示通过两个输入参数（一个数据库<literal>postgres</literal>和 OID <literal>1</literal>）检索到的数据库统计。
    </para>

<!--==========================orignal english content==========================
    <para>
     First, declare an SQLDA for input and an SQLDA for output.
<programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* an output descriptor */
sqlda_t *sqlda2; /* an input descriptor  */
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     首先，为输入和输出分别声明一个 SQLDA。
<programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 一个输出描述符 */
sqlda_t *sqlda2; /* 一个输入描述符  */
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Next, connect to the database, prepare a statement, and declare a
     cursor for the prepared statement.
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     接下来，连接到数据库，准备一个语句并且为预备语句声明一个游标。
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Next, put some values in the input SQLDA for the input
     parameters.  Allocate memory for the input SQLDA, and set the
     number of input parameters to <literal>sqln</literal>.  Store
     type, value, and value length into <literal>sqltype</literal>,
     <literal>sqldata</literal>, and <literal>sqllen</literal> in the
     <literal>sqlvar</literal> structure.

<programlisting>
    /* Create SQLDA structure for input parameters. */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     然后，为输入参数在输入 SQLDA 中放入一些值。为输入 SQLDA 分配内存，并且在<literal>sqln</literal>中设置输入参数的数目。在<literal>sqlvar</literal>结构的<literal>sqltype</literal>、<literal>sqldata</literal>和<literal>sqllen</literal>中存入类型、值和值长度。

<programlisting>
    /* 为输入参数创建 SQLDA 结构。 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     After setting up the input SQLDA, open a cursor with the input
     SQLDA.

<programlisting>
    /* Open a cursor with input parameters. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     设置完输入 SQLDA 之后，用输入 SQLDA 打开一个游标。

<programlisting>
    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Fetch rows into the output SQLDA from the opened cursor.
     (Generally, you have to call <command>FETCH</command> repeatedly
     in the loop, to fetch all rows in the result set.)
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assign descriptor to the cursor  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     从打开的游标中取行到输出 SQLDA 中（通常，你不得不在循环中反复调用<command>FETCH</command>来取出结果集中的所有行）。
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 分配描述符给游标  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Next, retrieve the fetched records from the SQLDA, by following
     the linked list of the <type>sqlda_t</type> structure.
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     再后，沿着<type>sqlda_t</type>结构的链表从 SQLDA 中检索取得的记录。
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Read each columns in the first record.  The number of columns is
     stored in <structfield>sqld</>, the actual data of the first
     column is stored in <literal>sqlvar[0]</>, both members of
     the <type>sqlda_t</type> structure.

<programlisting>
        /* Print every column in a row. */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     读取第一个记录中的每一列。列的数量被存储在<structfield>sqld</>中，第一列的实际数据被存储在<literal>sqlvar[0]</>中，两者都是<type>sqlda_t</type>结构的成员。

<programlisting>
        /* 打印一行中的每一列。 */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Now, the column data is stored in the variable <varname>v</>.
     Copy every datum into host variables, looking
     at <literal>v.sqltype</> for the type of the column.
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     现在，列数据已经被存在了变量<varname>v</>中。把每个数据复制到主变量中，列的类型可以查看。
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* 整数 */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Close the cursor after processing all of records, and disconnect
     from the database.
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     处理所有记录后关闭游标，并且从数据库断开连接。
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The whole program is shown
     in <xref linkend="ecpg-sqlda-example-example">.
    </para>
____________________________________________________________________________-->
    <para>
     整个程序显示在<xref linkend="ecpg-sqlda-example-example">中。
    </para>

    <example id="ecpg-sqlda-example-example">
<!--==========================orignal english content==========================
     <title>Example SQLDA Program</title>
____________________________________________________________________________-->
     <title>示例 SQLDA 程序</title>
<!--==========================orignal english content==========================
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* descriptor for output */
sqlda_t *sqlda2; /* descriptor for input */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* Create a SQLDA structure for an input parameter */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* a number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* Open a cursor with input parameters. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assign descriptor to the cursor  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* Print every column in a row. */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
____________________________________________________________________________-->
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 用于输出的描述符 */
sqlda_t *sqlda2; /* 用于输入的描述符 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* 为一个输入参数创建一个 SQLDA 结构 */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 给游标分配描述符  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* 打印一行中的每一列。 */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* 整数 */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* 大整数 */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>

<!--==========================orignal english content==========================
     <para>
      The output of this example should look something like the
      following (some numbers will vary).
     </para>
____________________________________________________________________________-->
     <para>
      这个例子的输出应该看起来类似下面的结果（一些数字会变化）。
     </para>

<!--==========================orignal english content==========================
<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
____________________________________________________________________________-->
<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
<!--==========================orignal english content==========================
  <title>Error Handling</title>
____________________________________________________________________________-->
  <title>错误处理</title>

<!--==========================orignal english content==========================
  <para>
   This section describes how you can handle exceptional conditions
   and warnings in an embedded SQL program.  There are two
   nonexclusive facilities for this.

   <itemizedlist>
    <listitem>
     <simpara>
      Callbacks can be configured to handle warning and error
      conditions using the <literal>WHENEVER</literal> command.
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      Detailed information about the error or warning can be obtained
      from the <varname>sqlca</varname> variable.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   这一节描述在一个嵌入式 SQL 程序中如何处理异常情况和警告。有两种非互斥的工具可以用于这个目的。

   <itemizedlist>
    <listitem>
     <simpara>
      可以使用<literal>WHENEVER</literal>命令配置回调来处理警告和错误情况。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      可以从<varname>sqlca</varname>变量中获得错误或警告的详细信息。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <sect2 id="ecpg-whenever">
<!--==========================orignal english content==========================
   <title>Setting Callbacks</title>
____________________________________________________________________________-->
   <title>设置回调</title>

<!--==========================orignal english content==========================
   <para>
    One simple method to catch errors and warnings is to set a
    specific action to be executed whenever a particular condition
    occurs.  In general:
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一种捕捉错误和警告的简单方法是设置一个特殊的动作，只要一个特定情况发生就执行该动作。通常是这样：
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <replaceable>condition</replaceable> can be one of the following:

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        The specified action is called whenever an error occurs during
        the execution of an SQL statement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        The specified action is called whenever a warning occurs
        during the execution of an SQL statement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        The specified action is called whenever an SQL statement
        retrieves or affects zero rows.  (This condition is not an
        error, but you might be interested in handling it specially.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>condition</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个错误就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个警告就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        只要一个 SQL 语句检索或者影响零行就调用指定的动作（这种情况不是一个错误，但是你可能需要特别地处理它）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    <replaceable>action</replaceable> can be one of the following:

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        This effectively means that the condition is ignored.  This is
        the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        Jump to the specified label (using a C <literal>goto</literal>
        statement).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        Print a message to standard error.  This is useful for simple
        programs or during prototyping.  The details of the message
        cannot be configured.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        Call <literal>exit(1)</literal>, which will terminate the
        program.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        Execute the C statement <literal>break</literal>.  This should
        only be used in loops or <literal>switch</literal> statements.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        Call the specified C functions with the specified arguments.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The SQL standard only provides for the actions
    <literal>CONTINUE</literal> and <literal>GOTO</literal> (and
    <literal>GO TO</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>action</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        这实际上表示该情况被忽略。这是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        调到指定的标签（使用一个 C <literal>goto</literal>语句）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        把一个消息打印到标准错误。对于简单程序或原型开发中这很有用。消息的细节无法配置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        调用<literal>exit(1)</literal>终止程序。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        执行 C 语句<literal>break</literal>。只应被用在循环或<literal>switch</literal>语句中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        用指定参数调用指定的 C 函数。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    SQL 标准只提供动作<literal>CONTINUE</literal>和<literal>GOTO</literal>（以及<literal>GO TO</literal>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example that you might want to use in a simple program.
    It prints a simple message when a warning occurs and aborts the
    program when an error happens:
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个可能会用在简单程序中的例子。当一个警告发生时它打印一个简单消息，而发生一个错误时它会中止程序：
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The statement <literal>EXEC SQL WHENEVER</literal> is a directive
    of the SQL preprocessor, not a C statement.  The error or warning
    actions that it sets apply to all embedded SQL statements that
    appear below the point where the handler is set, unless a
    different action was set for the same condition between the first
    <literal>EXEC SQL WHENEVER</literal> and the SQL statement causing
    the condition, regardless of the flow of control in the C program.
    So neither of the two following C program excerpts will have the
    desired effect:
<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    语句<literal>EXEC SQL WHENEVER</literal>是 SQL 预处理器的一个指令，而不是一个 C 语句。不管 C 程序的控制流程如何，该语句设置的错误或警告动作适用于所有位于处理程序设置点之后的嵌入式 SQL 语句，除非在第一个<literal>EXEC SQL WHENEVER</literal>和导致情况的 SQL 语句之间为同一个情况设置了不同的动作。因此下面的两个 C 程序都不会得到预期的效果：
<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlca">
<!--==========================orignal english content==========================
   <title>sqlca</title>
____________________________________________________________________________-->
   <title>sqlca</title>

<!--==========================orignal english content==========================
   <para>
    For more powerful error handling, the embedded SQL interface
    provides a global variable with the name <varname>sqlca</varname>
    (SQL communication area)
    that has the following structure:
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    (In a multithreaded program, every thread automatically gets its
    own copy of <varname>sqlca</varname>.  This works similarly to the
    handling of the standard C global variable
    <varname>errno</varname>.)
   </para>
____________________________________________________________________________-->
   <para>
    为了更强大的错误处理，嵌入式 SQL 接口提供了一个名为<varname>sqlca</varname>（SQL 通讯区域）的全局变量，它具有下面的结构：
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    （在一个多线程程序中，每一个线程会自动得到它自己的<varname>sqlca</varname>副本。这和对于标准 C 全局变量<varname>errno</varname>的处理相似。）
   </para>

<!--==========================orignal english content==========================
   <para>
    <varname>sqlca</varname> covers both warnings and errors.  If
    multiple warnings or errors occur during the execution of a
    statement, then <varname>sqlca</varname> will only contain
    information about the last one.
   </para>
____________________________________________________________________________-->
   <para>
    <varname>sqlca</varname>覆盖了警告和错误。如果执行一个语句时发生了多个警告或错误，那么<varname>sqlca</varname>将只包含关于最后一个的信息。
   </para>

<!--==========================orignal english content==========================
   <para>
    If no error occurred in the last <acronym>SQL</acronym> statement,
    <literal>sqlca.sqlcode</literal> will be 0 and
    <literal>sqlca.sqlstate</literal> will be
    <literal>"00000"</literal>.  If a warning or error occurred, then
    <literal>sqlca.sqlcode</literal> will be negative and
    <literal>sqlca.sqlstate</literal> will be different from
    <literal>"00000"</literal>.  A positive
    <literal>sqlca.sqlcode</literal> indicates a harmless condition,
    such as that the last query returned zero rows.
    <literal>sqlcode</literal> and <literal>sqlstate</literal> are two
    different error code schemes; details appear below.
   </para>
____________________________________________________________________________-->
   <para>
    如果在上一个<acronym>SQL</acronym>语句中没有产生错误，<literal>sqlca.sqlcode</literal>将为 0 并且<literal>sqlca.sqlstate</literal>将为<literal>"00000"</literal>。如果发生一个警告或错误，则<literal>sqlca.sqlcode</literal>将为负并且<literal>sqlca.sqlstate</literal>将不为<literal>"00000"</literal>。一个正的<literal>sqlca.sqlcode</literal>表示一种无害的情况，例如上一个查询返回零行。<literal>sqlcode</literal>和<literal>sqlstate</literal>是两种不同的错误代码模式，详见下文。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the last SQL statement was successful, then
    <literal>sqlca.sqlerrd[1]</literal> contains the OID of the
    processed row, if applicable, and
    <literal>sqlca.sqlerrd[2]</literal> contains the number of
    processed or returned rows, if applicable to the command.
   </para>
____________________________________________________________________________-->
   <para>
    如果上一个 SQL 语句成功，那么<literal>sqlca.sqlerrd[1]</literal>包含被处理行的 OID （如果可用），并且<literal>sqlca.sqlerrd[2]</literal>包含被处理或被返回的行数（如果适用于该命令）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In case of an error or warning,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> will contain a string
    that describes the error.  The field
    <literal>sqlca.sqlerrm.sqlerrml</literal> contains the length of
    the error message that is stored in
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (the result of
    <function>strlen()</function>, not really interesting for a C
    programmer).  Note that some messages are too long to fit in the
    fixed-size <literal>sqlerrmc</literal> array; they will be truncated.
   </para>
____________________________________________________________________________-->
   <para>
    在发生一个错误或警告的情况下，<literal>sqlca.sqlerrm.sqlerrmc</literal>将包含一个描述该错误的字符串。域<literal>sqlca.sqlerrm.sqlerrml</literal>包含存储在<literal>sqlca.sqlerrm.sqlerrmc</literal>中错误消息的长度（<function>strlen()</function>的结果，对于一个 C 程序员来说并不感兴趣）。注意一些消息可能太长不能适应定长的<literal>sqlerrmc</literal>数组，它们将被截断。
   </para>

<!--==========================orignal english content==========================
   <para>
    In case of a warning, <literal>sqlca.sqlwarn[2]</literal> is set
    to <literal>W</literal>.  (In all other cases, it is set to
    something different from <literal>W</literal>.)  If
    <literal>sqlca.sqlwarn[1]</literal> is set to
    <literal>W</literal>, then a value was truncated when it was
    stored in a host variable.  <literal>sqlca.sqlwarn[0]</literal> is
    set to <literal>W</literal> if any of the other elements are set
    to indicate a warning.
   </para>
____________________________________________________________________________-->
   <para>
    在发生一个警告的情况下，<literal>sqlca.sqlwarn[2]</literal>被设置为<literal>W</literal>（在所有其他情况中，它被设置为不同于<literal>W</literal>的东西）。如果<literal>sqlca.sqlwarn[1]</literal>被设置为<literal>W</literal>，那么一个值被存储在一个主变量中时会被截断。如果任意其他元素被设置为指示一个警告，<literal>sqlca.sqlwarn[0]</literal>会被设置为<literal>W</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The fields <structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>, and the remaining elements of
    <structfield>sqlerrd</structfield> and
    <structfield>sqlwarn</structfield> currently contain no useful
    information.
   </para>
____________________________________________________________________________-->
   <para>
    域<structfield>sqlcaid</structfield>、
    <structfield>sqlcabc</structfield>、
    <structfield>sqlerrp</structfield>以及
    <structfield>sqlerrd</structfield>的剩余元素还有
    <structfield>sqlwarn</structfield>当前不包含有用的信息。
   </para>

<!--==========================orignal english content==========================
   <para>
    The structure <varname>sqlca</varname> is not defined in the SQL
    standard, but is implemented in several other SQL database
    systems.  The definitions are similar at the core, but if you want
    to write portable applications, then you should investigate the
    different implementations carefully.
   </para>
____________________________________________________________________________-->
   <para>
    SQL 标准中没有定义<varname>sqlca</varname>结构，但是在一些其他的 SQL 数据系统中都有实现。在核心上这些定义都想死，但是如果你想要编写可移植的应用，那么你应该仔细研究不同的实现。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is one example that combines the use of <literal>WHENEVER</>
    and <varname>sqlca</varname>, printing out the contents
    of <varname>sqlca</varname> when an error occurs.  This is perhaps
    useful for debugging or prototyping applications, before
    installing a more <quote>user-friendly</quote> error handler.

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

    The result could look as follows (here an error due to a
    misspelled table name):

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个整合使用<literal>WHENEVER</>和<varname>sqlca</varname>的例子，当一个错误发生时打印出<varname>sqlca</varname>的内容。在安装一个更<quote>用户友好</quote>的错误处理器之前，这可能对调试或开发原型应用有用。

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

    结果看起来像（这里的错误是一个拼写错误的表名）：

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
<!--==========================orignal english content==========================
   <title><literal>SQLSTATE</literal> vs. <literal>SQLCODE</literal></title>
____________________________________________________________________________-->
   <title><literal>SQLSTATE</literal> 与 <literal>SQLCODE</literal></title>

<!--==========================orignal english content==========================
   <para>
    The fields <literal>sqlca.sqlstate</literal> and
    <literal>sqlca.sqlcode</literal> are two different schemes that
    provide error codes.  Both are derived from the SQL standard, but
    <literal>SQLCODE</literal> has been marked deprecated in the SQL-92
    edition of the standard and has been dropped in later editions.
    Therefore, new applications are strongly encouraged to use
    <literal>SQLSTATE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    域<literal>sqlca.sqlstate</literal>以及<literal>sqlca.sqlcode</literal>是提供错误代码的两种不同模式。两种都源自于 SQL 标准，但是在标准的 SQL-92 版本中<literal>SQLCODE</literal>已经被标记为弃用并且在后面的版本中被删除。因此，强烈建议新应用使用<literal>SQLSTATE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>SQLSTATE</literal> is a five-character array.  The five
    characters contain digits or upper-case letters that represent
    codes of various error and warning conditions.
    <literal>SQLSTATE</literal> has a hierarchical scheme: the first
    two characters indicate the general class of the condition, the
    last three characters indicate a subclass of the general
    condition.  A successful state is indicated by the code
    <literal>00000</literal>.  The <literal>SQLSTATE</literal> codes are for
    the most part defined in the SQL standard.  The
    <productname>PostgreSQL</productname> server natively supports
    <literal>SQLSTATE</literal> error codes; therefore a high degree
    of consistency can be achieved by using this error code scheme
    throughout all applications.  For further information see
    <xref linkend="errcodes-appendix">.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>SQLSTATE</literal>是一个五字符数组。这五个字符包含数字或大写字母，它表示多种错误或警告情况的代码。<literal>SQLSTATE</literal>具有一种层次模式：前两个字符表示情况的总体分类，后三个字符表示总体情况的子类。代码<literal>00000</literal>表示一种成功的状态。SQL 标准中的大部分都有对应的<literal>SQLSTATE</literal>代码。<productname>PostgreSQL</productname>服务器本地支持<literal>SQLSTATE</literal>错误代码，因此通过在所有应用中自始至终使用这种错误代码模式可以实现高度的一致性。进一步的信息请见<xref linkend="errcodes-appendix">。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>SQLCODE</literal>, the deprecated error code scheme, is a
    simple integer.  A value of 0 indicates success, a positive value
    indicates success with additional information, a negative value
    indicates an error.  The SQL standard only defines the positive
    value +100, which indicates that the last command returned or
    affected zero rows, and no specific negative values.  Therefore,
    this scheme can only achieve poor portability and does not have a
    hierarchical code assignment.  Historically, the embedded SQL
    processor for <productname>PostgreSQL</productname> has assigned
    some specific <literal>SQLCODE</literal> values for its use, which
    are listed below with their numeric value and their symbolic name.
    Remember that these are not portable to other SQL implementations.
    To simplify the porting of applications to the
    <literal>SQLSTATE</literal> scheme, the corresponding
    <literal>SQLSTATE</literal> is also listed.  There is, however, no
    one-to-one or one-to-many mapping between the two schemes (indeed
    it is many-to-many), so you should consult the global
    <literal>SQLSTATE</literal> listing in <xref linkend="errcodes-appendix">
    in each case.
   </para>
____________________________________________________________________________-->
   <para>
    被弃用的错误代码模式<literal>SQLCODE</literal>是一个简单的整数。值为 0 表示成功，一个正值表示带附加信息的成功，一个负值表示一个错误。SQL 标准只定义了正值 +100，它表示上一个命令返回或者影响了零行，并且没有特定的负值。因此，这种模式只能实现很可怜的可移植性并且不具有层次性的代码分配。历史上，<productname>PostgreSQL</productname>的嵌入式 SQL 处理器已经分配了一些特定的<literal>SQLCODE</literal>值供它使用，它们的数字值和符号名称被列在下文。记住这些对其他 SQL 实现不是可移植的。为了简化移植应用到<literal>SQLSTATE</literal>模式，对应的<literal>SQLSTATE</literal>也被列出。不过，在两种模式之间没有一对一或者一对多的映射（事实上是多对多），因此在每一种情况下你都应该参考<xref linkend="errcodes-appendix">中列出的全局<literal>SQLSTATE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    These are the assigned <literal>SQLCODE</literal> values:

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        Indicates no error. (SQLSTATE 00000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       This is a harmless condition indicating that the last command
       retrieved or processed zero rows, or that you are at the end of
       the cursor.  (SQLSTATE 02000)
      </para>

      <para>
       When processing a cursor in a loop, you could use this code as
       a way to detect when to abort the loop, like this:
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
       But <literal>WHENEVER NOT FOUND DO BREAK</literal> effectively
       does this internally, so there is usually no advantage in
       writing this out explicitly.
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        Indicates that your virtual memory is exhausted.  The numeric
        value is defined as <literal>-ENOMEM</literal>.  (SQLSTATE
        YE001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       Indicates the preprocessor has generated something that the
       library does not know about.  Perhaps you are running
       incompatible versions of the preprocessor and the
       library. (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       This means that the command specified more host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       This means that the command specified fewer host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       This means a query has returned multiple rows but the statement
       was only prepared to store one result row (for example, because
       the specified variables are not arrays).  (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>int</type> and the datum in
       the database is of a different type and contains a value that
       cannot be interpreted as an <type>int</type>.  The library uses
       <function>strtol()</function> for this conversion.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>unsigned int</type> and the
       datum in the database is of a different type and contains a
       value that cannot be interpreted as an <type>unsigned
       int</type>.  The library uses <function>strtoul()</function>
       for this conversion.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>float</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>float</type>.  The library
       uses <function>strtod()</function> for this conversion.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>numeric</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>numeric</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>interval</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as an <type>interval</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>date</type> and the datum in
       the database is of another type and contains a value that
       cannot be interpreted as a <type>date</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>timestamp</type> and the
       datum in the database is of another type and contains a value
       that cannot be interpreted as a <type>timestamp</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       This means the host variable is of type <type>bool</type> and
       the datum in the database is neither <literal>'t'</> nor
       <literal>'f'</>.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       The statement sent to the <productname>PostgreSQL</productname>
       server was empty.  (This cannot normally happen in an embedded
       SQL program, so it might point to an internal error.)  (SQLSTATE
       YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       A null value was returned and no null indicator variable was
       supplied.  (SQLSTATE 22002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       An ordinary variable was used in a place that requires an
       array.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       The database returned an ordinary variable in a place that
       requires array value.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-&minus; disabled by #if 0 in ecpglib -&minus;>
    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       The value could not be inserted into the array.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       The program tried to access a connection that does not exist.
       (SQLSTATE 08003)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       The program tried to access a connection that does exist but is
       not open.  (This is an internal error.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       The statement you are trying to use has not been prepared.
       (SQLSTATE 26000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       Duplicate key error, violation of unique constraint (Informix
       compatibility mode).  (SQLSTATE 23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       The descriptor specified was not found.  The statement you are
       trying to use has not been prepared.  (SQLSTATE 33000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       The descriptor index specified was out of range.  (SQLSTATE
       07009)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       An invalid descriptor item was requested.  (This is an internal
       error.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       During the execution of a dynamic statement, the database
       returned a numeric value and the host variable was not numeric.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       During the execution of a dynamic statement, the database
       returned a non-numeric value and the host variable was numeric.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       A result of the subquery is not single row (Informix
       compatibility mode).  (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       Some error caused by the <productname>PostgreSQL</productname>
       server.  The message contains the error message from the
       <productname>PostgreSQL</productname> server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       The <productname>PostgreSQL</productname> server signaled that
       we cannot start, commit, or rollback the transaction.
       (SQLSTATE 08007)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       The connection attempt to the database did not succeed.
       (SQLSTATE 08001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       Duplicate key error, violation of unique constraint.  (SQLSTATE
       23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       A result for the subquery is not single row. (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-&minus; currently not used by the code -&minus;>
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       An unrecognized warning was received from the server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       Current transaction is aborted.  Queries are ignored until the
       end of the transaction block.
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
       An invalid cursor name was specified. (SQLSTATE 34000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       Transaction is in progress. (SQLSTATE 25001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       There is no active (in-progress) transaction. (SQLSTATE 25P01)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
       An existing cursor name was specified. (SQLSTATE 42P03)
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
____________________________________________________________________________-->
   <para>
    这些是已分配的<literal>SQLCODE</literal>值：

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        表示没有错误（SQLSTATE 00000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       这是一种无害情况，它表示上一个命令检索或者处理了零行，或者你到达了游标的末尾（SQLSTATE 02000）。
      </para>

      <para>
       在一个循环中处理一个游标时，你可以使用这个代码作为一种方法来检测何时中止该循环，像这样：
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
       但是<literal>WHENEVER NOT FOUND DO BREAK</literal>实际上会在内部这样做，因此显式地把它写出来通常没有什么好处。
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        表示你的虚拟内存已被耗尽。数字值被定义为<literal>-ENOMEM</literal>（SQLSTATE YE001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       表示预处理器已经产生了一些该库不知道的东西。也许你正在运行一个不兼容版本的预处理和库（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定了超过该命令预期数量的主变量（SQLSTATE 07001 或 07002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定的主变量数量低于该命令的预期（SQLSTATE 07001 或 07002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       这意味着一个查询已经返回了多个行，但是该语句只准备存储一个结果行（例如，因为指定的变量不是数组）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>int</type>的值。该库使用<function>strtol()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>unsigned int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>unsigned int</type>的值。该库使用<function>strtoul()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>float</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>float</type>的值。该库使用<function>strtod()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>numeric</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>numeric</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>interval</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>interval</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>date</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>date</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>timestamp</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>timestamp</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       这表示主变量是类型<type>bool</type>而数据库中的数据既不是<literal>'t'</>也不是<literal>'f'</>（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       发送给<productname>PostgreSQL</productname>服务器的语句是空的（通常在一个嵌入式 SQL 程序中不会发生，因此它可能指向一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       返回了一个空值并且没有提供空值指示符（SQLSTATE 22002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在要求一个数组的地方使用了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在一个要求数组值的地方数据库返回了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- disabled by #if 0 in ecpglib -->
    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       该值不能被插入到数组（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个不存在的连接（SQLSTATE 08003）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个存在的连接但是它没有打开（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       你尝试使用的语句还没有被准备好（SQLSTATE 26000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（Informix 兼容模式）（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       没有找到指定的描述符。你尝试使用的语句还没有被准备好（SQLSTATE 33000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       指定的描述符超出范围（SQLSTATE 07009）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       请求了一个非法的描述符（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个numeric值而主变量不是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个非numeric值而主变量是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（Informix 兼容模式）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器导致了某个错误。该消息包含来自<productname>PostgreSQL</productname>服务器的错误消息。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器通知我们不能启动、提交或回滚事务（SQLSTATE 08007）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       到数据库的连接尝试没有成功（SQLSTATE 08001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- currently not used by the code -->
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       从服务器接收到一个无法识别的警告。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       当前事务被中止。到事务块末尾的查询被忽略。
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
       指定了一个非法的游标名（SQLSTATE 34000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       事务正在进行（SQLSTATE 25001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       没有活动（正在进行）的事务（SQLSTATE 25P01）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
       指定了一个现有的游标名（SQLSTATE 42P03）。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
<!--==========================orignal english content==========================
  <title>Preprocessor Directives</title>
____________________________________________________________________________-->
  <title>预处理器指令</title>

<!--==========================orignal english content==========================
  <para>
   Several preprocessor directives are available that modify how
   the <command>ecpg</command> preprocessor parses and processes a
   file.
  </para>
____________________________________________________________________________-->
  <para>
   一些预处理器指令可以用来改变<command>ecpg</command>预处理器解析和处理一个文件的方式。
  </para>

  <sect2 id="ecpg-include">
<!--==========================orignal english content==========================
   <title>Including Files</title>
____________________________________________________________________________-->
   <title>包括文件</title>

<!--==========================orignal english content==========================
   <para>
    To include an external file into your embedded SQL program, use:
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    The embedded SQL preprocessor will look for a file named
    <literal><replaceable>filename</replaceable>.h</literal>,
    preprocess it, and include it in the resulting C output.  Thus,
    embedded SQL statements in the included file are handled correctly.
   </para>
____________________________________________________________________________-->
   <para>
    要包括一个外部文件到你的嵌入式 SQL 程序中，可以用：
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    嵌入式 SQL 预处理器将查找一个名为<literal><replaceable>filename</replaceable>.h</literal>的文件，处理它并且把它包括在结果 C 输出中。这样，被包括文件中的嵌入式 SQL 语句会被正确地处理。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <command>ecpg</command> preprocessor will search a file at
    several directories in following order:

    <itemizedlist>
     <listitem><simpara>current directory</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL include directory, defined at build time (e.g., <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    But when <literal>EXEC SQL INCLUDE
    "<replaceable>filename</replaceable>"</literal> is used, only the
    current directory is searched.
   </para>
____________________________________________________________________________-->
   <para>
    <command>ecpg</command>预处理器将以下列顺序在几个目录中搜索一个文件：

    <itemizedlist>
     <listitem><simpara>当前目录</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL 的包括目录，在编译时定义（例如<filename>/usr/local/pgsql/include</filename>）</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    但是当使用<literal>EXEC SQL INCLUDE "<replaceable>filename</replaceable>"</literal>时，只有当前目录会被搜索。
   </para>

<!--==========================orignal english content==========================
   <para>
    In each directory, the preprocessor will first look for the file
    name as given, and if not found will append <literal>.h</literal>
    to the file name and try again (unless the specified file name
    already has that suffix).
   </para>
____________________________________________________________________________-->
   <para>
    在每一个目录中，预处理器将首先按给定的文件名搜索，如果没有找到将会追加<literal>.h</literal>到文件名并且重试（除非指定的文件名已经具有该后缀）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that <command>EXEC SQL INCLUDE</command> is <emphasis>not</emphasis> the same as:
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    because this file would not be subject to SQL command preprocessing.
    Naturally, you can continue to use the C
    <literal>#include</literal> directive to include other header
    files.
   </para>
____________________________________________________________________________-->
   <para>
    注意<command>EXEC SQL INCLUDE</command><emphasis>不</emphasis>同于：
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    因为这个文件不服从 SQL 命令预处理。自然地，你可以继续使用 C 的<literal>#include</literal>指令来包括其他头文件。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The include file name is case-sensitive, even though the rest of
     the <literal>EXEC SQL INCLUDE</literal> command follows the normal
     SQL case-sensitivity rules.
    </para>
____________________________________________________________________________-->
    <para>
     包括文件名是大小写敏感的，即使<literal>EXEC SQL INCLUDE</literal>命令的剩余部分遵守通常的 SQL 大小写敏感规则。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
<!--==========================orignal english content==========================
   <title>The define and undef Directives</title>
____________________________________________________________________________-->
   <title>define 和 undef 指令</title>
<!--==========================orignal english content==========================
   <para>
    Similar to the directive <literal>#define</literal> that is known from C,
    embedded SQL has a similar concept:
<programlisting>
EXEC SQL DEFINE <replaceable>name</>;
EXEC SQL DEFINE <replaceable>name</> <replaceable>value</>;
</programlisting>
    So you can define a name:
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    And you can also define constants:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    Use <literal>undef</> to remove a previous definition:
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    与 C 中我们熟知的指令<literal>#define</literal>相似，嵌入式 SQL 具有类似的概念：
<programlisting>
EXEC SQL DEFINE <replaceable>name</>;
EXEC SQL DEFINE <replaceable>name</> <replaceable>value</>;
</programlisting>
    因此你可以定义一个名称：
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    并且你也可以定义常量：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    使用<literal>undef</>来移除一个之前的定义：
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Of course you can continue to use the C versions <literal>#define</literal>
    and <literal>#undef</literal> in your embedded SQL program. The difference
    is where your defined values get evaluated. If you use <literal>EXEC SQL
    DEFINE</> then the <command>ecpg</> preprocessor evaluates the defines and substitutes
    the values. For example if you write:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    then <command>ecpg</> will already do the substitution and your C compiler will never
    see any name or identifier <literal>MYNUMBER</>. Note that you cannot use
    <literal>#define</literal> for a constant that you are going to use in an
    embedded SQL query because in this case the embedded SQL precompiler is not
    able to see this declaration.
   </para>
____________________________________________________________________________-->
   <para>
    当然在你的嵌入式 SQL 程序中你可以继续使用 C 版本的<literal>#define</literal>和<literal>#undef</literal>。区别在于你定义的值会在哪里被计算。如果你使用<literal>EXEC SQL DEFINE</>，那么<command>ecpg</>预处理器会计算这些定义并且替换值。例如，如果你写：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    那么<command>ecpg</>将已经做过替换并且你的 C 编译器将永远不会看见名为<literal>MYNUMBER</>的任何名称或标识符。注意你不能把<literal>#define</literal>用于一个将要在一个嵌入式 SQL 查询中使用的常量，因为在这种情况下嵌入式 SQL 预编译器不能看到这个声明。
   </para>
  </sect2>

  <sect2 id="ecpg-ifdef">
<!--==========================orignal english content==========================
   <title>ifdef, ifndef, else, elif, and endif Directives</title>
____________________________________________________________________________-->
   <title>ifdef、ifndef、else、elif 以及 endif 指令</title>
<!--==========================orignal english content==========================
   <para>
   You can use the following directives to compile code sections conditionally:

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has <emphasis>not</emphasis> been created with
      <literal>EXEC SQL define <replaceable>name</></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      Starts processing an alternative section to a section introduced by
      either <literal>EXEC SQL ifdef <replaceable>name</></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      Checks <replaceable>name</> and starts an alternative section if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      Ends an alternative section.
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
   你可以使用下列指定来有条件地编译代码小节：

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      检查一个<replaceable>name</>，如果已经用<literal>EXEC SQL define <replaceable>name</></literal>创建了<replaceable>name</>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
     检查一个<replaceable>name</>，如果<emphasis>没有</emphasis>用<literal>EXEC SQL define <replaceable>name</></literal>创建<replaceable>name</>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      为一个由<literal>EXEC SQL ifdef <replaceable>name</></literal>或者<literal>EXEC SQL ifndef <replaceable>name</></literal>引入的小节开始处理一个备选小节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      检查<replaceable>name</>，如果已经用<literal>EXEC SQL define <replaceable>name</></literal>创建了<replaceable>name</>就开始处理一个备选小节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      结束一个备选小节。
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Example:
<programlisting>
EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<programlisting>
EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;
</programlisting>
   </para>

  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
<!--==========================orignal english content==========================
  <title>Processing Embedded SQL Programs</title>
____________________________________________________________________________-->
  <title>处理嵌入式 SQL 程序</title>

<!--==========================orignal english content==========================
  <para>
   Now that you have an idea how to form embedded SQL C programs, you
   probably want to know how to compile them.  Before compiling you
   run the file through the embedded <acronym>SQL</acronym>
   <acronym>C</acronym> preprocessor, which converts the
   <acronym>SQL</acronym> statements you used to special function
   calls.  After compiling, you must link with a special library that
   contains the needed functions. These functions fetch information
   from the arguments, perform the <acronym>SQL</acronym> command using
   the <application>libpq</application> interface, and put the result
   in the arguments specified for output.
  </para>
____________________________________________________________________________-->
  <para>
   现在你已经对如何构造嵌入式 SQL C 程序有所了解了，你可能希望知道如何编译它们。在编译之前，你需要让该文件通过嵌入式<acronym>SQL</acronym> <acronym>C</acronym>预处理器，它会把你用到的<acronym>SQL</acronym>转换成特殊的函数调用。在编译之后，你必须链接一个包含所需函数的特殊库。这些函数从参数中取得信息、使用<application>libpq</application>执行<acronym>SQL</acronym>命令并且把结果放在指定的参数中用来输出。
  </para>

<!--==========================orignal english content==========================
  <para>
   The preprocessor program is called <filename>ecpg</filename> and is
   included in a normal <productname>PostgreSQL</> installation.
   Embedded SQL programs are typically named with an extension
   <filename>.pgc</filename>.  If you have a program file called
   <filename>prog1.pgc</filename>, you can preprocess it by simply
   calling:
<programlisting>
ecpg prog1.pgc
</programlisting>
   This will create a file called <filename>prog1.c</filename>.  If
   your input files do not follow the suggested naming pattern, you
   can specify the output file explicitly using the
   <option>-o</option> option.
  </para>
____________________________________________________________________________-->
  <para>
   该预处理器程序被称作<filename>ecpg</filename>并且被包括在一个正常的<productname>PostgreSQL</>安装中。嵌入式 SQL 程序通常带有扩展名<filename>.pgc</filename>。如果你有一个程序文件<filename>prog1.pgc</filename>，你可以调用下面的命令对它进行预处理：
<programlisting>
ecpg prog1.pgc
</programlisting>
   这将创建一个文件<filename>prog1.c</filename>。如果你的输入文件不遵循建议的命名模式，你可以用<option>-o</option>选项显式地指定输出文件。
  </para>

<!--==========================orignal english content==========================
  <para>
   The preprocessed file can be compiled normally, for example:
<programlisting>
cc -c prog1.c
</programlisting>
   The generated C source files include header files from the
   <productname>PostgreSQL</> installation, so if you installed
   <productname>PostgreSQL</> in a location that is not searched by
   default, you have to add an option such as
   <literal>-I/usr/local/pgsql/include</literal> to the compilation
   command line.
  </para>
____________________________________________________________________________-->
  <para>
   预处理过的文件可以被正常地编译，例如：
<programlisting>
cc -c prog1.c
</programlisting>
   产生的 C 源文件从<productname>PostgreSQL</>安装中包括头文件，因此如果你把<productname>PostgreSQL</>安装在一个不被默认搜索的位置，你必须在编译命令行中增加一个选项（例如<literal>-I/usr/local/pgsql/include</literal>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To link an embedded SQL program, you need to include the
   <filename>libecpg</filename> library, like so:
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
   Again, you might have to add an option like
   <literal>-L/usr/local/pgsql/lib</literal> to that command line.
  </para>
____________________________________________________________________________-->
  <para>
   要链接一个嵌入式 SQL 程序，你需要包括<filename>libecpg</filename>库，像这样：
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
   再次，你可能不得不在命令行中增加类似<literal>-L/usr/local/pgsql/lib</literal>的选项。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can
   use <command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   or <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> with package name <literal>libecpg</literal> to
   get the paths for your installation.
  </para>
____________________________________________________________________________-->
  <para>
   你可以使用<command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   或者<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> 加上包名<literal>libecpg</literal>来得到你的安装路径。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you manage the build process of a larger project using
   <application>make</application>, it might be convenient to include
   the following implicit rule to your makefiles:
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   如果你使用<application>make</application>来管理一个大工程的构建过程，把下面的隐式规则包括在你的 makefile 中将会很方便：
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The complete syntax of the <command>ecpg</command> command is
   detailed in <xref linkend="app-ecpg">.
  </para>
____________________________________________________________________________-->
  <para>
   <command>ecpg</command>命令的完整语法可见<xref linkend="app-ecpg">。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <application>ecpg</application> library is thread-safe by
   default.  However, you might need to use some threading
   command-line options to compile your client code.
  </para>
____________________________________________________________________________-->
  <para>
   <application>ecpg</application>库默认是线程安全的。不过，你可能需要使用一些线程命令行选项来编译你的客户端代码。
  </para>
 </sect1>

 <sect1 id="ecpg-library">
<!--==========================orignal english content==========================
  <title>Library Functions</title>
____________________________________________________________________________-->
  <title>库函数</title>

<!--==========================orignal english content==========================
  <para>
   The <filename>libecpg</filename> library primarily contains
   <quote>hidden</quote> functions that are used to implement the
   functionality expressed by the embedded SQL commands.  But there
   are some functions that can usefully be called directly.  Note that
   this makes your code unportable.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>libecpg</filename>库主要包含用于实现嵌入式 SQL 命令所表达功能的<quote>隐藏</quote>函数。但是也有一些可以被直接调用的函数。但是注意这会让你的代码不可移植。
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>stream</replaceable>)</function> turns on debug
     logging if called with the first argument non-zero. Debug logging
     is done on <replaceable>stream</replaceable>.  The log contains
     all <acronym>SQL</acronym> statements with all the input
     variables inserted, and the results from the
     <productname>PostgreSQL</productname> server. This can be very
     useful when searching for errors in your <acronym>SQL</acronym>
     statements.
    </para>
____________________________________________________________________________-->
    <para>
     如果调用时第一个参数非零，<function>ECPGdebug(int <replaceable>on</replaceable>, FILE *<replaceable>stream</replaceable>)</function>会打开调试日志。调试日志在<replaceable>流</replaceable>上完成。该日志包含所有插入了输入变量的<acronym>SQL</acronym>语句，以及来自于<productname>PostgreSQL</productname>服务器的结果。在你的<acronym>SQL</acronym>语句中查找错误时这会非常有用。
    </para>
    <note>
<!--==========================orignal english content==========================
    <para>
    On Windows, if the <application>ecpg</> libraries and an application are
    compiled with different flags, this function call will crash the
    application because the internal representation of the
    <literal>FILE</> pointers differ.  Specifically,
    multithreaded/single-threaded, release/debug, and static/dynamic
    flags should be the same for the library and all applications using
    that library.
    </para>
____________________________________________________________________________-->
    <para>
    在 Windows 上，如果<application>ecpg</>库和应用使用不同标志编译的，这个函数调用将会是应用崩溃，因为<literal>FILE</>指针的内部表达不同。特别地，库和使用库的应用应该使用相同的多线程/单线程、发行/调试以及静态/动态标志。
    </para>
    </note>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
     <para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function> returns the library database connection handle identified by the given name.
       If <replaceable>connection_name</replaceable> is set to <literal>NULL</literal>, the current
       connection handle is returned. If no connection handle can be identified, the function returns
       <literal>NULL</literal>. The returned connection handle can be used to call any other functions
       from <application>libpq</application>, if necessary.
     </para>
____________________________________________________________________________-->
     <para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function>返回由给定名称标识的库数据库连接句柄。如果<replaceable>connection_name</replaceable>被设置为<literal>NULL</literal>，当前连接句柄将被返回。如果无法定位到连接句柄，该函数返回<literal>NULL</literal>。如果需要，返回的连接句柄可以被用来调用任何其他来自于<application>libpq</application>的函数。
     </para>
     <note>
<!--==========================orignal english content==========================
     <para>
       It is a bad idea to manipulate database connection handles made from <application>ecpg</application> directly
       with <application>libpq</application> routines.
     </para>
____________________________________________________________________________-->
     <para>
       直接使用<application>libpq</application>例程来操纵<application>ecpg</application>中建立的数据库连接句柄是一种糟糕的做法。
     </para>
     </note>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
     <para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>
       returns the current transaction status of the given connection identified by <replaceable>connection_name</replaceable>.
       See <xref linkend="libpq-status"> and libpq's <function>PQtransactionStatus()</function> for details about the returned status codes.
     </para>
____________________________________________________________________________-->
     <para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>返回由<replaceable>connection_name</replaceable>标识的给定连接的当前事务状态。关于返回的状态代码请参考<xref linkend="libpq-status">和 libpq 的<function>PQtransactionStatus()</function>。
     </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     <function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>
     returns true if you are connected to a database and false if not.
     <replaceable>connection_name</replaceable> can be <literal>NULL</>
     if a single connection is being used.
    </para>
____________________________________________________________________________-->
    <para>
     如果你连接到了一个数据库，<function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>会返回真；否则返回假。
     如果使用的是一个单一连接，<replaceable>connection_name</replaceable>可以为<literal>NULL</>。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
<!--==========================orignal english content==========================
  <title>Large Objects</title>
____________________________________________________________________________-->
  <title>大对象</title>

<!--==========================orignal english content==========================
  <para>
   Large objects are not directly supported by ECPG, but ECPG
   application can manipulate large objects through the libpq large
   object functions, obtaining the necessary <type>PGconn</type>
   object by calling the <function>ECPGget_PGconn()</function>
   function.  (However, use of
   the <function>ECPGget_PGconn()</function> function and touching
   <type>PGconn</type> objects directly should be done very carefully
   and ideally not mixed with other ECPG database access calls.)
  </para>
____________________________________________________________________________-->
  <para>
   ECPG 并不直接支持大对象，在调用<function>ECPGget_PGconn()</function>函数获得所需的<type>PGconn</type>对象后，ECPG 应用能通过 libpq 大对象函数操纵大对象（不过，对<function>ECPGget_PGconn()</function>函数的使用以及直接接触<type>PGconn</type>对象都必须非常小心，并且最好不要与其他 ECPG 数据库访问调用混合在一起）。
  </para>

<!--==========================orignal english content==========================
  <para>
   For more details about the <function>ECPGget_PGconn()</function>, see
   <xref linkend="ecpg-library">.  For information about the large
   object function interface, see <xref linkend="largeObjects">.
  </para>
____________________________________________________________________________-->
  <para>
   更多关于<function>ECPGget_PGconn()</function>的细节可见<xref linkend="ecpg-library">。大对象函数接口的相关信息可见<xref linkend="largeObjects">。
  </para>

<!--==========================orignal english content==========================
  <para>
   Large object functions have to be called in a transaction block, so
   when autocommit is off, <command>BEGIN</command> commands have to
   be issued explicitly.
  </para>
____________________________________________________________________________-->
  <para>
   大对象函数必须在一个事务块中被调用，因此当自动提交关闭时，必须显式地发出<command>BEGIN</command>命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="ecpg-lo-example"> shows an example program that
   illustrates how to create, write, and read a large object in an
   ECPG application.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="ecpg-lo-example">给出了一个例子程序，它展示了在一个 ECPG 应用中如何创建、写入和读取一个大对象。
  </para>

  <example id="ecpg-lo-example">
<!--==========================orignal english content==========================
   <title>ECPG Program Accessing Large Objects</title>
____________________________________________________________________________-->
   <title>访问大对象的 ECPG 程序</title>
<!--==========================orignal english content==========================
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* create */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* write test */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* read test */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* check */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* cleanup */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
____________________________________________________________________________-->
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* 创建 */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* 写入测试 */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* 读取测试 */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* 检查 */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* 清理 */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
<!--==========================orignal english content==========================
  <title><acronym>C++</acronym> Applications</title>
____________________________________________________________________________-->
  <title><acronym>C++</acronym> 应用</title>

<!--==========================orignal english content==========================
  <para>
   ECPG has some limited support for C++ applications.  This section
   describes some caveats.
  </para>
____________________________________________________________________________-->
  <para>
   ECPG 对于 C++ 应用提供了有限的支持。这一节描述了一些忠告。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <command>ecpg</command> preprocessor takes an input file
   written in C (or something like C) and embedded SQL commands,
   converts the embedded SQL commands into C language chunks, and
   finally generates a <filename>.c</filename> file.  The header file
   declarations of the library functions used by the C language chunks
   that <command>ecpg</command> generates are wrapped
   in <literal>extern "C" { ... }</literal> blocks when used under
   C++, so they should work seamlessly in C++.
  </para>
____________________________________________________________________________-->
  <para>
   <command>ecpg</command>预处理器采用一个用 C（或者类似 C 的东西）和嵌入式 SQL 命令编写的输入文件，把嵌入式 SQL 命令转换成 C 语言块，并且最终产生一个<filename>.c</filename>文件。在 C++ 下使用时，因此它们应该能在 C++ 中无缝地使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   In general, however, the <command>ecpg</command> preprocessor only
   understands C; it does not handle the special syntax and reserved
   words of the C++ language.  So, some embedded SQL code written in
   C++ application code that uses complicated features specific to C++
   might fail to be preprocessed correctly or might not work as
   expected.
  </para>
____________________________________________________________________________-->
  <para>
   不过，通常<command>ecpg</command>预处理器只理解 C，它无法处理 C++ 语言的特殊语法和保留词。因此，一些写在 C++ 应用代码中的使用了 C++ 特定复杂特性的嵌入式 SQL 代码可能无法被正确地预处理或者无法按预期工作。
  </para>

<!--==========================orignal english content==========================
  <para>
   A safe way to use the embedded SQL code in a C++ application is
   hiding the ECPG calls in a C module, which the C++ application code
   calls into to access the database, and linking that together with
   the rest of the C++ code.  See <xref linkend="ecpg-cpp-and-c">
   about that.
  </para>
____________________________________________________________________________-->
  <para>
   使用 C++ 应用中嵌入式 SQL 代码的安全方法是把 ECPG 调用隐藏在一个 C 模块中，C++ 应用代码会调用它来访问数据库，还要把它和剩余的 C++ 代码链接起来。详见<xref linkend="ecpg-cpp-and-c">。
  </para>

  <sect2 id="ecpg-cpp-scope">
<!--==========================orignal english content==========================
   <title>Scope for Host Variables</title>
____________________________________________________________________________-->
   <title>主变量的可见范围</title>

<!--==========================orignal english content==========================
   <para>
    The <command>ecpg</command> preprocessor understands the scope of
    variables in C.  In the C language, this is rather simple because
    the scopes of variables is based on their code blocks.  In C++,
    however, the class member variables are referenced in a different
    code block from the declared position, so
    the <command>ecpg</command> preprocessor will not understand the
    scope of the class member variables.
   </para>
____________________________________________________________________________-->
   <para>
    <command>ecpg</command>预处理器能理解 C 中变量的可见范围。在 C 语言中，这是相当简单的，因为变量的可见范围是基于它们的代码块的。不过在 C++ 中，引用类成员变量的代码块是不同于定义它的代码块的，因此<command>ecpg</command>预处理器将无法理解类成员变量的可见范围。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, in the following case, the <command>ecpg</command>
    preprocessor cannot find any declaration for the
    variable <literal>dbname</literal> in the <literal>test</literal>
    method, so an error will occur.

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

    This code will result in an error like this:
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    例如，在下面的情况中，<command>ecpg</command>预处理器无法为<literal>test</literal>方法中的变量<literal>dbname</literal>找到任何生命，因此将发生一个错误。

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

    这段代码将导致一个这样的错误：
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    To avoid this scope issue, the <literal>test</literal> method
    could be modified to use a local variable as intermediate storage.
    But this approach is only a poor workaround, because it uglifies
    the code and reduces performance.

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    为了避免这种可见性问题，可以修改<literal>test</literal>方法来把一个本地变量用作中间存储。但是这种方法只是一种比较差的变通方案，因为它让代码变得丑陋并且降低了性能。

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-cpp-and-c">
<!--==========================orignal english content==========================
   <title>C++ Application Development with External C Module</title>
____________________________________________________________________________-->
   <title>使用外部 C 模块的 C++ 应用开发</title>

<!--==========================orignal english content==========================
   <para>
    If you understand these technical limitations of
    the <command>ecpg</command> preprocessor in C++, you might come to
    the conclusion that linking C objects and C++ objects at the link
    stage to enable C++ applications to use ECPG features could be
    better than writing some embedded SQL commands in C++ code
    directly.  This section describes a way to separate some embedded
    SQL commands from C++ application code with a simple example.  In
    this example, the application is implemented in C++, while C and
    ECPG is used to connect to the PostgreSQL server.
   </para>
____________________________________________________________________________-->
   <para>
    如果你理解了 C++ 中<command>ecpg</command>预处理器的这些技术限制，你可能已经知道在链接阶段把 C 对象和 C++ 对象链接起来让 C++ 应用能使用 ECPG 特性比直接在 C++ 代码中写一些嵌入式 SQL 命令要更好。这一节用一个简单的例子描述了一种将嵌入式 SQL 命令从 C++ 应用代码中独立出去的方法。在这个例子中，应用由 C++ 实现，而 C 和 ECPG 被用来连接到 PostgreSQL 服务器。
   </para>

<!--==========================orignal english content==========================
   <para>
    Three kinds of files have to be created: a C file
    (<filename>*.pgc</filename>), a header file, and a C++ file:

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
        A sub-routine module to execute SQL commands embedded in C.
        It is going to be converted
        into <filename>test_mod.c</filename> by the preprocessor.

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
        A header file with declarations of the functions in the C
        module (<filename>test_mod.pgc</filename>).  It is included by
        <filename>test_cpp.cpp</filename>.  This file has to have an
        <literal>extern "C"</literal> block around the declarations,
        because it will be linked from the C++ module.

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
        The main code for the application, including
        the <function>main</function> routine, and in this example a
        C++ class.

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    需要创建三种文件：一个 C 文件（<filename>*.pgc</filename>）、一个头文件和一个 C++ 文件：

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
        一个执行嵌入在 C 中的 SQL 命令的子例程模块。它将被预处理器转换成<filename>test_mod.c</filename>。

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
        包含 C 模块（<filename>test_mod.pgc</filename>）中函数定义的头文件。它会被<filename>test_cpp.cpp</filename>包括。这个文件必须在声明周围有一个<literal>extern "C"</literal>块，因为它将被链接到 C++ 模块。

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
        应用的主代码，包括<function>main</function>例程以及这个例子中的一个 C++ 类。

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    To build the application, proceed as follows.  Convert
    <filename>test_mod.pgc</> into <filename>test_mod.c</> by
    running <command>ecpg</command>, and generate
    <filename>test_mod.o</> by compiling
    <filename>test_mod.c</> with the C compiler:
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    要构建该应用，按以下步骤处理。通过运行<command>ecpg</command>将<filename>test_mod.pgc</>转换为<filename>test_mod.c</>，并且用 C 编译器将<filename>test_mod.c</>编译成<filename>test_mod.o</>：
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Next, generate <filename>test_cpp.o</> by compiling
    <filename>test_cpp.cpp</> with the C++ compiler:
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    接着，用 C++ 编译器把<filename>test_cpp.cpp</>编译成<filename>test_cpp.o</>：
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Finally, link these object files, <filename>test_cpp.o</>
    and <filename>test_mod.o</>, into one executable, using the C++
    compiler driver:
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    最后，使用 C++ 编译器链接这些对象文件（<filename>test_cpp.o</>和<filename>test_mod.o</>）成为一个可执行文件：
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
<!--==========================orignal english content==========================
  <title>Embedded SQL Commands</title>
____________________________________________________________________________-->
  <title>嵌入式 SQL 命令</title>

<!--==========================orignal english content==========================
  <para>
   This section describes all SQL commands that are specific to
   embedded SQL.  Also refer to the SQL commands listed
   in <xref linkend="sql-commands">, which can also be used in
   embedded SQL, unless stated otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   这一节描述嵌入式 SQL 所有特定的 SQL 命令。<xref linkend="sql-commands">中的 SQL 命令也能被用于嵌入式 SQL，如果有例外会特别说明。
  </para>

  <refentry id="ecpg-sql-allocate-descriptor">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>allocate an SQL descriptor area</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>分配一个 SQL 描述符区域</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>ALLOCATE DESCRIPTOR</command> allocates a new named SQL
     descriptor area, which can be used to exchange data between the
     PostgreSQL server and the host program.
    </para>
____________________________________________________________________________-->
    <para>
     <command>ALLOCATE DESCRIPTOR</command>分配一个新的命名 SQL 描述符区域，它能被用来在 PostgreSQL 服务器和主程序之间交换数据。
    </para>

<!--==========================orignal english content==========================
    <para>
     Descriptor areas should be freed after use using
     the <command>DEALLOCATE DESCRIPTOR</command> command.
    </para>
____________________________________________________________________________-->
    <para>
     以后可以使用<command>DEALLOCATE DESCRIPTOR</command>命令释放描述符区域。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A name of SQL descriptor, case sensitive.  This can be an SQL
        identifier or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        SQL 描述符的名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>ALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>ALLOCATE DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>establish a database connection</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>建立一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     The <command>CONNECT</command> command establishes a connection
     between the client and the PostgreSQL server.
    </para>
____________________________________________________________________________-->
    <para>
     <command>CONNECT</command>命令在客户端和 PostgreSQL 服务器之间建立一个连接。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">connection_target</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">connection_target</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <replaceable class="PARAMETER">connection_target</replaceable>
        specifies the target server of the connection on one of
        several forms.

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
            Connect over TCP/IP
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            Connect over Unix-domain sockets
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            Connect over TCP/IP
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>SQL string constant</term>
          <listitem>
           <para>
            containing a value in one of the above forms
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>host variable</term>
          <listitem>
           <para>
            host variable of type <type>char[]</type>
            or <type>VARCHAR[]</type> containing a value in one of the
            above forms
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
____________________________________________________________________________-->
       <para>
        <replaceable class="PARAMETER">connection_target</replaceable>以下列形式之一指定连接的目标服务器。

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 Unix 域套接字
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>SQL string constant</term>
          <listitem>
           <para>
            包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>host variable</term>
          <listitem>
           <para>
            类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，它包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">connection_object</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">connection_object</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An optional identifier for the connection, so that it can be
        referred to in other commands.  This can be an SQL identifier
        or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        用于该连接的一个可选标识符，这样可以在其他命令中引用它。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">connection_user</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">connection_user</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The user name for the database connection.
       </para>
____________________________________________________________________________-->
       <para>
        用于数据库连接的用户名。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can also specify user name and password, using one the forms
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>, or
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
       </para>
____________________________________________________________________________-->
       <para>
        使用
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>、
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>或者
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>之一，这个参数也能指定用户名和口令.
       </para>

<!--==========================orignal english content==========================
       <para>
        User name and password can be SQL identifiers, string
        constants, or host variables.
       </para>
____________________________________________________________________________-->
       <para>
        用户名和口令可以是 SQL 标识符、字符串常量或者主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DEFAULT</literal></term>
____________________________________________________________________________-->
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Use all default connection parameters, as defined by libpq.
       </para>
____________________________________________________________________________-->
       <para>
        按 libpq 的定义使用所有默认连接参数。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
    <para>
     Here a several variants for specifying connection parameters:
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一些指定连接参数的变体：
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example program that illustrates the use of host
     variables to specify connection parameters:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* database name */
    char *user       = "testuser";  /* connection user name */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* connection string */
    char ver[256];                  /* buffer to store the version string */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个展示使用主变量指定连接参数的例子程序：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* 数据库名 */
    char *user       = "testuser";  /* 连接用户名 */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* 连接字符串 */
    char ver[256];                  /* 存储版本字符串的缓冲区 */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>CONNECT</command> is specified in the SQL standard, but
     the format of the connection parameters is
     implementation-specific.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>CONNECT</command>，但是连接参数的格式是与实现相关的。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>deallocate an SQL descriptor area</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>释放一个 SQL 描述符区域</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>DEALLOCATE DESCRIPTOR</command> deallocates a named SQL
     descriptor area.
    </para>
____________________________________________________________________________-->
    <para>
     <command>DEALLOCATE DESCRIPTOR</command>释放一个命名的 SQL 描述符区域。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the descriptor which is going to be deallocated.
        It is case sensitive.  This can be an SQL identifier or a host
        variable.
       </para>
____________________________________________________________________________-->
       <para>
        要被释放的描述符的名称。它是大小写敏感的。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>DEALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准说明了<command>DEALLOCATE DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>define a cursor</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>定义一个游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">prepared_name</replaceable>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">query</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">prepared_name</replaceable>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">query</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>DECLARE</command> declares a cursor for iterating over
     the result set of a prepared statement.  This command has
     slightly different semantics from the direct SQL
     command <command>DECLARE</command>: Whereas the latter executes a
     query and prepares the result set for retrieval, this embedded
     SQL command merely declares a name as a <quote>loop
     variable</quote> for iterating over the result set of a query;
     the actual execution happens when the cursor is opened with
     the <command>OPEN</command> command.
    </para>
____________________________________________________________________________-->
    <para>
     <command>DECLARE</command>声明一个游标用来在一个预备语句的结果集上迭代。这个命令与直接的 SQL 命令<command>DECLARE</command>在语义上有一点点区别：后者会执行一个查询并且准备结果集用于检索，而这个嵌入式 SQL 命令仅仅声明一个名称作为<quote>循环变量</quote>用于在一个查询的结果集上迭代，实际的执行在游标被<command>OPEN</command>命令打开时才发生。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>
    <variablelist>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A cursor name, case sensitive.  This can be an SQL identifier
        or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个游标名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a prepared query, either as an SQL identifier or a
        host variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个预备查询的名称，可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">query</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A <xref linkend="sql-select"> or
        <xref linkend="sql-values"> command which will provide the
        rows to be returned by the cursor.
       </para>
____________________________________________________________________________-->
       <para>
        一个提供游标要返回的行的<xref linkend="sql-select">或者<xref linkend="sql-values">命令。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--==========================orignal english content==========================
    <para>
     For the meaning of the cursor options,
     see <xref linkend="sql-declare">.
    </para>
____________________________________________________________________________-->
    <para>
     游标选项的含义请见<xref linkend="sql-declare">。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
    <para>
     Examples declaring a cursor for a query:
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     为一个查询声明一个游标的例子：
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     An example declaring a cursor for a prepared statement:
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     为一个预备语句声明一个游标的例子：
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>DECLARE</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DECLARE</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"></member>
     <member><xref linkend="sql-close"></member>
     <member><xref linkend="sql-declare"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>obtain information about a prepared statement or result set</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>得到有关一个预备语句或结果集的信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO <replaceable class="PARAMETER">sqlda_name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO <replaceable class="PARAMETER">sqlda_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>DESCRIBE</command> retrieves metadata information about
     the result columns contained in a prepared statement, without
     actually fetching a row.
    </para>
____________________________________________________________________________-->
    <para>
     <command>DESCRIBE</command>检索被一个预备语句所含的结果列的元信息，而不会实际取得一行。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a prepared statement.  This can be an SQL
        identifier or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个预备语句的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A descriptor name. It is case sensitive.  It can be an SQL
        identifier or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个描述符名称。它是大小写敏感的。它可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">sqlda_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">sqlda_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of an SQLDA variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个 SQLDA 变量的名称。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>DESCRIBE</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DESCRIBE</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>terminate a database connection</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>终止一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
DISCONNECT <replaceable class="PARAMETER">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
</synopsis>
____________________________________________________________________________-->
<synopsis>
DISCONNECT <replaceable class="PARAMETER">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>DISCONNECT</command> closes a connection (or all
     connections) to the database.
    </para>
____________________________________________________________________________-->
    <para>
     <command>DISCONNECT</command>关闭一个（或者所有）到数据库的连接。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
____________________________________________________________________________-->
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>CURRENT</literal></term>
____________________________________________________________________________-->
      <term><literal>CURRENT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Close the <quote>current</quote> connection, which is either
        the most recently opened connection, or the connection set by
        the <command>SET CONNECTION</command> command.  This is also
        the default if no argument is given to
        the <command>DISCONNECT</command> command.
       </para>
____________________________________________________________________________-->
       <para>
        关闭<quote>当前的</quote>连接，它可以是最近打开的连接或者是由<command>SET CONNECTION</command>命令设置的连接。如果没有参数被传给<command>DISCONNECT</command>命令，这将是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DEFAULT</literal></term>
____________________________________________________________________________-->
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Close the default connection.
       </para>
____________________________________________________________________________-->
       <para>
        关闭默认连接。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>ALL</literal></term>
____________________________________________________________________________-->
      <term><literal>ALL</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Close all open connections.
       </para>
____________________________________________________________________________-->
       <para>
        关闭所有打开的连接。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* close DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */

    return 0;
}
</programlisting>
____________________________________________________________________________-->
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* 关闭 con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* 关闭 DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* 关闭 con2 以及 con1 */

    return 0;
}
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>DISCONNECT</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DISCONNECT</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>dynamically prepare and execute a statement</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>动态地准备和执行一个语句</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
EXECUTE IMMEDIATE <replaceable class="PARAMETER">string</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXECUTE IMMEDIATE <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>EXECUTE IMMEDIATE</command> immediately prepares and
     executes a dynamically specified SQL statement, without
     retrieving result rows.
    </para>
____________________________________________________________________________-->
    <para>
     <command>EXECUTE IMMEDIATE</command>立刻预备并且执行一个动态指定的 SQL 语句，不检索结果行。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">string</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A literal C string or a host variable containing the SQL
        statement to be executed.
       </para>
____________________________________________________________________________-->
       <para>
        包含要被执行的 SQL 语句的一个 C 字符串或者是一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
    <para>
     Here is an example that executes an <command>INSERT</command>
     statement using <command>EXECUTE IMMEDIATE</command> and a host
     variable named <varname>command</varname>:
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个用<command>EXECUTE IMMEDIATE</command>和一个名为<varname>command</varname>的主变量执行<command>INSERT</command>语句的例子：
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>EXECUTE IMMEDIATE</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>EXECUTE IMMEDIATE</command>。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>get information from an SQL descriptor area</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>从一个 SQL 描述符区域得到信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">column_number</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_item</replaceable> [, ... ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">column_number</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_item</replaceable> [, ... ]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>GET DESCRIPTOR</command> retrieves information about a
     query result set from an SQL descriptor area and stores it into
     host variables.  A descriptor area is typically populated
     using <command>FETCH</command> or <command>SELECT</command>
     before using this command to transfer the information into host
     language variables.
    </para>
____________________________________________________________________________-->
    <para>
     <command>GET DESCRIPTOR</command>从一个 SQL 描述符区域检索关于一个查询结果集的信息并且把它存储在主变量中。在使用这个命令把信息传输到主语言变量之前，一个描述符区域通常是用<command>FETCH</command>或<command>SELECT</command>填充的。
    </para>

<!--==========================orignal english content==========================
    <para>
     This command has two forms: The first form retrieves
     descriptor <quote>header</quote> items, which apply to the result
     set in its entirety.  One example is the row count.  The second
     form, which requires the column number as additional parameter,
     retrieves information about a particular column.  Examples are
     the column name and the actual column value.
    </para>
____________________________________________________________________________-->
    <para>
     这个命令有两种形式：第一种形式检索描述符的<quote>头部</quote>项，它适用于全面地查看结果集。一种例子是行计数。第二种形式要求列号作为附加参数，它检索有关一个特定列的信息。其例子是查看列名和实际列值。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A descriptor name.
       </para>
____________________________________________________________________________-->
       <para>
        一个描述符名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A token identifying which header information item to retrieve.
        Only <literal>COUNT</literal>, to get the number of columns in the
        result set, is currently supported.
       </para>
____________________________________________________________________________-->
       <para>
        一个标识要检索哪一个头部信息项的记号。当前只支持用于得到结果集中列数的<literal>COUNT</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">column_number</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">column_number</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The number of the column about which information is to be
        retrieved.  The count starts at 1.
       </para>
____________________________________________________________________________-->
       <para>
        要检索其信息的列号。计数从 1 开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A token identifying which item of information about a column
        to retrieve.  See <xref linkend="ecpg-named-descriptors"> for
        a list of supported items.
       </para>
____________________________________________________________________________-->
       <para>
        一个标识要检索哪一个有关一列信息的项的记号。被支持的项可见<xref linkend="ecpg-named-descriptors">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">cvariable</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">cvariable</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A host variable that will receive the data retrieved from the
        descriptor area.
       </para>
____________________________________________________________________________-->
       <para>
        接收从描述符区域检索到的数据的主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
    <para>
     An example to retrieve the number of columns in a result set:
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     检索一个结果集中列数的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     An example to retrieve a data length in the first column:
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     检索第一列中数据长度的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     An example to retrieve the data body of the second column as a
     string:
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     把第二列的数据体检索成一个字符串的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example for a whole procedure of
     executing <literal>SELECT current_database();</> and showing the number of
     columns, the column data length, and the column data:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* Declare, open a cursor, and assign a descriptor to the cursor  */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* Get a number of total columns */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* Get length of a returned column */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* Fetch the returned column as a string */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* Closing */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     When the example is executed, the result will look like this:
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     这里是执行<literal>SELECT current_database();</>并且显示列数、列数据长度和列数据的完整过程的例子：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* 描述、打开一个游标，并且分配一个描述符给该游标  */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* 得到全部列的数量 */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* 得到一个返回列的长度 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* 将返回的列取出成一个字符串 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* 关闭 */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     当该例子被执行时，结果看起来是：
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>GET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>GET DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>open a dynamic cursor</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>打开一个动态游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING <replaceable class="PARAMETER">value</replaceable> [, ... ]
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING <replaceable class="PARAMETER">value</replaceable> [, ... ]
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>OPEN</command> opens a cursor and optionally binds
     actual values to the placeholders in the cursor's declaration.
     The cursor must previously have been declared with
     the <command>DECLARE</command> command.  The execution
     of <command>OPEN</command> causes the query to start executing on
     the server.
    </para>
____________________________________________________________________________-->
    <para>
     <command>OPEN</command>打开一个游标并且可选地绑定实际值到游标声明中的占位符。该游标必须之前用<command>DECLARE</command>命令声明。<command>OPEN</command>的执行会导致查询开始在服务器上执行。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the cursor to be opened.  This can be an SQL
        identifier or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        要被打开的游标的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">value</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A value to be bound to a placeholder in the cursor.  This can
        be an SQL constant, a host variable, or a host variable with
        indicator.
       </para>
____________________________________________________________________________-->
       <para>
        要被绑定到游标中一个占位符的值。这可以是一个 SQL 常量、一个主变量或者一个带有指示符的主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a descriptor containing values to be bound to the
        placeholders in the cursor.  This can be an SQL identifier or
        a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        包含要绑定到游标中占位符的值的描述符的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>OPEN</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>OPEN</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"></member>
     <member><xref linkend="sql-close"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>prepare a statement for execution</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>准备一个语句用于执行</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
PREPARE <replaceable class="PARAMETER">name</replaceable> FROM <replaceable class="PARAMETER">string</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
PREPARE <replaceable class="PARAMETER">name</replaceable> FROM <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>PREPARE</command> prepares a statement dynamically
     specified as a string for execution.  This is different from the
     direct SQL statement <xref linkend="sql-prepare">, which can also
     be used in embedded programs.  The <xref linkend="sql-execute">
     command is used to execute either kind of prepared statement.
    </para>
____________________________________________________________________________-->
    <para>
     <command>PREPARE</command>将一个作为字符串动态指定的语句准备好执行。这不同于直接的 SQL 语句<xref linkend="sql-prepare">（也可以用于嵌入式程序）。<xref linkend="sql-execute">命令被用来执行两种类型的预备语句。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An identifier for the prepared query.
       </para>
____________________________________________________________________________-->
       <para>
        预备查询的一个标识符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">string</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A literal C string or a host variable containing a preparable
        statement, one of the SELECT, INSERT, UPDATE, or
        DELETE.
       </para>
____________________________________________________________________________-->
       <para>
        包含一个可预备语句的一个 C 字符串或一个主变量，可预备语句是 SELECT、INSERT、UPDATE 或者 DELETE 之一。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>
<!--==========================orignal english content==========================
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
____________________________________________________________________________-->
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>PREPARE</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>PREPARE</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="sql-execute"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>set the autocommit behavior of the current session</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>设置当前会话的自动提交行为</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
____________________________________________________________________________-->
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET AUTOCOMMIT</command> sets the autocommit behavior of
     the current database session.  By default, embedded SQL programs
     are <emphasis>not</emphasis> in autocommit mode,
     so <command>COMMIT</command> needs to be issued explicitly when
     desired.  This command can change the session to autocommit mode,
     where each individual statement is committed implicitly.
    </para>
____________________________________________________________________________-->
    <para>
     <command>SET AUTOCOMMIT</command>设置当前数据库会话的自动提交行为。默认情况下，嵌入式 SQL 程序<emphasis>不</emphasis>在自动提交模式中，因此需要显式地发出<command>COMMIT</command>。这个命令可以把会话改成自动提交模式，这样每一个单独的语句都会被隐式提交。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET AUTOCOMMIT</command> is an extension of PostgreSQL ECPG.
    </para>
____________________________________________________________________________-->
    <para>
     <command>SET AUTOCOMMIT</command>是 PostgreSQL ECPG 的扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>select a database connection</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>选择一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="PARAMETER">connection_name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="PARAMETER">connection_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET CONNECTION</command> sets the <quote>current</quote>
     database connection, which is the one that all commands use
     unless overridden.
    </para>
____________________________________________________________________________-->
    <para>
     <command>SET CONNECTION</command>设置<quote>当前的</quote>数据库连接，除非被覆盖，所有命令都会使用这个连接。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
____________________________________________________________________________-->
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DEFAULT</literal></term>
____________________________________________________________________________-->
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Set the connection to the default connection.
       </para>
____________________________________________________________________________-->
       <para>
        设置该连接为默认连接。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET CONNECTION</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>SET CONNECTION</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-disconnect"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>set information in an SQL descriptor area</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>在一个 SQL 描述符区域中设置信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">number</replaceable> <replaceable class="PARAMETER">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
____________________________________________________________________________-->
<synopsis>
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">number</replaceable> <replaceable class="PARAMETER">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET DESCRIPTOR</command> populates an SQL descriptor
     area with values.  The descriptor area is then typically used to
     bind parameters in a prepared query execution.
    </para>
____________________________________________________________________________-->
    <para>
     <command>SET DESCRIPTOR</command>用值填充一个 SQL 描述符区域。然后该描述符区域通常会被用来在一个预备查询执行中绑定参数。
    </para>

<!--==========================orignal english content==========================
    <para>
     This command has two forms: The first form applies to the
     descriptor <quote>header</quote>, which is independent of a
     particular datum.  The second form assigns values to particular
     datums, identified by number.
    </para>
____________________________________________________________________________-->
    <para>
     这个命令由两种形式：第一种形式适用于描述符<quote>头部</quote>，它独立于特定的数据。第二种形式为由数字标识的特定数据赋值。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A descriptor name.
       </para>
____________________________________________________________________________-->
       <para>
        一个描述符名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A token identifying which header information item to set.
        Only <literal>COUNT</literal>, to set the number of descriptor
        items, is currently supported.
       </para>
____________________________________________________________________________-->
       <para>
        一个标识要设置哪个头部信息项的记号。当前只有设置描述符项数量的<literal>COUNT</literal>被支持。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">number</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">number</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The number of the descriptor item to set.  The count starts at
        1.
       </para>
____________________________________________________________________________-->
       <para>
        要设置的描述符项的编号。计数从 1 开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A token identifying which item of information to set in the
        descriptor.  See <xref linkend="ecpg-named-descriptors"> for a
        list of supported items.
       </para>
____________________________________________________________________________-->
       <para>
        一个标识在描述符中要设置哪个信息项的记号。受支持的项的列表可见<xref linkend="ecpg-named-descriptors">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">value</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A value to store into the descriptor item.  This can be an SQL
        constant or a host variable.
       </para>
____________________________________________________________________________-->
       <para>
        一个要存储在描述符项中的值。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>
<!--==========================orignal english content==========================
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>SET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>SET DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>See Also</title>
____________________________________________________________________________-->
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>define a new data type</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>定义一种新数据类型</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
TYPE <replaceable class="PARAMETER">type_name</replaceable> IS <replaceable class="PARAMETER">ctype</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
TYPE <replaceable class="PARAMETER">type_name</replaceable> IS <replaceable class="PARAMETER">ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     The <command>TYPE</command> command defines a new C type.  It is
     equivalent to putting a <literal>typedef</literal> into a declare
     section.
    </para>
____________________________________________________________________________-->
    <para>
     <command>TYPE</command>命令定义一个新的 C 类型。它等效于把一个<literal>typedef</literal>放在声明节中。
    </para>

<!--==========================orignal english content==========================
    <para>
     This command is only recognized when <command>ecpg</command> is
     run with the <option>-c</option> option.
    </para>
____________________________________________________________________________-->
    <para>
     只有使用选项<option>-c</option>运行<command>ecpg</command>时才能识别这个命令。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">type_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">type_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name for the new type.  It must be a valid C type name.
       </para>
____________________________________________________________________________-->
       <para>
        新类型的名称。这必须是一个合法的 C 类型名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A C type specification.
       </para>
____________________________________________________________________________-->
       <para>
        一个 C 类型说明。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>

<!--==========================orignal english content==========================
    <para>
     Here is an example program that uses <command>EXEC SQL
     TYPE</command>:
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

     The output from this program looks like this:
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个使用<command>EXEC SQL TYPE</command>的例子程序：
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

     这个程序的输出看起来像：
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     The <command>TYPE</command> command is a PostgreSQL extension.
    </para>
____________________________________________________________________________-->
    <para>
     <command>TYPE</command>命令是一种 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>define a variable</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>定义一个变量</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     The <command>VAR</command> command assigns a new C data type
     to a host variable.  The host variable must be previously
     declared in a declare section.
    </para>
____________________________________________________________________________-->
    <para>
     <command>VAR</command>命令分配一个新的 C 数据类型给一个主变量。主变量必须之前在一个声明节中声明过。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">varname</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">varname</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A C variable name.
       </para>
____________________________________________________________________________-->
       <para>
        一个 C 变量名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A C type specification.
       </para>
____________________________________________________________________________-->
       <para>
        一个 C 类型说明。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
____________________________________________________________________________-->
<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     The <command>VAR</command> command is a PostgreSQL extension.
    </para>
____________________________________________________________________________-->
    <para>
     <command>VAR</command>命令是一个 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
<!--==========================orignal english content==========================
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>specify the action to be taken when an SQL statement causes a specific class condition to be raised</refpurpose>
   </refnamediv>
____________________________________________________________________________-->
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>指定一个要在一个 SQL 语句导致发生一个特定类别的情况时要采取的动作</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="PARAMETER">action</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="PARAMETER">action</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Description</title>
____________________________________________________________________________-->
    <title>描述</title>

<!--==========================orignal english content==========================
    <para>
     Define a behavior which is called on the special cases (Rows not
     found, SQL warnings or errors) in the result of SQL execution.
    </para>
____________________________________________________________________________-->
    <para>
     定义一个行为，它会在 SQL 执行结果的特殊情况（行未找到、SQL 警告或错误）中被调用。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Parameters</title>
____________________________________________________________________________-->
    <title>参数</title>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="ecpg-whenever"> for a description of the
     parameters.
    </para>
____________________________________________________________________________-->
    <para>
     参数描述见<xref linkend="ecpg-whenever">。
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Examples</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
____________________________________________________________________________-->
<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>

<!--==========================orignal english content==========================
    <para>
     A typical application is the use of <literal>WHENEVER NOT FOUND
     BREAK</literal> to handle looping through result sets:
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一个典型的应用是使用<literal>WHENEVER NOT FOUND BREAK</literal>来处理通过结果集的循环：
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* 当到达结果集末尾时，跳出循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--==========================orignal english content==========================
    <title>Compatibility</title>
____________________________________________________________________________-->
    <title>兼容性</title>

<!--==========================orignal english content==========================
    <para>
     <command>WHENEVER</command> is specified in the SQL standard, but
     most of the actions are PostgreSQL extensions.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准中说明了<command>WHENEVER</command>，但是大部分动作是 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
<!--==========================orignal english content==========================
  <title><productname>Informix</productname> Compatibility Mode</title>
____________________________________________________________________________-->
  <title><productname>Informix</productname>兼容模式</title>
<!--==========================orignal english content==========================
  <para>
   <command>ecpg</command> can be run in a so-called <firstterm>Informix compatibility mode</>. If
   this mode is active, it tries to behave as if it were the <productname>Informix</productname>
   precompiler for <productname>Informix</productname> E/SQL. Generally spoken this will allow you to use
   the dollar sign instead of the <literal>EXEC SQL</> primitive to introduce
   embedded SQL commands:
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <command>ecpg</command>可以运行在一种所谓的<firstterm>Informix 兼容模式</>中。如果这种模式被激活，它的行为就好像它是一个用于<productname>Informix</productname> E/SQL 的<productname>Informix</productname>预编译器。一般而言，这将允许你使用美元符号替代<literal>EXEC SQL</>来引入嵌入式 SQL 命令：
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    There must not be any white space between the <literal>$</literal>
    and a following preprocessor directive, that is,
    <literal>include</literal>, <literal>define</literal>, <literal>ifdef</literal>,
    etc.  Otherwise, the preprocessor will parse the token as a host
    variable.
   </para>
____________________________________________________________________________-->
   <para>
    在<literal>$</literal>之间不能有任何空白以及下列之一的预处理器指令：<literal>include</literal>、<literal>define</literal>、<literal>ifdef</literal>等。否则，预处理器将把记号解析成一个主变量。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   There are two compatibility modes: <literal>INFORMIX</>, <literal>INFORMIX_SE</>
  </para>
____________________________________________________________________________-->
  <para>
   有两种兼容性模式：<literal>INFORMIX</>、<literal>INFORMIX_SE</>
  </para>
<!--==========================orignal english content==========================
  <para>
   When linking programs that use this compatibility mode, remember to link
   against <literal>libcompat</> that is shipped with ECPG.
  </para>
____________________________________________________________________________-->
  <para>
   在链接使用这种兼容性模式的程序时，要记得链接上和 ECPG 一起发布的<literal>libcompat</>。
  </para>
<!--==========================orignal english content==========================
  <para>
   Besides the previously explained syntactic sugar, the <productname>Informix</productname> compatibility
   mode ports some functions for input, output and transformation of data as
   well as embedded SQL statements known from E/SQL to ECPG.
  </para>
____________________________________________________________________________-->
  <para>
   除了之前解释过的语法糖，<productname>Informix</productname>兼容性模式从 E/SQL 中移植了一些用于输入、输出和数据转换的函数以及嵌入式 SQL 语句到 ECPG 中。
  </para>
<!--==========================orignal english content==========================
  <para>
   <productname>Informix</productname> compatibility mode is closely connected to the pgtypeslib library
   of ECPG. pgtypeslib maps SQL data types to data types within the C host
   program and most of the additional functions of the <productname>Informix</productname> compatibility
   mode allow you to operate on those C host program types. Note however that
   the extent of the compatibility is limited. It does not try to copy <productname>Informix</productname>
   behavior; it allows you to do more or less the same operations and gives
   you functions that have the same name and the same basic behavior but it is
   no drop-in replacement if you are using <productname>Informix</productname> at the moment. Moreover,
   some of the data types are different. For example,
   <productname>PostgreSQL's</productname> datetime and interval types do not
   know about ranges like for example <literal>YEAR TO MINUTE</> so you won't
   find support in ECPG for that either.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>Informix</productname>兼容性模式与 ECPG 的 pgtypeslib 库紧密连接。pgtypeslib 把 SQL 数据类型映射到 C 主程序中的数据类型并且大部分<productname>Informix</productname>兼容性模式的附加函数允许我们在那些 C 主程序类型上操作。不过注意兼容性的范围被有所限制。它并不是想尝试复制<productname>Informix</productname>的行为。它允许你做或多或少的相同操作并且给你具有相同名称和相同基本行为的函数，但是此刻如果你使用<productname>Informix</productname>，其中并没有唾手可得的替代品。此外，一些数据类型也不同。例如，<productname>PostgreSQL</productname>的日期时间和区间类型不理解范围（例如<literal>YEAR TO MINUTE</>），因此你也无法在 ECPG 中找到支持。
  </para>

  <sect2 id="ecpg-informix-types">
<!--==========================orignal english content==========================
   <title>Additional Types</title>
____________________________________________________________________________-->
   <title>附加类型</title>
<!--==========================orignal english content==========================
   <para>
    The Informix-special "string" pseudo-type for storing right-trimmed character string data is now
    supported in Informix-mode without using <literal>typedef</literal>. In fact, in Informix-mode,
    ECPG refuses to process source files that contain <literal>typedef sometype string;</literal>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* this variable will contain trimmed data */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    用于存储右切边字符串数据的 Informix-特殊的 "string" 伪类型现在在 Informix 模式中不用<literal>typedef</literal>就能支持。事实上，在 Informix 模式中，ECPG 拒绝处理包含<literal>typedef sometype string;</literal>的源文件。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* 这个变量将包含切边过的数据 */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-statements">
<!--==========================orignal english content==========================
   <title>Additional/Missing Embedded SQL Statements</title>
____________________________________________________________________________-->
   <title>附加的/缺少的 嵌入式 SQL 语句</title>
<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</></term>
      <listitem>
       <para>
        This statement closes the current connection. In fact, this is a
        synonym for ECPG's <literal>DISCONNECT CURRENT</>:
<programlisting>
$CLOSE DATABASE;                /* close the current connection */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</></term>
      <listitem>
       <para>
        Due to the differences how ECPG works compared to Informix's ESQL/C (i.e. which steps
        are purely grammar transformations and which steps rely on the underlying run-time library)
        there is no <literal>FREE cursor_name</> statement in ECPG. This is because in ECPG,
        <literal>DECLARE CURSOR</literal> doesn't translate to a function call into
        the run-time library that uses to the cursor name. This means that there's no run-time
        bookkeeping of SQL cursors in the ECPG run-time library, only in the PostgreSQL server.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</></term>
      <listitem>
       <para>
        <literal>FREE statement_name</> is a synonym for <literal>DEALLOCATE PREPARE statement_name</>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</></term>
      <listitem>
       <para>
        这个语句关闭当前连接。事实上，这是 ECPG 的<literal>DISCONNECT CURRENT</>语句的同义词：
<programlisting>
$CLOSE DATABASE;                /* 关闭当前连接 */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</></term>
      <listitem>
       <para>
        由于 ECPG 和 Informix ESQL/C 在工作方式上的区别（一个是纯语法转换而另一个依赖于底层的运行时库），在 ECPG 中没有<literal>FREE cursor_name</>语句。这是因为在 ECPG 中，<literal>DECLARE CURSOR</literal>不会翻译成一个运行时库中使用游标名的函数调用。这意味着在 ECPG 运行时库中不会有 SQL 游标的运行时登记，SQL 游标只登记在 PostgreSQL 服务器中。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</></term>
      <listitem>
       <para>
        <literal>FREE statement_name</>是<literal>DEALLOCATE PREPARE statement_name</>的同义词。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
<!--==========================orignal english content==========================
   <title>Informix-compatible SQLDA Descriptor Areas</title>
____________________________________________________________________________-->
   <title>Informix-兼容的 SQLDA 描述符区域</title>
<!--==========================orignal english content==========================
   <para>
    Informix-compatible mode supports a different structure than the one described in
    <xref linkend="ecpg-sqlda-descriptors">. See below:
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    Informix-兼容模式支持一种与中所述不同的结构。如下：
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The global properties are:
    <variablelist>

     <varlistentry>
     <term><literal>sqld</></term>
      <listitem>
       <para>
        The number of fields in the <literal>SQLDA</> descriptor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</></term>
      <listitem>
       <para>
        Pointer to the per-field properties.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</></term>
      <listitem>
       <para>
        Unused, filled with zero-bytes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</></term>
      <listitem>
       <para>
        Size of the allocated structure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</></term>
      <listitem>
       <para>
        Pointer to the next SQLDA structure if the result set contains more than one record.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</></term>
      <listitem>
       <para>
        Unused pointer, contains NULL. Kept for Informix-compatibility.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    The per-field properties are below, they are stored in the <literal>sqlvar</literal> array:

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</></term>
      <listitem>
       <para>
        Type of the field. Constants are in <literal>sqltypes.h</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</></term>
      <listitem>
       <para>
        Length of the field data.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</></term>
      <listitem>
       <para>
        Pointer to the field data. The pointer is of <literal>char *</literal> type,
        the data pointed by it is in a binary format. Example:
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</></term>
      <listitem>
       <para>
        Pointer to the NULL indicator. If returned by DESCRIBE or FETCH then it's always a valid pointer.
        If used as input for <literal>EXECUTE ... USING sqlda;</literal> then NULL-pointer value means
        that the value for this field is non-NULL. Otherwise a valid pointer and <literal>sqlitype</literal>
        has to be properly set. Example:
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</></term>
      <listitem>
       <para>
        Name of the field. 0-terminated string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</></term>
      <listitem>
       <para>
        Reserved in Informix, value of <function>PQfformat()</> for the field.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</></term>
      <listitem>
       <para>
        Type of the NULL indicator data. It's always SQLSMINT when returning data from the server.
        When the <literal>SQLDA</literal> is used for a parameterized query, the data is treated
        according to the set type.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</></term>
      <listitem>
       <para>
        Length of the NULL indicator data.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</></term>
      <listitem>
       <para>
        Extended type of the field, result of <function>PQftype()</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</></term>
     <term><literal>sqltypelen</></term>
     <term><literal>sqlownerlen</></term>
     <term><literal>sqlsourcetype</></term>
     <term><literal>sqlownername</></term>
     <term><literal>sqlsourceid</></term>
     <term><literal>sqlflags</></term>
     <term><literal>sqlreserved</></term>
      <listitem>
       <para>
        Unused.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</></term>
      <listitem>
       <para>
        It equals to <literal>sqldata</literal> if <literal>sqllen</literal> is larger than 32kB.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    Example:
<programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* This doesn't need to be under embedded DECLARE SECTION */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* The main structure is all to be free(),
                  * sqlda and sqlda-&gt;sqlvar is in one allocated area */
</programlisting>
    For more information, see the <literal>sqlda.h</> header and the
    <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal> regression test.
   </para>
____________________________________________________________________________-->
   <para>
    全局属性是：
    <variablelist>

     <varlistentry>
     <term><literal>sqld</></term>
      <listitem>
       <para>
        <literal>SQLDA</>描述符中域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</></term>
      <listitem>
       <para>
        每一个域属性的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</></term>
      <listitem>
       <para>
        未使用，用零字节填充。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</></term>
      <listitem>
       <para>
        已分配结构的尺寸。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</></term>
      <listitem>
       <para>
        如果结果集包含多于一个记录，这个域是下一个 SQLDA 结构的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</></term>
      <listitem>
       <para>
        未使用的指针，包含 NULL。为 Informix-兼容性而保留。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    对每一个域的属性如下，它们被存储在<literal>sqlvar</literal>数组中：

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</></term>
      <listitem>
       <para>
        域的类型。可以使用的常量定义在<literal>sqltypes.h</literal>中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</></term>
      <listitem>
       <para>
        域数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</></term>
      <listitem>
       <para>
        域数据的指针。该指针是<literal>char *</literal>类型，它所指向的数据是二进制个事。例子：
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</></term>
      <listitem>
       <para>
        NULL 指示符的指针。如果是由 DESCRIBE 或 FETCH 返回，那么它总是一个有效的指针。如果被用作<literal>EXECUTE ... USING sqlda;</literal>的输入，那么 NULL-指针值意味着这个域的值是非-NULL 的。否则必须正确地设置一个有效的指针和<literal>sqlitype</literal>。例子：
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</></term>
      <listitem>
       <para>
        域的名称。以 0 终止的字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</></term>
      <listitem>
       <para>
        在 Informix 中保留，是该域的<function>PQfformat()</>的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</></term>
      <listitem>
       <para>
        NULL 指示符数据的类型。当从服务器返回数据时，它总是 SQLSMINT。当<literal>SQLDA</literal>被用于一个参数化查询时，数据要根据设置的类型对待。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</></term>
      <listitem>
       <para>
        NULL 指示符数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</></term>
      <listitem>
       <para>
        该域的扩展类型，<function>PQftype()</>的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</></term>
     <term><literal>sqltypelen</></term>
     <term><literal>sqlownerlen</></term>
     <term><literal>sqlsourcetype</></term>
     <term><literal>sqlownername</></term>
     <term><literal>sqlsourceid</></term>
     <term><literal>sqlflags</></term>
     <term><literal>sqlreserved</></term>
      <listitem>
       <para>
        未使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</></term>
      <listitem>
       <para>
        如果<literal>sqllen</literal>大于 32kB，它等于<literal>sqldata</literal>。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    例子：
<programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* 这不需要在嵌入式 DECLARE SECTION 下 */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* 主结构完全被 free()，sqlda 和 sqlda-&gt;sqlvar 在一个已分配区域中 */
</programlisting>
    更多信息可见<literal>sqlda.h</>头部和<literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>回归测试。
   </para>
  </sect2>

  <sect2 id="ecpg-informix-functions">
<!--==========================orignal english content==========================
   <title>Additional Functions</title>
____________________________________________________________________________-->
   <title>附加函数</title>
<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</></term>
      <listitem>
       <para>
        Add two decimal type values.
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        The function receives a pointer to the first operand of type decimal
        (<literal>arg1</>), a pointer to the second operand of type decimal
        (<literal>arg2</>) and a pointer to a value of type decimal that will
        contain the sum (<literal>sum</>). On success, the function returns 0.
        <symbol>ECPG_INFORMIX_NUM_OVERFLOW</> is returned in case of overflow and
        <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</> in case of underflow. -1 is returned for
        other failures and <varname>errno</> is set to the respective <varname>errno</> number of the
        pgtypeslib.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</></term>
      <listitem>
       <para>
        Compare two variables of type decimal.
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        The function receives a pointer to the first decimal value
        (<literal>arg1</>), a pointer to the second decimal value
        (<literal>arg2</>) and returns an integer value that indicates which is
        the bigger value.
        <itemizedlist>
         <listitem>
          <para>
           1, if the value that <literal>arg1</> points to is bigger than the
           value that <literal>var2</> points to
          </para>
         </listitem>
         <listitem>
          <para>
           -1, if the value that <literal>arg1</> points to is smaller than the
           value that <literal>arg2</> points to </para>
         </listitem>
         <listitem>
          <para>
           0, if the value that <literal>arg1</> points to and the value that
           <literal>arg2</> points to are equal
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</></term>
      <listitem>
       <para>
        Copy a decimal value.
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        The function receives a pointer to the decimal value that should be
        copied as the first argument (<literal>src</>) and a pointer to the
        target structure of type decimal (<literal>target</>) as the second
        argument.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</></term>
      <listitem>
       <para>
        Convert a value from its ASCII representation into a decimal type.
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
        The function receives a pointer to string that contains the string
        representation of the number to be converted (<literal>cp</>) as well
        as its length <literal>len</>. <literal>np</> is a pointer to the
        decimal value that saves the result of the operation.
       </para>
       <para>
        Valid formats are for example:
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal> or
         <literal>-32.84e-4</literal>.
       </para>
       <para>
        The function returns 0 on success. If overflow or underflow occurred,
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> is returned. If the ASCII
        representation could not be parsed,
        <literal>ECPG_INFORMIX_BAD_NUMERIC</> is returned or
        <literal>ECPG_INFORMIX_BAD_EXPONENT</> if this problem occurred while
        parsing the exponent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</></term>
      <listitem>
       <para>
        Convert a value of type double to a value of type decimal.
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        The function receives the variable of type double that should be
        converted as its first argument (<literal>dbl</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</></term>
      <listitem>
       <para>
        Convert a value of type int to a value of type decimal.
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        The function receives the variable of type int that should be
        converted as its first argument (<literal>in</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</></term>
      <listitem>
       <para>
        Convert a value of type long to a value of type decimal.
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        The function receives the variable of type long that should be
        converted as its first argument (<literal>lng</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</></term>
      <listitem>
       <para>
        Divide two variables of type decimal.
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>/<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
       </para>
       <para>
        On success, 0 is returned and a negative value if the division fails.
        If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively. If an attempt to
        divide by zero is observed, the function returns
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</></term>
      <listitem>
       <para>
        Multiply two decimal values.
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>*<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
       </para>
       <para>
        On success, 0 is returned and a negative value if the multiplication
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</></term>
      <listitem>
       <para>
        Subtract one decimal value from another.
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>-<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
       </para>
       <para>
        On success, 0 is returned and a negative value if the subtraction
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</></term>
      <listitem>
       <para>
        Convert a variable of type decimal to its ASCII representation in a C
        char* string.
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        The function receives a pointer to a variable of type decimal
        (<literal>np</>) that it converts to its textual representation.
        <literal>cp</> is the buffer that should hold the result of the
        operation. The parameter <literal>right</> specifies, how many digits
        right of the decimal point should be included in the output. The result
        will be rounded to this number of decimal digits. Setting
        <literal>right</> to -1 indicates that all available decimal digits
        should be included in the output. If the length of the output buffer,
        which is indicated by <literal>len</> is not sufficient to hold the
        textual representation including the trailing zero byte, only a
        single <literal>*</> character is stored in the result and -1 is
        returned.
       </para>
       <para>
        The function returns either -1 if the buffer <literal>cp</> was too
        small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</> if memory was
        exhausted.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</></term>
      <listitem>
       <para>
        Convert a variable of type decimal to a double.
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the double variable that
        should hold the result of the operation (<literal>dblp</>).
       </para>
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</></term>
      <listitem>
       <para>
        Convert a variable to type decimal to an integer.
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the integer variable that
        should hold the result of the operation (<literal>ip</>).
       </para>
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
       </para>
       <para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits an integer to the range from -32767 to
        32767, while the limits in the ECPG implementation depend on the
        architecture (<literal>-INT_MAX .. INT_MAX</>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</></term>
      <listitem>
       <para>
        Convert a variable to type decimal to a long integer.
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the long variable that
        should hold the result of the operation (<literal>lngp</>).
       </para>
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
       </para>
       <para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits a long integer to the range from
        -2,147,483,647 to 2,147,483,647, while the limits in the ECPG
        implementation depend on the architecture (<literal>-LONG_MAX ..
        LONG_MAX</>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</></term>
      <listitem>
       <para>
        Converts a date to a C char* string.
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        The function receives two arguments, the first one is the date to
        convert (<literal>d</>) and the second one is a pointer to the target
        string. The output format is always <literal>yyyy-mm-dd</>, so you need
        to allocate at least 11 bytes (including the zero-byte terminator) for the
        string.
       </para>
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
       <para>
        Note that ECPG's implementation differs from the <productname>Informix</productname>
        implementation. In <productname>Informix</productname> the format can be influenced by setting
        environment variables. In ECPG however, you cannot change the output
        format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</></term>
      <listitem>
       <para>
        Parse the textual representation of a date.
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
        The function receives the textual representation of the date to convert
        (<literal>str</>) and a pointer to a variable of type date
        (<literal>d</>). This function does not allow you to specify a format
        mask. It uses the default format mask of <productname>Informix</productname> which is
        <literal>mm/dd/yyyy</>. Internally, this function is implemented by
        means of <function>rdefmtdate</>. Therefore, <function>rstrdate</> is
        not faster and if you have the choice you should opt for
        <function>rdefmtdate</> which allows you to specify the format mask
        explicitly.
       </para>
       <para>
        The function returns the same values as <function>rdefmtdate</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</></term>
      <listitem>
       <para>
        Get the current date.
<synopsis>
void rtoday(date *d);
</synopsis>
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
       </para>
       <para>
        Internally this function uses the <xref linkend="PGTYPESdatetoday">
        function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</></term>
      <listitem>
       <para>
        Extract the values for the day, the month and the year from a variable
        of type date.
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        The function receives the date <literal>d</> and a pointer to an array
        of 3 short integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
       </para>
       <para>
        The function always returns 0 at the moment.
       </para>
       <para>
        Internally the function uses the <xref linkend="PGTYPESdatejulmdy">
        function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</></term>
      <listitem>
       <para>
        Use a format mask to convert a character string to a value of type
        date.
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
       </para>
       <para>
        The function returns the following values:
        <itemizedlist>
         <listitem>
          <para>
           0 - The function terminated successfully.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</> - The date does not contain
           delimiters between day, month and year. In this case the input
           string must be exactly 6 or 8 bytes long but isn't.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOTDMY</> - The format string did not
           correctly indicate the sequential order of year, month and day.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_DAY</> - The input string does not
           contain a valid day.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_MONTH</> - The input string does not
           contain a valid month.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_YEAR</> - The input string does not
           contain a valid year.
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        Internally this function is implemented to use the <xref
        linkend="PGTYPESdatedefmtasc"> function. See the reference there for a
        table of example input.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</></term>
      <listitem>
       <para>
        Convert a variable of type date to its textual representation using a
        format mask.
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        The function receives the date to convert (<literal>d</>), the format
        mask (<literal>fmt</>) and the string that will hold the textual
        representation of the date (<literal>str</>).
       </para>
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
       <para>
        Internally this function uses the <xref linkend="PGTYPESdatefmtasc">
        function, see the reference there for examples.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</></term>
      <listitem>
       <para>
        Create a date value from an array of 3 short integers that specify the
        day, the month and the year of the date.
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        The function receives the array of the 3 short integers
        (<literal>mdy</>) and a pointer to a variable of type date that should
        hold the result of the operation.
       </para>
       <para>
        Currently the function returns always 0.
       </para>
       <para>
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatemdyjul">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</></term>
      <listitem>
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int rdayofweek(date d);
</synopsis>
        The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
        <itemizedlist>
         <listitem>
          <para>
           0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
           1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
           2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
           3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
           4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
           5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
           6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatedayofweek">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</></term>
      <listitem>
       <para>
        Retrieve the current timestamp.
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</></term>
      <listitem>
       <para>
        Parses a timestamp from its textual representation
        into a timestamp variable.
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        The function receives the string to parse (<literal>str</>) and a
        pointer to the timestamp variable that should hold the result of the
        operation (<literal>ts</>).
       </para>
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
       <para>
        Internally this function uses the <xref
        linkend="PGTYPEStimestampfromasc"> function. See the reference there
        for a table with example inputs.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</></term>
      <listitem>
       <para>
        Parses a timestamp from its textual representation
        using a format mask into a timestamp variable.
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        The function receives the string to parse (<literal>inbuf</>), the
        format mask to use (<literal>fmtstr</>) and a pointer to the timestamp
        variable that should hold the result of the operation
        (<literal>dtvalue</>).
       </para>
       <para>
        This function is implemented by means of the <xref
        linkend="PGTYPEStimestampdefmtasc"> function. See the documentation
        there for a list of format specifiers that can be used.
       </para>
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</></term>
      <listitem>
       <para>
        Subtract one timestamp from another and return a variable of type
        interval.
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* string.
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        The function receives a pointer to the timestamp variable to convert
        (<literal>ts</>) and the string that should hold the result of the
        operation (<literal>output</>). It converts <literal>ts</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
       <para>
        Internally, this function uses the <xref
        linkend="PGTYPEStimestampfmtasc"> function. See the reference there for
        information on what format mask specifiers can be used.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</></term>
      <listitem>
       <para>
        Convert an interval variable to a C char* string.
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        The function receives a pointer to the interval variable to convert
        (<literal>i</>) and the string that should hold the result of the
        operation (<literal>str</>). It converts <literal>i</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</></term>
      <listitem>
       <para>
        Convert a long integer value to its textual representation using a
        format mask.
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
        The function receives the long value <literal>lng_val</>, the format
        mask <literal>fmt</> and a pointer to the output buffer
        <literal>outbuf</>. It converts the long value according to the format
        mask to its textual representation.
       </para>
       <para>
        The format mask can be composed of the following format specifying
        characters:
        <itemizedlist>
         <listitem>
          <para>
           <literal>*</literal> (asterisk) - if this position would be blank
           otherwise, fill it with an asterisk.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&amp;</literal> (ampersand) - if this position would be
           blank otherwise, fill it with a zero.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>#</literal> - turn leading zeroes into blanks.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&lt;</literal> - left-justify the number in the string.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>,</literal> (comma) - group numbers of four or more digits
           into groups of three digits separated by a comma.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>.</literal> (period) - this character separates the
           whole-number part of the number from the fractional part.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>-</literal> (minus) - the minus sign appears if the number
           is a negative value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>+</literal> (plus) - the plus sign appears if the number is
           a positive value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>(</literal> - this replaces the minus sign in front of the
           negative number. The minus sign will not appear.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>)</literal> - this character replaces the minus and is
           printed behind the negative value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>$</literal> - the currency symbol.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</></term>
      <listitem>
       <para>
        Convert a string to upper case.
<synopsis>
void rupshift(char *str);
</synopsis>
        The function receives a pointer to the string and transforms every
        lower case character to upper case.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</></term>
      <listitem>
       <para>
        Return the number of characters in a string without counting trailing
        blanks.
<synopsis>
int byleng(char *str, int len);
</synopsis>
        The function expects a fixed-length string as its first argument
        (<literal>str</>) and its length as its second argument
        (<literal>len</>). It returns the number of significant characters,
        that is the length of the string without trailing blanks.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</></term>
      <listitem>
       <para>
        Copy a fixed-length string into a null-terminated string.
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        The function receives the fixed-length string to copy
        (<literal>src</>), its length (<literal>len</>) and a pointer to the
        destination memory (<literal>dest</>). Note that you need to reserve at
        least <literal>len+1</> bytes for the string that <literal>dest</>
        points to. The function copies at most <literal>len</> bytes to the new
        location (less if the source string has trailing blanks) and adds the
        null-terminator.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</></term>
      <listitem>
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</></term>
      <listitem>
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</></term>
      <listitem>
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</></term>
      <listitem>
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</></term>
      <listitem>
       <para>
        Set a variable to NULL.
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        The function receives an integer that indicates the type of the
        variable and a pointer to the variable itself that is cast to a C
        char* pointer.
       </para>
       <para>
        The following types exist:
        <itemizedlist>
         <listitem>
          <para>
           <literal>CCHARTYPE</literal> - For a variable of type <type>char</type> or <type>char*</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CSHORTTYPE</literal> - For a variable of type <type>short int</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CINTTYPE</literal> - For a variable of type <type>int</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CBOOLTYPE</literal> - For a variable of type <type>boolean</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CFLOATTYPE</literal> - For a variable of type <type>float</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CLONGTYPE</literal> - For a variable of type <type>long</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDOUBLETYPE</literal> - For a variable of type <type>double</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDECIMALTYPE</literal> - For a variable of type <type>decimal</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDATETYPE</literal> - For a variable of type <type>date</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDTIMETYPE</literal> - For a variable of type <type>timestamp</type>
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
        Here is an example of a call to this function:
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</></term>
      <listitem>
       <para>
        Test if a variable is NULL.
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        The function receives the type of the variable to test (<literal>t</>)
        as well a pointer to this variable (<literal>ptr</>). Note that the
        latter needs to be cast to a char*. See the function <xref
        linkend="rsetnull"> for a list of possible variable types.
       </para>
       <para>
        Here is an example of how to use this function:
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</></term>
      <listitem>
       <para>
        将两个decimal类型值相加。
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        该函数接收第一个类型为 decimal 的操作数的指针（<literal>arg1</>）、第二个类型为 decimal 的操作数的指针（<literal>arg2</>）以及将包含和的 decimal 值的指针（<literal>sum</>）。成功时该函数返回 0。溢出时返回<symbol>ECPG_INFORMIX_NUM_OVERFLOW</>，下溢时返回<symbol>ECPG_INFORMIX_NUM_UNDERFLOW</>。其他失败会返回 -1 并且<varname>errno</>会被设置为相应的 pgtypeslib 中的<varname>errno</>编号。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</></term>
      <listitem>
       <para>
        比较两个 decimal 变量。
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        该函数接收第一个 decimal 值的指针（<literal>arg1</>）、第二个 decimal 值的指针（<literal>arg2</>）并且返回一个整数值说明哪一个值更大。
        <itemizedlist>
         <listitem>
          <para>
           1，如果<literal>arg1</>指向的值大于<literal>var2</>指向的值
          </para>
         </listitem>
         <listitem>
          <para>
           -1，如果<literal>arg1</>指向的值小于<literal>var2</>指向的值</para>
         </listitem>
         <listitem>
          <para>
           0，如果<literal>arg1</>指向的值与<literal>arg2</>指向的值相等
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</></term>
      <listitem>
       <para>
        拷贝一个 decimal 值。
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        该函数接收要拷贝的 decimal 值的指针作为第一个参数（<literal>src</>）以及一个类型为 decimal 的目标结构的指针作为第二个参数（<literal>target</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</></term>
      <listitem>
       <para>
        把一个值从 ASCII 表达转换成一个 decimal 类型。
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
        该函数接收一个包含要转换的数字的字符串表达的字符串指针（<literal>cp</>）及其长度（<literal>len</>）。<literal>np</>是一个用来保存操作结果的 decimal 值的指针。
       </para>
       <para>
        例如，可用的格式有：
         <literal>-2</literal>、
         <literal>.794</literal>、
         <literal>+3.44</literal>、
         <literal>592.49E07</literal>或者
         <literal>-32.84e-4</literal>。
       </para>
       <para>
        成功时该函数返回 0。如果发生溢出或者下溢，分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。如果 ASCII 表达无法被解析，将返回<literal>ECPG_INFORMIX_BAD_NUMERIC</>。如果解析指数时发生问题则返回<literal>ECPG_INFORMIX_BAD_EXPONENT</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</></term>
      <listitem>
       <para>
        将一个 double 值转换成一个 decimal 值。
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        该函数接收要被转换的 double 变量作为第一个参数（<literal>dbl</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</></term>
      <listitem>
       <para>
        将一个 int 值转换成 decimal 值。
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        该函数接收要被转换的 int 变量作为第一个参数（<literal>in</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</></term>
      <listitem>
       <para>
        将一个 long 值转换成 decimal 值。
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        该函数接收要被转换的 long 变量作为第一个参数（<literal>lng</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</></term>
      <listitem>
       <para>
        用两个 decimal 类型的变量做除法。
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>/<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果除法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。如果发现一次除零尝试，该函数返回
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</></term>
      <listitem>
       <para>
        将两个 decimal 值相乘。
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>*<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果乘法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</></term>
      <listitem>
       <para>
        从一个 decimal 值中减去另一个。
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>

        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>-<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果减法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</></term>
      <listitem>
       <para>
        将一个 decimal 变量转换成它的 ASCII 表达放在一个 C char* 字符串中。
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        该函数接收一个要被转换成文本表达的 decimal 类型变量的指针（<literal>np</>）。<literal>cp</>是应保存操作结果的缓冲区。参数<literal>right</>指定小数点右边应该有多少位保留在输出中。结果将被圆整到所指定数量的十进制位。将<literal>right</>设置为 -1 表示输出中应该包括所有可用的十进制位。如果输出缓冲区的长度（由<literal>len</>指定）不足以保存包含拖尾零字节的文本表达，结果中将只保存一个单一的<literal>*</>字符并且返回 -1。
       </para>
       <para>
        如果缓冲区<literal>cp</>太小该函数返回 -1；如果内存耗尽，则返回<literal>ECPG_INFORMIX_OUT_OF_MEMORY</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个 double 类型变量。
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的 double 变量的指针（<literal>dblp</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个整数类型变量。
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的整数变量的指针（<literal>ip</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。如果发生溢出，会返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。<productname>Informix</productname>限制一个整数的范围是从 -32767 到 32767，而 ECPG 实现中的限制取决于架构（<literal>-INT_MAX .. INT_MAX</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个长整型变量。
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的长整型变量的指针（<literal>lngp</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。如果发生溢出，会返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。<productname>Informix</productname>限制一个整数的范围是从 -2,147,483,647 到 2,147,483,647，而 ECPG 实现中的限制取决于架构（<literal>-LONG_MAX .. LONG_MAX</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</></term>
      <listitem>
       <para>
        将一个日期转换成一个 C char* 字符串。
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        该函数接收两个参数，第一个是要转换的日期（<literal>d</>），第二个是目标字符串的指针。输出格式总是<literal>yyyy-mm-dd</>，因此你需要为该字符串分配至少 11 个字节（包括零字节终止符）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。在<productname>Informix</productname>中，该格式可能受到环境变量设置的影响。而在 ECPG 中，你不能改变输出格式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</></term>
      <listitem>
       <para>
        解析一个日期的文本表达。
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
        该函数接收要转换的日期的文本表达（<literal>str</>）以及一个日期类型变量的指针（<literal>d</>）。这个函数不允许你指定一个格式掩码。它使用<productname>Informix</productname>的默认格式掩码<literal>mm/dd/yyyy</>。在内部，这个函数用<function>rdefmtdate</>的方式实现。因此，<function>rstrdate</>不会更快，并且如果可以选择，你应该选用允许你显式指定格式掩码的<function>rdefmtdate</>。
       </para>
       <para>
        该返回与<function>rdefmtdate</>相同的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</></term>
      <listitem>
       <para>
        得到当前日期。
<synopsis>
void rtoday(date *d);
</synopsis>
        该函数接收一个日期变量的指针（<literal>d</>），它会把该变量设置为当前日期。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPESdatetoday">函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</></term>
      <listitem>
       <para>
        从一个日期类型变量中抽取日、月、年的值。
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        该函数接收日期<literal>d</>和由 3 个短整型值构成的数组的指针<literal>mdy</>。该变量名指定了顺序：<literal>mdy[0]</>将被设置为包含月的编号，<literal>mdy[1]</>将被设置为日的值，而<literal>mdy[2]</>将包含年。
       </para>
       <para>
        当前该函数总是返回 0。
       </para>
       <para>
        在内部该函数使用<xref linkend="PGTYPESdatejulmdy">函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</></term>
      <listitem>
       <para>
        使用一个格式掩码把一个字符串转换成一个日期类型的值。
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        该函数接收一个用于保存操作结果的日期值的指针（<literal>d</>）、要用来解析日期的格式掩码（<literal>fmt</>）以及包含日期文本表达的 C char* 字符串（<literal>str</>）。该文本表达应该匹配格式掩码。不过，你不需要具有从该字符串到格式掩码的 一一映射。该函数将分析顺序并且寻找表示年的位置的文字<literal>yy</literal>或<literal>yyyy</literal>、表示月的位置的<literal>mm</literal>以及表示日的位置的<literal>dd</literal>。
       </para>
       <para>
        该函数返回下列值：
        <itemizedlist>
         <listitem>
          <para>
           0 - 该函数成功终止。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</> - 该日期不包含日、月、年之间的定界符。在这种情况下，输入字符串必须是正好 6 个或 8 个字节，但实际上却不是。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOTDMY</> - 格式字符串没有正确地指示年、月、日的顺序。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_DAY</> - 输入字符串不含一个合法的日。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_MONTH</> - 输入字符串不含一个合法的月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_YEAR</> - 输入字符串不含一个合法的年。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        在内部这个函数被实现为使用<xref linkend="PGTYPESdatedefmtasc">函数。示例输入表可以在那里找到。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</></term>
      <listitem>
       <para>
        使用一个格式掩码将一个日期类型变量转换成它的文本表达。
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        该函数接收要转换的日期（<literal>d</>）、格式掩码（<literal>fmt</>）以及将保存日期的文本表达的字符串（<literal>str</>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPESdatefmtasc">函数，例子请参考该函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</></term>
      <listitem>
       <para>
        从由 3 个短整型组成的数组创建一个日期值，它指定了该日期的日、月、年。
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        该函数接收一个由 3 个短整型构成的数组（<literal>mdy</>）以及一个用来保存操作结构的日期类型变量的指针。
       </para>
       <para>
        当前该函数总是返回 0。
       </para>
       <para>
        在内部这个函数被实现为使用<xref linkend="PGTYPESdatemdyjul">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</></term>
      <listitem>
       <para>
        为一个日期值返回一个表示它是星期几的数字。
<synopsis>
int rdayofweek(date d);
</synopsis>
        该函数接收日期变量<literal>d</>作为它的唯一参数并且返回一个整数指示这一天是星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 周日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 周一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 周二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 周三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 周四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 周五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 周六
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        在内部这个函数被实现为使用函数<xref linkend="PGTYPESdatedayofweek">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</></term>
      <listitem>
       <para>
        检索当前的时间戳。
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        该函数检索当前时间戳并且把它保存在<literal>ts</>指向的时间戳变量中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</></term>
      <listitem>
       <para>
        把一个时间戳从它的文本表达解析到一个时间戳变量中。
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        该函数接收要解析的字符串（<literal>str</>）以及一个指向保存操作结果的时间戳变量的指针（<literal>ts</>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPEStimestampfromasc">函数。一个输入示例的表格可以参考该函数的文档。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</></term>
      <listitem>
       <para>
        使用一个格式掩码把一个时间戳从它的文本表达解析到一个时间戳变量中。
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        该函数接收要解析的字符串（<literal>inbuf</>）、要使用的格式掩码（<literal>fmtstr</>）以及一个指向保存操作结果的时间戳变量的指针（<literal>dtvalue</>）。
       </para>
       <para>
        这个函数通过<xref linkend="PGTYPEStimestampdefmtasc">函数实现。可以使用的格式说明符的列表可以参考该函数的文档。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</></term>
      <listitem>
       <para>
        从一个时间戳中减去另一个并且返回一个区间类型变量。
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从<literal>ts1</>指向的时间戳变量中减去<literal>ts2</>指向的时间戳变量，并且将把结果存储在<literal>iv</>指向的区间变量中。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</></term>
      <listitem>
       <para>
        将一个时间戳变量转换成一个 C char* 字符串。
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        该函数接收一个要转换的时间戳变量的指针（<literal>ts</>）以及用于保存操作结果的字符串（<literal>output</>）。它根据 SQL 标准把<literal>ts</>转换成它的文本表达，形式为<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</></term>
      <listitem>
       <para>
        使用一个格式掩码将一个时间戳变量转换成一个 C char*。
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个要转换的时间戳的指针（<literal>ts</>）、一个输出缓冲区的指针（<literal>output</>）、已经为输出缓冲区分配的最大长度（<literal>str_len</literal>）以及用于转换的格式掩码（<literal>fmtstr</literal>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部，这个函数使用<xref linkend="PGTYPEStimestampfmtasc">函数。可以使用的格式说明符的列表可以参考该函数的文档。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</></term>
      <listitem>
       <para>
        将一个区间变量转换成一个 C char* 字符串。
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        该函数接收一个要转换的区间变量的指针（<literal>i</>）以及要保持该操作结果的字符串（<literal>str</>）。它根据 SQL 标准把<literal>i</>转换成它的文本表达，形式为<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</></term>
      <listitem>
       <para>
        用一个格式掩码将一个长整型值转换成它的文本表达。
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
        该函数接收长整型值<literal>lng_val</>、格式掩码<literal>fmt</>以及输出缓冲区的指针<literal>outbuf</>。它根据格式掩码将长整型值转换成文本表达。
       </para>
       <para>
        格式掩码可以由下列格式说明字符构成：
        <itemizedlist>
         <listitem>
          <para>
           <literal>*</literal> （星） - 如果这个位置可以为空白，否则用一个星号填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&amp;</literal> （花号） -如果这个位置可以为空白，否则用一个零填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>#</literal> - 把前导零转变成空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&lt;</literal> - 左对齐字符串中的数字。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>,</literal> （逗号） - 将有四个或者更多数位的数字份组成用逗号分隔的 3 数位组。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>.</literal> （点） - 这个字符分隔数字的整数部分和小数部分。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>-</literal> （负） - 如果该数字是一个负值则负号会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>+</literal> （加） - 如果该数字是一个正值则加号会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>(</literal> - 这会替换负数前面的负号。负号将不会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>)</literal> - 这个字符替换负号并且被打印在负值的后面。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>$</literal> - 货币符号。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</></term>
      <listitem>
       <para>
        把一个字符串转换成大写形式。
<synopsis>
void rupshift(char *str);
</synopsis>
        该函数接收一个字符串的指针并且把每一个小写形式的字符变成大写形式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</></term>
      <listitem>
       <para>
        返回一个字符串的字符数，其中不含拖尾的空白。
<synopsis>
int byleng(char *str, int len);
</synopsis>
        该函数期待一个定长字符串作为它的第一个参数（<literal>str</>）并且把它的长度作为第二个参数（<literal>len</>）。该函数会返回有效字符的数量，也就是字符串不含拖尾空白的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</></term>
      <listitem>
       <para>
        复制一个定长字符串到一个空终止的字符串。
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        该函数接收要被复制的定长字符串（<literal>src</>）、它的长度（<literal>len</>）以及目标内存的指针（<literal>dest</>）。注意你需要为<literal>dest</>指向的字符串保留至少<literal>len+1</>个字节。该函数复制至多<literal>len</>个字节到新的位置（如果源字符串有拖尾的空格）并且增加空终止符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</></term>
      <listitem>
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</></term>
      <listitem>
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</></term>
      <listitem>
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</></term>
      <listitem>
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</></term>
      <listitem>
       <para>
        设置一个变量为 NULL。
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        该函数接收一个表示变量类型的整数以及一个被造型成 C char* 指针的变量本身的指针。
       </para>
       <para>
        存在下列类型：
        <itemizedlist>
         <listitem>
          <para>
           <literal>CCHARTYPE</literal> - 用于类型<type>char</type>或者<type>char*</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CSHORTTYPE</literal> - 用于类型<type>short int</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CINTTYPE</literal> - 用于类型<type>int</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CBOOLTYPE</literal> - 用于类型<type>boolean</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CFLOATTYPE</literal> - 用于类型<type>float</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CLONGTYPE</literal> - 用于类型<type>long</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDOUBLETYPE</literal> - 用于类型<type>double</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDECIMALTYPE</literal> - 用于类型<type>decimal</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDATETYPE</literal> - 用于类型<type>date</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDTIMETYPE</literal> - 用于类型<type>timestamp</type>的一个变量
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
        这里是一个调用这个函数的例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</></term>
      <listitem>
       <para>
        测试一个变量是否为 NULL。
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        该函数接收要测试的变量的类型（<literal>t</>）以及一个指向该变量的指针（<literal>ptr</>）。注意后者需要被造型为一个 char*。可能的变量类型请见函数<xref linkend="rsetnull">。
       </para>
       <para>
        这里是一个如何使用这个函数的例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
<!--==========================orignal english content==========================
   <title>Additional Constants</title>
____________________________________________________________________________-->
   <title>额外的常量</title>
<!--==========================orignal english content==========================
   <para>
    Note that all constants here describe errors and all of them are defined
    to represent negative values. In the descriptions of the different
    constants you can also find the value that the constants represent in the
    current implementation. However you should not rely on this number. You can
    however rely on the fact all of them are defined to represent negative
    values.
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</></term>
      <listitem>
       <para>
        Functions return this value if an overflow occurred in a
        calculation. Internally it is defined as -1200 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</></term>
      <listitem>
       <para>
        Functions return this value if an underflow occurred in a calculation.
        Internally it is defined as -1201 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</></term>
      <listitem>
       <para>
        Functions return this value if an attempt to divide by zero is
        observed. Internally it is defined as -1202 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a year was found while
        parsing a date. Internally it is defined as -1204 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a month was found while
        parsing a date. Internally it is defined as -1205 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a day was found while
        parsing a date. Internally it is defined as -1206 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine needs a short date
        representation but did not get the date string in the right length.
        Internally it is defined as -1209 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</></term>
      <listitem>
       <para>
        Functions return this value if an error occurred during date
        formatting.  Internally it is defined as -1210 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</></term>
      <listitem>
       <para>
        Functions return this value if memory was exhausted during
        their operation.  Internally it is defined as -1211 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine was supposed to get a
        format mask (like <literal>mmddyy</>) but not all fields were listed
        correctly. Internally it is defined as -1212 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</></term>
      <listitem>
       <para>
        Functions return this value either if a parsing routine cannot parse
        the textual representation for a numeric value because it contains
        errors or if a routine cannot complete a calculation involving numeric
        variables because at least one of the numeric variables is invalid.
        Internally it is defined as -1213 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine cannot parse
        an exponent.  Internally it is defined as -1216 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine cannot parse
        a date.  Internally it is defined as -1218 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine is passed extra
        characters it cannot parse.  Internally it is defined as -1264 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    注意这里所有的常量都描述错误并且它们都被定义为表示负值。在每一种不同常量的描述中，你还可以找到在当前实现中该常量表示的值。不过你不应该依赖于这个数字。但是你可以相信所有的这些常量都是被定义为表示负值。
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</></term>
      <listitem>
       <para>
        如果在一次计算中发生了溢出，函数会返回这个值。在内部它被定义为 -1200（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</></term>
      <listitem>
       <para>
        如果在一次计算中发生了下溢，函数会返回这个值。在内部它被定义为 -1201（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</></term>
      <listitem>
       <para>
       如果发现尝试除零，函数会返回这个值。在内部它被定义为 -1202（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</></term>
      <listitem>
       <para>
        如果在解析一个日期时为年找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1204（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</></term>
      <listitem>
       <para>
        如果在解析一个日期时为月找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1205（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</></term>
      <listitem>
       <para>
        如果在解析一个日期时为日找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1206（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</></term>
      <listitem>
       <para>
        如果一个解析例程需要一个短日期表示但是却没有得到正确长度的日期自如穿，函数会返回这个值。在内部它被定义为 -1209（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</></term>
      <listitem>
       <para>
        如果在日期格式化时产生了一个错误，函数会返回这个值。在内部它被定义为 -1210（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</></term>
      <listitem>
       <para>
        如果在操作时内存被耗尽，函数会返回这个值。在内部它被定义为 -1211（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</></term>
      <listitem>
       <para>
        如果一个解析例程被假定为得到一个格式掩码（如<literal>mmddyy</>）但是列出的域并不是全部正确，函数会返回这个值。在内部它被定义为 -1212（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</></term>
      <listitem>
       <para>
        如果一个解析例程因为一个numeric值的文本表达包含错误而不能解析它或者一个例程因为至少一个numeric变量非法而无法完成一次涉及numeric变量的计算，函数会返回这个值。在内部它被定义为 -1213（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</></term>
      <listitem>
       <para>
        如果一个解析例程不能解析一个指数，函数会返回这个值。在内部它被定义为 -1216（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</></term>
      <listitem>
       <para>
       如果一个解析例程不能解析一个日期，函数会返回这个值。在内部它被定义为 -1218（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</></term>
      <listitem>
       <para>
       如果一个解析例程被传递了它不能解析的额外字符，函数会返回这个值。在内部它被定义为 -1264（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-develop">
<!--==========================orignal english content==========================
  <title>Internals</title>
____________________________________________________________________________-->
  <title>内部</title>

<!--==========================orignal english content==========================
  <para>
   This section explains how <application>ECPG</application> works
   internally. This information can occasionally be useful to help
   users understand how to use <application>ECPG</application>.
  </para>
____________________________________________________________________________-->
  <para>
   这一节解释<application>ECPG</application>在内部如何工作。这些信息有时有助于用户理解如何使用<application>ECPG</application>。
  </para>

<!--==========================orignal english content==========================
   <para>
    The first four lines written by <command>ecpg</command> to the
    output are fixed lines.  Two are comments and two are include
    lines necessary to interface to the library.  Then the
    preprocessor reads through the file and writes output.  Normally
    it just echoes everything to the output.
   </para>
____________________________________________________________________________-->
   <para>
    <command>ecpg</command>写到输出的头四行是固定行。两行是注释，两行是与库接口必须的包括行。然后预处理器会从文件读取并且写输出。通常它会把所有东西回显在输出上。
   </para>

<!--==========================orignal english content==========================
   <para>
    When it sees an <command>EXEC SQL</command> statement, it
    intervenes and changes it. The command starts with <command>EXEC
    SQL</command> and ends with <command>;</command>. Everything in
    between is treated as an <acronym>SQL</acronym> statement and
    parsed for variable substitution.
   </para>
____________________________________________________________________________-->
   <para>
    当它看见一个<command>EXEC SQL</command>语句时，它会干预并且改变它。命令开始于<command>EXEC SQL</command> 并且结束于<command>;</command>。之间的任何东西都被视作一个<acronym>SQL</acronym>语句，并且会被解析进行变量替换。
   </para>

<!--==========================orignal english content==========================
   <para>
    Variable substitution occurs when a symbol starts with a colon
    (<literal>:</literal>). The variable with that name is looked up
    among the variables that were previously declared within a
    <literal>EXEC SQL DECLARE</> section.
   </para>
____________________________________________________________________________-->
   <para>
    当一个符号开始于一个冒号（<literal>:</literal>）时，变量替换会发生。有该名称的变量会被在之前声明于<literal>EXEC SQL DECLARE</>小节中的变量中搜索。
   </para>

<!--==========================orignal english content==========================
   <para>
    The most important function in the library is
    <function>ECPGdo</function>, which takes care of executing most
    commands. It takes a variable number of arguments. This can easily
    add up to 50 or so arguments, and we hope this will not be a
    problem on any platform.
   </para>
____________________________________________________________________________-->
   <para>
    该库中最重要的函数是<function>ECPGdo</function>，它负责执行大部分命令。它采用可变数量的参数。可以很容易地增加到最多 50 个左右的参数，并且我们希望在任何平台上这都不会成为问题。
   </para>

<!--==========================orignal english content==========================
   <para>
    The arguments are:

    <variablelist>
     <varlistentry>
      <term>A line number</term>
      <listitem>
       <para>
        This is the line number of the original line; used in error
        messages only.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>A string</term>
      <listitem>
       <para>
        This is the <acronym>SQL</acronym> command that is to be issued.
        It is modified by the input variables, i.e., the variables that
        where not known at compile time but are to be entered in the
        command. Where the variables should go the string contains
        <literal>?</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Input variables</term>
      <listitem>
       <para>
        Every input variable causes ten arguments to be created.  (See below.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <para>
        An <type>enum</> telling that there are no more input
        variables.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Output variables</term>
      <listitem>
       <para>
        Every output variable causes ten arguments to be created.
        (See below.)  These variables are filled by the function.
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <para>
        An <type>enum</> telling that there are no more variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    参数是：

    <variablelist>
     <varlistentry>
      <term>一个行号</term>
      <listitem>
       <para>
        这是原始行的行号，只用于错误消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>一个字符串</term>
      <listitem>
       <para>
        这是要被发出的<acronym>SQL</acronym>命令。它会被输入变量修改，即在编译时不知道但是要在命令中被输入的变量。其中变量应该去到包含<literal>?</literal>的字符串中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输入变量</term>
      <listitem>
       <para>
        每一个输入参数导致十个参数被创建（见下文）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <para>
        一个说明没有更多输入变量的<type>enum</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输出变量</term>
      <listitem>
       <para>
        每一个输出变量导致十个参数被创建（见下文）。这些变量由该函数填充。
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <para>
        一个说明没有更多变量的<type>enum</>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    For every variable that is part of the <acronym>SQL</acronym>
    command, the function gets ten arguments:

    <orderedlist>
     <listitem>
      <para>
       The type as a special symbol.
      </para>
     </listitem>

     <listitem>
      <para>
       A pointer to the value or a pointer to the pointer.
      </para>
     </listitem>

     <listitem>
      <para>
       The size of the variable if it is a <type>char</type> or <type>varchar</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       The number of elements in the array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The offset to the next element in the array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The type of the indicator variable as a special symbol.
      </para>
     </listitem>

     <listitem>
      <para>
       A pointer to the indicator variable.
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       The number of elements in the indicator array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The offset to the next element in the indicator array (for
       array fetches).
      </para>
     </listitem>
    </orderedlist>
   </para>
____________________________________________________________________________-->
   <para>
    对于每一个作为<acronym>SQL</acronym>命令一部分的变量，该函数得到十个参数：

    <orderedlist>
     <listitem>
      <para>
       作为一个特殊符号的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个值的指针或者一个指针的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       如果变量是一个<type>char</type>或者<type>varchar</type>，这是它的尺寸。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中元素的数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中下一个元素的偏移量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       作为一个特别符号的指示符变量的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个指示符变量的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       指示符数组中的元素数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       到指示符数组中下一个元素的偏移量（用于数组取得）。
      </para>
     </listitem>
    </orderedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that not all SQL commands are treated in this way.  For
    instance, an open cursor statement like:
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    is not copied to the output. Instead, the cursor's
    <command>DECLARE</> command is used at the position of the <command>OPEN</> command
    because it indeed opens the cursor.
   </para>
____________________________________________________________________________-->
   <para>
    注意并非所有 SQL 命令都被以这种方式对待。例如，一个打开游标语句：
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    不会被复制到输出。反而，游标的<command>DECLARE</>命令被用在<command>OPEN</>命令的位置上，因为它事实上会打开该游标。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is a complete example describing the output of the
    preprocessor of a file <filename>foo.pgc</filename> (details might
    change with each particular version of the preprocessor):
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    is translated into:
<programlisting><![CDATA[
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
    (The indentation here is added for readability and not
    something the preprocessor does.)
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个完整的例子，它描述了一个文件<filename>foo.pgc</filename>的预处理器输出（对预处理器的每一个特定版本细节可能不同）：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    会被翻译成：
<programlisting><![CDATA[
/* 由 ecpg (2.6.0) 处理 */
/* 这两个头文件由预处理器增加 */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* 声明节开始 */

#line 1 "foo.pgc"

 int index;
 int result;
/* 声明节结束 */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
    （这里的缩进是为了可读性而添加的，并非是预处理器做的处理）。
   </para>
 </sect1>
</chapter>
