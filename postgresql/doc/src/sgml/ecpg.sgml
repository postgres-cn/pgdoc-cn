<!-- doc/src/sgml/ecpg.sgml -->

<chapter id="ecpg">
 <title><application>ECPG</application> - C 中的嵌入式 <acronym>SQL</acronym></title>

 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>
  这一章描述了用于<productname>PostgreSQL</productname>的嵌入式<acronym>SQL</acronym>包。它由 Linus Tolke（<email>linus@epact.se</email>）和 Michael Meskes（<email>meskes@postgresql.org</email>）编写。最初它是为了与<acronym>C</acronym>一起工作而编写的。它也能与<acronym>C++</acronym>配合，但是它还不识别所有的<acronym>C++</acronym>结构。
 </para>

 <para>
  这份文档还远没有完成。但是因为这个结构是标准化的，额外的信息可以在有关 SQL 的很多资源中找到。
 </para>

 <sect1 id="ecpg-concept">
  <title>概念</title>

  <para>
   一个嵌入式 SQL 程序由一种普通编程语言编写的代码（在这里是 C）和位于特殊标记的小节中的 SQL 命令混合组成。要构建该程序，源代码（<filename>*.pgc</filename>）首先会通过嵌入式 SQL 预处理器，它会将源代码转换成一个普通 C 程序（<filename>*.c</filename>），并且后来它能够被一个 C 编译器所处理（编译和链接详见<xref linkend="ecpg-process">）。转换过的 ECPG 应用会通过嵌入式 SQL 库（ecpglib）调用 libpq 库中的函数，并且与 PostgreSQL 服务器使用普通的前端/后端协议通信。
  </para>

  <para>
   嵌入式<acronym>SQL</acronym>在为 C 代码处理<acronym>SQL</acronym>命令方面比起其他方法来具有优势。首先，它会搞定向你的<acronym>C</acronym>程序变量传递或者读取信息时的繁文缛节。其次，程序中的 SQL 代码在编译时就会被检查以保证语法正确性。第三，C 中的嵌入式<acronym>SQL</acronym>是在<acronym>SQL</acronym>标准中指定的并且受到很多其他<acronym>SQL</acronym>数据库系统的支持。<productname>PostgreSQL</>实现被设计为尽可能匹配这个标准，并且通常可以相对容易地把为其他 SQL 数据库编写的<acronym>SQL</acronym>程序移植到<productname>PostgreSQL</productname>。
  </para>

  <para>
   正如已经支出的，为嵌入式<acronym>SQL</acronym>接口编写的程序是插入了用于执行数据库相关动作的特殊代码的普通的 C 程序。这种特殊代码总是具有这样的形式：
<programlisting>
EXEC SQL ...;
</programlisting>
   这些语句在语法上取代了一个 C 语句。取决于特定的语句，它们可以出现在全局层面或者是一个函数中。嵌入式
   <acronym>SQL</acronym>语句遵循普通<acronym>SQL</acronym>代码的大小写敏感性规则，
   而不是 C 的大小写敏感性规则。它们也允许嵌套的 C 风格注释（SQL 标准的一部分）。
   不过，程序的 C 部分遵循 C 的标准不接受嵌套注释。
  </para>

  <para>
   下列小节解释了所有嵌入式 SQL 语句。
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
  <title>管理数据库连接</title>

  <para>
   这一节描述如何打开、关闭以及切换数据库连接。
  </para>

  <sect2 id="ecpg-connecting">
   <title>连接到数据库服务器</title>

  <para>
   我们可以使用下列语句连接到一个数据库：
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   <replaceable>target</replaceable>可以用下列方法指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</><optional>@<replaceable>hostname</></optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      一个包含上述形式之一的 SQL 字符串
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      到一个包含上述形式之一（参见例子）的字符变量的引用
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如果你用字面（也就是不通过一个变量引用）指定连接目标并且你没有引用该值，那么将会应用普通 SQL 的大小写不敏感性规则。在那种情况中，你也能够按照需要单独将个体参数放置在双引号中。实际上，使用一个（单引号引用）的字符串或一个变量引用出错的可能性更小。连接目标<literal>DEFAULT</literal>会以默认用户名发起一个到默认数据库的连接。在那种情况中不能指定单独的用户名或连接名。
  </para>

  <para>
   也有不同的方法来指定用户名：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如上所述，参数<replaceable>username</replaceable>以及<replaceable>password</replaceable>可以是一个 SQL 标识符、一个 SQL 字符串或者一个对字符变量的引用。
  </para>

  <para>
   <replaceable>connection-name</replaceable>被用来在一个程序中处理多个连接。如果一个程序只使用一个连接，它可以被忽略。最近被打开的连接将成为当前连接，当一个 SQL 语句要被执行时，将默认使用它（见这一章稍后的部分）。
  </para>

  <para>
   这里有一些<command>CONNECT</command>语句的例子：
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* 或者 EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   最后一种形式利用被上文成为字符变量引用的变体。你将在后面的小节中看到当你把 C 变量前放上一个冒号时，它们是怎样被用于 SQL 语句的。
  </para>

  <para>
   注意连接目标的格式没有在 SQL 标准中说明。因此如果你想要开发可移植的应用，你可能想要使用某种基于上述最后一个例子的方法来把连接目标字符串封装在某个地方。
  </para>
  </sect2>

  <sect2 id="ecpg-set-connection">
   <title>选择一个连接</title>

  <para>
   嵌入式 SQL 程序中的 SQL 语句默认是在当前连接（也就是最近打开的那一个）上执行的。如果一个应用需要管理多个连接，那么有两种方法来处理这种需求。
  </para>

  <para>
   第一个选项是显式地为每一个 SQL 语句选择一个连接，例如：
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   如果应用需要以混合的顺序使用多个连接，这个选项特别合适。
  </para>

  <para>
   如果你的应用使用多个线程执行，它们不能并发地共享一个连接。你必须显式地控制对连接的访问（使用互斥量）或者为每个线程使用一个连接。如果每个线程都使用自己的连接，你将需要使用 AT 子句来指定该线程将使用哪一个连接。
  </para>

  <para>
   第二个选项是执行一个语句来切换当前的连接。该语句是：
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   如果很多语句要被在同一个连接上执行，这个选项特别方便。它不是线程感知的。
  </para>

  <para>
   这里有一个管理多个数据库连接的例子程序：
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;

    /* 这个查询将在最近打开的数据库 "testdb3" 中执行 */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* 使用 "AT" 在 "testdb2" 中运行一个查询 */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* 切换当前连接到 "testdb1" */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   这个例子将产生这样的输出：
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
  </sect2>

  <sect2 id="ecpg-disconnect">
   <title>关闭一个连接</title>

  <para>
   要关闭一个连接，使用下列语句：
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   <replaceable>connection</replaceable>可以用下列方法指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如果没有指定连接名，当前连接将被关闭。
  </para>

  <para>
   在一个应用中总是显式地从它打开的每一个连接断开是一种好的风格。
  </para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
  <title>运行 SQL 命令</title>

  <para>
   任何 SQL 命令都可以在一个嵌入式 SQL 应用中被运行。下面是一些在嵌入式 SQL 应用中运行 SQL 命令的例子。
  </para>

  <sect2 id="ecpg-executing">
   <title>执行 SQL 语句</title>

  <para>
   创建一个表：
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   插入行：
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   删除行：
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   更新：
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   返回一个单一结果行的<literal>SELECT</literal>语句也可以直接使用<literal>EXEC SQL</literal>执行。要处理有多行的结果集，一个应用必须使用一个游标，可参考下面的<xref linkend="ecpg-cursors">（作为一种特殊情况，一个应用可以一次取出多行到一个数组主变量中，参考<xref linkend="ecpg-variables-arrays">）。
  </para>

  <para>
   单行选择：
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>

  <para>
   还有，一个配置参数可以用<literal>SHOW</literal>命令检索：
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>

  <para>
   <literal>:<replaceable>something</replaceable></literal>形式的记号是<firstterm>主变量</firstterm>，即它们指向 C 程序中的变量。它们在<xref linkend="ecpg-variables">中解释。
  </para>
  </sect2>

  <sect2 id="ecpg-cursors">
   <title>使用游标</title>

  <para>
   要检索一个保持多行的结果集，一个应用必须声明一个游标并且从该游标中取得每一行。使用一个游标的步骤如下：声明一个游标、打开它、从该游标取得一行、重复并且最终关闭它。
  </para>

  <para>
   使用游标选择：
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   有关声明游标的更多细节，可参考<xref linkend="ecpg-sql-declare">；<literal>FETCH</literal>命令的细节则可以参考<xref linkend="sql-fetch">。
  </para>

   <note>
    <para>
     ECPG <command>DECLARE</command>命令实际上不会导致一个语句被发送到 PostgreSQL 后端。在<command>OPEN</command>命令被执行时，游标会在后端被打开（使用后端的<command>DECLARE</command>命令）。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
   <title>管理事务</title>

  <para>
   在默认模式中，只有当<command>EXEC SQL COMMIT</command>被发出时才会提交命令。嵌入式 SQL 接口也通过<command>ecpg</command>的<option>-t</option>命令行选项（见<xref linkend="app-ecpg">）或者通过<literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>语句支持事务的自动提交（类似于<application>psql</>的缺省行为）。在自动提交模式中，除非位于一个显式事务块内，每一个命令都会被自动提交。这种模式可以使用<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>显式地关闭。
  </para>

   <para>
    可以使用下列事务管理命令：

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        提交一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        回滚一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        启用自动提交模式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        禁用自动提交模式。这是默认值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-prepared">
   <title>预备语句</title>

   <para>
    当传递给 SQL 语句的值在编译时未知或者同一个语句要被使用多次时，那么预备语句就有用武之地了。
   </para>

   <para>
    语句使用命令<literal>PREPARE</literal>进行预备。对于还未知的值，使用占位符<quote><literal>?</literal></quote>：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>

   <para>
    如果一个语句返回一个单一行，应用可以在<literal>PREPARE</literal>之后调用<literal>EXECUTE</literal>来执行该语句，同时要用一个<literal>USING</literal>子句为占位符提供真实的值：
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>

   <para>
    如果一个语句返回多行，应用可以使用一个基于该预备语句声明的游标。要绑定输入参数，该游标必须用一个<literal>USING</literal>子句打开：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* 当到达结果集末尾时，跳出 while 循环 */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>

   <para>
    当你不再需要该预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>

   <para>
    更多有关<literal>PREPARE</literal>的细节，可参考<xref linkend="ecpg-sql-prepare">。关于使用占位符和输入参数的细节，可参考<xref linkend="ecpg-dynamic">。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
  <title>使用主变量</title>

  <para>
   在<xref linkend="ecpg-commands">中，你了解了如何从一个嵌入式 SQL 程序执行 SQL 语句。某些那种语句只使用固定值并且没有提供方法来插入用户提供的值到语句中或者让程序处理查询返回的值。那种语句在实际应用中其实没有什么用处。这一节详细解释了如何使用一种简单的机制（<firstterm>主变量</firstterm>）在 C 程序和嵌入式 SQL 语句之间传递数据。在一个嵌入式 SQL 程序中，我们认为 SQL 语句是 C 程序代码中的<firstterm>客人</firstterm>，而 C 代码是<firstterm>主语言</firstterm>。因此 C 程序的变量被称为<firstterm>主变量</firstterm>。
  </para>

  <para>
   另一种在 PostgreSQL 后端和 ECPG 应用之间交换值的方式是使用 SQL 描述符，它在<xref linkend="ecpg-descriptors">中介绍。
  </para>

  <sect2 id="ecpg-variables-overview">
   <title>概述</title>

   <para>
    在嵌入式 SQL 中进行 C 程序和 SQL 语句见的数据传递特别简单。我们不需要让程序把数据粘贴到语句（这会导致很多复杂性，例如正确地引用值），我们可以简单地在 SQL 语句中写 C 变量的名称，只要在它前面放上一个冒号。例如：
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    这个语句引用了两个 C 变量（名为<varname>v1</varname>和<varname>v2</varname>）并且还使用了一个常规的 SQL 字符串来说明你没有被限制于使用某一种数据。
   </para>

   <para>
    这种在 SQL 语句中插入 C 变量的风格可以用在 SQL 语句中每一个应该出现值表达式的地方。
   </para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
   <title>声明小节</title>

   <para>
    要从程序传递数据给数据库（例如作为一个查询的参数）或者从数据库传数据回程序，用于包含这些数据的 C 变量必须在特别标记的节中被声明，这样嵌入式 SQL 预处理器才会注意它们。
   </para>

   <para>
    这个节开始于：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    并且结束于：
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    在这两行之间，必须是正常的 C 变量声明，例如：
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
    如你所见，你可以选择为变量赋一个初始值。变量的可见范围由定义它的节在程序中的位置决定。你也可以使用下面的语法声明变量，这种语法将会隐式地创建一个声明节：
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    你可以按照你的意愿在一个程序中放上多个声明节。
   </para>

   <para>
    这些声明也会作为 C 变量被重复在输出文件中，因此无需再次声明它们。不准备在 SQL 命令中使用的变量可以正常地在这些特殊节之外声明。
   </para>

   <para>
    一个结构或联合的定义也必须被列在一个<literal>DECLARE</>节中。否则预处理器无法处理这些类型，因为它不知道它们的定义。
   </para>
  </sect2>

  <sect2 id="ecpg-retrieving">
   <title>检索查询结果</title>

   <para>
    现在你应该能够把程序产生的数据传递到一个 SQL 命令中了。但是怎么检索一个查询的结果呢？为此，嵌入式  SQL 提供了常规命令<command>SELECT</command>和<command>FETCH</command>的特殊变体。这些命令有一个特殊的<literal>INTO</literal>子句，它指定被检索到的值要被存储在哪些主变量中。<command>SELECT</command>被用于只返回单一行的查询，而<command>FETCH</command>被用于使用一个游标返回多行的查询。
   </para>

   <para>
    这里是一个例子：
<programlisting>
/*
 * 假定有这个表：
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    那么<literal>INTO</literal>子句出现在选择列表和<literal>FROM</literal>子句之间。选择列表中的元素数量必须和<literal>INTO</literal>后面列表（也被称为目标列表）的元素数量相等。
   </para>

   <para>
    这里有一个使用命令<command>FETCH</command>的例子：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    这里<literal>INTO</literal>子句出现在所有正常子句的后面。
   </para>

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
   <title>类型映射</title>

   <para>
    当 ECPG 应用在 PostgreSQL 服务器和 C 应用之间交换值时（例如从服务器检索查询结果时或者用输入参数执行 SQL 语句时），值需要在 PostgreSQL 数据类型和主语言变量类型（具体来说是 C 语言数据类型）之间转换。ECPG 的要点之一就是它会在大多数情况下自动搞定这种转换。
   </para>

   <para>
    在这方面有两类数据类型：一些简单 PostgreSQL 数据类型（例如<type>integer</type>和<type>text</type>）可以被应用直接读取和写入。其他 PostgreSQL 数据类型（例如<type>timestamp</type>和<type>numeric</type>）只能通过特殊库函数访问，见<xref linkend="ecpg-special-types">。
   </para>

   <para>
    <xref linkend="ecpg-datatype-hostvars-table">展示了哪种 PostgreSQL 数据类型对应于哪一种 C 数据类型。当你希望发送或接收一种给定 PostgreSQL 数据类型的值时，你应该在声明节中声明一个具有相应 C 数据类型的 C 变量。
   </para>

   <table id="ecpg-datatype-hostvars-table">
    <title>在 PostgreSQL 数据类型和 C 变量类型之间映射</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>PostgreSQL 数据类型</entry>
       <entry>主变量类型</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>这种类型只能通过特殊的库函数访问，见<xref linkend="ecpg-special-types">。</para></footnote></entry>
      </row>

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><para> 在<filename>ecpglib.h</filename>中声明</para></footnote></entry>
      </row>

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>如果不是本地化类型，则声明在<filename>ecpglib.h</filename>中</para></footnote></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
    <title>处理字符串</title>

    <para>
     要处理 SQL 字符串数据类型（例如<type>varchar</type>以及<type>text</type>），有两种可能的方式来声明主变量。
    </para>

    <para>
     一种方式是使用<type>char[]</type>（一个<type>char</type>字符串），这是在 C 中处理字符数据最常见的方式。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     注意你必须自己照看长度。如果你把这个主变量用作一个查询的目标变量并且该查询返回超过 49 个字符的字符串，那么将会发生缓冲区溢出。
    </para>

    <para>
     另一种方式是使用<type>VARCHAR</type>类型，它是 ECPG 提供的一种特殊类型。在一个<type>VARCHAR</type>类型数组上的定义会被转变成一个命名的<type>struct</>。这样一个声明：
<programlisting>
VARCHAR var[180];
</programlisting>
     会被转变成：
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
     成员<structfield>arr</structfield>容纳包含一个终止零字节的字符串。因此，要在一个<type>VARCHAR</type>主变量中存储一个字符串，该主变量必须被声明为具有包括零字节终止符的长度。成员<structfield>len</structfield>保存存储在<structfield>arr</structfield>中的字符串的长度，不包括终止零字节。当一个主变量被用做一个查询的输入时，如果<literal>strlen(arr)</literal>和<structfield>len</structfield>不同，将使用短的那一个。
    </para>

    <para>
     <type>VARCHAR</type>可以被写成大写或小写形式，但是不能大小写混合。
    </para>

    <para>
     <type>char</type>和<type>VARCHAR</type>主变量也可以保存其他 SQL 类型的值，它们将被存储为字符串形式。
    </para>
   </sect3>

   <sect3 id="ecpg-special-types">
    <title>访问特殊数据类型</title>

    <para>
     ECPG 包含一些特殊类型帮助你容易地与来自 PostgreSQL 服务器的一些特殊数据类型交互。特别地，它已经实现了对于<type>numeric</>、<type>decimal</type>、<type>date</>、<type>timestamp</>以及<type>interval</>类型的支持。这些数据类型无法有效地被映射到原始的主变量类型（例如<type>int</>、<type>long long int</type>或者<type>char[]</type>），因为它们有一种复杂的内部结构。应用通过声明特殊类型的主变量以及使用 pgtypes 库中的函数来处理这些类型。pgtypes 库（在<xref linkend="ecpg-pgtypes">中详细描述）包含了处理这些类型的基本函数，这样你不需要仅仅为了给一个时间戳增加一个时段而发送一个查询给 SQL 服务器。
    </para>

    <para>
     下面的小节描述了这些特殊数据类型。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
    </para>

    <sect4>
     <title id="ecpg-type-timestamp-date">timestamp, date</title>

     <para>
      这里有一种在 ECPG 主应用中处理<type>timestamp</type>变量的模式。
     </para>

     <para>
      首先，程序必须包括用于<type>timestamp</type>类型的头文件：
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>

     <para>
      接着，在声明节中声明一个主变量为类型<type>timestamp</type>：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>

     <para>
      并且在读入一个值到该主变量中之后，使用 pgtypes 库函数处理它。在下面的例子中，<type>timestamp</type>值被<function>PGTYPEStimestamp_to_asc()</function>函数转变成文本（ASCII）形式：
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      这个例子将展示像下面形式的一些结果：
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>

     <para>
      另外，DATE 类型可以用相同的方式处理。程序必须包括<filename>pgtypes_date.h</filename>，声明一个主变量为日期类型并且将一个 DATE 值使用<function>PGTYPESdate_to_asc()</function>函数转变成一种文本形式。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
     </para>
    </sect4>

    <sect4 id="ecpg-type-interval">
     <title>interval</title>

     <para>
      对<type>interval</type>类型的处理也类似于<type>timestamp</type>和<type>date</type>类型。不过，必须显式为一个<type>interval</type>类型分配内存。换句话说，该变量的内存空间必须在堆内存中分配，而不是在栈内存中分配。
     </para>

     <para>
      这里是一个例子程序：
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
     <title>numeric, decimal</title>

     <para>
      <type>numeric</type>和<type>decimal</type>类型的处理类似于<type>interval</type>类型：需要定义一个指针、在堆上分配一些内存空间并且使用 pgtypes 库函数访问该变量。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes">。
     </para>

     <para>
      pgtypes 库没有特别为<type>decimal</type>类型提供函数。一个应用必须使用一个 pgtypes 库函数把它转变成一个<type>numeric</type>变量以便进一步处理。
     </para>

     <para>
      这里是一个处理<type>numeric</type>和<type>decimal</type>类型变量的例子程序。
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* 将一个decimal转变成numeric以显示一个decimal值。 */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
    <title>非简单类型的主变量</title>

    <para>
     你也可以把数组、typedefs、结构和指针用作主变量。
    </para>

    <sect4 id="ecpg-variables-arrays">
     <title>数组</title>

     <para>
      将数组用作主变量有两种情况。第一种如<xref linkend="ecpg-char">所述，是一种将一些文本字符串存储在<type>char[]</type>或<type>VARCHAR[]</type>中的方法。第二种是不用一个游标从一个查询结果中检索多行。如果没有一个数组，要处理由多个行组成的查询结果，我们需要使用一个游标以及<command>FETCH</command>命令。但是使用数组主变量，多个行可以被一次收取。该数组的长度必须被定义成足以容纳所有的行，否则很可能会发生一次缓冲区溢出。
     </para>

     <para>
      下面的例子扫描<literal>pg_database</literal>系统表并且显示所有可用数据库的 OID 和名称：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    /* 一次检索多行到数组中。 */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

    这个例子显示下面的结果（确切的值取决于本地环境）。
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
    </sect4>

    <sect4 id="ecpg-variables-struct">
     <title>结构</title>

     <para>
      一个成员名称匹配查询结果列名的结构可以被用来一次检索多列。该结构使得我们能够在一个单一主变量中处理多列值。
     </para>

     <para>
      下面的例子从<literal>pg_database</literal>系统表以及使用<function>pg_database_size()</function>函数检索可用数据库的 OID、名称和尺寸。在这个例子中，一个成员名匹配<literal>SELECT</literal>结果的每一列的结构变量<varname>dbinfo_t</varname>被用来检索结果行，而不需要把多个主变量放在<literal>FETCH</literal>语句中。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>

     <para>
      这个例子会显示下列结果（确切的值取决于本地环境）。
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>

     <para>
      结构主变量将列尽数<quote>吸收</quote>成结构的域。额外的列可以被分配给其他主变量。例如，上面的程序也可以使用结构外部的<varname>size</varname>变量重新构造：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
    </sect4>

    <sect4>
     <title>Typedefs</title>

     <para>
      使用<literal>typedef</literal>关键词可以把新类型映射到已经存在的类型。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      注意你也可以使用：
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      这种声明不需要位于一个声明节之中。
     </para>
    </sect4>

    <sect4>
     <title>指针</title>

     <para>
      你可以声明最常见类型的指针。不过注意，你不能使用指针作为不带自动分配内存的查询的目标变量。关于自动分配内存的详情请参考<xref linkend="ecpg-descriptors">。
     </para>

     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
   <title>处理非简单 SQL 数据类型</title>

   <para>
    这一节包含关于如何处理 ECPG 应用中非标量以及用户定义的 SQL 级别数据类型。注意这和上一节中描述的简单类型主变量的处理有所不同。
   </para>

   <sect3>
    <title>数组</title>

    <para>
     ECPG 中不直接支持 SQL 级别的多维数组。一维 SQL 数组可以被映射到 C 数组主机变量，反之
     亦然。不过，在创建一个语句时，ecpg并不知道列的类型，因此它无法检查一个 C 数组否是一个
     SQL 数组的输入。在处理一个 SQL 语句的输出时，ecpg 有必需的信息并且进而检查是否两者都是
     数组。
    </para>

    <para>
     如果一个查询个别地访问一个数组的<emphasis>元素</emphasis>，那么这可以避免使用 ECPG 中的数组。然后，应该使用一个能被映射到该元素类型的类型的主变量。例如，如果一个列类型是<type>integer</type>数组，可以使用一个类型<type>int</type>的主变量。还有如果元素类型是<type>varchar</type>或<type>text</type>，可以使用一个类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量。
    </para>

    <para>
     这里是一个例子。假定有下面的表：
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=> SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

     下面的例子程序检索数组的第四个元素并且把它存储到一个类型为<type>int</type>的主变量中：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下面的结果：
<screen>
ii=4
</screen>
    </para>

    <para>
     要把多个数组元素映射到一个数组类型主变量中的多个元素，数组列的每一个元素以及主变量数组的每一个元素都必须被单独管理，例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>

    <para>
     注意
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 错误 */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
     在这种情况中不会正确工作，因为你无法把一个数组类型列直接映射到一个数组主变量。
    </para>

    <para>
     另一种变通方案是在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中存储数组的外部字符串表达。关于这种表达的详情请见<xref linkend="arrays-input">。注意这意味着该数组无法作为一个主程序中的数组被自然地访问（没有解析文本表达的进一步处理）。
    </para>
   </sect3>

   <sect3>
    <title>组合类型</title>

    <para>
     ECPG 中并不直接支持组合类型，但是有一种可能的简单变通方案。可用的变通方案和上述用于数组的方案相似：要么单独访问每一个属性或者使用外部字符串表达。
    </para>

    <para>
     对于下列例子，假定有下面的类型和表：
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

     最显而易见的解决方案是单独访问每一个属性。下面的程序通过单独选择类型<type>comp_t</type>的每一个属性从例子表中检索数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将组合类型列的每一个元素取到主变量中。 */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>

    <para>
     为了加强这个例子，在<command>FETCH</command>命令中存储值的主变量可以被集中在一个结构中。结构形式的主变量的详情可见<xref linkend="ecpg-variables-struct">。要切换到结构形式，该例子可以被改成下面的样子。两个主变量<varname>intval</varname>和<varname>textval</varname>变成<structname>comp_t</structname>结构的成员，并且该结构在<command>FETCH</command>命令中指定。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

     尽管在<command>FETCH</command>命令中使用了一个结构，<command>SELECT</command>子句中的属性名还是要一个一个指定。可以通过使用一个<literal>*</literal>来要求该组合类型值的所有属性来改进。
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     通过这种方法，即便 ECPG 不理解组合类型本身，组合类型也能够几乎无缝地被映射到结构。
    </para>

    <para>
     最后，也可以在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中把组合类型值存储成它们的外部字符串表达。但是如果使用那种方法，就不太可能从主程序中访问该值的各个域了。
    </para>
   </sect3>

   <sect3>
    <title>用户定义的基础类型</title>

    <para>
     ECPG 并不直接支持新的用户定义的基本类型。你可以使用外部字符串表达以及类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，并且这种方案事实上对很多类型都是合适和足够的。
    </para>

    <para>
     这里有一个使用来自<xref linkend="xtypes">中例子里的数据类型<type>complex</type>的例子。该类型的外部字符串表达是<literal>(%lf,%lf)</literal>，它被定义在函数<function>complex_in()</function>以及<xref linkend="xtypes">中的<function>complex_out()</function>函数内。下面的例子把复杂类型值<literal>(1,1)</literal>和<literal>(3,3)</literal>插入到列<literal>a</literal>和<literal>b</literal>，并且之后把它们从表中选择出来。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下列结果：
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>

    <para>
     另一种变通方案是避免在 ECPG 中直接使用用户定义的类型，而是创建一个在用户定义的类型和 ECPG 能处理的简单类型之间转换的函数或者造型。不过要注意，在类型系统中引入类型造型（特别是隐式造型）要非常小心。
    </para>

    <para>
     例如，
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
    在这个定义之后 ，下面的语句
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    具有和
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    相同的效果。
    </para>
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
   <title>指示符</title>

   <para>
    上述例子并没有处理空值。事实上，如果检索的例子从数据库取到了一个空值，它们将会产生一个错误。要能够向数据库传递空值或者从数据库检索空值，你需要对每一个包含数据的主变量追加一个次要主变量说明。这个次要主变量被称为<firstterm>指示符</firstterm>并且包含一个说明数据是否为空的标志，如果为空真正的主变量中的值就应该被忽略。这里有一个能正确处理检索空值的例子：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    如果值不为空，指示符变量<varname>val_ind</varname>将为零；否则它将为负值。
   </para>

   <para>
    指示符有另一种功能：如果指示符值为正，它表示值不为空，但是当它被存储在主变量中时已被截断。
   </para>

   <para>
    如果参数<literal>-r no_indicator</literal>被传递给预处理器<command>ecpg</command>，它会工作在<quote>无指示符</quote>模式。在无指示符模式中，如果没有指定指示符变量，对于字符串类型空值被标志（在输入和输出上）为空串，对于整数类型空值被标志为类型的最低可能值（例如，<type>int</type>的是<symbol>INT_MIN</symbol>）。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
  <title>动态 SQL</title>

  <para>
   在很多情况中，一个应用必须要执行的特定 SQL 语句在编写该应用时就已知。不过在某些情况中，SQL 语句在运行时构造或者由一个外部来源提供。这样你就不能直接把 SQL 语句嵌入到 C 源代码，不过有一种功能允许你调用在一个字符串变量中提供的任意 SQL 语句。
  </para>

  <sect2 id="ecpg-dynamic-without-result">
   <title>执行没有结果集的语句</title>

   <para>
    执行一个任意 SQL 语句的最简单方法是使用命令<command>EXECUTE IMMEDIATE</command>。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <command>EXECUTE IMMEDIATE</command>可以被用于不返回结果集的 SQL 语句（例如 DDL、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）。你不能用这种方法执行检索数据的语句（例如<command>SELECT</command>）。下一节将描述如何执行这一种语句。
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-input">
   <title>执行一个有输入参数的语句</title>

   <para>
    执行任意 SQL 语句的一种更强大的方法是准备它们一次并且在每次需要时执行该预备语句。也可以准备一个一般化的语句，然后通过替换参数执行它的特定版本。在准备语句时，在你想要稍后替换参数的地方写上问号。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>

   <para>
    当你不再需要预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
   <title>执行一个有结果集的语句</title>

   <para>
    要执行一个只有单一结果行的 SQL 语句，可以使用<command>EXECUTE</command>。要保存结果，在其中增加一个<literal>INTO</literal>子句。
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    一个<command>EXECUTE</command>命令可以有一个<literal>INTO</literal>子句、一个<literal>USING</literal>子句，可以同时有这两个子句，也可以不带这两个子句。
   </para>

   <para>
    如果一个查询被期望返回多于一个结果行，应该如下列例子所示使用一个游标（关于游标详见<xref linkend="ecpg-cursors">）。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
  <title>pgtypes 库</title>

  <para>
   pgtypes 库将<productname>PostgreSQL</productname>数据库类型映射到 C 中等价的类型以便在 C 程序中使用。它还提供在 C 中对这些类型进行基本计算的函数，即不依赖<productname>PostgreSQL</productname>服务器进行计算。请看下面的例子：
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting>
  </para>

  <sect2 id="ecpg-pgtypes-numeric">
   <title>numeric类型</title>
   <para>
    numeric类型用来完成对任意精度的计算。<productname>PostgreSQL</>服务器中等效的类型请见<xref linkend="datatype-numeric">。因为要用于任意精度，这种变量需要能够动态地扩展和收缩。这也是为什么你只能用<function>PGTYPESnumeric_new</>和<function>PGTYPESnumeric_free</>函数在堆上创建numeric变量。decimal类型与numeric类型相似但是在精度上有限制，decimal类型可以在堆上创建也可以在栈上创建。
   </para>
   <para>
   下列函数可以用于numeric类型：
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      请求一个指向新分配的numeric变量的指针。
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      释放一个numeric类型，释放它所有的内存。
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       从字符串记号中解析一个numeric类型。
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       例如，可用的格式是：
        <literal>-2</literal>、
        <literal>.794</literal>、
        <literal>+3.44</literal>、
        <literal>592.49E07</literal>或者
        <literal>-32.84e-4</literal>。
       如果值能被成功地解析，将返回一个有效的指针，否则返回 NULL 指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       返回由<function>malloc</function>分配的字符串的指针，它包含numeric类型<literal>num</literal>的字符串表达。
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       numeric值将被使用<literal>dscale</literal>小数位打印，必要时会圆整。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       把两个numeric变量相加放到第三个numeric变量中。
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相加放到结果变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       把两个numeric变量相减并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var2</literal>从变量<literal>var1</literal>中减除。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       把两个numeric变量相乘并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相乘。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       把两个numeric变量相除并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数用变量<literal>var2</literal>除变量<literal>var1</literal>。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       比较两个numeric变量。
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       这个函数比较两个numeric变量。错误时会返回<literal>INT_MAX</literal>。成功时，该函数返回三种可能结果之一：
       <itemizedlist>
        <listitem>
         <para>
          <literal>var1</>大于<literal>var2</>则返回 1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</>小于<literal>var2</>则返回 -1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</>和<literal>var2</>相等则返回 0
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       把一个整数变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       这个函数接受一个有符号整型变量并且把它存储在numeric变量<literal>var</>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       把一个长整型变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       这个函数接受一个有符号长整型变量并且把它存储在numeric变量<literal>var</>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       把一个numeric变量复制到另一个中。
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       这个函数把<literal>src</literal>指向的变量的值复制到<literal>dst</>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       把一个双精度类型的变量转换成一个numeric变量。
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       这个函数接受一个双精度类型的变量并且把结果存储在<literal>dst</>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成双精度。
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       这个函数将<literal>nv</>指向的变量中的numeric值转换成<literal>dp</>指向的双精度变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成整数。
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的整数变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成长整型。
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的长整型变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成decimal。
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       该函数将<literal>nv</>指向的变量的numeric值转换成<literal>ip</>指向的decimal变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       将一个decimal类型的变量转换成numeric。
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       该函数将<literal>nv</>指向的变量的decimal值转换成<literal>ip</>指向的numeric变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。因为decimal类型被实现为numeric类型的一个有限的版本，在这个转换上不会发生溢出。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
   <title>日期类型</title>
   <para>
    C 中的日期类型允许你的程序处理 SQL 日期类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
   <para>
    下列函数可以被用于日期类型：
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        从一个时间戳中抽取日期部分。
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        该函数接收一个时间戳作为它的唯一参数并且从这个时间戳返回抽取的日期部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       从日期的文本表达解析一个日期。
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
        该函数接收一个 C 的字符串<literal>str</>以及一个指向 C 字符串的指针<literal>endptr</>。当前 ECPG 总是解析完整的字符串并且因此当前不支持将第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
       <para>
        注意该函数总是假定格式按照 MDY 格式化并且当前在 ECPG 中没有变体可以改变这种格式。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table">展示了所有允许的输入格式。
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title><function>PGTYPESdate_from_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>年以及积日</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>儒略日</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>公元前 99 年</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        返回一个日期变量的文本表达。
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        该函数接收日期<literal>dDate</>作为它的唯一参数。它将以形式<literal>1999-01-18</>输出该日期，即以<literal>YYYY-MM-DD</>格式输出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        从一个日期类型变量中抽取日、月和年的值。
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
        该函数接收日期<literal>d</>以及一个指向有 3 个整数值的数组<literal>mdy</>的指针。变量名就表明了顺序：<literal>mdy[0]</>将被设置为包含月份，<literal>mdy[1]</>将被设置为日的值，而<literal>mdy[2]</>将包含年。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        从一个由 3 个整数构成的数组创建一个日期值，3 个整数分别指定日、月和年。
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        这个函数接收 3 个整数（<literal>mdy</>）组成的数组作为其第一个参数，其第二个参数是一个指向日期类型变量的指针，它被用来保存操作的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        为一个日期值返回表示它是星期几的数字。
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        这个函数接收日期变量<literal>d</>作为它唯一的参数并且返回一个整数说明这个日期是星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 星期日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 星期一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 星期二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 星期三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 星期四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 星期五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 星期六
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        得到当前日期。
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
        该函数接收一个指向一个日期变量（<literal>d</>）的指针并且把该参数设置为当前日期。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码将一个日期类型的变量转换成它的文本表达。
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        该函数接收要转换的日期（<literal>dDate</>）、格式掩码（<literal>fmtstring</>）以及将要保存日期的文本表达的字符串（<literal>outbuf</>）。
       </para>
       <para>
        成功时，返回 0；如果发生错误，则返回一个负值。
       </para>
       <para>
        下面是你可以使用的域指示符：
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - 一个月中的第几天。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - 一年中的第几个月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - 两位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - 四位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - 星期几的名称（简写）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - 月份的名称（简写）。
          </para>
         </listitem>
        </itemizedlist>
        所有其他字符会被原封不动地复制到输出字符串中。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table">指出了一些可能的格式。这将给你一些线索如何使用这个函数。所有输出都是基于同一个日期：1959年11月23日。
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title><function>PGTYPESdate_fmt_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码把一个 C 的 <type>char*</type>子返回串转换成一个日期类型的值。
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-- same description as rdefmtdate -->
        该函数接收一个用来保存操作结果的指向日期值的指针（<literal>d</>）、用于解析日期的格式掩码（<literal>fmt</>）以及包含日期文本表达的 C char* 串（<literal>str</>）。该函数期望文本表达匹配格式掩码。不过你不需要字符串和格式掩码的一一映射。该函数只分析相继顺序并且查找表示年份位置的文字<literal>yy</literal>或者<literal>yyyy</literal>、表示月份位置的<literal>mm</literal>以及表示日位置的<literal>dd</literal>。
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table">给出了一些可能的格式。这将给你一些线索如何使用这个函数。
       </para>
        <table id="ecpg-rdefmtdate-example-table">
         <title><function>rdefmtdate</function>的合法输入格式</title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>字符串</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>在 2525 年的七月二十八日，人类还将存在</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>也是 2525 年七月的二十八日</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
   <title>时间戳类型</title>
   <para>
    C 中的时间戳类型允许你的程序处理 SQL 时间戳类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
   <para>
    下列函数可用于时间戳类型：
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
        从文本表达解析一个时间戳并放到一个时间戳变量中。
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
        这个函数接收一个要解析的字符串（<literal>str</>）以及一个 C char* 的指针（<literal>endptr</>）。当前 ECPG 总是解析完整的字符串并且因此当前不支持将第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
       <para>
        成功时该函数返回解析到的时间戳。错误时，会返回<literal>PGTYPESInvalidTimestamp</literal>并且<varname>errno</>会被设置为<literal>PGTYPES_TS_BAD_TIMESTAMP</>。关于这个值的重要提示请见<xref linkend="PGTYPESInvalidTimestamp">。
       </para>
       <para>
        通常，该输入字符串能够包含一个允许的日期说明、一个空格字符和一个允许的时间说明的任意组合。注意 ECPG 不支持时区。它能够解析时区但是不会应用任何计算（例如<productname>PostgreSQL</>服务器所作的事情）。时区指示符会被无声无息地丢弃。
       </para>
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table">包含输入字符串的一些例子。
       </para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
         <title><function>PGTYPEStimestamp_from_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
            <entry><literal>1999-01-08 04:05:06.789 （忽略了时区指示符）</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <entry><literal>1999-01-08 04:05:00 （忽略了时区指示符）</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
        将一个日期转换成一个 C char* 字符串。
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
        该函数接收时间戳<literal>tstamp</>作为它的唯一参数并且返回一个分配好的包含该时间戳文本表达的字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
        检索当前的时间戳。
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        该函数检索当前的时间戳并且将它保存在<literal>ts</>指向的时间戳变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码将一个时间戳变量转换成一个 C char* 。
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个指向时间戳的指针作为它的第一个参数（<literal>ts</>）、一个指向输出缓冲区的指针（<literal>output</>）、为输出缓冲区分配的最大长度（<literal>str_len</literal>）以及用于转换的格式掩码（<literal>fmtstr</literal>）。
       </para>
       <para>
        成功时，该函数返回 0；如果有错误发生，则返回一个负值。
       </para>
       <para>
        你可以为格式掩码使用下列格式指示符。格式指示符就是用在<productname>libc</productname>的<function>strftime</>函数中的那一些。任何非格式指示符将被复制到输出缓冲区。
        <!-- This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
          <para>
           <literal>%A</literal> - 被完整的星期几名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%a</literal> - 被简写星期几名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%B</literal> - 被完整的月份名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%b</literal> - 被简写月份名称的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%C</literal> - 被十进制数（年份/100）所替换，单一数字会被前置一个零。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%c</literal> - 被时间和日期的本国表达所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%D</literal> - 等效于<literal>%m/%d/%y</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%d</literal> - 被十进制数（01-31）的日所替换。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX 区域扩展。序列
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           被假定提供可供选择的表达。
          </para>
          <para>
           此外还实现了<literal>%OB</literal>来表达可供选择的月份名称（单独使用，不用提过的日）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%e</literal> - 被十进制数（01-31）的日所替换，单一数字被前置一个空格。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%F</literal> - 等效于<literal>%Y-%m-%d</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%G</literal> - 被替换为一个带有世纪的十进制数年份。这个年份是包含这一周大部分的年份（星期一作为这一周的第一天）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%g</literal> - 被替换为与<literal>%G</literal>中相同的年份，但是作为一个不带世纪的十进制数（00-99）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%H</literal> - 被替换为一个十进制数的小时（24 小时制，00-23）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%h</literal> - 和<literal>%b</literal>相同。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%I</literal> - 被替换为一个十进制数的小时（12 小时制，01-12）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%j</literal> - 被替换为一个十进制数的积日（001-366）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%k</literal> - 被替换为一个十进制数的小时（24 小时制，00-23），单一数字被前置一个空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%l</literal> - 被替换为一个十进制数的小时（12 小时制，01-12），单一数字被前置一个空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%M</literal> - 被替换为一个十进制数的分钟（00-59）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%m</literal> - 被替换为一个十进制数的月份（01-12）。
          </para>
         </listitem>
         <listitem>
          <para>
          <literal>%n</literal> - 被替换为一个新行。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%O*</literal> - 和<literal>%E*</literal>相同。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%p</literal> - 根据情况被替换为<quote>午前</quote>或<quote>午后</quote>的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%R</literal> - 等效于<literal>%H:%M</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%r</literal> - 等效于<literal>%I:%M:%S%p</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%S</literal> - 被替换为十进制数的秒（00-60）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%s</literal> - 被替换为从 UTC 新纪元以来的秒数。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%T</literal> - 等效于<literal>%H:%M:%S</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%t</literal> - 被替换为一个制表符。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%U</literal> - 被替换为十进制数的周数（周日作为一周的第一天，00-53）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%u</literal> - 被替换为十进制数的星期几（周一作为一周的第一天，1-7）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%V</literal> - 被替换为十进制数的周数（周一作为一周的第一天，01-53）。如果包含 1 月 1 日的周在新年中有 4 天或更多天，那么它是第一周。否则它是前一年的最后一周，并且下一周是第一周。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%v</literal> - 等效于<literal>%e-%b-%Y</literal>。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%W</literal> - 被替换为十进制数的周数（周一作为一周的第一天，00-53）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%w</literal> - 被替换为十进制数的星期几（0-6，周日作为一周的第一天）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%X</literal> - 被替换为时间的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%x</literal> - 被替换为日期的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Y</literal> - 被替换为十进制数的带世纪的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%y</literal> - 被替换为十进制数的不带世纪的年份（00-99）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Z</literal> - 被替换为时区名称。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%z</literal> - 被替换为相对于 UTC 的时区偏移；一个前导的加号表示 UTC 东部，一个负号表示 UTC 西部，接着是分别有两个数字的小时和分钟并且它们之间没有定界符（RFC 822 日期头部的一般形式）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%+</literal> - 被替换为日期和时间的本国表达。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%-*</literal> - GNU libc 扩展。在执行数值输出时不做任何填充。
          </para>
         </listitem>
         <listitem>
          <para>
           $_* - GNU libc 扩展。显式地指定用空格填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%0*</literal> - GNU libc 扩展。显式地指定用零填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%%</literal> - 被替换为<literal>%</literal>。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
        从一个时间戳中减去另一个时间戳并且把结果保存在一个区间类型的变量中。
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从<literal>ts1</>指向的时间戳变量中减去<literal>ts2</>指向的时间戳变量，并且将把结果存储在<literal>iv</>指向的区间变量中。
       </para>
       <para>
        成功时，该函数返回 0；发生错误时则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
        Parse a timestamp value from its textual representation using a
        formatting mask.
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        The function receives the textual representation of a timestamp in the
        variable <literal>str</> as well as the formatting mask to use in the
        variable <literal>fmt</>. The result will be stored in the variable
        that <literal>d</> points to.
       </para>
       <para>
        If the formatting mask <literal>fmt</> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
       </para>
       <para>
        This is the reverse function to <xref
        linkend="PGTYPEStimestampfmtasc">.  See the documentation there in
        order to find out about the possible formatting mask entries.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
        Add an interval variable to a timestamp variable.
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function receives a pointer to a timestamp variable <literal>tin</>
        and a pointer to an interval variable <literal>span</>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</> points to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
        Subtract an interval variable from a timestamp variable.
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function subtracts the interval variable that <literal>span</>
        points to from the timestamp variable that <literal>tin</> points to
        and saves the result into the variable that <literal>tout</> points
        to.
       </para>
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
   <title>区间类型</title>
   <para>
    C 中的区间类型允许你的程序处理 SQL 区间类型的数据。<productname>PostgreSQL</>服务器的等效类型可见<xref linkend="datatype-datetime">。
   </para>
   <para>
    下列函数可以用于区间类型：
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        返回一个指向新分配的区间变量的指针。
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        释放先前分配的区间变量的内存。
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        从文本表达解析一个区间。
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        该函数解析输入字符串<literal>str</>并且返回一个已分配的区间变量的指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        将一个区间类型的变量转换成它的文本表达。
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        该函数将<literal>span</>指向的区间变量转换成一个 C char*。输出看起来像这个例子：
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        复制一个区间类型的变量。
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
        该函数将<literal>intvlsrc</>指向的区间变量复制到<literal>intvldest</>指向的区间变量。注意你需要现为目标变量分配好内存。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
   <title>decimal类型</title>
   <para>
     decimal类型和numeric类型相似。不过，它被限制为最大精度是 30 个有效位。与numeric类型只能在堆上创建相反，decimal类型既可以在栈上也可以在堆上创建（使用函数<function>PGTYPESdecimal_new</> 和<function>PGTYPESdecimal_free</>）。在<xref linkend="ecpg-informix-compat">中描述的<productname>Informix</productname>兼容模式中有很多其它函数可以处理decimal类型。
   </para>
   <para>
    下列函数可以被用于decimal类型并且不仅被包含于<literal>libcompat</>库中。
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       要求一个指向新分配的decimal变量的指针。
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       释放一个decimal类型，释放它的所有内存。
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
    <title>pgtypeslib 的 errno 值</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        一个参数应该包含一个numeric变量（或者指向一个numeric变量），但是实际上它的内存表达非法。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        发生一次溢出。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致溢出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        发生一次下溢。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致下溢。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        尝试了一次除零。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        一个非法的日期字符串被传给了<function>PGTYPESdate_from_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        非法参数被传给了<function>PGTYPESdate_defmt_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数在输入字符串中发现了一个非法记号。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        一个非法的区间字符串被传给了<function>PGTYPESinterval_from_asc</function>函数，或者一个非法的区间值被传给了<function>PGTYPESinterval_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        在<function>PGTYPESdate_defmt_asc</function>函数中有日/月/年不匹配的赋值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了月中的一个非法日值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了一个非法的月值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        一个非法的时间戳字符串被传给了<function>PGTYPEStimestamp_from_asc</function>函数，或者一个非法的时间戳值被传给了<function>PGTYPEStimestamp_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        在一个无法处理无限时间戳值的环境中遇到了这样一个值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
    <title>pgtypeslib 的特殊常量</title>
   <para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        表示一个非法时间戳的时间戳类型值。在解析错误时，函数<function>PGTYPEStimestamp_from_asc</>会返回这个值。注意由于<type>timestamp</type>数据类型的内部表达，<literal>PGTYPESInvalidTimestamp</literal>在同时也是一个合法的时间戳。它被设置为<literal>1899-12-31 23:59:59</>。为了检测到错误，确认你的应用在每次调用<function>PGTYPEStimestamp_from_asc</>后不仅仅测试<literal>PGTYPESInvalidTimestamp</literal>，还应该测试<literal>errno != 0</>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
  <title>使用描述符区域</title>

  <para>
   一个 SQL 描述符区域是一种处理<command>SELECT</command>、<command>FETCH</command>或者<command>DESCRIBE</command>语句结果的高级方法。一个 SQL 描述符区域把数据中一行的数据及元数据项组合到一个数据结构中。在执行动态 SQL 语句时（结果行的性质无法提前预知），元数据特别有用。PostgreSQL 提供两种方法来使用描述符区域：命名 SQL 描述符区域和 C 结构 SQLDA。
  </para>

  <sect2 id="ecpg-named-descriptors">
   <title>命名 SQL 描述符区域</title>

   <para>
    一个命名 SQL 描述符区域由一个头部以及一个或多个条目描述符区域构成，头部包含与整个描述符相关的信息，而条目描述符区域则描述结果行中的每一列。
   </para>

   <para>
    在使用 SQL 描述符区域之前，需要先分配一个：
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    identifier 会作为该描述符区域的<quote>变量名</quote>。<remark>分配的描述符的范围有多大？</remark>当不再需要该描述符时，应当释放它：
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>

   <para>
    要使用一个描述符区域，把它指定为<literal>INTO</literal>子句的存储目标（而不是列出主变量）：
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    如果结果集为空，该描述符区域仍然会包含查询的元数据，即域的名称。
   </para>

   <para>
    对于还没有执行的预备查询，<command>DESCRIBE</command>可以被用来得到其结果集的元数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>

   <para>
    在 PostgreSQL 9.0 之前，<literal>SQL</literal>关键词是可选的，因此使用<literal>DESCRIPTOR</literal>和<literal>SQL DESCRIPTOR</literal>都会产生命名 SQL 描述符区域。现在该关键词是强制性的，省略<literal>SQL</literal>关键词会产生 SQLDA 描述符区域（见<xref linkend="ecpg-sqlda-descriptors">）。
   </para>

   <para>
    在<command>DESCRIBE</command>和<command>FETCH</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的使用相似：它们产生结果集以及一个描述符区域中的元数据。
   </para>

   <para>
    现在我们如何从描述符区域得到数据呢？你可以把描述符区域看成是一个具有命名域的结构。要从头部检索一个域的值并且把它存储到一个主变量中，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    当前，只定义了一个头部域：<replaceable>COUNT</replaceable>，它告诉我们有多少个条目描述符区域（也就是，结果中包含多少列）。主变量需要是一个整数类型。要从条目描述符区域中得到一个域，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <replaceable>num</replaceable>可以是一个字面整数或者包含一个整数的主变量。可能的域有：

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> （整数）</term>
      <listitem>
       <para>
        结果集中的行数
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        实际的数据项（因此，这个域的数据类型取决于查询）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> （整数）</term>
      <listitem>
       <para>
        当<literal>TYPE</literal>是<literal>9</literal>时，
        <literal>DATETIME_INTERVAL_CODE</literal>将具有以下值之一：
        <literal>1</literal> 表示 <literal>DATE</literal>，
        <literal>2</literal> 表示 <literal>TIME</literal>，
        <literal>3</literal> 表示 <literal>TIMESTAMP</literal>，
        <literal>4</literal> 表示 <literal>TIME WITH TIME ZONE</literal>，
        <literal>5</literal> 表示 <literal>TIMESTAMP WITH TIME ZONE</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> （整数）</term>
      <listitem>
       <para>
        指示符（表示一个空值或者一个值截断）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        列名
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        精度（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> （整数）</term>
      <listitem>
       <para>
        比例（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> （整数）</term>
      <listitem>
       <para>
        列的数据类型的数字编码
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    在<command>EXECUTE</command>、<command>DECLARE</command>以及<command>OPEN</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的效果不同。也可以手工建立一个描述符区域来为一个查询或者游标提供输入参数，并且<literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>是用来传递输入参数给参数化查询的方法。建立一个命名 SQL 描述符区域的语句如下：
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>

   <para>
    PostgreSQL 支持在一个<command>FETCH</command>语句中检索多于一个记录并且在这种情况下把主变量假定为一个数组来存储数据。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
   <title>SQLDA 描述符区域</title>

   <para>
    SQLDA 描述符区域是一个 C 语言结构，它也能被用来得到一个查询的结果集和元数据。一个结构存储一个来自结果集的记录。
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    注意<literal>SQL</literal>关键词被省略了。<xref linkend="ecpg-named-descriptors">中关于<literal>INTO</literal>和<literal>USING</literal>关键词用例的段落在一定条件下也适用于这里。在一个<command>DESCRIBE</command>语句中，如果使用了<literal>INTO</literal>关键词，则<literal>DESCRIPTOR</literal>关键词可以完全被省略：
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>

    <procedure>
     <para>
      使用 SQLDA 的程序的一般流程是：
     </para>
     <step><simpara>准备一个查询，并且为它声明一个游标。</simpara></step>
     <step><simpara>为结果行声明一个 SQLDA 。</simpara></step>
     <step><simpara>为输入参数声明一个 SQLDA，并且初始化它们（内存分配、参数设置）。</simpara></step>
     <step><simpara>用输入 SQLDA 打开一个游标。</simpara></step>
     <step><simpara>从游标中取得行，并且把它们存储到一个输出 SQLDA。</simpara></step>
     <step><simpara>从输出 SQLDA 读取值到主变量中（必要时使用转换）。</simpara></step>
     <step><simpara>关闭游标。</simpara></step>
     <step><simpara>关闭为输入 SQLDA 分配的内存区域。</simpara></step>
    </procedure>

   <sect3>
    <title>SQLDA 数据结构</title>

    <para>
     SQLDA 使用三种数据结构类型：<type>sqlda_t</type>、<type>sqlvar_t</type>以及<type>struct sqlname</type>。
    </para>

    <tip>
     <para>
      PostgreSQL 的 SQLDA 与 IBM DB2 Unversal 数据库中相似的数据结构，因此一些 DB2 的 SQLDA 的技术信息有助于更好地理解 PostgreSQL 的 SQLDA。
     </para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
     <title>sqlda_t 结构</title>

     <para>
      结构类型<type>sqlda_t</type>是实际 SQLDA 的类型。它保存一个记录。并且两个或者更多个<type>sqlda_t</type>结构能够以<structfield>desc_next</structfield>域中的指针连接成一个链表，这样可以表示一个有序的行集合。因此，当两个或多个行被取得时，应用可以通过沿着每一个<type>sqlda_t</type>节点中的<structfield>desc_next</structfield>指针读取它们。
     </para>

     <para>
      <type>sqlda_t</type>的定义是：
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

      域的含义是：

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</></term>
      <listitem>
       <para>
        它包含一个字符串<literal>"SQLDA  "</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</></term>
      <listitem>
       <para>
        它包含已分配空间的尺寸（以字节计）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</></term>
      <listitem>
       <para>
        它包含用于一个参数化查询实例的输入参数的数目，它被传递给使用<literal>USING</literal>关键词的<command>OPEN</command>、<command>DECLARE</command>或者<command>EXECUTE</command>语句。在它被用作<command>SELECT</command>、<command>EXECUTE</command>或<command>FETCH</command>语句的输出时，它的值和<literal>sqld</literal>一样
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</></term>
      <listitem>
       <para>
        它包含一个结果集中的域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</></term>
      <listitem>
       <para>
        如果查询返回不止一个记录，会返回多个链接在一起的 SQLDA 结构，并且<literal>desc_next</>保存一个指向下一个项的指针。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</></term>
      <listitem>
       <para>
        这是结果集中列的数组。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
     <title>sqlvar_t 结构</title>

     <para>
      结构类型<type>sqlvar_t</type>保存一个列值和元数据（例如类型和长度）。该类型的定义是：

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

      各个域的含义是：

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</></term>
          <listitem>
           <para>
            包含该域的类型标识符。值可以参考<literal>ecpgtype.h</literal>中的<literal>enum ECPGttype</literal>。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</></term>
          <listitem>
           <para>
            包含域的二进制长度，例如<type>ECPGt_int</type>是 4 字节。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</></term>
          <listitem>
           <para>
            指向数据。数据的格式在<xref linkend="ecpg-variables-type-mapping">中描述。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</></term>
          <listitem>
           <para>
            指向空指示符。0 表示非空，-1 表示空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</></term>
          <listitem>
           <para>
            域的名称。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
     <title>struct sqlname 结构</title>

     <para>
      一个<type>struct sqlname</type>结构保持一个列名。它被用作<type>sqlvar_t</type>结构的一个成员。该结构的定义是：
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      各个域的含义是：
            <variablelist>
             <varlistentry>
              <term><literal>length</></term>
               <listitem>
                <para>
                 包含域名称的长度。
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</></term>
               <listitem>
                <para>
                 包含实际的域名称。
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
    <title>使用一个 SQLDA 检索一个结果集</title>

    <procedure>
     <para>
      通过一个 SQLDA 检索一个查询结果集的一般步骤是：
     </para>
     <step><simpara>声明一个<type>sqlda_t</type>结构来接收结果集。</simpara></step>
     <step><simpara>执行 <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> 命令来处理一个指定已声明 SQLDA 的查询。</simpara></step>
     <step><simpara>通过查看<type>sqlda_t</type>结构的成员<structfield>sqln</>来检查结果集中记录的数量。</simpara></step>
     <step><simpara>从<type>sqlda_t</type>结构的成员<literal>sqlvar[0]</>、<literal>sqlvar[1]</>等中得到每一列的值。</simpara></step>
     <step><simpara>沿着<type>sqlda_t</type>结构的成员<structfield>desc_next</>指针到达下一行（<type>sqlda_t</type>）。</simpara></step>
     <step><simpara>根据你的需要重复上述步骤。</simpara></step>
    </procedure>

    <para>
     这里是一个通过 SQLDA 检索结果集的例子。
    </para>

    <para>
     首先，声明一个<type>sqlda_t</type>结构来接收结果集。
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>

    <para>
     接下来，指定一个命令中的 SQLDA。这是一个<command>FETCH</>命令的例子。
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

    <para>
     运行一个循环顺着链表来检索行。
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>

    <para>
     在循环内部，运行另一个循环来检索行中每一列的数据（<type>sqlvar_t</type>结构）。
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>

    <para>
     要得到一列的值，应检查<type>sqlvar_t</type>结构的成员<structfield>sqltype</>的值。然后，根据列类型切换到一种合适的方法从<structfield>sqlvar</>域中复制数据到一个主变量。
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
    <title>使用一个 SQLDA 传递查询参数</title>

    <procedure>
     <para>
      使用一个 SQLDA 传递输入参数给一个预备查询的一般步骤是：
     </para>
     <step><simpara>创建一个预备查询（预备语句）。</simpara></step>
     <step><simpara>声明一个 sqlda_t 结构作为输入 SQLDA。</simpara></step>
     <step><simpara>为输入 SQLDA 分配内存区域（作为 sqlda_t 结构）。</simpara></step>
     <step><simpara>在分配好的内存中设置（复制）输入值。</simpara></step>
     <step><simpara>打开一个说明了输入 SQLDA 的游标。</simpara></step>
    </procedure>

    <para>
     这里是一个例子。
    </para>

    <para>
     首先，创建一个预备语句。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>

    <para>
     接下来为一个 SQLDA 分配内存，并且在<type>sqlda_t</type>结构的<structfield>sqln</>成员变量中设置输入参数的数量。当预备查询要求两个或多个输入参数时，应用必须分配额外的内存空间，空间的大小为 (参数数目 - 1) * sizeof(sqlvar_t)。这里的例子展示了为两个输入参数分配内存空间。
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* 输入变量的数目 */
</programlisting>
    </para>

    <para>
     内存分配之后，把参数值存储到<literal>sqlvar[]</literal>数组（当 SQLDA 在接收结果集时，这也是用来检索列值的数组）。在这个例子中，输入参数是<literal>"postgres"</literal>（字符串类型）和<literal>1</literal>（整数类型）。
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

    <para>
     通过打开一个游标并且说明之前已经建立好的 SQLDA，输入参数被传递给预备语句。
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

    <para>
     最后，用完输入 SQLDA 后必须显式地释放已分配的内存空间，这与用于接收查询结果的 SQLDA 不同。
<programlisting>
free(sqlda2);
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-example">
    <title>一个使用 SQLDA 的应用例子</title>

    <para>
     这里是一个例子程序，它描述了如何按照输入参数的指定从系统目录中取得数据库的访问统计。
    </para>

    <para>
     这个应用在数据库 OID 上连接两个系统表（pg_database 和 pg_stat_database），并且还取得和显示通过两个输入参数（一个数据库<literal>postgres</literal>和 OID <literal>1</literal>）检索到的数据库统计。
    </para>

    <para>
     首先，为输入和输出分别声明一个 SQLDA。
<programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 一个输出描述符 */
sqlda_t *sqlda2; /* 一个输入描述符  */
</programlisting>
    </para>

    <para>
     接下来，连接到数据库，准备一个语句并且为预备语句声明一个游标。
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>

    <para>
     然后，为输入参数在输入 SQLDA 中放入一些值。为输入 SQLDA 分配内存，并且在<literal>sqln</literal>中设置输入参数的数目。在<literal>sqlvar</literal>结构的<literal>sqltype</literal>、<literal>sqldata</literal>和<literal>sqllen</literal>中存入类型、值和值长度。

<programlisting>
    /* 为输入参数创建 SQLDA 结构。 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

    <para>
     设置完输入 SQLDA 之后，用输入 SQLDA 打开一个游标。

<programlisting>
    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

    <para>
     从打开的游标中取行到输出 SQLDA 中（通常，你不得不在循环中反复调用<command>FETCH</command>来取出结果集中的所有行）。
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 分配描述符给游标  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

    <para>
     再后，沿着<type>sqlda_t</type>结构的链表从 SQLDA 中检索取得的记录。
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>

    <para>
     读取第一个记录中的每一列。列的数量被存储在<structfield>sqld</>中，第一列的实际数据被存储在<literal>sqlvar[0]</>中，两者都是<type>sqlda_t</type>结构的成员。

<programlisting>
        /* 打印一行中的每一列。 */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>

    <para>
     现在，列数据已经被存在了变量<varname>v</>中。把每个数据复制到主变量中，列的类型可以查看。
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* 整数 */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>

    <para>
     处理所有记录后关闭游标，并且从数据库断开连接。
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>

    <para>
     整个程序显示在<xref linkend="ecpg-sqlda-example-example">中。
    </para>

    <example id="ecpg-sqlda-example-example">
     <title>示例 SQLDA 程序</title>
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 用于输出的描述符 */
sqlda_t *sqlda2; /* 用于输入的描述符 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* 为一个输入参数创建一个 SQLDA 结构 */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 给游标分配描述符  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* 打印一行中的每一列。 */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* 整数 */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* 大整数 */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>

     <para>
      这个例子的输出应该看起来类似下面的结果（一些数字会变化）。
     </para>

<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
  <title>错误处理</title>

  <para>
   这一节描述在一个嵌入式 SQL 程序中如何处理异常情况和警告。有两种非互斥的工具可以用于这个目的。

   <itemizedlist>
    <listitem>
     <simpara>
      可以使用<literal>WHENEVER</literal>命令配置回调来处理警告和错误情况。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      可以从<varname>sqlca</varname>变量中获得错误或警告的详细信息。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <sect2 id="ecpg-whenever">
   <title>设置回调</title>

   <para>
    一种捕捉错误和警告的简单方法是设置一个特殊的动作，只要一个特定情况发生就执行该动作。通常是这样：
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>

   <para>
    <replaceable>condition</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个错误就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个警告就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        只要一个 SQL 语句检索或者影响零行就调用指定的动作（这种情况不是一个错误，但是你可能需要特别地处理它）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <replaceable>action</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        这实际上表示该情况被忽略。这是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        调到指定的标签（使用一个 C <literal>goto</literal>语句）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        把一个消息打印到标准错误。对于简单程序或原型开发中这很有用。消息的细节无法配置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        调用<literal>exit(1)</literal>终止程序。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        执行 C 语句<literal>break</literal>。只应被用在循环或<literal>switch</literal>语句中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        用指定参数调用指定的 C 函数。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    SQL 标准只提供动作<literal>CONTINUE</literal>和<literal>GOTO</literal>（以及<literal>GO TO</literal>）。
   </para>

   <para>
    这里有一个可能会用在简单程序中的例子。当一个警告发生时它打印一个简单消息，而发生一个错误时它会中止程序：
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>

   <para>
    语句<literal>EXEC SQL WHENEVER</literal>是 SQL 预处理器的一个指令，而不是一个 C 语句。不管 C 程序的控制流程如何，该语句设置的错误或警告动作适用于所有位于处理程序设置点之后的嵌入式 SQL 语句，除非在第一个<literal>EXEC SQL WHENEVER</literal>和导致情况的 SQL 语句之间为同一个情况设置了不同的动作。因此下面的两个 C 程序都不会得到预期的效果：
<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlca">
   <title>sqlca</title>

   <para>
    为了更强大的错误处理，嵌入式 SQL 接口提供了一个名为<varname>sqlca</varname>（SQL 通讯区域）的全局变量，它具有下面的结构：
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    （在一个多线程程序中，每一个线程会自动得到它自己的<varname>sqlca</varname>副本。这和对于标准 C 全局变量<varname>errno</varname>的处理相似。）
   </para>

   <para>
    <varname>sqlca</varname>覆盖了警告和错误。如果执行一个语句时发生了多个警告或错误，那么<varname>sqlca</varname>将只包含关于最后一个的信息。
   </para>

   <para>
    如果在上一个<acronym>SQL</acronym>语句中没有产生错误，<literal>sqlca.sqlcode</literal>将为 0 并且<literal>sqlca.sqlstate</literal>将为<literal>"00000"</literal>。如果发生一个警告或错误，则<literal>sqlca.sqlcode</literal>将为负并且<literal>sqlca.sqlstate</literal>将不为<literal>"00000"</literal>。一个正的<literal>sqlca.sqlcode</literal>表示一种无害的情况，例如上一个查询返回零行。<literal>sqlcode</literal>和<literal>sqlstate</literal>是两种不同的错误代码模式，详见下文。
   </para>

   <para>
    如果上一个 SQL 语句成功，那么<literal>sqlca.sqlerrd[1]</literal>包含被处理行的 OID （如果可用），并且<literal>sqlca.sqlerrd[2]</literal>包含被处理或被返回的行数（如果适用于该命令）。
   </para>

   <para>
    在发生一个错误或警告的情况下，<literal>sqlca.sqlerrm.sqlerrmc</literal>将包含一个描述该错误的字符串。域<literal>sqlca.sqlerrm.sqlerrml</literal>包含存储在<literal>sqlca.sqlerrm.sqlerrmc</literal>中错误消息的长度（<function>strlen()</function>的结果，对于一个 C 程序员来说并不感兴趣）。注意一些消息可能太长不能适应定长的<literal>sqlerrmc</literal>数组，它们将被截断。
   </para>

   <para>
    在发生一个警告的情况下，<literal>sqlca.sqlwarn[2]</literal>被设置为<literal>W</literal>（在所有其他情况中，它被设置为不同于<literal>W</literal>的东西）。如果<literal>sqlca.sqlwarn[1]</literal>被设置为<literal>W</literal>，那么一个值被存储在一个主变量中时会被截断。如果任意其他元素被设置为指示一个警告，<literal>sqlca.sqlwarn[0]</literal>会被设置为<literal>W</literal>。
   </para>

   <para>
    域<structfield>sqlcaid</structfield>、
    <structfield>sqlcabc</structfield>、
    <structfield>sqlerrp</structfield>以及
    <structfield>sqlerrd</structfield>的剩余元素还有
    <structfield>sqlwarn</structfield>当前不包含有用的信息。
   </para>

   <para>
    SQL 标准中没有定义<varname>sqlca</varname>结构，但是在一些其他的 SQL 数据系统中都有实现。在核心上这些定义都想死，但是如果你想要编写可移植的应用，那么你应该仔细研究不同的实现。
   </para>

   <para>
    这里有一个整合使用<literal>WHENEVER</>和<varname>sqlca</varname>的例子，当一个错误发生时打印出<varname>sqlca</varname>的内容。在安装一个更<quote>用户友好</quote>的错误处理器之前，这可能对调试或开发原型应用有用。

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

    结果看起来像（这里的错误是一个拼写错误的表名）：

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
   <title><literal>SQLSTATE</literal> 与 <literal>SQLCODE</literal></title>

   <para>
    域<literal>sqlca.sqlstate</literal>以及<literal>sqlca.sqlcode</literal>是提供错误代码的两种不同模式。两种都源自于 SQL 标准，但是在标准的 SQL-92 版本中<literal>SQLCODE</literal>已经被标记为弃用并且在后面的版本中被删除。因此，强烈建议新应用使用<literal>SQLSTATE</literal>。
   </para>

   <para>
    <literal>SQLSTATE</literal>是一个五字符数组。这五个字符包含数字或大写字母，它表示多种错误或警告情况的代码。<literal>SQLSTATE</literal>具有一种层次模式：前两个字符表示情况的总体分类，后三个字符表示总体情况的子类。代码<literal>00000</literal>表示一种成功的状态。SQL 标准中的大部分都有对应的<literal>SQLSTATE</literal>代码。<productname>PostgreSQL</productname>服务器本地支持<literal>SQLSTATE</literal>错误代码，因此通过在所有应用中自始至终使用这种错误代码模式可以实现高度的一致性。进一步的信息请见<xref linkend="errcodes-appendix">。
   </para>

   <para>
    被弃用的错误代码模式<literal>SQLCODE</literal>是一个简单的整数。值为 0 表示成功，一个正值表示带附加信息的成功，一个负值表示一个错误。SQL 标准只定义了正值 +100，它表示上一个命令返回或者影响了零行，并且没有特定的负值。因此，这种模式只能实现很可怜的可移植性并且不具有层次性的代码分配。历史上，<productname>PostgreSQL</productname>的嵌入式 SQL 处理器已经分配了一些特定的<literal>SQLCODE</literal>值供它使用，它们的数字值和符号名称被列在下文。记住这些对其他 SQL 实现不是可移植的。为了简化移植应用到<literal>SQLSTATE</literal>模式，对应的<literal>SQLSTATE</literal>也被列出。不过，在两种模式之间没有一对一或者一对多的映射（事实上是多对多），因此在每一种情况下你都应该参考<xref linkend="errcodes-appendix">中列出的全局<literal>SQLSTATE</literal>。
   </para>

   <para>
    这些是已分配的<literal>SQLCODE</literal>值：

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        表示没有错误（SQLSTATE 00000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       这是一种无害情况，它表示上一个命令检索或者处理了零行，或者你到达了游标的末尾（SQLSTATE 02000）。
      </para>

      <para>
       在一个循环中处理一个游标时，你可以使用这个代码作为一种方法来检测何时中止该循环，像这样：
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
       但是<literal>WHENEVER NOT FOUND DO BREAK</literal>实际上会在内部这样做，因此显式地把它写出来通常没有什么好处。
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        表示你的虚拟内存已被耗尽。数字值被定义为<literal>-ENOMEM</literal>（SQLSTATE YE001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       表示预处理器已经产生了一些该库不知道的东西。也许你正在运行一个不兼容版本的预处理和库（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定了超过该命令预期数量的主变量（SQLSTATE 07001 或 07002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定的主变量数量低于该命令的预期（SQLSTATE 07001 或 07002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       这意味着一个查询已经返回了多个行，但是该语句只准备存储一个结果行（例如，因为指定的变量不是数组）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>int</type>的值。该库使用<function>strtol()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>unsigned int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>unsigned int</type>的值。该库使用<function>strtoul()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>float</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>float</type>的值。该库使用<function>strtod()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>numeric</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>numeric</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>interval</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>interval</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>date</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>date</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>timestamp</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>timestamp</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       这表示主变量是类型<type>bool</type>而数据库中的数据既不是<literal>'t'</>也不是<literal>'f'</>（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       发送给<productname>PostgreSQL</productname>服务器的语句是空的（通常在一个嵌入式 SQL 程序中不会发生，因此它可能指向一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       返回了一个空值并且没有提供空值指示符（SQLSTATE 22002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在要求一个数组的地方使用了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在一个要求数组值的地方数据库返回了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- disabled by #if 0 in ecpglib -->
    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       该值不能被插入到数组（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个不存在的连接（SQLSTATE 08003）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个存在的连接但是它没有打开（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       你尝试使用的语句还没有被准备好（SQLSTATE 26000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（Informix 兼容模式）（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       没有找到指定的描述符。你尝试使用的语句还没有被准备好（SQLSTATE 33000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       指定的描述符超出范围（SQLSTATE 07009）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       请求了一个非法的描述符（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个numeric值而主变量不是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个非numeric值而主变量是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（Informix 兼容模式）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器导致了某个错误。该消息包含来自<productname>PostgreSQL</productname>服务器的错误消息。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器通知我们不能启动、提交或回滚事务（SQLSTATE 08007）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       到数据库的连接尝试没有成功（SQLSTATE 08001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- currently not used by the code -->
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       从服务器接收到一个无法识别的警告。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       当前事务被中止。到事务块末尾的查询被忽略。
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
       指定了一个非法的游标名（SQLSTATE 34000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       事务正在进行（SQLSTATE 25001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       没有活动（正在进行）的事务（SQLSTATE 25P01）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
       指定了一个现有的游标名（SQLSTATE 42P03）。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
  <title>预处理器指令</title>

  <para>
   一些预处理器指令可以用来改变<command>ecpg</command>预处理器解析和处理一个文件的方式。
  </para>

  <sect2 id="ecpg-include">
   <title>包括文件</title>

   <para>
    要包括一个外部文件到你的嵌入式 SQL 程序中，可以用：
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    嵌入式 SQL 预处理器将查找一个名为<literal><replaceable>filename</replaceable>.h</literal>的文件，处理它并且把它包括在结果 C 输出中。这样，被包括文件中的嵌入式 SQL 语句会被正确地处理。
   </para>

   <para>
    <command>ecpg</command>预处理器将以下列顺序在几个目录中搜索一个文件：

    <itemizedlist>
     <listitem><simpara>当前目录</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL 的包括目录，在编译时定义（例如<filename>/usr/local/pgsql/include</filename>）</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    但是当使用<literal>EXEC SQL INCLUDE "<replaceable>filename</replaceable>"</literal>时，只有当前目录会被搜索。
   </para>

   <para>
    在每一个目录中，预处理器将首先按给定的文件名搜索，如果没有找到将会追加<literal>.h</literal>到文件名并且重试（除非指定的文件名已经具有该后缀）。
   </para>

   <para>
    注意<command>EXEC SQL INCLUDE</command><emphasis>不</emphasis>同于：
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    因为这个文件不服从 SQL 命令预处理。自然地，你可以继续使用 C 的<literal>#include</literal>指令来包括其他头文件。
   </para>

   <note>
    <para>
     包括文件名是大小写敏感的，即使<literal>EXEC SQL INCLUDE</literal>命令的剩余部分遵守通常的 SQL 大小写敏感规则。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
   <title>define 和 undef 指令</title>
   <para>
    与 C 中我们熟知的指令<literal>#define</literal>相似，嵌入式 SQL 具有类似的概念：
<programlisting>
EXEC SQL DEFINE <replaceable>name</>;
EXEC SQL DEFINE <replaceable>name</> <replaceable>value</>;
</programlisting>
    因此你可以定义一个名称：
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    并且你也可以定义常量：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    使用<literal>undef</>来移除一个之前的定义：
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>

   <para>
    当然在你的嵌入式 SQL 程序中你可以继续使用 C 版本的<literal>#define</literal>和<literal>#undef</literal>。区别在于你定义的值会在哪里被计算。如果你使用<literal>EXEC SQL DEFINE</>，那么<command>ecpg</>预处理器会计算这些定义并且替换值。例如，如果你写：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    那么<command>ecpg</>将已经做过替换并且你的 C 编译器将永远不会看见名为<literal>MYNUMBER</>的任何名称或标识符。注意你不能把<literal>#define</literal>用于一个将要在一个嵌入式 SQL 查询中使用的常量，因为在这种情况下嵌入式 SQL 预编译器不能看到这个声明。
   </para>
  </sect2>

  <sect2 id="ecpg-ifdef">
   <title>ifdef、ifndef、else、elif 以及 endif 指令</title>
   <para>
   你可以使用下列指定来有条件地编译代码小节：

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      检查一个<replaceable>name</>，如果已经用<literal>EXEC SQL define <replaceable>name</></literal>创建了<replaceable>name</>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
     检查一个<replaceable>name</>，如果<emphasis>没有</emphasis>用<literal>EXEC SQL define <replaceable>name</></literal>创建<replaceable>name</>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      为一个由<literal>EXEC SQL ifdef <replaceable>name</></literal>或者<literal>EXEC SQL ifndef <replaceable>name</></literal>引入的小节开始处理一个备选小节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</>;</literal></term>
     <listitem>
     <para>
      检查<replaceable>name</>，如果已经用<literal>EXEC SQL define <replaceable>name</></literal>创建了<replaceable>name</>就开始处理一个备选小节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      结束一个备选小节。
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>

   <para>
    例子：
<programlisting>
EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;
</programlisting>
   </para>

  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
  <title>处理嵌入式 SQL 程序</title>

  <para>
   现在你已经对如何构造嵌入式 SQL C 程序有所了解了，你可能希望知道如何编译它们。在编译之前，你需要让该文件通过嵌入式<acronym>SQL</acronym> <acronym>C</acronym>预处理器，它会把你用到的<acronym>SQL</acronym>转换成特殊的函数调用。在编译之后，你必须链接一个包含所需函数的特殊库。这些函数从参数中取得信息、使用<application>libpq</application>执行<acronym>SQL</acronym>命令并且把结果放在指定的参数中用来输出。
  </para>

  <para>
   该预处理器程序被称作<filename>ecpg</filename>并且被包括在一个正常的<productname>PostgreSQL</>安装中。嵌入式 SQL 程序通常带有扩展名<filename>.pgc</filename>。如果你有一个程序文件<filename>prog1.pgc</filename>，你可以调用下面的命令对它进行预处理：
<programlisting>
ecpg prog1.pgc
</programlisting>
   这将创建一个文件<filename>prog1.c</filename>。如果你的输入文件不遵循建议的命名模式，你可以用<option>-o</option>选项显式地指定输出文件。
  </para>

  <para>
   预处理过的文件可以被正常地编译，例如：
<programlisting>
cc -c prog1.c
</programlisting>
   产生的 C 源文件从<productname>PostgreSQL</>安装中包括头文件，因此如果你把<productname>PostgreSQL</>安装在一个不被默认搜索的位置，你必须在编译命令行中增加一个选项（例如<literal>-I/usr/local/pgsql/include</literal>）。
  </para>

  <para>
   要链接一个嵌入式 SQL 程序，你需要包括<filename>libecpg</filename>库，像这样：
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
   再次，你可能不得不在命令行中增加类似<literal>-L/usr/local/pgsql/lib</literal>的选项。
  </para>

  <para>
   你可以使用<command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   或者<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> 加上包名<literal>libecpg</literal>来得到你的安装路径。
  </para>

  <para>
   如果你使用<application>make</application>来管理一个大工程的构建过程，把下面的隐式规则包括在你的 makefile 中将会很方便：
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>

  <para>
   <command>ecpg</command>命令的完整语法可见<xref linkend="app-ecpg">。
  </para>

  <para>
   <application>ecpg</application>库默认是线程安全的。不过，你可能需要使用一些线程命令行选项来编译你的客户端代码。
  </para>
 </sect1>

 <sect1 id="ecpg-library">
  <title>库函数</title>

  <para>
   <filename>libecpg</filename>库主要包含用于实现嵌入式 SQL 命令所表达功能的<quote>隐藏</quote>函数。但是也有一些可以被直接调用的函数。但是注意这会让你的代码不可移植。
  </para>

  <itemizedlist>
   <listitem>
    <para>
     如果调用时第一个参数非零，<function>ECPGdebug(int <replaceable>on</replaceable>, FILE *<replaceable>stream</replaceable>)</function>会打开调试日志。调试日志在<replaceable>流</replaceable>上完成。该日志包含所有插入了输入变量的<acronym>SQL</acronym>语句，以及来自于<productname>PostgreSQL</productname>服务器的结果。在你的<acronym>SQL</acronym>语句中查找错误时这会非常有用。
    </para>
    <note>
    <para>
    在 Windows 上，如果<application>ecpg</>库和应用使用不同标志编译的，这个函数调用将会是应用崩溃，因为<literal>FILE</>指针的内部表达不同。特别地，库和使用库的应用应该使用相同的多线程/单线程、发行/调试以及静态/动态标志。
    </para>
    </note>
   </listitem>

   <listitem>
     <para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function>返回由给定名称标识的库数据库连接句柄。如果<replaceable>connection_name</replaceable>被设置为<literal>NULL</literal>，当前连接句柄将被返回。如果无法定位到连接句柄，该函数返回<literal>NULL</literal>。如果需要，返回的连接句柄可以被用来调用任何其他来自于<application>libpq</application>的函数。
     </para>
     <note>
     <para>
       直接使用<application>libpq</application>例程来操纵<application>ecpg</application>中建立的数据库连接句柄是一种糟糕的做法。
     </para>
     </note>
   </listitem>

   <listitem>
     <para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>返回由<replaceable>connection_name</replaceable>标识的给定连接的当前事务状态。关于返回的状态代码请参考<xref linkend="libpq-status">和 libpq 的<function>PQtransactionStatus()</function>。
     </para>
   </listitem>

   <listitem>
    <para>
     如果你连接到了一个数据库，<function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>会返回真；否则返回假。
     如果使用的是一个单一连接，<replaceable>connection_name</replaceable>可以为<literal>NULL</>。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
  <title>大对象</title>

  <para>
   ECPG 并不直接支持大对象，在调用<function>ECPGget_PGconn()</function>函数获得所需的<type>PGconn</type>对象后，ECPG 应用能通过 libpq 大对象函数操纵大对象（不过，对<function>ECPGget_PGconn()</function>函数的使用以及直接接触<type>PGconn</type>对象都必须非常小心，并且最好不要与其他 ECPG 数据库访问调用混合在一起）。
  </para>

  <para>
   更多关于<function>ECPGget_PGconn()</function>的细节可见<xref linkend="ecpg-library">。大对象函数接口的相关信息可见<xref linkend="largeObjects">。
  </para>

  <para>
   大对象函数必须在一个事务块中被调用，因此当自动提交关闭时，必须显式地发出<command>BEGIN</command>命令。
  </para>

  <para>
   <xref linkend="ecpg-lo-example">给出了一个例子程序，它展示了在一个 ECPG 应用中如何创建、写入和读取一个大对象。
  </para>

  <example id="ecpg-lo-example">
   <title>访问大对象的 ECPG 程序</title>
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* 创建 */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* 写入测试 */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* 读取测试 */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* 检查 */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* 清理 */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
  <title><acronym>C++</acronym> 应用</title>

  <para>
   ECPG 对于 C++ 应用提供了有限的支持。这一节描述了一些忠告。
  </para>

  <para>
   <command>ecpg</command>预处理器采用一个用 C（或者类似 C 的东西）和嵌入式 SQL 命令编写的输入文件，把嵌入式 SQL 命令转换成 C 语言块，并且最终产生一个<filename>.c</filename>文件。在 C++ 下使用时，因此它们应该能在 C++ 中无缝地使用。
  </para>

  <para>
   不过，通常<command>ecpg</command>预处理器只理解 C，它无法处理 C++ 语言的特殊语法和保留词。因此，一些写在 C++ 应用代码中的使用了 C++ 特定复杂特性的嵌入式 SQL 代码可能无法被正确地预处理或者无法按预期工作。
  </para>

  <para>
   使用 C++ 应用中嵌入式 SQL 代码的安全方法是把 ECPG 调用隐藏在一个 C 模块中，C++ 应用代码会调用它来访问数据库，还要把它和剩余的 C++ 代码链接起来。详见<xref linkend="ecpg-cpp-and-c">。
  </para>

  <sect2 id="ecpg-cpp-scope">
   <title>主变量的可见范围</title>

   <para>
    <command>ecpg</command>预处理器能理解 C 中变量的可见范围。在 C 语言中，这是相当简单的，因为变量的可见范围是基于它们的代码块的。不过在 C++ 中，引用类成员变量的代码块是不同于定义它的代码块的，因此<command>ecpg</command>预处理器将无法理解类成员变量的可见范围。
   </para>

   <para>
    例如，在下面的情况中，<command>ecpg</command>预处理器无法为<literal>test</literal>方法中的变量<literal>dbname</literal>找到任何生命，因此将发生一个错误。

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

    这段代码将导致一个这样的错误：
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>

   <para>
    为了避免这种可见性问题，可以修改<literal>test</literal>方法来把一个本地变量用作中间存储。但是这种方法只是一种比较差的变通方案，因为它让代码变得丑陋并且降低了性能。

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-cpp-and-c">
   <title>使用外部 C 模块的 C++ 应用开发</title>

   <para>
    如果你理解了 C++ 中<command>ecpg</command>预处理器的这些技术限制，你可能已经知道在链接阶段把 C 对象和 C++ 对象链接起来让 C++ 应用能使用 ECPG 特性比直接在 C++ 代码中写一些嵌入式 SQL 命令要更好。这一节用一个简单的例子描述了一种将嵌入式 SQL 命令从 C++ 应用代码中独立出去的方法。在这个例子中，应用由 C++ 实现，而 C 和 ECPG 被用来连接到 PostgreSQL 服务器。
   </para>

   <para>
    需要创建三种文件：一个 C 文件（<filename>*.pgc</filename>）、一个头文件和一个 C++ 文件：

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
        一个执行嵌入在 C 中的 SQL 命令的子例程模块。它将被预处理器转换成<filename>test_mod.c</filename>。

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
        包含 C 模块（<filename>test_mod.pgc</filename>）中函数定义的头文件。它会被<filename>test_cpp.cpp</filename>包括。这个文件必须在声明周围有一个<literal>extern "C"</literal>块，因为它将被链接到 C++ 模块。

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
        应用的主代码，包括<function>main</function>例程以及这个例子中的一个 C++ 类。

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    要构建该应用，按以下步骤处理。通过运行<command>ecpg</command>将<filename>test_mod.pgc</>转换为<filename>test_mod.c</>，并且用 C 编译器将<filename>test_mod.c</>编译成<filename>test_mod.o</>：
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>

   <para>
    接着，用 C++ 编译器把<filename>test_cpp.cpp</>编译成<filename>test_cpp.o</>：
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>

   <para>
    最后，使用 C++ 编译器链接这些对象文件（<filename>test_cpp.o</>和<filename>test_mod.o</>）成为一个可执行文件：
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
  <title>嵌入式 SQL 命令</title>

  <para>
   这一节描述嵌入式 SQL 所有特定的 SQL 命令。<xref linkend="sql-commands">中的 SQL 命令也能被用于嵌入式 SQL，如果有例外会特别说明。
  </para>

  <refentry id="ecpg-sql-allocate-descriptor">
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>分配一个 SQL 描述符区域</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>ALLOCATE DESCRIPTOR</command>分配一个新的命名 SQL 描述符区域，它能被用来在 PostgreSQL 服务器和主程序之间交换数据。
    </para>

    <para>
     以后可以使用<command>DEALLOCATE DESCRIPTOR</command>命令释放描述符区域。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
        SQL 描述符的名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>ALLOCATE DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>建立一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>CONNECT</command>命令在客户端和 PostgreSQL 服务器之间建立一个连接。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_target</replaceable></term>
      <listitem>
       <para>
        <replaceable class="PARAMETER">connection_target</replaceable>以下列形式之一指定连接的目标服务器。

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 Unix 域套接字
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>SQL string constant</term>
          <listitem>
           <para>
            包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>host variable</term>
          <listitem>
           <para>
            类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，它包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_object</replaceable></term>
      <listitem>
       <para>
        用于该连接的一个可选标识符，这样可以在其他命令中引用它。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_user</replaceable></term>
      <listitem>
       <para>
        用于数据库连接的用户名。
       </para>

       <para>
        使用
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>、
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>或者
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>之一，这个参数也能指定用户名和口令.
       </para>

       <para>
        用户名和口令可以是 SQL 标识符、字符串常量或者主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
        按 libpq 的定义使用所有默认连接参数。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

    <para>
     这里是一些指定连接参数的变体：
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>

    <para>
     这里是一个展示使用主变量指定连接参数的例子程序：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* 数据库名 */
    char *user       = "testuser";  /* 连接用户名 */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* 连接字符串 */
    char ver[256];                  /* 存储版本字符串的缓冲区 */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>CONNECT</command>，但是连接参数的格式是与实现相关的。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>释放一个 SQL 描述符区域</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>DEALLOCATE DESCRIPTOR</command>释放一个命名的 SQL 描述符区域。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
        要被释放的描述符的名称。它是大小写敏感的。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准说明了<command>DEALLOCATE DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>定义一个游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">prepared_name</replaceable>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">query</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>DECLARE</command>声明一个游标用来在一个预备语句的结果集上迭代。这个命令与直接的 SQL 命令<command>DECLARE</command>在语义上有一点点区别：后者会执行一个查询并且准备结果集用于检索，而这个嵌入式 SQL 命令仅仅声明一个名称作为<quote>循环变量</quote>用于在一个查询的结果集上迭代，实际的执行在游标被<command>OPEN</command>命令打开时才发生。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>
    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <para>
        一个游标名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
        一个预备查询的名称，可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
       <para>
        一个提供游标要返回的行的<xref linkend="sql-select">或者<xref linkend="sql-values">命令。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     游标选项的含义请见<xref linkend="sql-declare">。
    </para>
   </refsect1>

   <refsect1>
    <title>例子</title>

    <para>
     为一个查询声明一个游标的例子：
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>

    <para>
     为一个预备语句声明一个游标的例子：
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>DECLARE</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"></member>
     <member><xref linkend="sql-close"></member>
     <member><xref linkend="sql-declare"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>得到有关一个预备语句或结果集的信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO <replaceable class="PARAMETER">sqlda_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>DESCRIBE</command>检索被一个预备语句所含的结果列的元信息，而不会实际取得一行。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
        一个预备语句的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
        一个描述符名称。它是大小写敏感的。它可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">sqlda_name</replaceable></term>
      <listitem>
       <para>
        一个 SQLDA 变量的名称。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>DESCRIBE</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>终止一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DISCONNECT <replaceable class="PARAMETER">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>DISCONNECT</command>关闭一个（或者所有）到数据库的连接。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
       <para>
        关闭<quote>当前的</quote>连接，它可以是最近打开的连接或者是由<command>SET CONNECTION</command>命令设置的连接。如果没有参数被传给<command>DISCONNECT</command>命令，这将是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
        关闭默认连接。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        关闭所有打开的连接。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* 关闭 con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* 关闭 DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* 关闭 con2 以及 con1 */

    return 0;
}
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>DISCONNECT</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>动态地准备和执行一个语句</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
EXECUTE IMMEDIATE <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>EXECUTE IMMEDIATE</command>立刻预备并且执行一个动态指定的 SQL 语句，不检索结果行。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <para>
        包含要被执行的 SQL 语句的一个 C 字符串或者是一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

    <para>
     这里是一个用<command>EXECUTE IMMEDIATE</command>和一个名为<varname>command</varname>的主变量执行<command>INSERT</command>语句的例子：
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>EXECUTE IMMEDIATE</command>。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>从一个 SQL 描述符区域得到信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">column_number</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_item</replaceable> [, ... ]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>GET DESCRIPTOR</command>从一个 SQL 描述符区域检索关于一个查询结果集的信息并且把它存储在主变量中。在使用这个命令把信息传输到主语言变量之前，一个描述符区域通常是用<command>FETCH</command>或<command>SELECT</command>填充的。
    </para>

    <para>
     这个命令有两种形式：第一种形式检索描述符的<quote>头部</quote>项，它适用于全面地查看结果集。一种例子是行计数。第二种形式要求列号作为附加参数，它检索有关一个特定列的信息。其例子是查看列名和实际列值。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
        一个描述符名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <para>
        一个标识要检索哪一个头部信息项的记号。当前只支持用于得到结果集中列数的<literal>COUNT</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column_number</replaceable></term>
      <listitem>
       <para>
        要检索其信息的列号。计数从 1 开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <para>
        一个标识要检索哪一个有关一列信息的项的记号。被支持的项可见<xref linkend="ecpg-named-descriptors">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">cvariable</replaceable></term>
      <listitem>
       <para>
        接收从描述符区域检索到的数据的主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

    <para>
     检索一个结果集中列数的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>

    <para>
     检索第一列中数据长度的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>

    <para>
     把第二列的数据体检索成一个字符串的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>

    <para>
     这里是执行<literal>SELECT current_database();</>并且显示列数、列数据长度和列数据的完整过程的例子：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* 描述、打开一个游标，并且分配一个描述符给该游标  */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* 得到全部列的数量 */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* 得到一个返回列的长度 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* 将返回的列取出成一个字符串 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* 关闭 */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     当该例子被执行时，结果看起来是：
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>GET DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>打开一个动态游标</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING <replaceable class="PARAMETER">value</replaceable> [, ... ]
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>OPEN</command>打开一个游标并且可选地绑定实际值到游标声明中的占位符。该游标必须之前用<command>DECLARE</command>命令声明。<command>OPEN</command>的执行会导致查询开始在服务器上执行。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <para>
        要被打开的游标的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
        要被绑定到游标中一个占位符的值。这可以是一个 SQL 常量、一个主变量或者一个带有指示符的主变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
        包含要绑定到游标中占位符的值的描述符的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>OPEN</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"></member>
     <member><xref linkend="sql-close"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>准备一个语句用于执行</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
PREPARE <replaceable class="PARAMETER">name</replaceable> FROM <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>PREPARE</command>将一个作为字符串动态指定的语句准备好执行。这不同于直接的 SQL 语句<xref linkend="sql-prepare">（也可以用于嵌入式程序）。<xref linkend="sql-execute">命令被用来执行两种类型的预备语句。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
        预备查询的一个标识符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <para>
        包含一个可预备语句的一个 C 字符串或一个主变量，可预备语句是 SELECT、INSERT、UPDATE 或者 DELETE 之一。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>PREPARE</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="sql-execute"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>设置当前会话的自动提交行为</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>SET AUTOCOMMIT</command>设置当前数据库会话的自动提交行为。默认情况下，嵌入式 SQL 程序<emphasis>不</emphasis>在自动提交模式中，因此需要显式地发出<command>COMMIT</command>。这个命令可以把会话改成自动提交模式，这样每一个单独的语句都会被隐式提交。
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     <command>SET AUTOCOMMIT</command>是 PostgreSQL ECPG 的扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>选择一个数据库连接</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="PARAMETER">connection_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>SET CONNECTION</command>设置<quote>当前的</quote>数据库连接，除非被覆盖，所有命令都会使用这个连接。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
        设置该连接为默认连接。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>SET CONNECTION</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-disconnect"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>在一个 SQL 描述符区域中设置信息</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">number</replaceable> <replaceable class="PARAMETER">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>SET DESCRIPTOR</command>用值填充一个 SQL 描述符区域。然后该描述符区域通常会被用来在一个预备查询执行中绑定参数。
    </para>

    <para>
     这个命令由两种形式：第一种形式适用于描述符<quote>头部</quote>，它独立于特定的数据。第二种形式为由数字标识的特定数据赋值。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
        一个描述符名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <para>
        一个标识要设置哪个头部信息项的记号。当前只有设置描述符项数量的<literal>COUNT</literal>被支持。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">number</replaceable></term>
      <listitem>
       <para>
        要设置的描述符项的编号。计数从 1 开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <para>
        一个标识在描述符中要设置哪个信息项的记号。受支持的项的列表可见<xref linkend="ecpg-named-descriptors">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
        一个要存储在描述符项中的值。这可以是一个 SQL 标识符或者一个主变量。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>SET DESCRIPTOR</command>。
    </para>
   </refsect1>

   <refsect1>
    <title>参见</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>定义一种新数据类型</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
TYPE <replaceable class="PARAMETER">type_name</replaceable> IS <replaceable class="PARAMETER">ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>TYPE</command>命令定义一个新的 C 类型。它等效于把一个<literal>typedef</literal>放在声明节中。
    </para>

    <para>
     只有使用选项<option>-c</option>运行<command>ecpg</command>时才能识别这个命令。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">type_name</replaceable></term>
      <listitem>
       <para>
        新类型的名称。这必须是一个合法的 C 类型名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <para>
        一个 C 类型说明。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>

    <para>
     这里是一个使用<command>EXEC SQL TYPE</command>的例子程序：
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

     这个程序的输出看起来像：
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     <command>TYPE</command>命令是一种 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>定义一个变量</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     <command>VAR</command>命令分配一个新的 C 数据类型给一个主变量。主变量必须之前在一个声明节中声明过。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">varname</replaceable></term>
      <listitem>
       <para>
        一个 C 变量名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <para>
        一个 C 类型说明。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     <command>VAR</command>命令是一个 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>指定一个要在一个 SQL 语句导致发生一个特定类别的情况时要采取的动作</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="PARAMETER">action</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>描述</title>

    <para>
     定义一个行为，它会在 SQL 执行结果的特殊情况（行未找到、SQL 警告或错误）中被调用。
    </para>
   </refsect1>

   <refsect1>
    <title>参数</title>

    <para>
     参数描述见<xref linkend="ecpg-whenever">。
    </para>
   </refsect1>

   <refsect1>
    <title>例子</title>

<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>

    <para>
     一个典型的应用是使用<literal>WHENEVER NOT FOUND BREAK</literal>来处理通过结果集的循环：
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* 当到达结果集末尾时，跳出循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
    <title>兼容性</title>

    <para>
     SQL 标准中说明了<command>WHENEVER</command>，但是大部分动作是 PostgreSQL 扩展。
    </para>
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
  <title><productname>Informix</productname>兼容模式</title>
  <para>
   <command>ecpg</command>可以运行在一种所谓的<firstterm>Informix 兼容模式</>中。如果这种模式被激活，它的行为就好像它是一个用于<productname>Informix</productname> E/SQL 的<productname>Informix</productname>预编译器。一般而言，这将允许你使用美元符号替代<literal>EXEC SQL</>来引入嵌入式 SQL 命令：
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>

  <note>
   <para>
    在<literal>$</literal>之间不能有任何空白以及下列之一的预处理器指令：<literal>include</literal>、<literal>define</literal>、<literal>ifdef</literal>等。否则，预处理器将把记号解析成一个主变量。
   </para>
  </note>

  <para>
   有两种兼容性模式：<literal>INFORMIX</>、<literal>INFORMIX_SE</>
  </para>
  <para>
   在链接使用这种兼容性模式的程序时，要记得链接上和 ECPG 一起发布的<literal>libcompat</>。
  </para>
  <para>
   除了之前解释过的语法糖，<productname>Informix</productname>兼容性模式从 E/SQL 中移植了一些用于输入、输出和数据转换的函数以及嵌入式 SQL 语句到 ECPG 中。
  </para>
  <para>
   <productname>Informix</productname>兼容性模式与 ECPG 的 pgtypeslib 库紧密连接。pgtypeslib 把 SQL 数据类型映射到 C 主程序中的数据类型并且大部分<productname>Informix</productname>兼容性模式的附加函数允许我们在那些 C 主程序类型上操作。不过注意兼容性的范围被有所限制。它并不是想尝试复制<productname>Informix</productname>的行为。它允许你做或多或少的相同操作并且给你具有相同名称和相同基本行为的函数，但是此刻如果你使用<productname>Informix</productname>，其中并没有唾手可得的替代品。此外，一些数据类型也不同。例如，<productname>PostgreSQL</productname>的日期时间和区间类型不理解范围（例如<literal>YEAR TO MINUTE</>），因此你也无法在 ECPG 中找到支持。
  </para>

  <sect2 id="ecpg-informix-types">
   <title>附加类型</title>
   <para>
    用于存储右切边字符串数据的 Informix-特殊的 "string" 伪类型现在在 Informix 模式中不用<literal>typedef</literal>就能支持。事实上，在 Informix 模式中，ECPG 拒绝处理包含<literal>typedef sometype string;</literal>的源文件。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* 这个变量将包含切边过的数据 */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-statements">
   <title>附加的/缺少的 嵌入式 SQL 语句</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</></term>
      <listitem>
       <para>
        这个语句关闭当前连接。事实上，这是 ECPG 的<literal>DISCONNECT CURRENT</>语句的同义词：
<programlisting>
$CLOSE DATABASE;                /* 关闭当前连接 */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</></term>
      <listitem>
       <para>
        由于 ECPG 和 Informix ESQL/C 在工作方式上的区别（一个是纯语法转换而另一个依赖于底层的运行时库），在 ECPG 中没有<literal>FREE cursor_name</>语句。这是因为在 ECPG 中，<literal>DECLARE CURSOR</literal>不会翻译成一个运行时库中使用游标名的函数调用。这意味着在 ECPG 运行时库中不会有 SQL 游标的运行时登记，SQL 游标只登记在 PostgreSQL 服务器中。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</></term>
      <listitem>
       <para>
        <literal>FREE statement_name</>是<literal>DEALLOCATE PREPARE statement_name</>的同义词。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
   <title>Informix-兼容的 SQLDA 描述符区域</title>
   <para>
    Informix-兼容模式支持一种与中所述不同的结构。如下：
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>

   <para>
    全局属性是：
    <variablelist>

     <varlistentry>
     <term><literal>sqld</></term>
      <listitem>
       <para>
        <literal>SQLDA</>描述符中域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</></term>
      <listitem>
       <para>
        每一个域属性的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</></term>
      <listitem>
       <para>
        未使用，用零字节填充。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</></term>
      <listitem>
       <para>
        已分配结构的尺寸。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</></term>
      <listitem>
       <para>
        如果结果集包含多于一个记录，这个域是下一个 SQLDA 结构的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</></term>
      <listitem>
       <para>
        未使用的指针，包含 NULL。为 Informix-兼容性而保留。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    对每一个域的属性如下，它们被存储在<literal>sqlvar</literal>数组中：

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</></term>
      <listitem>
       <para>
        域的类型。可以使用的常量定义在<literal>sqltypes.h</literal>中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</></term>
      <listitem>
       <para>
        域数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</></term>
      <listitem>
       <para>
        域数据的指针。该指针是<literal>char *</literal>类型，它所指向的数据是二进制个事。例子：
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</></term>
      <listitem>
       <para>
        NULL 指示符的指针。如果是由 DESCRIBE 或 FETCH 返回，那么它总是一个有效的指针。如果被用作<literal>EXECUTE ... USING sqlda;</literal>的输入，那么 NULL-指针值意味着这个域的值是非-NULL 的。否则必须正确地设置一个有效的指针和<literal>sqlitype</literal>。例子：
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</></term>
      <listitem>
       <para>
        域的名称。以 0 终止的字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</></term>
      <listitem>
       <para>
        在 Informix 中保留，是该域的<function>PQfformat()</>的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</></term>
      <listitem>
       <para>
        NULL 指示符数据的类型。当从服务器返回数据时，它总是 SQLSMINT。当<literal>SQLDA</literal>被用于一个参数化查询时，数据要根据设置的类型对待。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</></term>
      <listitem>
       <para>
        NULL 指示符数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</></term>
      <listitem>
       <para>
        该域的扩展类型，<function>PQftype()</>的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</></term>
     <term><literal>sqltypelen</></term>
     <term><literal>sqlownerlen</></term>
     <term><literal>sqlsourcetype</></term>
     <term><literal>sqlownername</></term>
     <term><literal>sqlsourceid</></term>
     <term><literal>sqlflags</></term>
     <term><literal>sqlreserved</></term>
      <listitem>
       <para>
        未使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</></term>
      <listitem>
       <para>
        如果<literal>sqllen</literal>大于 32KB，它等于<literal>sqldata</literal>。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    例子：
<programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* 这不需要在嵌入式 DECLARE SECTION 下 */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* 主结构完全被 free()，sqlda 和 sqlda-&gt;sqlvar 在一个已分配区域中 */
</programlisting>
    更多信息可见<literal>sqlda.h</>头部和<literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>回归测试。
   </para>
  </sect2>

  <sect2 id="ecpg-informix-functions">
   <title>附加函数</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</></term>
      <listitem>
       <para>
        将两个decimal类型值相加。
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        该函数接收第一个类型为 decimal 的操作数的指针（<literal>arg1</>）、第二个类型为 decimal 的操作数的指针（<literal>arg2</>）以及将包含和的 decimal 值的指针（<literal>sum</>）。成功时该函数返回 0。溢出时返回<symbol>ECPG_INFORMIX_NUM_OVERFLOW</>，下溢时返回<symbol>ECPG_INFORMIX_NUM_UNDERFLOW</>。其他失败会返回 -1 并且<varname>errno</>会被设置为相应的 pgtypeslib 中的<varname>errno</>编号。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</></term>
      <listitem>
       <para>
        比较两个 decimal 变量。
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        该函数接收第一个 decimal 值的指针（<literal>arg1</>）、第二个 decimal 值的指针（<literal>arg2</>）并且返回一个整数值说明哪一个值更大。
        <itemizedlist>
         <listitem>
          <para>
           1，如果<literal>arg1</>指向的值大于<literal>var2</>指向的值
          </para>
         </listitem>
         <listitem>
          <para>
           -1，如果<literal>arg1</>指向的值小于<literal>var2</>指向的值</para>
         </listitem>
         <listitem>
          <para>
           0，如果<literal>arg1</>指向的值与<literal>arg2</>指向的值相等
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</></term>
      <listitem>
       <para>
        拷贝一个 decimal 值。
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        该函数接收要拷贝的 decimal 值的指针作为第一个参数（<literal>src</>）以及一个类型为 decimal 的目标结构的指针作为第二个参数（<literal>target</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</></term>
      <listitem>
       <para>
        把一个值从 ASCII 表达转换成一个 decimal 类型。
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
        该函数接收一个包含要转换的数字的字符串表达的字符串指针（<literal>cp</>）及其长度（<literal>len</>）。<literal>np</>是一个用来保存操作结果的 decimal 值的指针。
       </para>
       <para>
        例如，可用的格式有：
         <literal>-2</literal>、
         <literal>.794</literal>、
         <literal>+3.44</literal>、
         <literal>592.49E07</literal>或者
         <literal>-32.84e-4</literal>。
       </para>
       <para>
        成功时该函数返回 0。如果发生溢出或者下溢，分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。如果 ASCII 表达无法被解析，将返回<literal>ECPG_INFORMIX_BAD_NUMERIC</>。如果解析指数时发生问题则返回<literal>ECPG_INFORMIX_BAD_EXPONENT</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</></term>
      <listitem>
       <para>
        将一个 double 值转换成一个 decimal 值。
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        该函数接收要被转换的 double 变量作为第一个参数（<literal>dbl</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</></term>
      <listitem>
       <para>
        将一个 int 值转换成 decimal 值。
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        该函数接收要被转换的 int 变量作为第一个参数（<literal>in</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</></term>
      <listitem>
       <para>
        将一个 long 值转换成 decimal 值。
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        该函数接收要被转换的 long 变量作为第一个参数（<literal>lng</>）。该函数接收一个 decimal 变量的指针作为第二个参数（<literal>np</>），它被用来保存操作的结果。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</></term>
      <listitem>
       <para>
        用两个 decimal 类型的变量做除法。
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>/<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果除法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。如果发现一次除零尝试，该函数返回
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</></term>
      <listitem>
       <para>
        将两个 decimal 值相乘。
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>*<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果乘法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</></term>
      <listitem>
       <para>
        从一个 decimal 值中减去另一个。
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>

        该函数接收两个变量的指针作为第一个（<literal>n1</>）和第二个（<literal>n2</>）操作数并且结算<literal>n1</>-<literal>n2</>。 <literal>result</>是一个指向保存操作结果的变量的指针。
       </para>
       <para>
        成功时返回 0，如果减法失败则返回一个负值。如果发生溢出或下溢，该函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</>或者
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</></term>
      <listitem>
       <para>
        将一个 decimal 变量转换成它的 ASCII 表达放在一个 C char* 字符串中。
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        该函数接收一个要被转换成文本表达的 decimal 类型变量的指针（<literal>np</>）。<literal>cp</>是应保存操作结果的缓冲区。参数<literal>right</>指定小数点右边应该有多少位保留在输出中。结果将被圆整到所指定数量的十进制位。将<literal>right</>设置为 -1 表示输出中应该包括所有可用的十进制位。如果输出缓冲区的长度（由<literal>len</>指定）不足以保存包含拖尾零字节的文本表达，结果中将只保存一个单一的<literal>*</>字符并且返回 -1。
       </para>
       <para>
        如果缓冲区<literal>cp</>太小该函数返回 -1；如果内存耗尽，则返回<literal>ECPG_INFORMIX_OUT_OF_MEMORY</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个 double 类型变量。
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的 double 变量的指针（<literal>dblp</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个整数类型变量。
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的整数变量的指针（<literal>ip</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。如果发生溢出，会返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。<productname>Informix</productname>限制一个整数的范围是从 -32767 到 32767，而 ECPG 实现中的限制取决于架构（<literal>-INT_MAX .. INT_MAX</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</></term>
      <listitem>
       <para>
        将一个 decimal 类型变量转换成一个长整型变量。
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        该函数接收一个要转换的 decimal 值的指针（<literal>np</>）以及一个保存操作结果的长整型变量的指针（<literal>lngp</>）。
       </para>
       <para>
        该函数在成功时返回 0，在转换失败时返回一个负值。如果发生溢出，会返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</>。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。<productname>Informix</productname>限制一个整数的范围是从 -2,147,483,647 到 2,147,483,647，而 ECPG 实现中的限制取决于架构（<literal>-LONG_MAX .. LONG_MAX</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</></term>
      <listitem>
       <para>
        将一个日期转换成一个 C char* 字符串。
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        该函数接收两个参数，第一个是要转换的日期（<literal>d</>），第二个是目标字符串的指针。输出格式总是<literal>yyyy-mm-dd</>，因此你需要为该字符串分配至少 11 个字节（包括零字节终止符）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        注意 ECPG 实现与<productname>Informix</productname>实现不同。在<productname>Informix</productname>中，该格式可能受到环境变量设置的影响。而在 ECPG 中，你不能改变输出格式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</></term>
      <listitem>
       <para>
        解析一个日期的文本表达。
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
        该函数接收要转换的日期的文本表达（<literal>str</>）以及一个日期类型变量的指针（<literal>d</>）。这个函数不允许你指定一个格式掩码。它使用<productname>Informix</productname>的默认格式掩码<literal>mm/dd/yyyy</>。在内部，这个函数用<function>rdefmtdate</>的方式实现。因此，<function>rstrdate</>不会更快，并且如果可以选择，你应该选用允许你显式指定格式掩码的<function>rdefmtdate</>。
       </para>
       <para>
        该返回与<function>rdefmtdate</>相同的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</></term>
      <listitem>
       <para>
        得到当前日期。
<synopsis>
void rtoday(date *d);
</synopsis>
        该函数接收一个日期变量的指针（<literal>d</>），它会把该变量设置为当前日期。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPESdatetoday">函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</></term>
      <listitem>
       <para>
        从一个日期类型变量中抽取日、月、年的值。
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        该函数接收日期<literal>d</>和由 3 个短整型值构成的数组的指针<literal>mdy</>。该变量名指定了顺序：<literal>mdy[0]</>将被设置为包含月的编号，<literal>mdy[1]</>将被设置为日的值，而<literal>mdy[2]</>将包含年。
       </para>
       <para>
        当前该函数总是返回 0。
       </para>
       <para>
        在内部该函数使用<xref linkend="PGTYPESdatejulmdy">函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</></term>
      <listitem>
       <para>
        使用一个格式掩码把一个字符串转换成一个日期类型的值。
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        该函数接收一个用于保存操作结果的日期值的指针（<literal>d</>）、要用来解析日期的格式掩码（<literal>fmt</>）以及包含日期文本表达的 C char* 字符串（<literal>str</>）。该文本表达应该匹配格式掩码。不过，你不需要具有从该字符串到格式掩码的 一一映射。该函数将分析顺序并且寻找表示年的位置的文字<literal>yy</literal>或<literal>yyyy</literal>、表示月的位置的<literal>mm</literal>以及表示日的位置的<literal>dd</literal>。
       </para>
       <para>
        该函数返回下列值：
        <itemizedlist>
         <listitem>
          <para>
           0 - 该函数成功终止。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</> - 该日期不包含日、月、年之间的定界符。在这种情况下，输入字符串必须是正好 6 个或 8 个字节，但实际上却不是。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOTDMY</> - 格式字符串没有正确地指示年、月、日的顺序。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_DAY</> - 输入字符串不含一个合法的日。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_MONTH</> - 输入字符串不含一个合法的月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_YEAR</> - 输入字符串不含一个合法的年。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        在内部这个函数被实现为使用<xref linkend="PGTYPESdatedefmtasc">函数。示例输入表可以在那里找到。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</></term>
      <listitem>
       <para>
        使用一个格式掩码将一个日期类型变量转换成它的文本表达。
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        该函数接收要转换的日期（<literal>d</>）、格式掩码（<literal>fmt</>）以及将保存日期的文本表达的字符串（<literal>str</>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPESdatefmtasc">函数，例子请参考该函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</></term>
      <listitem>
       <para>
        从由 3 个短整型组成的数组创建一个日期值，它指定了该日期的日、月、年。
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        该函数接收一个由 3 个短整型构成的数组（<literal>mdy</>）以及一个用来保存操作结构的日期类型变量的指针。
       </para>
       <para>
        当前该函数总是返回 0。
       </para>
       <para>
        在内部这个函数被实现为使用<xref linkend="PGTYPESdatemdyjul">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</></term>
      <listitem>
       <para>
        为一个日期值返回一个表示它是星期几的数字。
<synopsis>
int rdayofweek(date d);
</synopsis>
        该函数接收日期变量<literal>d</>作为它的唯一参数并且返回一个整数指示这一天是星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 周日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 周一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 周二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 周三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 周四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 周五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 周六
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        在内部这个函数被实现为使用函数<xref linkend="PGTYPESdatedayofweek">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</></term>
      <listitem>
       <para>
        检索当前的时间戳。
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        该函数检索当前时间戳并且把它保存在<literal>ts</>指向的时间戳变量中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</></term>
      <listitem>
       <para>
        把一个时间戳从它的文本表达解析到一个时间戳变量中。
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        该函数接收要解析的字符串（<literal>str</>）以及一个指向保存操作结果的时间戳变量的指针（<literal>ts</>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部这个函数使用<xref linkend="PGTYPEStimestampfromasc">函数。一个输入示例的表格可以参考该函数的文档。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</></term>
      <listitem>
       <para>
        使用一个格式掩码把一个时间戳从它的文本表达解析到一个时间戳变量中。
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        该函数接收要解析的字符串（<literal>inbuf</>）、要使用的格式掩码（<literal>fmtstr</>）以及一个指向保存操作结果的时间戳变量的指针（<literal>dtvalue</>）。
       </para>
       <para>
        这个函数通过<xref linkend="PGTYPEStimestampdefmtasc">函数实现。可以使用的格式说明符的列表可以参考该函数的文档。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</></term>
      <listitem>
       <para>
        从一个时间戳中减去另一个并且返回一个区间类型变量。
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从<literal>ts1</>指向的时间戳变量中减去<literal>ts2</>指向的时间戳变量，并且将把结果存储在<literal>iv</>指向的区间变量中。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</></term>
      <listitem>
       <para>
        将一个时间戳变量转换成一个 C char* 字符串。
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        该函数接收一个要转换的时间戳变量的指针（<literal>ts</>）以及用于保存操作结果的字符串（<literal>output</>）。它根据 SQL 标准把<literal>ts</>转换成它的文本表达，形式为<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</></term>
      <listitem>
       <para>
        使用一个格式掩码将一个时间戳变量转换成一个 C char*。
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个要转换的时间戳的指针（<literal>ts</>）、一个输出缓冲区的指针（<literal>output</>）、已经为输出缓冲区分配的最大长度（<literal>str_len</literal>）以及用于转换的格式掩码（<literal>fmtstr</literal>）。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
       <para>
        在内部，这个函数使用<xref linkend="PGTYPEStimestampfmtasc">函数。可以使用的格式说明符的列表可以参考该函数的文档。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</></term>
      <listitem>
       <para>
        将一个区间变量转换成一个 C char* 字符串。
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        该函数接收一个要转换的区间变量的指针（<literal>i</>）以及要保持该操作结果的字符串（<literal>str</>）。它根据 SQL 标准把<literal>i</>转换成它的文本表达，形式为<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
       <para>
        成功时该函数返回 0，如果发生错误则返回一个负值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</></term>
      <listitem>
       <para>
        用一个格式掩码将一个长整型值转换成它的文本表达。
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
        该函数接收长整型值<literal>lng_val</>、格式掩码<literal>fmt</>以及输出缓冲区的指针<literal>outbuf</>。它根据格式掩码将长整型值转换成文本表达。
       </para>
       <para>
        格式掩码可以由下列格式说明字符构成：
        <itemizedlist>
         <listitem>
          <para>
           <literal>*</literal> （星） - 如果这个位置可以为空白，否则用一个星号填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&amp;</literal> （花号） -如果这个位置可以为空白，否则用一个零填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>#</literal> - 把前导零转变成空白。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&lt;</literal> - 左对齐字符串中的数字。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>,</literal> （逗号） - 将有四个或者更多数位的数字份组成用逗号分隔的 3 数位组。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>.</literal> （点） - 这个字符分隔数字的整数部分和小数部分。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>-</literal> （负） - 如果该数字是一个负值则负号会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>+</literal> （加） - 如果该数字是一个正值则加号会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>(</literal> - 这会替换负数前面的负号。负号将不会出现。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>)</literal> - 这个字符替换负号并且被打印在负值的后面。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>$</literal> - 货币符号。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</></term>
      <listitem>
       <para>
        把一个字符串转换成大写形式。
<synopsis>
void rupshift(char *str);
</synopsis>
        该函数接收一个字符串的指针并且把每一个小写形式的字符变成大写形式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</></term>
      <listitem>
       <para>
        返回一个字符串的字符数，其中不含拖尾的空白。
<synopsis>
int byleng(char *str, int len);
</synopsis>
        该函数期待一个定长字符串作为它的第一个参数（<literal>str</>）并且把它的长度作为第二个参数（<literal>len</>）。该函数会返回有效字符的数量，也就是字符串不含拖尾空白的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</></term>
      <listitem>
       <para>
        复制一个定长字符串到一个空终止的字符串。
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        该函数接收要被复制的定长字符串（<literal>src</>）、它的长度（<literal>len</>）以及目标内存的指针（<literal>dest</>）。注意你需要为<literal>dest</>指向的字符串保留至少<literal>len+1</>个字节。该函数复制至多<literal>len</>个字节到新的位置（如果源字符串有拖尾的空格）并且增加空终止符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</></term>
      <listitem>
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</></term>
      <listitem>
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</></term>
      <listitem>
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</></term>
      <listitem>
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        这个函数存在，但是目前还没有实现！
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</></term>
      <listitem>
       <para>
        设置一个变量为 NULL。
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        该函数接收一个表示变量类型的整数以及一个被造型成 C char* 指针的变量本身的指针。
       </para>
       <para>
        存在下列类型：
        <itemizedlist>
         <listitem>
          <para>
           <literal>CCHARTYPE</literal> - 用于类型<type>char</type>或者<type>char*</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CSHORTTYPE</literal> - 用于类型<type>short int</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CINTTYPE</literal> - 用于类型<type>int</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CBOOLTYPE</literal> - 用于类型<type>boolean</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CFLOATTYPE</literal> - 用于类型<type>float</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CLONGTYPE</literal> - 用于类型<type>long</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDOUBLETYPE</literal> - 用于类型<type>double</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDECIMALTYPE</literal> - 用于类型<type>decimal</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDATETYPE</literal> - 用于类型<type>date</type>的一个变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDTIMETYPE</literal> - 用于类型<type>timestamp</type>的一个变量
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
        这里是一个调用这个函数的例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</></term>
      <listitem>
       <para>
        测试一个变量是否为 NULL。
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        该函数接收要测试的变量的类型（<literal>t</>）以及一个指向该变量的指针（<literal>ptr</>）。注意后者需要被造型为一个 char*。可能的变量类型请见函数<xref linkend="rsetnull">。
       </para>
       <para>
        这里是一个如何使用这个函数的例子：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
   <title>额外的常量</title>
   <para>
    注意这里所有的常量都描述错误并且它们都被定义为表示负值。在每一种不同常量的描述中，你还可以找到在当前实现中该常量表示的值。不过你不应该依赖于这个数字。但是你可以相信所有的这些常量都是被定义为表示负值。
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</></term>
      <listitem>
       <para>
        如果在一次计算中发生了溢出，函数会返回这个值。在内部它被定义为 -1200（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</></term>
      <listitem>
       <para>
        如果在一次计算中发生了下溢，函数会返回这个值。在内部它被定义为 -1201（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</></term>
      <listitem>
       <para>
       如果发现尝试除零，函数会返回这个值。在内部它被定义为 -1202（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</></term>
      <listitem>
       <para>
        如果在解析一个日期时为年找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1204（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</></term>
      <listitem>
       <para>
        如果在解析一个日期时为月找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1205（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</></term>
      <listitem>
       <para>
        如果在解析一个日期时为日找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1206（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</></term>
      <listitem>
       <para>
        如果一个解析例程需要一个短日期表示但是却没有得到正确长度的日期自如穿，函数会返回这个值。在内部它被定义为 -1209（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</></term>
      <listitem>
       <para>
        如果在日期格式化时产生了一个错误，函数会返回这个值。在内部它被定义为 -1210（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</></term>
      <listitem>
       <para>
        如果在操作时内存被耗尽，函数会返回这个值。在内部它被定义为 -1211（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</></term>
      <listitem>
       <para>
        如果一个解析例程被假定为得到一个格式掩码（如<literal>mmddyy</>）但是列出的域并不是全部正确，函数会返回这个值。在内部它被定义为 -1212（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</></term>
      <listitem>
       <para>
        如果一个解析例程因为一个numeric值的文本表达包含错误而不能解析它或者一个例程因为至少一个numeric变量非法而无法完成一次涉及numeric变量的计算，函数会返回这个值。在内部它被定义为 -1213（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</></term>
      <listitem>
       <para>
        如果一个解析例程不能解析一个指数，函数会返回这个值。在内部它被定义为 -1216（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</></term>
      <listitem>
       <para>
       如果一个解析例程不能解析一个日期，函数会返回这个值。在内部它被定义为 -1218（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</></term>
      <listitem>
       <para>
       如果一个解析例程被传递了它不能解析的额外字符，函数会返回这个值。在内部它被定义为 -1264（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-develop">
  <title>内部</title>

  <para>
   这一节解释<application>ECPG</application>在内部如何工作。这些信息有时有助于用户理解如何使用<application>ECPG</application>。
  </para>

   <para>
    <command>ecpg</command>写到输出的头四行是固定行。两行是注释，两行是与库接口必须的包括行。然后预处理器会从文件读取并且写输出。通常它会把所有东西回显在输出上。
   </para>

   <para>
    当它看见一个<command>EXEC SQL</command>语句时，它会干预并且改变它。命令开始于<command>EXEC SQL</command> 并且结束于<command>;</command>。之间的任何东西都被视作一个<acronym>SQL</acronym>语句，并且会被解析进行变量替换。
   </para>

   <para>
    当一个符号开始于一个冒号（<literal>:</literal>）时，变量替换会发生。有该名称的变量会被在之前声明于<literal>EXEC SQL DECLARE</>小节中的变量中搜索。
   </para>

   <para>
    该库中最重要的函数是<function>ECPGdo</function>，它负责执行大部分命令。它采用可变数量的参数。可以很容易地增加到最多 50 个左右的参数，并且我们希望在任何平台上这都不会成为问题。
   </para>

   <para>
    参数是：

    <variablelist>
     <varlistentry>
      <term>一个行号</term>
      <listitem>
       <para>
        这是原始行的行号，只用于错误消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>一个字符串</term>
      <listitem>
       <para>
        这是要被发出的<acronym>SQL</acronym>命令。它会被输入变量修改，即在编译时不知道但是要在命令中被输入的变量。其中变量应该去到包含<literal>?</literal>的字符串中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输入变量</term>
      <listitem>
       <para>
        每一个输入参数导致十个参数被创建（见下文）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <para>
        一个说明没有更多输入变量的<type>enum</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输出变量</term>
      <listitem>
       <para>
        每一个输出变量导致十个参数被创建（见下文）。这些变量由该函数填充。
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <para>
        一个说明没有更多变量的<type>enum</>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    对于每一个作为<acronym>SQL</acronym>命令一部分的变量，该函数得到十个参数：

    <orderedlist>
     <listitem>
      <para>
       作为一个特殊符号的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个值的指针或者一个指针的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       如果变量是一个<type>char</type>或者<type>varchar</type>，这是它的尺寸。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中元素的数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中下一个元素的偏移量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       作为一个特别符号的指示符变量的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个指示符变量的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       指示符数组中的元素数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       到指示符数组中下一个元素的偏移量（用于数组取得）。
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    注意并非所有 SQL 命令都被以这种方式对待。例如，一个打开游标语句：
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    不会被复制到输出。反而，游标的<command>DECLARE</>命令被用在<command>OPEN</>命令的位置上，因为它事实上会打开该游标。
   </para>

   <para>
    这里有一个完整的例子，它描述了一个文件<filename>foo.pgc</filename>的预处理器输出（对预处理器的每一个特定版本细节可能不同）：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    会被翻译成：
<programlisting><![CDATA[
/* 由 ecpg (2.6.0) 处理 */
/* 这两个头文件由预处理器增加 */
#include <ecpgtype.h>;
#include <ecpglib.h>; 

/* 声明节开始 */

#line 1 "foo.pgc"

 int index;
 int result;
/* 声明节结束 */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
    （这里的缩进是为了可读性而添加的，并非是预处理器做的处理）。
   </para>
 </sect1>
</chapter>
