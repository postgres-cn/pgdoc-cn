<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
  <title>函数和操作符</title>

  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>

  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>为内建的数据类型提供了大量的函数和操作符。 用户也可以定义它们自己的函数和操作符， 如<xref linkend="server-programming">所述。<application>psql</application>命令<command>\df</command>和<command>\do</command>可以分别被用于显示所有可用的函数和操作符的列表。
  </para>

  <para>
   如果你关心移植性，那么请注意，我们在本章描述的大多数函数和操作符， 除了最琐碎的算术和比较操作符以及一些做了明确标记的函数以外，都没有在<acronym>SQL</acronym>标准里声明。某些这种扩展的功能也出现在许多其它<acronym>SQL</acronym>数据库管理系统中，并且在很多情况下多个实现的这种功能是相互兼容的和一致的。本章也并没有穷尽一切信息；一些附加的函数在本手册的相关小节里出现。
  </para>


  <sect1 id="functions-logical">
   <title>逻辑操作符</title>

   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>

   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>

   <para>
    常用的逻辑操作符有：

    <indexterm>
     <primary>AND（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>OR（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>NOT（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</></member>
     <member><literal>OR</></member>
     <member><literal>NOT</></member>
    </simplelist>

    <acronym>SQL</acronym>使用三值的逻辑系统，包括真、假和<literal>null</>，<literal>null</>表示<quote>未知</quote>。观察下面的真值表：

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry> 
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
    操作符<literal>AND</literal>和<literal>OR</literal>是可交换的，也就是说，你可以交换左右操作数而不影响结果。但是请参阅<xref
    linkend="syntax-express-eval">获取有关子表达式计算顺序的更多信息。
   </para>
  </sect1>

  <sect1 id="functions-comparison">
   <title>比较操作符</title>

   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>

   <para>
    常见的比较操作符都可用，如<xref
    linkend="functions-comparison-table">所示。
   </para>

   <table id="functions-comparison-table">
    <title>比较操作符</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
       <entry>小于</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
       <entry>大于</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
       <entry>小于等于</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
       <entry>大于等于</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
       <entry>等于</entry>
      </row>

      <row>
       <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
       <entry>不等于</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     <literal>!=</literal>操作符在分析器阶段被转换成<literal>&lt;&gt;</literal>。不能把<literal>!=</literal>和<literal>&lt;&gt;</literal>操作符实现为做不同的事。
    </para>
   </note>

   <para>
    比较操作符可以用于所有可以比较的数据类型。所有比较操作符都是双目操作符，它们返回<type>boolean</type>类型；类似于<literal>1 &lt; 2 &lt; 3</literal>的表达式是非法的（因为没有<literal>&lt;</literal>操作符可以比较一个布尔值和<literal>3</literal>）。
   </para>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    除了比较操作符以外，特殊的<token>BETWEEN</token>结构也可以使用：
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    等效于
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    注意<token>BETWEEN</token>认为终点值是包含在范围内的。
    <literal>NOT BETWEEN</literal>可以做相反比较：
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    等效于
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    <literal>BETWEEN SYMMETRIC</>和<literal>BETWEEN</>相同，不过<literal>BETWEEN SYMMETRIC</>不要求<literal>AND</>左边的参数小于或等于右边的参数。如果左参数不是小于等于右参数，这两个参数会自动被交换，这样总是会应用一个非空范围。
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    要检查一个值是否为空，使用下面的结构：
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    或者等效，但并不标准的结构：
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>

   <para>
    <emphasis>不要</emphasis>写<literal><replaceable>expression</replaceable> = NULL</literal>，因为<literal>NULL</>是不<quote>等于</quote><literal>NULL</>的（控制代表一个未知的值，因此我们无法知道两个未知的数值是否相等）。这种行为符合 SQL 标准。
   </para>

  <tip>
   <para>
    有些应用可能要求表达式<literal><replaceable>expression</replaceable> = NULL</literal>在<replaceable>expression</replaceable>得出空值时返回真。我们强烈建议这样的应用修改成遵循 SQL 标准。但是，如果这样修改不可能完成，那么我们可以使用配置变量<xref linkend="guc-transform-null-equals">。如果打开它，<productname>PostgreSQL</productname>将把<literal>x = NULL</literal>子句转换成<literal>x IS NULL</literal>。
   </para>
  </tip>

  <note>
   <para>
    如果<replaceable>expression</replaceable>是行值，那么当行表达式本身为非空值或者行的所有域为非空时<literal>IS NULL</>为真。由于这种行为，<literal>IS NULL</>和<literal>IS NOT NULL</>并不总是为行值表达式返回反转的结果，即一个同时包含 NULL 和非空值的行值表达式将会对两种测试都返回假。这种定义符合 SQL 标准，它是一个对<productname>PostgreSQL</productname> 8.2之前版本中的不一致行为的修改。
   </para>
  </note>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    当任何一个输入为空时，普通比较操作符得到空值（代表<quote>未知</>），不是真也不是假。例如，<literal>7 = NULL</>得到空，<literal>7 &lt;&gt; NULL</>也一样。当这种行为不合适时，使用<literal>IS <optional> NOT </> DISTINCT FROM</literal>结构：
<synopsis>
<replaceable>expression</replaceable> IS DISTINCT FROM <replaceable>expression</replaceable>
<replaceable>expression</replaceable> IS NOT DISTINCT FROM <replaceable>expression</replaceable>
</synopsis>
    对于非空输入，<literal>IS DISTINCT FROM</literal>与<literal>&lt;&gt;</>操作符相同。但是，假如两个输入都是空，那么它将返回假，而如果只有一个输入是空，那么它将返回真。相似地，对于非空输入<literal>IS NOT DISTINCT FROM</literal>和<literal>=</literal>是一样的，但是它在两个输入为空时返回真，只有一个输入为空是返回假。所以，这些结构实际上表现得似乎空值是一个普通数据值，而不是<quote>未知</>。
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    布尔值也可以使用下列结构进行测试：
<synopsis>
<replaceable>expression</replaceable> IS TRUE
<replaceable>expression</replaceable> IS NOT TRUE
<replaceable>expression</replaceable> IS FALSE
<replaceable>expression</replaceable> IS NOT FALSE
<replaceable>expression</replaceable> IS UNKNOWN
<replaceable>expression</replaceable> IS NOT UNKNOWN
</synopsis>
    这些结构将总是返回真或假，从来不返回空值，即使操作数是空也如此。空值输入被当做逻辑值<quote>未知</>。 请注意实际上<literal>IS UNKNOWN</>和<literal>IS NOT UNKNOWN</>分别与<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>相同， 只是输入表达式必须是布尔类型。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    constructs
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

  </sect1>

  <sect1 id="functions-math">
   <title>数学函数和操作符</title>

   <para>
    <productname>PostgreSQL</productname>为很多类型提供了数学操作符。对于那些没有标准数学表达的类型（如日期/时间类型），我们将在后续小节中描述实际的行为。
   </para>

   <para>
    <xref linkend="functions-math-op-table">展示了所有可用的数学操作符。
   </para>

   <table id="functions-math-op-table">
    <title>数学操作符</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
       <entry>加</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
       <entry>减</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
       <entry>乘</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
       <entry>除（整数除法截断结果）</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
       <entry>模（取余）</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
       <entry>指数</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
       <entry>平方根</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
       <entry>立方根</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
       <entry>阶乘</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
       <entry>阶乘（前缀操作符）</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
       <entry>绝对值</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>按位与</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>按位或</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>按位异或</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>按位求反</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>按位左移</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>按位右移</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    按位操作操作符只能用于整数数据类型，而其它的操作符可以用于全部数字数据类型。按位操作的操作符还可以用于位串类型<type>bit</type>和<type>bit varying</type>， 如<xref linkend="functions-bit-string-op-table">所示。
   </para>

  <para>
   <xref linkend="functions-math-func-table">显示了可用的数学函数。在该表中，<literal>dp</literal>表示<type>double precision</type>。这些函数中有许多都有多种不同的形式，区别是参数不同。除非特别指明，任何特定形式的函数都返回和它的参数相同的数据类型。 处理<type>double precision</type>数据的函数大多数是在宿主系统的 C 库基础上实现的；因此，边界情况下的准确度和行为是根据宿主系统而变化的。
  </para>

   <table id="functions-math-func-table">
    <title>数学函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>绝对值</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>立方根</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <literal><function>ceil(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>不小于参数的最小整数</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <literal><function>ceiling(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>不小于参数的最小整数（<function>ceil</function>的别名）</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>把弧度转为角度</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</>,
         <parameter>x</parameter> <type>numeric</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
       <entry><parameter>y</parameter>/<parameter>x</parameter>的整数商</entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <literal><function>exp(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <literal><function>floor(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>不大于参数的最大整数</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <literal><function>ln(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>自然对数</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <literal><function>log(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>以10为底的对数</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>以<parameter>b</parameter>为底的对数</entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <literal><function>mod(<parameter>y</parameter>,
         <parameter>x</parameter>)</function></literal>
       </entry>
       <entry>（和参数类型相同）</entry>
       <entry><parameter>y</parameter>/<parameter>x</parameter>的余数</entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry><quote>&pi;</quote>常数</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>求<parameter>a</>的<parameter>b</parameter>次幂</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>求<parameter>a</>的<parameter>b</parameter>次幂</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>把角度转为弧度</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <literal><function>round(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>圆整为最接近的整数</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>圆整为<parameter>s</parameter>位小数数字</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <literal><function>sign(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>参数的符号（-1, 0, +1）</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
        <literal><function>sqrt(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <literal><function>trunc(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
       <entry>（和输入相同）</entry>
       <entry>截断（向零靠近）</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>截断为<parameter>s</parameter>位小数位置的数字</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <literal><function>width_bucket(<parameter>operand</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>


       <entry><type>int</type></entry>
       <entry>返回一个桶，这个桶是在一个有<parameter>count</>个桶， 上界为<parameter>b1</>，下界为<parameter>b2</>的柱图中<parameter>operand</>将被赋予的那个桶。为外部范围输入返回<literal>0</>或者<literal><parameter>count</>+1</literal></entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>返回一个桶，这个桶是在一个有<parameter>count</>个桶，上界为<parameter>b1</>，下界为<parameter>b2</>的柱图中<parameter>operand</>将被赋予的那个桶；
       为范围外的输入返回<literal>0</>或者<literal><parameter>count</>+1</literal></entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>返回一个桶，它是给定数组列出桶的下限<parameter>operand</>将被赋予的那个桶，
       为了输入低于第一下界返回<literal>0</>；<parameter>thresholds</>数组<emphasis>必须被存储</>，
       首先最小值，或者获取意想不到的结果</entry>
       <entry><literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    <xref linkend="functions-math-random-table">展示了用于产生随机数的函数。
  </para>

   <table id="functions-math-random-table">
    <title>随机函数</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>范围 0.0 &lt;= x &lt; 1.0 中的随机值</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>为后续的<literal>random()</literal>调用设置种子（值为于 -1.0 和 1.0 之间，包括边界值）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <literal><function>random()</function></literal>返回的值的特征取决于系统实现。
   它不适合用于加密应用，如果需要用于加密应用请参考<xref linkend="pgcrypto">模块。
   </para>

  <para>
   最后，<xref linkend="functions-math-trig-table">显示了可用的三角函数。所有三角函数都有类型为<type>double precision</type>的参数和返回类型。三角函数参数表示为弧度。反函数返回表示为弧度的值。参见上述的转换函数<literal><function>radians()</function></literal>和<literal><function>degrees()</function></literal>。
  </para>

   <table id="functions-math-trig-table">
    <title>三角函数</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>acos</primary>
        </indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>反余弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>反正弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>反正切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry><literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal>的反正切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>余弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>余切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>正弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>正切</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
   <title>字符串函数和操作符</title>

   <para>
    本节描述了用于检查和操作字符串值的函数和操作符。在这个环境中的串包括所有类型<type>character</type>、<type>character varying</type>和<type>text</type>的值。除非另外说明，所有下面列出的函数都可以处理这些类型，不过要小心的是，在使用<type>character</type>类型的时候， 它有自动填充空白的潜在影响。有些函数还可以处理位串类型。
   </para>

   <para>
    <acronym>SQL</acronym>定义了一些字符串函数，它们使用关键字，而不是逗号来分隔参数。详情请见<xref linkend="functions-string-sql">，<productname>PostgreSQL</>也提供了这些函数使用正常函数调用语法的版本（见<xref linkend="functions-string-other">）。
   </para>

   <note>
    <para>
     由于存在从那些数据类型到<type>text</>的隐式强制措施，在<productname>PostgreSQL</productname> 8.3之前，这些函数也可以接受多种非字符串数据类型。这些强制措施在目前的版本中已经被删除，因为它们常常导致令人惊讶的行为。不过，字符串串接操作符（<literal>||</>）仍然接受非字符串输入，只要至少一个输入是一种字符串类型，如<xref linkend="functions-string-sql">所示。对于其他情况，如果你需要复制之前的行为，可以为<type>text</>插入一个显式强制措施。
    </para>
   </note>

   <table id="functions-string-sql">
    <title><acronym>SQL</acronym>字符串函数和操作符</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
        串接
        <indexterm>
         <primary>字符串</primary>
         <secondary>串接</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry>
        <literal><parameter>string</parameter> <literal>||</literal>
        <parameter>non-string</parameter></literal>
        or
        <literal><parameter>non-string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal>
       </entry>
       <entry> <type>text</type> </entry>
       <entry>
        使用一个非字符串输入的串接
       </entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>串中的位数</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> or <literal><function>character_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        串中字符数
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>将字符串转换为小写形式</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>串中的字节数</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        替换子串
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>定位指定子串</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        提取子串
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        提取匹配POSIX正则表达式的子串。模式匹配详情见<xref linkend="functions-matching">。
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        提取匹配<acronym>SQL</acronym>正则表达式的子串。模式匹配详情见<xref linkend="functions-matching">。
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional>
        <optional><parameter>characters</parameter></optional> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        从<parameter>string</parameter>的开头/结尾/两端删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的串
       </entry>
       <entry><literal>trim(both 'x' from 'xTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
      
      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing
        | both</optional> <optional>from</optional>
        <parameter>string</parameter>
        <optional><parameter>, characters</parameter></optional>
        )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <function>trim()</>的非标准版本
       </entry>
       <entry><literal>trim(both from 'xTomxx', 'x')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>将字符串转换成大写形式</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    还有额外的串操作函数可以用，它们在<xref linkend="functions-string-other">中列出。它们有些在内部用于实现<xref linkend="functions-string-sql">列出的<acronym>SQL</acronym>标准字符串函数。
   </para>

   <table id="functions-string-other">
    <title>其他字符串函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        参数第一个字符的<acronym>ASCII</acronym>代码。对于<acronym>UTF8</acronym>返回该字符的Unicode代码点。对于其他多字节编码，该参数必须是一个<acronym>ASCII</acronym>字符。
       </entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        从<parameter>string</parameter>的开头或结尾删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的串
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xy')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        给定代码的字符。对于<acronym>UTF8</acronym>该参数被视作一个Unicode代码点。对于其他多字节编码该参数必须指定一个<acronym>ASCII</acronym>字符。NULL (0) 字符不被允许，因为文本数据类型不能存储这种字节。
       </entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type>
         [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        串接所有参数的文本表示。NULL 参数被忽略。
       </entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>,
        <parameter>str</parameter> <type>"any"</type>
        [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将除了第一个参数外的其他参数用分隔符串接在一起。第一个参数被用作分隔符字符串。NULL 参数被忽略。
       </entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert</primary>
        </indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        将字符串转换为<parameter>dest_encoding</parameter>。原始编码由<parameter>src_encoding</parameter>指定。<parameter>string</parameter>在这个编码中必须可用。转换可以使用<command>CREATE CONVERSION</command>定义。也有一些预定义的转换。可用的转换请见<xref linkend="conversion-names">。
       </entry>
       <entry><literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal></entry>
       <entry>用Latin-1 encoding (ISO 8859-1) 表示的<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_from</primary>
        </indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将字符串转换为数据库编码。原始编码由<parameter>src_encoding</parameter>指定。<parameter>string</parameter>在这个编码中必须可用。
       </entry>
       <entry><literal>convert_from('text_in_utf8', 'UTF8')</literal></entry>
       <entry>用当前数据库编码表示的<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_to</primary>
        </indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        将字符串转换为<parameter>dest_encoding</parameter>。
       </entry>
       <entry><literal>convert_to('some text', 'UTF8')</literal></entry>
       <entry>用UTF8编码表达的<literal>some text</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        从<parameter>string</>中的文本表达解码二进制数据。<parameter>format</>的选项和<function>encode</>中的一样。
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将二进制数据编码成一个文本表达。支持的格式有：<literal>base64</>、<literal>hex</>、<literal>escape</>。<literal>escape</>将零字节和高位组字节转换为八进制序列（<literal>\</><replaceable>nnn</>）和双写的反斜线。
       </entry>
       <entry><literal>encode(E'123\\000\\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
         根据一个格式字符串格式化参数。该函数和C函数<function>sprintf</>相似。见<xref linkend="functions-string-format">。
       </entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将每一个词的第一个字母转换为大写形式并把剩下的字母转换为小写形式。词是由非字母数字字符分隔的字母数字字符的序列。
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>,
        <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        返回字符串中的前<replaceable>n</>个字符。当<replaceable>n</>为负时，将返回除了最后|<replaceable>n</>|个字符之外的所有字符。
        </entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <parameter>string</parameter>中的字符数
       </entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
        <parameter>string</parameter>在给定<parameter>编码</parameter>中的字符数。<parameter>string</parameter>必须在这个编码中有效。
       </entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将<parameter>string</parameter>通过前置字符<parameter>fill</parameter>（默认是一个空格）填充到长度<parameter>length</parameter>。如果<parameter>string</parameter>已经长于<parameter>length</parameter>，则它被（从右边）截断。
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        从<parameter>string</parameter>的开头删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的串
       </entry>
       <entry><literal>ltrim('zzzytrim', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        计算<parameter>string</parameter>的 MD5 哈希，返回十六进制的结果
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>
        当前的客户端编码名字
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将给定字符串返回成合适的引用形式，使它可以在一个<acronym>SQL</acronym>语句字符串中被用作一个标识符。只有需要时才会加上引号（即，如果字符串包含非标识符字符或可能是大小写折叠的）。嵌入的引号会被正确地双写。参见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将给定字符串返回成合适的引用形式，使它可以在一个<acronym>SQL</acronym>语句字符串中被用作一个字符串文字。嵌入的引号会被正确地双写。注意<function>quote_literal</function>对空输入返回空；如果参数可能为空，<function>quote_nullable</function>通常更合适。参见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        强迫给定值为文本并且接着将它用引号包围作为一个文本。嵌入的单引号和反斜线被正确的双写。
       </entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将给定字符串返回成合适的引用形式，使它可以在一个<acronym>SQL</acronym>语句字符串中被用作一个字符串文字；或者，如果参数为空，返回<literal>NULL</>。嵌入的引号会被正确地双写。请参见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        强迫给定值为文本并且接着将它用引号包围作为一个文本；或者，如果参数为空，返回<literal>NULL</>。嵌入的单引号和反斜线被正确的双写。
       </entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <literal><function>regexp_matches(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>
        返回对<parameter>string</parameter>匹配一个POSIX正则表达式得到的所有子串。详见<xref linkend="functions-posix-regexp">。
       </entry>
       <entry><literal>regexp_matches('foobarbequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <literal><function>regexp_replace(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        替换匹配一个POSIX正则表达式的子串。详见<xref linkend="functions-posix-regexp">。
       </entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
        使用一个POSIX正则表达式作为分隔符划分<parameter>string</parameter>。详见<xref linkend="functions-posix-regexp">。
       </entry>
       <entry><literal>regexp_split_to_array('hello world', E'\\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
        使用一个POSIX正则表达式作为分隔符划分<parameter>string</parameter>。详见<xref linkend="functions-posix-regexp">。
       </entry>
       <entry><literal>regexp_split_to_table('hello world', E'\\s+')</literal></entry>
       <entry><literal>hello</literal><para><literal>world</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>重复<parameter>string</parameter>指定的<parameter>number</parameter>次</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>将<parameter>string</parameter>中出现的所有子串<parameter>from</parameter>替换为子串<parameter>to</parameter>
       </entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        返回反转的字符串。
       </entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>,
         <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        返回字符串中的最后<replaceable>n</>个字符。如果<replaceable>n</>为负，返回除最前面的|<replaceable>n</>|个字符外的所有字符。
       </entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        将<parameter>string</parameter>通过增加字符<parameter>fill</parameter>（默认为一个空格）填充到长度<parameter>length</parameter>。如果<parameter>string</parameter>已经长于<parameter>length</parameter>则它会被截断。
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        从<parameter>string</parameter>的结尾删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的串
       </entry>
       <entry><literal>rtrim('trimxxxx', 'x')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>按<parameter>delimiter</parameter>划分<parameter>string</parameter>并返回给定域（从1开始计算）
       </entry>
       <entry><literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        指定子串的位置（和<literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>相同，但是注意相反的参数顺序）
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        提取子串（与<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>相同）
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
       将<parameter>string</parameter>从另一个编码转换到<acronym>ASCII</acronym>（只支持从<literal>LATIN1</>、<literal>LATIN2</>、<literal>LATIN9</>和<literal>WIN1250</>编码的转换）
       </entry>
       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type>
        or <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>将<parameter>number</parameter>转换到它等效的十六进制表示
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <parameter>string</parameter>中任何匹配<parameter>from</parameter>集合中一个字符的字符会被替换成<parameter>to</parameter>集合中的相应字符。如果<parameter>from</parameter>比<parameter>to</parameter>长，<parameter>from</parameter>中的额外字符会被删除。
       </entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    <function>concat</function>、<function>concat_ws</function>和<function>format</function>函数是可变的，因此可以把要串接或格式化的值作为一个标记了<literal>VARIADIC</literal>关键字的数组进行传递（见<xref linkend="xfunc-sql-variadic-functions">）。数组的元素被当作函数的独立普通参数一样处理。如果可变数组参数为 NULL，<function>concat</function>和<function>concat_ws</function>返回 NULL，但<function>format</function>把 NULL 当作一个零元素数组。
   </para>

   <para>
   还可以参阅<xref linkend="functions-aggregate">中的<function>string_agg</function>。
   </para>

   <table id="conversion-names">
    <title>内建转换</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>转换名
        <footnote>
         <para>
          转换名遵循一种标准命名模式：将全部非字母数字字符替换为下划线的源编码的官方名称，后面跟上<literal>_to_</literal>，最后是按照相似方式处理过的目标编码名称。因此，名称可能会不同于习惯的编码名称。
         </para>
        </footnote>
       </entry>
       <entry>源编码</entry>
       <entry>目标编码</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>tcvn_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_tcvn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm>
     <primary>format</primary>
    </indexterm>

    <para>
     函数<function>format</>根据一个格式字符串产生格式化的输出，其形式类似于 C 函数<function>sprintf</>。
    </para>

    <para>
<synopsis>
<function>format</>(<parameter>formatstr</> <type>text</> [, <parameter>formatarg</> <type>"any"</> [, ...] ])
</synopsis>
     <replaceable>formatstr</>是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用<firstterm>格式说明符</>的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个<replaceable>formatarg</>参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。
    </para>

    <para>
     格式说明符由一个<literal>%</>字符开始并且有这样的形式
<synopsis>
%[<replaceable>position</>][<replaceable>flags</>][<replaceable>width</>]<replaceable>type</>
</synopsis>
     其中的各组件域是：

     <variablelist>
      <varlistentry>
       <term><replaceable>position</replaceable>（可选）</term>
       <listitem>
        <para>
         一个形式为<literal><replaceable>n</>$</>的字符串，其中<replaceable>n</>是要打印的参数的索引。索引 1 表示<replaceable>formatstr</>之后的第一个参数。如果<replaceable>position</>被忽略，默认会使用序列中的下一个参数。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>flags</replaceable>（可选）</term>
       <listitem>
        <para>
         控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（<literal>-</>），它将导致格式说明符的输出会被左对齐（left-justified）。除非<replaceable>width</>域也被指定，否者这个域不会产生任何效果。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>width</replaceable>（可选）</term>
       <listitem>
        <para>
         指定用于显示格式说明符输出的<emphasis>最小</>字符数。输出将被在左部或右部（取决于<literal>-</>标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（<literal>*</>）表示使用下一个函数参数作为宽度；或者一个形式为<literal>*<replaceable>n</>$</>的字符串表示使用第<replaceable>n</>个函数参数作为宽度。
        </para>

        <para>
         如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为<function>abs</>(<replaceable>width</replaceable>)的域中被左对齐（如果<literal>-</>标志被指定）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>type</replaceable>（必需）</term>
       <listitem>
        <para>
         格式转换的类型，用于产生格式说明符的输出。支持下面的类型：
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal>将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal>将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等同于<function>quote_ident</>）。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal>将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串<literal>NULL</>（等同于<function>quote_nullable</function>）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     除了以上所述的格式说明符之外，要输出一个文字形式的<literal>%</>字符，可以使用特殊序列<literal>%%</>。
    </para>

    <para>
     下面有一些基本的格式转换的例子：

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>结果：</lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>结果：</><computeroutput>Testing one, two, three, %</>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\Program Files');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>

    <para>
     下面是使用<replaceable>width</replaceable>域和<literal>-</>标志的例子：

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>结果：</><computeroutput>|       foo|</>

SELECT format('|%-10s|', 'foo');
<lineannotation>结果：</><computeroutput>|foo       |</>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>结果：</><computeroutput>|       foo|</>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>结果：</><computeroutput>|foo       |</>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>结果：</><computeroutput>|foo       |</>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>结果：</><computeroutput>|foo       |</>
</screen>
    </para>

    <para>
     这些例子展示了<replaceable>position</>域的例子：

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>结果：</><computeroutput>Testing three, two, one</>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</><computeroutput>|       bar|</>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</><computeroutput>|       foo|</>
</screen>
    </para>

    <para>
     不同于标准的 C 函数<function>sprintf</>，<productname>PostgreSQL</>的<function>format</>函数允许将带有或者不带有<replaceable>position</>域的格式说明符被混在同一个格式字符串中。一个不带有<replaceable>position</>域的格式说明符总是使用最后一个被消耗的参数的下一个参数。另外，<function>format</>函数不要求所有函数参数都被用在格式字符串中。例如：

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>结果：</><computeroutput>Testing three, two, three</>
</screen>
    </para>

    <para>
     对于安全地构造动态 SQL 语句，<literal>%I</>和<literal>%L</>格式说明符特别有用。参见<xref linkend="plpgsql-quote-literal-example">。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
   <title>二进制串函数和操作符</title>

   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>

   <para>
    本节描述那些检查和操作类型为<type>bytea</type>的值的函数和操作符。
   </para>

   <para>
    <acronym>SQL</acronym>定义了一些使用关键字而不是逗号来分割参数的串函数。详情请见<xref linkend="functions-binarystring-sql">。<productname>PostgreSQL</>也提供了这些函数使用常规函数调用语法的版本（参阅<xref linkend="functions-binarystring-other">）。
   </para>

   <note>
    <para>
     本页中显示的示例结果假设服务器参数<link linkend="guc-bytea-output"><varname>bytea_output</></link>被设置为<literal>escape</literal>（传统PostgreSQL格式）。
    </para>
   </note>

   <table id="functions-binarystring-sql">
    <title><acronym>SQL</acronym>二进制串函数和操作符</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
        串连接
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
       </entry>
       <entry><literal>E'\\\\Post'::bytea || E'\\047gres\\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>二进制串中的字节数</entry>
       <entry><literal>octet_length(E'jo\\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        替换子串
       </entry>
       <entry><literal>overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002\\003mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>指定子串的位置</entry>
      <entry><literal>position(E'\\000om'::bytea in E'Th\\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        提取子串
       </entry>
       <entry><literal>substring(E'Th\\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        从<parameter>string</parameter>的开头或结尾删除只包含<parameter>bytes</parameter>中字节的最长串
       </entry>
       <entry><literal>trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    还有一些二进制串处理函数可以使用，在<xref linkend="functions-binarystring-other">列出。 其中有一些是在内部使用，用于实现<xref linkend="functions-binarystring-sql">列出的 SQL 标准串函数。
   </para>

   <table id="functions-binarystring-other">
    <title>其他二进制串函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        从<parameter>string</parameter>的开头或结尾删除只由<parameter>bytes</parameter>中字节组成的最长串
      </entry>
      <entry><literal>btrim(E'\\000trim\\000'::bytea, E'\\000'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
       从<parameter>string</>中的文本表示解码二进制数据。<parameter>format</>的参数和在<function>encode</>中一样。
      </entry>
      <entry><literal>decode(E'123\\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
       将二进制数据编码为一个文本表示。支持的格式有：<literal>base64</>、<literal>hex</>、<literal>escape</>。<literal>escape</>将零字节和高位组字节转换为八进制序列（<literal>\</><replaceable>nnn</>）和双反斜线。
      </entry>
      <entry><literal>encode(E'123\\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        从串中抽取位
       </entry>
       <entry><literal>get_bit(E'Th\\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        从串中抽取字节
       </entry>
       <entry><literal>get_byte(E'Th\\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>
       二进制串的长度
       <indexterm>
        <primary>binary string</primary>
        <secondary>length</secondary>
       </indexterm>
       <indexterm>
        <primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see>
       </indexterm>
      </entry>
      <entry><literal>length(E'jo\\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
       计算<parameter>string</parameter>的MD5哈希码，以十六进制形式返回结果
      </entry>
      <entry><literal>md5(E'Th\\000omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9689aaf18 b4958c334c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <literal><function>set_bit(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        设置串中的位
       </entry>
       <entry><literal>set_bit(E'Th\\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <literal><function>set_byte(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        设置串中的字节
       </entry>
       <entry><literal>set_byte(E'Th\\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <function>get_byte</>和<function>set_byte</>把一个二进制串中的一个字节计数为字节 0。<function>get_bit</>和<function>set_bit</>在每一个字节中从右边起计数位；例如位 0 是第一个字节的最低有效位，而位 15 是第二个字节的最高有效位。
  </para>

  <para>
  参见<xref linkend="functions-aggregate">中的聚集函数<function>string_agg</function>以及<xref linkend="lo-funcs">中的大对象函数。
  </para>
 </sect1>


  <sect1 id="functions-bitstring">
   <title>位串函数和操作符</title>

   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>

   <para>
    本节描述用于检查和操作位串的函数和操作符，也就是操作类型为<type>bit</type>和<type>bit varying</type>的值的函数和操作符。除了常用的比较操作符之外，还可以使用<xref linkend="functions-bit-string-op-table">里显示的操作符。<literal>&amp;</literal>、<literal>|</literal>和<literal>#</literal>的位串操作数必须等长。在移位的时候，保留原始的位串的的长度，如例子所示。
   </para>

   <table id="functions-bit-string-op-table">
    <title>位串操作符</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
       <entry>连接</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>按位与</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>按位或</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>按位异或</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>按位求反</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>按位左移</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>按位右移</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    下面的<acronym>SQL</acronym>标准函数除了可以用于字符串之外，也可以用于位串：
    <literal><function>length</function></literal>、
    <literal><function>bit_length</function></literal>、
    <literal><function>octet_length</function></literal>、
    <literal><function>position</function></literal>、
    <literal><function>substring</function></literal>、
    <literal><function>overlay</function></literal>。
   </para>

   <para>
    下面的函数除了可以用于二进制串之外，也可以用于位串：
    <literal><function>get_bit</function></literal>、
    <literal><function>set_bit</function></literal>。
    当使用于一个位串时，这些函数将串的第一（最左）位计数为位 0。
   </para>

   <para>
    另外，我们可以在整数和<type>bit</>之间来回转换。一些例子：
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    请注意，如果只是转换为<quote>bit</>，意思是转换成<literal>bit(1)</>，因此只会转换整数的最低有效位。
   </para>

    <note>
     <para>
      把一个整数转换成<type>bit(n)</>将拷贝整数的最右边的<literal>n</>位。
      把一个整数转换成比整数本身长的位串，就会在最左边扩展符号。
     </para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
  <title>模式匹配</title>

  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>

   <para>
    <productname>PostgreSQL</productname>提供了三种独立的实现模式匹配的方法：<acronym>SQL</acronym> <function>LIKE</function>操作符、更近一些的<function>SIMILAR TO</function>操作符（SQL:1999 里添加进来的）和<acronym>POSIX</acronym>-风格的正则表达式。除了这些基本的<quote>这个串匹配这个模式吗？</>操作符外，还有一些函数可用于提取或替换匹配子串并在匹配位置分离一个串。
   </para>

   <tip>
    <para>
     如果你的模式匹配的要求超出了这些，请考虑用 Perl 或 Tcl 写一个用户定义的函数。
    </para>
   </tip>

   <caution>
    <para>
     当大多数正则表达式搜索可以很快执行时，
     正则表达式可以被设计，采取时间和存储过程的任意数量。
     警惕接受来自敌对来源的正则表达式搜索模式。
     如果你必须这样做，那么建议强加语句超时。
    </para>

    <para>
     使用<function>SIMILAR TO</function>模式的搜索具有相同的安全隐患，
     因为<function>SIMILAR TO</function>
     提供了许多诸如<acronym>POSIX</acronym>风格的规则表达式相同的能力。
    </para>

    <para>
     <function>LIKE</function>搜索，比其它两个选项更简单，安全使用可能的敌对模式源。
    </para>
   </caution>
   
  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <para>
     如果该<replaceable>string</replaceable>匹配了提供的<replaceable>pattern</replaceable>，那么<function>LIKE</function>表达式返回真（和预期的一样，如果<function>LIKE</function>返回真，那么<function>NOT LIKE</function>表达式返回假， 反之亦然。一个等效的表达式是<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>）。
    </para>

    <para>
     如果<replaceable>pattern</replaceable>不包含百分号或者下划线，那么该模式只代表它本身的串；这时候<function>LIKE</function>的行为就象等号操作符。在<replaceable>pattern</replaceable>里的下划线 （<literal>_</literal>）代表（匹配）任何单个字符； 而一个百分号（<literal>%</literal>）匹配任何零或更多个字符的序列。
    </para>

   <para>
    一些例子：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
    <function>LIKE</function>模式匹配总是覆盖整个串。因此，要匹配在串内任何位置的序列，该模式必须以百分号开头和结尾。
   </para>

   <para>
    要匹配文本的下划线或者百分号，而不是匹配其它字符， 在<replaceable>pattern</replaceable>里相应的字符必须 前导逃逸字符。缺省的逃逸字符是反斜线，但是你可以用<literal>ESCAPE</literal>子句指定一个不同的逃逸字符。 要匹配逃逸字符本身，写两个逃逸字符。
   </para>

   <note>
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings">，你在文串常量中写的任何反斜线都需要被双写。详见<xref linkend="sql-syntax-strings">。
    </para>
   </note>

   <para>
    请注意反斜线在串文本里已经有特殊含义了，所以如果你写一个 包含反斜线的模式常量，那你就要在 SQL 语句里写两个反斜线。 因此，写一个匹配单个反斜线的模式实际上要在语句里写四个反斜线。 你可以通过用 ESCAPE 选择一个不同的逃逸字符 来避免这样；这样反斜线就不再是 LIKE 的特殊字符了。 但仍然是字符文本分析器的特殊字符，所以你还是需要两个反斜线。)
    我们也可以通过写<literal>ESCAPE ''</literal>的方式不选择逃逸字符，这样可以有效地禁用逃逸机制，但是没有办法关闭下划线和百分号在模式中的特殊含义。
   </para>

   <para>
    关键字<token>ILIKE</token>可以用于替换<token>LIKE</token>， 它令该匹配根据活动区域成为大小写无关。这个不属于<acronym>SQL</acronym>标准而是一个<productname>PostgreSQL</productname>扩展。
   </para>

   <para>
    操作符<literal>~~</literal>等效于<function>LIKE</function>， 而<literal>~~*</literal>对应<function>ILIKE</function>。 还有 <literal>!~~</literal>和<literal>!~~*</literal>操作符分别代表<function>NOT LIKE</function>和<function>NOT ILIKE</function>。所有这些操作符都是<productname>PostgreSQL</productname>特有的。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
   <title><function>SIMILAR TO</function>正则表达式</title>

   <indexterm>
    <primary>regular expression</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <para>
    <function>SIMILAR TO</function>操作符根据自己的模式是否匹配给定串而返回真或者假。 它和<function>LIKE</function>非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。 SQL 正则表达式是在<function>LIKE</function>标记和普通的正则表达式标记的奇怪的杂交。
   </para>

   <para>
    类似<function>LIKE</function>，<function>SIMILAR TO</function>操作符只有在它的模式匹配整个串的时候才能成功；这一点和普通的 正则表达式的行为不同，在普通的正则表达式里，模式匹配串的任意部分。 和<function>LIKE</function>类似的地方还有，<function>SIMILAR TO</function>使用<literal>_</>和<literal>%</>作为分别代表任意单个字符和任意串的通配符（这些可以比得上 POSIX 正则表达式里的<literal>.</>和<literal>.*</>）。
   </para>

   <para>
    除了这些从<function>LIKE</function>借用的功能之外，<function>SIMILAR TO</function>支持下面这些从 POSIX 正则表达式借用的 模式匹配元字符：

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal>表示选择（两个候选之一）。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal>表示重复前面的项零次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal>表示重复前面的项一次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal>表示重复前面的项零次或一次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</><replaceable>m</><literal>}</literal>表示重复前面的项刚好<replaceable>m</>次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</><replaceable>m</><literal>,}</literal>表示重复前面的项<replaceable>m</>次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>表示重复前面的项至少<replaceable>m</>次并且不超过<replaceable>n</>次。
     </para>
    </listitem>
    <listitem>
     <para>
      可以使用圆括号<literal>()</literal>把多个项组合成一个逻辑项。
     </para>
    </listitem>
    <listitem>
     <para>
      一个方括号表达式<literal>[...]</literal>声明一个字符类，就像 POSIX 正则表达式一样。
     </para>
    </listitem>
   </itemizedlist>

    注意点号（<literal>.</>）不是<function>SIMILAR TO</>的一个元字符。
   </para>

   <para>
    和<function>LIKE</>一样，反斜线禁用所有这些元字符的特殊含义；当然我们也可以用<literal>ESCAPE</>指定一个不同的逃逸字符。
   </para>

   <para>
    一些例子：
<programlisting>
'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
    带三个参数的<function>substring</>，即<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)</function>，提供了抽取一个匹配 SQL 正则表达式的子串的方法。和<literal>SIMILAR TO</>一样，声明的模式必须匹配整个数据串，否则函数失败并返回空值。为了标识在成功的时候应该返回的模式部分，模式 必须包含逃逸字符的两次出现，并且后面要跟上双引号（<literal>"</>）。匹配这两个标记之间的模式的文本将被返回。
   </para>

   <para>
    一些例子，使用<literal>#&quot;</>定界返回串：
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
   <title><acronym>POSIX</acronym>正则表达式</title>

   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

   <para>
    <xref linkend="functions-posix-table">列出了所有可用于 POSIX 正则表达式模式匹配的操作符。
   </para>

   <table id="functions-posix-table">
    <title>正则表达式匹配操作符</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>匹配正则表达式，大小写敏感</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
        <entry>匹配正则表达式，大小写不敏感</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
        <entry>不匹配正则表达式，大小写敏感</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
        <entry>不匹配正则表达式，大小写不敏感</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     <acronym>POSIX</acronym>正则表达式提供了比<function>LIKE</function>和<function>SIMILAR TO</>操作符更强大的含义。许多 Unix 工具，例如<command>egrep</command>、<command>sed</command>或<command>awk</command>使用一种与我们这里描述的类似的模式匹配语言。
    </para>

    <para>
     正则表达式是一个字符序列，它是定义一个串集合 （一个<firstterm>正则集</firstterm>）的缩写。 如果一个串是正则表达式描述的正则集中的一员时， 我们就说这个串匹配该正则表达式。 和<function>LIKE</function>一样，模式字符准确地匹配串字符， 除非在正则表达式语言里有特殊字符 &mdash; 不过正则表达式用的 特殊字符和<function>LIKE</function>用的不同。 和<function>LIKE</function>模式不一样的是，正则表达式允许匹配串里的任何位置，除非该正则表达式显式地挂接在串的开头或者结尾。
    </para>

    <para>
     一些例子：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

    <para>
     <acronym>POSIX</acronym>模式语言的详细描述见下文。
    </para>

    <para>
     带两个参数的<function>substring</>函数，即<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable>)</function>，提供了抽取一个匹配 POSIX 正则表达式模式的子串的方法。如果没有匹配它返回空值，否则就是文本中匹配模式的那部分。 但是如果该模式包含任何圆括号，那么将返回匹配第一对子表达式（对应第一个左圆括号的） 的文本。如果你想在表达式里使用圆括号而又不想导致这个例外，那么你可以在整个表达式外边放上一对圆括号。 如果你需要在想抽取的子表达式前有圆括号，参阅后文描述的非捕获性圆括号。
    </para>

   <para>
    一些例子：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

    <para>
     <function>regexp_replace</>函数提供了将匹配 POSIX 正则表达式模式的子串替换为新文本的功能。 它的语法是 <function>regexp_replace</function>(<replaceable>source</>, <replaceable>pattern</>, <replaceable>replacement</> <optional>, <replaceable>flags</> </optional>)。 如果没有匹配<replaceable>pattern</>，那么返回不加修改的<replaceable>source</>串。 如果有匹配，则返回的<replaceable>source</>串里面的匹配子串将被<replaceable>replacement</>串替换掉。<replaceable>replacement</>串可以包含<literal>\</><replaceable>n</>， 其中<literal>\</><replaceable>n</>是 1 到 9， 表明源串里匹配模式里第<replaceable>n</>个圆括号子表达式的子串应该被插入， 并且它可以包含<literal>\&amp;</>表示应该插入匹配整个模式的子串。如果你需要放一个文字形式的反斜线在替换文本里，那么写<literal>\\</>。<replaceable>flags</>参数是一个可选的文本串，它包含另个或更多单字母标志，这些标志可以改变函数的行为。标志<literal>i</>指定大小写无关的匹配，而标志<literal>g</>指定替换每一个匹配的子串而不仅仅是第一个。支持的标志（但不是<literal>g</>）在<xref linkend="posix-embedded-options-table">中描述。
    </para>

   <para>
    一些例子：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

    <para>
     <function>regexp_matches</>函数返回一个文本数组，该数组由匹配一个 POSIX 正则表达式模式得到的所有被捕获子串构成。其语法是<function>regexp_matches</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)。该函数可以不返回任何行、返回一行或者返回多行（见下文的<literal>g</>）。如果<replaceable>pattern</>不匹配，该函数不返回行。如果模式不包含圆括号子表达式，则每一个被返回的行都是一个单一元素的文本数组，其中包括匹配整个模式的子串。如果模式包含圆括号子表达式，该函数返回一个文本数组，它的第<replaceable>n</>个元素是匹配模式的第<replaceable>n</>个圆括号子表达式的子串（<quote>非捕获</>圆括号不计算在内，详见下文）。<replaceable>flags</>参数是一个可选的文本字符串，它包含零个或更多个单字母标志，它们可以改变函数的行为。标志<literal>g</>让函数寻找串中的每一个匹配，而不仅仅是第一个，并且为每一个这样的匹配返回一行。支持的标志（但不是<literal>g</>）在<xref linkend="posix-embedded-options-table">中描述。
    </para>

   <para>
    一些例子：
<programlisting>
SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
 regexp_matches 
----------------
 {bar,beque}
(1 row)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches 
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)

SELECT regexp_matches('foobarbequebaz', 'barbeque');
 regexp_matches 
----------------
 {barbeque}
(1 row)
</programlisting>
   </para>

   <para>
    也可以强制<function>regexp_matches()</>通过使用一个子选择来总是返回一行。当你希望所有行都被返回（甚至是不能匹配的行）时，把它用在一个<literal>SELECT</>目标列表中会特别有用：
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
   </para>

    <para>
     <function>regexp_split_to_table</>把一个 POSIX 正则表达式模式当作一个定界符来分离一个串。它的语法形式是<function>regexp_split_to_table</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)。如果没有与<replaceable>pattern</>的匹配，该函数返回<replaceable>string</>。如果有至少有一个匹配，对每一个匹配它都返回从上一个匹配的末尾（或者串的开头）到这次匹配开头之间的文本。当没有更多匹配时，它返回从上一次匹配的末尾到串末尾之间的文本。<replaceable>flags</>参数是一个可选的文本串，它包含零个或更多单字母标志，这些标识可以改变该函数的行为。<function>regexp_split_to_table</function>能支持的标志在<xref linkend="posix-embedded-options-table">中描述。
    </para>

    <para>
     <function>regexp_split_to_array</>函数的行为和<function>regexp_split_to_table</>相同，不过<function>regexp_split_to_array</>会把它的结果以一个<type>text</>数组的形式返回。它的语法是<function>regexp_split_to_array</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)。这些参数和<function>regexp_split_to_table</>的相同。
    </para>

   <para>
    一些例子：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

   <para>
    正如上一个例子所示，正则表达式分离函数会忽略零长度的匹配，这种匹配发生在串的开头或结尾或者正好发生在前一个匹配之后。这和正则表达式匹配的严格定义是相悖的，后者由<function>regexp_matches</>实现，但是通常前者是实际中最常用的行为。其他软件系统如Perl也使用相似的定义。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
    <title>正则表达式细节</title>

   <para>
    <productname>PostgreSQL</productname>的正则表达式是使用 Henry Spencer 写的一个包来实现的。下面的正则表达式的大部分描述都是从他的手册页中逐字拷贝过来的。
   </para>

   <para>
    正则表达式（<acronym>RE</acronym>），在<acronym>POSIX</acronym> 1003.2 中定义， 它有两种形式：<firstterm>扩展</>的<acronym>RE</acronym>或者是<acronym>ERE</>（大概地说就是那些在<command>egrep</command>里的）， <firstterm>基本</>的<acronym>RE</acronym>或者是<acronym>BRE</>（大概地说就是那些在<command>ed</command>里的）。<productname>PostgreSQL</productname>支持两种形式，并且还实现了一些POSIX标准中没有但是在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。使用了那些非POSIX扩展的<acronym>RE</acronym>叫<firstterm>高级</><acronym>RE</acronym>， 或者本文档里说的<acronym>ARE</>。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容（以及更多的限制）。我们首先描述 ARE 和 ERE 形式， 描述那些只适用于 ARE 的特性，然后描述 BRE 的区别是什么。
   </para>

   <note>
    <para>
     <productname>PostgreSQL</>初始时总是推测一个正则表达式遵循 ARE 规则。但是，可以通过为 RE 模式预置一个<firstterm>embedded option</>来选择限制更多的 ERE 或 BRE 规则，如<xref linkend="posix-metasyntax">中所述。这对为期望准确的<acronym>POSIX</acronym> 1003.2 规则的应用提供兼容性很有用。
    </para>
   </note>

   <para>
    一个正则表达式被定义为一个或更多<firstterm>分支</firstterm>，它们之间被<literal>|</literal>分隔。只要能匹配其中一个分支的东西都能匹配正则表达式。
   </para>

   <para>
    一个分支是一个或多个<firstterm>量化原子</>或者<firstterm>约束</>连接而成。一个原子匹配第一个，然后后面的原子匹配第二个， 以此类推；一个空分支匹配空串。
   </para>

   <para>
    一个量化原子是一个<firstterm>原子</>， 后面可能跟着一个<firstterm>量词</>。没有量词的时候，它匹配一个原子， 有量词的时候，它可以匹配若干个原子。一个<firstterm>原子</>可以是在<xref linkend="posix-atoms-table">里面显示的任何可能。 可能的量词和它们的含义在<xref linkend="posix-quantifiers-table">里显示。
   </para>

   <para>
    一个<firstterm>约束</>匹配一个空串，但只是在满足特定条件下才匹配。 约束可以在能够使用原子的地方使用，只是它不能跟着量词。简单的约束在<xref linkend="posix-constraints-table">里显示； 更多的约束稍后描述。
   </para>


   <table id="posix-atoms-table">
    <title>正则表达式原子</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>原子</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</><replaceable>re</><literal>)</> </entry>
       <entry>（其中<replaceable>re</>是任何正则表达式） 匹配一个对<replaceable>re</>的匹配，匹配将为可能的报告被记下</entry>
       </row>

       <row>
       <entry> <literal>(?:</><replaceable>re</><literal>)</> </entry>
       <entry>同上，但是匹配不会为了报告而被记下 （一个<quote>非捕获</>圆括号集） （只对 ARE）</entry>
       </row>

       <row>
       <entry> <literal>.</> </entry>
       <entry>匹配任意单个字符</entry>
       </row>

       <row>
       <entry> <literal>[</><replaceable>chars</><literal>]</> </entry>
       <entry> 一个<firstterm>方括号表达式</>， 匹配<replaceable>chars</>中的任意一个（详见<xref linkend="posix-bracket-expressions">）</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>k</> </entry>
       <entry>（其中<replaceable>k</>是一个非字母数字字符） 匹配一个被当作普通字符看待的特定字符， 例如，<literal>\\</>匹配一个反斜线字符</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>c</> </entry>
       <entry>其中<replaceable>c</>是一个字母数字 （可能跟着其它字符），它是一个<firstterm>逃逸</>， 参阅<xref linkend="posix-escape-sequences">（仅对 ARE； 在 ERE 和 BRE 中，它匹配<replaceable>c</>）</entry>
       </row>

       <row>
       <entry> <literal>{</> </entry>
       <entry>如果后面跟着一个字符，而不是数字， 那么就匹配左花括弧<literal>{</>；如果跟着一个数字， 那么它是<replaceable>范围</>的开始（见下文）</entry>
       </row>

       <row>
       <entry> <replaceable>x</> </entry>
       <entry>其中<replaceable>x</>是一个没有其它意义的单个字符，则匹配该字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    RE 不能以反斜线（<literal>\</>）结尾。
   </para>

   <note>
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings">，任何你写在文字串常量中的反斜线都需要被双写。详见<xref linkend="sql-syntax-strings">。
    </para>
   </note>

   <table id="posix-quantifiers-table">
    <title>正则表达式量词</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>量词</entry>
       <entry>匹配</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</> </entry>
       <entry>一个由原子的 0 次或更多次匹配组成的序列</entry>
       </row>

       <row>
       <entry> <literal>+</> </entry>
       <entry>一个由原子的 1 次或更多次匹配组成的序列</entry>
       </row>

       <row>
       <entry> <literal>?</> </entry>
       <entry>一个由原子的 0 次或 1 次匹配组成的序列</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}</> </entry>
       <entry>一个由原子的正好<replaceable>m</>次匹配组成的序列</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}</> </entry>
       <entry>一个由原子的<replaceable>m</>次或更多次匹配组成的序列</entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
       <entry>一个由原子的从<replaceable>m</>次到<replaceable>n</>次（包括）匹配组成的序列；<replaceable>m</>不能超过<replaceable>n</> </entry>
       </row>

       <row>
       <entry> <literal>*?</> </entry>
       <entry><literal>*</>的非贪婪版本</entry>
       </row>

       <row>
       <entry> <literal>+?</> </entry>
       <entry><literal>+</>的非贪婪版本</entry>
       </row>

       <row>
       <entry> <literal>??</> </entry>
       <entry><literal>?</>的非贪婪版本</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}?</> </entry>
       <entry><literal>{</><replaceable>m</><literal>}</>的非贪婪版本 </entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}?</> </entry>
       <entry><literal>{</><replaceable>m</><literal>,}</>的非贪婪版本 </entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</> </entry>
       <entry><literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>的非贪婪版本 </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    使用<literal>{</><replaceable>...</><literal>}</>的形式被称作<firstterm>范围</>。 一个范围内的数字<replaceable>m</>和<replaceable>n</>都是无符号十进制整数， 允许的数值从 0 到 255（包含）。
   </para>

    <para>
     <firstterm>非贪婪</>的量词（只在 ARE 中可用）匹配对应的正常 （<firstterm>贪婪</>）模式，区别是它寻找最少的匹配，而不是最多的匹配。详见<xref linkend="posix-matching-rules">。
   </para>

   <note>
    <para>
     一个量词不能紧跟在另外一个量词后面，例如<literal>**</>是非法的。量词不能作为表达式或者子表达式的开头，也不能跟在<literal>^</literal>或者<literal>|</literal>后面。
    </para>
   </note>

   <table id="posix-constraints-table">
    <title>正则表达式约束</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>约束</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</> </entry>
       <entry>串开头的匹配</entry>
       </row>

       <row>
       <entry> <literal>$</> </entry>
       <entry>串末尾的匹配</entry>
       </row>

       <row>
       <entry> <literal>(?=</><replaceable>re</><literal>)</> </entry>
       <entry>在匹配<replaceable>re</>的子串开始的任何点的<firstterm>positive lookahead</>匹配（只对 ARE）</entry>
       </row>

       <row>
       <entry> <literal>(?!</><replaceable>re</><literal>)</> </entry>
       <entry>在匹配<replaceable>re</>的子串开始的任何点的<firstterm>negative lookahead</>匹配（只对 ARE）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Lookahead约束不能包含<firstterm>后引用</> （参阅<xref linkend="posix-escape-sequences">），并且其中的所有圆括号 都被认为是非捕获的。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
    <title>方括号表达式</title>

   <para>
    <firstterm>方括号表达式</firstterm>是一个包围在<literal>[]</literal>中的字符列表。它通常匹配列表中的任意单个字符（但见下文）。 如果列表以<literal>^</literal>开头，它匹配任意单个<emphasis>不</>在该列表参与部分中的字符。如果该列表中两个字符用<literal>-</literal>隔开， 那它就是那两个字符（包括在内）之间的所有字符范围的缩写，例如，在<acronym>ASCII</acronym>中<literal>[0-9]</literal>匹配任何十进制数字。两个范围共享一个端点是非法的，例如，<literal>a-c-e</literal>。范围与字符集关系密切， 可移植的程序应该避免依靠它们。
   </para>

   <para>
    想在列表中包含文本<literal>]</literal>，可以让它做列表的首字符（如果使用了<literal>^</literal>，需要放在其后）。 想在列表中包含文本<literal>-</literal>，可以让它做列表的首字符或者尾字符，或者一个范围的第二个端点。 想在列表中把文本<literal>-</literal>当做范围的起点， 把它用<literal>[.</literal>和<literal>.]</literal>包围起来，这样它就成为一个排序元素（见下文）。 除了这些字符本身、一些用<literal>[</literal>的组合（见下段）以及逃逸（只在 ARE 中有效）以外，所有其它特殊字符 在方括号表达式里都失去它们的特殊含义。特别是，在 ERE 和 BRE 规则下<literal>\</literal>不是特殊的， 但在 ARE 里，它是特殊的（引入一个逃逸）。
   </para>

   <para>
    在一个方括号表达式里，一个排序元素（一个字符、一个被当做一个单一字符排序的多字符序列或者一个表示上面两种情况的排序序列名称） 包含在<literal>[.</literal>和<literal>.]</literal>里面的时候表示该排序元素的字符序列。该序列被当做该方括号列表 的一个单一元素。这允许一个包含多字符排序元素的方括号表达式去匹配多于一个字符，例如，如果排序序列包含一个<literal>ch</literal>排序元素， 那么 RE <literal>[[.ch.]]*c</literal>匹配<literal>chchcc</literal>的头五个字符。
   </para>

   <note>
    <para>
     <productname>PostgreSQL</>当前不支持多字符排序元素。这些信息描述了将来可能有的行为。
    </para>
   </note>

   <para>
    在方括号表达式里，包围在<literal>[=</literal>和<literal>=]</literal>里的排序元素是一个<firstterm>等价类</>， 代表等效于那一个的所有排序元素的字符序列，包括它本身（如果没有其它等效排序元素，那么就好象封装定界符是<literal>[.</literal>和 <literal>.]</literal>）。例如，如果<literal>o</literal>和<literal>^</literal>是一个等价类的成员，那么<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>和<literal>[o^]</literal>都是同义的。一个等价类不能是一个范围的端点。
   </para>

   <para>
    在方括号表达式里，在<literal>[:</literal>和<literal>:]</literal>里面封装的字符类的名字代表属于该类的所有字符的列表。 标准的字符类名字是：<literal>alnum</literal>、
    <literal>alpha</literal>、<literal>blank</literal>、
    <literal>cntrl</literal>、<literal>digit</literal>、
    <literal>graph</literal>、<literal>lower</literal>、
    <literal>print</literal>、<literal>punct</literal>、
    <literal>space</literal>、<literal>upper</literal>、
    <literal>xdigit</literal>。 它们代表在<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>中定义的字符类。 一个区域可以会提供其他的类。字符类不能用做一个范围的端点。
   </para>

   <para>
    方括号表达式里有两个特例：方括号表达式<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>是约束，分别匹配一个单词开头和结束的空串。 单词定义为一个单词字符序列，前面和后面都没有其它单词字符。单词字符是一个<literal>alnum</>字符（和<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>中定义的一样） 或者一个下划线。这是一个扩展，兼容<acronym>POSIX</acronym> 1003.2， 但那里面并没有说明， 而且在准备移植到其他系统里去的软件里一定要小心使用。通常下文描述的约束逃逸更好些（它们并非更标准，但是更容易键入）。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
    <title>正则表达式逃逸</title>

   <para>
    <firstterm>逃逸</>是以<literal>\</>开头，后面跟着一个字母数字字符得特殊序列。 逃逸有好几种变体：字符项、类缩写、约束逃逸以及后引用。在 ARE 里， 如果一个<literal>\</>后面跟着一个字母数字，但是并未组成一个合法的逃逸， 那么它是非法的。在 ERE 中没有逃逸：在方括号表达式之外，一个后面跟着字母数字字符的<literal>\</>只是表示该字符是一个普通的字符，而且在一个方括号表达式里，<literal>\</>是一个普通的字符（后者实际上在 ERE 和 ARE 不兼容）。
   </para>

   <para>
    <firstterm>字符项逃逸</>用于便于我们在 RE 中声明那些不可打印的或其他习惯的字符。它们显示在<xref linkend="posix-character-entry-escapes-table">中。
   </para>

   <para>
    <firstterm>类缩写逃逸</>用来提供一些常用的字符类缩写。它们显示在<xref linkend="posix-class-shorthand-escapes-table">中。
   </para>

   <para>
    <firstterm>约束逃逸</>是一个约束，如果满足特定的条件，它匹配该空串。它们显示在<xref linkend="posix-constraint-escapes-table">中。
   </para>

   <para>
    <firstterm>后引用</>（<literal>\</><replaceable>n</>）匹配数字<literal>\</><replaceable>n</>指定的被前面的圆括号子表达式匹配的同一个串 （参阅<xref linkend="posix-constraint-backref-table">）。例如， <literal>([bc])\1</>匹配<literal>bb</>或者<literal>cc</>， 但是不匹配<literal>bc</>或者<literal>cb</>。RE 中子表达式必须完全在后引用前面。子表达式以它们的先导圆括号的顺序编号。非捕获圆括号并不定义子表达式。
   </para>

   <table id="posix-character-entry-escapes-table">
    <title>正则表达式字符项逃逸</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</> </entry>
       <entry>警告（响铃）字符，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\b</> </entry>
       <entry>退格，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\B</> </entry>
       <entry>反斜线（<literal>\</>）的同义词，用来减少双写反斜线</entry>
       </row>

       <row>
       <entry> <literal>\c</><replaceable>X</> </entry>
       <entry>（其中<replaceable>X</>是任意字符）低序5位和<replaceable>X</>相同的字符，它的其他位都是零</entry>
       </row>

       <row>
       <entry> <literal>\e</> </entry>
       <entry>排序序列名为<literal>ESC</>的字符，如果无法做到该字符为八进制值<literal>033</></entry>
       </row>

       <row>
       <entry> <literal>\f</> </entry>
       <entry>换页，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\n</> </entry>
       <entry>新行，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\r</> </entry>
       <entry>回车，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\t</> </entry>
       <entry>水平制表符，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\u</><replaceable>wxyz</> </entry>
       <entry>
       （其中<replaceable>wxyz</>正好是四个十六进制位）
        字符十六进制值是<literal>0x</><replaceable>wxyz</>
       </entry>
       </row>

       <row>
       <entry> <literal>\U</><replaceable>stuvwxyz</> </entry>
       <entry>（其中<replaceable>stuvwxyz</>正好是八个十六进制位）
       字符十六进制值是<literal>0x</><replaceable>stuvwxyz</> 
       </entry>
       </row>

       <row>
       <entry> <literal>\v</> </entry>
       <entry>垂直制表符，和 C 中一样</entry>
       </row>

       <row>
       <entry> <literal>\x</><replaceable>hhh</> </entry>
       <entry>（其中<replaceable>hhh</>是十六进制位的任意序列）十六进制值为<literal>0x</><replaceable>hhh</>的字符（一个单一字符，不管用了多少个十六进制位）
       </entry>
       </row>

       <row>
       <entry> <literal>\0</> </entry>
       <entry>值为<literal>0</>（空字节）的字符</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xy</> </entry>
       <entry>（其中<replaceable>xy</>正好是两个八进制位，并且不是一个<firstterm>后引用</>）八进制值为<literal>0</><replaceable>xy</>的字符</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xyz</> </entry>
       <entry>（其中<replaceable>xyz</>正好是三个八进制位，并且不是一个<firstterm>后引用</>）八进制值为<literal>0</><replaceable>xyz</>的字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    十六进制位是<literal>0</>-<literal>9</>、<literal>a</>-<literal>f</>和<literal>A</>-<literal>F</>。八进制位是<literal>0</>-<literal>7</>。
   </para>

   <para>
     指定ASCII范围以外的值（0-127）数字字符输入逃逸依赖于数据库编码。
     当编码是UTF-8的时候，逃避值相当于Unicode代码点，
     例如<literal>\u1234</>即字符<literal>U+1234</>。
     对于其它多字节编码，字符输入转义通常只指定字符的字节值的连接。
     如果逃逸值不与数据库编码中的任何合法字符相对应，不会抛出错误，
     但它永远不会匹配任何数据。
   </para>
   
   <para>
    字符项逃逸总是被当作普通字符。例如，<literal>\135</>是 ASCII 中的<literal>]</>， 但<literal>\135</>并不终止一个方括号表达式。
   </para>

   <table id="posix-class-shorthand-escapes-table">
    <title>正则表达式类缩写逃逸</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</> </entry>
       <entry> <literal>[[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\s</> </entry>
       <entry> <literal>[[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\w</> </entry>
       <entry> <literal>[[:alnum:]_]</>（注意下划线是被包括的）</entry>
       </row>

       <row>
       <entry> <literal>\D</> </entry>
       <entry> <literal>[^[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\S</> </entry>
       <entry> <literal>[^[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\W</> </entry>
       <entry> <literal>[^[:alnum:]_]</>
      （注意下划线是被包括的）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    在方括号表达式里，<literal>\d</>、<literal>\s</>和<literal>\w</>会失去它们的外层方括号，而<literal>\D</>、<literal>\S</>和 <literal>\W</>是非法的（也就是说，例如<literal>[a-c\d]</>等效于<literal>[a-c[:digit:]]</>。同样<literal>[a-c\D]</>等效于 <literal>[a-c^[:digit:]]</>的，也是非法的）。
   </para>

   <table id="posix-constraint-escapes-table">
    <title>正则表达式约束逃逸</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</> </entry>
       <entry>只在串开头匹配（与<literal>^</>的不同请参见<xref linkend="posix-matching-rules">）</entry>
       </row>

       <row>
       <entry> <literal>\m</> </entry>
       <entry>只在一个词的开头匹配</entry>
       </row>

       <row>
       <entry> <literal>\M</> </entry>
       <entry>只在一个词的末尾匹配</entry>
       </row>

       <row>
       <entry> <literal>\y</> </entry>
       <entry>只在一个词的开头或末尾匹配</entry>
       </row>

       <row>
       <entry> <literal>\Y</> </entry>
       <entry>只在一个词的不是开头或末尾的点上匹配</entry>
       </row>

       <row>
       <entry> <literal>\Z</> </entry>
       <entry>只在串的末尾匹配（与<literal>$</>的不同请参见<xref linkend="posix-matching-rules">）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    一个词被定义成在上面<literal>[[:&lt;:]]</>和<literal>[[:&gt;:]]</>中的声明。在方括号表达式里，约束逃逸是非法的。
   </para>

   <table id="posix-constraint-backref-table">
    <title>正则表达式后引用</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</><replaceable>m</> </entry>
       <entry>（其中<replaceable>m</>是一个非零位）一个到第<replaceable>m</>个子表达式的后引用</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>mnn</> </entry>
       <entry>（其中<replaceable>m</>是一个非零位，并且<replaceable>nn</>是一些更多的位，并且十六进制值<replaceable>mnn</>不超过目前能看到的封闭捕获圆括号的数目）一个到第<replaceable>mnn</>个子表达式的后引用</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     在八进制字符项逃逸和后引用之间有一个历史继承的歧义存在，这个歧义是 通过下面的启发式规则解决的，像上面描述地那样。前导零总是表示这是一个八进制逃逸。 而单个非零数字，如果没有跟着任何其它位，那么总是被认为后引用。 一个多位的非零开头的序列也被认为是后引用，只要它出现在合适的子表达式后面 （也就是说，在后引用的合法范围中的数），否则就被认为是一个八进制。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
    <title>正则表达式元语法</title>

   <para>
    除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。
   </para>

   <para>
    如果一个 RE 以<literal>***:</>开头，那么剩下的 RE 都被当作 ARE（这在<productname>PostgreSQL</>中通常是无效的，因为 RE 被假定为 ARE，但是如果 ERE 或 BRE 模式通过<replaceable>flags</>参数被指定为一个正则表达式函数时，它确实能产生效果）。如果一个 RE 以<literal>***=</>开头， 那么剩下的 RE 被当作一个文本串，所有的字符都被认为是一个普通字符。
   </para>

   <para>
    一个 ARE 可以以<firstterm>嵌入选项</>开头：一个序列<literal>(?</><replaceable>xyz</><literal>)</>（这里的<replaceable>xyz</>是一个或多个字母字符）声明影响剩余 RE 的选项。 这些选项覆盖任何前面判断的选项 &mdash; 特别地，它们可以覆盖一个正则表达式操作符隐含的大小写敏感的行为，或者覆盖<replaceable>flags</>参数中的正则表达式函数。可用的选项字母在<xref linkend="posix-embedded-options-table">中显示。注意这些同样的选项字母也被用在正则表达式函数的<replaceable>flags</>参数中。
   </para>

   <table id="posix-embedded-options-table">
    <title>ARE 嵌入选项字母</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>选项</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</> </entry>
       <entry>RE的剩余部分是一个BRE </entry>
       </row>

       <row>
       <entry> <literal>c</> </entry>
       <entry>大小写敏感的匹配（覆盖操作符类型）</entry>
       </row>

       <row>
       <entry> <literal>e</> </entry>
       <entry>RE的剩余部分是一个ERE </entry>
       </row>

       <row>
       <entry> <literal>i</> </entry>
       <entry>大小写不敏感的匹配（见<xref linkend="posix-matching-rules">）（覆盖操作符类型）</entry>
       </row>

       <row>
       <entry> <literal>m</> </entry>
       <entry><literal>n</>的历史原因的同义词 </entry>
       </row>

       <row>
       <entry> <literal>n</> </entry>
       <entry>新行敏感的匹配（见<xref linkend="posix-matching-rules">）</entry>
       </row>

       <row>
       <entry> <literal>p</> </entry>
       <entry>部分新行敏感的匹配（见<xref linkend="posix-matching-rules">）</entry>
       </row>

       <row>
       <entry> <literal>q</> </entry>
       <entry>RE的剩余部分是一个文字（<quote>quoted</>）串，全部是普通字符</entry>
       </row>

       <row>
       <entry> <literal>s</> </entry>
       <entry>非新行敏感的匹配（默认）</entry>
       </row>

       <row>
       <entry> <literal>t</> </entry>
       <entry>紧语法（默认，见下文）</entry>
       </row>

       <row>
       <entry> <literal>w</> </entry>
       <entry>逆部分新行敏感（<quote>怪异</>）的匹配（见<xref linkend="posix-matching-rules">）</entry>
       </row>

       <row>
       <entry> <literal>x</> </entry>
       <entry>扩展语法（见下文）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    嵌入选项在<literal>)</>终止序列时发生作用。它们只在 ARE 的开始处起作用 （在任何可能存在的<literal>***:</>控制器后面）。
   </para>

   <para>
    除了通常的（<firstterm>紧</>）RE 语法（这种情况下所有字符都有效）， 还有一种<firstterm>扩展</>语法，可以通过声明嵌入的<literal>x</>选项获得。在扩展语法里，RE 中的空白字符被忽略，就像那些在<literal>#</>和其后的新行（或 RE 的末尾）之间的字符一样。这样就允许我们给一个复杂的 RE 分段和注释。不过这个基本规则有三种例外：

    <itemizedlist>
     <listitem>
      <para>
       空白字符或前置了<literal>\</>的<literal>#</>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       方括号表达式里的空白或者<literal>#</>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       在多字符符号里面不能出现空白和注释，例如<literal>(?:</>
      </para>
     </listitem>
    </itemizedlist>

    为了这个目的，空白是空格、制表符、新行和任何属于<replaceable>空白</>字符类的字符。
   </para>

   <para>
    最后，在 ARE 里，方括号表达式外面，序列<literal>(?#</><replaceable>ttt</><literal>)</>（其中<replaceable>ttt</>是任意不包含一个<literal>)</>)的文本）是一个注释， 它被完全忽略。同样，这样的东西是不允许出现在多字符符号的字符中间的，例如 <literal>(?:</>。这种注释更像是一种历史产物而不是一种有用的设施，并且它们的使用已经被废弃；请使用扩展语法来替代。   </para>

   <para>
    如果声明了一个初始的<literal>***=</>控制器，那么所有这些元语法扩展<emphasis>都不能</>使用，因为这样表示把用户输入当作一个文字串而不是 RE 对待。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
    <title>正则表达式匹配规则</title>

   <para>
    在 RE 可以在给定串中匹配多于一个子串的情况下， RE 匹配串中最靠前的那个子串。如果 RE 可以匹配在那个位置开始 的多个子串，要么是取最长的子串，要么是最短的，具体哪种， 取决于 RE 是<firstterm>贪婪</>的还是<firstterm>非贪婪</>的。
   </para>

   <para>
    一个 RE 是否贪婪取决于下面规则：
    <itemizedlist>
     <listitem>
      <para>
       大多数原子以及所有约束，都没有贪婪属性（因为它们毕竟无法匹配个数变化的文本）。
      </para>
     </listitem>
     <listitem>
      <para>
       在一个 RE 周围加上圆括号并不会改变其贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       带一个固定重复次数量词 （<literal>{</><replaceable>m</><literal>}</>或者<literal>{</><replaceable>m</><literal>}?</>） 的量化原子和原子自身具有同样的贪婪性（可能是没有）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带其他普通的量词（包括<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>中<replaceable>m</>等于<replaceable>n</>的情况）的量化原子是贪婪的（首选最长匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带非贪婪量词（包括<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>中<replaceable>m</>等于 <replaceable>n</>的情况）的量化原子是非贪婪的（首选最短匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个分支 &mdash; 也就是说，一个没有顶级<literal>|</>操作符的 RE &mdash; 和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       一个由<literal>|</>操作符连接起来的两个或者更多分支组成的 RE 总是贪婪的。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子， 而且也适用于包含量化原子的分支和整个 RE。这里的意思是， 匹配是按照分支或者整个 RE <emphasis>作为一个整体</>匹配最长或者最短的可能子串。 一旦整个匹配的长度确定，那么匹配任意特定子表达式的部分就基于该子表达式的贪婪属性进行判断，在 RE 里面靠前的子表达式的优先级高于靠后的子表达式。
   </para>

   <para>
    一个相应的例子：
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
    在第一个例子里，RE 作为整体是贪婪的，因为<literal>Y*</>是贪婪的。它可以匹配从<literal>Y</>开始的东西，并且它匹配从这个位置开始的最长的串， 也就是，<literal>Y123</>。输出是这里的圆括号包围的部分，或者说是<literal>123</>。在第二个例子里， RE 总体上是一个非贪婪的 RE，因为<literal>Y*?</>是非贪婪的。它可以匹配从<literal>Y</>开始的最短的子串，也就是说<literal>Y1</>。子表达式<literal>[0-9]{1,3}</>是贪婪的，但是它不能修改总体匹配长度的决定； 因此它被迫只匹配<literal>1</>。
   </para>

   <para>
    简而言之，如果一个 RE 同时包含贪婪和非贪婪的子表达式，那么总的匹配长度要么是尽可能长，要么是尽可能短，这取决于给整个 RE 赋予的属性。给子表达式赋予的属性只影响在这个匹配里，各个子表达式之间相互允许<quote>吃掉</>的多少。
   </para>

   <para>
    量词<literal>{1,1}</>和<literal>{1,1}?</>可以分别用于在一个子表达式或者整个 RE 上强制
    贪婪或者非贪婪。
    当你需要整个RE具有不同于从它的元素推导出的贪婪属性，这是非常有用的。
    作为一个例子，
    假设我们正在尝试分隔包含一些数字到它们之前和之后的数字和部分的字符串。
    我们可能会尝试这样做：
<screen>
SELECT regexp_matches('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    这不工作：第一个<literal>.*</>是贪婪的，因此它可以尽可能多的<quote>吃</>，
    剩下的<literal>\d+</>在最后可能的位置上匹配最后一个数字。
    我们可能会通过使它不贪婪尝试修复：    
<screen>
SELECT regexp_matches('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    这也不能工作，因为现在RE作为一个整体是非贪婪的，
    并且它尽快结束了整体匹配。
    我们可以得到我们想要通过迫使RE作为一个整体是贪婪的东西：
<screen>
SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    控制从组件贪婪中分离出RE整体贪婪允许处理可变长度的模式更加灵活。
   </para>

   <para>
    当决定什么是较长或较短匹配的时候，
    匹配长度是以字符衡量的，而不是排序元素。一个空串会被认为比什么都不匹配长。例如：<literal>bb*</>匹配<literal>abbbc</>的中间三个字符；<literal>(week|wee)(night|knights)</>匹配<literal>weeknights</>的所有十个字符； 而<literal>(.*).*</>匹配 <literal>abc</>的时候，圆括号包围的子表达式匹配所有三个字符；当<literal>(a*)*</>被拿来匹配<literal>bc</>时，整个 RE 和圆括号 子表达式都匹配一个空串。
   </para>

   <para>
    如果声明了大小写无关的匹配，那么效果就好像所有大小写区别在字母表中消失了。如果在多个情况中一个字母以一个普通字符的形式出现在方括号表达式外面，那么它实际上被转换成 一个包含大小写的方括号表达式，也就是说，x 变成 [xX]。 如果它出现在一个方括号表达式里面，那么它的所有大小写的同族都被加入 方括号表达式中，也就是说，<literal>x</>变成<literal>[xX]</>。当它出现在一个方括号表达式内时，它的所有大小写副本都被加入到方括号表达式中，例如， <literal>[x]</>会变成<literal>[xX]</>，而<literal>[^x]</>会变成<literal>[^xX]</>。
   </para>

   <para>
    如果指定了新行敏感的匹配，<literal>.</>和使用<literal>^</>的方括号表达式 将永远不会匹配新行字符（这样，匹配就绝对不会跨越新行，除非 RE 显式地安排了这样的情况）并且<literal>^</>和<literal>$</>除了分别匹配串开头和结尾之外，还将分别匹配新行后面和前面的空串。但是 ARE 逃逸<literal>\A</>和<literal>\Z</>仍然<emphasis>只</>匹配串的开头和结尾。
   </para>

   <para>
    如果指定了部分新行敏感的匹配，那么它影响<literal>.</>和方括号表达式， 这个时候和新行敏感的匹配一样，但是不影响<literal>^</>和<literal>$</>。
   </para>

   <para>
    如果指定了逆新行敏感匹配，那么它影响<literal>^</>和<literal>$</>，其作用和在新行敏感的匹配里一样，但是不影响<literal>.</>和方括号表达式。这个并不是很有用，只是为了满足对称性而提供的。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
    <title>限制和兼容性</title>

   <para>
    在这个实现里，对 RE 的长度没有特别的限制。但是，那些希望高移植性的程序应该避免使用长度超过 256 字节的 RE，因为 POSIX 兼容 的实现可以拒绝接受这样的 RE。
   </para>

   <para>
    ARE 实际上和 POSIX ERE 不兼容的唯一的特性是在方括号表达式里<literal>\</>并不失去它特殊的含义。所有其它 ARE 特性都使用在 POSIX ERE 里面是非法或者是未定义、未声明效果的语法；指示器的<literal>***</>就是在 POSIX 的 BRE 和 ERE 之外的语法。
   </para>

   <para>
    许多 ARE 扩展都是从 Perl 那里借来的（但是有些被做了修改来清理它们），以及一些 Perl 里没有出现的扩展。要注意的不兼容性包括<literal>\b</>、<literal>\B</>、对结尾的新行缺乏特别的处理、对那些被新行敏感匹配的东西附加的补齐方括号表达式、在 lookahead 约束里对圆括号和后引用的限制以及最长/最短 匹配（而不是第一匹配）的语义。
   </para>

   <para>
    <productname>PostgreSQL</> 7.4 之前的版本中识别的 ARE 和 ERE 语法存在两个非常明显的不兼容：

    <itemizedlist>
     <listitem>
      <para>
       在 ARE 中，后面跟着一个字母数字字符的<literal>\</>要么是一个逃逸要么是一个错误， 但是在以前的版本里，它只是写该字母数字字符的另外一种方法。这个应该不是什么问题， 因为在以前的版本里没有什么理由会让我们写这样的序列。
      </para>
     </listitem>
     <listitem>
      <para>
       在 ARE 里，<literal>\</>在<literal>[]</>里还是一个特殊字符， 因此在方括号表达式里的一个文本<literal>\</>必须被写成<literal>\\</>。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
    <title>基本正则表达式</title>

   <para>
    BRE 在几个方面和 ERE 不太一样。在 BRE 中，<literal>|</>、<literal>+</>和<literal>?</>都是普通字符并且没有与它们功能等价的东西。范围的定界符是<literal>\{</>和<literal>\}</>， 因为 <literal>{</>和<literal>}</>本身是普通字符。嵌套的子表达式的圆括号是<literal>\(</>和<literal>\)</>，因为<literal>(</>和<literal>)</>自身是普通字符。除非在 RE 开头或者是圆括号子表达式开头，<literal>^</>都是一个普通字符。 除非在 RE 结尾或者是圆括号子表达式的结尾，<literal>$</>是一个普通字符。如果<literal>*</>出现在 RE 开头或者是圆括号封装的子表达式开头 （前面可能有<literal>^</>），那么它是个普通字符。最后，可以用单数字的后引用，<literal>\&lt;</>和<literal>\&gt;</>分别是<literal>[[:&lt;:]]</>和<literal>[[:&gt;:]]</>的同义词；在 BRE 中没有其它可用的逃逸。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
   <title>数据类型格式化函数</title>

   <indexterm>
    <primary>formatting</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>格式化函数提供一套强大的工具用于把各种数据类型 （日期/时间、整数、浮点、数字） 转换成格式化的字符串以及反过来从格式化的字符串转换成 指定的数据类型。<xref linkend="functions-formatting-table">列出了这些函数。这些函数都遵循一个公共的调用习惯： 第一个参数是待格式化的值，而第二个是一个定义输出或输入格式的模板。
   </para>
   <para>
    一个单参数的<function>to_timestamp</function>函数也能使用。它接受一个<type>double precision</type>参数， 把它从 Unix 纪元（从 1970-01-01 00:00:00+00 开始的秒数）转换成 <type>timestamp with time zone</type>（<type>Integer</type> Unix 纪元被隐式地造型成<type>double precision</type>）。
   </para>

    <table id="functions-formatting-table">
     <title>格式化函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>把时间戳转成字符串</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把间隔转成字符串</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把整数转成字符串</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>把实数或双精度转成字符串</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把数字转成字符串</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>把字符串转成日期</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
        <entry>把字符串转成数字</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>把字符串转成时间戳</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_timestamp(<type>double precision</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>把 Unix 纪元转成时间戳</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    在一个<function>to_char</>输出模板串中，一些特定的模式可以被识别并且被替换成基于给定值的被恰当地格式化的数据。任何不属于模板模式的文本都简单地照字面拷贝。同样，在一个输入 模板串里（对其他函数），模板模式标识由输入数据串提供的值。
   </para>

  <para>
   <xref linkend="functions-formatting-datetime-table">展示了可以用于格式化日期和时间值的模版。
  </para>

    <table id="functions-formatting-datetime-table">
     <title>用于日期/时间格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
        <entry>一天中的小时 （01-12）</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>一天中的小时 （01-12）</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>一天中的小时 （00-23）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>分钟 （00-59）minute (00-59)</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
        <entry>秒（00-59）</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
        <entry>毫秒（000-999）</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
        <entry>微秒（000000-999999）</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
        <entry>午夜后的秒（0-86399）</entry>
       </row>
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>正午指示器（不带句号）</entry>
       </row>
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>正午指示器（带句号）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>带逗号的年（4 位或者更多位）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>年（4 位或者更多位）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>年的后三位</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
        <entry>年的后两位</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
        <entry>年的最后一位</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 周编号方式的年（4 位或更多位）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 3 位</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 2 位</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后一位</entry>
       </row>
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal>或者<literal>ad</literal></entry>
        <entry>纪元指示器（不带句号）</entry>
       </row>
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal>或者<literal>a.d.</literal></entry>
        <entry>纪元指示器（带句号）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>全大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
        <entry>全首字母大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
        <entry>全小写形式的月名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
        <entry>简写的大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>简写的首字母大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
        <entry>简写的小写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
        <entry>月编号（01-12）</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>全大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
        <entry>全首字母大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
        <entry>全小写形式的日名（空格补齐到 9 字符）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
        <entry>简写的大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>简写的首字母大写形式的日名（英语 3 字符，本地化长度可变） </entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
        <entry>简写的小写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>一年中的日（001-366）</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>ISO 8601 周编号方式的年中的日（001-371，年的第 1 日时第一个 ISO 周的周一）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
        <entry>月中的日（01-31）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>周中的日，周日（<literal>1</>）到周六（<literal>7</>）</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
        <entry>周中的 ISO 8601 日，周一（<literal>1</>）到周日（<literal>7</>）</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
        <entry>月中的周（1-5）（第一周从该月的第一天开始）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
        <entry>年中的周数（1-53）（第一周从该年的第一天开始）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
        <entry>ISO 8601 周编号方式的年中的周数（01 - 53；新的一年的第一个周四在第一周）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
        <entry>世纪（2 位数）（21 世纪开始于 2001-01-01）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
        <entry>儒略日（从午夜 UTC 的公元前 4714 年 11 月 24 日开始的整数日数）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
        <entry>季度（<function>to_date</>和<function>to_timestamp</>会忽略）</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
        <entry>大写形式的罗马计数法的月（I-XII；I 是 一月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
        <entry>小写形式的罗马计数法的月（i-xii；i 是 一月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>大写形式的时区名称</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
        <entry>小写形式的时区名称</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
        <entry>时区偏移量</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    修饰语可以被应用于模板模式来修改它们的行为。例如，<literal>FMMonth</literal>就是带着<literal>FM</literal>修饰语的<literal>Month</literal>模式。<xref linkend="functions-formatting-datetimemod-table">展示了可用于日期/时间格式化的修饰语模式。
   </para>

    <table id="functions-formatting-datetimemod-table">
     <title>用于日期/时间格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制前导零以及填充的空格）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写形式的序数后缀</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</></entry>
       </row>
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写形式的序数后缀</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</></entry>
       </row>
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>固定的格式化全局选项（见使用须知）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>翻译模式（基于<xref linkend="guc-lc-time">打印本地化的日和月名）</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>拼写模式（未实现）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    日期/时间格式化的使用须知：

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal>抑制前导的零或尾随的空白， 否则会把它们增加到输入从而把一个模式的输出变成固定宽度。在<productname>PostgreSQL</productname>中，<literal>FM</literal>只修改下一个声明，而在 Oracle 中，<literal>FM</literal>影响所有随后的声明，并且重复的<literal>FM</literal>修饰语将触发填充模式开和关。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TM</literal>不包括结尾空白。
       <function>to_timestamp</>和<function>to_date</>忽略<literal>TM</literal>修饰符。
      </para>
     </listitem>

     <listitem>
      <para>
       如果没有使用<literal>FX</literal>选项，<function>to_timestamp</function>和<function>to_date</function>会跳过输入字符串中的多个空白。例如，<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>是正确的，但<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal>会返回一个错误，因为<function>to_timestamp</function>只期望一个空白。<literal>FX</literal>必须被指定为模板中的第一个项。
      </para>
     </listitem>
     
     <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>的存在是为了
       处理无法被简单转换的输入格式。这些函数会从字面上解释输入，并做一点点错误检查。当
       它们产生有效输出时，该转换可能得到意料之外的结果。例如，这些函数的输入没有被限制
       在正常的范围内，因此<literal>to_date('20096040','YYYYMMDD')</literal>会返回
       <literal>2014-01-17</literal>而不是报错。而造型不会有这样的行为。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_char</function>模板里可以有普通文本，并且它们会被照字面输出。你可以把一个子串放到双引号里强迫它被解释成一个文本，即使它里面包含模式关键字也如此。例如，在 <literal>'"Hello Year "YYYY'</literal>中，<literal>YYYY</literal>将被年份数据代替，但是<literal>Year</literal>中单独的<literal>Y</literal>不会。在<function>to_date</>、<function>to_number</>和<function>to_timestamp</>中，双引号字符串会跳过包含在字符串中字符个数的字符，例如<literal>"XX"</>跳过两个输入字符。
      </para>
     </listitem>

     <listitem>
      <para>
       如果你想在输出里有双引号，那么你必须在它们前面放反斜线，例如 <literal>'\"YYYY Month\"'</literal>。<!-- "" font-lock sanity :-) -->
      </para>
     </listitem>

     <listitem>
      <para>
       如果年份格式声明少于四位（如<literal>YYY</>）并且提供的年份少于四位，年份将被调整为最接近于 2020 年，例如<literal>95</>会变成 1995。
      </para>
     </listitem>

     <listitem>
      <para>
       在处理长于 4 位的年份时，从字串向<type>timestamp</type>或者<type>date</type>的<literal>YYYY</literal>转换有一个限制。你必须在<literal>YYYY</literal>后面使用一些非数字字符或者模板， 否则年份总是被解释为 4 位数字。例如（对于 20000 年）：<literal>to_date('200001131', 'YYYYMMDD')</literal>将会被解释成一个 4 位数字的年份，而不是在年份后使用一个非数字分隔符，像<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>或<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       在从字符串向<type>timestamp</type>或<type>date</type>的转换中， 如果有<literal>YYY</literal>、<literal>YYYY</literal>或者<literal>Y,YYY</literal>域， 那么<literal>CC</literal>（世纪）域会被忽略。如果<literal>CC</literal>和<literal>YY</literal>或<literal>Y</literal>一起使用， 那么年份被计算时会认为年份位于指定的世纪中。如果该世纪被指定但是年份没有被指定，将假定用该世纪的第一年。
      </para>
     </listitem>

     <listitem>
      <para>
       一个 ISO 8601 周编号的日期（与一个格里高利日期相区别）可以用两种方法之一被指定为<function>to_timestamp</function>和<function>to_date</function>：
       <itemizedlist>
        <listitem>
         <para>
          年、周编号和工作日：例如<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>返回日期<literal>2006-10-19</literal>。如果你忽略工作日，它被假定为 1（周一）。
         </para>
        </listitem>
        <listitem>
         <para>
          年和一年中的日：例如<literal>to_date('2006-291', 'IYYY-IDDD')</literal>也返回<literal>2006-10-19</literal>。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       尝试使用一个混合了 ISO 8601 周编号和格里高利日期的域来输入一个日期是无意义的，并且将导致一个错误。在一个 ISO 周编号的年的环境下，一个<quote>月</>或<quote>月中的日</>的概念没有意义。在一个格里高利年的环境下，ISO 周没有意义。用户应当避免混合格里高利和 ISO 日期声明。
      </para>
      <caution>
       <para>
        虽然<function>to_date</function>将会拒绝混合使用格里高利和 ISO 周编号日期的域，
        <function>to_char</function>却不会，因为<literal>YYYY-MM-DD (IYYY-IDDD)</>
        这种输出格式也会有用。但是避免写类似<literal>IYYY-MM-DD</>的东西，那会得到在
        起始年附近令人惊讶的结果（详见<xref linkend="functions-datetime-extract">）。
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
       在从字符串到<type>timestamp</type>的转换中，毫秒（<literal>MS</literal>）和微秒（<literal>US</literal>）值都被用作小数点后的秒位。例如<literal>to_timestamp('12:3', 'SS:MS')</literal>不是 3 毫秒, 而是 300，因为该转换把它看做 12 + 0.3 秒。这意味着对于格式<literal>SS:MS</literal>而言，输入值<literal>12:3</literal>、<literal>12:30</literal>和<literal>12:300</literal>指定了相同数目的毫秒。要得到三毫秒，你必须使用 <literal>12:003</literal>，转换会把它看做 12 + 0.003 = 12.003 秒。
      </para>

      <para>
       下面是一个更复杂的例子∶<literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>是 15 小时、12 分钟和 2 秒 + 20 毫秒 + 1230微秒 = 2.021230 秒。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(..., 'ID')</function>的一周中日的编号匹配<function>extract(isodow from ...)</function>函数，但是<function>to_char(..., 'D')</function>不匹配<function>extract(dow from ...)</function>的日编号。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(interval)</function>格式化<literal>HH</>和<literal>HH12</>为显示在一个 12 小时的时钟上，即零小时和 36 小时输出为<literal>12</>，而<literal>HH24</>会输出完整的小时值，对于间隔它可以超过 23.
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
   <xref linkend="functions-formatting-numeric-table">展示了可以用于格式化数字值的模版模式。
  </para>

    <table id="functions-formatting-numeric-table">
     <title>用于数字格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
        <entry>带有指定位数的值</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
        <entry>带前导零的值</entry>
       </row>
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>小数点</entry>
       </row>
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>分组（千）分隔符</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
        <entry>尖括号内的负值</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
        <entry>带符号的数字（使用区域）</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
        <entry>货币符号（使用区域）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>小数点（使用区域）</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
        <entry>分组分隔符（使用区域）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>在指定位置的负号（如果数字 &lt; 0）</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
        <entry>在指定位置的正号（如果数字 &gt; 0）</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
        <entry>在指定位置的正/负号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
        <entry>罗马数字（输入在 1 和 3999 之间）</entry>
       </row>
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>序数后缀</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
        <entry>移动指定位数（参阅注解）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>科学记数的指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    数字格式化的用法须知：

    <itemizedlist>
     <listitem>
      <para>
       使用<literal>SG</literal>、<literal>PL</literal>或<literal>MI</literal>格式化的符号并不挂在数字上面； 例如，<literal>to_char(-12, 'MI9999')</literal>生成<literal>'-&nbsp;&nbsp;12'</literal>，而<literal>to_char(-12, 'S9999')</literal>生成 <literal>'&nbsp;&nbsp;-12'</literal>。Oracle 里的实现不允许在<literal>9</literal>前面使用<literal>MI</literal>，而是要求<literal>9</literal>在<literal>MI</literal>前面。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>9</literal>导致一个值，这个值的位数好像有那么多个<literal>9</literal>在那里。如果一个数字不可用，它将输出一个空格。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal>不会转换小于零的数值，也不会转换小数。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>、<literal>SG</literal>和<literal>TH</literal>是<productname>PostgreSQL</productname>扩展。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>V</literal>方便地把输入值乘以<literal>10^<replaceable>n</replaceable></literal>，这里<replaceable>n</replaceable>是跟在<literal>V</literal>后面的数字。<function>to_char</function>不支持把<literal>V</literal>与一个小数点组合在一起使用 （也就是说，<literal>99.9V99</literal>是不允许的）。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>EEEE</literal>（科学记数法）不能和任何其他格式化模式或修饰语（数字和小数点模式除外）组合在一起使用，并且必须位于格式化字符串的最后（例如<literal>9.99EEEE</literal>是一个合法的模式）。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    某些修饰语可以被应用到任何模板来改变其行为。例如，<literal>FM9999</literal>是带有<literal>FM</literal>修饰语的<literal>9999</literal>模式。<xref linkend="functions-formatting-numericmod-table">中展示了用于数字格式化模式修饰语。
   </para>

    <table id="functions-formatting-numericmod-table">
     <title>用于数字格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制前导零和空白）</entry>
        <entry><literal>FM9999</literal></entry>
       </row>
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写序数后缀</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写序数后缀</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   <xref linkend="functions-formatting-examples-table">展示了一些使用<function>to_char</function>函数的例子。
  </para>

    <table id="functions-formatting-examples-table">
     <title><function>to_char</function>例子</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>表达式</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
   <title>时间/日期函数和操作符</title>

  <para>
   <xref linkend="functions-datetime-table">展示了可用于处理日期/时间值的函数，其细节在随后的小节中描述。<xref linkend="operators-datetime-table">演示了基本算术操作符 （<literal>+</literal>、<literal>*</literal>等）的行为。 而与格式化相关的函数，可以参考<xref linkend="functions-formatting">。你应该很熟悉<xref linkend="datatype-datetime">中的日期/时间数据类型的背景知识。
  </para>

  <para>
   所有下文描述的接受<type>time</type>或<type>timestamp</type>输入的函数和操作符实际上都有两种变体： 一种接收<type>time with time zone</type>或<type>timestamp with time zone</type>， 另外一种接受<type>time without time zone</type>或者 <type>timestamp without time zone</type>。为了简化，这些变种没有被独立地展示。此外，<literal>+</>和<literal>*</>操作符都是可交换的操作符对（例如，date + integer 和 integer + date）；我们只显示其中一个。
  </para>

    <table id="operators-datetime-table">
     <title>日期/时间操作符</title>

     <tgroup cols="3">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
        <entry><literal>integer '3'</literal> (days)</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
     <title>日期/时间函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>减去参数，生成一个使用年、月（而不是只用日）的<quote>符号化</>的结果</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 年 9 月 27 日</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <entry>从<function>current_date</function>（在午夜）减去</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>当前日期和时间（在语句执行期间变化）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>当前日期；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <entry>当前时间（一天中的时间）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>当前日期和时间（当前事务开始时）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
        <entry>获得子域（等价于<function>extract</function>）；见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>获得子域（等价于<function>extract</function>）；见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>截断到指定精度；另见<xref linkend="functions-datetime-trunc">
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>
       
       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <entry>截断到指定精度；另见<xref linkend="functions-datetime-trunc">
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
        <entry>获得子域；见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>获得子域；见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>测试有限日期（不是+/-无限）</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>测试有限时间戳（不是+/-无限）</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>测试有限间隔</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>调整间隔这样30天时间周期可以表示为月</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>调整间隔这样24小时时间周期可以表示为日</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>使用<function>justify_days</>和<function>justify_hours</>调整间隔，使用额外的符号调整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>当前时间（一天中的时间）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>当前日期和时间（当前事务的开始）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
       
       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
         从年、月、日域创建日期
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
         从年、月、周、日、时、分、秒域创建 interval
        </entry>
        <entry><literal>make_interval(days => 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
         从时、分、秒域创建时间
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
         从年、月、日、时、分、秒域创建时间戳
        </entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
         从年、月、日、时、分、秒域创建带时区的时间戳。如果没有指定<parameter>timezone</parameter>，
         则使用当前时区。
        </entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>当前日期和时间（当前事务的开始）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>当前日期和时间（当前事务的开始）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>当前日期和时间（像<function>clock_timestamp</>，但是作为一个<type>text</>字符串）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>当前日期和时间（当前事务的开始）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    除了这些函数以外，还支持 SQL 操作符<literal>OVERLAPS</>：
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。端点可以用一对日期、时间或者时间戳来指定；或者是用一个后面跟着一个间隔的日期、时间或时间戳来指定。当一对值被提供时，起点或终点都可以被写在前面，<literal>OVERLAPS</>会自动地把较早的值作为起点。每一个时间段被认为是表示半开的间隔<replaceable>start</> <literal>&lt;=</> <replaceable>time</> <literal>&lt;</> <replaceable>end</>，除非<replaceable>start</>和<replaceable>end</>相等，这种情况下它表示单个时间实例。例如这表示两个只有一个共同端点的时间段不重叠。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
   当把一个<type>interval</type>值添加到<type>timestamp with time zone</type>上（或从中减去）时， days 部分会按照指定的天数增加或减少<type>timestamp with time zone</type>的日期。 对于横跨夏令时的变化（当会话的时区被设置为可识别DST的时区时），这意味着<literal>interval '1 day'</literal>并 不一定等于<literal>interval '24 hours'</literal>。例如，当会话的时区设置为<literal>CST7CDT</literal>时，<literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>的结果是<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>，而将<literal>interval '24 hours'</literal>增加到相同的初始<type>timestamp with time zone</type>的结果 则是<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>， 因为<literal>CST7CDT</literal>时区在<literal>2005-04-03 02:00</literal>有一个夏令时变更。
  </para>

  <para>
   注意<function>age</>返回的<literal>月数</>域可能有歧义，因为不同的月份有不同的天数。 <productname>PostgreSQL</>的方法是当计算部分月数时，采用两个日期中较早的月。例如：<literal>age('2004-06-01', '2004-04-30')</>使用4月份得到<literal>1 mon 1 day</>，而用5月分时会得到<literal>1 mon 2 days</>，因为5月有31天，而4月只有30天。
  </para>
  
  <para>
   日期和时间戳的减法也可能会很复杂。执行减法的一种概念上很简单的方法是，使用
   <literal>EXTRACT(EPOCH FROM ...)</>把每个值都转换成秒数，然后执行减法，
   这样会得到两个值之间的<emphasis>秒</>数。这种方法将会适应每个月中天数、
   时区改变和夏令时调整。使用<quote><literal>-</></quote>操作符的日期或时间
   戳减法会返回值之间的天数（24小时）以及时/分/秒，也会做同样的调整。
   <function>age</>函数会返回年、月、日以及时/分/秒，执行按域的减法，然后对
   负值域进行调整。下面的查询展示了这些方法的不同。例子中的结果由
   <literal>timezone = 'US/Eastern'</>产生，这使得两个使用的日期之间存在着夏令
   时的变化：
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
    <function>extract</function>函数从日期/时间值中抽取子域，例如年或者小时等。<replaceable>source</replaceable>必须是一个类型 <type>timestamp</type>、<type>time</type>或<type>interval</type>的值表达式（类型为<type>date</type>的表达式将被造型为 <type>timestamp</type>，并且因此也可以被同样使用）。<replaceable>field</replaceable>是一个标识符或者字符串，它指定从源值中抽取的域。<function>extract</function>函数返回类型为<type>double precision</type>的值。 下列值是有效的域名字∶

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        世纪
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        第一个世纪从 0001-01-01 00:00:00 AD 开始， 尽管那时候人们还不知道这是第一个世纪。这个定义适用于所有使用格里高利历法的国家。其中没有 0 世纪，我们直接从公元前 1 世纪到公元 1 世纪。
        
        如果你认为这个不合理，那么请把抱怨发给：罗马圣彼得教堂，梵蒂冈，教皇收。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，是（月份）里的日域（1-31）；对于<type>interval</type>值，是日数
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        年份域除以10
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        一周中的日，从周日（<literal>0</>）到周六（<literal>6</>）
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        请注意，<function>extract</function>的一周中的日和<function>to_char(..., 'D')</function>函数不同。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        一年的第几天（1 -365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        对于<type>timestamp with time zone</type>值， 是自 1970-01-01 00:00:00 UTC 以来的秒数（结果可能是负数）； 对于<type>date</type> and <type>timestamp</type>值，是自本地时间 1970-01-01 00:00:00 以来的描述；对于<type>interval</type>值，它是时间间隔的总秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>结果：</lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>结果：</lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        下面是把纪元值转换回时间戳的方法：
       </para>
<screen>
SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';
</screen>
       <para>
        （<function>to_timestamp</>函数封装了上述转换）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        小时域（0 - 23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
        一周中的日，从周一（<literal>1</>）到周日（<literal>7</>）
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
        除了周日，这和<literal>dow</>相同。这符合<acronym>ISO</> 8601 中一周中的日的编号。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
        日期所落在的<acronym>ISO</acronym> 8601 周编号的年（不适用于间隔）
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>结果：</lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>结果：</lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
        每一个<acronym>ISO</acronym> 8601 周编号的年都开始于包含1月4日的那一周的周一，在早的1月或迟的12月中<acronym>ISO</acronym>年可能和格里高利年不同。更多信息见<literal>week</literal>域。
       </para>
       <para>
        这个域不能用于 PostgreSQL 8.3之前的版本。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1,000,000。请注意它包括全部的秒
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        千年
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        19xx的年份在第二个千年里。第三个千年从 2001 年 1 月 1 日开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1000。请注意它包括完整的秒。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        分钟域（0 - 59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，它是一年里的月份数（1 - 12）； 对于<type>interval</type>值，它是月的数目，然后对 12 取模（0 - 11）
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        该天所在的该年的季度（1 - 4）
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分（0 - 59<footnote><simpara>如果操作系统实现了闰秒，则为60</simpara></footnote>）
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        与 UTC 的时区偏移，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区（从技术上来看，<productname>PostgreSQL</productname>使用<acronym>UT1</>，因为闰秒没有被处理）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        时区偏移的小时部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        时区偏移的分钟部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        该天在所在的<acronym>ISO</acronym> 8601 周编号的年份里是第几周。根据定义， 一年的第一周包含该年的 1月 4 日并且 ISO 周从星期一开始。换句话说，一年的第一个星期四在第一周。
       </para>
       <para>
        在 ISO 周编号系统中，早的 1 月的日期可能位于前一年的第五十二或者第五十三周，而迟的 12 月的日期可能位于下一年的第一周。例如， <literal>2005-01-01</>位于 2004 年的第五十三周，并且<literal>2006-01-01</>位于 2005 年的第五十二周，而<literal>2012-12-31</>位于 2013 年的第一周。我们推荐把<literal>isoyear</>域和<literal>week</>一起使用来得到一致的结果。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        年份域。要记住这里没有<literal>0 AD</>，所以从<literal>AD</>年里抽取<literal>BC</>年应该小心处理。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    <function>extract</function>函数主要的用途是做计算性处理。对于用于显示的日期/时间值格式化，参阅<xref linkend="functions-formatting">。
   </para>

   <para>
    在传统的<productname>Ingres</productname>上建模的<function>date_part</function>函数等价于<acronym>SQL</acronym>标准函数<function>extract</function>：
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    请注意这里的<replaceable>field</replaceable>参数必须是一个串值，而不是一个名字。有效的<function>date_part</function>域名 和<function>extract</function>相同。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>结果：</lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
    <function>date_trunc</function>函数在概念上和用于数字的<function>trunc</function>函数类似。
   </para>

   <para>
<synopsis>
date_trunc('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    <replaceable>source</replaceable>是类型<type>timestamp</type>或<type>interval</>的值表达式（类型<type>date</type>和 <type>time</type>的值都分别被自动转换成<type>timestamp</type>或者<type>interval</>）。<replaceable>field</replaceable>选择对输入值选用什么样的精度进行截断。返回的值是<type>timestamp</type>类型或者所有小于选定的 精度的域都设置为零（或者一，对于日期和月份）的<type>interval</>。
   </para>

   <para>
    <replaceable>field</replaceable>的有效值是∶
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
    例子：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
    <literal>AT TIME ZONE</literal>结构允许把时间戳转换成不同的时区。<xref linkend="functions-datetime-zoneconvert-table">展示了其变体。
   </para>

    <table id="functions-datetime-zoneconvert-table">
     <title><literal>AT TIME ZONE</literal> Variants</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>表达式</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>把给定的<emphasis>不带时区</>的时间戳当作位于指定时区的时间对待</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
        <entry>把给定的<emphasis>带时区</>的时间戳转换到新的时区，不带时区指定</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <entry>把给定的<emphasis>带时区</>的时间转换到新时区</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    在这些表达式里，我们需要的时区<replaceable>zone</>可以指定为文本串（例如，<literal>'PST'</literal>）或者一个间隔 （例如，<literal>INTERVAL '-08:00'</literal>）。 在文本情况下，可用的时区名字可以用<xref linkend="datatype-timezones">中描述的任何方式指定。
   </para>

   <para>
    例子（假设本地时区是<literal>PST8PDT</>）：
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen>
    第一个例子接受一个无时区的时间戳然后把它解释成 MST 时间（UTC-7），然后这个时间转换为 PST（UTC-8）来显示。 第二个例子接受一个指定为 EST（UTC-5）的时间戳，然后把它 转换成 MST（UTC-7）的当地时间。
   </para>

   <para>
    函数<literal><function>timezone</function>(<replaceable>zone</>, <replaceable>timestamp</>)</literal>等效于 SQL 兼容的结构<literal><replaceable>timestamp</> AT TIME ZONE <replaceable>zone</></literal>。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>当前日期/时间</title>

   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>

   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>提供了许多返回当前日期和时间的函数。这些 SQL 标准的函数全部都按照当前事务的开始时刻返回值：
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
     <function>CURRENT_TIME</function>和<function>CURRENT_TIMESTAMP</function>传递带有时区的值；<function>LOCALTIME</function>和<function>LOCALTIMESTAMP</function>传递的值不带时区。
    </para>

    <para>
     <function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>和 <function>LOCALTIMESTAMP</function>可以有选择地接受一个精度参数， 该精度导致结果的秒域被园整为指定小数位。如果没有精度参数，结果将被给予所能得到的全部精度。
    </para>

   <para>
    一些例子：
<screen>
SELECT CURRENT_TIME;
<lineannotation>结果：</lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>结果：</lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>结果：</lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>结果：</lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>结果：</lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
    因为这些函数全部都按照当前事务的开始时刻返回结果，所以它们的值在事务运行的整个期间内都不改变。 我们认为这是一个特性：目的是为了允许一个事务在<quote>当前</quote>时间上有一致的概念， 这样在同一个事务里的多个修改可以保持同样的时间戳。
   </para>

   <note>
    <para>
     许多其它数据库系统可能会更频繁地推进这些值。
    </para>
   </note>

   <para>
    <productname>PostgreSQL</productname>同样也提供了返回当前语句开始时间的函数， 它们会返回函数被调用时的真实当前时间。这些非 SQL 标准的函数列表如下：
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
    <function>transaction_timestamp()</>等价于<function>CURRENT_TIMESTAMP</function>，但是其命名清楚地反映了它的返回值。<function>statement_timestamp()</>返回当前语句的开始时刻（更准确的说是收到 客户端最后一条命令的时间）。<function>statement_timestamp()</>和<function>transaction_timestamp()</>在一个事务的第一条命令期间返回值相同，但是在随后的命令中却不一定相同。 <function>clock_timestamp()</>返回真正的当前时间，因此它的值甚至在同一条 SQL 命令中都会变化。<function>timeofday()</>是一个有历史原因的<productname>PostgreSQL</productname>函数。和<function>clock_timestamp()</>相似，<function>timeofday()</>也返回真实的当前时间，但是它的结果是一个格式化的<type>text</>串，而不是<type>timestamp with time zone</>值。<function>now()</>是<productname>PostgreSQL</productname>的一个传统，等效于<function>transaction_timestamp()</function>。
   </para>

   <para>
    所有日期/时间类型还接受特殊的文字值<literal>now</literal>，用于指定当前的日期和时间（重申，被解释为当前事务的开始时刻）。 因此，下面三个都返回相同的结果：
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- 对于和 DEFAULT 一起使用是不正确的
</programlisting>
   </para>

    <tip>
     <para>
      在创建表期间指定一个<literal>DEFAULT</>子句时，你不会希望使用第三种形式。系统将在分析这个常量的时候把<literal>now</literal>转换为一个<type>timestamp</type>， 这样需要默认值时就会得到创建表的时间！而前两种形式要到实际使用缺省值的时候才被计算， 因为它们是函数调用。因此它们可以给出每次插入行的时刻。
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
   <title>延时执行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
   <indexterm>
    <primary>delay</primary>
   </indexterm>

   <para>
    下面的这些函数可以用于让服务器进程延时执行：
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</>)
pg_sleep_until(<type>timestamp with time zone</>)
</synopsis>

    <function>pg_sleep</function>让当前的会话进程休眠<replaceable>seconds</replaceable>
    秒以后再执行。<replaceable>seconds</replaceable>是一个<type>double precision</>
    类型的值，所以可以指定带小数的秒数。<function>pg_sleep_for</function>是针对用
    <type>interval</>指定的较长休眠时间的函数。<function>pg_sleep_until</function>
    则可以用来休眠到一个指定的时刻唤醒。例如：

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
      有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用值。休眠延迟将至少持续指
      定的时长， 也有可能由于服务器负荷而比指定的时间长。特别地，
      <function>pg_sleep_until</function>并不保证能刚好在指定的时刻被唤醒，但它不会
      在比指定时刻早的时候醒来。
     </para>
   </note>

   <warning>
     <para>
      请确保在调用<function>pg_sleep</function>或者其变体时，你的会话没有持有不必要
      的锁。否则其它会话可能必须等待你的休眠会话，因而减慢整个系统速度。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
  <title>枚举支持函数</title>

  <para>
   对于枚举类型(在<xref linkend="datatype-enum">中描述）， 有一些函数允许更清洁的编码，而不需要为一个枚举类型硬写特定的值。它们被列在<xref linkend="functions-enum-table">中。本例假定一个枚举类型被创建为：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
    <title>枚举支持函数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>例子结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
       <entry>返回输入枚举类型的第一个值</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
       <entry>返回输入枚举类型的最后一个值</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
       <entry>将输入枚举类型的所有值作为一个有序的数组返回</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
        以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    请注意，除了双参数形式的<function>enum_range</>外， 这些函数忽略传递给它们的具体值，它们只关心声明的数据类型。 空值或类型的一个特定值可以通过，并得到相同的结果。这些函数更多地被用于一个表列或函数参数，而不是一个硬写的类型名，如例子中所建议。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
  <title>几何函数和操作符</title>

   <para>
    几何类型<type>point</type>、<type>box</type>、
    <type>lseg</type>、<type>line</type>、<type>path</type>、
    <type>polygon</type>和<type>circle</type>有一大堆本地支持函数和操作符，如<xref linkend="functions-geometry-op-table">、<xref linkend="functions-geometry-func-table">和<xref linkend="functions-geometry-conv-table">中所示。
   </para>

   <caution>
    <para>
     请注意<quote>same as</>操作符（<literal>~=</>），表示<type>point</type>、<type>box</type>、<type>polygon</type>和<type>circle</type>类型的一般相等概念。这些类型中的某些还有一个<literal>=</>操作符，但是<literal>=</>只比较相同的<emphasis>面积</>。其它的标量比较操作符 （<literal>&lt;=</>等等）也是为这些类型比较面积。
    </para>
   </caution>

   <table id="functions-geometry-op-table">
     <title>几何操作符</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>平移</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>平移</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
        <entry>缩放/旋转</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
        <entry>缩放/旋转</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>相交的点或方框</entry>
        <entry><literal>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>路径或多边形中的点数</entry>
        <entry><literal># '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
        <entry>长度或周长</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
        <entry>第二个操作数上最接近第一个操作数的点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry>距离</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>是否重叠？（只要有一个公共点这就为真）</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>是否严格地在左侧？</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>是否严格地在右侧？</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>没有延展到右边？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>没有延展到左边？</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
        <entry>严格在下？</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
        <entry>严格在上？</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
        <entry>没有延展到上面？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
        <entry>没有延展到下面？</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
        <entry>在下面（允许相切）？</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
        <entry>在上面（允许相切）？</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
        <entry>相交？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>水平？</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>水平对齐？</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>垂直？</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>垂直对齐？</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
        <entry>相互垂直？</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
        <entry>平行？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含？</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>包含在内或在上？</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
        <entry>相同？</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>
     在<productname>PostgreSQL</productname>之前，包含操作符<literal>@&gt;</>和<literal>&lt;@</>被分别称为<literal>~</>和<literal>@</>。 这些名字仍然可以使用，但是已被废除并且最终将被移除。
    </para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
     <title>几何函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>面积</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>圆的直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>方框的垂直尺寸</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>一个封闭路径？</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>一个开放路径？</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>长度</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</>)</function></literal></entry>
        <entry><type>int</type></entry>
        <entry>点数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</>)</function></literal></entry>
        <entry><type>int</type></entry>
        <entry>点数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
        <entry>将路径转换成封闭的</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<![IGNORE[
<!-- Not defined by this name. Implements the intersection operator '#' -->
       <row>
        <entry><literal><function>point(<type>lseg</>, <type>lseg</>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>相交</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
]]>
       <row>
        <entry><literal><function>popen(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
        <entry>将路径转换成开放</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>圆的半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>方框的水平尺寸</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
     <title>几何类型转换函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
        <entry>圆到方框</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>点到空方框</entry>
        <entry><literal>box(point '(0,0)')</literal></entry>
       </row> 
       
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>点到方框</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>多边形到方框</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       
       <row>
        <entry><literal><function>bound_box(<type>box</type>, <type>box</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>盒到边界框</entry>
        <entry><literal>bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')</literal></entry>
       </row> 
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
        <entry>方框到圆</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <entry>中心和半径到圆</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <entry>多边形到圆</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
        <entry>点到线</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
        <entry>方框对角线到线段</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
        <entry>点到线段</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
        <entry>多边形到路径</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
        <entry>构造点</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>方框的中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>圆的中心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>线段的中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>多边形的中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
        <entry>方框到4点多边形</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>圆到12点多边形</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>点到<replaceable class="parameter">npts</replaceable>点多边形</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>路径到多边形</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
     我们可以把一个<type>point</>的两个组成数字当作具有索引 0 和 1 的数组访问。例如，如果<literal>t.p</>是一个<type>point</>列，那么<literal>SELECT p[0] FROM t</>检索 X 座标而 <literal>UPDATE t SET p[1] = ...</>改变 Y 座标。同样，<type>box</>或者<type>lseg</>类型的值可以当作两个<type>point</>值的数组值看待。
    </para>

    <para>
     函数<function>area</function>可以用于类型<type>box</type>、<type>circle</type>和<type>path</type>。<function>area</function>函数操作<type>path</type>数据类型的时候， 只有在<type>path</type>的点没有交叉的情况下才可用。例如，<type>path</type> <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>是不行的， 而下面的视觉上相同的 <type>path</type> <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>就可以。 如果交叉和不交叉的<type>path</type>概念让你疑惑，那么把上面两个<type>path</type>都画在一张图纸上，你就明白了。
    </para>

  </sect1>


 <sect1 id="functions-net">
  <title>网络地址函数和操作符</title>

  <para>
   <xref linkend="cidr-inet-operators-table">展示了可以用于<type>cidr</type>和
   <type>inet</type>类型的操作符。 操作符<literal>&lt;&lt;</literal>、<literal>&lt;&lt;=</literal>、
   <literal>&gt;&gt;</literal>、<literal>&gt;&gt;=</literal>和
   <literal>&amp;&amp;</literal>测试用于子网包含。它们只考虑两个地址的网
   络部分（忽略任何主机部分），然后判断其中一个网络部分是等于另外一个或者是
   另外一个的子网。
  </para>

    <table id="cidr-inet-operators-table">
     <title><type>cidr</type>和<type>inet</type>操作符</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>小于</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>小于等于</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>等于</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>大于等于</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>大于</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>不等于</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>被包含在内</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
        <entry>被包含在内或等于</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>包含</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
        <entry>包含或等于</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>包含或者被包含contains or is contained by</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>按位 NOT</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
        <entry>按位 AND</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
        <entry>按位 OR</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>加</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>减</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>减</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   <xref linkend="cidr-inet-functions-table">展示了所有可以用于<type>cidr</type>和<type>inet</type>类型的函数。函数<function>abbrev</function>、<function>host</function>和<function>text</function>主要是为了提供可选的显示格式用的。
  </para>

    <table id="cidr-inet-functions-table">
     <title><type>cidr</type>和<type>inet</type>函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>缩写显示格式文本</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>缩写显示格式文本</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>网络广播地址</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>抽取地址族；<literal>4</literal>为 IPv4，
         <literal>6</literal>为 IPv6</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>抽取 IP 地址为文本</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>为网络构造主机掩码</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>抽取网络掩码长度</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>为网络构造网络掩码</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
        <entry>抽取地址的网络部分</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>为<type>inet</type>值设置网络掩码长度</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
        <entry>为<type>cidr</type>值设置网络掩码长度</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>抽取 IP 地址和网络掩码长度为文本</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>       
       <row>
        <entry>
         <indexterm>
          <primary>inet_same_family</primary>
         </indexterm>
         <literal><function>inet_same_family(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>地址来自同一个网段吗？</entry>
        <entry><literal>inet_same_family('192.168.1.5/24', '::1')</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_merge</primary>
         </indexterm>
         <literal><function>inet_merge(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
        <entry>最小的网络包括给定的两个网络</entry>
        <entry><literal>inet_merge('192.168.1.5/24', '192.168.2.5/24')</literal></entry>
        <entry><literal>192.168.0.0/22</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   任何<type>cidr</>值都能够被隐式或显式地转换为<type>inet</>值， 因此上述能够操作<type>inet</>值的函数也同样能够操作<type>cidr</>值（也有独立的用于<type>inet</>和<type>cidr</>的函数，因为它的行为应当和这两种情况不同）。<type>inet</>值也可以转换为<type>cidr</>值。完成时，该网络掩码右侧的任何位都将无声地转换为零以获得一个有效的<type>cidr</>值。另外，你还可以使用常规的造型语法将一个文本字符串转换为<type>inet</>或<type>cidr</>值：例如，<literal>inet(<replaceable>expression</>)</literal>或<literal><replaceable>colname</>::cidr</literal>。
  </para>

  <para>
   <xref linkend="macaddr-functions-table">展示了可以用于<type>macaddr</type>类型的函数。 函数<literal><function>trunc(<type>macaddr</type>)</function></literal>返回一个 MAC 地址，该地址的最后三个字节设置为零。这样可以把剩下的前缀与一个制造商相关联。
  </para>

    <table id="macaddr-functions-table">
     <title><type>macaddr</type>函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
        <entry>设置最后3个字节为零</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <type>macaddr</type>类型还支持标准关系操作符 （<literal>&gt;</literal>、<literal>&lt;=</literal>等） 用于编辑次序，并且按位算术操作符（<literal>~</literal>、<literal>&amp;</literal>和<literal>|</literal>）用于 NOT、AND 和 OR。
   </para>

  </sect1>


 <sect1 id="functions-textsearch">
  <title>文本搜索函数和操作符</title>

   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

  <para>
   <xref linkend="textsearch-operators-table">、
   <xref linkend="textsearch-functions-table">和
   <xref linkend="textsearch-functions-debug-table">总结了为全文搜索提供的函数和操作符。<productname>PostgreSQL</productname>的文本搜索功能的详细解释可参考<xref linkend="textsearch">。
  </para>

    <table id="textsearch-operators-table">
     <title>文本搜索操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry><type>tsvector</>匹配<type>tsquery</>吗？</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
        <entry><literal>@@</>的已废弃同义词</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry>连接<type>tsvector</></entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>将<type>tsquery</>用 AND 连接起来</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry>将<type>tsquery</>用 OR 连接起来</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
        <entry>对一个<type>tsquery</>取反</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry><type>tsquery</>包含另一个？</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry><type>tsquery</>被包含？</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
      <type>tsquery</>的包含操作符只考虑两个查询中的词位，而忽略组合操作符。
     </para>
    </note>

    <para>
     除了显示在表中的操作符，还定义了<type>tsvector</>和<type>tsquery</>类型的普通B-tree比较操作符（<literal>=</>、<literal>&lt;</>等）。它们对于文本搜索不是很有用，但是允许使用。例如，建在这些类型列上的唯一索引。
    </para>

    <table id="textsearch-functions-table">
     <title>文本搜索函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
        <entry>获得默认文本搜索配置</entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <entry><type>tsvector</>中的词位数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <entry><type>tsquery</>中词位外加操作符的数目</entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>产生<type>tsquery</>但忽略标点符号</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>获得一个<type>tsquery</>的可索引部分</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<type>tsvector</>, <type>"char"</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>为<type>tsvector</>的每一个元素分配权重</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>从<type>tsvector</>中移除位置和权重</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>规范化词并转换成<type>tsquery</></entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">document</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>缩减文档文本成<type>tsvector</></entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">options</replaceable> <type>text</> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>显示一个查询匹配</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <entry>为查询排名文档</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <entry>使用覆盖密度为查询排名文档</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">target</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">substitute</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>在查询内用 substitute 替换 target </entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">select</replaceable> <type>text</>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
        <entry>使用来自一个<command>SELECT</>的目标和替换者进行替换</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <entry>用于自动<type>tsvector</>列更新的触发器函数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <entry>用于自动<type>tsvector</>列更新的触发器函数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>
    所有接受一个可选的<type>regconfig</>参数的文本搜索函数在该参数被忽略时，使用由<xref linkend="guc-default-text-search-config">指定的配置。
   </para>
  </note>

  <para>
   <xref linkend="textsearch-functions-debug-table">中的函数被单独列出，因为它们通常不被用于日常的文本搜索操作。 它们有助于开发和调试新的文本搜索配置。
  </para>

    <table id="textsearch-functions-debug-table">
     <title>文本搜索调试函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>, OUT <replaceable class="PARAMETER">token</> <type>text</>, OUT <replaceable class="PARAMETER">dictionaries</> <type>regdictionary[]</>, OUT <replaceable class="PARAMETER">dictionary</> <type>regdictionary</>, OUT <replaceable class="PARAMETER">lexemes</> <type>text[]</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>测试一个配置</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="PARAMETER">dict</replaceable> <type>regdictionary</>, <replaceable class="PARAMETER">token</replaceable> <type>text</>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
        <entry>测试一个字典</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="PARAMETER">parser_name</replaceable> <type>text</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>测试一个解析器</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="PARAMETER">parser_oid</replaceable> <type>oid</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <entry>测试一个解析器</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="PARAMETER">parser_name</> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>获得解析器定义的记号类型</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="PARAMETER">parser_oid</> <type>oid</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <entry>获得解析器定义的记号类型</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="PARAMETER">sqlquery</replaceable> <type>text</>, <optional> <replaceable class="PARAMETER">weights</replaceable> <type>text</>, </optional> OUT <replaceable class="PARAMETER">word</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">ndoc</replaceable> <type>integer</>, OUT <replaceable class="PARAMETER">nentry</replaceable> <type>integer</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>获得一个<type>tsvector</>列的统计</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">
  <title>XML 函数</title>

  <para>
   本节中描述的函数以及类函数的表达式都在类型<type>xml</type>的值上操作。类型<type>xml</type>的详细信息请参见<xref linkend="datatype-xml">。用于在值和类型<type>xml</type>之间转换的类函数的表达式<function>xmlparse</function>和<function>xmlserialize</function>就不在这里重复介绍。使用大部分这些函数要求安装时使用了<command>configure --with-libxml</>进行编译。
  </para>

  <sect2 id="functions-producing-xml">
   <title>产生 XML 内容</title>

   <para>
    有一组函数和类函数的表达式可以用来从 SQL 数据产生 XML 内容。它们特别适合于将查询结果格式化成 XML 文档以便于在客户端应用中处理。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
     函数<function>xmlcomment</function>创建了一个 XML 值，它包含一个使用指定文本作为内容的 XML 注释。该文本不包含<quote><literal>--</literal></quote>或者也不会以一个<quote><literal>-</literal></quote>结尾，这样结果的结构是一个合法的 XML 注释。如果参数为空，结果也为空。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <para>
     函数<function>xmlconcat</function>将由单个 XML 值组成的列表串接成一个单独的值，这个值包含一个 XML 内容片断。空值会被忽略，只有当没有参数为非空时结果才为空。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
     如果 XML 声明存在，它们会按照下面的方式被组合。如果所有的参数值都有相同的 XML 版本声明，该版本将被用在结果中，否则将不使用版本。如果所有参数值有独立声明值<quote>yes</quote>，那么该值将被用在结果中。如果所有参数值都有一个独立声明值并且至少有一个为<quote>no</quote>，则<quote>no</quote>被用在结果中。否则结果中将没有独立声明。如果结果被决定要要求一个独立声明但是没有版本声明，将会使用一个版本 1.0 的版本声明，因为 XML 要求一个 XML 声明要包含一个版本声明。编码声明会被忽略并且在所有情况中都会被移除。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <para>
     表达式<function>xmlelement</function>使用给定名称、属性和内容产生一个 XML 元素。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
     不是合法 XML 名字的元素名和属性名将被逃逸，逃逸的方法是将违反的字符用序列<literal>_x<replaceable>HHHH</replaceable>_</literal>替换，其中<replaceable>HHHH</replaceable>是被替换字符的 Unicode 代码点的十六进制表示。例如：
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
     如果属性值是一个列引用，则不需要指定一个显式的属性名，在这种情况下列的名字将被默认用于属性的名字。在其他情况下，属性必须被给定一个显式名称。因此这个例子是合法的：
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     但是下面这些不合法：
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
     如果指定了元素内容，它们将被根据其数据类型格式化。如果内容本身也是类型<type>xml</type>，就可以构建复杂的 XML 文档。例如：
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

     其他类型的内容将被格式化为合法的 XML 字符数据。这意味着字符 &lt;, &gt;, 和 &amp; 将被转换为实体。二进制数据（数据类型<type>bytea</type>）将被表示成 base64 或十六进制编码，具体取决于配置参数<xref linkend="guc-xmlbinary">的设置。为了将 SQL 和 PostgreSQL 数据类型和 XML 模式声明对齐，我们期待单独数据类型的特定行为能够改进，到那时将会出现一个更为精确的描述。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <para>
     表达式<function>xmlforest</function>使用给定名称和内容产生一个元素的 XML 森林（序列）。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>

     如我们在第二个例子中所见，如果内容值是一个列引用，元素名称可以被忽略，这种情况下默认使用列名。否则，必须指定一个名字。
    </para>

    <para>
     如上文<function>xmlelement</function>所示，非法 XML 名字的元素名会被逃逸。相似地，内容数据也会被逃逸来产生合法的 XML 内容，除非它已经是一个<type>xml</type>类型。
    </para>

    <para>
     注意如果 XML 森林由多于一个元素组成，那么它不是合法的 XML 文档，因此在<function>xmlelement</function>中包装<function>xmlforest</function>表达式会有用处。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <para>
     表达式<function>xmlpi</function>创建一个 XML 处理指令。如果存在内容，内容不能包含字符序列<literal>?&gt;</literal>。
    </para>

    <para>
     例子：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <para>
     表达式<function>xmlroot</function>修改一个 XML 值的根结点的属性。如果指定了一个版本，它会替换根节点的版本声明中的值；如果指定了一个独立设置，它会替换根节点的独立声明中的值。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <para>
     和这里描述的其他函数不同，函数<function>xmlagg</function>是一个聚集函数。它将聚集函数调用的输入值串接起来，非常像<function>xmlconcat</function>所做的事情，除了串接是跨行发生的而不是在单一行的多个表达式上发生。聚集表达式的更多信息请见<xref linkend="functions-aggregate">。
    </para>

    <para>
     例子：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
     为了决定串接的顺序，可以为聚集调用增加一个<literal>ORDER BY</>子句，如<xref linkend="syntax-aggregates">中所述。例如：

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
     我们推荐在以前的版本中使用下列非标准方法，并且它们在特定情况下仍然有用：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
    <title>XML 谓词</title>

    <para>
     这一节描述的表达式检查<type>xml</type>值的属性。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <para>
     如果参数 XML 值是一个正确的 XML 文档，则<literal>IS DOCUMENT</literal>返回真，如果不是则返回假（即它是一个内容片断），或者是参数为空时返回空。文档和内容片断之间的区别请见<xref linkend="datatype-xml">。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY REF</optional> <replaceable>xml</replaceable> <optional>BY REF</optional>)
</synopsis>

    <para>
     如果第一个参数中的 XPath 表达式返回任何结点，则函数<function>xmlexists</function>返回真，否则返回假（如果哪一个参数为空，则结果就为空）。
    </para>

    <para>
     例子：
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
     <literal>BY REF</literal>子句在 PostgreSQL 中没有作用，但是为了和其他实现保持 SQL 一致性和兼容性还是允许它出现。每一种 SQL 标准，第一个<literal>BY REF</literal>是被要求的，而第二个则是可选的。也要注意 SQL 标准指定<function>xmlexists</function>结构来将一个 XQuery 表达式作为第一个参数，但 PostgreSQL 目前只支持 XPath，它是 XQuery的一个子集。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
     这些函数检查一个<type>text</>串是不是一个良构的 XML，返回一个布尔结果。<function>xml_is_well_formed_document</function>检查一个良构的文档，而<function>xml_is_well_formed_content</function>检查良构的内容。如果<xref linkend="guc-xmloption">配置参数被设置为<literal>DOCUMENT</>，<function>xml_is_well_formed</function>会做第一个函数的工作；如果配置参数被设置为<literal>CONTENT</>，<function>xml_is_well_formed</function>会做第二个函数的工作。这意味着<function>xml_is_well_formed</function>对于检查一个到类型<type>xml</>的简单造型是否会成功非常有用，而其他两个函数对于检查<function>XMLPARSE</>的对应变体是否会成功有用。
    </para>

    <para>
     例子：

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

     最后一个例子显示了这些检查也包括名字空间是否正确地匹配。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
   <title>处理 XML</title>

   <indexterm>
    <primary>XPath</primary>
   </indexterm>

   <para>
    要处理数据类型<type>xml</type>的值， PostgreSQL 提供了函数<function>xpath</function>和<function>xpath_exists</function>，它们计算 XPath 1.0 表达式。
   </para>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
    函数<function>xpath</function>在 XML 值<replaceable>xml</replaceable>上计算 XPath 表达式<replaceable>xpath</replaceable> (a <type>text</> value)。它返回一个 XML 值的数组，该数组对应于该 XPath 表达式产生的结点集合。如果该 XPath 表达式返回一个标量值而不是一个结点集合，将会返回一个单一元素的数组。
   </para>

  <para>
    第二个参数必须是一个良构的 XML 文档。特殊地，它必须有一个单一根结点元素。
  </para>

   <para>
    该函数可选的第三个参数是一个名字空间映射的数组。这个数组应该是一个二维<type>text</>数组，其第二轴长度等于2（即它应该是一个数组的数组，其中每一个都由刚好 2 个元素组成）。每个数组项的第一个元素是名字空间的名称（别名），第二个元素是名字空间的 URI。并不要求在这个数组中提供的别名和在 XML 文档本身中使用的那些名字空间相同（换句话说，在 XML 文档中和在<function>xpath</function>函数环境中，别名都是<emphasis>本地的</>）。
   </para>

   <para>
    例子：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
   </para>

   <para>
    要处理默认（匿名）命名空间，做这样的事情：
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
   </para>

   <indexterm>
    <primary>xpath_exists</primary>
   </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
    函数<function>xpath_exists</function>是<function>xpath</function>函数的一种特殊形式。这个函数不是返回满足 XPath 的单一 XML 值，它返回一个布尔值表示查询是否被满足。这个函数等价于标准的<literal>XMLEXISTS</>谓词，不过它还提供了对一个名字空间映射参数的支持。
   </para>

   <para>
    例子：
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
   </para>
  </sect2>

  <sect2 id="functions-xml-mapping">
   <title>将表映射到 XML</title>

   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>

   <para>
    下面的函数将会把关系表的内容映射成 XML 值。它们可以被看成是 XML 导出功能：
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
    每一个函数的返回值都是<type>xml</type>。
   </para>

   <para>
    <function>table_to_xml</function>映射由参数<parameter>tbl</parameter>传递的命名表的内容。<type>regclass</type>类型接受使用常见标记标识表的字符串，包括可选的模式限定和双引号。<function>query_to_xml</function>执行由参数<parameter>query</parameter>传递的查询并且映射结果集。<function>cursor_to_xml</function>从<parameter>cursor</parameter>指定的游标中取出指定数量的行。如果需要映射一个大型的表，我们推荐这种变体，因为每一个函数都是在内存中构建结果值的。
   </para>

   <para>
    如果<parameter>tableforest</parameter>为假，则结果的 XML 文档看起来像这样：
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    如果<parameter>tableforest</parameter>为真，结果是一个看起来像这样的 XML 内容片断：
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    如果没有表名可用，在映射一个查询或一个游标时，在第一种格式中使用串<literal>table</literal>，在第二种格式中使用<literal>row</literal>。
   </para>

   <para>
    这几种格式的选择由用户决定。第一种格式是一个正确的 XML 文档，它在很多应用中都很重要。如果结果值要被重组为一个文档，第二种格式在<function>cursor_to_xml</function>函数中更有用。前文讨论的产生 XML 内容的函数（特别是<function>xmlelement</function>）可以被用来把结果修改成符合用户的要求。
   </para>

   <para>
    数据值会被以前文的函数<function>xmlelement</function>中描述的相同方法映射。
   </para>

   <para>
    参数<parameter>nulls</parameter>决定空值是否会被包含在输出中。如果为真，列中的空值被表示为：
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    其中<literal>xsi</literal>是 XML 模式实例的 XML 名字空间前缀。一个合适的名字空间声明将被加入到结果值中。如果为假，包含空值的列将被从输出中忽略掉。
   </para>

   <para>
    参数<parameter>targetns</parameter>指定想要的结果的 XML 名字空间。如果没有想要的特定名字空间，将会传递一个空串。
   </para>

   <para>
    下面的函数返回 XML 模式文档，这些文档描述上述对应函数所执行的映射：
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
    最重要的是相同的参数被传递来获得匹配的 XML 数据映射和 XML 模式文档。
   </para>

   <para>
    下面的函数产生 XML 数据映射和对应的 XML 模式，并把产生的结果链接在一起放在一个文档（或森林）中。在要求自包含和自描述的结果是它们非常有用：
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>

   <para>
    另外，下面的函数可用于产生相似的整个模式或整个当前数据库的映射：
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>

    注意这些函数可能产生很多数据，它们都需要在内存中被构建。在请求大型模式或数据库的内容映射时，可以考虑分别映射每一个表，甚至通过一个游标来映射。
   </para>

   <para>
    一个模式内容映射的结果看起来像这样：

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    其中一个表映射的格式取决于上文解释的<parameter>tableforest</parameter>参数。
   </para>

   <para>
    一个数据库内容映射的结果看起来像这样：

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    其中的模式映射如上所述。
   </para>

   <para>
    作为一个使用这些函数产生的输出的例子，<xref linkend="xslt-xml-html">展示了一个 XSLT 样式表，它将<function>table_to_xml_and_xmlschema</function>的输出转换为一个包含表数据的扁平转印的 HTML 文档。以一种相似的方式，这些函数的结果可以被转换成其他基于 XML 的格式。
   </para>

   <figure id="xslt-xml-html">
    <title>转换 SQL/XML 输出到 HTML 的 XSLT 样式表</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
  <title>JSON 函数和操作符</title>

  <indexterm zone="functions-json">
    <primary>JSON</primary>
    <secondary>函数和操作符</secondary>
  </indexterm>

   <para>
   <xref linkend="functions-json-op-table">展示了可以用于两种 JSON 
   数据类型（见<xref linkend="datatype-json">）的操作符。
  </para>

  <table id="functions-json-op-table">
     <title><type>json</>和<type>jsonb</> 操作符</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>右操作数类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>例子结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry>获得 JSON 数组元素（索引从 0 开始，负整数结束）</entry>
        <entry><literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</literal></entry>
        <entry><literal>{"c":"baz"}</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry>通过键获得 JSON 对象域</entry>
        <entry><literal>'{"a": {"b":"foo"}}'::json-&gt;'a'</literal></entry>
        <entry><literal>{"b":"foo"}</literal></entry>
       </row>
        <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry>以<type>文本</>形式获得 JSON 数组元素</entry>
        <entry><literal>'[1,2,3]'::json-&gt;&gt;2</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry>以<type>文本</>形式获得 JSON 对象域</entry>
        <entry><literal>'{"a":1,"b":2}'::json-&gt;&gt;'b'</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>获取在指定路径的 JSON 对象</entry>
        <entry><literal>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</literal></entry>
        <entry><literal>{"c": "foo"}</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>以<type>文本</>形式获取在指定路径的 JSON 对象</entry>
        <entry><literal>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>
    对<type>json</type>和<type>jsonb</type>类型，这些操作符都有其并行变体。
    域/元素/路径抽取操作符返回与其左手输入（<type>json</type>或<type>jsonb</type>）
    相同的类型，不过那些被指定为返回<type>text</>的除外，它们的返回值会被强制
    为文本。如果该 JSON 输入没有匹配请求的正确结构（例如那样的元素不存在），这些域/元素/路径抽取操作符会返回 NULL 而不是失败。
    接受整数JSON数组下标的域/元素/路径提取操作符支持数组末尾的负下标。
   </para>
  </note>
  <para>
   <xref linkend="functions-comparison-table">中展示的标准比较操作符只对
   <type>jsonb</type>有效，而不适合<type>json</type>。它们遵循在<xref
   linkend="json-indexing">中给出的 B 树操作规则。
  </para>
  <para>
   如<xref linkend="functions-jsonb-op-table">中所示，还存在一些只适合
   <type>jsonb</type>的操作符。这些操作符中的很多可以用<type>jsonb</>
   操作符类索引。<type>jsonb</>包含和存在语义的完整描述可参见<xref
   linkend="json-containment">。<xref linkend="json-indexing">描述了如何
   用这些操作符来有效地索引<type>jsonb</>数据。
  </para>
  <table id="functions-jsonb-op-table">
     <title>额外的<type>jsonb</>操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>右操作数类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>@&gt;</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>左边的 JSON 值是否包含顶层右边JSON路径/值项?</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;@</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>左边的JSON路径/值是否包含在顶层右边JSON值中？</entry>
        <entry><literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>?</literal></entry>
        <entry><type>text</type></entry>
        <entry><emphasis>字符串</emphasis>是否作为顶层键值存在于JSON值中？</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal></entry>
       </row>
       <row>
        <entry><literal>?|</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>这些数组<emphasis>字符串</emphasis>中的任何一个是否作为顶层键值存在？</entry>
        <entry><literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</literal></entry>
       </row>
       <row>
        <entry><literal>?&amp;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>这些数组<emphasis>字符串</emphasis>是否作为顶层键值存在？</entry>
        <entry><literal>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</literal></entry>
       </row>
       
       <row>
        <entry><literal>||</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>连接两个<type>jsonb</type>值到新的<type>jsonb</type>值</entry>
        <entry><literal>'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>text</type></entry>
        <entry>从左操作数中删除键/值对或<emphasis>字符串</emphasis>元素。基于键值匹配键/值对。</entry>
        <entry><literal>'{"a": "b"}'::jsonb - 'a' </literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>integer</type></entry>
        <entry>删除指定索引的数组元素（负整数结尾）。如果顶层容器不是一个数组，那么抛出错误。</entry>
        <entry><literal>'["a", "b"]'::jsonb - 1 </literal></entry>
       </row>
       <row>
        <entry><literal>#-</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>删除指定路径的域或元素（JSON数组，负整数结尾）</entry>
        <entry><literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal></entry>
       </row>  
       
      </tbody>
     </tgroup>
   </table>
   
   <note>
   <para>
    <literal>||</>操作符连接每个操作数顶层的元素。
    它不递归操作。比如，如果两个操作数都是具有共同键字段名称的对象，
    则结果中字段值只会是从右边操作数的值。
   </para>
  </note>

  <para>
   <xref linkend="functions-json-creation-table">展示了能用来创建
   <type>json</type>和<type>jsonb</type>值的函数
   （当前，没有用于<type>jsonb</>，
   <literal>row_to_json</>以及<literal>array_to_json</>的等效函数，
   然而，<literal>to_jsonb</>函数提供了许多诸如这些函数的相同功能）。
  </para>

  <indexterm>
   <primary>to_json</primary>
  </indexterm>
  <indexterm>
   <primary>array_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>row_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>json_object</primary>
  </indexterm>
  <indexterm>
   <primary>to_jsonb</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object</primary>
  </indexterm>
  
  <table id="functions-json-creation-table">
    <title>JSON 创建函数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>例子结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <para><literal>to_json(anyelement)</literal>
          </para><para><literal>to_jsonb(anyelement)</literal>
       </para></entry>
       <entry>
         把值返回为<type>json</>或者<type>jsonb</>。数组和组合被（递归地）转换成数组和对象；否则，
         如果有从该类型到<type>json</type>的投影，将使用该投影函数来执行转换；
         否则将产生一个标量值。对任何一个数值、布尔量或空值的标量类型，
         将使用其文本表达，以这样一种方式使其成为有效的<type>json</>或者<type>jsonb</>值。
       </entry>
       <entry><literal>to_json('Fred said "Hi."'::text)</literal></entry>
       <entry><literal>"Fred said \"Hi.\""</literal></entry>
      </row>
      <row>
       <entry>
         <literal>array_to_json(anyarray [, pretty_bool])</literal>
       </entry>
       <entry>
         把数组作为一个 JSON 数组返回。一个 PostgreSQL 多维数组会成为一个数组
         的 JSON 数组。如果<parameter>pretty_bool</parameter>为真，将在
         第 1 维度的元素之间增加换行。
       </entry>
       <entry><literal>array_to_json('{{1,5},{99,100}}'::int[])</literal></entry>
       <entry><literal>[[1,5],[99,100]]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>row_to_json(record [, pretty_bool])</literal>
       </entry>
       <entry>
         把行作为一个 JSON 对象返回。如果<parameter>pretty_bool</parameter>为真，将在第1层元素之间增加换行。
       </entry>
       <entry><literal>row_to_json(row(1,'foo'))</literal></entry>
       <entry><literal>{"f1":1,"f2":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_array(VARIADIC "any")</literal>
       </para><para><literal>jsonb_build_array(VARIADIC "any")</literal>
       </para></entry>
       <entry>
         从一个可变参数列表构造一个可能包含异质类型的 JSON 数组。
       </entry>
       <entry><literal>json_build_array(1,2,'3',4,5)</literal></entry>
       <entry><literal>[1, 2, "3", 4, 5]</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_object(VARIADIC "any")</literal>
       </para><para><literal>jsonb_build_object(VARIADIC "any")</literal>
       </para>
       </entry>
       <entry>
         从一个可变参数列表构造一个 JSON 对象。通过转换，该参数列表由交替
         出现的键和值构成。
       </entry>
       <entry><literal>json_build_object('foo',1,'bar',2)</literal></entry>
       <entry><literal>{"foo": 1, "bar": 2}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(text[])</literal>
       </para><para><literal>jsonb_object(text[])</literal>
       </para></entry>
       <entry>
         从一个文本数组构造一个 JSON 对象。该数组必须可以是具有偶数个成员的
         一维数组（成员被当做交替出现的键/值对），或者是一个二维数组（每一个
         内部数组刚好有 2 个元素，可以被看做是键/值对）。
       </entry>
       <entry><para><literal>json_object('{a, 1, b, "def", c, 3.5}')</></para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</></para></entry>
       <entry><literal>{"a": "1", "b": "def", "c": "3.5"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(keys text[], values text[])</literal>
          </para><para><literal>jsonb_object(keys text[], values text[])</literal>
       </para></entry>
       <entry>
         <function>json_object</>的这种形式从两个独立的数组得到键/值对。在其
         他方面和一个参数的形式相同。
       </entry>
       <entry><literal>json_object('{a, b}', '{1,2}')</literal></entry>
       <entry><literal>{"a": "1", "b": "2"}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
     <function>array_to_json</>和<function>row_to_json</>与<function>to_json</>
     具有相同的行为，不过它们提供了更好的打印选项。针对<function>to_json</>所描述
     的行为同样也适用于由其他 JSON 创建函数转换的每个值。
    </para>
  </note>

  <note>
    <para>
     <xref linkend="hstore">扩展有一个从<type>hstore</type>到<type>json</type>
     的造型，因此通过 JSON 创建函数转换的<type>hstore</type>值将被表示为 JSON
     对象，而不是原始字符串值。
    </para>
  </note>

  <para>
   <xref linkend="functions-json-processing-table">展示了可用来处理<type>json</type>
   和<type>jsonb</type>值的函数。
  </para>
      
         <indexterm>
          <primary>json_array_length</primary>
         </indexterm>
         <indexterm>
   <primary>jsonb_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>json_each</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each</primary>
  </indexterm>
  <indexterm>
   <primary>json_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_strip_nulls</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_strip_nulls</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_set</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_pretty</primary>
  </indexterm>

  <table id="functions-json-processing-table">
    <title>JSON 处理</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回值</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>例子结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>json_array_length(json)</literal>
         </para><para><literal>jsonb_array_length(jsonb)</literal>
       </para></entry>
       <entry><type>int</type></entry>
       <entry>
         返回最外层 JSON 数组中的元素数量。
       </entry>
       <entry><literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_each(json)</literal>
         </para><para><literal>jsonb_each(jsonb)</literal>
       </para></entry>
       <entry><para><literal>setof key text, value json</literal>
         </para><para><literal>setof key text, value jsonb</literal>
       </para></entry>
       <entry>
         扩展最外层的 JSON 对象成为一组键/值对。
       </entry>
       <entry><literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_each_text(json)</literal>
         </para><para><literal>jsonb_each_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof key text, value text</type></entry>
       <entry>
         扩展最外层的 JSON 对象成为一组键/值对。返回值将是<type>文本</>类型。
       </entry>
       <entry><literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path(from_json json, VARIADIC path_elems text[])</literal>
        </para><para><literal>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type>
       </para></entry>
       <entry>
         返回由<replaceable>path_elems</replaceable>指向的 JSON 值（等效于<literal>#&gt;</literal>操作符）。
       </entry>
       <entry><literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</literal></entry>
       <entry><literal>{"f5":99,"f6":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path_text(from_json json, VARIADIC path_elems text[])</literal>
         </para><para><literal>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
         以<type>文本</>返回由<parameter>path_elems</parameter>指向的 JSON 值（等效于<literal>#&gt;&gt;</literal>操作符）。
       </entry>
       <entry><literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</literal></entry>
       <entry><literal>foo</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object_keys(json)</literal>
         </para><para><literal>jsonb_object_keys(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
          返回最外层 JSON 对象中的键集合。
       </entry>
       <entry><literal>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal></entry>
       <entry>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_record(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_record(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>anyelement</type></entry>
       <entry>
         扩展<replaceable>from_json</replaceable>中的对象成一个行，它的列匹配由<replaceable>base</>定义的记录类型（见下文的注释）。
       </entry>
       <entry><literal>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_recordset(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_recordset(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>setof anyelement</type></entry>
       <entry>
         扩展<replaceable>from_json</replaceable>中最外的对象数组为一个集合，该集合的列匹配由<replaceable>base</>定义的记录类型。
       </entry>
       <entry><literal>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements(json)</literal>
         </para><para><literal>jsonb_array_elements(jsonb)</literal>
       </para></entry>
       <entry><para><type>setof json</type>
         </para><para><type>setof jsonb</type>
       </para></entry>
       <entry>
         把一个 JSON 数组扩展成一个 JSON 值的集合。
       </entry>
       <entry><literal>select * from json_array_elements('[1,true, [2,false]]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements_text(json)</literal>
         </para><para><literal>jsonb_array_elements_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
         把一个 JSON 数组扩展成一个<type>text</>值集合。
       </entry>
       <entry><literal>select * from json_array_elements_text('["foo", "bar"]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_typeof(json)</literal>
         </para><para><literal>jsonb_typeof(jsonb)</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
         把最外层的 JSON 值的类型作为一个文本字符串返回。可能的类型是：
         <literal>object</>、<literal>array</>、<literal>string</>、<literal>number</>、
         <literal>boolean</>以及<literal>null</>。
       </entry>
       <entry><literal>json_typeof('-123.4')</literal></entry>
       <entry><literal>number</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_to_record(json)</literal>
          </para><para><literal>jsonb_to_record(jsonb)</literal>
       </para></entry>
       <entry><type>record</type></entry>
       <entry>
         从一个 JSON 对象（见下文的注解）构建一个任意的记录。正如所有返回<type>record</>
         的函数一样，调用者必须用一个<literal>AS</>子句显式地定义记录的结构。
       </entry>
       <entry><literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text) </literal></entry>
       <entry>
<programlisting>
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_to_recordset(json)</literal>
         </para><para><literal>jsonb_to_recordset(jsonb)</literal>
       </para></entry>
       <entry><type>setof record</type></entry>
       <entry>
         从一个 JSON 对象数组（见下文的注解）构建一个任意的记录集合。正如所有返回<type>record</>
         的函数一样，调用者必须用一个<literal>AS</>子句显式地定义记录的结构。
       </entry>
       <entry><literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</literal></entry>
       <entry>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </entry>
      </row>
      
       <row>
       <entry><para><literal>json_strip_nulls(from_json json)</literal>
         </para><para><literal>jsonb_strip_nulls(from_json jsonb)</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type></para></entry>
       <entry>
         返回具有空值对象域的<replaceable>from_json</replaceable>。其它空值不变。  
       </entry>
       <entry><literal>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry><literal>[{"f1":1},2,null,3]</literal></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_set(target jsonb, path text[], new_value jsonb<optional>, <parameter>create_missing</parameter> <type>boolean</type></optional>)</literal>
         </para></entry>
       <entry><para><type>jsonb</type></para></entry>
       <entry>
         如果<replaceable>create_missing</replaceable>是真的
         （缺省是<literal>true</>）并且通过<replaceable>path</replaceable>
         指定部分不存在，那么返回<replaceable>target</replaceable>，
         它具有<replaceable>path</replaceable>指定部分，
         <replaceable>new_value</replaceable>替换部分，
         或者<replaceable>new_value</replaceable>添加部分。
         正如路径导向的操作符，负整数出现在JSON数组结尾的<replaceable>path</replaceable>>计数中。
       </entry>
       <entry><para><literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</literal>
         </para><para><literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</literal>
         </para></entry>
       <entry><para><literal>[{"f1":[2,3,4],"f2":null},2,null,3]</literal>
         </para><para><literal>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</literal>
        </para></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_pretty(from_json jsonb)</literal>
         </para></entry>
       <entry><para><type>text</type></para></entry>
       <entry>
         作为缩进JSON文本返回<replaceable>from_json</replaceable>。
       </entry>
       <entry><literal>jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]
</programlisting>
        </entry>
       </row>
          
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
      很多这些函数和操作符将把 JSON 字符串中的 Unicode 转义转换成合适的单一字符。如果
      输入类型是<type>jsonb</>，这就没有问题，因为该转换已经完成了。但是对于<type>json</>
      输入，这可能会导致抛出一个错误（如<xref linkend="datatype-json">所述）。
    </para>
  </note>

  <note>
    <para>
      在<function>json_populate_record</>、<function>json_populate_recordset</>、
      <function>json_to_record</>和<function>json_to_recordset</>中，来自 JSON 的
      类型强制是<quote>尽力而为</>并且对于某些类型可能得不到想要的值。JSON 键会被
      匹配目标行类型中相同的列名。没有出现在目标行类型中的 JSON 域将会被从输出中忽略，
      并且不匹配任何 JSON 域的目标列将被简单地作为 NULL。
    </para>
  </note>

  <note>
    <para>
      所有<literal>jsonb_set</>的<literal>path</>参数项必须存在于<literal>target</>中，
      除非<literal>create_missing</>是真的，在这种情况下，除了最后一项都存在。
      如果这些条件未满足<literal>target</>返回不变。
    </para>
    <para>
      如果最后路径项是对象键，如果它不存在并且给予新值，则被创建。
      如果最后路径项是一个数组索引，如果通过从左边计数发现设置项是正数，
      如果从右边- <literal>-1</>计数负数指定右边的元素，等等。
      如果项超出-array_length .. array_length -1范围，并且create_missing是真，
      如果项是负数，则在数组开头添加新值，如果是正数，则添加到数组末尾。
    </para>
  </note>
  
  <note>
    <para>
      不要把<literal>json_typeof</>函数的<literal>null</>返回值与 SQL 的 NULL 弄混。
      虽然调用<literal>json_typeof('null'::json)</>将会返回<literal>null</>，但调用
      <literal>json_typeof(NULL::json)</>将会返回一个 SQL 的 NULL。
    </para>
  </note>
  
  <note>
    <para>
      如果参数到<literal>json_strip_nulls</>包含任何对象的复制字段名，
      其结果可能是语义上不同，依赖于它们所产生的顺序。
      这不是<literal>jsonb_strip_nulls</>的问题，
      因为<type>jsonb</type>值从不复制对象字段名。
    </para>
  </note>

  <para>
    也可参见<xref linkend="functions-aggregate">了解聚集函数<function>json_agg</function>，它可以把记录值聚集成 JSON。还有聚集函数<function>json_object_agg</function>，它可以把值对
    聚集成一个 JSON 对象，以及<type>jsonb</type>等价物，
    <function>jsonb_agg</>和<function>jsonb_object_agg</>。
  </para>
 </sect1>

 <sect1 id="functions-sequence">
  <title>序列操作函数</title>

  <indexterm>
   <primary>sequence</primary>
  </indexterm>
  <indexterm>
   <primary>nextval</primary>
  </indexterm>
  <indexterm>
   <primary>currval</primary>
  </indexterm>
  <indexterm>
   <primary>lastval</primary>
  </indexterm>
  <indexterm>
   <primary>setval</primary>
  </indexterm>

  <para>
   本节描述用于操作<firstterm>序列对象</firstterm>的函数，序列对象也被称为序列生成器或者就是序列。序列对象都是用<xref linkend="sql-createsequence">创建的特殊的单行表。序列对象通常用于为表的行生成唯一的标识符。<xref linkend="functions-sequence-table">中列出的这些序列函数，可以为我们从序列对象中获取连续的序列值提供了简单的、多用户安全的 方法。
  </para>

   <table id="functions-sequence-table">
    <title>序列函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>函数</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>currval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>返回最近一次用<function>nextval</function>获取的指定序列的值</entry>
      </row>
      <row>
        <entry><literal><function>lastval()</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>返回最近一次用<function>nextval</function>获取的任何序列的值</entry>
      </row>
      <row>
        <entry><literal><function>nextval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>递增序列并返回新值</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>设置序列的当前值</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>, <type>boolean</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>设置序列的当前值以及<literal>is_called</literal>标志</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   将要由序列函数调用操作的序列是用一个<type>regclass</>参数声明的， 它只是序列在<structname>pg_class</>系统表里面的 OID。不过，你不需要手工查找 OID， 因为<type>regclass</>数据类型的输入转换器会帮你做这件事情。 只要写出用单引号包围的序列名字即可，因此它看上去像文本常量。为了和普通<acronym>SQL</acronym>名字处理兼容，这个字串将转换成小写形式， 除非在序列名字周围包含双引号。因此：
<programlisting>
nextval('foo')      <lineannotation>操作序列<literal>foo</literal></>
nextval('FOO')      <lineannotation>操作序列<literal>foo</literal></>
nextval('"Foo"')    <lineannotation>操作序列<literal>Foo</literal></>
</programlisting>
   必要时序列名可以用模式限定∶
<programlisting>
nextval('myschema.foo')     <lineannotation>操作<literal>myschema.foo</literal></>
nextval('"myschema".foo')   <lineannotation>同上</lineannotation>
nextval('foo')              <lineannotation>在搜索路径中查找<literal>foo</literal></>
</programlisting>
   参阅<xref linkend="datatype-oid">获取有关<type>regclass</>的更多信息。
  </para>

  <note>
   <para>
    在<productname>PostgreSQL</productname> 8.1 之前，序列函数的参数类型是<type>text</>， 而不是 <type>regclass</>，并且前文所述的从文本串到 OID 值的转换将在每次调用的时候发生。 为了向后兼容，这个处理仍然存在，但是在内部实际上是通过在函数调用前隐式地将<type>text</>转换成<type>regclass</>实现的。
   </para>

   <para>
    当你把一个序列函数的参数写成一个无修饰的文字串，那么它将变成类型为<type>regclass</>的常量。因为这只是一个 OID，它将跟踪最初标识的序列，而不管后面是否改名、模式变化等等。 这种<quote>早期绑定</>的行为通常是列默认值和视图中引用的序列所需要的。 但是有时候你可能想要<quote>延迟绑定</>，其中序列的引用是在运行时解析的。要得到延迟绑定的行为，我们可以强制常量被存储为<type>text</>常量，而不是<type>regclass</>：
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal>在运行时查找</>
</programlisting>
    请注意，延迟绑定是<productname>PostgreSQL</productname>版本 8.1 之前唯一被支持的行为， 因此你可能需要做这些来保留旧应用的语义。
   </para>

   <para>
    当然，序列函数的参数也可以是表达式。如果它是一个文本表达式，那么隐式的转换将导致运行时的查找。
   </para>
  </note>

  <para>
   可用的序列函数有∶

    <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
       <para>
        递增序列对象到它的下一个值并且返回该值。这个动作是自动完成的： 即使多个会话并发执行<function>nextval</function>，每个进程也会安全地收到一个唯一的序列值。
       </para>

       <para>
        如果一个序列对象是用默认参数创建的，连续的<function>nextval</function>调用将会返回从 1 开始的连续的值。其他的行为可以通过在<xref linkend="sql-createsequence">命令中使用特殊参数来获得；详见该命令的参考页。
       </para>

       <important>
        <para>
         为了避免从同一个序列获取值的并发事务被阻塞，
         <function>nextval</function>操作决不会回滚；也就是说，一旦一个值已经被抓取，
         那么就认为它已经被用过了，并且不会再被返回。
         即使周围的事务之后中断，或者如果调用查询结束不使用该值，那么为真。
         例如，带有<literal>ON CONFLICT</>的<command>INSERT</>子句将计算被插入的元组，
         包括执行任何所需的<function>nextval</function>调用，
         相反检测任何冲突之前将导致它遵循<literal>ON CONFLICT</>规则。
         这种情况将在指定值的顺序中留下未使用的<quote>空洞</quote>。
         因此，<productname>PostgreSQL</>序列对象<emphasis>不能用于获得<quote>无间隙</>序列</emphasis>。
        </para>
       </important>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <para>
        在当前会话中返回最近一次<function>nextval</function>取到的该序列的值（如果在本会话中从未在该序列上调用过<function>nextval</function>，那么会报告一个错误）。请注意因为此函数返回一个会话本地的值，不论其它会话是否在当前会话之后执行过<function>nextval</function>，它都能给出一个可预测的回答。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>lastval</function></term>
      <listitem>
       <para>
        返回当前会话里最近一次<function>nextval</>返回的值。
        这个函数等效于<function>currval</function>，
        只是它不用序列名作参数，
        它指的是哪个序列<function>nextval</function>被应用到当前会话。
        如果当前会话还没有调用过<function>nextval</function>，
        那么调用<function>lastval</function>会报错。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <para>
        重置序列对象的计数器值。双参数的形式设置序列的<literal>last_value</literal>域为指定值并且将其<literal>is_called</literal>域设置为 <literal>true</literal>，表示下一次<function>nextval</function>将在返回值之前递增该序列。<function>currval</>报告的值也被设置为指定的值。在三参数形式里，<literal>is_called</literal>可以设置为<literal>true</literal>或<literal>false</literal>。<literal>true</>具有和双参数形式相同的效果。如果你把它设置为<literal>false</literal>，那么下一次<function>nextval</function>将返回指定的值，而从随后的<function>nextval</function>才开始递增该序列。此外，在这种情况中<function>currval</>报告的值不会被改变。 例如：

<screen>
SELECT setval('foo', 42);           <lineannotation>下一次<function>nextval</>会返回 43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>同上</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>下一次<function>nextval</>将返回 42</lineannotation>
</screen>

        <function>setval</function>返回的结果就是它的第二个参数的值。
       </para>
       <important>
        <para>
         因为序列是非事务的，<function>setval</function>造成的改变不会由于事务的回滚而撤销。
        </para>
       </important>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>

 </sect1>


 <sect1 id="functions-conditional">
  <title>条件表达式</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
   <primary>条件表达式</primary>
  </indexterm>

  <para>
   本节描述在<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的条件表达式。
  </para>

  <tip>
   <para>
    如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个存储过程。
   </para>
  </tip>

  <sect2 id="functions-case">
   <title><literal>CASE</></title>

  <para>
   <acronym>SQL</acronym> <token>CASE</token>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句：

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token>子句可以用于任何表达式可以出现的地方。每一个<replaceable>condition</replaceable>是一个返回<type>boolean</type>结果的表达式。如果结果为真，那么<token>CASE</token>表达式的结果就是符合条件的<replaceable>result</replaceable>，并且剩下的<token>CASE</token>表达式不会被处理。如果条件的结果不为真，那么以相同方式搜寻任何随后的<token>WHEN</token>子句。如果没有<token>WHEN</token> <replaceable>condition</replaceable>为真，那么<token>CASE</>表达式的值就是在<token>ELSE</token>子句里的<replaceable>result</replaceable>。如果省略了<token>ELSE</token>子句而且没有条件为真，结果为空。
  </para>

   <para>
    例子：
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

  <para>
   所有<replaceable>result</replaceable>表达式的数据类型都必须可以转换成单一的输出类型。 参阅<xref linkend="typeconv-union-case">获取细节。
  </para>

  <para>
   下面这个<quote>简单</>形式的<token>CASE</token>表达式是上述通用形式的一个变种：

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   第一个<replaceable>expression</replaceable>会被计算，然后与所有在<token>WHEN</token>子句中的每一个<replaceable>value</replaceable>对比，直到找到一个相等的。如果没有找到匹配的，则返回在<token>ELSE</token>子句中的<replaceable>result</replaceable>（或者控制）。 这类似于 C 里的<function>switch</function>语句。
  </para>

   <para>
    上面的例子可以用简单<token>CASE</token>语法来写：
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

   <para>
    <token>CASE</token>表达式并不计算任何无助于判断结果的子表达式。例如，下面是一个可以避免被零除错误的方法：
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <para>
     如<xref linkend="syntax-express-eval">中所述，在有几种情况中一个表达式的子表达式
     会被计算多次，因此<quote><token>CASE</token>只计算必要的表达式</quote>这
     一原则并非不可打破。例如一个常量子表达式<literal>1/0</>通常将会在规划时导致一次
     除零错误，即便它位于一个执行时永远也不会进入的<token>CASE</token>分支时也是
     如此。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
   <function>COALESCE</function>函数返回它的第一个非空参数的值。当且仅当所有参数都为空时才会返回空。它常用于在为显示目的检索数据时用缺省值替换空值。例如：
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   如果<varname>description</>不为空，这将会返回它的值，否则如果<varname>short_description</>非空则返回<varname>short_description</>的值，如果前两个都为空则返回<literal>(none)</>。
  </para>

   <para>
    和<token>CASE</token>表达式一样，<function>COALESCE</function>将不会 计算无助于判断结果的参数；也就是说，在第一个非空参数右边的参数不会被计算。这个 SQL 标准函数提供了类似于<function>NVL</>和<function>IFNULL</>的能力，它们被用在某些其他数据库系统中。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  <para>
   当<replaceable>value1</replaceable>和<replaceable>value2</replaceable>相等时，<function>NULLIF</function>返回一个空值。 否则它返回<replaceable>value1</replaceable>。 这些可以用于执行前文给出的<function>COALESCE</function>例子的逆操作：
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
  </para>
  <para>
   在这个例子中，如果<literal>value</literal>是<literal>(none)</>，将返回空值，否则返回<literal>value</literal>的值。
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
   <title><literal>GREATEST</literal>和<literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <para>
    <function>GREATEST</>和<function>LEAST</>函数从一个任意的数字表达式列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型 （参阅<xref linkend="typeconv-union-case">获取细节）。列表中的 NULL 数值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。
   </para>

   <para>
    请注意<function>GREATEST</>和<function>LEAST</>都不是 SQL 标准，但却是很常见的扩展。某些其他数据库让它们在任何参数为 NULL 时返回 NULL，而不是在所有参数都为 NULL 时才返回 NULL。
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
  <title>数组函数和操作符</title>

  <para>
   <xref linkend="array-operators-table">显示了可以用于数组类型的操作符。
  </para>

    <table id="array-operators-table">
     <title>数组操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>等于</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>不等于</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>小于</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>大于</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>小于等于</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>大于等于</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含</entry>
        <entry><literal>ARRAY[1,4,3] @&gt; ARRAY[3,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>被包含</entry>
        <entry><literal>ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>重叠（具有公共元素）</entry>
        <entry><literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>数组和数组串接</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>数组和数组串接</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>元素到数组串接</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>数组到元素串接</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   数组比较使用默认的 B-Tree 在元素数据类型上的比较函数对数组内容按元素逐一进行。 多维数组的元素按照行序进行访问（最后的下标变化最快）。如果两个数组的内容相同但维数不等，那么维度信息中的第一个不同将决定排序顺序（这是对<productname>PostgreSQL</> 8.2 之前版本的修改： 老版本认为内容相同的两个数组相等，即使它们的维数或下标范围并不相同）。
  </para>

  <para>
   参阅<xref linkend="arrays">获取有关数组操作符行为的更多细节。有关哪些操作符支持被索引的操作，请参阅<xref linkend="indexes-types">。
  </para>

  <para>
   <xref linkend="array-functions-table">展示了可以用于数组类型的函数。 参阅<xref linkend="arrays">获取更多信息以及使用这些函数的例子。
  </para>

  <indexterm>
    <primary>array_append</primary>
  </indexterm>
  <indexterm>
    <primary>array_cat</primary>
  </indexterm>
  <indexterm>
    <primary>array_ndims</primary>
  </indexterm>
  <indexterm>
    <primary>array_dims</primary>
  </indexterm>
  <indexterm>
    <primary>array_fill</primary>
  </indexterm>
  <indexterm>
    <primary>array_length</primary>
  </indexterm>
  <indexterm>
    <primary>array_lower</primary>
  </indexterm> 
  <indexterm>
    <primary>array_position</primary>
  </indexterm>
  <indexterm>
    <primary>array_positions</primary>
  </indexterm>
  
  <indexterm>
    <primary>array_prepend</primary>
  </indexterm>
  <indexterm>
    <primary>array_remove</primary>
  </indexterm>
  <indexterm>
    <primary>array_replace</primary>
  </indexterm>
  <indexterm>
    <primary>array_to_string</primary>
  </indexterm>
 <indexterm>
    <primary>array_upper</primary>
  </indexterm>
  <indexterm>
    <primary>cardinality</primary>
  </indexterm>
  <indexterm>
    <primary>string_to_array</primary>
  </indexterm>
  <indexterm>
    <primary>unnest</primary>
  </indexterm>

    <table id="array-functions-table">
     <title>数组函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>array_append</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>向一个数组的末端追加一个元素</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_cat</function>(<type>anyarray</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>连接两个数组</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_ndims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>返回数组的维度数</entry>
        <entry><literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_dims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>返回数组的维度的文本表示</entry>
        <entry><literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_fill</function>(<type>anyelement</type>, <type>int[]</type>,
          <optional>, <type>int[]</type></optional>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>返回一个用提供的值和维度初始化好的数组，可以选择下界不为 1</entry>
        <entry><literal>array_fill(7, ARRAY[3], ARRAY[2])</literal></entry>
        <entry><literal>[2:4]={7,7,7}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_length</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>返回被请求的数组维度的长度</entry>
        <entry><literal>array_length(array[1,2,3], 1)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_lower</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>返回被请求的数组维度的下界</entry>
        <entry><literal>array_lower('[0:2]={1,2,3}'::int[], 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       
       <row>
        <entry>
         <literal>
          <function>array_position</function>(<type>anyarray</type>, <type>anyelement</type> <optional>, <type>int</type></optional>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>
        返回数组中第二个参数第一次出现的下标。
        起始于第三个参数或第一个元素指示的元素位置（数组必须是一维的)
        </entry>
        <entry><literal>array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_positions</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>int[]</type></entry>
        <entry>返回作为第一个参数的数组中第二个参数出现的数组下标（数组必须是一维的)</entry>
        <entry><literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal></entry>
        <entry><literal>{1,2,4}</literal></entry>
       </row>
            
       <row>
        <entry>
         <literal>
          <function>array_prepend</function>(<type>anyelement</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>向一个数组的首部追加一个元素</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_remove</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>从数组中移除所有等于给定值的所有元素（数组必须是一维的）</entry>
        <entry><literal>array_remove(ARRAY[1,2,3,2], 2)</literal></entry>
        <entry><literal>{1,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_replace</function>(<type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>将每一个等于给定值的数组元素替换成一个新值</entry>
        <entry><literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal></entry>
        <entry><literal>{1,2,3,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_to_string</function>(<type>anyarray</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>使用提供的定界符和可选的空串连接数组元素</entry>
        <entry><literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal></entry>
        <entry><literal>1,2,3,*,5</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_upper</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>返回被请求的数组维度的上界</entry>
        <entry><literal>array_upper(ARRAY[1,8,3,7], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>cardinality</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>返回数组中元素的总数，如果数组为空则返回 0</entry>
        <entry><literal>cardinality(ARRAY[[1,2],[3,4]])</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>string_to_array</function>(<type>text</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text[]</type></entry>
        <entry>使用提供的定界符和可选的空串将字符串划分成数组元素</entry>
        <entry><literal>string_to_array('xx~^~yy~^~zz', '~^~', 'yy')</literal></entry>
        <entry><literal>{xx,NULL,zz}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>setof anyelement</type></entry>
        <entry>将一个数组扩展成一组行</entry>
        <entry><literal>unnest(ARRAY[1,2])</literal></entry>
        <entry><literallayout class="monospaced">1
2</literallayout>(2 rows)</entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>, <type>anyarray</type> [, ...])
         </literal>
        </entry>
        <entry><type>setof anyelement, anyelement [, ...]</type></entry>
        <entry>把多维数组（可能是不同类型）扩展成一个行的集合。
        这只允许用在 FROM 子句中，见
         <xref linkend="queries-tablefunctions"></entry>
        <entry><literal>unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</literal></entry>
        <entry><literallayout class="monospaced">1    foo
2    bar
NULL baz</literallayout>(3 rows)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
    在<function>array_position</function>和<function>array_positions</>中，
    每个数组元素与使用<literal>IS NOT DISTINCT FROM</literal>语法的搜索值进行比较。
   </para>

   <para>
    在<function>array_position</function>中，如果没有找到该值，则返回<literal>NULL</literal>。
   </para>

   <para>
    在<function>array_positions</function>中，如果数组是<literal>NULL</literal>，则返回<literal>NULL</literal>；
    如果数组中没有找到该值，相反返回空数组。
   </para>
    
   <para>
    在<function>string_to_array</function>中，如果定界符参数为 NULL，输入字符串中的每一个字符将变成结果数组中的一个独立元素。如果定界符是一个空串，则整个输入字符串被作为一个单一元素的数组返回。否则输入字符串会被在每一个出现定界符字符串的位置分裂。
   </para>

   <para>
    在<function>string_to_array</function>中，如果空值串参数被忽略或者为 NULL，输入中的子串不会被替换成 NULL。在<function>array_to_string</function>中，如果空值串参数被忽略或者为 NULL，该数组中的任何空值元素会被简单地跳过并且不会在输出串中被表示。
   </para>

   <note>
    <para>
     <function>string_to_array</>的行为中有两点与<productname>PostgreSQL</> 9.1之前的版本不同。首先，当输入串的长度为零时，它将返回一个空（无元素）数组而不是 NULL。其次，如果定界符串为 NULL，该函数会将输入划分成独立字符，而不是像以前那样返回 NULL。
    </para>
   </note>

   <para>
    也可参见<xref linkend="functions-aggregate">了解用于数组的聚集函数<function>array_agg</function>。
   </para>
  </sect1>

 <sect1 id="functions-range">
  <title>范围函数和操作符</title>

  <para>
   范围类型的概述请见<xref linkend="rangetypes">。
  </para>

  <para>
   <xref linkend="range-operators-table">展示了范围类型可用的操作符。
  </para>

    <table id="range-operators-table">
     <title>范围操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>等于</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>不等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>小于</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>大于</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>小于等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>大于等于</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含范围</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含元素</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>范围被包含</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>元素被包含</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>重叠（有公共点）</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>严格左部</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>严格右部</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>不超过右部</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>不超过左部</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>-|-</literal> </entry>
        <entry>相邻</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry>并</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry>交</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry>差</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

  <para>
   简单比较操作符<literal>&lt;</literal>、
   <literal>&gt;</literal>、<literal>&lt;=</literal>和
   <literal>&gt;=</literal>首先比较下界，并且只有在下界相等时才比较上界。这些比较通常对范围不怎么有用，但是还是提供它们以便能够在范围上构建 B树索引。
  </para>

  <para>
   当涉及一个空范围时，左部/右部/相邻操作符总是返回假；即一个空范围被认为不在任何其他范围前面或者后面。
  </para>

  <para>
   如果结果范围可能需要包含两个分离的子范围，并和差操作符将会失败，因为这样的范围无法被表示。
  </para>

  <para>
   <xref linkend="range-functions-table">显示可用于范围类型的函数。
  </para>

  <indexterm>
    <primary>lower</primary>
  </indexterm>
  <indexterm>
    <primary>upper</primary>
  </indexterm>
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>

    <table id="range-functions-table">
     <title>范围函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>范围的元素类型</entry>
        <entry>范围的下界</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>范围的元素类型</entry>
        <entry>范围的上界</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>范围为空？</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>下界包含在内？</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>上界包含在内？</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>下界无限？</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>上界无限？</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>   
       <row>
        <entry>
         <literal>
          <function>range_merge</function>(<type>anyrange</type>, <type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>anyrange</type></entry>
        <entry>最小范围其中包含两个给定范围</entry>
        <entry><literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal></entry>
        <entry><literal>[1,4)</literal></entry>
       </row>      
      </tbody>
     </tgroup>
    </table>

  <para>
   如果范围为空或者被请求的界是无限的，<function>lower</>和<function>upper</>函数返回空值。函数<function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>和<function>upper_inf</function>对一个空范围全部返回假。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
  <title>聚集函数</title>

  <indexterm zone="functions-aggregate">
   <primary>聚集函数</primary>
   <secondary>内建</secondary>
  </indexterm>

  <para>
   <firstterm>聚集函数</firstterm>从一个输入值的集合计算一个单一结果。内建的普通聚集函数被列在<xref linkend="functions-aggregate-table">和<xref linkend="functions-aggregate-statistics-table">中。内建的顺序集聚集函数被列在<xref linkend="functions-orderedset-table">和
   <xref linkend="functions-hypothetical-table">中。分组操作，这与聚集函数有密切联系，被列在<xref linkend="functions-grouping-table">中。聚集函数的特殊语法考虑在<xref linkend="syntax-aggregates">中解释。更多介绍性信息请参考<xref linkend="tutorial-agg">。
  </para>

  <table id="functions-aggregate-table">
   <title>通用聚集函数</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
        任何非数组类型
      </entry>
      <entry>
       参数类型的数组
      </entry>
      <entry>输入值（包括空）被连接到一个数组</entry>
     </row>

     <row>
      <entry>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       任何数组类型
      </entry>
      <entry>
       和参数数据类型一样
      </entry>
      <entry>级联到更高维数组的输入数组（输入必须都具有相同的维度，不能为空或NULL）</entry>
     </row>
        
     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、<type>numeric</type>或<type>interval</type>
      </entry>
      <entry>
       对于任何整数类型参数是<type>numeric</type>，对于一个浮点参数是<type>double precision</type>，否则和参数数据类型相同
      </entry>
      <entry>所有输入值的平均值（算术平均）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、<type>bigint</type>或<type>bit</type>
      </entry>
      <entry>
        与参数数据类型相同
      </entry>
      <entry>所有非空输入值的按位与，如果没有非空值则结果是空值</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <entry>
        与参数数据类型相同
      </entry>
      <entry>所有非空输入值的按位或，如果没有非空值则结果是空值</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>如果所有输入值为真则结果为真，否则为假</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>至少一个输入值为真时结果为真，否则为假</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
      <entry>输入的行数</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>
       <replaceable class="parameter">expression</replaceable>值非空的输入行的数目
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>等价于<function>bool_and</function></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>将值聚集成一个 JSON 数组</entry>
     </row>
     
     <row>
      <entry>
       <indexterm>
        <primary>jsonb_agg</primary>
       </indexterm>
       <function>jsonb_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>将值聚集成一个JSON数组</entry>
     </row>
     
     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>将名字/值对聚集成一个 JSON 对象</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>jsonb_object_agg</primary>
       </indexterm>
       <function>jsonb_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>将名字/值对聚集成一个JSON对象</entry>
     </row>
     
     
     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>任意数字、字符串，日期/时间，网络，或枚举类型或这些类型数组</entry>
      <entry>与参数数据类型相同</entry>
      <entry>
       所有输入值中<replaceable class="parameter">expression</replaceable>的最大值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>任意数字、字符串，日期/时间，网络，或枚举类型或这些类型数组</entry>
      <entry>与参数数据类型相同</entry>
      <entry>
       所有输入值中<replaceable class="parameter">expression</replaceable>的最小值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
       (<type>text</type>, <type>text</type>) 或 (<type>bytea</type>, <type>bytea</type>)
      </entry>
      <entry>
       与参数数据类型相同
      </entry>
      <entry>输入值连接成一个串，用定界符分隔</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、<type>numeric</type>、
       <type>interval</type>或<type>money</>
      </entry>
      <entry>
       对<type>smallint</type>或<type>int</type>参数是<type>bigint</type>，对<type>bigint</type>参数是<type>numeric</type>，否则和参数数据类型相同
      </entry>
      <entry>所有输入值的<replaceable class="parameter">expression</replaceable>的和</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>连接 XML 值（参见<xref linkend="functions-xml-xmlagg">）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   请注意，除了<function>count</function>以外，这些函数在没有行被选中时返回控制。尤其是<function>sum</function>函数在没有输入行时返回空值，而不是零，并且<function>array_agg</function>在这种情况返回空值而不是一个空数组。必要时可以用<function>coalesce</function>把空值替换成零或一个空数组。
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
      布尔聚集<function>bool_and</function>和<function>bool_or</function>对应于标准的 SQL 聚集<function>every</function>和<function>any</function>或<function>some</function>。而对于<function>any</function> 和<function>some</function>，似乎在标准语法中有一个歧义：
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      如果子查询返回一行有一个布尔值的结果，这里的<function>ANY</function>可以被认为是引入一个子查询，或者是作为一个聚集函数。因而标准的名称不能指定给这些聚集。
    </para>
  </note>

  <note>
   <para>
    在把<function>count</function>聚集应用到整个表上时，习惯于使用其他 SQL 数据管理系统的用户可能会对它的性能感到失望。一个如下的查询：
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    将会要求与整个表大小成比例的工作：<productname>PostgreSQL</productname>将需要扫描整个表或者整个包含表中所有行的索引。
   </para>
  </note>

  <para>
   与相似的用户定义的聚集函数一样，聚集函数<function>array_agg</function>、
   <function>json_agg</function>、<function>jsonb_agg</function>、
   <function>json_object_agg</function>、<function>jsonb_object_agg</function>、<function>string_agg</function>和<function>xmlagg</function>会依赖输入值的顺序产生有意义的不同结果值。这个顺序默认是不用指定的，但是可以在聚集调用时使用<literal>ORDER BY</>子句进行控制，如<xref linkend="syntax-aggregates">中所示。作为一种选择，从一个排序号的子查询来提供输入值通常会有帮助。例如：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   但是在 SQL 标准中不允许这种语法，并且不能被移植到其他数据库系统。
  </para>

  <para>
   <xref linkend="functions-aggregate-statistics-table">展示了通常被用在统计分析中的聚集函数（这些被隔离出来是为了不和常用聚集混淆）。其中描述提到了<replaceable class="parameter">N</replaceable>，它表示对应于所有非空输入表达式的输入行的数目。在所有情况中，如果计算是无意义的，将会返回空值，例如当<replaceable class="parameter">N</replaceable>为零。
  </para>

  <indexterm>
   <primary>统计</primary>
  </indexterm>
  <indexterm>
   <primary>线性回归</primary>
  </indexterm>

  <table id="functions-aggregate-statistics-table">
   <title>用于统计的聚集函数</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>correlation</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>相关系数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>总体协方差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>样本协方差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>自变量的平均值
      （<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>因变量的平均值
      （<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>两个表达式都不为空的输入行的数目</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>回归截矩</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>由（<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>）对决定的最小二乘拟合的线性方程的 y截距</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>相关系数的平方</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>回归斜率</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>由（<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>）对决定的最小二乘拟合的线性方程的斜率</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>（自变量的<quote>平方和</quote>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal>（自变量乘以因变量的<quote>积之合</quote>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>（因变量的<quote>平方和</quote>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry><function>stddev_samp</function>的历史别名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>输入值的总体标准偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>输入值的样本标准偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry><function>var_samp</function>的历史别名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
        <secondary>总体</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>输入值的总体方差（总体标准偏差的平方）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
        <secondary>样本</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>输入值的样本方差（样本标准偏差的平方）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   <xref linkend="functions-orderedset-table">展示了一些使用
   <firstterm>有序集聚集</>语法的聚集函数。这些函数有时也被称为
   <quote>逆分布</>函数。
  </para>

  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>

  <table id="functions-orderedset-table">
   <title>有序集聚集函数</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚集参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>mode</primary>
        <secondary>statistical</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
       任何可排序类型
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>
       返回最频繁的输入值（如果有多个频度相同的值就选第一个）
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>continuous</secondary>
       </indexterm>
       <indexterm>
        <primary>median</primary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>或者<type>interval</type>
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>
       连续百分率：返回一个对应于排序中指定分数的值，如有必要就在相邻的输入项之间插值
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       <type>double precision</type>或者<type>interval</type>
      </entry>
      <entry>
       排序表达式的类型的数组
      </entry>
      <entry>
       多重连续百分率：返回一个匹配<literal>fractions</literal>参数形状的结果数组，
       其中每一个非空元素都用对应于那个百分率的值替换
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>discrete</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       一种可排序类型
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>
       离散百分率：返回第一个在排序中位置等于或者超过指定分数的输入值
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       任何可排序类型
      </entry>
      <entry>
       排序表达式的类型的数组
      </entry>
      <entry>
       多重离散百分率：返回一个匹配<literal>fractions</literal>参数形状的结果数组，
       其中每一个非空元素都用对应于那个百分率的输入值替换
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   所有列在<xref linkend="functions-orderedset-table">中的聚集会忽略它们的已
   排序输入中的空值。对那些有一个<replaceable>fraction</replaceable>参数的聚
   集来说，该分数值必须位于 0 和 1 之间，否则会抛出错误。不过，一个空分数值会
   产生一个空结果。
  </para>

  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>

  <para>
   每个列在<xref linkend="functions-hypothetical-table">中的聚集都与一个定义在
   <xref linkend="functions-window">中的同名窗口函数相关联。在每种情况中，聚集
   结果的计算方法是：假设根据<replaceable>args</replaceable>构建的<quote>假想</>行已
   经被增加到从<replaceable>sorted_args</replaceable>计算得到的已排序行分组中，
   然后用相关联的窗口函数针对该行返回的值就是聚集的结果。
  </para>

  <table id="functions-hypothetical-table">
   <title>假想集聚集函数</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚集参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
       假想行的排名，为重复的行留下间隔
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
       假想行的排名，不留间隔
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       假想行的相对排名，范围从 0 到 1
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       假想行的相对排名，范围从 1/<replaceable>N</> 到 1
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   对于这些假想集聚集的每一个，<replaceable>args</replaceable>中给定的直接参数
   列表必须匹配<replaceable>sorted_args</replaceable>中给定的聚集参数的
   数量和类型。与大部分的内建聚集不同，这些聚集并不严格，即它们不会丢弃包含空值
   的输入行。空值的排序根据<literal>ORDER BY</>子句中指定的规则进行。
  </para>

  <table id="functions-grouping-table">
   <title>分组操作</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>GROUPING</primary>
       </indexterm>
       <function>GROUPING(<replaceable class="parameter">args...</replaceable>)</function>
      </entry>
      <entry> 
       <type>integer</type>
      </entry>
      <entry>整数位掩码表示当前分组集中不包含的参数</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>
    分组操作与分组集合一起（参见<xref linkend="queries-grouping-sets">）区分结果行。
    这个<literal>GROUPING</>操作的参数实际上并没有进行评估，
    但它们必须完全匹配关联查询级别的<literal>GROUP BY</>子句中的表达式。
    Bit连同最右边参数是最不重要的一点；
    如果对应的表达式被包含在分组集生成的结果行的分组条件中，那么每位是0，
    如果不是，则为1。比如：
 
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM items_sold;</>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20 
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
   </para>
  
 </sect1>

 <sect1 id="functions-window">
  <title>窗口函数</title>

  <indexterm zone="functions-window">
   <primary>窗口函数</primary>
   <secondary>内建</secondary>
  </indexterm>

  <para>
   <firstterm>窗口函数</firstterm>提供在与当前查询行相关的行集合上执行计算的能力。有关这个特性的介绍请见<xref linkend="tutorial-window">。
   语法细节则请见<xref linkend="syntax-window-functions">。
  </para>

  <para>
   <xref linkend="functions-window-table">列出了内建的窗口函数。注意<emphasis>必须</>使用窗口函数的语法调用这些函数； 一个<literal>OVER</>子句是必需的。
  </para>

  <para>
   除了这些函数外，任何内建的或用户定义的普通聚集函数（但有序集或假想集聚集除外）都可以作为窗口函数（内建聚集函数的列表见<xref linkend="functions-aggregate">）。仅当调用跟着<literal>OVER</>子句时，聚集函数才会作为窗口函数；否则它们作为常规的聚集。
  </para>

  <table id="functions-window-table">
   <title>通用窗口函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>当前行在其分区中的行号，从1计</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>带间隙的当前行排名； 与该行的第一个同等行的<function>row_number</>相同</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>不带间隙的当前行排名； 这个函数计数同等组</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>当前行的相对排名： (<function>rank</>- 1) / (总行数 - 1)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>当前行的相对排名： (当前行前面的行数 或 与当前行同等的行的行数)/(总行数)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>从1到参数值的整数范围，尽可能等分分区</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
          lag(<replaceable class="parameter">value</replaceable> <type>anyelement</>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</>
             [, <replaceable class="parameter">default</replaceable> <type>anyelement</> ]])
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>的类型相同</type>
      </entry>
      <entry>
       返回<replaceable class="parameter">value</replaceable>，
       它在分区内当前行的之前<replaceable class="parameter">offset</replaceable>个位置的行上计算；如果没有这样的行，返回<replaceable class="parameter">default</replaceable>替代。
       (作为<replaceable class="parameter">value</replaceable>必须是相同类型)。
       <replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>都是根据当前行计算的结果。如果忽略它们，则<replaceable class="parameter">offset</replaceable>默认是1，<replaceable class="parameter">default</replaceable>默认是空值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
          lead(<replaceable class="parameter">value</replaceable> <type>anyelement</>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</>
              [, <replaceable class="parameter">default</replaceable> <type>anyelement</> ]])
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回<replaceable class="parameter">value</replaceable>，它在分区内当前行的之后<replaceable class="parameter">offset</replaceable>个位置的行上计算；如果没有这样的行，返回<replaceable class="parameter">default</replaceable>替代。(作为<replaceable class="parameter">value</replaceable>必须是相同类型)。<replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>都是根据当前行计算的结果。如果忽略它们，则<replaceable class="parameter">offset</replaceable>默认是1，<replaceable class="parameter">default</replaceable>默认是空值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       返回在窗口帧中第一行上计算的<replaceable class="parameter">value</replaceable>
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回在窗口帧中最后一行上计算的<replaceable class="parameter">value</replaceable>
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</>, <replaceable class="parameter">nth</replaceable> <type>integer</>)
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回在窗口帧中第<replaceable class="parameter">nth</replaceable>行（行从1计数）上计算的<replaceable class="parameter">value</replaceable>；没有这样的行则返回空值
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   在<xref linkend="functions-window-table">中列出的所有函数都依赖于相关窗口定义的<literal>ORDER BY</>子句指定的排序顺序。 在<literal>ORDER BY</>排序中不能区分的行被称为是<firstterm>同等行</>。定义的这四个排名函数，对于任何两个同等行的答案相同。
  </para>

  <para>
   注意<function>first_value</>、<function>last_value</>和<function>nth_value</>只考虑<quote>窗口帧</>内的行，它默认情况下包含从分区的开始行直到当前行的最后一个同等行。这对<function>last_value</>可能不会给出有用的结果，有时对<function>nth_value</>也一样。你可以通过向<literal>OVER</>子句增加一个合适的帧声明（<literal>RANGE</>或<literal>ROWS</>）来重定义帧。关于帧声明的更多信息请参考<xref linkend="syntax-window-functions">。
  </para>

  <para>
   当一个聚集函数被用作窗口函数时，它将在当前行的窗口帧内的行上聚集。 一个使用<literal>ORDER BY</>和默认窗口帧定义的聚集产生一种<quote>运行时求和</>类型的行为，这可能是或者不是想要的结果。为了获取在整个分区上的聚集，忽略<literal>ORDER BY</>或者使用<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</>。 其它窗口帧声明可以用来获得其它的效果。
  </para>

  <note>
   <para>
    SQL 标准为<function>lead</>、<function>lag</>、<function>first_value</>、<function>last_value</>和<function>nth_value</>定义了 一个<literal>RESPECT NULLS</>或<literal>IGNORE NULLS</>选项。 这在<productname>PostgreSQL</productname>中没有实现：行为总是与标准的默认相同，即<literal>RESPECT NULLS</>。 同样，标准中用于<function>nth_value</>的<literal>FROM FIRST</>或<literal>FROM LAST</>选项没有实现： 只有支持默认的<literal>FROM FIRST</>行为（你可以通过反转<literal>ORDER BY</>的排序达到<literal>FROM LAST</>的结果）。
   </para>
  </note>

 </sect1>

 <sect1 id="functions-subquery">
  <title>子查询表达式</title>

  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>subquery</primary>
  </indexterm>

  <para>
   本节描述<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的子查询表达式。所有本节中成文的表达式都返回布尔值（真/假）结果。
  </para>

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   <token>EXISTS</token>的参数是一个任意的<command>SELECT</>语句， 或者说<firstterm>子查询</firstterm>。系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么<token>EXISTS</token>的结果就为<quote>真</>； 如果子查询没有返回行，那么<token>EXISTS</token>的结果是<quote>假</>。
  </para>

  <para>
   子查询可以引用来自周围的查询的变量，这些变量在该子查询的任何一次计算中都起常量的作用。
  </para>

  <para>
   这个子查询通常只是运行到能判断它是否可以返回至少一行为止， 而不是等到全部结束。在这里写任何有副作用的子查询都是不明智的（例如调用序列函数）；这些副作用是否发生是很难判断的。
  </para>

  <para>
   因为结果只取决于是否会返回行，而不取决于这些行的内容， 所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用<literal>EXISTS(SELECT 1 WHERE ...)</literal>的形式写所有的<literal>EXISTS</>测试。不过这条规则有例外，例如那些使用<token>INTERSECT</token>的子查询。
  </para>

  <para>
   下面这个简单的例子类似在<literal>col2</>上的一次内联接，但是它为每个 <literal>tab1</>的行生成最多一个输出，即使存在多个匹配<literal>tab2</>的行也如此∶
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   右手边是一个圆括弧括起来的子查询， 它必须正好只返回一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果找到任何等于子查询行的情况，那么<token>IN</token>的结果就是<quote>真</>。 如果没有找到相等行，那么结果是<quote>假</>（包括子查询没有返回任何行的情况）。
  </para>

  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>IN</token>结构的结果将是空值，而不是假。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   这种形式的<token>IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors">中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到任意相等的子查询行，则<token>IN</token>的结果为<quote>true</>。如果没有找到相等行， 那么结果为<quote>假</>（包括子查询不返回行的情况）。
  </para>

  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   右手边是一个用圆括弧包围的子查询，它必须返回正好一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果只找到不相等的子查询行（包括子查询不返回行的情况），那么<token>NOT IN</token>的结果是<quote>真</>。 如果找到任何相等行，则结果为<quote>假</>。
  </para>

  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>NOT IN</token>结构的结果将是空值，而不是真。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

  <para>
   和<token>EXISTS</token>一样，假设子查询会完全结束是不明智的。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   这种形式的<token>NOT IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors">中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到不等于子查询行的行，则<token>NOT IN</token>的结果为<quote>true</>。如果找到相等行， 那么结果为<quote>假</>（包括子查询不返回行的情况）。
  </para>

  <para>
  通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>NOT IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   这种形式的右手边是一个圆括弧括起来的子查询， 它必须返回正好一个列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果获得任何真值结果，那么<token>ANY</token>的结果就是<quote>真</>。 如果没有找到真值结果，那么结果是<quote>假</>（包括子查询没有返回任何行的情况）。
  </para>

  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。<token>IN</token>等价于<literal>= ANY</literal>。
  </para>

  <para>
   请注意如果没有任何成功并且至少有一个右手边行为该操作符结果生成空值， 那么<token>ANY</token>结构的结果将是空值，而不是假。 这个行为是遵照 SQL 处理空值布尔组合的一般规则制定的。
  </para>

  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors">所述。右手边是一个圆括弧括起来的子查询， 它必须返回和左手边列表给出的表达式一样多的列。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果比较为任何子查询行返回真，则<token>ANY</token>的结果为<quote>真</>。如果比较对每一个子查询行都返回假，则结果为<quote>假</>（包括子查询不返回行的情况）。如果比较不对任何行返回真并且至少对一行返回 NULL，则结果为 NULL。
  </para>

  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison">。
  </para>
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   ALL 的这种形式的右手边是一个圆括弧括起来的子查询， 它必须只返回一列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。该操作符必须生成布尔结果。 如果所有行得到真（包括子查询没有返回任何行的情况），<token>ALL</token>的结果就是<quote>真</>。如果没有存在任何假值结果，那么结果是<quote>假</>。如果比较为任何行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

  <para>
   <token>NOT IN</token>等价于<literal>&lt;&gt; ALL</literal>。
  </para>

  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   <token>ALL</token>的这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors">所述。 右手边是一个圆括弧括起来的子查询，它必须返回和左手边行中表达式一样多的列。 左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果对所有子查询行该比较都返回真，那么<token>ALL</token>的结果就是<quote>真</>（包括子查询没有返回任何行的情况）。如果对任何子查询行比较返回假，则结果为<quote>假</>。如果比较对任何子查询行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison">。
  </para>
  </sect2>

  <sect2>
   <title>单一行比较</title>

   <indexterm zone="functions-subquery">
    <primary>比较</primary>
    <secondary>子查询结果行</secondary>
   </indexterm>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
   左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors">所述。 右手边是一个圆括弧括起来的子查询，该查询必须返回和左手边行中表达式数目完全一样的列。 另外，该子查询不能返回超过一行的数量（如果它返回零行，那么结果就是空值）。 左手边被计算并逐行与右手边的子查询结果行比较。
  </para>

  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison">。
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
  <title>行和数组比较</title>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>
  
  <indexterm>
   <primary>组合类型</primary>
   <secondary>比较</secondary>
  </indexterm>

  <indexterm>
   <primary>逐行比较</primary>
  </indexterm>

  <indexterm>
   <primary>比较</primary>
   <secondary>逐行</secondary>
  </indexterm>
  
  <indexterm>
   <primary>比较</primary>
   <secondary>行构造器</secondary>
  </indexterm>

  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

  <para>
   本节描述几个特殊的结构，用于在值的组之间进行多重比较。这些形式语法上和前面一节的子查询形式相关，但是不涉及子查询。 这种形式涉及的数组子表达式是<productname>PostgreSQL</productname>的扩展； 其它的是<acronym>SQL</acronym>兼容的。所有本节记录的表达式形式都返回布尔（Boolean）结果（真/假）。
  </para>

  <sect2>
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果等于任何右手边表达式中的一个，结果为<quote>真</>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>

  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>IN</token>结构的结果将为空值，而不是假。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果不等于所有右手边表达式，结果为<quote>真</quote>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>

  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>NOT IN</token>结构的结果将为空值， 而不是我们可能天真地认为的真值。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>

  <tip>
  <para>
   <literal>x NOT IN y</literal>在所有情况下都等效于<literal>NOT (x IN y)</literal>。但是，在处理空值的时候，用<token>NOT IN</token>比用<token>IN</token>更可能迷惑新手。最好尽可能用正逻辑来表达你的条件。
  </para>
  </tip>
  </sect2>

  <sect2>
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式被计算并且使用给出的<replaceable>操作符</replaceable>对数组的每个元素进行比较，这个操作符必须得到布尔结果。如果得到了任何真值结果，那么<token>ANY</token>的结果是<quote>真</>。 如果没有找到真值结果（包括数组只有零个元素的情况），那么结果是<quote>假</>。
  </para>

  <para>
   如果数组表达式得到一个空数组，<token>ANY</token>的结果将为空值。如果左手边的表达式得到空值，<token>ANY</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到真值比较结果，<token>ANY</token>的结果将是空值而不是假（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>

  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。
  </para>
  </sect2>

  <sect2>
   <title><literal>ALL</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>与数组的每个元素进行比较，这个操作符必须得到一个布尔结果。如果所有比较都得到真值结果，那么<token>ALL</token>的结果是 <quote>真</>（包括数组只有零个元素的情况）。如果有任何假值结果，那么结果是<quote>假</>。
  </para>

  <para>
  如果数组表达式得到一个空数组，<token>ALL</token>的结果将为空值。如果左手边的表达式得到空值，<token>ALL</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到假值比较结果，<token>ALL</token>的结果将是空值而不是真（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2 id="row-wise-comparison">
   <title>行构造器比较</title>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
   每一边都是一个行构造器，如<xref linkend="sql-syntax-row-constructors">所述。两个行值必须具有相同数量的域。每一边被计算并且被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</>、
   <literal>&lt;&gt;</>、
   <literal>&lt;</>
   <literal>&lt;=</>、
   <literal>&gt;</>、
   <literal>&gt;=</>时，允许进行行构造器比较。每一个行元素必须是具有一个默认 B 树操作符类的类型，否则尝试比较会产生一个错误。
  </para>
  
  <note>
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para>
  </note>

  <para>
   <literal>=</>和<literal>&lt;&gt;</>情况略有不同。如果两行的所有对应成员都是非空且相等则这两行被认为相等；如果任何对应成员是非空但是不相等则这两行不相等；否则行比较的结果为未知（空值）。
  </para>

  <para>
   对于<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>和<literal>&gt;=</>情况，行元素被从左至右比较，在找到一处不等的或为空的元素对就立刻停下来。如果这一对元素都为空值，则行比较的结果为未知（空值）；否则这一对元素的比较结果决定行比较的结果。例如，<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</>得到真，而不是空值，因为第三对元素并没有被考虑。
  </para>

  <note>
   <para>
    在<productname>PostgreSQL</productname> 8.2之前，<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>和<literal>&gt;=</>情况不是按照每个 SQL 声明来处理的。一个像<literal>ROW(a,b) &lt; ROW(c,d)</>的比较会被实现为<literal>a &lt; c AND b &lt; d</>，而结果行为等价于<literal>a &lt; c OR (a = c AND b &lt; d)</>。
   </para>
  </note>

<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
   这个结构与<literal>&lt;&gt;</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
   这个结构与<literal>=</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>
  
  </sect2>

  <sect2 id="composite-type-comparison">
   <title>组合类型比较</title>

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

   <para>
    SQL 规范要求在结果依赖于比较两个 NULL 值或者一个 NULL 与一个非 NULL 时逐行比较返回 NULL。<productname>PostgreSQL</productname>只有在比较两个行构造器（如<xref linkend="row-wise-comparison">）的结果或者比较一个行构造器与一个子查询的输出时才这样做（如<xref linkend="functions-subquery">中所述）。在其他比较两个组合类型值的环境中，两个 NULL 域值被认为相等，并且一个 NULL 被认为大于一个非 NULL。为了得到组合类型的一致的排序和索引行为，这样做是必要的。
   </para>
   
   <para>
   每一边都会被计算并且它们会被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</>、
   <literal>&lt;&gt;</>、
   <literal>&lt;</>、
   <literal>&lt;=</>、
   <literal>&gt;</>或者
   <literal>&gt;=</>时或者具有与这些类似的语义时，允许组合类型的比较（更准确地说，如果一个操作符是一个 B 树操作符类的成员，或者是一个 B 树操作符类的<literal>=</>成员的否定词，它就可以是一个行比较操作符）。
   上述操作符的行为与用于行构造器（见<xref linkend="row-wise-comparison">）的<literal>IS [ NOT ] DISTINCT FROM</literal>相同。
  </para>

  <para>
   为了支持包含无默认 B 树操作符类的元素的行匹配，为组合类型比较定义了下列操作符：
   <literal>*=</>,
   <literal>*&lt;&gt;</>,
   <literal>*&lt;</>,
   <literal>*&lt;=</>,
   <literal>*&gt;</>, and
   <literal>*&gt;=</>.
   这些操作符比较两行的内部二进制表达。即使两行用相等操作符的比较为真，两行也可能
   具有不同的二进制表达。行在这些比较操作符之下的排序是决定性的，其他倒没什么意义。
   这些操作符在内部被用于物化视图并且可能对其他如复制之类的特殊功能有用，但是它们
   并不打算用在书写查询这类普通用途中。
  </para>

  </sect2>
 </sect1>

 <sect1 id="functions-srf">
  <title>集合返回函数</title>

  <indexterm zone="functions-srf">
   <primary>集合返回函数</primary>
   <secondary>函数</secondary>
  </indexterm>

  <indexterm>
   <primary>generate_series</primary>
  </indexterm>

  <para>
   本节描述那些可能返回多于一行的函数。目前这个类中被使用最广泛的是级数生成函数， 如<xref linkend="functions-srf-series">和<xref linkend="functions-srf-subscripts">所述。其他更特殊的集合返回函数在本手册的其他地方描述。
   组合多集合返回函数的方法可见<xref linkend="queries-tablefunctions">。
  </para>

  <table id="functions-srf-series">
   <title>级数生成函数</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
      <entry><type>int</type>，<type>bigint</type>或者<type>numeric</type></entry>
      <entry><type>setof int</type>，<type>setof bigint</type>或者<type>setof numeric</type> (与参数类型相同)</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为 1
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
      <entry><type>int</type>，<type>bigint</type>或者<type>numeric</type></entry>
      <entry><type>setof int</type>，<type>setof bigint</type>或者<type>setof numeric</type> (与参数类型相同)</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</>)</function></literal></entry>
      <entry><type>timestamp</type>或<type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type>或<type>setof timestamp with time zone</type>（和参数类型相同）</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   当<parameter>step</parameter>为正时，如果<parameter>start</parameter>大于<parameter>stop</parameter>则返回零行。相反，当<parameter>step</parameter>为负时，如果<parameter>start</parameter>小于<parameter>stop</parameter>则返回零行。对于<literal>NULL</literal>输入也会返回零行。<parameter>step</parameter>为零是一个错误。下面是一些例子：
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series 
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- 这个例子依赖于日期+整数操作符
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>

  <table id="functions-srf-subscripts">
   <title>下标生成函数</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       生成一个级数组成给定数组的下标。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       生成一个级数组成给定数组的下标。当<parameter>reverse</parameter>为真，级数以逆序返回。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>

  <para>
   <function>generate_subscripts</>是一个快捷函数，它为给定数组的指定维度生成一组合法的下标。对于不具有请求维度的数组返回零行，对于 NULL 数组也返回零行（但是会对 NULL 数组元素返回合法的下标）。下面是一些例子：
<programlisting>
-- 基本使用
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

-- 表示一个数组，下标和被下标的值需要一个子查询
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- 平面化一个 2D 数组
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
  
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>

  <para>
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the output which starts from 1 and increments by 1 for each row
   of the function's output.  This is most useful in the case of set returning
   functions such as <function>unnest()</>.

<programlisting>
-- set returning function WITH ORDINALITY
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_clog         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_xlog         | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>

 </sect1>

 <sect1 id="functions-info">
  <title>系统信息函数</title>

  <para>
   <xref linkend="functions-info-session-table">展示了多个可以抽取会话和系统信息的函数。
  </para>

  <para>
   除了本节列出的函数，还有一些与统计系统相关的函数也提供系统信息。详见<xref linkend="monitoring-stats-views">。
  </para>

   <table id="functions-info-session-table">
    <title>会话信息函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前数据库名（SQL 标准中称作<quote>目录</quote>）</entry>
      </row>

      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前数据库名</entry>
      </row>

      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>当前正在执行的查询的文本，和客户端提交的一样（可能包含多于一个语句）</entry>
      </row>

      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
       <entry>当前模式名</entry>
      </row>

      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
       <entry>搜索路径中的模式名，可以选择是否包含隐式模式</entry>
      </row>

      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前执行上下文的用户名</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>远程连接的地址</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>远程连接的端口</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>本地连接的地址</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>本地连接的端口</entry>
      </row>

      <row>
       <!-- See also the entry for this in monitoring.sgml -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
        与当前会话关联的服务器进程的进程 ID
       </entry>
      </row>

      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>配置载入时间</entry>
      </row>

      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>模式是另一个会话的临时模式吗？</entry>
      </row>

      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
       <entry>会话当前正在监听的频道名称</entry>
      </row>

      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
       <entry>会话的临时模式的 OID，如果没有则为 0</entry>
      </row>

      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>服务器启动时间</entry>
      </row>

      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry><productname>PostgreSQL</>触发器的当前嵌套层次（如果没有调用则为 0，直接或间接，从一个触发器内部开始）</entry>
      </row>

      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>会话用户名</entry>
      </row>

      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>等价于<function>current_user</function></entry>
      </row>

      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry><productname>PostgreSQL</>版本信息。参阅<xref linkend="guc-server-version-num">获取机器可读版本。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     <function>current_catalog</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>和<function>user</function>在<acronym>SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号（在 PostgreSQL 中，圆括号可以有选择性地被用于<function>current_schema</function>，但是不能和其他的一起用）。
    </para>
   </note>

   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>

   <indexterm>
    <primary>current_database</primary>
   </indexterm>

   <indexterm>
    <primary>current_query</primary>
   </indexterm>

   <indexterm>
    <primary>current_schema</primary>
   </indexterm>

   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>

   <indexterm>
    <primary>current_user</primary>
   </indexterm>

   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>

   <indexterm>
    <primary>模式</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <primary>搜索路径</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <primary>session_user</primary>
   </indexterm>

   <indexterm>
    <primary>用户</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <primary>用户</primary>
   </indexterm>

   <para>
    <function>session_user</function>通常是发起当前数据库连接的用户，不过超级用户可以用<xref linkend="sql-set-session-authorization">修改这个设置。<function>current_user</function>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<xref linkend="sql-set-role">改变。它也会在函数执行的过程中随着属性<literal>SECURITY DEFINER</literal>的改变而改变。在 Unix 的说法里，那么会话用户是<quote>真实用户</quote>，而当前用户是<quote>有效用户</quote>。
   </para>

   <para>
    <function>current_schema</function>返回在搜索路径中的第一个模式名（如果搜索路径是空则返回空值）。 如果创建表或者其它命名对象时没有声明目标模式，那么它将是被用于这些对象的模式。<function>current_schemas(boolean)</function>返回一个在搜索路径中出现的所有模式名的数组。布尔选项决定<literal>pg_catalog</>这样的隐式包含的系统模式是否包含在返回的搜索路径中。
   </para>

   <note>
    <para>
     搜索路径可以在运行时修改。命令是：
<programlisting>
SET search_path TO <replaceable>schema</> <optional>, <replaceable>schema</>, ...</optional>
</programlisting>
    </para>
   </note>

   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>

   <para>
    <function>pg_listening_channels</function>返回一组当前会话正在监听的频道名称。详见<xref linkend="sql-listen">。
   </para>

   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>

   <para>
     <function>inet_client_addr</function>返回当前客户端的 IP 地址，<function>inet_client_port</function>返回它的端口号。 <function>inet_server_addr</function>返回接受当前连接的服务器的 IP 地址，而<function>inet_server_port</function>返回对应的端口号。如果连接是通过 Unix 域套接字进行的，那么所有这些函数都返回 NULL。
   </para>

   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>

   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>

   <para>
    <function>pg_my_temp_schema</function>返回当前会话临时模式的 OID，如果没有使用临时模式（因为它没有创建任何临时表）则返回零。如果给定的 OID 是另一个会话的临时模式的 OID，则<function>pg_is_other_temp_schema</function>返回真（这是有用的，例如，要将其他会话的临时表从一个目录显示中排除）。
   </para>

   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>

   <para>
    <function>pg_postmaster_start_time</function>返回服务器启动时的<type>timestamp with time zone</type>。
   </para>

   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>

   <para>
    <function>pg_conf_load_time</function>返回最近一次服务器配置文件被载入的<type>timestamp with time zone</type>（如果当前会话在那时是活动的，这将是该会话重读配置文件的时间，因此读取的时间在不同会话中会变化。否则它将是 postmaster 进程重读配置文件的时间）。
   </para>

   <indexterm>
    <primary>version</primary>
   </indexterm>

   <para>
    <function>version</function>返回一个描述
    <productname>PostgreSQL</productname>服务器版本的字符串。
    你也可以从<xref linkend="guc-server-version">获取机器
    可读版本<xref linkend="guc-server-version-num">信息，
    软件开发者应该使用<literal>server_version_num</literal>
    (8.2可用)或者<xref linkend="libpq-pqserverversion">解析文本版本。
   </para>

  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>

  <para>
   <xref linkend="functions-info-access-table">列出那些允许用户编程查询对象访问权限的函数。参阅<xref linkend="ddl-priv">获取更多有关权限的信息。
  </para>

   <table id="functions-info-access-table">
    <title>访问权限查询函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表中任意列上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表中任意列上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有数据库的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有数据库的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有外部数据包装器上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有外部数据包装器上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有函数上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有函数上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有语言上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有语言上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有模式上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有模式上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有序列上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有序列上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有外部服务器上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有外部服务器上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表空间上的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表空间上的权限</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有角色上的权限</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有角色上的权限</entry>
      </row>
      
      <row>
       <entry><literal><function>row_security_active</function>(<parameter>table</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表上的行级安全性</entry>
      </row>
      
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>
   <indexterm>
    <primary>row_security_active</primary>
   </indexterm>
   
   
   <para>
    <function>has_table_privilege</function>判断一个用户是否可以用某种特定的方式访问一个表。 该用户可以通过名字或者 OID （<literal>pg_authid.oid</literal>） 来指定，也可以用<literal>public</>表示 PUBLIC 伪角色。如果省略该参数，则使用<function>current_user</function>。 该表可以通过名字或者 OID 指定（因此，实际上有六种 <function>has_table_privilege</function>的变体，我们可以通过它们的参数数目和类型来区分它们） 。如果用名字指定，那么在必要时该名字可以是模式限定的。 所希望的权限类型是用一个文本串来指定的，它必须是下面的几个值之一： <literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</>、<literal>REFERENCES</literal>或<literal>TRIGGER</literal>。<literal>WITH GRANT OPTION</>可以被选择增加到一个权限类型来测试是否该权限是使用转授选项得到。另外，可以使用逗号分隔来列出多个权限类型，在这种情况下只要具有其中之一的权限则结果为<literal>真</>（权限字符串的大小写并不重要，可以在权限名称之间出现额外的空白，但是在权限名内部不能有空白）。一些例子：
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>

   <para>
    <function>has_sequence_privilege</function>检查一个用户是否能以某种特定方式访问一个序列。它的参数可能性和<function>has_table_privilege</function>相似。所希望测试的访问权限类型必须是下列之一：<literal>USAGE</literal>、<literal>SELECT</literal>或<literal>UPDATE</literal>。
   </para>

   <para>
    <function>has_any_column_privilege</function>检查一个用户是否能以特定方式访问一个表的任意列。其参数可能性和<function>has_table_privilege</>类似，除了所希望的访问权限类型必须是下面值的某种组合：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>或<literal>REFERENCES</literal>。注意在表层面上具有这些权限的任意一个都会隐式地把它授权给表中的每一列，因此如果<function>has_table_privilege</>对同样的参数返回真则<function>has_any_column_privilege</function>将总是返回<literal>真</>。但是如果在至少一列上有一个该权限的列级授权，<function>has_any_column_privilege</>也会成功。
   </para>

   <para>
    <function>has_column_privilege</function>检查一个用户是否能以特定方式访问一个列。它的参数可能性与<function>has_table_privilege</function>类似，并且列还可以使用名字或者属性号来指定。希望的访问权限类型必须是下列值的某种组合：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>或<literal>REFERENCES</literal>。注意在表级别上具有这些权限中的任意一种将会隐式地把它授予给表上的每一列。
   </para>

   <para>
    <function>has_database_privilege</function>检查一个用户是否能以特定方式访问一个数据库。它的参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是以下值的某种组合：<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>或<literal>TEMP</literal>（等价于<literal>TEMPORARY</literal>）。
   </para>

   <para>
    <function>has_function_privilege</function>检查一个用户是否能以特定方式访问一个函数。其参数可能性类似<function>has_table_privilege</function>。在用一个文本串而不是 OID 指定一个函数时，允许的输入和<type>regprocedure</>数据类型一样（参阅 <xref linkend="datatype-oid">）。希望的访问权限类型必须是<literal>EXECUTE</literal>。一个例子：
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>

   <para>
    <function>has_foreign_data_wrapper_privilege</function>检查一个用户是否能以特定方式访问一个外部数据包装器。它的参数可能性类似于<function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

   <para>
    <function>has_language_privilege</function>检查一个用户是否可以以某种特定的方式访问一个过程语言。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

   <para>
    <function>has_schema_privilege</function>检查一个用户是否可以以某种特定的方式访问一个模式。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>CREATE</literal>或<literal>USAGE</literal>。
   </para>

   <para>
    <function>has_server_privilege</function>检查一个用户是否可以以某种特定的方式访问一个外部服务器。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

   <para>
    <function>has_tablespace_privilege</function>检查一个用户是否可以以某种特定的方式访问一个表空间。其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>CREATE</literal>。
   </para>

   <para>
    <function>pg_has_role</function>检查一个用户是否可以以某种特定的方式访问一个角色。其参数可能性类似 <function>has_table_privilege</function>，除了<literal>public</>不能被允许作为一个用户名。希望的访问权限类型必须是下列值的某种组合：<literal>MEMBER</literal>或<literal>USAGE</literal>。<literal>MEMBER</literal>表示该角色中的直接或间接成员关系（即使用<command>SET ROLE</>的权力），而<literal>USAGE</literal>表示不做<command>SET ROLE</>的情况下该角色的权限是否立即可用。
   </para>

   <para>
    <function>row_security_active</function>检查行级安全是否对
    <function>current_user</function>以及环境上下文中的指定表是活跃的。
    通过名称或者OID指定表。    
   </para>
   
  <para>
   <xref linkend="functions-info-schema-table">展示了决定是否一个特定对象在当前模式搜索路径中<firstterm>可见</>的函数。例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。这等价于在语句中表可以被用名称引用但不加显式的模式限定。要列出所有可见表的名字：
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>

   <indexterm>
    <primary>搜索路径</primary>
    <secondary>对象可见性</secondary>
   </indexterm>

   <table id="functions-info-schema-table">
    <title>模式可见性查询函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>排序规则在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>转换在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>函数在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符类在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符族在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>表在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索配置在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索字典在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索解析器在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索模板在搜索路径中可见吗？</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>类型（或域）在搜索路径中可见吗？</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>

   <para>
    每一个函数对一种数据库对象执行可见性检查。
    注意<function>pg_table_is_visible</function>也可被用于视图、索引和序列以及外表，
    <function>pg_type_is_visible</function>也可以被用于域。对于函数和操作符，
    如果在路径中更早的地方没有出现具有相同名称<emphasis>和参数数据类型</>的对象，
    该对象在搜索路径中是可见的。对于操作符类，名称和相关的索引访问方法都要考虑。
   </para>

   <para>
    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<type>regclass</>、<type>regtype</>、<type>regprocedure</>、<type>regoperator</>、<type>regconfig</>或<type>regdictionary</>）将会很方便。例如：
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    注意以这种方式测试一个非模式限定的类型名没什么意义 &mdash; 如果该名称完全能被识别，它必须是可见的。
   </para>

   <indexterm>
    <primary>format_type</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>

   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>

   <indexterm>
    <primary>collation for</primary>
   </indexterm>

   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>

   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>

   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>

   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>

   <indexterm>
    <primary>to_regnamespace</primary>
   </indexterm>

   <indexterm>
    <primary>to_regrole</primary>
   </indexterm>
   
  <para>
   <xref linkend="functions-info-catalog-table">列出了从系统目录抽取信息的函数。
  </para>

   <table id="functions-info-catalog-table">
    <title>系统目录信息函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个数据类型的 SQL 名字</entry>
      </row>
      
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个约束的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个约束的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个函数的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个函数定义的参数列表（带有默认值）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得标识一个函数的参数列表（不带默认值）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得函数的<literal>RETURNS</>子句</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得索引的<command>CREATE INDEX</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得索引的<command>CREATE INDEX</>命令，或者当<parameter>column_no</>为非零时只得到一个索引列的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>获得 SQL 关键字的列表及其分类</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得规则的<command>CREATE RULE</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得规则的<command>CREATE RULE</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个<type>serial</type>、<type>smallserial</type>或<type>bigserial</type>列使用的序列的名称</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>获得触发器的<command>CREATE [ CONSTRAINT ] TRIGGER</>命令</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</>)</entry>
       <entry><type>text</type></entry>
       <entry>获得触发器的<command>CREATE [ CONSTRAINT ] TRIGGER</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>获得给定 OID 指定的角色名</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令（<emphasis>已废弃</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令（<emphasis>已废弃</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令；带域的行被包装成指定的列数，并隐含了优质打印</entry>
      </row>
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>获得存储选项的名称/值对的集合</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
       <entry>获得在该表空间中有对象的数据库的 OID 的集合</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得这个表空间所在的文件系统的路径</entry>
      </row>
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>获得任意值的数据类型</entry>
      </row>
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得该参数的排序规则</entry>
      </row>
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
       <entry>获得命名关系的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
       <entry>获得命名函数的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
       <entry>获得命名函数的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
       <entry>获得命名操作符的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
       <entry>获得命名操作符的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>获得命名类型的OID</entry>
      </row>
      
      <row>
       <entry><literal><function>to_regnamespace(<parameter>schema_name</parameter>)</function></literal></entry>
       <entry><type>regnamespace</type></entry>
       <entry>获得命名模式的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regrole(<parameter>role_name</parameter>)</function></literal></entry>
       <entry><type>regrole</type></entry>
       <entry>获得命名角色的OID</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <function>format_type</function>返回一个数据类型的 SQL 名称，它由它的类型 OID 标识并且可能是一个类型修饰符。如果不知道相关的修饰符，则为类型修饰符传递 NULL。
  </para>

  <para>
   <function>pg_get_keywords</function>返回一组记录描述服务器识别的 SQL 关键字。<structfield>word</>列包含关键字。<structfield>catcode</>列包含一个分类码：<literal>U</>为未被预定，<literal>C</> 为列名，<literal>T</>类型或函数名，<literal>R</>为预留。<structfield>catdesc</>列包含一个可能本地化的描述分类的字符串。
  </para>

  <para>
   <function>pg_get_constraintdef</function>、<function>pg_get_indexdef</function>、<function>pg_get_ruledef</function>和<function>pg_get_triggerdef</function>分别重建一个约束、索引、规则或触发器的创建命令（注意这是一个反编译的重构，而不是命令的原始文本）。<function>pg_get_expr</function>反编译一个表达式的内部形式，例如一个列的默认值。在检查系统目录内容时有用。如果表达式可能包含 Var，在第二个参数中指定它们引用的关系的 OID；如果不会出现 Var，第二个参数设置为 0 即可。<function>pg_get_viewdef</function>重构定义一个视图的<command>SELECT</>查询。这些函数的大部分都有两种变体，一种可以可选地<quote>优质打印</>结果。优质打印的格式可读性更强，但是默认格式更可能被未来版本的<productname>PostgreSQL</>以相同的方式解释。在转出目的中避免使用优质打印输出。为优质打印参数传递<literal>假</>将得到和不带该参数的变体相同的结果。
  </para>

  <para>
   <function>pg_get_functiondef</>为一个函数返回一个完整的<command>CREATE OR REPLACE FUNCTION</>语句。<function>pg_get_function_arguments</function>返回一个函数的参数列表，形式按照它们出现在<command>CREATE FUNCTION</>中的那样。<function>pg_get_function_result</function>类似地返回函数的合适的<literal>RETURNS</>子句。<function>pg_get_function_identity_arguments</function>返回标识一个函数必要的参数列表，形式和它们出现在<command>ALTER FUNCTION</>中的一样。这种形式忽略默认值。
  </para>

  <para>
   <function>pg_get_serial_sequence</function>返回与一个列相关联的序列的名称，如果与列相关联的序列则返回 NULL。第一个输入参数是一个带可选模式的表名，第二个参数是一个列名。因为第一个参数可能是一个模式和表，它不能按照一个双引号包围的标识符来对待，意味着它默认情况下是小写的。而第二个参数只是一个列名，将被当作一个双引号包围的来处理并且会保留其大小写。函数返回的值会被适当地格式化以便传递给序列函数（参见<xref linkend="functions-sequence">）。这种关联可以使用<command>ALTER SEQUENCE OWNED BY</>来改变或移除（该函数应该曾经被称作<function>pg_get_owned_sequence</function>，它目前的名字反映了它通常和<type>serial</>或<type>bigserial</>列一起使用）。
  </para>

  <para>
   <function>pg_get_userbyid</function>抽取给定 OID 的角色的名称。
  </para>

  <para>
   当传入<structname>pg_class</>.<structfield>reloptions</>或<structname>pg_attribute</>.<structfield>attoptions</>时，<function>pg_options_to_table</function>返回存储选项名称/值对（<literal>option_name</>/<literal>option_value</>）的集合。
  </para>

  <para>
   <function>pg_tablespace_databases</function>允许一个表空间被检查。它返回一组数据库的 OID，这些数据库都有对象存储在该表空间中。如果这个函数返回任何行，则该表空间为非空并且不能被删除。为了显示该表空间中的指定对象，你将需要连接到<function>pg_tablespace_databases</function>标识的数据库并且查询它们的<structname>pg_class</>目录。
  </para>


  <para>
   <function>pg_typeof</function>返回传递给它的值的数据类型的 OID。这在检修或者动态构建 SQL 查询时有用。函数被声明为返回<type>regtype</>，它是一个 OID 别名类型（见<xref linkend="datatype-oid">）；这表明它和一个用于比较目的的 OID 相同，但是作为一个类型名称显示。例如：
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row) 

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</programlisting>
  </para>

  <para>
   表达式<literal>collation for</literal>返回传递给它的值的排序规则。例子：
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</programlisting>
  值可能被加上引号并且变成模式限定的。如果从参数表达式得不到排序规则，则返回一个空值。如果参数不是一个可排序的数据类型，则抛出一个错误。
  </para>
  
  <para>
   <function>to_regclass</function>，<function>to_regproc</function>，
   <function>to_regprocedure</function>，<function>to_regoper</function>，
   <function>to_regoperator</function>，<function>to_regtype</function>，
   <function>to_regnamespace</function>以及<function>to_regrole</function>
   函数各自转换关系，函数，操作符，类型，模式以及角色名称为
   <type>regclass</>，<type>regproc</>，<type>regprocedure</type>，
   <type>regoper</>，<type>regoperator</type>，<type>regtype</>，
   <type>regnamespace</>以及<type>regrole</>类型对象。
   这些函数不同于来自不接受数字OID的文本映射，并返回空而不是抛出一个错误。
   如果没有找到名称（或<function>to_regproc</function>和<function>to_regoper</function>，
   如果给定的名称匹配多个对象）。
  </para>

  <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object_as_address</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_object_address</primary>
   </indexterm>

  <para>
   <xref linkend="functions-info-object-table">列出与数据库对象标识和寻址有关的函数。
  </para>

   <table id="functions-info-object-table">
    <title>对象信息和地址函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_describe_object(<parameter>catalog_id</parameter>, <parameter>object_id</parameter>, <parameter>object_sub_id</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获取数据库对象的描述</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object(<parameter>catalog_id</parameter> <type>oid</>, <parameter>object_id</parameter> <type>oid</>, <parameter>object_sub_id</parameter> <type>integer</>)</function></literal></entry>
       <entry><parameter>type</> <type>text</>, <parameter>schema</> <type>text</>, <parameter>name</> <type>text</>, <parameter>identity</> <type>text</></entry>
       <entry>获取数据库对象标识</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object_as_address(<parameter>catalog_id</parameter> <type>oid</>, <parameter>object_id</parameter> <type>oid</>, <parameter>object_sub_id</parameter> <type>integer</>)</function></literal></entry>
       <entry><parameter>type</> <type>text</>, <parameter>name</> <type>text[]</>, <parameter>args</> <type>text[]</></entry>
       <entry>获取数据库对象地址的外部表征</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_object_address(<parameter>type</parameter> <type>text</>, <parameter>name</parameter> <type>text[]</>, <parameter>args</parameter> <type>text[]</>)</function></literal></entry>
       <entry><parameter>catalog_id</> <type>oid</>, <parameter>object_id</> <type>oid</>, <parameter>object_sub_id</> <type>int32</></entry>
       <entry>从外部表征中获取数据库对象地址</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <function>pg_describe_object</function>返回一个数据库对象的文本描述，
      该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
      这个描述会是人类可读的，并且可能是被翻译过的，具体情况取决于服务器配置。
      这在判断存储在<structname>pg_depend</structname>目录中的一个对象的身份有用。
  </para>

  <para>
   <function>pg_identify_object</function>返回一行，
      其中包含足够的信息来唯一地标识数据库对象，
      该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
      这个信息是机器可读的，并且永远不会被翻译。<parameter>type</>标识数据库对象的类型；
      <parameter>schema</>是对象所属的模式的名称，
      如果对象类型不属于模式则为<literal>NULL</>；
      <parameter>name</>是对象的名称，必要时要加上引号，
      只在能被用作对象的唯一标识符时出现（和模式名称一起，如果相关），
      否则为<literal>NULL</>；<parameter>identity</>是完整的对象身份，
      确切格式取决于对象类型，并且格式中的每一部分都是模式限定的并且按照需要被加上了引号。
  </para>

  <para>
   <function>pg_identify_object_as_address</function>返回一行，
   其中包含足够的信息来唯一地标识数据库对象，
   该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
   返回的信息是独立于当前服务器的，也就是说，
   它可以用于标识另一个服务器中同一个命名对象。
   <parameter>type</>标识数据库对象的类型；
   <parameter>name</>和<parameter>args</>是形成对象引用的文本数组。 
   传递三列到<function>pg_get_object_address</>获取对象的外部地址。
   这个函数是<function>pg_get_object_address</function>的逆函数。
  </para>

  <para>
   <function>pg_get_object_address</function>返回行，
   包含足够信息来唯一地标识数据库对象，该数据库对象由类型和对象名称以及参数数组指定。
   返回值是在系统目录中使用的比如<structname>pg_depend</>，并且可以传递给其它系统函数
   比如<function>pg_identify_object</>或者<function>pg_describe_object</>。
   <parameter>catalog_id</>是包含对象的系统目录OID； 
   <parameter>object_id</>是对象本身的OID，<parameter>object_sub_id</>是对象的子ID，
   如果没有则为零。这个函数是<function>pg_identify_object_as_address</function>的逆函数。
  </para>
  
   <indexterm>
    <primary>col_description</primary>
   </indexterm>

   <indexterm>
    <primary>obj_description</primary>
   </indexterm>

   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>

   <indexterm>
    <primary>注释</primary>
    <secondary sortas="database objects">关于数据库对象</secondary>
   </indexterm>

   <para>
    <xref linkend="functions-info-comment-table">中展示的函数抽取注释，注释是由<xref linkend="sql-comment">命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </para>

   <table id="functions-info-comment-table">
    <title>注释信息函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个表列获得注释</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个数据库对象获得注释</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个数据库对象获得注释（<emphasis>已被废弃</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个共享数据库对象获得注释</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>col_description</function>为一个表列返回注释，该表列由所在表的 OID 和它的列号指定（<function>obj_description</function>不能被用在表列，因为表列没有自己的 OID）。
   </para>

   <para>
    <function>obj_description</function>的双参数形式返回一个由其 OID 和所在系统目录名称指定的数据库对象的注释。例如，<literal>obj_description(123456,'pg_class')</literal>将会检索出 OID 为123456的表的注释。<function>obj_description</function>的单参数形式只要求对象 OID。它已经被废弃，因为无法保证 OID 在不同系统目录之间是唯一的；这样可能会返回错误的注释。
   </para>

   <para>
    <function>shobj_description</function>用起来就像<function>obj_description</function>，但是前者是用于检索共享对象上的注释。某些系统目录对于一个集簇中的所有数据库是全局的，并且其中的对象的描述也是全局存储的。
   </para>

   <indexterm>
    <primary>txid_current</primary>
   </indexterm>

   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>

   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>

   <para>
    <xref linkend="functions-txid-snapshot">中展示的函数以一种可导出的形式提供了服务器事务信息。这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </para>

   <table id="functions-txid-snapshot">
    <title>事务 ID 和快照</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得当前事务ID，如果当前事务没有则分配一个新的</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
       <entry>获得当前快照</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
       <entry>获得快照中正在进行的事务 ID</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得快照的<literal>xmax</literal></entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得快照的<literal>xmin</literal></entry>
      </row>
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>事务 ID 在快照中可见吗？（不能用于子事务 ID）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    内部事务 ID 类型（<type>xid</>）是 32 位宽并且每 40 亿个事务就会回卷。但是，这些函数导出一种 64 位格式，它被使用一个<quote>世代</>计数器，这样在一个安装的生命期内不会回卷。这些函数使用的数据类型<type>txid_snapshot</type>存储了在一个特定时刻有关事务 ID 可见性的信息。它的成分在<xref linkend="functions-txid-snapshot-parts">中描述。
   </para>

   <table id="functions-txid-snapshot-parts">
    <title>快照成分</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>名称</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>xmin</type></entry>
       <entry>
         仍然活动的最早的事务 ID （txid）。所有更早的事务要么已经被提交并且可见，要么已经被回滚并且死亡。
       </entry>
      </row>

      <row>
       <entry><type>xmax</type></entry>
       <entry>
        第一个还未分配的 txid。所有大于等于它的 txid 在快照的时刻还没有开始，并且因此是不可见的。
       </entry>
      </row>

      <row>
       <entry><type>xip_list</type></entry>
       <entry>
        在快照时刻活动的 txid。这个列表只包括那些位于<literal>xmin</>和<literal>xmax</>之间的活动 txid；可能有活动的超过<literal>xmax</>的 txid。一个满足<literal>xmin &lt;= txid &lt; xmax</literal>并且不在这个列表中的 txid 在快照时刻已经结束，并且因此根据其提交状态要么可见要么死亡。该列表不包括子事务的 txid。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    <type>txid_snapshot</>的文本表示是<literal><replaceable>xmin</>:<replaceable>xmax</>:<replaceable>xip_list</></literal>。例如<literal>10:20:10,14,15</literal>表示<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>。
   </para>
   
   <para>
    在<xref linkend="functions-commit-timestamp">中显示的函数
    提供了已提交事务的信息。这些函数主要提供关于事务提交的信息。
    当<xref linkend="guc-track-commit-timestamp">配置选项启用的时候，
    并且只有启用后提交的事务，它们只提供有用的数据。
   </para>

   <table id="functions-commit-timestamp">
    <title>已提交事务信息</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_xact_commit_timestamp</primary></indexterm>
        <literal><function>pg_xact_commit_timestamp(<parameter>xid</parameter>)</function></literal>
       </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>事务提交的时间戳</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_last_committed_xact</primary></indexterm>
        <literal><function>pg_last_committed_xact()</function></literal>
       </entry>
       <entry><parameter>xid</> <type>xid</>, <parameter>timestamp</> <type>timestamp with time zone</></entry>
       <entry>最近提交事务的事务ID以及提交时间戳</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
  </sect1>

  <sect1 id="functions-admin">
   <title>系统管理函数</title>

   <para>
    这一节描述的函数被用来控制和监视一个<productname>PostgreSQL</>安装。
   </para>

  <sect2 id="functions-admin-set">
   <title>配置设定函数</title>

   <para>
    <xref linkend="functions-admin-set-table">展示了那些可以用于查询以及修改运行时配置参数的函数。
   </para>

   <table id="functions-admin-set-table">
    <title>配置设定函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>获得设置的当前值</entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>设置一个参数并返回新值</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>SET</primary>
   </indexterm>

   <indexterm>
    <primary>SHOW</primary>
   </indexterm>

   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>

   <para>
    <function>current_setting</function>得到<parameter>setting_name</parameter>设置的当前值。它对应于<acronym>SQL</acronym>命令<command>SHOW</command>。一个例子：
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</programlisting>
   </para>

   <para>
    <function>set_config</function>将参数<parameter>setting_name</parameter>设置为<parameter>new_value</parameter>。如果 <parameter>is_local</parameter>设置为<literal>true</literal>，那么新值将只应用于当前事务。 如果你希望新值应用于当前会话，那么应该使用<literal>false</literal>。 它等效于 SQL 命令 <command>SET</command>。例如：
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-admin-signal">
   <title>服务器信号函数</title>

   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>

   <indexterm>
    <primary>信号</primary>
    <secondary sortas="backend">后端进程</secondary>
   </indexterm>

   <para>
    在<xref linkend="functions-admin-signal-table">中展示的函数向其它服务器进程发送控制信号。这些函数的使用通常限制为超级用户。
   </para>

   <table id="functions-admin-signal-table">
    <title>服务器信号函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>取消一个后端的当前查询。
        如果调用角色是其后端正在被取消的角色的成员，
        然而只有超级用户可以取消超级用户的后端。这也是允许的。
        </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>导致服务器进程重载它们的配置文件</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>切换服务器的日志文件</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>中止一个后端。
        如果调用角色是其后端被终止的角色成员，
        然而只有超级用户可以终止超级用户的后端。这也是允许的。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    这些函数中的每一个都在成功时返回<literal>true</literal>，并且在失败时返回<literal>false</literal>。
   </para>

   <para>
    <function>pg_cancel_backend</>和<function>pg_terminate_backend</>向由进程 ID 标识的后端进程发送信号（分别是<systemitem>SIGINT</>或<systemitem>SIGTERM</>）。一个活动后端的进程 ID可以从<structname>pg_stat_activity</structname>视图的<structfield>pid</structfield>列中找到，或者通过在服务器上列出<command>postgres</command>进程（在 Unix 上使用<application>ps</>或者在<productname>Windows</>上使用<application>任务管理器</>）得到。一个活动后端的角色可以在<structname>pg_stat_activity</structname>视图的<structfield>usename</structfield>列中找到。
   </para>

   <para>
    <function>pg_reload_conf</>给服务器发送一个<systemitem>SIGHUP</>信号， 导致所有服务器进程重载配置文件。
   </para>

   <para>
    <function>pg_rotate_logfile</>给日志文件管理器发送信号，告诉它立即切换到一个新的输出文件。这个函数只有在内建日志收集器运行时才能工作，因为否则就不存在日志文件管理器子进程。
    subprocess.
   </para>

  </sect2>

  <sect2 id="functions-admin-backup">
   <title>备份控制函数</title>

   <indexterm>
    <primary>backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_insert_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
   <indexterm>
    <primary>pg_switch_xlog</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name_offset</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_location_diff</primary>
   </indexterm>

   <para>
    <xref linkend="functions-admin-backup-table">中展示的函数可以辅助制作在线备份。这些函数不能在恢复期间执行（<function>pg_is_in_backup</function>、<function>pg_backup_start_time</function>和<function>pg_xlog_location_diff</function>除外）。
   </para>

   <table id="functions-admin-backup-table">
    <title>备份控制函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</> <type>text</>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>为执行恢复创建一个命名点（只限于超级用户）</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_insert_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得当前事务日志插入位置</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得当前事务日志写入位置</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</> <type>text</> <optional>, <parameter>fast</> <type>boolean</> </optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>准备执行在线备份（只限于超级用户或者复制角色）</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>完成执行在线备份（只限于超级用户或者复制角色）</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果一个在线排他备份仍在进行中则为真。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>获得一个进行中的在线排他备份的开始时间。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_switch_xlog()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>强制切换到一个新的事务日志文件（只限于超级用户）</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name(<parameter>location</> <type>text</>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>转换事务日志位置字符串为文件名</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name_offset(<parameter>location</> <type>text</>)</function></literal>
        </entry>
       <entry><type>pg_lsn</>, <type>integer</></entry>
       <entry>转换事务日志位置字符串为文件名以及文件内的十进制字节偏移</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_location_diff(<parameter>location</> <type>pg_lsn</>, <parameter>location</> <type>pg_lsn</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
       <entry>计算两个事务日志位置间的差别</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>pg_start_backup</>接受一个参数，
    这个参数可以是备份的任意用户定义的标签
    （通常这是备份转储文件将被存储的名字）。
    该函数写入一个备份标签文件（<filename>backup_label</>），
    如果在<filename>pg_tblspc/</>目录中有任何链接，
    表空间映射文件(<filename>tablespace_map</>)到数据库集群的数据目录中，
    执行一个检查点，然后以文本方式返回备份的起始事务日志位置。
    用户可以忽略这个结果值，但是为了可能需要的场合我们还是提供该值。
  
<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</programlisting>
    第二个参数是可选的，其类型为<type>boolean</type>。如果为<literal>true</>，它指定尽快执行<function>pg_start_backup</>。这会强制一个立即执行的检查点，它会导致 I/O 操作的峰值，拖慢任何并发执行的查询。
   </para>

   <para>
    <function>pg_stop_backup</>删除通过<function>pg_start_backup</>创建的<filename>tablespace_map</>标签文件， 
    并且在事务日志归档区里创建一个备份历史文件。
    这个历史文件包含给予<function>pg_start_backup</>的标签、
    备份的起始与终止事务日志位置以及备份的起始和终止时间。
    返回值是备份的终止事务日志位置（同样也可以被忽略）。
    在记录结束位置之后，
    当前事务日志插入点被自动地推进到下一个事务日志文件，
    这样结束的事务日志文件可以立即被归档来结束备份。
   </para>

   <para>
    <function>pg_switch_xlog</>移动到下一个事务日志文件，允许当前文件被归档（假定你正在使用连续归档）。返回值是在甘冈完成的事务日志文件中结束事务日志位置 + 1。如果从上一次事务日志切换依赖没有事务日志活动，<function>pg_switch_xlog</>不会做任何事情并且返回当前正在使用的事务日志文件的开始位置。
   </para>

   <para>
    <function>pg_create_restore_point</>创建一个命名事务日志记录，它可以被用作恢复目标，并且返回相应的事务日志位置。这个给定的名字可以用于<xref linkend="recovery-target-name">来指定恢复要进行到的点。避免使用同一个名称创建多个恢复点，因为恢复会停止在第一个匹配名称的恢复目标。
   </para>

   <para>
    <function>pg_current_xlog_location</>使用上述函数使用的相同格式显示当前事务日志写入位置。相似地，<function>pg_current_xlog_insert_location</>显示当前事务日志插入点。插入点是在任何实例中事务日志的<quote>逻辑</>终点，而写入位置表示那些已经确实被从服务器的内部缓存写出的东西的重点。写出位置是哪些可以从服务器外部检查的东西的重点，并且通常是你所需要的，如果你对归档部分完成的事务日志文件感兴趣。插入点主要是为服务器调试目的创造的。这些都是只读操作并且不需要超级用户权限。
   </para>

   <para>
    你可以使用<function>pg_xlogfile_name_offset</>从任何上述函数的结果中抽取相应的事务日志文件名称以及字节偏移。例如：
<programlisting>
postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    相似地，<function>pg_xlogfile_name</>只抽取事务日志文件名。当给定的事务日志位置正好在一个事务日志文件的边界，这些函数都返回之前的事务日志文件的名称。这对管理事务日志归档行为通常是所希望的行为，因为前一个文件是当前需要被归档的最后一个文件。
   </para>

   <para>
    <function>pg_xlog_location_diff</>以字节数计算两个事务日志位置之间的差别。它可以和<structname>pg_stat_replication</structname>或<xref linkend="functions-admin-backup-table">中其他的函数一起使用来获得复制延迟。
   </para>

   <para>
    关于正确使用这些函数的细节，请见<xref linkend="continuous-archiving">。
   </para>

  </sect2>

  <sect2 id="functions-recovery-control">
   <title>恢复控制函数</title>

   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_receive_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_replay_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>

   <para>
    <xref linkend="functions-recovery-info-table">中展示的函数提供有关后备机当前状态的信息。这些函数可以在恢复或普通运行过程中被执行。
   </para>

   <table id="functions-recovery-info-table">
    <title>恢复信息函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果恢复仍在进行中，为真。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_receive_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得最后一个收到并由流复制同步到磁盘的事务日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中收到并同步到磁盘的最后一个 WAL 记录。如果流复制被禁用，或者还没有被启动，该函数返回 NULL。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_replay_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得恢复过程中被重放的最后一个事务日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中被应用的最后一个 WAL 记录。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>获得恢复过程中被重放的最后一个事务的时间戳。这是在主机上产生的事务的提交或中止 WAL 记录的时间。如果在恢复过程中没有事务被重放，这个函数返回 NULL。否则，如果恢复仍在进行这将单调增加。如果恢复已经完成，则这个值会保持静止在恢复过程中最后一个被应用的事务。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_is_xlog_replay_paused</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_pause</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_resume</primary>
   </indexterm>

   <para>
    <xref linkend="functions-recovery-control-table">中展示的函数空值恢复的进程。这些函数只能在恢复过程中被执行。
   </para>

   <table id="functions-recovery-control-table">
    <title>恢复控制函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_xlog_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果恢复被暂停，为真。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>立即暂停恢复（仅限于超级用户）。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>如果恢复被暂停，重启之（仅限于超级用户）。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    在恢复被暂停时，不会有进一步的数据库改变被应用。如果在热备模式，所有新的查询将看到数据库的同一个一致快照，并且在恢复被继续之前不会有更多查询冲突会产生。
   </para>

   <para>
    如果流复制被禁用，暂停状态可以无限制地继续而不出问题。在流复制进行时，WAL 记录将继续被接收，最后将会填满可用的磁盘空间，取决于暂停的持续时间、WAL 的产生率和可用的磁盘空间。
   </para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
   <title>快照同步函数</title>

   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</>允许数据库会话同步它们的快照。一个<firstterm>快照</>决定对于正在使用该快照的事务哪些数据是可见的。当两个或者更多个会话需要看到数据库中的相同内容时，就需要同步快照。如果两个会话独立开始其事务，就总是有可能有某个第三事务在两个<command>START TRANSACTION</>命令的执行之间提交，这样其中一个会话就可以看到该事务的效果而另一个则看不到。
   </para>

   <para>
    为了解决这个问题，<productname>PostgreSQL</>允许一个事务<firstterm>导出</>它正在使用的快照。只要导出的事务仍然保持打开，其他事务可以<firstterm>导入</>它的快照，并且因此可以保证它们可以看到和第一个事务看到的完全一样的数据库视图。但是注意这些事务中的任何一个对数据库所作的更改对其他事务仍然保持不可见，和未提交事务所作的修改一样。因此这些事务是针对以前存在的数据同步，而对由它们自己所作的更改则采取正常的动作。
   </para>

   <para>
    如<xref linkend="functions-snapshot-synchronization-table">中所示，快照通过<function>pg_export_snapshot</>函数导出，并且通过<xref linkend="sql-set-transaction">命令导入。
   </para>

   <table id="functions-snapshot-synchronization-table">
    <title>快照同步函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>保存当前快照并返回它的标识符</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    函数<function>pg_export_snapshot</>保存当前的快照并且返回一个<type>text</>串标识该快照。该字符串必须被传递（到数据库外）给希望导入快照的客户端。直到导出快照的事务的末尾，快照都可以被导入。如果需要，一个事务可以导出多于一个快照。注意这样做只在 <literal>READ COMMITTED</>事务中有用，因为在<literal>REPEATABLE READ</>和更高隔离级别中，事务在它们的生命期中都使用同一个快照。一旦一个事务已经导出了任何快照，它不能使用<xref linkend="sql-prepare-transaction">。
   </para>

   <para>
    关于如何使用一个已导出快照的细节请见<xref linkend="sql-set-transaction">.
   </para>
  </sect2>
  
  <sect2 id="functions-replication">
   <title>Replication Functions</title>

   <para>
    <xref linkend="functions-replication-table">中显示的函数为了控制和交互复制功能。
    参阅<xref linkend="streaming-replication">，
    <xref linkend="streaming-replication-slots">以及
    <xref linkend="replication-origins">获取基本功能信息。这些函数的使用受制于超级用户。
   </para>

   <para>
    在复制协议中有许多这些函数的相等命令；
    参阅<xref linkend="protocol-replication">。
   </para>

   <para>
    <xref linkend="functions-snapshot-synchronization">，
    <xref linkend="functions-recovery-control">以及
    <xref linkend="functions-admin-backup">中的函数也是与复制有关的。
   </para>

   <table id="functions-replication-table">
    <title>复制<acronym>SQL</acronym>函数</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        创建一个名为<parameter>slot_name</parameter>的新物理复制槽。
        只有用流复制协议才能从一个物理槽流式传送变化 - 见
        <xref linkend="protocol-replication">。对应于复制协议命令
        <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        丢弃名为<parameter>slot_name</parameter>的物理或逻辑复制槽。
        和复制协议命令<literal>DROP_REPLICATION_SLOT</>相同。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        使用输出插件<parameter>plugin</parameter>创建一个名为
        <parameter>slot_name</parameter>的新逻辑（解码）复制槽。
        对这个函数的调用与复制协议命令
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>具有相同的效果。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        返回槽<parameter>slot_name</parameter>中的改变，从上一次已经被消费的点开始返回。
        如果<parameter>upto_lsn</>和<parameter>upto_nchanges</>为 NULL，逻辑解码将一
        直继续到 WAL 的末尾。如果<parameter>upto_lsn</>为非 NULL，解码将只包括那些在指
        定 LSN 之前提交的事务。如果<parameter>upto_nchanges</parameter>为非 NULL，
        解码将在其产生的行数超过指定值后停止。不过要注意，
        被返回的实际行数可能更大，因为对这个限制的检查只会在增加了解码每个新的提交事务产生
        的行之后进行。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>text</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变不会被消费， 即在未来的调用中还会返回这些改变。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回并且这些改变不会被消费，
        即在未来的调用中还会返回这些改变。
       </entry>
      </row>
      
      <row>
       <entry id="pg-replication-origin-create">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <literal><function>pg_replication_origin_create(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        创建具有给定外部名称的复制源，并返回分配给它的内部标识。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-drop">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <literal><function>pg_replication_origin_drop(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        删除之前创建的复制源，包含任何相关的回放进程。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <literal><function>pg_replication_origin_oid(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        通过名称查找复制源并返回内部标识。
        如果没有发现相应的复制源，则抛出一个错误。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-setup">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_setup(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        标记当前会话从给定源开始回放，允许跟踪重播进度。如果没有配置之前的源，
        使用<function>pg_replication_origin_session_reset</function>恢复。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_reset()</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        取消<function>pg_replication_origin_session_setup()</function>的影响。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_is_setup()</function></literal>
       </entry>
       <entry>
        <type>bool</type>
       </entry>
       <entry>
        在当前会话中已经配置复制源吗？
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-progress">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_progress(<parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        返回当前会话中配置的复制源的重播位置。
        参数<parameter>flush</parameter>决定是否相应的本地事务将被刷新到磁盘或者不刷新。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-setup">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_setup(<parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamptz</type>)</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        标记当前事务为回放给定<acronym>LSN</acronym>和时间戳点提交的事务。
        当使用<function>pg_replication_origin_session_setup()</function>配置
        复制源时，调用它。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-reset">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_reset()</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        取消<function>pg_replication_origin_xact_setup()</function>的影响。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <literal>pg_replication_origin_advance<function>(<parameter>node_name</parameter> <type>text</type>, <parameter>pos</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        void
       </entry>
       <entry>
        为给定节点到给定位置设置复制进度。
        这主要是用于设置配置更改后的初始位置或新位置。
        要知道这个函数使用不当会导致不一致的复制数据。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-progress">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_progress(<parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        返回给定复制源的重放位置。
        参数<parameter>flush</parameter>确定是
        否相应的本地事务将被保证刷新到磁盘或不刷新。
       </entry>
      </row>
      
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
   <title>数据库对象管理函数</title>

   <para>
    <xref linkend="functions-admin-dbsize">中展示的函数计算数据库对象使用的磁盘空间。
   </para>

   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>

   <table id="functions-admin-dbsize">
    <title>数据库对象尺寸函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>存储一个特定值（可能压缩过）所需的字节数</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定 OID 的数据库使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定名称的数据库使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        附加到指定表的索引所占的总磁盘空间
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        指定表或索引的指定分叉（<literal>'main'</literal>、<literal>'fsm'</literal>、<literal>'vm'</>或<literal>'init'</>）使用的磁盘空间
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        <literal>pg_relation_size(..., 'main')的简写</literal>
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         将表示成一个 64位整数的字节尺寸转换为带尺寸单位的人类可读格式
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         将表示成一个数字值的字节尺寸转换为带尺寸单位的人类可读格式
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        被指定表使用的磁盘空间，排除索引（但包括 TOAST、空闲空间映射和可见性映射）
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定 OID 的表空间使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定名称的表空间使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        指定表所用的总磁盘空间，包括所有的索引和<acronym>TOAST</>数据
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>pg_column_size</>显示用于存储任意独立数据值的空间。
   </para>

   <para>
    <function>pg_total_relation_size</>接受一个表或 TOAST 表的 OID 或名称，并返回该表所使用的总磁盘空间，包括所有相关的索引。这个函数等价于<function>pg_table_size</function> <literal>+</> <function>pg_indexes_size</function>。
   </para>

   <para>
    <function>pg_table_size</>接受一个表的 OID 或名称，并返回该表所需的磁盘空间，但是排除索引（TOAST 空间、空闲空间映射和可见性映射包含在内）
   </para>

   <para>
    <function>pg_indexes_size</>接受一个表的 OID 或名称，并返回附加到该表的所有索引所使用的全部磁盘空间。
   </para>

   <para>
    <function>pg_database_size</function>和<function>pg_tablespace_size</>接受一个数据库或表空间的 OID 或 名称，并且返回它们所使用的全部磁盘空间。
    To use <function>pg_database_size</function>,
    you must have <literal>CONNECT</> permission on the specified database
    (which is granted by default).  To use <function>pg_tablespace_size</>,
    you must have <literal>CREATE</> permission on the specified tablespace,
    unless it is the default tablespace for the current database.
   </para>

   <para>
    <function>pg_relation_size</> accepts the OID or name of a table, index
    or toast table, and returns the on-disk size in bytes of one fork of
    that relation.  (Note that for most purposes it is more convenient to
    use the higher-level functions <function>pg_total_relation_size</>
    or <function>pg_table_size</>, which sum the sizes of all forks.)
    With one argument, it returns the size of the main data fork of the
    relation.  The second argument can be provided to specify which fork
    to examine:
    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>'main'</literal> returns the size of the main
       data fork of the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'fsm'</literal> returns the size of the Free Space Map
       (see <xref linkend="storage-fsm">) associated with the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'vm'</literal> returns the size of the Visibility Map
       (see <xref linkend="storage-vm">) associated with the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'init'</literal> returns the size of the initialization
       fork, if any, associated with the relation.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    <function>pg_size_pretty</>可以用于把其它函数之一的结果格式化成一种人类易读的格式，可以根据情况使用 KB、MB、GB 或者 TB。
   </para>

   <para>
    上述操作表和索引的函数接受一个<type>regclass</>参数，它是该表或索引在<structname>pg_class</>系统目录中的 OID。你不必手工去查找该 OID，因为<type>regclass</>数据类型的输入转换器会为你代劳。只写包围在单引号内的表名，这样它看起来像一个文字常量。为了与普通<acronym>SQL</acronym>名称的处理相兼容，该字符串将被转换为小写形式，除非其中在表名周围包含双引号。
   </para>

   <para>
    如果一个 OID 不表示一个已有的对象并且被作为参数传递给了上述函数，将会返回 NULL。
   </para>

   <para>
    <xref linkend="functions-admin-dblocation">中展示的函数帮助标识数据库对象相关的磁盘文件。
   </para>

   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>

   <table id="functions-admin-dblocation">
    <title>数据库对象定位函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>
        指定关系的文件结点号
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
        指定关系的文件路径名
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
        查找与给定的表空间和文件节点相关的关系
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>pg_relation_filenode</>接受一个表、索引、序列或 TOAST 表的 OID 或名称，返回当前分配给它的<quote>filenode</>号。文件结点是关系的文件名的基本组件（详见<xref linkend="storage-file-layout">）。对于大多数表结果和<structname>pg_class</>.<structfield>relfilenode</>相同，但是对于某些系统目录<structfield>relfilenode</>为零，并且必须使用此函数获取正确的值。 如果传递一个没有存储的关系（如视图），此函数将返回 NULL。
   </para>

   <para>
    <function>pg_relation_filepath</>与<function>pg_relation_filenode</>类似，但是它返回关系的整个文件路径名（相对于数据库集簇的数据目录<varname>PGDATA</>）。
   </para>
   
   <para>
    <function>pg_filenode_relation</>是<function>pg_relation_filenode</>的反向函数。给定一个<quote>tablespace</> OID 以及一个 <quote>filenode</>，它会返回相关关系的 OID。对于一个在数据库的默认表空间中的表，该表空间可以指定为 0。
   </para>

  </sect2>

   <sect2 id="functions-admin-index">
   <title>索引维护函数</title>

   <indexterm>
    <primary>brin_summarize_new_values</primary>
   </indexterm>

   <para>
    <xref linkend="functions-admin-index-table">显示可用于索引维护功能的函数。
   </para>

   <table id="functions-admin-index-table">
    <title>Index Maintenance Functions</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>brin_summarize_new_values(<parameter>index_oid</> <type>regclass</>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>总结尚未汇总的页面范围</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>brin_summarize_new_values</>接收BRIN索引OID作为参数，
    并检查索引以查找基表中的页范围，它不是目前所总结的索引；
    对于任何这样的范围，它通过扫描表页创建一个新的汇总索引元组。
    它返回插入索引的新页范围汇总的数量。
   </para>

  </sect2>
  
  <sect2 id="functions-admin-genfile">
   <title>通用文件访问函数</title>

   <para>
    <xref linkend="functions-admin-genfile-table">中展示的函数提供了对数据库服务器所在机器上的文件的本地访问。 只有那些在数据库集簇目录和<varname>log_directory</>目录中的文件可以访问。使用相对路径访问集簇目录里面的文件，以及匹配 <varname>log_directory</>配置设置的路径访问日志文件。只有超级用户才能使用这些函数。
   </para>

   <table id="functions-admin-genfile-table">
    <title>通用文件访问函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</> <type>text</> [, <parameter>missing_ok</> <type>boolean</>, <parameter>include_dot_dirs</> <type>boolean</>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
        列出目录内容。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</> [, <parameter>missing_ok</> <type>boolean</>] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        返回文本文件的内容。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</> [, <parameter>missing_ok</> <type>boolean</>] ])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        返回一个文件的内容。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</> <type>text</>[, <parameter>missing_ok</> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        返回文件信息。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    所有这些函数接受可选的<parameter>missing_ok</>参数，
    当文件或目录不存在时，指定操作。
    如果<literal>true</literal>，那么函数返回NULL
    除了<function>pg_ls_dir</>，将返回空结果集）。如果<literal>false</>，则抛出错误。默认为<literal>false</>。
   </para>

   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
   <para>
    <function>pg_ls_dir</>返回所有指定目录中的文件名称（目录以及其它指定文件）。
    <parameter>include_dot_dirs</>显示<quote>.</>和<quote>..</>是否包含在结果集中。
    缺省排除它们(<literal>false</>)，
    但是当<parameter>missing_ok</>是<literal>true</literal>时，
    包含它们从非存在目录中区分空目录是非常有用的。
   </para>

   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
   <para>
    <function>pg_read_file</>返回一个文本文件的一部分，从给定的<parameter>offset</>开始，返回最多<parameter>length</>字节（如果先到达文件末尾则会稍短）。如果<parameter>offset</>为负，它相对于文件的末尾。如果<parameter>offset</>和<parameter>length</>被忽略，整个文件都被返回。从文件中读的字节被使用服务器编码解释成一个字符串；如果它们在编码中不合法则抛出一个错误。
   </para>

   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
   <para>
    <function>pg_read_binary_file</>与<function>pg_read_file</>相似，除了前者的结果是一个<type>bytea</type>值；相应地，不会执行编码检查。通过与<function>convert_from</>函数结合，这个函数可以用来读取一个指定编码的文件：
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>

   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
   <para>
    <function>pg_stat_file</>返回一个记录，其中包含文件尺寸、最后访问时间戳、最后修改时间戳、最后文件状态改变时间戳（只支持 Unix 平台）、文件创建时间戳（只支持 Windows）和一个<type>boolean</type>指示它是否为目录。通常的用法包括：
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-advisory-locks">
   <title>咨询锁函数</title>

   <para>
    <xref linkend="functions-advisory-locks-table">中展示的函数管理咨询锁。有关正确使用这些函数的细节请参考<xref linkend="advisory-locks">。
   </para>

   <table id="functions-advisory-locks-table">
    <title>咨询锁函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>释放当前会话持有的所有会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享事务级别咨询锁</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
   <para>
    <function>pg_advisory_lock</>锁住一个应用定义的资源，可以使用一个单一64位键值或两个32位键值标识（注意这些两个键空间不重叠）。如果另一个会话已经在同一个资源标识符上持有了一个锁，这个函数将等待直到该资源变成可用。该锁是排他的。多个锁请求会入栈，因此如果同一个资源被锁住三次，则它必须被解锁三次来被释放给其他会话使用。
   </para>

   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
   <para>
    <function>pg_advisory_lock_shared</>的工作和<function>pg_advisory_lock</>相同，不过该锁可以与其他请求共享锁的会话共享。只有想要排他的锁请求会被排除。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
   <para>
    <function>pg_try_advisory_lock</>与<function>pg_advisory_lock</>相似，不过该函数将不会等待锁变为可用。它要么立刻获得锁并返回<literal>true</>，要么不能立即获得锁并返回<literal>false</>。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
   <para>
    <function>pg_try_advisory_lock_shared</>的工作和<function>pg_try_advisory_lock</>相同，不过它尝试获得一个共享锁而不是一个排他锁。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
   <para>
    <function>pg_advisory_unlock</>将会释放之前获得的排他会话级别咨询锁。如果锁被成功释放，它返回<literal>true</>。如果锁没有被持有，它将返回<literal>false</>并且额外由服务器报告一个 SQL 警告。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
   <para>
    <function>pg_advisory_unlock_shared</>的工作和<function>pg_advisory_unlock</>相同，除了它释放一个共享的会话级别咨询锁。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
   <para>
    <function>pg_advisory_unlock_all</>将释放当前会话所持有的所有会话级别咨询锁（这个函数隐式地在会话末尾被调用，即使客户端已经不雅地断开）。
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
   <para>
    <function>pg_advisory_xact_lock</>的工作和<function>pg_advisory_lock</>相同，不过锁是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
    <function>pg_advisory_xact_lock_shared</>的工作和<function>pg_advisory_lock_shared</>相同，除了锁是在当前事务的末尾自动被释放的并且不能被显式释放。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
   <para>
    <function>pg_try_advisory_xact_lock</>的工作和<function>pg_try_advisory_lock</>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
    <function>pg_try_advisory_xact_lock_shared</>的工作和<function>pg_try_advisory_lock_shared</>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
   <title>触发器函数</title>

   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>

   <para>
      当前<productname>PostgreSQL</>提供一个内建的触发器函数<function>suppress_redundant_updates_trigger</>， 它将阻止任何不会实际更改行中数据的更新发生，这与正常的行为不管数据是否改变始终执行更新相反（这是正常的行为，使得更新运行速度更快，因为不需要检查，并在某些情况下也是有用的）。
    </para>

    <para>
      理想的情况下，你通常应该避免运行实际上并没有改变记录中数据的更新。 冗余更新会花费大量不必要的时间，尤其是如果有大量索引要改变， 并将最终不得不清理被死亡行占用的空间。但是，在客户端代码中检测这种情况并不总是容易的，甚至不可能做到。 而写表达式来检测它们容易产生错误。作为替代，使用<function>suppress_redundant_updates_trigger</>可以跳过不改变数据的更新。 但是，你需要小心使用它。触发器需要很短但不能忽略的时间来处理每条记录，所以如果大多数被一个更新影响的记录确实被更改，此触发器的使用将实际上使更新运行得更慢。
    </para>

    <para>
      <function>suppress_redundant_updates_trigger</>函数可以像这样被加到一个表：
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
</programlisting>
      在大部分情况下，你可能希望在最后为每行触发这个触发器。考虑到触发器是按照名字顺序被触发，你需要选择一个位于该表所有其他触发器之后的触发器名字。
    </para>
    <para>
       有关创建触发器的更多信息请参考<xref linkend="SQL-CREATETRIGGER">。
    </para>
  </sect1>

  <sect1 id="functions-event-triggers">
   <title>事件触发器函数</title>

   <para>
    <productname>PostgreSQL</>提供这些帮助函数用以从事件触发器中检索信息。
   </para>

   <para>
    关于事件触发器的更多信息，参见<xref linkend="event-triggers">。
   </para>

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
   <title>捕获命令结尾的改变</title>

   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>

   <para>
    <function>pg_event_trigger_ddl_commands</>返回通过
    每个用户操作执行的<acronym>DDL</acronym>命令列表，
    当调用函数中<literal>ddl_command_end</>事件触发器，
    如果在任何其它上下文中调用，则抛出一个错误。
    <function>pg_event_trigger_ddl_commands</>返回每个基本执行命令的每一行；
    单独SQL语句的命令可能返回多个行。此函数返回以下列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>对象从属的系统OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>系统中对象的OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>对象子ID(比如列的属性数)</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>命令标签</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象从属模式名，如果没有；否则为<literal>NULL</>。没有应用引用。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>bool</type></entry>
        <entry>命令是否是扩展脚本的一部分</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         内部格式中命令的完整表示。这不能直接输出，
         但它可以传递给其它函数用来获取该命令的不同信息。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
   <title>通过DDL命令删除处理的对象</title>

   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>


   <para>
    <function>pg_event_trigger_dropped_objects</>返回其<literal>sql_drop</>事件中命令所删除的所有对象的列表。如果在任何其他环境中被调用，<function>pg_event_trigger_dropped_objects</>将抛出一个错误。<function>pg_event_trigger_dropped_objects</>返回下列列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>在目录中的对象的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>int32</type></entry>
        <entry>对象的子ID（如列的属性号）</entry>
       </row>
       
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>bool</type></entry>
        <entry>用于标识删除的根对象的标志</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         标志表明在导致这个对象的依赖关系图中有一个正常的依赖关系
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         标志表明该对象是临时对象。
        </entry>
       </row>
       
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象所属模式的名称（如果存在）；否则为<literal>NULL</>。不应用引用。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         如果模式和名称的组合能被用于对象的一个唯一标识符，则是对象的名称；否则是<literal>NULL</>。不应用引用，并且名称不是模式限定的。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。
        </entry>
       </row>
       
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         一个数组，连同<literal>object_type</literal>和<literal>address_args</literal>，
         可以用于<function>pg_get_object_address()</function>在包含相同命
         名对象的远程服务器中重新创建对象地址。
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         <literal>address_names</literal>的补充。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
    <function>pg_event_trigger_dropped_objects</>可以被这样用在一个事件触发器中：
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name, 
                     obj.object_identity;
    END LOOP;
END 
$$; 
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE PROCEDURE test_event_trigger_for_drops();
</programlisting>
    </para> 

 </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
   <title>处理表重写事件</title>

   <para>

   显示在<xref linkend="functions-event-trigger-table-rewrite">中的函数提供关于表的信息，
    其中<literal>table_rewrite</>事件刚刚被调用。如果在任何其它上下文中调用，则抛出错误。
   </para>

   <table id="functions-event-trigger-table-rewrite">
    <title>表重写信息</title>
    <tgroup cols="3">
     <thead>
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_oid</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_oid()</function></literal>
       </entry>
       <entry><type>Oid</type></entry>
       <entry>关于被改写的表的OID。</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_reason</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_reason()</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        原因代码解释重写的原因。代码的确切意义是释放依赖。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table> 

   <para>
    在下面这样的事件触发器中使用<function>pg_event_trigger_table_rewrite_oid</>函数：
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS  
$$ 
BEGIN 
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();
</programlisting>
    </para> 
  </sect2> 
  </sect1>   

</chapter>