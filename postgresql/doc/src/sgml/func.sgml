<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
<!-- pgdoc-cn_start sig_en=ed883272be06c3247383bf977684a98e sig_cn_org=None source=14.1 
  <title>Functions and Operators</title>
________________________________________________________-->
  <title>函数和操作符</title>
<!-- pgdoc-cn_end sig_en=ed883272be06c3247383bf977684a98e -->

<!-- pgdoc-cn_start sig_en=6f53e54ac51f516df40b078549c5008f sig_cn_org=None source=14.1 
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6f53e54ac51f516df40b078549c5008f -->

<!-- pgdoc-cn_start sig_en=38899c7445555695f721d03b821af3ab sig_cn_org=None source=14.1 
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=38899c7445555695f721d03b821af3ab -->

<!-- pgdoc-cn_start sig_en=bb370c2e938f6a4fc2c4beee46a6179e sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  This chapter
   describes most of them, although additional special-purpose functions
   appear in relevant sections of the manual.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming"/>.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>为内建的数据类型提供了大量的函数和操作符。 
   本章描述了其中的大部分内容，不过在手册的相关章节中还显示了更多的特殊用途函数。
   用户也可以定义它们自己的函数和操作符， 如<xref linkend="server-programming"/>所述。
   <application>psql</application>命令<command>\df</command>和<command>\do</command>可以分别被用于显示所有可用的函数和操作符的列表。
  </para>
<!-- pgdoc-cn_end sig_en=bb370c2e938f6a4fc2c4beee46a6179e -->

<!-- pgdoc-cn_start sig_en=2b20f287dd68cc78f8404c91846a22a5 sig_cn_org=None source=14.1 
  <para>
   The notation used throughout this chapter to describe the argument and
   result data types of a function or operator is like this:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   which says that the function <function>repeat</function> takes one text and
   one integer argument and returns a result of type text.  The right arrow
   is also used to indicate the result of an example, thus:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>
________________________________________________________-->
  <para>
   本章中用于描述函数或操作符的参数和结果数据类型的符号如下所示:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   函数<function>repeat</function>接受一个文本和一个整型参数，并返回文本类型的结果。右箭头也用于指示举例的结果，因此:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=2b20f287dd68cc78f8404c91846a22a5 -->

<!-- pgdoc-cn_start sig_en=270bac4d89deb0d9b0789a838165c9f1 sig_cn_org=None source=14.1 
  <para>
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.
  </para>
________________________________________________________-->
  <para>
   如果你关心移植性，那么请注意，我们在本章描述的大多数函数和操作符， 除了最琐碎的算术和比较操作符以及一些做了明确标记的函数以外，都没有在<acronym>SQL</acronym>标准里声明。某些这种扩展的功能也出现在许多其它<acronym>SQL</acronym>数据库管理系统中，并且在很多情况下多个实现的这种功能是相互兼容的和一致的。
  </para>
<!-- pgdoc-cn_end sig_en=270bac4d89deb0d9b0789a838165c9f1 -->


  <sect1 id="functions-logical">
<!-- pgdoc-cn_start sig_en=f08e498400e6ae7add2ebf1f4b882d3c sig_cn_org=None source=14.1 
   <title>Logical Operators</title>
________________________________________________________-->
   <title>逻辑操作符</title>
<!-- pgdoc-cn_end sig_en=f08e498400e6ae7add2ebf1f4b882d3c -->

<!-- pgdoc-cn_start sig_en=babd9078809c605310f8c16c1c4ec249 sig_cn_org=None source=14.1 
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=babd9078809c605310f8c16c1c4ec249 -->

<!-- pgdoc-cn_start sig_en=99326bf1490fd8550076e01afed55e4b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>
<!-- pgdoc-cn_end sig_en=99326bf1490fd8550076e01afed55e4b -->

<!-- pgdoc-cn_start sig_en=7e3484f649ec2d525e30558ec38da856 sig_cn_org=None source=14.1 
   <para>
    The usual logical operators are available:

    <indexterm>
     <primary>AND (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>OR (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>NOT (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    常用的逻辑操作符有：

    <indexterm>
     <primary>AND（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>OR（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>NOT（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym>使用三值的逻辑系统，包括真、假和<literal>null</literal>，<literal>null</literal>表示<quote>未知</quote>。观察下面的真值表：

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=7e3484f649ec2d525e30558ec38da856 -->

<!-- pgdoc-cn_start sig_en=a85b26923418242ae3fa33f25fe51c9b sig_cn_org=None source=14.1 
   <para>
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operands
    without affecting the result.  (However, it is not guaranteed that
    the left operand is evaluated before the right operand.  See <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.)
   </para>
________________________________________________________-->
   <para>
    操作符<literal>AND</literal>和<literal>OR</literal>是可交换的，也就是说，你可以交换左右操作数而不影响结果。
    （但是，不能保证左操作数在右操作数之前计算。参见<xref linkend="syntax-express-eval"/>获取有关子表达式计算顺序的更多信息。）
   </para>
<!-- pgdoc-cn_end sig_en=a85b26923418242ae3fa33f25fe51c9b -->
  </sect1>

  <sect1 id="functions-comparison">
<!-- pgdoc-cn_start sig_en=19efc1f0b17dc130665b1e728eefee0b sig_cn_org=None source=14.1 
   <title>Comparison Functions and Operators</title>
________________________________________________________-->
   <title>比较函数和操作符</title>
<!-- pgdoc-cn_end sig_en=19efc1f0b17dc130665b1e728eefee0b -->

<!-- pgdoc-cn_start sig_en=3543e155dd0a58b969ae485d78a4300b sig_cn_org=None source=14.1 
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3543e155dd0a58b969ae485d78a4300b -->

<!-- pgdoc-cn_start sig_en=551440ccc494ddb379a905dc84e34ed0 sig_cn_org=None source=14.1 
   <para>
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
   </para>
________________________________________________________-->
   <para>
    常见的比较操作符都可用，如<xref linkend="functions-comparison-op-table"/>所示。
   </para>
<!-- pgdoc-cn_end sig_en=551440ccc494ddb379a905dc84e34ed0 -->

   <table id="functions-comparison-op-table">
<!-- pgdoc-cn_start sig_en=07e0491957aa8d9dcb9b6f6c52b15472 sig_cn_org=None source=14.1 
    <title>Comparison Operators</title>
________________________________________________________-->
    <title>比较操作符</title>
<!-- pgdoc-cn_end sig_en=07e0491957aa8d9dcb9b6f6c52b15472 -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=a2afd805141bb40b02812434b9225e0d sig_cn_org=None source=14.1 
      <row>
       <entry>Operator</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2afd805141bb40b02812434b9225e0d -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=0a137e4b95ac2762fbe5864a85851033 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=0a137e4b95ac2762fbe5864a85851033 -->

<!-- pgdoc-cn_start sig_en=1f235bad306a83cdf71f0ea3e239fb97 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=1f235bad306a83cdf71f0ea3e239fb97 -->

<!-- pgdoc-cn_start sig_en=b2676db7cc9138f5deb52f8c2ae42375 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than or equal to</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于等于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2676db7cc9138f5deb52f8c2ae42375 -->

<!-- pgdoc-cn_start sig_en=f5318c8c5d5a5c70a1518a2969563052 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than or equal to</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于等于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f5318c8c5d5a5c70a1518a2969563052 -->

<!-- pgdoc-cn_start sig_en=7a01e170504f75b63628768db8fe01b4 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Equal</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>等于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=7a01e170504f75b63628768db8fe01b4 -->

<!-- pgdoc-cn_start sig_en=9e069ba4425c0edabb3f34adf71b26b2 sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9e069ba4425c0edabb3f34adf71b26b2 -->

<!-- pgdoc-cn_start sig_en=64340523099b9d70ecbd8564608e578e sig_cn_org=None source=14.1 
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>
<!-- pgdoc-cn_end sig_en=64340523099b9d70ecbd8564608e578e -->
     </tbody>
    </tgroup>
   </table>

   <note>
<!-- pgdoc-cn_start sig_en=2c58c2cdb9e091306885444e96cabd6f sig_cn_org=None source=14.1 
    <para>
     <literal>&lt;&gt;</literal> is the standard SQL notation for <quote>not
     equal</quote>.  <literal>!=</literal> is an alias, which is converted
     to <literal>&lt;&gt;</literal> at a very early stage of parsing.
     Hence, it is not possible to implement <literal>!=</literal>
     and <literal>&lt;&gt;</literal> operators that do different things.
    </para>
________________________________________________________-->
    <para>
     <literal>&lt;&gt;</literal> 表示 <quote>not equal</quote> 的标准的SQL符号。
     <literal>!=</literal> 是一个别名, 在解析的早期阶段被转换为 <literal>&lt;&gt;</literal> 。
     因此, 它不可能实现 <literal>!=</literal> 和 <literal>&lt;&gt;</literal> 操作符以做不同的事情。
    </para>
<!-- pgdoc-cn_end sig_en=2c58c2cdb9e091306885444e96cabd6f -->
   </note>

<!-- pgdoc-cn_start sig_en=145e28c9c5fe80515bead9fb8fd00472 sig_cn_org=None source=14.1 
   <para>
    These comparison operators are available for all built-in data types
    that have a natural ordering, including numeric, string, and date/time
    types.  In addition, arrays, composite types, and ranges can be compared
    if their component data types are comparable.
   </para>
________________________________________________________-->
   <para>
    这些比较操作符适用于所有具有自然排序的内置数据类型，包括数字、字符串、和日期/时间类型。 
    此外，如果它们的组件数据类型具有可比性，则可以比较阵列、复合类型和范围。
   </para>
<!-- pgdoc-cn_end sig_en=145e28c9c5fe80515bead9fb8fd00472 -->

<!-- pgdoc-cn_start sig_en=d8e6f046acedc79ee84e5848f612a4e1 sig_cn_org=None source=14.1 
   <para>
    It is usually possible to compare values of related data
    types as well; for example <type>integer</type> <literal>&gt;</literal>
    <type>bigint</type> will work.  Some cases of this sort are implemented
    directly by <quote>cross-type</quote> comparison operators, but if no
    such operator is available, the parser will coerce the less-general type
    to the more-general type and apply the latter's comparison operator.
   </para>
________________________________________________________-->
   <para>
    通常也可以比较相关数据类型的值；例如<type>integer</type> <literal>&gt;</literal> <type>bigint</type> 将起作用。
    这种排序的某些情况直接由<quote>cross-type</quote> 比较操作符实现，但是，如果没有这种操作符，解析器将把不太通用的类型强制为更通用的类型，并应用后者的比较操作符。
   </para>
<!-- pgdoc-cn_end sig_en=d8e6f046acedc79ee84e5848f612a4e1 -->

<!-- pgdoc-cn_start sig_en=f3cb99c0b722ae3c383b447bd2614dfa sig_cn_org=None source=14.1 
   <para>
    As shown above, all comparison operators are binary operators that
    return values of type <type>boolean</type>.  Thus, expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).  Use the <literal>BETWEEN</literal> predicates
    shown below to perform range tests.
   </para>
________________________________________________________-->
   <para>
    如上所示，所有比较操作符都是二元操作符，返回<type>boolean</type>类型的值。
    因此，类似<literal>1 &lt; 2 &lt; 3</literal>的表达式是无效的。因为没有<literal>&lt;</literal>操作符与 <literal>3</literal> 进行Boolean值比较）。
    使用下面显示的<literal>BETWEEN</literal>谓词执行范围测试。
   </para>
<!-- pgdoc-cn_end sig_en=f3cb99c0b722ae3c383b447bd2614dfa -->

<!-- pgdoc-cn_start sig_en=1f99d595540772f8c63f28437809acab sig_cn_org=None source=14.1 
   <para>
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
   </para>
________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-pred-table"/>所示，也有一些比较谓词。它们的行为和操作符很像，但是具有 SQL 标准所要求的特殊语法。
   </para>
<!-- pgdoc-cn_end sig_en=1f99d595540772f8c63f28437809acab -->

   <table id="functions-comparison-pred-table">
<!-- pgdoc-cn_start sig_en=6fff04b1332fa963702f7405631990d8 sig_cn_org=None source=14.1 
    <title>Comparison Predicates</title>
________________________________________________________-->
    <title>比较谓词</title>
<!-- pgdoc-cn_end sig_en=6fff04b1332fa963702f7405631990d8 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=84f02c846457b9eeee259eeb79f104be sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词
       </para>
       <para>
        描述
       </para>
       <para>
        示例(s)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=84f02c846457b9eeee259eeb79f104be -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=68ab5a85ed2b10720a3755fb2b5a639e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between (inclusive of the range endpoints).
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间(包括范围端点)。
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=68ab5a85ed2b10720a3755fb2b5a639e -->

<!-- pgdoc-cn_start sig_en=1deb3e5e9a3867e730423f27b3122cc7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between (the negation of <literal>BETWEEN</literal>).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间 (<literal>BETWEEN</literal>的否定).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1deb3e5e9a3867e730423f27b3122cc7 -->

<!-- pgdoc-cn_start sig_en=e2982c511484b5dd336912421da87d73 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e2982c511484b5dd336912421da87d73 -->

<!-- pgdoc-cn_start sig_en=40eb393d1aacbf7ae95311aece328293 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=40eb393d1aacbf7ae95311aece328293 -->

<!-- pgdoc-cn_start sig_en=9714568084f6a4b60adf6676371de20a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9714568084f6a4b60adf6676371de20a -->

<!-- pgdoc-cn_start sig_en=6f334bc43139e29d430e6c97fda0cd1c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f334bc43139e29d430e6c97fda0cd1c -->

<!-- pgdoc-cn_start sig_en=4c73da8deeeed454879a9946536033b0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null.
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空。
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c73da8deeeed454879a9946536033b0 -->

<!-- pgdoc-cn_start sig_en=7c82eb8ae81a9c3cc35bee9671b0feed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null.
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空。
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7c82eb8ae81a9c3cc35bee9671b0feed -->

<!-- pgdoc-cn_start sig_en=8279f7650f07c999b6a89da01dcbc14e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null (nonstandard syntax).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空（非标准语法）。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8279f7650f07c999b6a89da01dcbc14e -->

<!-- pgdoc-cn_start sig_en=92718012724e34eecc2130bdb5d1572a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null (nonstandard syntax).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空（非标准语法）。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=92718012724e34eecc2130bdb5d1572a -->

<!-- pgdoc-cn_start sig_en=e8bb1a4c4da77db14c024774dabfa305 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true.
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真。
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e8bb1a4c4da77db14c024774dabfa305 -->

<!-- pgdoc-cn_start sig_en=c07c5202357d177dd01a52926737c9be sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false or unknown.
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假或未知。
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c07c5202357d177dd01a52926737c9be -->

<!-- pgdoc-cn_start sig_en=f8576a1a81fd909ea95227b5c3f8cb3b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false.
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假。
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8576a1a81fd909ea95227b5c3f8cb3b -->

<!-- pgdoc-cn_start sig_en=5ef6af249e1259e52b4688a8dabecc11 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or unknown.
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或未知。
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5ef6af249e1259e52b4688a8dabecc11 -->

<!-- pgdoc-cn_start sig_en=250882ac9feccbaca5b31b4d31d4e465 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields unknown.
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为未知。
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=250882ac9feccbaca5b31b4d31d4e465 -->

<!-- pgdoc-cn_start sig_en=6f93e4ff572a7e9c5b71435f90191a5a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or false.
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或假。
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f93e4ff572a7e9c5b71435f90191a5a -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=ef06245d81dc40fee61f5ce6f7c3f052 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    The <token>BETWEEN</token> predicate simplifies range tests:
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    is equivalent to
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    <token>BETWEEN</token>谓词可以简化范围测试：
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    等效于
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    注意<token>BETWEEN</token>认为终点值是包含在范围内的。
    <literal>BETWEEN SYMMETRIC</literal> 就像<literal>BETWEEN</literal>，除了没有要求<literal>AND</literal>的左边的参数小于或等于右边的参数。
    如果不是的话，这两个参数将自动交换，因此总是隐含一个非空范围。。
   </para>
<!-- pgdoc-cn_end sig_en=ef06245d81dc40fee61f5ce6f7c3f052 -->

<!-- pgdoc-cn_start sig_en=3a5c55e4a7531231c68c1d61c22463a5 sig_cn_org=None source=14.1 
   <para>
    The various variants of <literal>BETWEEN</literal> are implemented in
    terms of the ordinary comparison operators, and therefore will work for
    any data type(s) that can be compared.
   </para>
________________________________________________________-->
   <para>
    <literal>BETWEEN</literal>的各种变量都是以普通比较操作符的方式实现的，因此适用于任何可以比较的数据类型。
   </para>
<!-- pgdoc-cn_end sig_en=3a5c55e4a7531231c68c1d61c22463a5 -->

   <note>
<!-- pgdoc-cn_start sig_en=11af8b011a6f7223c5bf5c1ebd827183 sig_cn_org=None source=14.1 
    <para>
     The use of <literal>AND</literal> in the <literal>BETWEEN</literal>
     syntax creates an ambiguity with the use of <literal>AND</literal> as a
     logical operator.  To resolve this, only a limited set of expression
     types are allowed as the second argument of a <literal>BETWEEN</literal>
     clause.  If you need to write a more complex sub-expression
     in <literal>BETWEEN</literal>, write parentheses around the
     sub-expression.
    </para>
________________________________________________________-->
    <para>
     在<literal>BETWEEN</literal>语法中使用<literal>AND</literal>会与使用<literal>AND</literal>作为逻辑操作符产生歧义。 
     为了解决这个问题，只允许有限的一组表达类型作为<literal>BETWEEN</literal>子句的第二个参数。 
     如果您需要在<literal>BETWEEN</literal>中写一个更复杂的子表达式，在子表达式两边写上圆括号。
    </para>
<!-- pgdoc-cn_end sig_en=11af8b011a6f7223c5bf5c1ebd827183 -->
   </note>

<!-- pgdoc-cn_start sig_en=8ebaf6b6a9890dffdd6e7ccd47ff8aa7 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    当有一个输入为空时，普通的比较操作符会得到空（表示<quote>未知</quote>），而不是真或假。例如，<literal>7 = NULL</literal>得到空，<literal>7 &lt;&gt; NULL</literal>也一样。如果这种行为不合适，可以使用<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>谓词：
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    对于非空输入，<literal>IS DISTINCT FROM</literal>和<literal>&lt;&gt;</literal>操作符一样。不过，如果两个输入都为空，它会返回假。而如果只有一个输入为空，它会返回真。类似地，<literal>IS NOT DISTINCT FROM</literal>对于非空输入的行为与<literal>=</literal>相同，但是当两个输入都为空时它返回真，并且当只有一个输入为空时返回假。因此，这些谓词实际上把空值当作一种普通数据值而不是<quote>unknown</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=8ebaf6b6a9890dffdd6e7ccd47ff8aa7 -->

<!-- pgdoc-cn_start sig_en=c539d75c5e84375bf3b8a9f55e7aa08f sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    To check whether a value is or is not null, use the predicates:
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    or the equivalent, but nonstandard, predicates:
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    要检查一个值是否为空，使用下面的谓词：
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    或者等效，但并不标准的谓词：
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>
<!-- pgdoc-cn_end sig_en=c539d75c5e84375bf3b8a9f55e7aa08f -->

<!-- pgdoc-cn_start sig_en=474c9df569a066e07982a6f9c9af61d0 sig_cn_org=None source=14.1 
   <para>
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
   </para>
________________________________________________________-->
   <para>
    <emphasis>不要</emphasis>写<literal><replaceable>expression</replaceable> = NULL</literal>，因为<literal>NULL</literal>是不<quote>等于</quote><literal>NULL</literal>的（控制代表一个未知的值，因此我们无法知道两个未知的数值是否相等）。
   </para>
<!-- pgdoc-cn_end sig_en=474c9df569a066e07982a6f9c9af61d0 -->

  <tip>
<!-- pgdoc-cn_start sig_en=6f2ed73ec9a67104643a743234613460 sig_cn_org=None source=14.1 
   <para>
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
   </para>
________________________________________________________-->
   <para>
    有些应用可能要求表达式<literal><replaceable>expression</replaceable> = NULL</literal>在<replaceable>expression</replaceable>得出空值时返回真。我们强烈建议这样的应用修改成遵循 SQL 标准。但是，如果这样修改不可能完成，那么我们可以使用配置变量<xref linkend="guc-transform-null-equals"/>。如果打开它，<productname>PostgreSQL</productname>将把<literal>x = NULL</literal>子句转换成<literal>x IS NULL</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=6f2ed73ec9a67104643a743234613460 -->
  </tip>

<!-- pgdoc-cn_start sig_en=22d0891bebe8a71f08748f39621d9366 sig_cn_org=None source=14.1 
   <para>
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
   </para>
________________________________________________________-->
   <para>
    如果<replaceable>expression</replaceable>是行值，那么当行表达式本身为非空值或者行的所有域为非空时<literal>IS NULL</literal>为真。由于这种行为，<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>并不总是为行值表达式返回反转的结果，特别是，一个同时包含 NULL 和非空值的域将会对两种测试都返回假。在某些情况下，写成<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>或者<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>会更好，它们只会检查整个行值是否为空而不需要在行的域上做额外的测试。
   </para>
<!-- pgdoc-cn_end sig_en=22d0891bebe8a71f08748f39621d9366 -->

<!-- pgdoc-cn_start sig_en=0a4c1f057a2abf7972cc52a0e228d6a1 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    Boolean values can also be tested using the predicates
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    布尔值也可以使用下列谓词进行测试：
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    这些谓词将总是返回真或假，从来不返回空值，即使操作数是空也如此。空值输入被当做逻辑值<quote>未知</quote>。 请注意实际上<literal>IS UNKNOWN</literal>和<literal>IS NOT UNKNOWN</literal>分别与<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>相同， 只是输入表达式必须是布尔类型。
   </para>
<!-- pgdoc-cn_end sig_en=0a4c1f057a2abf7972cc52a0e228d6a1 -->

<!-- pgdoc-cn_start sig_en=923c3d0990bcbf0210e5037bb6f0d090 sig_cn_org=None source=14.1 
   <para>
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
   </para>
________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-func-table"/>中所示，也有一些比较相关的函数可用。
   </para>
<!-- pgdoc-cn_end sig_en=923c3d0990bcbf0210e5037bb6f0d090 -->

  <table id="functions-comparison-func-table">
<!-- pgdoc-cn_start sig_en=0bcb0ad8ed18e7ddfb912fe7e4014b7f sig_cn_org=None source=14.1 
    <title>Comparison Functions</title>
________________________________________________________-->
    <title>比较函数</title>
<!-- pgdoc-cn_end sig_en=0bcb0ad8ed18e7ddfb912fe7e4014b7f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=e0db020ab696bbc176703040dcc45df8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of non-null arguments.
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回非空参数的数量。
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e0db020ab696bbc176703040dcc45df8 -->
<!-- pgdoc-cn_start sig_en=35bcce738eaf2f266a947f482a76f273 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of null arguments.
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回空参数的数量。
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=35bcce738eaf2f266a947f482a76f273 -->
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!-- pgdoc-cn_start sig_en=c188f0a13fbce3ec8570ade057198435 sig_cn_org=None source=14.1 
   <title>Mathematical Functions and Operators</title>
________________________________________________________-->
   <title>数学函数和操作符</title>
<!-- pgdoc-cn_end sig_en=c188f0a13fbce3ec8570ade057198435 -->

<!-- pgdoc-cn_start sig_en=f0f66d209604dc4ac5bf0db8e51b6508 sig_cn_org=None source=14.1 
   <para>
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>为很多类型提供了数学操作符。对于那些没有标准数学表达的类型（如日期/时间类型），我们将在后续小节中描述实际的行为。
   </para>
<!-- pgdoc-cn_end sig_en=f0f66d209604dc4ac5bf0db8e51b6508 -->

<!-- pgdoc-cn_start sig_en=8fb769d54daae0635c1255c0f312489a sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-math-op-table"/> shows the mathematical
    operators that are available for the standard numeric types.
    Unless otherwise noted, operators shown as
    accepting <replaceable>numeric_type</replaceable> are available for all
    the types <type>smallint</type>, <type>integer</type>,
    <type>bigint</type>, <type>numeric</type>, <type>real</type>,
    and <type>double precision</type>.
    Operators shown as accepting <replaceable>integral_type</replaceable>
    are available for the types <type>smallint</type>, <type>integer</type>,
    and <type>bigint</type>.
    Except where noted, each form of an operator returns the same data type
    as its argument(s).  Calls involving multiple argument data types, such
    as <type>integer</type> <literal>+</literal> <type>numeric</type>,
    are resolved by using the type appearing later in these lists.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-math-op-table"/> 显示了可用于标准数字类型的数学操作符。.
    除非另有说明, 显示为可接受 <replaceable>numeric_type</replaceable> 的操作符对所有的 <type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type> 和 <type>double precision</type>类型都可用。
    显示为可接受 <replaceable>integral_type</replaceable> 的操作符对 <type>smallint</type>、<type>integer</type> 和 <type>bigint</type>类型是可用的。
    除了特别说明之处，操作符的每种形式都返回与其参数相同的数据类型。
    涉及多个参数数据类型的调用， 例如 <type>integer</type> <literal>+</literal> <type>numeric</type>，可通过使用这些列表中稍后出现的类型来解析。
   </para>
<!-- pgdoc-cn_end sig_en=8fb769d54daae0635c1255c0f312489a -->

   <table id="functions-math-op-table">
<!-- pgdoc-cn_start sig_en=551397f2f13888d73629b11ab0104054 sig_cn_org=None source=14.1 
    <title>Mathematical Operators</title>
________________________________________________________-->
    <title>数学操作符</title>
<!-- pgdoc-cn_end sig_en=551397f2f13888d73629b11ab0104054 -->

    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=22e3af2abb8fa2b384071cc1e1c3f1d9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        加
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22e3af2abb8fa2b384071cc1e1c3f1d9 -->

<!-- pgdoc-cn_start sig_en=d4c3a4c7d41397f422f317dfe2954b9e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        一元加(无操作)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4c3a4c7d41397f422f317dfe2954b9e -->

<!-- pgdoc-cn_start sig_en=56babc3a689ed01a06d91a0cdcf09a08 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        减
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=56babc3a689ed01a06d91a0cdcf09a08 -->

<!-- pgdoc-cn_start sig_en=76b365b8cd3c2e6284153b883b1843c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Negation
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        否定
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=76b365b8cd3c2e6284153b883b1843c1 -->

<!-- pgdoc-cn_start sig_en=22bd50ad4ef95d0763d4e511d85f4c4e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        乘
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22bd50ad4ef95d0763d4e511d85f4c4e -->

<!-- pgdoc-cn_start sig_en=1f9a470daf2c76820183aec14a05c0a2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Division (for integral types, division truncates the result towards
        zero)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        除(对于整型，除法将结果截断为零)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1f9a470daf2c76820183aec14a05c0a2 -->

<!-- pgdoc-cn_start sig_en=b5b2b8fe824192f95e6e793daa31c522 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder); available for <type>smallint</type>,
        <type>integer</type>, <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        模（取余）; 适用于 <type>smallint</type>，<type>integer</type>，<type>bigint</type> 和 <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b5b2b8fe824192f95e6e793daa31c522 -->

<!-- pgdoc-cn_start sig_en=9bfa2257cd40c8c15e5deab649a71808 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponentiation
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        Unlike typical mathematical practice, multiple uses of
        <literal>^</literal> will associate left to right by default:
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para>
       <para>
        <literal>2 ^ (3 ^ 3)</literal>
        <returnvalue>134217728</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        不像典型的数学实践，多次使用 <literal>^</literal> 将会默认从左到右关联:
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para>
       <para>
        <literal>2 ^ (3 ^ 3)</literal>
        <returnvalue>134217728</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9bfa2257cd40c8c15e5deab649a71808 -->

<!-- pgdoc-cn_start sig_en=ed8e4076610a4c9ea082c3052e5b53ad sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ed8e4076610a4c9ea082c3052e5b53ad -->

<!-- pgdoc-cn_start sig_en=7a1100232e19cd28b4a4ab74ca3f8c46 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7a1100232e19cd28b4a4ab74ca3f8c46 -->

<!-- pgdoc-cn_start sig_en=083685009cd60c7bd75aa66330185d98 sig_cn_org=f322e58da7be2985cd7d5a6d5d61dfa9 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5.0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5.0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=083685009cd60c7bd75aa66330185d98 -->

<!-- pgdoc-cn_start sig_en=7449283640d1b8660b41d1e5c57b7626 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise AND
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位与(AND)
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7449283640d1b8660b41d1e5c57b7626 -->

<!-- pgdoc-cn_start sig_en=184e222ec91b5d9d2bb79eacff67dff4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise OR
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位或(OR)
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=184e222ec91b5d9d2bb79eacff67dff4 -->

<!-- pgdoc-cn_start sig_en=697876d3807a63a6c5fbcc2be7fcfaa3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise exclusive OR
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位异或(exclusive OR)
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=697876d3807a63a6c5fbcc2be7fcfaa3 -->

<!-- pgdoc-cn_start sig_en=112087894c1e294798361563a8f66238 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位求反(NOT)
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=112087894c1e294798361563a8f66238 -->

<!-- pgdoc-cn_start sig_en=91a5dd40242d38c99940a6193420c101 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift left
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位左移
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=91a5dd40242d38c99940a6193420c101 -->

<!-- pgdoc-cn_start sig_en=a1f7df19fcd971f2e534bbbfe2163278 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift right
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位右移
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a1f7df19fcd971f2e534bbbfe2163278 -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=1d8183522513c5abc24a2a0b9ba8aedf sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.
   Many of these functions are provided in multiple forms with different
   argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument(s); cross-type cases are resolved in the
   same way as explained above for operators.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-math-func-table"/> 显示了可用的数学函数。
   许多这样的函数以多种具有不同的参数类型的形式提供。
   除非注明，任何给定形式的函数都返回与其参数相同的数据类型;跨类型情况的解决方法与上述对操作符的解释相同。
   使用<type>double precision</type>数据的函数大多是在主机系统的C库上实现的;
   因此，边界情况下的准确性和行为会因主机系统的区别而不同。
  </para>
<!-- pgdoc-cn_end sig_en=1d8183522513c5abc24a2a0b9ba8aedf -->

   <table id="functions-math-func-table">
<!-- pgdoc-cn_start sig_en=c44d72ea2d5872d33f44fe37af7a87c5 sig_cn_org=None source=14.1 
    <title>Mathematical Functions</title>
________________________________________________________-->
    <title>数学函数</title>
<!-- pgdoc-cn_end sig_en=c44d72ea2d5872d33f44fe37af7a87c5 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=500f3b650baddc716e7ad2588f6358e2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=500f3b650baddc716e7ad2588f6358e2 -->

<!-- pgdoc-cn_start sig_en=4f0552380d2f420207c9c4861e413183 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4f0552380d2f420207c9c4861e413183 -->

<!-- pgdoc-cn_start sig_en=fbf9543b6b60b52f363db6860f514920 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fbf9543b6b60b52f363db6860f514920 -->

<!-- pgdoc-cn_start sig_en=e7b291001dcc2854fce4550cbce9cc73 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument (same
        as <function>ceil</function>)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数 (与 <function>ceil</function> 相同)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e7b291001dcc2854fce4550cbce9cc73 -->

<!-- pgdoc-cn_start sig_en=f0309f1537a87adf85ee740ccd5aa121 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts radians to degrees
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将弧度转换为角度
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f0309f1537a87adf85ee740ccd5aa121 -->

<!-- pgdoc-cn_start sig_en=ecb05098746acbffa03f8d3dc4459e37 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Integer quotient of <parameter>y</parameter>/<parameter>x</parameter>
        (truncates towards zero)
       </para>
       <para>
        <literal>div(9, 4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter> 的整数商（截断为零位）
       </para>
       <para>
        <literal>div(9, 4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ecb05098746acbffa03f8d3dc4459e37 -->

<!-- pgdoc-cn_start sig_en=fec4ba25429650bb2b25a054032b4a92 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponential (<literal>e</literal> raised to the given power)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数 (<literal>e</literal> 的给定次方)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fec4ba25429650bb2b25a054032b4a92 -->

<!-- pgdoc-cn_start sig_en=f04ba2d7cc7dbcadce2ba413f74572f7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f04ba2d7cc7dbcadce2ba413f74572f7 -->

<!-- pgdoc-cn_start sig_en=a42dc181a57fa53f4e8611b3bbec4776 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to argument
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        小于或等于参数的最接近整数
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a42dc181a57fa53f4e8611b3bbec4776 -->

<!-- pgdoc-cn_start sig_en=7e86a78d704dc4cc1d5e17389349691e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Greatest common divisor (the largest positive number that divides both
        inputs with no remainder); returns <literal>0</literal> if both inputs
        are zero; available for <type>integer</type>, <type>bigint</type>,
        and <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最大公约数 (能将两个输入数整除而无余数的最大正数); 如果两个输入为零则返回 <literal>0</literal> ; 适用于 <type>integer</type>, <type>bigint</type>,和 <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e86a78d704dc4cc1d5e17389349691e -->

<!-- pgdoc-cn_start sig_en=d9b1b4ae899760c43a36bccdd7d3350f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Least common multiple (the smallest strictly positive number that is
        an integral multiple of both inputs); returns <literal>0</literal> if
        either input is zero; available for <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最小公倍数(两个输入的整数倍的最小的严格正数)；如果任意一个输入值为零则返回<literal>0</literal>；适用于<type>integer</type>，<type>bigint</type>，和 <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d9b1b4ae899760c43a36bccdd7d3350f -->

<!-- pgdoc-cn_start sig_en=1bb999da1620320e5146bfa69f3de6ea sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Natural logarithm
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        自然对数
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1bb999da1620320e5146bfa69f3de6ea -->

<!-- pgdoc-cn_start sig_en=96093cc5a1b2663655ef84ce48c7a3a9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=96093cc5a1b2663655ef84ce48c7a3a9 -->

<!-- pgdoc-cn_start sig_en=f1daca3b6b7259c11e900750a138e5f5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm (same as <function>log</function>)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数 (与 <function>log</function> 相同)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f1daca3b6b7259c11e900750a138e5f5 -->

<!-- pgdoc-cn_start sig_en=5636781c6d7ec9fd112025ec254e4486 sig_cn_org=c568984b40c593bf833becdb9da0c94d source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Logarithm of <parameter>x</parameter> to base <parameter>b</parameter>
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000000000</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        以<parameter>b</parameter>为底对参数<parameter>x</parameter>取对数
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000000000</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5636781c6d7ec9fd112025ec254e4486 -->

<!-- pgdoc-cn_start sig_en=3a04c58897ccf3891f522cc4a999d1c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Minimum scale (number of fractional decimal digits) needed
        to represent the supplied value precisely
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        精确表示所提供值所需的最小刻度（小数位数）
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3a04c58897ccf3891f522cc4a999d1c1 -->

<!-- pgdoc-cn_start sig_en=ddea2674deaac8474916376216ed4238 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Remainder of <parameter>y</parameter>/<parameter>x</parameter>;
        available for <type>smallint</type>, <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>mod(9, 4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的余数；
        适用于<type>smallint</type>、<type>integer</type>、<type>bigint</type>、和 <type>numeric</type>
       </para>
       <para>
        <literal>mod(9, 4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ddea2674deaac8474916376216ed4238 -->

<!-- pgdoc-cn_start sig_en=caa3a160b6ab5dcf954ed59ab5d004dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Approximate value of <phrase role="symbol_font">&pi;</phrase>
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <phrase role="symbol_font">&pi;</phrase>的近似值
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=caa3a160b6ab5dcf954ed59ab5d004dc -->

<!-- pgdoc-cn_start sig_en=06ddb6259764d9eef06cd39715951f58 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter> raised to the power of <parameter>b</parameter>
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter>的<parameter>b</parameter>次幂
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=06ddb6259764d9eef06cd39715951f58 -->

<!-- pgdoc-cn_start sig_en=1baff451ccc07838cb108a5161a440b5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts degrees to radians
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将角度转换为弧度
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1baff451ccc07838cb108a5161a440b5 -->

<!-- pgdoc-cn_start sig_en=4f33dbab5ab3bcd64226f875869da3f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Rounds to nearest integer.  For <type>numeric</type>, ties are
        broken by rounding away from zero.  For <type>double precision</type>,
        the tie-breaking behavior is platform dependent, but
        <quote>round to nearest even</quote> is the most common rule.
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        四舍五入到最近的整数。
        对于<type>numeric</type>，通过从零舍入来截断ties。
        对于<type>double precision</type>，tie-breaking行为取决于平台，但是<quote>round to nearest even</quote>是最常见的规则。
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4f33dbab5ab3bcd64226f875869da3f0 -->

<!-- pgdoc-cn_start sig_en=0fea487bae0c900127f8771640b53a1e sig_cn_org=0fea487bae0c900127f8771640b53a1e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        将 <parameter>v</parameter> 四舍五入到 <parameter>s</parameter> 位小数。
        当出现平局时，通过远离零的方向进行四舍五入来解决。
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para>
       <para>
        <literal>round(1234.56, -1)</literal>
        <returnvalue>1230</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Rounds <parameter>v</parameter> to <parameter>s</parameter> decimal
        places.  Ties are broken by rounding away from zero.
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para>
       <para>
        <literal>round(1234.56, -1)</literal>
        <returnvalue>1230</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0fea487bae0c900127f8771640b53a1e -->

<!-- pgdoc-cn_start sig_en=4ace4c1336e0472d4d4a3931bb3689a6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Scale of the argument (the number of decimal digits in the fractional part)
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        参数的刻度（小数点后的位数）
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4ace4c1336e0472d4d4a3931bb3689a6 -->

<!-- pgdoc-cn_start sig_en=47ba21e5728b887f996c2ac26e982ca7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sign of the argument (-1, 0, or +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        参数的符号 (-1, 0, 或 +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=47ba21e5728b887f996c2ac26e982ca7 -->

<!-- pgdoc-cn_start sig_en=dedd122d21e01318cc9c23bd55b82318 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dedd122d21e01318cc9c23bd55b82318 -->

<!-- pgdoc-cn_start sig_en=47d86c32e319131a65a490c0042b7187 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Reduces the value's scale (number of fractional decimal digits) by
        removing trailing zeroes
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        通过删除尾数部分的零来降低值的刻度(小数位数)
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=47d86c32e319131a65a490c0042b7187 -->

<!-- pgdoc-cn_start sig_en=0309181d6b7d483db67ed7d31a18b996 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Truncates to integer (towards zero)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        截断整数 (向零靠近)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0309181d6b7d483db67ed7d31a18b996 -->

<!-- pgdoc-cn_start sig_en=e0e8d43b54261f2905029cd5c5bf18b9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Truncates <parameter>v</parameter> to <parameter>s</parameter>
        decimal places
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        截断 <parameter>v</parameter> 到 <parameter>s</parameter> 位小数位置的数字
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e0e8d43b54261f2905029cd5c5bf18b9 -->

<!-- pgdoc-cn_start sig_en=081bb1fd0c94338fd6c3d8c56f350439 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls in a histogram
        having <parameter>count</parameter> equal-width buckets spanning the
        range <parameter>low</parameter> to <parameter>high</parameter>.
        Returns <literal>0</literal>
        or <literal><parameter>count</parameter>+1</literal> for an input
        outside that range.
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回包含<parameter>count</parameter>等宽柱的柱状图中<parameter>operand</parameter>所在的柱的编号，范围从<parameter>low</parameter>到<parameter>high</parameter>。
        超出该范围的输入则返回<literal>0</literal>或<literal><parameter>计数</parameter>+1</literal>。
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=081bb1fd0c94338fd6c3d8c56f350439 -->

<!-- pgdoc-cn_start sig_en=0b0b03ac06c4eed81566d440f5884918 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anycompatible</type>, <parameter>thresholds</parameter> <type>anycompatiblearray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls given an array listing the
        lower bounds of the buckets.  Returns <literal>0</literal> for an
        input less than the first lower
        bound.  <parameter>operand</parameter> and the array elements can be
        of any type having standard comparison operators.
        The <parameter>thresholds</parameter> array <emphasis>must be
        sorted</emphasis>, smallest first, or unexpected results will be
        obtained.
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anycompatible</type>, <parameter>thresholds</parameter> <type>anycompatiblearray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个柱号，这个柱是在给定数组中<parameter>operand</parameter>将被分配的柱。
        对于一个低于第一个下界的输入返回<literal>0</literal>。
        <parameter>operand</parameter>和数组元素可以是具有标准比较操作符的任何类型。
        <parameter>thresholds</parameter>数组<emphasis>必须被排好序</emphasis>，最小的排在最前面，否则将会得到意想不到的结果。
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0b0b03ac06c4eed81566d440f5884918 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=0d69fd5f40ac8a2113212b5feac7ab0e sig_cn_org=None source=14.1 
  <para>
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
  </para>
________________________________________________________-->
  <para>
    <xref linkend="functions-math-random-table"/>展示了用于产生随机数的函数。
  </para>
<!-- pgdoc-cn_end sig_en=0d69fd5f40ac8a2113212b5feac7ab0e -->

   <table id="functions-math-random-table">
<!-- pgdoc-cn_start sig_en=b57eedb28cc14231a78430a0d1a86146 sig_cn_org=None source=14.1 
    <title>Random Functions</title>
________________________________________________________-->
    <title>随机函数</title>
<!-- pgdoc-cn_end sig_en=b57eedb28cc14231a78430a0d1a86146 -->

    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=f0f2a23e2a7545793d1401befecb95f4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns a random value in the range 0.0 &lt;= x &lt; 1.0
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回一个范围 0.0 &lt;= x &lt; 1.0 中的随机值
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f0f2a23e2a7545793d1401befecb95f4 -->

<!-- pgdoc-cn_start sig_en=74ac27e14c8aa59049ce7ac669bc7e16 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Sets the seed for subsequent <literal>random()</literal> calls;
        argument must be between -1.0 and 1.0, inclusive
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        为后续的<literal>random()</literal>调用设置种子；参数必须在-1.0和1.0之间，包括边界值
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74ac27e14c8aa59049ce7ac669bc7e16 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=d6ee9d5d18320e28d156ce99db543bd3 sig_cn_org=0a1c945b2a3bcd3a8b166d5e94140a8f source=15.7 
  <para>
   The <function>random()</function> function uses a deterministic
   pseudo-random number generator.
   It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the series of results of
   subsequent <function>random()</function> calls in the current session
   can be repeated by re-issuing <function>setseed()</function> with the same
   argument.
   Without any prior <function>setseed()</function> call in the same
   session, the first <function>random()</function> call obtains a seed
   from a platform-dependent source of random bits.
  </para>
________________________________________________________-->
  <para>
   <function>random()</function>函数使用确定性伪随机数生成器。
   它速度快，但不适用于加密应用；请参阅<xref linkend="pgcrypto"/>模块以获取更安全的替代方案。
   如果调用<function>setseed()</function>，则当前会话中后续<function>random()</function>调用的结果序列可以通过使用相同参数重新发出<function>setseed()</function>来重复。
   在同一会话中没有任何先前的<function>setseed()</function>调用时，第一个<function>random()</function>调用从平台相关的随机位源获取种子。
</para>
<!-- pgdoc-cn_end sig_en=d6ee9d5d18320e28d156ce99db543bd3 -->

<!-- pgdoc-cn_start sig_en=fed7b3a3aab3ce94adfa69cc4e9d244e sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  Each of these functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-math-trig-table"/>显示了可用的三角函数。
   每一种这样的函数都有两个变体，一个以弧度度量角，另一个以角度度量角。
  </para>
<!-- pgdoc-cn_end sig_en=fed7b3a3aab3ce94adfa69cc4e9d244e -->

   <table id="functions-math-trig-table">
<!-- pgdoc-cn_start sig_en=5c966da25890bb0b30c9ca6f669aeefa sig_cn_org=None source=14.1 
    <title>Trigonometric Functions</title>
________________________________________________________-->
    <title>三角函数</title>
<!-- pgdoc-cn_end sig_en=5c966da25890bb0b30c9ca6f669aeefa -->

    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=3b4a3f05f938f94712f19947f1a355a5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in radians
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为弧度
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b4a3f05f938f94712f19947f1a355a5 -->

<!-- pgdoc-cn_start sig_en=e93e5497d451f491d74bc348764714d1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in degrees
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为度数
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e93e5497d451f491d74bc348764714d1 -->

<!-- pgdoc-cn_start sig_en=6bbf0555ec8d9e5f85fdc142e7bc41a8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in radians
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为弧度
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6bbf0555ec8d9e5f85fdc142e7bc41a8 -->

<!-- pgdoc-cn_start sig_en=2ee08e00f8804d27cb542fc5aa598181 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in degrees
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为度数
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ee08e00f8804d27cb542fc5aa598181 -->

<!-- pgdoc-cn_start sig_en=99998468776af00189df867fec2ebc67 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in radians
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为弧度
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=99998468776af00189df867fec2ebc67 -->

<!-- pgdoc-cn_start sig_en=a4ff8ff1b8332b49f75a33df5c9ed5cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in degrees
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为度数
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a4ff8ff1b8332b49f75a33df5c9ed5cb -->

<!-- pgdoc-cn_start sig_en=4286a03862776dbb12b66618b5dc3f27 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in radians
       </para>
       <para>
        <literal>atan2(1, 0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为弧度
       </para>
       <para>
        <literal>atan2(1, 0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4286a03862776dbb12b66618b5dc3f27 -->

<!-- pgdoc-cn_start sig_en=39dec5da4eadf80ef6b7e2f53a843c86 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in degrees
       </para>
       <para>
        <literal>atan2d(1, 0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为度数
       </para>
       <para>
        <literal>atan2d(1, 0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=39dec5da4eadf80ef6b7e2f53a843c86 -->

<!-- pgdoc-cn_start sig_en=789b924f515a9e7cfc05e952739b4a57 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in radians
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为弧度
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=789b924f515a9e7cfc05e952739b4a57 -->

<!-- pgdoc-cn_start sig_en=0ff579ac779fb263dc07abe0b104cc27 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in degrees
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为度数
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0ff579ac779fb263dc07abe0b104cc27 -->

<!-- pgdoc-cn_start sig_en=3cd120b93e45629e81be572e36d7ee2d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in radians
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为弧度
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cd120b93e45629e81be572e36d7ee2d -->

<!-- pgdoc-cn_start sig_en=72d2f43055549ce2f09c191559ffecd9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in degrees
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为度数
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=72d2f43055549ce2f09c191559ffecd9 -->

<!-- pgdoc-cn_start sig_en=180dd4164c373ec3ce5e0bb180a0796b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in radians
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为弧度
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=180dd4164c373ec3ce5e0bb180a0796b -->

<!-- pgdoc-cn_start sig_en=fdf2ce7d9af1adf095d61306d17cb76c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in degrees
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为度数
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fdf2ce7d9af1adf095d61306d17cb76c -->

<!-- pgdoc-cn_start sig_en=6c24df1996da3a8c75b1623ec4c1c5d2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in radians
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为弧度
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6c24df1996da3a8c75b1623ec4c1c5d2 -->

<!-- pgdoc-cn_start sig_en=53799f819ea762821caef1446b808680 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in degrees
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为度数
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=53799f819ea762821caef1446b808680 -->
     </tbody>
    </tgroup>
   </table>

  <note>
<!-- pgdoc-cn_start sig_en=e8658e994db946f9fc0db811d05c4570 sig_cn_org=None source=14.1 
   <para>
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
   </para>
________________________________________________________-->
   <para>
    另一种使用以角度度量的角的方法是使用早前展示的单位转换函数<literal><function>radians()</function></literal>和<literal><function>degrees()</function></literal>。不过，使用基于角度的三角函数更好，因为这类方法能避免<literal>sind(30)</literal>等特殊情况下的舍入偏差。
   </para>
<!-- pgdoc-cn_end sig_en=e8658e994db946f9fc0db811d05c4570 -->
  </note>

<!-- pgdoc-cn_start sig_en=375896231b27392834c2610344982c93 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-math-hyp-table"/>显示的是可用的双曲函数。
  </para>
<!-- pgdoc-cn_end sig_en=375896231b27392834c2610344982c93 -->

  <table id="functions-math-hyp-table">
<!-- pgdoc-cn_start sig_en=7419d3b1c109e70f89318c0ce7824f0f sig_cn_org=None source=14.1 
    <title>Hyperbolic Functions</title>
________________________________________________________-->
    <title>双曲函数</title>
<!-- pgdoc-cn_end sig_en=7419d3b1c109e70f89318c0ce7824f0f -->

    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=867b213a984f91dcefb7c1fbfb15a2ca sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic sine
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲正弦
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=867b213a984f91dcefb7c1fbfb15a2ca -->

<!-- pgdoc-cn_start sig_en=becfe3fa1633429cdff9e4055a338956 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic cosine
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲余弦
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=becfe3fa1633429cdff9e4055a338956 -->

<!-- pgdoc-cn_start sig_en=5c471cb5257dcae0a59a763d5d50b88e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic tangent
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲切线
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c471cb5257dcae0a59a763d5d50b88e -->

<!-- pgdoc-cn_start sig_en=d67713b37391ef6023fe7c053ca6aa9b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic sine
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲正弦
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d67713b37391ef6023fe7c053ca6aa9b -->

<!-- pgdoc-cn_start sig_en=876ef537855d525b00c0c8bde1b71121 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic cosine
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲余弦
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=876ef537855d525b00c0c8bde1b71121 -->

<!-- pgdoc-cn_start sig_en=631de47145f5aac9d9d75a99c0ed2a23 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic tangent
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲切线
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=631de47145f5aac9d9d75a99c0ed2a23 -->
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!-- pgdoc-cn_start sig_en=bd23892aae3b3e041a065cc6c8e9d501 sig_cn_org=None source=14.1 
   <title>String Functions and Operators</title>
________________________________________________________-->
   <title>字符串函数和操作符</title>
<!-- pgdoc-cn_end sig_en=bd23892aae3b3e041a065cc6c8e9d501 -->

<!-- pgdoc-cn_start sig_en=9f7e063bf5123e7afb36f7881ffe8283 sig_cn_org=None source=14.1 
   <para>
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Except where noted, these functions and operators
    are declared to accept and return type <type>text</type>.  They will
    interchangeably accept <type>character varying</type> arguments.
    Values of type <type>character</type> will be converted
    to <type>text</type> before the function or operator is applied, resulting
    in stripping any trailing spaces in the <type>character</type> value.
   </para>
________________________________________________________-->
   <para>
    本节描述了用于检查和操作字符串值的函数和操作符。
    在这个环境中的串包括所有类型<type>character</type>、<type>character varying</type>和<type>text</type>的值。
    除非特别说明，这些函数和操作符声明为接受并返回<type>text</type>类型。
    他们将互换接受<type>character varying</type>参数。
    在应用函数或操作符之前<type>character</type>类型的值将被转换为<type>text</type>，结果删除<type>character</type>值中的任何末尾空格。
   </para>
<!-- pgdoc-cn_end sig_en=9f7e063bf5123e7afb36f7881ffe8283 -->

<!-- pgdoc-cn_start sig_en=37ad72d5b0babc476de919054d80f8d8 sig_cn_org=None source=14.1 
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
   </para>
________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些字符串函数，它们使用关键字，而不是逗号来分隔参数。详情请见<xref linkend="functions-string-sql"/>，<productname>PostgreSQL</productname>也提供了这些函数使用正常函数调用语法的版本（见<xref linkend="functions-string-other"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=37ad72d5b0babc476de919054d80f8d8 -->

   <note>
<!-- pgdoc-cn_start sig_en=2e4fac32cff6597b91c9f835590f355d sig_cn_org=None source=14.1 
    <para>
     The string concatenation operator (<literal>||</literal>) will accept
     non-string input, so long as at least one input is of string type, as shown
     in <xref linkend="functions-string-sql"/>.  For other cases, inserting an
     explicit coercion to <type>text</type> can be used to have non-string input
     accepted.
    </para>
________________________________________________________-->
    <para>
     字符串串接操作符（<literal>||</literal>）将接受非字符串输入，只要至少一个输入是一种字符串类型，如<xref linkend="functions-string-sql"/>所示。
     对于其他情况，向<type>text</type>插入一个显式强制，可用于接受非字符串输入。
    </para>
<!-- pgdoc-cn_end sig_en=2e4fac32cff6597b91c9f835590f355d -->
   </note>

   <table id="functions-string-sql">
<!-- pgdoc-cn_start sig_en=4e1eb330f1b46e20234dc2f07fa39c37 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> String Functions and Operators</title>
________________________________________________________-->
    <title><acronym>SQL</acronym>字符串函数和操作符</title>
<!-- pgdoc-cn_end sig_en=4e1eb330f1b46e20234dc2f07fa39c37 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=b071f1d79cf6d985f320d5bdc1c1ae90 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the two strings.
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接两个字符串。
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b071f1d79cf6d985f320d5bdc1c1ae90 -->

<!-- pgdoc-cn_start sig_en=84653270af8c504af0b956c1e33ee4f2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the non-string input to text, then concatenates the two
        strings.  (The non-string input cannot be of an array type, because
        that would create ambiguity with the array <literal>||</literal>
        operators.  If you want to concatenate an array's text equivalent,
        cast it to <type>text</type> explicitly.)
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将非字符串输入转换为文本，然后将两个字符串串联在一起。
        （非字符串输入不能为数组类型，因为这将在<literal>||</literal>操作符的数组中造成歧义。如果你想连接一个数组的文本相等的，请显式地将其转换为<type>text</type> 。）
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=84653270af8c504af0b956c1e33ee4f2 -->

<!-- pgdoc-cn_start sig_en=74ba4aca699e53fede8d2f2bf8bfb073 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the string is in the specified Unicode normalization
        form.  The optional <parameter>form</parameter> key word specifies the
        form: <literal>NFC</literal> (the default), <literal>NFD</literal>,
        <literal>NFKC</literal>, or <literal>NFKD</literal>.  This expression can
        only be used when the server encoding is <literal>UTF8</literal>.  Note
        that checking for normalization using this expression is often faster
        than normalizing possibly already normalized strings.
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查字符串是否在指定的 Unicode 规范化表单中。
        可选的<parameter>form</parameter>关键词指定表单：<literal>NFC</literal> (默认的), <literal>NFD</literal>, <literal>NFKC</literal>, 或 <literal>NFKD</literal>。 
        只有在服务器编码为<literal>UTF8</literal>时，才能使用此表达式。
        请注意，使用这个表达式检查规范化通常比规范化可能已经规范化的字符串要快。
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74ba4aca699e53fede8d2f2bf8bfb073 -->

<!-- pgdoc-cn_start sig_en=67691a22b12a4b2a44232b689588ed52 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的位数(8倍于<function>octet_length</function>)。
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=67691a22b12a4b2a44232b689588ed52 -->

<!-- pgdoc-cn_start sig_en=32cd8725adfa930b1be9c65d66d6fad5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of characters in the string.
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=32cd8725adfa930b1be9c65d66d6fad5 -->

<!-- pgdoc-cn_start sig_en=f1f972804a07ee7edbc9a8f33ded8dbc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all lower case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的语言环境规则，将字符串转换为全部小写。
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f1f972804a07ee7edbc9a8f33ded8dbc -->

<!-- pgdoc-cn_start sig_en=d3d1efdedc0f2709e6249c7fead87d2d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to the specified Unicode
        normalization form.  The optional <parameter>form</parameter> key word
        specifies the form: <literal>NFC</literal> (the default),
        <literal>NFD</literal>, <literal>NFKC</literal>, or
        <literal>NFKD</literal>.  This function can only be used when the
        server encoding is <literal>UTF8</literal>.
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将字符串转换为指定的Unicode规范化形式。
        可选的<parameter>form</parameter>关键字指定了如下形式:<literal>NFC</literal> (the default)，<literal>NFD</literal>， <literal>NFKC</literal>，或<literal>NFKD</literal>。
        该函数只能在服务器编码为<literal>UTF8</literal>时使用。
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d3d1efdedc0f2709e6249c7fead87d2d -->

<!-- pgdoc-cn_start sig_en=9657ae7e63fb85a565eebffb205d6e2c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串的字节数。
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9657ae7e63fb85a565eebffb205d6e2c -->

<!-- pgdoc-cn_start sig_en=14b15ed941436f5dd680bfa60e5c6595 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.  Since this version of the
        function accepts type <type>character</type> directly, it will not
        strip trailing spaces.
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字节数。 由于此版本的函数直接接受<type>character</type>类型，它不会剥离尾随空格。
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=14b15ed941436f5dd680bfa60e5c6595 -->

<!-- pgdoc-cn_start sig_en=a54f4cb7b923f648221aec7036b3e622 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>string</parameter> that starts at
        the <parameter>start</parameter>'th character and extends
        for <parameter>count</parameter> characters
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，并用<parameter>newsubstring</parameter>扩展到<parameter>count</parameter>字符。
        如果省略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a54f4cb7b923f648221aec7036b3e622 -->

<!-- pgdoc-cn_start sig_en=9c96a1e1b5e5a07d3097a1fc567f1350 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns first starting index of the specified
        <parameter>substring</parameter> within
        <parameter>string</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<parameter>string</parameter>中指定的<parameter>substring</parameter>的第一个起始索引，如果不存在则返回零，。
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9c96a1e1b5e5a07d3097a1fc567f1350 -->

<!-- pgdoc-cn_start sig_en=8cc57dc2839e2333997b77691eee4718 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character if that is specified,
        and stopping after <parameter>count</parameter> characters if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果已指定，提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，
        并且在<parameter>count</parameter>字符后停止。如果已指定的话。 
        提供至少一个<parameter>start</parameter>和<parameter>count</parameter>中的至少一个。
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8cc57dc2839e2333997b77691eee4718 -->

<!-- pgdoc-cn_start sig_en=7162711fc73ac57caf80cba203710193 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the first substring matching POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配POSIX正则表达式的第一个子字符串; 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7162711fc73ac57caf80cba203710193 -->

<!-- pgdoc-cn_start sig_en=7e84e1af1afb67ac6d4154f0509a1f19 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>SIMILAR</literal> <parameter>pattern</parameter> <type>text</type> <literal>ESCAPE</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the first substring matching <acronym>SQL</acronym> regular expression;
        see <xref linkend="functions-similarto-regexp"/>.  The first form has
        been specified since SQL:2003; the second form was only in SQL:1999
        and should be considered obsolete.
       </para>
       <para>
        <literal>substring('Thomas' similar '%#"o_a#"_' escape '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>SIMILAR</literal> <parameter>pattern</parameter> <type>text</type> <literal>ESCAPE</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配 <acronym>SQL</acronym> 正则表达式的第一个字串；参见 <xref linkend="functions-similarto-regexp"/>。
        第一种形式自从SQL:2003被指定，第二种形式仅在SQL:1999中，并应认为是废弃的。
       </para>
       <para>
        <literal>substring('Thomas' similar '%#"o_a#"_' escape '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e84e1af1afb67ac6d4154f0509a1f19 -->

<!-- pgdoc-cn_start sig_en=f60e3d336ae962fc6a1b5f4c98fec686 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>string</parameter>.
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开始、末端或两端(默认为<literal>BOTH</literal> )移除仅包含<parameter>characters</parameter>(默认为空格)字符的最长字符串。
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f60e3d336ae962fc6a1b5f4c98fec686 -->

<!-- pgdoc-cn_start sig_en=15de434f3422e3e481393a5423581018 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        这是一个非标准的<function>trim()</function>语法。
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=15de434f3422e3e481393a5423581018 -->

<!-- pgdoc-cn_start sig_en=763aef3a5fa1feb85f7d2e1653386ccb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all upper case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的定位规则，将字符串转换为所有大写。
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=763aef3a5fa1feb85f7d2e1653386ccb -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=d077526c3330d5fcb76990a1f95566d4 sig_cn_org=d69498d46ed2b35cf2a3da88250fb26d source=15.7 
   <para>
    Additional string manipulation functions and operators are available
    and are listed in <xref linkend="functions-string-other"/>.  (Some of
    these are used internally to implement
    the <acronym>SQL</acronym>-standard string functions listed in
    <xref linkend="functions-string-sql"/>.)
    There are also pattern-matching operators, which are described in
    <xref linkend="functions-matching"/>, and operators for full-text
    search, which are described in <xref linkend="textsearch"/>.
   </para>
________________________________________________________-->
   <para>
    额外的字符串操作函数和运算符可用，并在<xref linkend="functions-string-other"/>中列出。
    （其中一些用于内部实现<xref linkend="functions-string-sql"/>中列出的<acronym>SQL</acronym>标准字符串函数。）
    还有用于描述的模式匹配运算符<xref linkend="functions-matching"/>，以及用于全文搜索的运算符，这些在<xref linkend="textsearch"/>中描述。
   </para>
<!-- pgdoc-cn_end sig_en=d077526c3330d5fcb76990a1f95566d4 -->

   <table id="functions-string-other">
<!-- pgdoc-cn_start sig_en=51797b9394e295327999a6f2c7384668 sig_cn_org=178d41c8eaa6ff5baae9dfa0c6072f40 source=15.7 
    <title>Other String Functions and Operators</title>
________________________________________________________-->
    <title>其他字符串函数和运算符</title>
<!-- pgdoc-cn_end sig_en=51797b9394e295327999a6f2c7384668 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=61764da0ba03f53b6f566d0febc58d65 sig_cn_org=a6533b59b264d96e5fc117fa4715e757 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>prefix test</secondary>
        </indexterm>
        <type>text</type> <literal>^@</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if the first string starts with the second string
        (equivalent to the <function>starts_with()</function> function).
       </para>
       <para>
        <literal>'alphabet' ^@ 'alph'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry">
           <para role="func_signature">
               <indexterm>
                   <primary>字符串</primary>
                   <secondary>前缀测试</secondary>
               </indexterm>
               <type>text</type> <literal>^@</literal> <type>text</type>
               <returnvalue>boolean</returnvalue>
           </para>
           <para>
               如果第一个字符串以第二个字符串开头，则返回true（等同于<function>starts_with()</function>函数）。
           </para>
           <para>
               <literal>'alphabet' ^@ 'alph'</literal>
               <returnvalue>t</returnvalue>
           </para>
       </entry>
</row>
<!-- pgdoc-cn_end sig_en=61764da0ba03f53b6f566d0febc58d65 -->

<!-- pgdoc-cn_start sig_en=376a431261b24595f073daec2e70db15 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the numeric code of the first character of the argument.
        In <acronym>UTF8</acronym> encoding, returns the Unicode code point
        of the character.  In other multibyte encodings, the argument must
        be an <acronym>ASCII</acronym> character.
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回参数的第一个字符的数字代码。在<acronym>UTF8</acronym>编码中，返回该字符的Unicode代码点。
        在其他多字节编码中，该参数必须是一个<acronym>ASCII</acronym>字符。
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=376a431261b24595f073daec2e70db15 -->

<!-- pgdoc-cn_start sig_en=d1e00d1c4b216d52bf06aa174dd7e589 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>.
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开头或结尾删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的字符串
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d1e00d1c4b216d52bf06aa174dd7e589 -->

<!-- pgdoc-cn_start sig_en=b8f6a44850c2e72247cc53bf9bf14290 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the character with the given code. In <acronym>UTF8</acronym>
        encoding the argument is treated as a Unicode code point. In other
        multibyte encodings the argument must designate
        an <acronym>ASCII</acronym> character.  <literal>chr(0)</literal> is
        disallowed because text data types cannot store that character.
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回给定代码的字符。在<acronym>UTF8</acronym>编码中该参数被视作一个Unicode代码点。
        在其他多字节编码中该参数必须指定一个<acronym>ASCII</acronym>字符。
        <literal>chr(0)</literal> 字符不被允许，因为文本数据类型不能存储这种字符。
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b8f6a44850c2e72247cc53bf9bf14290 -->

<!-- pgdoc-cn_start sig_en=3ea0232bb6bb95887b23ac7d672d88b7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the text representations of all the arguments.
        NULL arguments are ignored.
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接所有参数的文本表示。空参数被忽略。
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3ea0232bb6bb95887b23ac7d672d88b7 -->

<!-- pgdoc-cn_start sig_en=69b105e93c63a0e47bafd37e88e63853 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates all but the first argument, with separators. The first
        argument is used as the separator string, and should not be NULL.
        Other NULL arguments are ignored.
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用分隔符连接除第一个参数外的所有参数。第一个参数用作分隔符字符串，不应为NULL。其他NULL参数将被忽略。
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69b105e93c63a0e47bafd37e88e63853 -->

<!-- pgdoc-cn_start sig_en=e4244bc3c5f6a433abf2c79736c877a4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         Formats arguments according to a format string;
         see <xref linkend="functions-string-format"/>.
         This function is similar to the C function <function>sprintf</function>.
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         根据格式字符串对参数进行格式化；参见 <xref linkend="functions-string-format"/>。
         这个函数类似于C函数 <function>sprintf</function>。
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e4244bc3c5f6a433abf2c79736c877a4 -->

<!-- pgdoc-cn_start sig_en=08b37c23e9a59e5a809e08892a2d8c6f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将每个单词的第一个字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=08b37c23e9a59e5a809e08892a2d8c6f -->

<!-- pgdoc-cn_start sig_en=886c3828c04cc616b57d0423930c6c0d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns first <parameter>n</parameter> characters in the
        string, or when <parameter>n</parameter> is negative, returns
        all but last |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以字符串返回第一个 <parameter>n</parameter> 字符，或在 <parameter>n</parameter> 为负时, 返回最后 |<parameter>n</parameter>| 个字符之外的全部字符。
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=886c3828c04cc616b57d0423930c6c0d -->

<!-- pgdoc-cn_start sig_en=5b3458859d1b5eb2ff6ef1af3fb9ddbd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the string.
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5b3458859d1b5eb2ff6ef1af3fb9ddbd -->

<!-- pgdoc-cn_start sig_en=9cfc10f9d1ce0ffad180ff1905ae9274 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the right).
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>扩展为长度<parameter>length</parameter>，通过前置字符<parameter>fill</parameter>（默认空格）。 
        如果<parameter>string</parameter>已经超过<parameter>length</parameter>那么它将被截断（在右侧）。
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9cfc10f9d1ce0ffad180ff1905ae9274 -->

<!-- pgdoc-cn_start sig_en=1b7ba8007a35f6faab3a1d93537a815f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>开始删除包含<parameter>characters</parameter>（默认空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1b7ba8007a35f6faab3a1d93537a815f -->

<!-- pgdoc-cn_start sig_en=a6be4a26cf7fc0c7a7fac3662252f130 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the argument, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算参数的 MD5 <link linkend="functions-hash-note">hash</link> ，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a6be4a26cf7fc0c7a7fac3662252f130 -->

<!-- pgdoc-cn_start sig_en=3e7bfcac305a21bf7d39b1fd74201993 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<parameter>qualified_identifier</parameter>拆分为一个标识符数组，删除单个标识符的任何引用。 
        默认情况下，最后一个标识符之后的额外字符被视为错误；但是，如果第二个参数为<literal>false</literal>，则忽略这些额外的字符。
        （这种行为对于解析类似函数的对象的名称有作用。）
        请注意，此函数不会截断超长标识符。如果你想截断，你可以把结果给到<type>name[]</type>。
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3e7bfcac305a21bf7d39b1fd74201993 -->

<!-- pgdoc-cn_start sig_en=9be09686229327447dc680dd67d889ef sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns current client encoding name.
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前客户端编码名称。
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9be09686229327447dc680dd67d889ef -->

<!-- pgdoc-cn_start sig_en=d9c2202fe3e6848422133ef7cc0d7c17 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回适合引用的给定字符串，作为<acronym>SQL</acronym>语句字符串中的标识符。
        只有在必要的情况下才添加引号(例如，如果字符串包含非标识符字符或将被大小写折叠)。
        嵌入的引号被适当地加双引号。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d9c2202fe3e6848422133ef7cc0d7c17 -->

<!-- pgdoc-cn_start sig_en=fa55b72677546c672ae73b87990bf136 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串，用作字符串文字使用。
        嵌入式单引号和反斜线适当的翻倍(转双引号或双斜线)。
        请注意，<function>quote_literal</function>返回无效输入；如果这个参数可能为空，<function>quote_nullable</function>通常更合适。另请参阅<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fa55b72677546c672ae73b87990bf136 -->

<!-- pgdoc-cn_start sig_en=cec0d91cd6bd90ff4c0b9d7d7f50014e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的值转换为文本，然后将其作为字面量引用。
        内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cec0d91cd6bd90ff4c0b9d7d7f50014e -->

<!-- pgdoc-cn_start sig_en=3370a46bc7beff779f1fe20468fcd6cf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串文字;或者，如果参数为null，则返回<literal>NULL</literal>。
        内嵌的单引号和反斜杠被适当地翻倍。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3370a46bc7beff779f1fe20468fcd6cf -->

<!-- pgdoc-cn_start sig_en=562b419870a661bc6500622bb95064fa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal;
        or, if the argument is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定值转换为文本，然后将其作为字面量引用；或者，如果参数为null，则返回<literal>NULL</literal>。
        内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=562b419870a661bc6500622bb95064fa -->

<!-- pgdoc-cn_start sig_en=f3410cdfb212d3f9299fd00af77595ab sig_cn_org=d3de29a7440211eac715fc6183fc019e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_count</primary>
        </indexterm>
        <function>regexp_count</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of times the POSIX regular
        expression <parameter>pattern</parameter> matches in
        the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_count('123456789012', '\d\d\d', 2)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_count</primary>
        </indexterm>
        <function>regexp_count</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回 POSIX 正则表达式<parameter>pattern</parameter>在<parameter>string</parameter>中匹配的次数；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_count('123456789012', '\d\d\d', 2)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f3410cdfb212d3f9299fd00af77595ab -->

<!-- pgdoc-cn_start sig_en=2a9706f733c37ec1b6ca4542eb0f228b sig_cn_org=8ce23603eaa855ae4aaaa687fc095cd3 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_instr</primary>
        </indexterm>
        <function>regexp_instr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>endoption</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the position within <parameter>string</parameter> where
        the <parameter>N</parameter>'th match of the POSIX regular
        expression <parameter>pattern</parameter> occurs, or zero if there is
        no such match; see <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i')</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i', 2)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_instr</primary>
        </indexterm>
        <function>regexp_instr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>endoption</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<parameter>string</parameter>中第<parameter>N</parameter>个匹配项的POSIX正则表达式<parameter>pattern</parameter>出现的位置，如果没有这样的匹配项，则返回零；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i')</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i', 2)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2a9706f733c37ec1b6ca4542eb0f228b -->

<!-- pgdoc-cn_start sig_en=22568c7d773cf1dcd58e28a023d5936e sig_cn_org=5215fe7d266ece180dac0f666fd02671 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_like</primary>
        </indexterm>
        <function>regexp_like</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether a match of the POSIX regular
        expression <parameter>pattern</parameter> occurs
        within <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_like('Hello World', 'world$', 'i')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_like</primary>
        </indexterm>
        <function>regexp_like</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查 POSIX 正则表达式<parameter>pattern</parameter>是否在<parameter>string</parameter>中出现；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_like('Hello World', 'world$', 'i')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22568c7d773cf1dcd58e28a023d5936e -->

<!-- pgdoc-cn_start sig_en=9116df1dce0fb3c5d26b1be3853cef57 sig_cn_org=277dc6ff6522481300e8f67953840428 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns substrings within the first match of the POSIX regular
        expression <parameter>pattern</parameter> to
        the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        返回第一个匹配的POSIX正则表达式<parameter>pattern</parameter>在<parameter>string</parameter>中的子字符串；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9116df1dce0fb3c5d26b1be3853cef57 -->

<!-- pgdoc-cn_start sig_en=ac01fcbcac15c0a9841b675885a1251f sig_cn_org=75b7ab0729173b56eb19de2780bbddbc source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        返回POSIX正则表达式 <parameter>pattern</parameter> 在 <parameter>string</parameter>中第一个匹配项内的子字符串, 或者如果使用 <literal>g</literal> 标志，则返回所有此类匹配项内的子字符串；
        参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        返回第一个匹配的 POSIX 正则表达式<parameter>pattern</parameter>在<parameter>string</parameter>中的子字符串，或者如果使用了<literal>g</literal>标志，则返回所有匹配的子字符串；
        参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ac01fcbcac15c0a9841b675885a1251f -->

<!-- pgdoc-cn_start sig_en=38d935c30155e5db3c4495aa5a475453 sig_cn_org=7e6aa83bdec34ac2dc3cdfaf937f3f08 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type> ]
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces the substring that is the first match to the POSIX
        regular expression <parameter>pattern</parameter>, or all such
        matches if the <literal>g</literal> flag is used; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type> ]
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换第一个与 POSIX 正则表达式<parameter>pattern</parameter>匹配的子字符串，如果使用了<literal>g</literal>标志，则替换所有这样的匹配；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=38d935c30155e5db3c4495aa5a475453 -->

<!-- pgdoc-cn_start sig_en=e4ab671968133addecb24b7ec9a06026 sig_cn_org=b18b2961600f101b90b4af3510148f59 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>,
         <parameter>start</parameter> <type>integer</type>,
         <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces the substring that is the <parameter>N</parameter>'th
        match to the POSIX regular expression <parameter>pattern</parameter>,
        or all such matches if <parameter>N</parameter> is zero; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.', 'X', 3, 2)</literal>
        <returnvalue>ThoXas</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>,
         <parameter>start</parameter> <type>integer</type>,
         <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换字符串中第<parameter>N</parameter>个与 POSIX 正则表达式<parameter>pattern</parameter>匹配的子字符串，如果<parameter>N</parameter>为零，则替换所有匹配项；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.', 'X', 3, 2)</literal>
        <returnvalue>ThoXas</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e4ab671968133addecb24b7ec9a06026 -->

<!-- pgdoc-cn_start sig_en=b2b2b172570b071f4e0c41fd8aa4f3ad sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter, producing an array of results; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>，生成一个结果的数组； 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2b2b172570b071f4e0c41fd8aa4f3ad -->

<!-- pgdoc-cn_start sig_en=0b623e94a7373097bf5415e8f879745d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter, producing a set of results; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>，生成一组结果；参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0b623e94a7373097bf5415e8f879745d -->

<!-- pgdoc-cn_start sig_en=050ba9392b0f3946daa1a0b4cdd9be30 sig_cn_org=f62425d6c54e3e1a632c49feba9f3978 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_substr</primary>
        </indexterm>
        <function>regexp_substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the substring within <parameter>string</parameter> that
        matches the <parameter>N</parameter>'th occurrence of the POSIX
        regular expression <parameter>pattern</parameter>,
        or <literal>NULL</literal> if there is no such match; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i')</literal>
        <returnvalue>CDEF</returnvalue>
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i', 2)</literal>
        <returnvalue>EF</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_substr</primary>
        </indexterm>
        <function>regexp_substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回<parameter>string</parameter>中与第<parameter>N</parameter>个出现的POSIX正则表达式<parameter>pattern</parameter>匹配的子字符串，
        如果没有这样的匹配，则返回<literal>NULL</literal>;参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i')</literal>
        <returnvalue>CDEF</returnvalue>
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i', 2)</literal>
        <returnvalue>EF</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=050ba9392b0f3946daa1a0b4cdd9be30 -->

<!-- pgdoc-cn_start sig_en=74e73e30e33a697b81ff54432e84e2cc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Repeats <parameter>string</parameter> the specified
        <parameter>number</parameter> of times.
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重复<parameter>string</parameter>指定<parameter>number</parameter>的次数。
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74e73e30e33a697b81ff54432e84e2cc -->

<!-- pgdoc-cn_start sig_en=9aa312cf63083b98d1d3615bedb91306 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces all occurrences in <parameter>string</parameter> of
        substring <parameter>from</parameter> with
        substring <parameter>to</parameter>.
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter> 中当前的子串<parameter>from</parameter>替换为子串<parameter>to</parameter>。
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9aa312cf63083b98d1d3615bedb91306 -->

<!-- pgdoc-cn_start sig_en=4dbf581a95395115a04de54a0a8d6b07 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reverses the order of the characters in the string.
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        颠倒字符串中字符的顺序。
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4dbf581a95395115a04de54a0a8d6b07 -->

<!-- pgdoc-cn_start sig_en=4093d06835e6084c2dfcafd44df2d187 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns last <parameter>n</parameter> characters in the string,
        or when <parameter>n</parameter> is negative, returns all but
        first |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回字符串中的最后<parameter>n</parameter>个字符，或者在<parameter>n</parameter>>为负时，返回除了前面的|<parameter>n</parameter>|字符之外的所有字符。
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4093d06835e6084c2dfcafd44df2d187 -->

<!-- pgdoc-cn_start sig_en=efcd07017ce6a984e62e925208828177 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        扩展 <parameter>string</parameter> 到长度 <parameter>length</parameter>，通过追加<parameter>fill</parameter> 字符(默认为空格).  
        如果<parameter>string</parameter> 已经比 <parameter>length</parameter> 长，则截断它。
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=efcd07017ce6a984e62e925208828177 -->

<!-- pgdoc-cn_start sig_en=50f296853ebca5b72ddcb7efaf6f4b5f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>末尾删除包含<parameter>characters</parameter>（默认为空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=50f296853ebca5b72ddcb7efaf6f4b5f -->

<!-- pgdoc-cn_start sig_en=482703bb695e7dedea8bd8852529e320 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns
        the <parameter>n</parameter>'th field (counting from one),
        or when <parameter>n</parameter> is negative, returns
        the |<parameter>n</parameter>|'th-from-last field.
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para>
       <para>
        <literal>split_part('abc,def,ghi,jkl', ',', -2)</literal>
        <returnvalue>ghi</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        在<parameter>delimiter</parameter>出现时拆分<parameter>string</parameter>，并且返回第<parameter>n</parameter>个字段(从一计数)，或者当<parameter>n</parameter>为负数时，返回|<parameter>n</parameter>|'th-from-last 字段。
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para>
       <para>
        <literal>split_part('abc,def,ghi,jkl', ',', -2)</literal>
        <returnvalue>ghi</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=482703bb695e7dedea8bd8852529e320 -->

<!-- pgdoc-cn_start sig_en=cd1746df2472c042495af2dd1a05f515 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if <parameter>string</parameter> starts
        with <parameter>prefix</parameter>.
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果 <parameter>string</parameter> 以 <parameter>prefix</parameter>开始就返回真。
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cd1746df2472c042495af2dd1a05f515 -->

<!-- pgdoc-cn_start sig_en=185808fa965b39f940723a353dc50c76 sig_cn_org=b50a082f7b57ae58de51d59667cfd80a source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-string-to-array">
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and forms the resulting fields
        into a <type>text</type> array.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate element in the array.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are
        replaced by <literal>NULL</literal>.
        See also <link linkend="function-array-to-string"><function>array_to_string</function></link>.
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-string-to-array">
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>按<parameter>delimiter</parameter>分割，并将结果字段形成<type>text</type>数组。
        如果<parameter>delimiter</parameter>是<literal>NULL</literal>，则<parameter>string</parameter>中的每个字符将成为数组中的一个单独元素。
        如果<parameter>delimiter</parameter>是空字符串，则<parameter>string</parameter>被视为单个字段。
        如果提供了<parameter>null_string</parameter>且不是<literal>NULL</literal>，则匹配该字符串的字段将被<literal>NULL</literal>替换。
        另请参见<link linkend="function-array-to-string"><function>array_to_string</function></link>。
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=185808fa965b39f940723a353dc50c76 -->

<!-- pgdoc-cn_start sig_en=b9d6bbb135cf8739e65ea0b2595d50f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_table</primary>
        </indexterm>
        <function>string_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns the resulting fields
        as a set of <type>text</type> rows.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate row of the result.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are
        replaced by <literal>NULL</literal>.
       </para>
       <para>
        <literal>string_to_table('xx~^~yy~^~zz', '~^~', 'yy')</literal>
        <returnvalue></returnvalue>
<programlisting>
 xx
 NULL
 zz
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_table</primary>
        </indexterm>
        <function>string_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        在出现<parameter>delimiter</parameter> 时拆分<parameter>string</parameter>，并将结果字段作为<type>text</type>行的集合返回。
        如果<parameter>delimiter</parameter>为<literal>NULL</literal>，则<parameter>string</parameter>中的每个字符将成为结果的单独一行。
        如果<parameter>delimiter</parameter>为空字符串，则将<parameter>string</parameter>视为单个字段。
        如果提供了<parameter>null_string</parameter>，并且不是<literal>NULL</literal>，则匹配该字符串的字段将被<literal>NULL</literal>替换。
       </para>
       <para>
        <literal>string_to_table('xx~^~yy~^~zz', '~^~', 'yy')</literal>
        <returnvalue></returnvalue>
<programlisting>
 xx
 NULL
 zz
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b9d6bbb135cf8739e65ea0b2595d50f0 -->

<!-- pgdoc-cn_start sig_en=ae7575d6635d6b4e8dfb3f49614666cd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns first starting index of the specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
        (Same as <literal>position(<parameter>substring</parameter> in
        <parameter>string</parameter>)</literal>, but note the reversed
        argument order.)
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回在<parameter>string</parameter>中指定的<parameter>substring</parameter>的第一个起始索引,如果不存在则为零。
        （与<literal>(<parameter>substring</parameter> 在 <parameter>string</parameter>中的)位置</literal>相同，但是请注意反转的参数顺序）
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ae7575d6635d6b4e8dfb3f49614666cd -->

<!-- pgdoc-cn_start sig_en=df1efae6458ffd6f6212a1722cb2066e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character,
        and extending for <parameter>count</parameter> characters if that is
        specified.  (Same
        as <literal>substring(<parameter>string</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子字符串，并扩展<parameter>count</parameter>字符，如果指定了的话。
        (与 <literal>子字符串(<parameter>string</parameter> 从 <parameter>start</parameter> 开始计数 <parameter>count</parameter>)</literal>相同。)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=df1efae6458ffd6f6212a1722cb2066e -->

<!-- pgdoc-cn_start sig_en=a054f6a8397ece738aa17f0efb5755f4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts <parameter>string</parameter> to <acronym>ASCII</acronym>
        from another encoding, which may be identified by name or number.
        If <parameter>encoding</parameter> is omitted the database encoding
        is assumed (which in practice is the only useful case).
        The conversion consists primarily of dropping accents.
        Conversion is only supported
        from <literal>LATIN1</literal>, <literal>LATIN2</literal>,
        <literal>LATIN9</literal>, and <literal>WIN1250</literal> encodings.
        (See the <xref linkend="unaccent"/> module for another, more flexible
        solution.)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>从另一个编码中转换为<acronym>ASCII</acronym>，该编码可按名称或编号标识。
        如果<parameter>encoding</parameter>被省略，则假定数据库编码（这在实践中是唯一有用的案例）。转换主要包括降音。
        转换仅支持来自 <literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、 和 <literal>WIN1250</literal> 的编码.
        (其他请参见 <xref linkend="unaccent"/> 模块, 更灵活的解决方案。)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a054f6a8397ece738aa17f0efb5755f4 -->

<!-- pgdoc-cn_start sig_en=4c8a6b8b2bafcc3b1c6f9fa04fa7cef4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the number to its equivalent hexadecimal representation.
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将数字转换为其相应的十六进制表示形式。
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c8a6b8b2bafcc3b1c6f9fa04fa7cef4 -->

<!-- pgdoc-cn_start sig_en=394ae8d9d88af26b790bd6115dc29649 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces each character in <parameter>string</parameter> that
        matches a character in the <parameter>from</parameter> set with the
        corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are deleted.
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>中与<parameter>from</parameter>集合中匹配的每个字符替换为<parameter>to</parameter>集合中相应的字符。
        如果<parameter>from</parameter>长于<parameter>to</parameter>，<parameter>from</parameter>中出现的额外字符被删除。
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=394ae8d9d88af26b790bd6115dc29649 -->

<!-- pgdoc-cn_start sig_en=689ff35db790b16dd95acd8ccde7b65e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unistr</primary>
        </indexterm>
        <function>unistr</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Evaluate escaped Unicode characters in the argument.  Unicode characters
        can be specified as
        <literal>\<replaceable>XXXX</replaceable></literal> (4 hexadecimal
        digits), <literal>\+<replaceable>XXXXXX</replaceable></literal> (6
        hexadecimal digits),
        <literal>\u<replaceable>XXXX</replaceable></literal> (4 hexadecimal
        digits), or <literal>\U<replaceable>XXXXXXXX</replaceable></literal>
        (8 hexadecimal digits).  To specify a backslash, write two
        backslashes.  All other characters are taken literally.
       </para>

       <para>
        If the server encoding is not UTF-8, the Unicode code point identified
        by one of these escape sequences is converted to the actual server
        encoding; an error is reported if that's not possible.
       </para>

       <para>
        This function provides a (non-standard) alternative to string
        constants with Unicode escapes (see <xref
        linkend="sql-syntax-strings-uescape"/>).
       </para>

       <para>
        <literal>unistr('d\0061t\+000061')</literal>
        <returnvalue>data</returnvalue>
       </para>
       <para>
        <literal>unistr('d\u0061t\U00000061')</literal>
        <returnvalue>data</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unistr</primary>
        </indexterm>
        <function>unistr</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算参数中的转义Unicode字符。
        Unicode字符可以被指定为<literal>\<replaceable>XXXX</replaceable></literal> (4个十六进制数字)，<literal>\+<replaceable>XXXXXX</replaceable></literal>(6个十六进制数字)，<literal>\u<replaceable>XXXX</replaceable></literal>(4个十六进制数字)，或<literal>\U<replaceable>XXXXXXXX</replaceable></literal> (8个十六进制数字)。
        要指定反斜杠，请写入两个反斜杠。
        所有其他字符都是按字面意义的。
       </para>

       <para>
        如果服务器编码不是UTF-8，由这些转义序列之一标识的Unicode编码点将被转换为实际的服务器编码;如果不可能，则会报告错误。
       </para>

       <para>
        这个函数提供了一个(非标准的)替代到Unicode转义的字符串常量(参见<xref linkend="sql-syntax-strings-uescape"/>)。
       </para>

       <para>
        <literal>unistr('d\0061t\+000061')</literal>
        <returnvalue>data</returnvalue>
       </para>
       <para>
        <literal>unistr('d\u0061t\U00000061')</literal>
        <returnvalue>data</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=689ff35db790b16dd95acd8ccde7b65e -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=c42e156579e5cad0951be8723647a495 sig_cn_org=None source=14.1 
   <para>
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
   </para>
________________________________________________________-->
   <para>
    <function>concat</function>、<function>concat_ws</function>和<function>format</function>函数是可变的，因此可以把要串接或格式化的值作为一个标记了<literal>VARIADIC</literal>关键字的数组进行传递（见<xref linkend="xfunc-sql-variadic-functions"/>）。
    数组的元素被当作函数的独立普通参数一样处理。如果可变数组参数为 NULL，<function>concat</function>和<function>concat_ws</function>返回 NULL，但<function>format</function>把 NULL 当作一个零元素数组。
   </para>
<!-- pgdoc-cn_end sig_en=c42e156579e5cad0951be8723647a495 -->

<!-- pgdoc-cn_start sig_en=f63916b6d1b8f60e9bbecb4e1fffb1ac sig_cn_org=None source=14.1 
   <para>
    See also the aggregate function <function>string_agg</function> in
    <xref linkend="functions-aggregate"/>, and the functions for
    converting between strings and the <type>bytea</type> type in
    <xref linkend="functions-binarystring-conversions"/>.
   </para>
________________________________________________________-->
   <para>
    还可以参阅<xref linkend="functions-aggregate"/>中的<function>string_agg</function>，以及<xref linkend="functions-binarystring-conversions"/>中的字符串和<type>bytea</type>类型之间转换的功能。
   </para>
<!-- pgdoc-cn_end sig_en=f63916b6d1b8f60e9bbecb4e1fffb1ac -->

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

<!-- pgdoc-cn_start sig_en=51ea28c9fb3289260887ff9ab999d12e sig_cn_org=None source=14.1 
    <indexterm>
     <primary>format</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>format</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=51ea28c9fb3289260887ff9ab999d12e -->

<!-- pgdoc-cn_start sig_en=08b4a1a2c9a4d76c68e2f5a2b272e0c6 sig_cn_org=None source=14.1 
    <para>
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
    </para>
________________________________________________________-->
    <para>
     函数<function>format</function>根据一个格式字符串产生格式化的输出，其形式类似于 C 函数<function>sprintf</function>。
    </para>
<!-- pgdoc-cn_end sig_en=08b4a1a2c9a4d76c68e2f5a2b272e0c6 -->

<!-- pgdoc-cn_start sig_en=3755e5cc7ee83deaa5175585f19b16f6 sig_cn_org=None source=14.1 
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <parameter>formatarg</parameter> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
    </para>
________________________________________________________-->
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter>是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用<firstterm>格式说明符</firstterm>的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个<parameter>formatarg</parameter>参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。
    </para>
<!-- pgdoc-cn_end sig_en=3755e5cc7ee83deaa5175585f19b16f6 -->

<!-- pgdoc-cn_start sig_en=c2b699ee2caf6498d8c56dd4a63d28bd sig_cn_org=None source=14.1 
    <para>
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     where the component fields are:

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter> (optional)</term>
       <listitem>
        <para>
         A string of the form <literal><parameter>n</parameter>$</literal> where
         <parameter>n</parameter> is the index of the argument to print.
         Index 1 means the first argument after
         <parameter>formatstr</parameter>.  If the <parameter>position</parameter> is
         omitted, the default is to use the next argument in sequence.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter> (optional)</term>
       <listitem>
        <para>
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <parameter>width</parameter>
         field is also specified.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter> (optional)</term>
       <listitem>
        <para>
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<parameter>n</parameter>$</literal> to
         use the <parameter>n</parameter>th function argument as the width.
        </para>

        <para>
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<parameter>width</parameter>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter> (required)</term>
       <listitem>
        <para>
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
________________________________________________________-->
    <para>
     格式说明符由一个<literal>%</literal>字符开始并且有这样的形式
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     其中的各组件域是：

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter>（可选）</term>
       <listitem>
        <para>
         一个形式为<literal><parameter>n</parameter>$</literal>的字符串，其中<parameter>n</parameter>是要打印的参数的索引。索引 1 表示<parameter>formatstr</parameter>之后的第一个参数。如果<parameter>position</parameter>被忽略，默认会使用序列中的下一个参数。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter>（可选）</term>
       <listitem>
        <para>
         控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（<literal>-</literal>），它将导致格式说明符的输出会被左对齐（left-justified）。除非<parameter>width</parameter>域也被指定，否者这个域不会产生任何效果。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter>（可选）</term>
       <listitem>
        <para>
         指定用于显示格式说明符输出的<emphasis>最小</emphasis>字符数。输出将被在左部或右部（取决于<literal>-</literal>标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（<literal>*</literal>）表示使用下一个函数参数作为宽度；或者一个形式为<literal>*<parameter>n</parameter>$</literal>的字符串表示使用第<parameter>n</parameter>个函数参数作为宽度。
        </para>

        <para>
         如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为<function>abs</function>(<parameter>width</parameter>)的域中被左对齐（如果<literal>-</literal>标志被指定）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter>（必需）</term>
       <listitem>
        <para>
         格式转换的类型，用于产生格式说明符的输出。支持下面的类型：
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal>将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal>将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等效于<function>quote_ident</function>）。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal>将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串<literal>NULL</literal>（等效于<function>quote_nullable</function>）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
<!-- pgdoc-cn_end sig_en=c2b699ee2caf6498d8c56dd4a63d28bd -->

<!-- pgdoc-cn_start sig_en=a2f56dde948bdffd144f09d0a0dba1b2 sig_cn_org=None source=14.1 
    <para>
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
    </para>
________________________________________________________-->
    <para>
     除了以上所述的格式说明符之外，要输出一个文字形式的<literal>%</literal>字符，可以使用特殊序列<literal>%%</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=a2f56dde948bdffd144f09d0a0dba1b2 -->

<!-- pgdoc-cn_start sig_en=7cea88677068996a09f4342d95301fb1 sig_cn_org=None source=14.1 
    <para>
     Here are some examples of the basic format conversions:

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>
________________________________________________________-->
    <para>
     下面有一些基本的格式转换的例子：

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>结果：</lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=7cea88677068996a09f4342d95301fb1 -->

<!-- pgdoc-cn_start sig_en=7c6f07da3016a4c48625dc532b819971 sig_cn_org=None source=14.1 
    <para>
     Here are examples using <parameter>width</parameter> fields
     and the <literal>-</literal> flag:

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>
________________________________________________________-->
    <para>
     下面是使用<parameter>width</parameter>域和<literal>-</literal>标志的例子：

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=7c6f07da3016a4c48625dc532b819971 -->

<!-- pgdoc-cn_start sig_en=f0ea29f3a9ab9801a5e958875dc0cb26 sig_cn_org=None source=14.1 
    <para>
     These examples show use of <parameter>position</parameter> fields:

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>
________________________________________________________-->
    <para>
     这些例子展示了<parameter>position</parameter>域的例子：

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=f0ea29f3a9ab9801a5e958875dc0cb26 -->

<!-- pgdoc-cn_start sig_en=e6c98dfe3d24aef1b82cd6df36b916c2 sig_cn_org=None source=14.1 
    <para>
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <parameter>position</parameter> fields to be mixed
     in the same format string.  A format specifier without a
     <parameter>position</parameter> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>
________________________________________________________-->
    <para>
     不同于标准的 C 函数<function>sprintf</function>，<productname>PostgreSQL</productname>的<function>format</function>函数允许将带有或者不带有<parameter>position</parameter>域的格式说明符被混在同一个格式字符串中。一个不带有<parameter>position</parameter>域的格式说明符总是使用最后一个被消耗的参数的下一个参数。另外，<function>format</function>函数不要求所有函数参数都被用在格式字符串中。例如：

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=e6c98dfe3d24aef1b82cd6df36b916c2 -->

<!-- pgdoc-cn_start sig_en=7aadbb9e43728f84d8c4d32749936c06 sig_cn_org=None source=14.1 
    <para>
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
    </para>
________________________________________________________-->
    <para>
     对于安全地构造动态 SQL 语句，<literal>%I</literal>和<literal>%L</literal>格式说明符特别有用。参见<xref linkend="plpgsql-quote-literal-example"/>。
    </para>
<!-- pgdoc-cn_end sig_en=7aadbb9e43728f84d8c4d32749936c06 -->
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!-- pgdoc-cn_start sig_en=1398877be33531be4623d461570ba5f3 sig_cn_org=None source=14.1 
   <title>Binary String Functions and Operators</title>
________________________________________________________-->
   <title>二进制串函数和操作符</title>
<!-- pgdoc-cn_end sig_en=1398877be33531be4623d461570ba5f3 -->

<!-- pgdoc-cn_start sig_en=a2eee2d8201a8e60b7f4de931c366b86 sig_cn_org=None source=14.1 
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a2eee2d8201a8e60b7f4de931c366b86 -->

<!-- pgdoc-cn_start sig_en=7fb6f07066486dd7b9f759c3be0fb79c sig_cn_org=None source=14.1 
   <para>
    This section describes functions and operators for examining and
    manipulating binary strings, that is values of type <type>bytea</type>.
    Many of these are equivalent, in purpose and syntax, to the
    text-string functions described in the previous section.
   </para>
________________________________________________________-->
   <para>
    本节描述那些检查和操作二进制字符串的函数和操作符，这是类型<type>bytea</type>的值。
    其中许多函数在用途和语法上都与上一节中描述的文本字符串函数等效。
   </para>
<!-- pgdoc-cn_end sig_en=7fb6f07066486dd7b9f759c3be0fb79c -->

<!-- pgdoc-cn_start sig_en=ecbfa10fe4637bf57ee4d74b74cc67b8 sig_cn_org=None source=14.1 
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
   </para>
________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些使用关键字而不是逗号来分割参数的串函数。详情请见<xref linkend="functions-binarystring-sql"/>。<productname>PostgreSQL</productname>也提供了这些函数使用常规函数调用语法的版本（参阅<xref linkend="functions-binarystring-other"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=ecbfa10fe4637bf57ee4d74b74cc67b8 -->

   <table id="functions-binarystring-sql">
<!-- pgdoc-cn_start sig_en=3bdfee7f183450c1902c79991e4b368a sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
________________________________________________________-->
    <title><acronym>SQL</acronym>二进制串函数和操作符</title>
<!-- pgdoc-cn_end sig_en=3bdfee7f183450c1902c79991e4b368a -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cdd049d2b7d2ed42e717c6cdb0e344c -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=baeedad8d952648beb39d8ca713d70ce sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the two binary strings.
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        连接两个二进制字符串。
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=baeedad8d952648beb39d8ca713d70ce -->

<!-- pgdoc-cn_start sig_en=5e9604c7328e6cdff25cc1f2462f4912 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the binary string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的位数 (8 倍于 <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5e9604c7328e6cdff25cc1f2462f4912 -->

<!-- pgdoc-cn_start sig_en=ee9d2b6b956b57bcd087380bbe6ece4c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the binary string.
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ee9d2b6b956b57bcd087380bbe6ece4c -->

<!-- pgdoc-cn_start sig_en=902d0c44297fd4942dd60a021d0cfd0f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bytes</parameter> that starts at
        the <parameter>start</parameter>'th byte and extends
        for <parameter>count</parameter> bytes
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        将<parameter>bytes</parameter>的子字符串替换为<parameter>newsubstring</parameter>，该子字符串从<parameter>start</parameter>字节开始，并以<parameter>count</parameter>字节扩展。
        如果忽略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=902d0c44297fd4942dd60a021d0cfd0f -->

<!-- pgdoc-cn_start sig_en=b54220e28afdefa9d71785fdae18e416 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns first starting index of the specified
        <parameter>substring</parameter> within
        <parameter>bytes</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<parameter>bytes</parameter>中指定的<parameter>substring</parameter>的第一个起始索引，如果不存在，则为零。
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b54220e28afdefa9d71785fdae18e416 -->

<!-- pgdoc-cn_start sig_en=e05e2e39667d374d218503f36ecb6a40 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte if that is specified,
        and stopping after <parameter>count</parameter> bytes if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        提取<parameter>bytes</parameter>从<parameter>start</parameter>字节开始的子字符串，如果指定了，并且在<parameter>count</parameter>字节之后停止，如果指定了的话。
        至少提供<parameter>start</parameter>和<parameter>count</parameter>中的一个。
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e05e2e39667d374d218503f36ecb6a40 -->

<!-- pgdoc-cn_start sig_en=3b7b1759197c3ff230b23684f4312a3a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start,
        end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>bytes</parameter>.
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        删除<parameter>bytesremoved</parameter>中只包含字节的最长字符串，从<parameter>bytes</parameter>的开始、结束，或两端(<literal>BOTH</literal> 为默认的)。
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b7b1759197c3ff230b23684f4312a3a -->

<!-- pgdoc-cn_start sig_en=4bb6070bbfbd630ca5004b5cd99c36d2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        这是<function>trim()</function>的非标准语法。
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4bb6070bbfbd630ca5004b5cd99c36d2 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=0e57e644fe41982ea730acd2fe57822e sig_cn_org=None source=14.1 
   <para>
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
   </para>
________________________________________________________-->
   <para>
    还有一些二进制串处理函数可以使用，在<xref linkend="functions-binarystring-other"/>列出。 其中有一些是在内部使用，用于实现<xref linkend="functions-binarystring-sql"/>列出的 SQL 标准串函数。
   </para>
<!-- pgdoc-cn_end sig_en=0e57e644fe41982ea730acd2fe57822e -->

   <table id="functions-binarystring-other">
<!-- pgdoc-cn_start sig_en=ac1b1349af1549eacf038e86a7961550 sig_cn_org=None source=14.1 
    <title>Other Binary String Functions</title>
________________________________________________________-->
    <title>其他二进制串函数</title>
<!-- pgdoc-cn_end sig_en=ac1b1349af1549eacf038e86a7961550 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=4a90c9b2a7c8f0781f4d61be49fe479a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <indexterm>
         <primary>popcount</primary>
         <see>bit_count</see>
        </indexterm>
        <function>bit_count</function> ( <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of bits set in the binary string (also known as
        <quote>popcount</quote>).
       </para>
       <para>
        <literal>bit_count('\x1234567890'::bytea)</literal>
        <returnvalue>15</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <indexterm>
         <primary>popcount</primary>
         <see>bit_count</see>
        </indexterm>
        <function>bit_count</function> ( <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回二进制字符串中设置的位数(也被认为<quote>popcount</quote>)。
       </para>
       <para>
        <literal>bit_count('\x1234567890'::bytea)</literal>
        <returnvalue>15</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4a90c9b2a7c8f0781f4d61be49fe479a -->

<!-- pgdoc-cn_start sig_en=b6699c97a912f38b157d063c7a4014d6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start and end of
        <parameter>bytes</parameter>.
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>bytes</parameter>的开始和结束处删除只包含<parameter>bytesremoved</parameter>中出现的字节的最长字符串
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b6699c97a912f38b157d063c7a4014d6 -->

<!-- pgdoc-cn_start sig_en=c9c82fe4d395fc49b98e5b1665beda6d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> bit
        from binary string.
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 位。
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c9c82fe4d395fc49b98e5b1665beda6d -->

<!-- pgdoc-cn_start sig_en=ec5d5e8121682375d1de94778bec0d03 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> byte
        from binary string.
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 字节。
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ec5d5e8121682375d1de94778bec0d03 -->

<!-- pgdoc-cn_start sig_en=b2a46ae049830b847321175dd9bb94c3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of bytes in the binary string.
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2a46ae049830b847321175dd9bb94c3 -->

<!-- pgdoc-cn_start sig_en=3a6faa26def5d46900f864df35d56860 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the binary string, assuming
        that it is text in the given <parameter>encoding</parameter>.
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字符数，假设它是给定<parameter>encoding</parameter>中的文本。
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3a6faa26def5d46900f864df35d56860 -->

<!-- pgdoc-cn_start sig_en=38f922565a22229a5385d89ea01a4a66 sig_cn_org=None source=14.1 
      <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>ltrim</primary>
         </indexterm>
         <function>ltrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
         Removes the longest string containing only bytes appearing in
         <parameter>bytesremoved</parameter> from the start of
         <parameter>bytes</parameter>.
        </para>
        <para>
         <literal>ltrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x34567890</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
      <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>ltrim</primary>
         </indexterm>
         <function>ltrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
         从<parameter>bytes</parameter>开头移除出现在<parameter>bytesremoved</parameter>中的只包含字节的最长字符串。
        </para>
        <para>
         <literal>ltrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x34567890</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=38f922565a22229a5385d89ea01a4a66 -->

<!-- pgdoc-cn_start sig_en=b6d3c2c0e89599537389da9ec97a72ac sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the binary string, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算二进制字符串的MD5 <link linkend="functions-hash-note">hash</link>，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b6d3c2c0e89599537389da9ec97a72ac -->

<!-- pgdoc-cn_start sig_en=76f8510508af1b1ee1cabaaea56c1ce7 sig_cn_org=None source=14.1 
      <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>rtrim</primary>
         </indexterm>
         <function>rtrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
         Removes the longest string containing only bytes appearing in
         <parameter>bytesremoved</parameter> from the end of
         <parameter>bytes</parameter>.
        </para>
        <para>
         <literal>rtrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x12345678</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
      <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>rtrim</primary>
         </indexterm>
         <function>rtrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
         从<parameter>bytes</parameter>结尾移除出现在<parameter>bytesremoved</parameter>中的只包含字节的最长字符串。
        </para>
        <para>
         <literal>rtrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x12345678</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=76f8510508af1b1ee1cabaaea56c1ce7 -->

<!-- pgdoc-cn_start sig_en=5bc217e7936b568cc6b7f4d03fcc85c9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> bit in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的<link linkend="functions-zerobased-note">n'th</link>位为<parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5bc217e7936b568cc6b7f4d03fcc85c9 -->

<!-- pgdoc-cn_start sig_en=57c3bcccde6c1f062fa03b0b2de2a9f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> byte in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的 <link linkend="functions-zerobased-note">n'th</link> 字节到 <parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=57c3bcccde6c1f062fa03b0b2de2a9f0 -->

<!-- pgdoc-cn_start sig_en=d7461ce4f2f523267734a2f310f589b5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-224 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-224 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d7461ce4f2f523267734a2f310f589b5 -->

<!-- pgdoc-cn_start sig_en=b061cdf3075d7867da2dffbe0205a573 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-256 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-256 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b061cdf3075d7867da2dffbe0205a573 -->

<!-- pgdoc-cn_start sig_en=f8cd03a8ef2f10e4a4536d723a1df2a4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-384 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-384 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8cd03a8ef2f10e4a4536d723a1df2a4 -->

<!-- pgdoc-cn_start sig_en=c2cc0007e223f2f9f8bcb41b354ab6fc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-512 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-512 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c2cc0007e223f2f9f8bcb41b354ab6fc -->

<!-- pgdoc-cn_start sig_en=27c43d63686b031652148a3f60434532 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte,
        and extending for <parameter>count</parameter> bytes if that is
        specified.  (Same
        as <literal>substring(<parameter>bytes</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>字节开始提取<parameter>bytes</parameter>的子字符串，并扩展为<parameter>count</parameter>字节，如果这是指定的。
        (与 <literal>substring(<parameter>bytes</parameter> 从 <parameter>start</parameter> 到 <parameter>count</parameter>)</literal> 相同.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=27c43d63686b031652148a3f60434532 -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=3fd0354ab19d3beb5b7f941d9d709815 sig_cn_org=None source=14.1 
  <para id="functions-zerobased-note">
   Functions <function>get_byte</function> and <function>set_byte</function>
   number the first byte of a binary string as byte 0.
   Functions <function>get_bit</function> and <function>set_bit</function>
   number bits from the right within each byte; for example bit 0 is the least
   significant bit of the first byte, and bit 15 is the most significant bit
   of the second byte.
  </para>
________________________________________________________-->
  <para id="functions-zerobased-note">
   函数<function>get_byte</function>和<function>set_byte</function>把一个二进制串中的一个字节计数为字节 0。
   函数<function>get_bit</function>和<function>set_bit</function>在每一个字节中从右边起计数位；
   例如位 0 是第一个字节的最低有效位，而位 15 是第二个字节的最高有效位。
  </para>
<!-- pgdoc-cn_end sig_en=3fd0354ab19d3beb5b7f941d9d709815 -->

<!-- pgdoc-cn_start sig_en=7e6fab6d68ef39edfd9cda9617219c41 sig_cn_org=None source=14.1 
  <para id="functions-hash-note">
   For historical reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <link linkend="function-encode"><function>encode</function></link>
   and <link linkend="function-decode"><function>decode</function></link> to
   convert between the two.  For example write <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation,
   or <literal>decode(md5('abc'), 'hex')</literal> to get
   a <type>bytea</type> value.
  </para>
________________________________________________________-->
  <para id="functions-hash-note">
   由于历史原因，函数<function>md5</function>返回的是一个十六进制编码的<type>text</type>值，而SHA-2函数返回类型<type>bytea</type>。
   可以使用函数<link linkend="function-encode"><function>encode</function></link>和<link linkend="function-decode"><function>decode</function></link>在两者之间转换。
   例如<literal>encode(sha256('abc'),'hex')</literal>可以得到一个十六进制编码的文本表示，或者<literal>decode(md5('abc'), 'hex')</literal>得到一个<type>bytea</type> 值。
  </para>
<!-- pgdoc-cn_end sig_en=7e6fab6d68ef39edfd9cda9617219c41 -->

<!-- pgdoc-cn_start sig_en=4728a56741f0f729610932771ff6d93d sig_cn_org=None source=14.1 
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   Functions for converting strings between different character sets
   (encodings), and for representing arbitrary binary data in textual
   form, are shown in
   <xref linkend="functions-binarystring-conversions"/>.  For these
   functions, an argument or result of type <type>text</type> is expressed
   in the database's default encoding, while arguments or results of
   type <type>bytea</type> are in an encoding named by another argument.
  </para>
________________________________________________________-->
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   用于在不同字符集(编码)之间转换字符串的函数，以及用于以文本形式表示任意二进制数据的函数，在<xref linkend="functions-binarystring-conversions"/>中显示。
   对于这些函数，类型为<type>text</type>的参数或结果表示为数据库的默认编码，而类型为<type>bytea</type>的参数或结果表示为由另一个参数命名的编码。
  </para>
<!-- pgdoc-cn_end sig_en=4728a56741f0f729610932771ff6d93d -->

  <table id="functions-binarystring-conversions">
<!-- pgdoc-cn_start sig_en=af1c971b9e728c09e435d6b28389f64b sig_cn_org=None source=14.1 
   <title>Text/Binary String Conversion Functions</title>
________________________________________________________-->
   <title>Text/Binary String Conversion Functions</title>
<!-- pgdoc-cn_end sig_en=af1c971b9e728c09e435d6b28389f64b -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=83231b6b6fc436c9bfb12740dddc3990 sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       Function
      </para>
      <para>
       Description
      </para>
      <para>
       Example(s)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       函数
      </para>
      <para>
       描述
      </para>
      <para>
       例子
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=83231b6b6fc436c9bfb12740dddc3990 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=8130878cda8b77a1392ddc3bc79e4255 sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to a binary string in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为编码<parameter>dest_encoding</parameter>的二进制字符串
       (适用的转换请参阅<xref linkend="multibyte-conversions-supported"/>)。
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8130878cda8b77a1392ddc3bc79e4255 -->

<!-- pgdoc-cn_start sig_en=571c8ab0bb88ee7ad328fabd0c522210 sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to <type>text</type> in the database encoding
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为数据库编码中的<type>text</type>。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。	   
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=571c8ab0bb88ee7ad328fabd0c522210 -->

<!-- pgdoc-cn_start sig_en=0069a085753b4e6577ad6920832b19bb sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a <type>text</type> string (in the database encoding) to a
       binary string encoded in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将<type>text</type>字符串(数据库编码)转换为编码<parameter>dest_encoding</parameter>中编码的二进制字符串。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0069a085753b4e6577ad6920832b19bb -->

<!-- pgdoc-cn_start sig_en=9597e156552c8c8f3b14442dd047ec75 sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Encodes binary data into a textual representation; supported
       <parameter>format</parameter> values are:
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将二进制数据编码成文本表示；支持的<parameter>format</parameter>值为：
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9597e156552c8c8f3b14442dd047ec75 -->

<!-- pgdoc-cn_start sig_en=4482db4f1c0f7cc3829bd65dca8aff4c sig_cn_org=None source=14.1 
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Decodes binary data from a textual representation; supported
       <parameter>format</parameter> values are the same as
       for <function>encode</function>.
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       从文本表示中解码二进制数据;支持的<parameter>format</parameter>值与<function>encode</function>相同。
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4482db4f1c0f7cc3829bd65dca8aff4c -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=45954409e7e4cf9aecd584f84382773e sig_cn_org=fc07e0f7ae621a69939cad6f3a175222 source=15.7 
  <para>
   The <function>encode</function> and <function>decode</function>
   functions support the following textual formats:

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>base64</literal> format is that
       of <ulink url="https://datatracker.ietf.org/doc/html/rfc2045#section-6.8">RFC
       2045 Section 6.8</ulink>.  As per the <acronym>RFC</acronym>, encoded lines are
       broken at 76 characters.  However instead of the MIME CRLF
       end-of-line marker, only a newline is used for end-of-line.
       The <function>decode</function> function ignores carriage-return,
       newline, space, and tab characters.  Otherwise, an error is
       raised when <function>decode</function> is supplied invalid
       base64 data &mdash; including when trailing padding is incorrect.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>escape</literal> format converts zero bytes and
       bytes with the high bit set into octal escape sequences
       (<literal>\</literal><replaceable>nnn</replaceable>), and it doubles
       backslashes.  Other byte values are represented literally.
       The <function>decode</function> function will raise an error if a
       backslash is not followed by either a second backslash or three
       octal digits; it accepts other byte values unchanged.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>hex</literal> format represents each 4 bits of
       data as one hexadecimal digit, <literal>0</literal>
       through <literal>f</literal>, writing the higher-order digit of
       each byte first.  The <function>encode</function> function outputs
       the <literal>a</literal>-<literal>f</literal> hex digits in lower
       case.  Because the smallest unit of data is 8 bits, there are
       always an even number of characters returned
       by <function>encode</function>.
       The <function>decode</function> function
       accepts the <literal>a</literal>-<literal>f</literal> characters in
       either upper or lower case.  An error is raised
       when <function>decode</function> is given invalid hex data
       &mdash; including when given an odd number of characters.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   <function>encode</function>和<function>decode</function>函数支持以下文本格式：

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64格式</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>base64</literal>格式是<ulink url="https://datatracker.ietf.org/doc/html/rfc2045#section-6.8">RFC
       2045第6.8节</ulink>中描述的。根据<acronym>RFC</acronym>，编码行在76个字符处换行。
       然而，与MIME CRLF换行符不同，结尾只使用换行符。
       <function>decode</function>函数会忽略回车、换行、空格和制表符。
       否则，当<function>decode</function>提供无效的base64数据时，包括尾部填充不正确时，会引发错误。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>转义格式</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>escape</literal>格式将零字节和高位设置的字节转换为八进制转义序列
       (<literal>\</literal><replaceable>nnn</replaceable>)，并将反斜杠加倍。
       其他字节值会直接表示。如果反斜杠后面不是第二个反斜杠或三个八进制数字，则<function>decode</function>函数会引发错误；
       它会接受其他字节值不变。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>十六进制格式</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>hex</literal>格式将每4位数据表示为一个十六进制数字，<literal>0</literal>到<literal>f</literal>，
       先写入每个字节的高阶数字。 <function>encode</function>函数以小写输出<literal>a</literal>-<literal>f</literal>十六进制数字。
       因为数据的最小单位是8位，所以<function>encode</function>总是返回偶数个字符。
       <function>decode</function>函数接受<literal>a</literal>-<literal>f</literal>字符的大小写。
       当<function>decode</function>提供无效的十六进制数据时，包括提供奇数个字符时，会引发错误。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=45954409e7e4cf9aecd584f84382773e -->

<!-- pgdoc-cn_start sig_en=0f54a7d2d86a5466a4424f89209b6d0a sig_cn_org=None source=14.1 
  <para>
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
  </para>
________________________________________________________-->
  <para>
   参见<xref linkend="functions-aggregate"/>中的聚集函数<function>string_agg</function>以及<xref linkend="lo-funcs"/>中的大对象函数。
  </para>
<!-- pgdoc-cn_end sig_en=0f54a7d2d86a5466a4424f89209b6d0a -->
 </sect1>


  <sect1 id="functions-bitstring">
<!-- pgdoc-cn_start sig_en=8ddc9bb03340b9e8475c020eb474be34 sig_cn_org=None source=14.1 
   <title>Bit String Functions and Operators</title>
________________________________________________________-->
   <title>位串函数和操作符</title>
<!-- pgdoc-cn_end sig_en=8ddc9bb03340b9e8475c020eb474be34 -->

<!-- pgdoc-cn_start sig_en=8a9551ecef8e8b3e67598697bdd2bc98 sig_cn_org=None source=14.1 
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8a9551ecef8e8b3e67598697bdd2bc98 -->

<!-- pgdoc-cn_start sig_en=275f458fa14691db0edfd72ba3249c71 sig_cn_org=None source=14.1 
   <para>
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  (While only
    type <type>bit</type> is mentioned in these tables, values of
    type <type>bit varying</type> can be used interchangeably.)
    Bit strings support the usual comparison operators shown in
    <xref linkend="functions-comparison-op-table"/>, as well as the
    operators shown in <xref linkend="functions-bit-string-op-table"/>.
   </para>
________________________________________________________-->
   <para>
    本节描述用于检查和操作位串的函数和操作符，也就是操作类型为<type>bit</type>和<type>bit varying</type>的值的函数和操作符。
    (虽然这些表中只提到了<type>bit</type>类型，但<type>bit varying</type>类型的值可以互换使用。)
    位字符串支持<xref linkend="functions-comparison-op-table"/>中显示的常用比较操作符，就像<xref linkend="functions-bit-string-op-table"/>中显示的操作符。
   </para>
<!-- pgdoc-cn_end sig_en=275f458fa14691db0edfd72ba3249c71 -->

   <table id="functions-bit-string-op-table">
<!-- pgdoc-cn_start sig_en=bec8d98054283f55bbf368c5c67337e8 sig_cn_org=None source=14.1 
    <title>Bit String Operators</title>
________________________________________________________-->
    <title>位串操作符</title>
<!-- pgdoc-cn_end sig_en=bec8d98054283f55bbf368c5c67337e8 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=4fab3429e6bbc7e8c2033cea676bc643 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Concatenation
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        连接
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4fab3429e6bbc7e8c2033cea676bc643 -->

<!-- pgdoc-cn_start sig_en=f070c39c2a1079d8c6a4960ff6a7c434 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise AND (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位与（输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f070c39c2a1079d8c6a4960ff6a7c434 -->

<!-- pgdoc-cn_start sig_en=236a2303f7b46fb0230d4e2481145780 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=236a2303f7b46fb0230d4e2481145780 -->

<!-- pgdoc-cn_start sig_en=eb6f139114b33c5b6f3238f6d647156b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise exclusive OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位异或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eb6f139114b33c5b6f3238f6d647156b -->

<!-- pgdoc-cn_start sig_en=c58f78d095bda44a84542f5c583598f1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位求反
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c58f78d095bda44a84542f5c583598f1 -->

<!-- pgdoc-cn_start sig_en=e4fe7d8d3053b41770259d4aaca531c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift left
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位左移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e4fe7d8d3053b41770259d4aaca531c1 -->

<!-- pgdoc-cn_start sig_en=69ce69c0b3df563490ee6db25682b682 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift right
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位右移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69ce69c0b3df563490ee6db25682b682 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=af8d40ed5aea2e5a28d3fcca871c744a sig_cn_org=None source=14.1 
   <para>
    Some of the functions available for binary strings are also available
    for bit strings, as shown in <xref linkend="functions-bit-string-table"/>.
   </para>
________________________________________________________-->
   <para>
    一些可用于二进制字符串的函数也可用于位字符串，如<xref linkend="functions-bit-string-table"/>中所示。
   </para>
<!-- pgdoc-cn_end sig_en=af8d40ed5aea2e5a28d3fcca871c744a -->

   <table id="functions-bit-string-table">
<!-- pgdoc-cn_start sig_en=344723c9175699d68d2c7a84ac71752c sig_cn_org=None source=14.1 
    <title>Bit String Functions</title>
________________________________________________________-->
    <title>位字符串函数</title>
<!-- pgdoc-cn_end sig_en=344723c9175699d68d2c7a84ac71752c -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=32d8c5f1d25497aefcf2f3b06800d479 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <function>bit_count</function> ( <type>bit</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of bits set in the bit string (also known as
        <quote>popcount</quote>).
       </para>
       <para>
        <literal>bit_count(B'10111')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <function>bit_count</function> ( <type>bit</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回位字符串中设置的位数(也被视为<quote>popcount</quote>)。
       </para>
       <para>
        <literal>bit_count(B'10111')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=32d8c5f1d25497aefcf2f3b06800d479 -->

<!-- pgdoc-cn_start sig_en=c2665fee725dd3ffd2030b5e380a73cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c2665fee725dd3ffd2030b5e380a73cb -->

<!-- pgdoc-cn_start sig_en=ebd676a616136e039f8f6a76d494508c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ebd676a616136e039f8f6a76d494508c -->

<!-- pgdoc-cn_start sig_en=b360f160b2ceac88f48f7a172c2d3a1c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the bit string.
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的字节数。
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b360f160b2ceac88f48f7a172c2d3a1c -->

<!-- pgdoc-cn_start sig_en=8b047f0b88cf5a2b4d108360af1e1c60 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bits</parameter> that starts at
        the <parameter>start</parameter>'th bit and extends
        for <parameter>count</parameter> bits
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        替换从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，并将<parameter>newsubstring</parameter>扩展<parameter>count</parameter>位。
        如果<parameter>count</parameter>被省略，默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8b047f0b88cf5a2b4d108360af1e1c60 -->

<!-- pgdoc-cn_start sig_en=d3192a30f0b8eba84da62c51d69f7045 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns first starting index of the specified <parameter>substring</parameter>
        within <parameter>bits</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        按返回指定<parameter>substring</parameter>的第一个起始索引，以<parameter>bits</parameter>为单位，如果不存在则返回0。
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d3192a30f0b8eba84da62c51d69f7045 -->

<!-- pgdoc-cn_start sig_en=7003d8cf9c9aa71481e6662b2ef99547 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bits</parameter> starting at
        the <parameter>start</parameter>'th bit if that is specified,
        and stopping after <parameter>count</parameter> bits if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        如果指定了起始位，则提取从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，如果指定了计数位，则在<parameter>count</parameter>位之后停止。
        <parameter>start</parameter>和<parameter>count</parameter>至少提供一个。
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7003d8cf9c9aa71481e6662b2ef99547 -->

<!-- pgdoc-cn_start sig_en=5c503cc14215ffe2458410884c7f4d8e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th bit
        from bit string; the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从位字符串中提取第<parameter>n</parameter>位；第一个(最左)位为第0位。
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c503cc14215ffe2458410884c7f4d8e -->

<!-- pgdoc-cn_start sig_en=1053a1418cde1747e690ffc9aff85349 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Sets <parameter>n</parameter>'th bit in
        bit string to <parameter>newvalue</parameter>;
        the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        将位字符串中的第<parameter>n</parameter>位设置为<parameter>newvalue</parameter>；第一个(最左)位是第0位。
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1053a1418cde1747e690ffc9aff85349 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=9d5bdfa3b52b59e9ea082021ad0a31f3 sig_cn_org=None source=14.1 
   <para>
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Casting an integer to <type>bit(n)</type> copies the rightmost
    <literal>n</literal> bits.  Casting an integer to a bit string width wider
    than the integer itself will sign-extend on the left.
    Some examples:
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
   </para>
________________________________________________________-->
   <para>
    另外，我们可以在整数和<type>bit</type>之间来回转换。
    将一个整数转换为<type>bit(n)</type>会复制最右边的<literal>n</literal>位。
    将一个整数转换为比整数本身更宽的位字符串宽度将在左边进行符号扩展。一些例子：
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    请注意，如果只是转换为<quote>bit</quote>，意思是转换成<literal>bit(1)</literal>，因此只会转换整数的最低有效位。
   </para>
<!-- pgdoc-cn_end sig_en=9d5bdfa3b52b59e9ea082021ad0a31f3 -->
  </sect1>


 <sect1 id="functions-matching">
<!-- pgdoc-cn_start sig_en=66096ee5398e6a6b654be7df4e0af6b4 sig_cn_org=None source=14.1 
  <title>Pattern Matching</title>
________________________________________________________-->
  <title>模式匹配</title>
<!-- pgdoc-cn_end sig_en=66096ee5398e6a6b654be7df4e0af6b4 -->

<!-- pgdoc-cn_start sig_en=37a15ae4acd4a7f33840a1b5cd262a41 sig_cn_org=None source=14.1 
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=37a15ae4acd4a7f33840a1b5cd262a41 -->

<!-- pgdoc-cn_start sig_en=f0e510124cb66f05f544672013181027 sig_cn_org=None source=14.1 
   <para>
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了三种独立的实现模式匹配的方法：<acronym>SQL</acronym> <function>LIKE</function>操作符、更近一些的<function>SIMILAR TO</function>操作符（SQL:1999 里添加进来的）和<acronym>POSIX</acronym>-风格的正则表达式。除了这些基本的<quote>这个串匹配这个模式吗？</quote>操作符外，还有一些函数可用于提取或替换匹配子串并在匹配位置分离一个串。
   </para>
<!-- pgdoc-cn_end sig_en=f0e510124cb66f05f544672013181027 -->

   <tip>
<!-- pgdoc-cn_start sig_en=e3436a9c68ae501d9e1525fe1532f0e5 sig_cn_org=None source=14.1 
    <para>
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
    </para>
________________________________________________________-->
    <para>
     如果你的模式匹配的要求超出了这些，请考虑用 Perl 或 Tcl 写一个用户定义的函数。
    </para>
<!-- pgdoc-cn_end sig_en=e3436a9c68ae501d9e1525fe1532f0e5 -->
   </tip>

   <caution>
<!-- pgdoc-cn_start sig_en=6db1c46b1a918cd4375b5e902f9f1248 sig_cn_org=None source=14.1 
    <para>
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
    </para>
________________________________________________________-->
    <para>
     虽然大部分的正则表达式搜索都能被很快地执行，但是正则表达式仍可能被
     人为地弄成需要任意长的时间和任意量的内存进行处理。要当心从不怀好意
     的来源接受正则表达式搜索模式。如果必须这样做，建议加上语句超时限制。
    </para>
<!-- pgdoc-cn_end sig_en=6db1c46b1a918cd4375b5e902f9f1248 -->

<!-- pgdoc-cn_start sig_en=debc7663d9bab3cc9fe393379a71abfc sig_cn_org=None source=14.1 
    <para>
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
    </para>
________________________________________________________-->
    <para>
     使用<function>SIMILAR TO</function>模式的搜索具有同样的安全性危险，
     因为<function>SIMILAR TO</function>提供了很多和
     <acronym>POSIX</acronym>-风格正则表达式相同的能力。
    </para>
<!-- pgdoc-cn_end sig_en=debc7663d9bab3cc9fe393379a71abfc -->

<!-- pgdoc-cn_start sig_en=4d41cb920bfc22de149f98a83f08c1e1 sig_cn_org=None source=14.1 
    <para>
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
    </para>
________________________________________________________-->
    <para>
     <function>LIKE</function>搜索比其他两种选项简单得多，因此在使用
     不怀好意的模式来源时要更安全些。
    </para>
<!-- pgdoc-cn_end sig_en=4d41cb920bfc22de149f98a83f08c1e1 -->
   </caution>

<!-- pgdoc-cn_start sig_en=662d44867d312db1bba0ed6c2d79e8f9 sig_cn_org=None source=14.1 
   <para>
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
   </para>
________________________________________________________-->
   <para>
    这三种类型的模式匹配算子都不支持非确定性拼贴。 如果需要的话，可以在表达式中应用不同的拼贴来绕过这个限制。
   </para>
<!-- pgdoc-cn_end sig_en=662d44867d312db1bba0ed6c2d79e8f9 -->

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

<!-- pgdoc-cn_start sig_en=99063774c8edbba453de4f877e49afae sig_cn_org=None source=14.1 
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=99063774c8edbba453de4f877e49afae -->

<!-- pgdoc-cn_start sig_en=d7d259b6332f2f067bf1481074328c2f sig_cn_org=None source=14.1 
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
<!-- pgdoc-cn_end sig_en=d7d259b6332f2f067bf1481074328c2f -->

<!-- pgdoc-cn_start sig_en=debcbfe10d7e275e043682c1f9cc1bd9 sig_cn_org=None source=14.1 
    <para>
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
    </para>
________________________________________________________-->
    <para>
     如果该<replaceable>string</replaceable>匹配了提供的<replaceable>pattern</replaceable>，那么<function>LIKE</function>表达式返回真（和预期的一样，如果<function>LIKE</function>返回真，那么<function>NOT LIKE</function>表达式返回假， 反之亦然。一个等效的表达式是<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=debcbfe10d7e275e043682c1f9cc1bd9 -->

<!-- pgdoc-cn_start sig_en=5478b6630c0a494a4976460800b4fe66 sig_cn_org=None source=14.1 
    <para>
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
    </para>
________________________________________________________-->
    <para>
     如果<replaceable>pattern</replaceable>不包含百分号或者下划线，那么该模式只代表它本身的串；这时候<function>LIKE</function>的行为就象等号操作符。在<replaceable>pattern</replaceable>里的下划线 （<literal>_</literal>）代表（匹配）任何单个字符； 而一个百分号（<literal>%</literal>）匹配任何零或更多个字符的序列。
    </para>
<!-- pgdoc-cn_end sig_en=5478b6630c0a494a4976460800b4fe66 -->

<!-- pgdoc-cn_start sig_en=e8d176477fb6155ef6cb5d664a2a6dab sig_cn_org=None source=14.1 
   <para>
    Some examples:
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e8d176477fb6155ef6cb5d664a2a6dab -->

<!-- pgdoc-cn_start sig_en=df0691b3c13826a0ad5721a6a1ad87fa sig_cn_org=None source=14.1 
   <para>
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
   </para>
________________________________________________________-->
   <para>
    <function>LIKE</function>模式匹配总是覆盖整个串。因此，要匹配在串内任何位置的序列，该模式必须以百分号开头和结尾。
   </para>
<!-- pgdoc-cn_end sig_en=df0691b3c13826a0ad5721a6a1ad87fa -->

<!-- pgdoc-cn_start sig_en=acd6d68bdfce38488044af393952f338 sig_cn_org=None source=14.1 
   <para>
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
   </para>
________________________________________________________-->
   <para>
    要匹配文本的下划线或者百分号，而不是匹配其它字符， 在<replaceable>pattern</replaceable>里相应的字符必须 前导逃逸字符。缺省的逃逸字符是反斜线，但是你可以用<literal>ESCAPE</literal>子句指定一个不同的逃逸字符。 要匹配逃逸字符本身，写两个逃逸字符。
   </para>
<!-- pgdoc-cn_end sig_en=acd6d68bdfce38488044af393952f338 -->

   <note>
<!-- pgdoc-cn_start sig_en=47ab8201ac50caafd4c53ea7456693dd sig_cn_org=None source=14.1 
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，你在文串常量中写的任何反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
<!-- pgdoc-cn_end sig_en=47ab8201ac50caafd4c53ea7456693dd -->
   </note>

<!-- pgdoc-cn_start sig_en=1dfdc6e3baf563581641a015cc2f3ff7 sig_cn_org=None source=14.1 
   <para>
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
   </para>
________________________________________________________-->
   <para>
    请注意反斜线在串文本里已经有特殊含义了，所以如果你写一个 包含反斜线的模式常量，那你就要在 SQL 语句里写两个反斜线。 因此，写一个匹配单个反斜线的模式实际上要在语句里写四个反斜线。 你可以通过用 ESCAPE 选择一个不同的逃逸字符 来避免这样；这样反斜线就不再是 LIKE 的特殊字符了。 但仍然是字符文本分析器的特殊字符，所以你还是需要两个反斜线。)
    我们也可以通过写<literal>ESCAPE ''</literal>的方式不选择逃逸字符，这样可以有效地禁用逃逸机制，但是没有办法关闭下划线和百分号在模式中的特殊含义。
   </para>
<!-- pgdoc-cn_end sig_en=1dfdc6e3baf563581641a015cc2f3ff7 -->

<!-- pgdoc-cn_start sig_en=19223a7fc7fca8aae11a2b7b8e5ad4ac sig_cn_org=None source=14.1 
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
	因此，<productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>
<!-- pgdoc-cn_end sig_en=19223a7fc7fca8aae11a2b7b8e5ad4ac -->

<!-- pgdoc-cn_start sig_en=e7264a678d5970ac7525d9733742d70d sig_cn_org=None source=14.1 
   <para>
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    关键字<token>ILIKE</token>可以用于替换<token>LIKE</token>， 它令该匹配根据活动区域成为大小写无关。这个不属于<acronym>SQL</acronym>标准而是一个<productname>PostgreSQL</productname>扩展。
   </para>
<!-- pgdoc-cn_end sig_en=e7264a678d5970ac7525d9733742d70d -->

<!-- pgdoc-cn_start sig_en=e125164bd8f1835b3b18d56689eddd5d sig_cn_org=None source=14.1 
   <para>
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.  You may see these
    operator names in <command>EXPLAIN</command> output and similar
    places, since the parser actually translates <function>LIKE</function>
    et al. to these operators.
   </para>
________________________________________________________-->
   <para>
    操作符<literal>~~</literal>等效于<function>LIKE</function>， 而<literal>~~*</literal>对应<function>ILIKE</function>。 
    还有 <literal>!~~</literal>和<literal>!~~*</literal>操作符分别代表<function>NOT LIKE</function>和<function>NOT ILIKE</function>。
    所有这些操作符都是<productname>PostgreSQL</productname>特有的。
    你可能会在<command>EXPLAIN</command>输出和类似的地方看到这些操作符名称，因为解析器实际上将<function>LIKE</function>等翻译成这些运算符。
   </para>
<!-- pgdoc-cn_end sig_en=e125164bd8f1835b3b18d56689eddd5d -->

<!-- pgdoc-cn_start sig_en=bae6453482960ad4788bcf7dd1ea8508 sig_cn_org=None source=14.1 
   <para>
    The phrases <function>LIKE</function>, <function>ILIKE</function>,
    <function>NOT LIKE</function>, and <function>NOT ILIKE</function> are
    generally treated as operators
    in <productname>PostgreSQL</productname> syntax; for example they can
    be used in <replaceable>expression</replaceable>
    <replaceable>operator</replaceable> ANY
    (<replaceable>subquery</replaceable>) constructs, although
    an <literal>ESCAPE</literal> clause cannot be included there.  In some
    obscure cases it may be necessary to use the underlying operator names
    instead.
   </para>
________________________________________________________-->
   <para>
    短语<function>LIKE</function>，<function>ILIKE</function>，<function>NOT LIKE</function>，和 <function>NOT ILIKE</function> 在<productname>PostgreSQL</productname>语法中通常被视为操作符；
    例如，它们可以用于<replaceable>expression</replaceable> <replaceable>operator</replaceable>的任何（<replaceable>subquery</replaceable>）构造，尽管这里不能包含<literal>ESCAPE</literal>子句。
    在某些晦涩难懂的情况下，可能需要用底层操作符名称替代。
   </para>
<!-- pgdoc-cn_end sig_en=bae6453482960ad4788bcf7dd1ea8508 -->

<!-- pgdoc-cn_start sig_en=34507e68c30a4a38455ce93e862baf85 sig_cn_org=98d3c101a23e0630073e6671a6a78036 source=15.7 
   <para>
    Also see the starts-with operator <literal>^@</literal> and the
    corresponding <function>starts_with()</function> function, which are
    useful in cases where simply matching the beginning of a string is
    needed.
   </para>
________________________________________________________-->
   <para>
    另请参阅以<literal>^@</literal>开头的运算符和相应的<function>starts_with()</function>函数，
    在需要简单匹配字符串开头的情况下非常有用。
   </para>
<!-- pgdoc-cn_end sig_en=34507e68c30a4a38455ce93e862baf85 -->
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!-- pgdoc-cn_start sig_en=1eb918886fb93f1312cb4c35020c7692 sig_cn_org=None source=14.1 
   <title><function>SIMILAR TO</function> Regular Expressions</title>
________________________________________________________-->
   <title><function>SIMILAR TO</function>正则表达式</title>
<!-- pgdoc-cn_end sig_en=1eb918886fb93f1312cb4c35020c7692 -->

<!-- pgdoc-cn_start sig_en=572517f2531c1a07816508bd5e9ba271 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regular expression</primary>
    <!-&minus; <seealso>pattern matching</seealso> breaks index build -&minus;>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regular expression</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>
<!-- pgdoc-cn_end sig_en=572517f2531c1a07816508bd5e9ba271 -->

<!-- pgdoc-cn_start sig_en=bbc5e8e209396dcb43242ff01939c706 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bbc5e8e209396dcb43242ff01939c706 -->
<!-- pgdoc-cn_start sig_en=3e5a09e0979659b7e5a64d946c1f3298 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>substring</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3e5a09e0979659b7e5a64d946c1f3298 -->

<!-- pgdoc-cn_start sig_en=d8945203d6a19758ff2be60c9a8ca98f sig_cn_org=None source=14.1 
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
<!-- pgdoc-cn_end sig_en=d8945203d6a19758ff2be60c9a8ca98f -->

<!-- pgdoc-cn_start sig_en=cbd1544888e7cc9d4253ec1c2ccac125 sig_cn_org=None source=14.1 
   <para>
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common (POSIX) regular
    expression notation.
   </para>
________________________________________________________-->
   <para>
    <function>SIMILAR TO</function>操作符根据自己的模式是否匹配给定串而返回真或者假。 
    它和<function>LIKE</function>非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。 
    SQL 正则表达式是在<function>LIKE</function>标记和普通的(POSIX)正则表达式标记的奇怪的杂交。
   </para>
<!-- pgdoc-cn_end sig_en=cbd1544888e7cc9d4253ec1c2ccac125 -->

<!-- pgdoc-cn_start sig_en=a3dc89907ac61e7271c244f8ee5b82be sig_cn_org=None source=14.1 
   <para>
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
   </para>
________________________________________________________-->
   <para>
    类似<function>LIKE</function>，<function>SIMILAR TO</function>操作符只有在它的模式匹配整个串的时候才能成功；这一点和普通的 正则表达式的行为不同，在普通的正则表达式里，模式匹配串的任意部分。 和<function>LIKE</function>类似的地方还有，<function>SIMILAR TO</function>使用<literal>_</literal>和<literal>%</literal>作为分别代表任意单个字符和任意串的通配符（这些可以比得上 POSIX 正则表达式里的<literal>.</literal>和<literal>.*</literal>）。
   </para>
<!-- pgdoc-cn_end sig_en=a3dc89907ac61e7271c244f8ee5b82be -->

<!-- pgdoc-cn_start sig_en=b72e96fc5cb8c01c3b5eb5fddf225e77 sig_cn_org=None source=14.1 
   <para>
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal> denotes alternation (either of two alternatives).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
     </para>
    </listitem>
    <listitem>
     <para>
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
     </para>
    </listitem>
   </itemizedlist>

    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
   </para>
________________________________________________________-->
   <para>
    除了这些从<function>LIKE</function>借用的功能之外，<function>SIMILAR TO</function>支持下面这些从 POSIX 正则表达式借用的 模式匹配元字符：

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal>表示选择（两个候选之一）。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal>表示重复前面的项零次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal>表示重复前面的项一次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal>表示重复前面的项零次或一次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal>表示重复前面的项刚好<replaceable>m</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>表示重复前面的项<replaceable>m</replaceable>次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>表示重复前面的项至少<replaceable>m</replaceable>次并且不超过<replaceable>n</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      可以使用圆括号<literal>()</literal>把多个项组合成一个逻辑项。
     </para>
    </listitem>
    <listitem>
     <para>
      一个方括号表达式<literal>[...]</literal>声明一个字符类，就像 POSIX 正则表达式一样。
     </para>
    </listitem>
   </itemizedlist>

    注意点号（<literal>.</literal>）不是<function>SIMILAR TO</function>的一个元字符。
   </para>
<!-- pgdoc-cn_end sig_en=b72e96fc5cb8c01c3b5eb5fddf225e77 -->

<!-- pgdoc-cn_start sig_en=a2a93a98d3a4be8783e7c34119251891 sig_cn_org=None source=14.1 
   <para>
    As with <function>LIKE</function>, a backslash disables the special
    meaning of any of these metacharacters.  A different escape character
    can be specified with <literal>ESCAPE</literal>, or the escape
    capability can be disabled by writing <literal>ESCAPE ''</literal>.
   </para>
________________________________________________________-->
   <para>
    与<function>LIKE</function>一样，反斜杠将禁用这些元字符的特殊含义。
    可以用 <literal>ESCAPE</literal> 来指定不同的转义字符，或者可以通过写 <literal>ESCAPE ''</literal> 来禁用转义功能。
   </para>
<!-- pgdoc-cn_end sig_en=a2a93a98d3a4be8783e7c34119251891 -->

<!-- pgdoc-cn_start sig_en=19223a7fc7fca8aae11a2b7b8e5ad4ac sig_cn_org=None source=14.1 
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
	因此，<productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>
<!-- pgdoc-cn_end sig_en=19223a7fc7fca8aae11a2b7b8e5ad4ac -->

<!-- pgdoc-cn_start sig_en=c927a41f83699366007cdf6783900092 sig_cn_org=None source=14.1 
   <para>
    Another nonstandard extension is that following the escape character
    with a letter or digit provides access to the escape sequences
    defined for POSIX regular expressions; see
    <xref linkend="posix-character-entry-escapes-table"/>,
    <xref linkend="posix-class-shorthand-escapes-table"/>, and
    <xref linkend="posix-constraint-escapes-table"/> below.
   </para>
________________________________________________________-->
   <para>
    另一个非标准扩展是，在转义字符后面跟着一个字母或数字提供了对为POSIX正则表达式定义的转义序列的访问；参见下面的
    <xref linkend="posix-character-entry-escapes-table"/>，<xref linkend="posix-class-shorthand-escapes-table"/>，和 <xref linkend="posix-constraint-escapes-table"/> 。
   </para>
<!-- pgdoc-cn_end sig_en=c927a41f83699366007cdf6783900092 -->

<!-- pgdoc-cn_start sig_en=b851458bdd7c8426ea69fb44a5c5a5ac sig_cn_org=None source=14.1 
   <para>
    Some examples:
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=b851458bdd7c8426ea69fb44a5c5a5ac -->

<!-- pgdoc-cn_start sig_en=5d43941c7a2f1f0447589b395c3712a8 sig_cn_org=None source=14.1 
   <para>
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to standard SQL syntax:
<synopsis>
substring(<replaceable>string</replaceable> similar <replaceable>pattern</replaceable> escape <replaceable>escape-character</replaceable>)
</synopsis>
    or using the now obsolete SQL:1999 syntax:
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    or as a plain three-argument function:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!-&minus; " font-lock sanity -&minus;>
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
   </para>
________________________________________________________-->
   <para>
    带有三个参数的<function>substring</function>函数可以提取匹配SQL正则表达式模式的子字符串。 该函数可以按照标准SQL99语法编写。
<synopsis>
substring(<replaceable>string</replaceable> similar <replaceable>pattern</replaceable> escape <replaceable>escape-character</replaceable>)
</synopsis>
    或使用现在废除的 SQL:1999 语法:
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    或作为一个普通的三参数函数:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    与<literal>SIMILAR TO</literal>一样，指定的模式必须与整个数据字符串匹配，否则函数失败并返回空值。 为了表示匹配的数据子字符串的模式中，模式中应该包含两个转义字符的出现，并在后面加上一个双引号(<literal>"</literal>)。<!-- " font-lock sanity --> 匹配成功后，将返回与这些分隔符之间的模式部分匹配的文本。
   </para>
<!-- pgdoc-cn_end sig_en=5d43941c7a2f1f0447589b395c3712a8 -->

<!-- pgdoc-cn_start sig_en=da6289866c23267cfb67897292810119 sig_cn_org=None source=14.1 
   <para>
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
   </para>
________________________________________________________-->
   <para>
    转义-双引号分隔符实际上是  将<function>子字符串</function>的模式分成三个独立的 正则表达式；例如，竖条(<literal>|</literal>)  三节中的任何一节只影响到该节。 此外，第一节和第三种正则表达式的定义是为了匹配最小的  尽可能多的文字，而不是最大的文字，当有歧义的时候，就不应该是最大的文字。关于有多少数据字符串符合哪种模式。 (在POSIX术语中，第一和第三种正则表达式被强行规定为非贪婪)。
   </para>
<!-- pgdoc-cn_end sig_en=da6289866c23267cfb67897292810119 -->

<!-- pgdoc-cn_start sig_en=38bae538dafab99afb6eeb656336c2ac sig_cn_org=None source=14.1 
   <para>
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
   </para>
________________________________________________________-->
   <para>
    作为对SQL标准的扩展，<productname>PostgreSQL</productname>只允许有一个转义双引号分隔符，在这种情况下，第三个正则表达式被视为空；或者没有分隔符，在这种情况下，第一个和第三个正则表达式被视为空。
   </para>
<!-- pgdoc-cn_end sig_en=38bae538dafab99afb6eeb656336c2ac -->

<!-- pgdoc-cn_start sig_en=1da4d1b5b84dbe7e43bfe115c3f8cbf1 sig_cn_org=None source=14.1 
   <para>
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
<programlisting>
substring('foobar' similar '%#"o_b#"%' escape '#')   <lineannotation>oob</lineannotation>
substring('foobar' similar '#"o_b#"%' escape '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些例子，使用<literal>#&quot;</literal>定界返回串：
<programlisting>
substring('foobar' similar '%#"o_b#"%' escape '#')   <lineannotation>oob</lineannotation>
substring('foobar' similar '#"o_b#"%' escape '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=1da4d1b5b84dbe7e43bfe115c3f8cbf1 -->
  </sect2>

  <sect2 id="functions-posix-regexp">
<!-- pgdoc-cn_start sig_en=bd811e8f8d22408d64b62c60cbbcfa80 sig_cn_org=None source=14.1 
   <title><acronym>POSIX</acronym> Regular Expressions</title>
________________________________________________________-->
   <title><acronym>POSIX</acronym>正则表达式</title>
<!-- pgdoc-cn_end sig_en=bd811e8f8d22408d64b62c60cbbcfa80 -->

<!-- pgdoc-cn_start sig_en=3a75a62e37edbcbd0a2a6f44d56b3f2f sig_cn_org=None source=14.1 
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3a75a62e37edbcbd0a2a6f44d56b3f2f -->
<!-- pgdoc-cn_start sig_en=3e5a09e0979659b7e5a64d946c1f3298 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>substring</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3e5a09e0979659b7e5a64d946c1f3298 -->
<!-- pgdoc-cn_start sig_en=18db4a322cd7331117efcfd005fb492e sig_cn_org=0a56741e31fe25ae29c172b44000115c source=15.7 
   <indexterm>
    <primary>regexp_count</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_count</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=18db4a322cd7331117efcfd005fb492e -->
<!-- pgdoc-cn_start sig_en=c3b527bec6a2f1be220eff2b7e6195d5 sig_cn_org=2542a0d9a16d948127c89aa8b6687dbc source=15.7 
   <indexterm>
    <primary>regexp_instr</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_instr</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c3b527bec6a2f1be220eff2b7e6195d5 -->
<!-- pgdoc-cn_start sig_en=bb8193084fb9a6f2666450f5f11be597 sig_cn_org=0e0a90dfd697ba6f8c77bd46cf95089e source=15.7 
   <indexterm>
    <primary>regexp_like</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_like</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bb8193084fb9a6f2666450f5f11be597 -->
<!-- pgdoc-cn_start sig_en=dae9935a06c401d391c27b0f0fbad112 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dae9935a06c401d391c27b0f0fbad112 -->
<!-- pgdoc-cn_start sig_en=85181408134eb6ae18089062bffb353b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=85181408134eb6ae18089062bffb353b -->
<!-- pgdoc-cn_start sig_en=1eb19c18a865b65a7ef30254f2352c4e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1eb19c18a865b65a7ef30254f2352c4e -->
<!-- pgdoc-cn_start sig_en=9de06a40e3b3bdd368dc50b1da4cd26e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9de06a40e3b3bdd368dc50b1da4cd26e -->
<!-- pgdoc-cn_start sig_en=5a05a392a7e78d690ca394be779ad7ec sig_cn_org=None source=14.1 
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5a05a392a7e78d690ca394be779ad7ec -->
<!-- pgdoc-cn_start sig_en=7b45de1923a06edd5b9ec80e2f9165f1 sig_cn_org=4a340131171b89652f2fbfa9d964ab8a source=15.7 
   <indexterm>
    <primary>regexp_substr</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>regexp_substr</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=7b45de1923a06edd5b9ec80e2f9165f1 -->

<!-- pgdoc-cn_start sig_en=474019362f50bfbebf1f3a0591a3b7fb sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-posix-table"/>列出了所有可用于 POSIX 正则表达式模式匹配的操作符。
   </para>
<!-- pgdoc-cn_end sig_en=474019362f50bfbebf1f3a0591a3b7fb -->

   <table id="functions-posix-table">
<!-- pgdoc-cn_start sig_en=d8b40fef5e060d2fff06fb876fbbbbb8 sig_cn_org=None source=14.1 
    <title>Regular Expression Match Operators</title>
________________________________________________________-->
    <title>正则表达式匹配操作符</title>
<!-- pgdoc-cn_end sig_en=d8b40fef5e060d2fff06fb876fbbbbb8 -->

    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=345526701861654b16b7a4e33750a457 sig_cn_org=None source=14.1 
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' ~ 't.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' ~ 't.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=345526701861654b16b7a4e33750a457 -->

<!-- pgdoc-cn_start sig_en=74bf507b24a45710ba4568b3b0603751 sig_cn_org=None source=14.1 
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' ~* 'T.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' ~* 'T.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=74bf507b24a45710ba4568b3b0603751 -->

<!-- pgdoc-cn_start sig_en=077c23712c8cca1646fe7b9784e18590 sig_cn_org=None source=14.1 
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' !~ 't.*max'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' !~ 't.*max'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=077c23712c8cca1646fe7b9784e18590 -->

<!-- pgdoc-cn_start sig_en=d75586669825d03bd9fc30bfc10331ca sig_cn_org=None source=14.1 
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' !~* 'T.*ma'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>
________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' !~* 'T.*ma'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=d75586669825d03bd9fc30bfc10331ca -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=5d8b087e6803f26deb4b0b7bc0e91340 sig_cn_org=None source=14.1 
    <para>
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
    </para>
________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>正则表达式提供了比<function>LIKE</function>和<function>SIMILAR TO</function>操作符更强大的含义。许多 Unix 工具，例如<command>egrep</command>、<command>sed</command>或<command>awk</command>使用一种与我们这里描述的类似的模式匹配语言。
    </para>
<!-- pgdoc-cn_end sig_en=5d8b087e6803f26deb4b0b7bc0e91340 -->

<!-- pgdoc-cn_start sig_en=9055183df01116877db1545ce6588b06 sig_cn_org=None source=14.1 
    <para>
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
    </para>
________________________________________________________-->
    <para>
     正则表达式是一个字符序列，它是定义一个串集合 （一个<firstterm>正则集</firstterm>）的缩写。 如果一个串是正则表达式描述的正则集中的一员时， 我们就说这个串匹配该正则表达式。 和<function>LIKE</function>一样，模式字符准确地匹配串字符， 除非在正则表达式语言里有特殊字符 &mdash; 不过正则表达式用的 特殊字符和<function>LIKE</function>用的不同。 和<function>LIKE</function>模式不一样的是，正则表达式允许匹配串里的任何位置，除非该正则表达式显式地挂接在串的开头或者结尾。
    </para>
<!-- pgdoc-cn_end sig_en=9055183df01116877db1545ce6588b06 -->

<!-- pgdoc-cn_start sig_en=a7efb01633b12b8f26d3d6e374e8b925 sig_cn_org=None source=14.1 
    <para>
     Some examples:
<programlisting>
'abcd' ~ 'bc'     <lineannotation>true</lineannotation>
'abcd' ~ 'a.c'    <lineannotation>true &mdash; dot matches any character</lineannotation>
'abcd' ~ 'a.*d'   <lineannotation>true &mdash; <literal>*</literal> repeats the preceding pattern item</lineannotation>
'abcd' ~ '(b|x)'  <lineannotation>true &mdash; <literal>|</literal> means OR, parentheses group</lineannotation>
'abcd' ~ '^a'     <lineannotation>true &mdash; <literal>^</literal> anchors to start of string</lineannotation>
'abcd' ~ '^(b|c)' <lineannotation>false &mdash; would match except for anchoring</lineannotation>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一些例子：
<programlisting>
'abcd' ~ 'bc'     <lineannotation>true</lineannotation>
'abcd' ~ 'a.c'    <lineannotation>true &mdash; dot matches any character</lineannotation>
'abcd' ~ 'a.*d'   <lineannotation>true &mdash; <literal>*</literal> repeats the preceding pattern item</lineannotation>
'abcd' ~ '(b|x)'  <lineannotation>true &mdash; <literal>|</literal> means OR, parentheses group</lineannotation>
'abcd' ~ '^a'     <lineannotation>true &mdash; <literal>^</literal> anchors to start of string</lineannotation>
'abcd' ~ '^(b|c)' <lineannotation>false &mdash; would match except for anchoring</lineannotation>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=a7efb01633b12b8f26d3d6e374e8b925 -->

<!-- pgdoc-cn_start sig_en=4b198e51574ed17724a2b8a69da2a736 sig_cn_org=None source=14.1 
    <para>
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
    </para>
________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>模式语言的详细描述见下文。
    </para>
<!-- pgdoc-cn_end sig_en=4b198e51574ed17724a2b8a69da2a736 -->

<!-- pgdoc-cn_start sig_en=52292aab3ebf4611973ba156b19fd107 sig_cn_org=None source=14.1 
    <para>
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the first portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
    </para>
________________________________________________________-->
    <para>
     带两个参数的<function>substring</function>函数，即<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable>)</function>，提供了抽取一个匹配 POSIX 正则表达式模式的子串的方法。
     如果没有匹配它返回空值，否则就是匹配模式的文本中的第一部分。 
     但是如果该模式包含任何圆括号，那么将返回匹配第一对子表达式（对应第一个左圆括号的） 的文本。
     如果你想在表达式里使用圆括号而又不想导致这个例外，那么你可以在整个表达式外边放上一对圆括号。 
     如果你需要在想抽取的子表达式前有圆括号，参阅后文描述的非捕获性圆括号。
    </para>
<!-- pgdoc-cn_end sig_en=52292aab3ebf4611973ba156b19fd107 -->

<!-- pgdoc-cn_start sig_en=85a50a63fed0c852c45fd844b85c7a4f sig_cn_org=None source=14.1 
   <para>
    Some examples:
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些例子：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=85a50a63fed0c852c45fd844b85c7a4f -->

<!-- pgdoc-cn_start sig_en=5ce46ce4815f4a47765fda3637331791 sig_cn_org=1a88e5ca5c23f4318258e291634d9bb2 source=15.7 
    <para>
     The <function>regexp_count</function> function counts the number of
     places where a POSIX regular expression pattern matches a string.
     It has the syntax
     <function>regexp_count</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>flags</replaceable>
     </optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  For example, including <literal>i</literal> in
     <replaceable>flags</replaceable> specifies case-insensitive matching.
     Supported flags are described in
     <xref linkend="posix-embedded-options-table"/>.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_count</function>函数计算 POSIX 正则表达式模式与字符串匹配的次数。
     它的语法为
     <function>regexp_count</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>flags</replaceable>
     </optional></optional>)。
     <replaceable>pattern</replaceable>在<replaceable>string</replaceable>中进行搜索，
     通常从字符串的开头开始，但如果提供了<replaceable>start</replaceable>参数，则从该字符索引开始。
     <replaceable>flags</replaceable>参数是一个可选的文本字符串，包含零个或多个单字母标志，改变函数的行为。
     例如，在<replaceable>flags</replaceable>中包含<literal>i</literal>指定不区分大小写匹配。
     支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=5ce46ce4815f4a47765fda3637331791 -->

<!-- pgdoc-cn_start sig_en=806d47391a8282ad89c4d86d6145f3cf sig_cn_org=1e48ad0fd0641166fb8b5a9d10cf11ed source=15.7 
    <para>
     Some examples:
<programlisting>
regexp_count('ABCABCAXYaxy', 'A.')          <lineannotation>3</lineannotation>
regexp_count('ABCABCAXYaxy', 'A.', 1, 'i')  <lineannotation>4</lineannotation>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一些示例:
<programlisting>
regexp_count('ABCABCAXYaxy', 'A.')          <lineannotation>3</lineannotation>
regexp_count('ABCABCAXYaxy', 'A.', 1, 'i')  <lineannotation>4</lineannotation>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=806d47391a8282ad89c4d86d6145f3cf -->

<!-- pgdoc-cn_start sig_en=3570fe78c07979cdac72a16f55ae1287 sig_cn_org=f881b180ba1beaedf63194369fba3861 source=15.7 
    <para>
     The <function>regexp_instr</function> function returns the starting or
     ending position of the <replaceable>N</replaceable>'th match of a
     POSIX regular expression pattern to a string, or zero if there is no
     such match.  It has the syntax
     <function>regexp_instr</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>endoption</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     If <replaceable>N</replaceable> is specified
     then the <replaceable>N</replaceable>'th match of the pattern
     is located, otherwise the first match is located.
     If the <replaceable>endoption</replaceable> parameter is omitted or
     specified as zero, the function returns the position of the first
     character of the match.  Otherwise, <replaceable>endoption</replaceable>
     must be one, and the function returns the position of the character
     following the match.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     For a pattern containing parenthesized
     subexpressions, <replaceable>subexpr</replaceable> is an integer
     indicating which subexpression is of interest: the result identifies
     the position of the substring matching that subexpression.
     Subexpressions are numbered in the order of their leading parentheses.
     When <replaceable>subexpr</replaceable> is omitted or zero, the result
     identifies the position of the whole match regardless of
     parenthesized subexpressions.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_instr</function>函数返回字符串中第<replaceable>N</replaceable>个匹配项的起始或结束位置，如果没有这样的匹配项则返回零。
     它的语法为<function>regexp_instr</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>endoption</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional></optional>).
     在<replaceable>string</replaceable>中搜索<replaceable>pattern</replaceable>，通常从字符串的开头开始，但如果提供了<replaceable>start</replaceable>参数，则从该字符索引开始。
     如果指定了<replaceable>N</replaceable>，则定位模式的第<replaceable>N</replaceable>个匹配项，否则定位第一个匹配项。
     如果省略了<replaceable>endoption</replaceable>参数或将其指定为0，则函数返回匹配项的第一个字符的位置。否则，<replaceable>endoption</replaceable>
     必须为1，函数返回匹配项后面字符的位置。
     <replaceable>flags</replaceable>参数是一个可选的文本字符串，包含零个或多个单字母标志，可以改变函数的行为。支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
     对于包含括号子表达式的模式，<replaceable>subexpr</replaceable>是一个整数，表示感兴趣的子表达式：结果标识与该子表达式匹配的子字符串的位置。
     子表达式按其前导括号的顺序编号。
     当省略或将<replaceable>subexpr</replaceable>指定为零时，结果标识整个匹配的位置，而不考虑括号子表达式。
</para>
<!-- pgdoc-cn_end sig_en=3570fe78c07979cdac72a16f55ae1287 -->

<!-- pgdoc-cn_start sig_en=96eb92b5d16307e0a8fdf1ed3dd22cd2 sig_cn_org=2e88c7ac07640fcd5a1bd17cd6d9eb3d source=15.7 
    <para>
     Some examples:
<programlisting>
regexp_instr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation>23</lineannotation>
regexp_instr('ABCDEFGHI', '(c..)(...)', 1, 1, 0, 'i', 2)
                                   <lineannotation>6</lineannotation>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一些示例:
<programlisting>
regexp_instr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation>23</lineannotation>
regexp_instr('ABCDEFGHI', '(c..)(...)', 1, 1, 0, 'i', 2)
                                   <lineannotation>6</lineannotation>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=96eb92b5d16307e0a8fdf1ed3dd22cd2 -->

<!-- pgdoc-cn_start sig_en=f522a09f8c5501fe8b6d5502c856e445 sig_cn_org=53cfb8226b8237b9972093ed4c88072f source=15.7 
    <para>
     The <function>regexp_like</function> function checks whether a match
     of a POSIX regular expression pattern occurs within a string,
     returning boolean true or false.  It has the syntax
     <function>regexp_like</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     This function has the same results as the <literal>~</literal>
     operator if no flags are specified.  If only the <literal>i</literal>
     flag is specified, it has the same results as
     the <literal>~*</literal> operator.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_like</function>函数检查字符串中是否存在 POSIX 正则表达式模式的匹配，
     返回布尔值 true 或 false。它的语法为
     <function>regexp_like</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>)。
     <replaceable>flags</replaceable>参数是一个可选的文本字符串，包含零个或多个单字母标志，
     可以改变函数的行为。支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
     如果没有指定标志，此函数的结果与<literal>~</literal>操作符相同。
     如果只指定了<literal>i</literal>标志，则结果与<literal>~*</literal>操作符相同。
</para>
<!-- pgdoc-cn_end sig_en=f522a09f8c5501fe8b6d5502c856e445 -->

<!-- pgdoc-cn_start sig_en=a6f8f49e65e87cf2da00b15f78688672 sig_cn_org=5491e61eda5fca277c545f2bfbf2895b source=15.7 
    <para>
     Some examples:
<programlisting>
regexp_like('Hello World', 'world')       <lineannotation>false</lineannotation>
regexp_like('Hello World', 'world', 'i')  <lineannotation>true</lineannotation>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一些示例:
<programlisting>
regexp_like('Hello World', 'world')       <lineannotation>false</lineannotation>
regexp_like('Hello World', 'world', 'i')  <lineannotation>true</lineannotation>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=a6f8f49e65e87cf2da00b15f78688672 -->

<!-- pgdoc-cn_start sig_en=d90d6e6d850ee782e6e134e00662eb0a sig_cn_org=74a0b93cdccbc755a6c4d7bed3c5730b source=15.7 
    <para>
     The <function>regexp_match</function> function returns a text array of
     matching substring(s) within the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_match</function>函数返回一个文本数组，其中包含与POSIX正则表达式模式对字符串的第一个匹配的子字符串。它的语法为
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。
     如果没有匹配，结果为<literal>NULL</literal>。
     如果找到匹配，并且<replaceable>pattern</replaceable>不包含括号子表达式，则结果是包含与整个模式匹配的子字符串的单元素文本数组。
     如果找到匹配，并且<replaceable>pattern</replaceable>包含括号子表达式，则结果是一个文本数组，其中<replaceable>n</replaceable>的元素是匹配
     <replaceable>pattern</replaceable>的第<replaceable>n</replaceable>个括号子表达式的子字符串（不包括<quote>非捕获</quote>括号；详情见下文）。
     <replaceable>flags</replaceable>参数是一个可选的文本字符串，其中包含零个或多个单个字母标志，用于更改函数的行为。支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=d90d6e6d850ee782e6e134e00662eb0a -->

<!-- pgdoc-cn_start sig_en=9618aa53fb7c4db4e146098961cffcbc sig_cn_org=1857304faea46712ab52908728b79627 source=15.7 
   <para>
    Some examples:
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
(1 row)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些示例:
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=9618aa53fb7c4db4e146098961cffcbc -->

    <tip>
<!-- pgdoc-cn_start sig_en=05f49ab5b9f0e2576faae619c24ab427 sig_cn_org=9944bf1ff4267bf88f12dcb853237ad8 source=15.7 
     <para>
      In the common case where you just want the whole matching substring
      or <literal>NULL</literal> for no match, the best solution is to
      use <function>regexp_substr()</function>.
      However, <function>regexp_substr()</function> only exists
      in <productname>PostgreSQL</productname> version 15 and up.  When
      working in older versions, you can extract the first element
      of <function>regexp_match()</function>'s result, for example:
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 barbeque
(1 row)
</programlisting>
     </para>
________________________________________________________-->
     <para>
      在通常情况下，当您只想要整个匹配的子字符串或<literal>NULL</literal>表示没有匹配时，
      最好的解决方案是使用<function>regexp_substr()</function>。
      然而，在<productname>PostgreSQL</productname>版本15及以上版本中才存在
      <function>regexp_substr()</function>。在旧版本中工作时，您可以提取
      <function>regexp_match()</function>结果的第一个元素，例如：
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=05f49ab5b9f0e2576faae619c24ab427 -->
    </tip>

<!-- pgdoc-cn_start sig_en=32383dea6fbd537ecd41971607aa652b sig_cn_org=6ae56cfc745a8f25318570f6572c9ce8 source=15.7 
    <para>
     The <function>regexp_matches</function> function returns a set of text arrays
     of matching substring(s) within matches of a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_matches</function>函数返回一个文本数组的集合，其中包含与POSIX正则表达式模式匹配的子字符串。
     它具有与<function>regexp_match</function>相同的语法。
     如果没有匹配，则此函数不返回任何行；如果有匹配且未给出<literal>g</literal>标志，则返回一行；
     如果有<replaceable>N</replaceable>个匹配且给出<literal>g</literal>标志，则返回<replaceable>N</replaceable>行。
     每个返回的行都是一个文本数组，其中包含整个匹配的子字符串或与<replaceable>pattern</replaceable>的括号子表达式匹配的子字符串，
     就像<function>regexp_match</function>中描述的那样。
     <function>regexp_matches</function>接受在<xref linkend="posix-embedded-options-table"/>中显示的所有标志，
     还接受<literal>g</literal>标志，该标志命令它返回所有匹配项，而不仅仅是第一个匹配项。
</para>
<!-- pgdoc-cn_end sig_en=32383dea6fbd537ecd41971607aa652b -->

<!-- pgdoc-cn_start sig_en=215f32e68513dfeb9df3005c845fbd00 sig_cn_org=None source=14.1 
   <para>
    Some examples:
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些例子：
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=215f32e68513dfeb9df3005c845fbd00 -->

   <tip>
<!-- pgdoc-cn_start sig_en=198e465e3ec889764eb9a75f3201e8a8 sig_cn_org=None source=14.1 
    <para>
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
    </para>
________________________________________________________-->
    <para>
     在大部分情况下，<function>regexp_matches()</function>应该与<literal>g</literal>标志一起使用，因为如果只是想要第一个匹配，使用<function>regexp_match()</function>会更加简单高效。不过，<function>regexp_match()</function>仅存在于<productname>PostgreSQL</productname>版本10以及更高的版本中。当在较老的版本中使用时，一种常用的技巧是把<function>regexp_matches()</function>调用放在子选择中，例如：
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     如果有一个匹配，则这个语句会产生一个文本数组，否则返回<literal>NULL</literal>，这和<function>regexp_match()</function>的做法一样。如果没有子选择，这个查询对于没有匹配的表行根本不会产生输出，显然那不是想要的行为。
    </para>
<!-- pgdoc-cn_end sig_en=198e465e3ec889764eb9a75f3201e8a8 -->
   </tip>

<!-- pgdoc-cn_start sig_en=1758842364f06d233fa5e57c4d9eca49 sig_cn_org=a692b064b2db1a05a4a2c0a8ec577c0e source=15.7 
    <para>
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     </optional></optional>
     <optional>, <replaceable>flags</replaceable> </optional>).
     (Notice that <replaceable>N</replaceable> cannot be specified
     unless <replaceable>start</replaceable> is,
     but <replaceable>flags</replaceable> can be given in any case.)
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     By default, only the first match of the pattern is replaced.
     If <replaceable>N</replaceable> is specified and is greater than zero,
     then the <replaceable>N</replaceable>'th match of the pattern
     is replaced.
     If the <literal>g</literal> flag is given, or
     if <replaceable>N</replaceable> is specified and is zero, then all
     matches at or after the <replaceable>start</replaceable> position are
     replaced.  (The <literal>g</literal> flag is ignored
     when <replaceable>N</replaceable> is specified.)
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_replace</function>函数提供了对匹配POSIX正则表达式模式的子字符串进行替换的功能。
     它的语法为
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     </optional></optional>
     <optional>, <replaceable>flags</replaceable> </optional>).
     (注意，除非指定了<replaceable>start</replaceable>，否则无法指定<replaceable>N</replaceable>，
     但<replaceable>flags</replaceable>可以在任何情况下给出。)
     如果<replaceable>pattern</replaceable>没有匹配到<replaceable>source</replaceable>字符串，
     则返回未更改的<replaceable>source</replaceable>字符串。如果有匹配，则返回带有
     <replaceable>replacement</replaceable>字符串替换匹配子字符串的<replaceable>source</replaceable>字符串。
     <replaceable>replacement</replaceable>字符串可以包含<literal>\</literal><replaceable>n</replaceable>，
     其中<replaceable>n</replaceable>为1至9，表示应插入与模式的第<replaceable>n</replaceable>个括号子表达式匹配的源子字符串，
     也可以包含<literal>\&amp;</literal>表示应插入与整个模式匹配的子字符串。
     如果需要在替换文本中放置一个字面上的反斜杠，则写<literal>\\</literal>。
     在<replaceable>string</replaceable>中搜索<replaceable>pattern</replaceable>，
     通常从字符串的开头开始，但如果提供了<replaceable>start</replaceable>参数，则从该字符索引开始。
     默认情况下，只替换模式的第一个匹配项。
     如果指定了<replaceable>N</replaceable>且大于零，则替换模式的第<replaceable>N</replaceable>个匹配项。
     如果给出了<literal>g</literal>标志，或者指定了<replaceable>N</replaceable>且为零，则在或之后的所有匹配项
     位置都将被替换。 （当指定了<replaceable>N</replaceable>时，<literal>g</literal>标志将被忽略。）
     <replaceable>flags</replaceable>参数是一个可选的文本字符串，包含零个或多个单字母标志，用于更改函数的行为。
     支持的标志（尽管不包括<literal>g</literal>）在<xref linkend="posix-embedded-options-table"/>中描述。
</para>
<!-- pgdoc-cn_end sig_en=1758842364f06d233fa5e57c4d9eca49 -->

<!-- pgdoc-cn_start sig_en=23abba7e0bfe7e7d5d5efe3294e5f090 sig_cn_org=f8cce996beffc4b0d1dc51ed77883c4c source=15.7 
   <para>
    Some examples:
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 0, 'i')
                                   <lineannotation>X PXstgrXSQL fXnctXXn</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 3, 'i')
                                   <lineannotation>A PostgrXSQL function</lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些示例:
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 0, 'i')
                                   <lineannotation>X PXstgrXSQL fXnctXXn</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 3, 'i')
                                   <lineannotation>A PostgrXSQL function</lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=23abba7e0bfe7e7d5d5efe3294e5f090 -->

<!-- pgdoc-cn_start sig_en=4b97e26455b1d7685f54950beda31035 sig_cn_org=None source=14.1 
    <para>
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_split_to_table</function>把一个 POSIX 正则表达式模式当作一个定界符来分离一个串。它的语法形式是<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。如果没有与<replaceable>pattern</replaceable>的匹配，该函数返回<replaceable>string</replaceable>。如果有至少有一个匹配，对每一个匹配它都返回从上一个匹配的末尾（或者串的开头）到这次匹配开头之间的文本。当没有更多匹配时，它返回从上一次匹配的末尾到串末尾之间的文本。<replaceable>flags</replaceable>参数是一个可选的文本串，它包含零个或更多单字母标志，这些标识可以改变该函数的行为。<function>regexp_split_to_table</function>能支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=4b97e26455b1d7685f54950beda31035 -->

<!-- pgdoc-cn_start sig_en=cb3b279c9c2e286220ef892dd5926d2d sig_cn_org=None source=14.1 
    <para>
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_split_to_array</function>函数的行为和<function>regexp_split_to_table</function>相同，不过<function>regexp_split_to_array</function>会把它的结果以一个<type>text</type>数组的形式返回。它的语法是<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。这些参数和<function>regexp_split_to_table</function>的相同。
    </para>
<!-- pgdoc-cn_end sig_en=cb3b279c9c2e286220ef892dd5926d2d -->

<!-- pgdoc-cn_start sig_en=0fbf6ff361b55e9d9bd8d64af5cf90aa sig_cn_org=77220b75235b0a7eddbc1f2678baa334 source=15.7 
   <para>
    Some examples:
<programlisting>
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo
-&minus;-&minus;-&minus;-
 the
 quick
 brown
 fox
 jumps
 over
 the
 lazy
 dog
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo
-&minus;-&minus;-
 t
 h
 e
 q
 u
 i
 c
 k
 b
 r
 o
 w
 n
 f
 o
 x
(16 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一些示例:
<programlisting>
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo
-------
 the
 quick
 brown
 fox
 jumps
 over
 the
 lazy
 dog
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo
-----
 t
 h
 e
 q
 u
 i
 c
 k
 b
 r
 o
 w
 n
 f
 o
 x
(16 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0fbf6ff361b55e9d9bd8d64af5cf90aa -->

<!-- pgdoc-cn_start sig_en=fccd46f9b7e79111955e5fc5c43ab04d sig_cn_org=ae15f176858505b8a5ad3f27c5ddd2ba source=15.7 
   <para>
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    the other regexp functions, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
   </para>
________________________________________________________-->
   <para>
    正如最后一个示例所示，regexp分割函数会忽略出现在字符串开头或结尾
    或紧跟在前一个匹配项之后的零长度匹配。这与其他regexp函数实现的
    严格的regexp匹配定义相矛盾，但在实践中通常是最方便的行为。
    其他软件系统如Perl使用类似的定义。
</para>
<!-- pgdoc-cn_end sig_en=fccd46f9b7e79111955e5fc5c43ab04d -->

<!-- pgdoc-cn_start sig_en=245aec611c2b4a0a0aecd727cf7cd17b sig_cn_org=b0104cd0f45771eaa1d9eafa2cff588d source=15.7 
    <para>
     The <function>regexp_substr</function> function returns the substring
     that matches a POSIX regular expression pattern,
     or <literal>NULL</literal> if there is no match.  It has the syntax
     <function>regexp_substr</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     If <replaceable>N</replaceable> is specified
     then the <replaceable>N</replaceable>'th match of the pattern
     is returned, otherwise the first match is returned.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     For a pattern containing parenthesized
     subexpressions, <replaceable>subexpr</replaceable> is an integer
     indicating which subexpression is of interest: the result is the
     substring matching that subexpression.
     Subexpressions are numbered in the order of their leading parentheses.
     When <replaceable>subexpr</replaceable> is omitted or zero, the result
     is the whole match regardless of parenthesized subexpressions.
    </para>
________________________________________________________-->
    <para>
     <function>regexp_substr</function>函数返回与POSIX正则表达式模式匹配的子字符串，
     如果没有匹配，则返回<literal>NULL</literal>。它的语法为
     <function>regexp_substr</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional>）。
     <replaceable>pattern</replaceable>在<replaceable>string</replaceable>中进行搜索，
     通常从字符串的开头开始，但如果提供了<replaceable>start</replaceable>参数，则从该字符索引开始。
     如果指定了<replaceable>N</replaceable>，则返回模式的第<replaceable>N</replaceable>次匹配，
     否则返回第一次匹配。参数<replaceable>flags</replaceable>是一个可选文本字符串，
     包含零个或多个单字母标志，可以改变函数的行为。支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
     对于包含括号子表达式的模式，<replaceable>subexpr</replaceable>是一个整数，
     表示感兴趣的子表达式：结果是与该子表达式匹配的子字符串。
     子表达式按其前导括号的顺序编号。
     当省略或为零时，<replaceable>subexpr</replaceable>的结果是整个匹配，而不考虑括号子表达式。
    </para>
<!-- pgdoc-cn_end sig_en=245aec611c2b4a0a0aecd727cf7cd17b -->

<!-- pgdoc-cn_start sig_en=412759d850281da99cb86bd6920aed1a sig_cn_org=a0985ec63dc32e84126ff6c6e797c247 source=15.7 
    <para>
     Some examples:
<programlisting>
regexp_substr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation> town zip</lineannotation>
regexp_substr('ABCDEFGHI', '(c..)(...)', 1, 1, 'i', 2)
                                   <lineannotation>FGH</lineannotation>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一些示例:
<programlisting>
regexp_substr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation> 城镇 邮编</lineannotation>
regexp_substr('ABCDEFGHI', '(c..)(...)', 1, 1, 'i', 2)
                                   <lineannotation>FGH</lineannotation>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=412759d850281da99cb86bd6920aed1a -->

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!-- pgdoc-cn_start sig_en=8699c5823be6fd066a9cdc54a4340c7c sig_cn_org=None source=14.1 
    <title>Regular Expression Details</title>
________________________________________________________-->
    <title>正则表达式细节</title>
<!-- pgdoc-cn_end sig_en=8699c5823be6fd066a9cdc54a4340c7c -->

<!-- pgdoc-cn_start sig_en=fed0aa7fb8bf99f11cf670f3bc7aaf6a sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的正则表达式是使用 Henry Spencer 写的一个包来实现的。下面的正则表达式的大部分描述都是从他的手册页中逐字拷贝过来的。
   </para>
<!-- pgdoc-cn_end sig_en=fed0aa7fb8bf99f11cf670f3bc7aaf6a -->

<!-- pgdoc-cn_start sig_en=3ee069f7f114ca53d8192adba838c046 sig_cn_org=None source=14.1 
   <para>
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
   </para>
________________________________________________________-->
   <para>
    正则表达式（<acronym>RE</acronym>），在<acronym>POSIX</acronym> 1003.2 中定义， 它有两种形式：<firstterm>扩展</firstterm>的<acronym>RE</acronym>或者是<acronym>ERE</acronym>（大概地说就是那些在<command>egrep</command>里的）， <firstterm>基本</firstterm>的<acronym>RE</acronym>或者是<acronym>BRE</acronym>（大概地说就是那些在<command>ed</command>里的）。<productname>PostgreSQL</productname>支持两种形式，并且还实现了一些POSIX标准中没有但是在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。使用了那些非POSIX扩展的<acronym>RE</acronym>叫<firstterm>高级</firstterm><acronym>RE</acronym>， 或者本文档里说的<acronym>ARE</acronym>。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容（以及更多的限制）。我们首先描述 ARE 和 ERE 形式， 描述那些只适用于 ARE 的特性，然后描述 BRE 的区别是什么。
   </para>
<!-- pgdoc-cn_end sig_en=3ee069f7f114ca53d8192adba838c046 -->

   <note>
<!-- pgdoc-cn_start sig_en=dd1833b5317a0ae83b52745ff84fe855 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>初始时总是推测一个正则表达式遵循 ARE 规则。但是，可以通过为 RE 模式预置一个<firstterm>embedded option</firstterm>来选择限制更多的 ERE 或 BRE 规则，如<xref linkend="posix-metasyntax"/>中所述。这对为期望准确的<acronym>POSIX</acronym> 1003.2 规则的应用提供兼容性很有用。
    </para>
<!-- pgdoc-cn_end sig_en=dd1833b5317a0ae83b52745ff84fe855 -->
   </note>

<!-- pgdoc-cn_start sig_en=2b24b47bc84d4f3c36c9c73c94d48674 sig_cn_org=None source=14.1 
   <para>
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
   </para>
________________________________________________________-->
   <para>
    一个正则表达式被定义为一个或更多<firstterm>分支</firstterm>，它们之间被<literal>|</literal>分隔。只要能匹配其中一个分支的东西都能匹配正则表达式。
   </para>
<!-- pgdoc-cn_end sig_en=2b24b47bc84d4f3c36c9c73c94d48674 -->

<!-- pgdoc-cn_start sig_en=12cd2a6352f29d02a1fdf5ef0f53f5d7 sig_cn_org=5e7e9db1d80eca92107497d1a3fcea4d source=15.7 
   <para>
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc.;
    an empty branch matches the empty string.
   </para>
________________________________________________________-->
   <para>
    一个分支是零个或多个<firstterm>quantified atoms</firstterm>或<firstterm>constraints</firstterm>，连接在一起。
    它匹配第一个的匹配项，然后是第二个的匹配项，依此类推；一个空分支匹配空字符串。
</para>
<!-- pgdoc-cn_end sig_en=12cd2a6352f29d02a1fdf5ef0f53f5d7 -->

<!-- pgdoc-cn_start sig_en=165b96f6abe671c3a18f76513763253b sig_cn_org=None source=14.1 
   <para>
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
   </para>
________________________________________________________-->
   <para>
    一个量化原子是一个<firstterm>原子</firstterm>， 后面可能跟着一个<firstterm>量词</firstterm>。没有量词的时候，它匹配一个原子， 有量词的时候，它可以匹配若干个原子。一个<firstterm>原子</firstterm>可以是在<xref linkend="posix-atoms-table"/>里面显示的任何可能。 可能的量词和它们的含义在<xref linkend="posix-quantifiers-table"/>里显示。
   </para>
<!-- pgdoc-cn_end sig_en=165b96f6abe671c3a18f76513763253b -->

<!-- pgdoc-cn_start sig_en=21ee1df01ffeb1fbbefada893f1c0b02 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
   </para>
________________________________________________________-->
   <para>
    一个<firstterm>约束</firstterm>匹配一个空串，但只是在满足特定条件下才匹配。 约束可以在能够使用原子的地方使用，只是它不能跟着量词。简单的约束在<xref linkend="posix-constraints-table"/>里显示； 更多的约束稍后描述。
   </para>
<!-- pgdoc-cn_end sig_en=21ee1df01ffeb1fbbefada893f1c0b02 -->


   <table id="posix-atoms-table">
<!-- pgdoc-cn_start sig_en=ea00fd208f5e9b684e44d47c05334d19 sig_cn_org=None source=14.1 
    <title>Regular Expression Atoms</title>
________________________________________________________-->
    <title>正则表达式原子</title>
<!-- pgdoc-cn_end sig_en=ea00fd208f5e9b684e44d47c05334d19 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=cf190cdbd9c468807481e482b276f222 sig_cn_org=None source=14.1 
      <row>
       <entry>Atom</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>原子</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=cf190cdbd9c468807481e482b276f222 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=de8767b2e4863fba716753960712279d sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>（其中<replaceable>re</replaceable>是任何正则表达式） 匹配一个对<replaceable>re</replaceable>的匹配，匹配将为可能的报告被记下</entry>
       </row>
<!-- pgdoc-cn_end sig_en=de8767b2e4863fba716753960712279d -->

<!-- pgdoc-cn_start sig_en=c9ec33e4bb6988fb96eb9f9c6393c72a sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>同上，但是匹配不会为了报告而被记下 （一个<quote>非捕获</quote>圆括号集） （只对 ARE）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c9ec33e4bb6988fb96eb9f9c6393c72a -->

<!-- pgdoc-cn_start sig_en=43143a2f40cb0fd3a7f02152555c77f4 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>.</literal> </entry>
       <entry> matches any single character </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>.</literal> </entry>
       <entry>匹配任意单个字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=43143a2f40cb0fd3a7f02152555c77f4 -->

<!-- pgdoc-cn_start sig_en=7bbb6f9c0f72f72bc45ebb895461466b sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> 一个<firstterm>方括号表达式</firstterm>， 匹配<replaceable>chars</replaceable>中的任意一个（详见<xref linkend="posix-bracket-expressions"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7bbb6f9c0f72f72bc45ebb895461466b -->

<!-- pgdoc-cn_start sig_en=66464c6cffab023f55ced687fd609db9 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry>（其中<replaceable>k</replaceable>是一个非字母数字字符） 匹配一个被当作普通字符看待的特定字符， 例如，<literal>\\</literal>匹配一个反斜线字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=66464c6cffab023f55ced687fd609db9 -->

<!-- pgdoc-cn_start sig_en=f4511c4beb42f44e9e6c59660d74d77b sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry>其中<replaceable>c</replaceable>是一个字母数字 （可能跟着其它字符），它是一个<firstterm>逃逸</firstterm>， 参阅<xref linkend="posix-escape-sequences"/>（仅对 ARE； 在 ERE 和 BRE 中，它匹配<replaceable>c</replaceable>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f4511c4beb42f44e9e6c59660d74d77b -->

<!-- pgdoc-cn_start sig_en=92763c5acde51626806b3c85b6c2086c sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>{</literal> </entry>
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>{</literal> </entry>
       <entry>如果后面跟着一个字符，而不是数字， 那么就匹配左花括弧<literal>{</literal>；如果跟着一个数字， 那么它是<replaceable>range</replaceable>的开始（见下文）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=92763c5acde51626806b3c85b6c2086c -->

<!-- pgdoc-cn_start sig_en=27a7f9ddbd4d4c7163e7da29607dc4f9 sig_cn_org=None source=14.1 
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry>其中<replaceable>x</replaceable>是一个没有其它意义的单个字符，则匹配该字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=27a7f9ddbd4d4c7163e7da29607dc4f9 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=b101d21ccbb9ddbd6d56f4202a73c5a3 sig_cn_org=None source=14.1 
   <para>
    An RE cannot end with a backslash (<literal>\</literal>).
   </para>
________________________________________________________-->
   <para>
    RE 不能以反斜线（<literal>\</literal>）结尾。
   </para>
<!-- pgdoc-cn_end sig_en=b101d21ccbb9ddbd6d56f4202a73c5a3 -->

   <note>
<!-- pgdoc-cn_start sig_en=47ab8201ac50caafd4c53ea7456693dd sig_cn_org=None source=14.1 
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，你在文串常量中写的任何反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
<!-- pgdoc-cn_end sig_en=47ab8201ac50caafd4c53ea7456693dd -->
   </note>

   <table id="posix-quantifiers-table">
<!-- pgdoc-cn_start sig_en=10ae8ef03670a1de912c0dd4dab83dc1 sig_cn_org=None source=14.1 
    <title>Regular Expression Quantifiers</title>
________________________________________________________-->
    <title>正则表达式量词</title>
<!-- pgdoc-cn_end sig_en=10ae8ef03670a1de912c0dd4dab83dc1 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=a62493faf1467327fd99ae366bb0b1f6 sig_cn_org=None source=14.1 
      <row>
       <entry>Quantifier</entry>
       <entry>Matches</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>量词</entry>
       <entry>匹配</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a62493faf1467327fd99ae366bb0b1f6 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=b917480246abbaa4c55bc3be8f4b530e sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>*</literal> </entry>
       <entry> a sequence of 0 or more matches of the atom </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>*</literal> </entry>
       <entry>一个由原子的 0 次或更多次匹配组成的序列</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b917480246abbaa4c55bc3be8f4b530e -->

<!-- pgdoc-cn_start sig_en=533dd7ab43060dd75e5761d0070c8cc4 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>+</literal> </entry>
       <entry> a sequence of 1 or more matches of the atom </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>+</literal> </entry>
       <entry>一个由原子的 1 次或更多次匹配组成的序列</entry>
       </row>
<!-- pgdoc-cn_end sig_en=533dd7ab43060dd75e5761d0070c8cc4 -->

<!-- pgdoc-cn_start sig_en=3723127977ab1f33e6fc590f39cb5faf sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>?</literal> </entry>
       <entry> a sequence of 0 or 1 matches of the atom </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>?</literal> </entry>
       <entry>一个由原子的 0 次或 1 次匹配组成的序列</entry>
       </row>
<!-- pgdoc-cn_end sig_en=3723127977ab1f33e6fc590f39cb5faf -->

<!-- pgdoc-cn_start sig_en=1d77f950a201d366614d3466b8543591 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的正好<replaceable>m</replaceable>次匹配组成的序列</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1d77f950a201d366614d3466b8543591 -->

<!-- pgdoc-cn_start sig_en=b92531ebc462775e220c4c193b1e21cd sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry>一个由原子的<replaceable>m</replaceable>次或更多次匹配组成的序列</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b92531ebc462775e220c4c193b1e21cd -->

<!-- pgdoc-cn_start sig_en=1ad8c08a73417f8f1d136e36ded01137 sig_cn_org=None source=14.1 
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的从<replaceable>m</replaceable>次到<replaceable>n</replaceable>次（包括）匹配组成的序列；<replaceable>m</replaceable>不能超过<replaceable>n</replaceable> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=1ad8c08a73417f8f1d136e36ded01137 -->

<!-- pgdoc-cn_start sig_en=152ce35eaa55144c4b88d72c0b23ea0b sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry> non-greedy version of <literal>*</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry><literal>*</literal>的非贪婪版本</entry>
       </row>
<!-- pgdoc-cn_end sig_en=152ce35eaa55144c4b88d72c0b23ea0b -->

<!-- pgdoc-cn_start sig_en=0e58fcac2609f4ff53a5ffa7aa2aa2ef sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry> non-greedy version of <literal>+</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry><literal>+</literal>的非贪婪版本</entry>
       </row>
<!-- pgdoc-cn_end sig_en=0e58fcac2609f4ff53a5ffa7aa2aa2ef -->

<!-- pgdoc-cn_start sig_en=d51fd8fde3f1472ca2047aa6996f6840 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>??</literal> </entry>
       <entry> non-greedy version of <literal>?</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>??</literal> </entry>
       <entry><literal>?</literal>的非贪婪版本</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d51fd8fde3f1472ca2047aa6996f6840 -->

<!-- pgdoc-cn_start sig_en=b90b0d148d4bbe16d480af52bfd106df sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>
<!-- pgdoc-cn_end sig_en=b90b0d148d4bbe16d480af52bfd106df -->

<!-- pgdoc-cn_start sig_en=bfda8d4f004b52bca6f522c1975393cc sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>的非贪婪版本 </entry>
       </row>
<!-- pgdoc-cn_end sig_en=bfda8d4f004b52bca6f522c1975393cc -->

<!-- pgdoc-cn_start sig_en=e64ff5fccbeec79e8d62d327c22b0c8c sig_cn_org=None source=14.1 
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>
<!-- pgdoc-cn_end sig_en=e64ff5fccbeec79e8d62d327c22b0c8c -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=65ffcaacff588fc54d737d745210a63f sig_cn_org=None source=14.1 
   <para>
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
   </para>
________________________________________________________-->
   <para>
    使用<literal>{</literal><replaceable>...</replaceable><literal>}</literal>的形式被称作<firstterm>范围</firstterm>。 一个范围内的数字<replaceable>m</replaceable>和<replaceable>n</replaceable>都是无符号十进制整数， 允许的数值从 0 到 255（包含）。
   </para>
<!-- pgdoc-cn_end sig_en=65ffcaacff588fc54d737d745210a63f -->

<!-- pgdoc-cn_start sig_en=eff439cd0f71e3a4b3c64486554f4f79 sig_cn_org=None source=14.1 
    <para>
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
   </para>
________________________________________________________-->
    <para>
     <firstterm>非贪婪</firstterm>的量词（只在 ARE 中可用）匹配对应的正常 （<firstterm>贪婪</firstterm>）模式，区别是它寻找最少的匹配，而不是最多的匹配。详见<xref linkend="posix-matching-rules"/>。
   </para>
<!-- pgdoc-cn_end sig_en=eff439cd0f71e3a4b3c64486554f4f79 -->

   <note>
<!-- pgdoc-cn_start sig_en=c0b4501d02f42bcd1bd807d65caac5ba sig_cn_org=None source=14.1 
    <para>
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
    </para>
________________________________________________________-->
    <para>
     一个量词不能紧跟在另外一个量词后面，例如<literal>**</literal>是非法的。量词不能作为表达式或者子表达式的开头，也不能跟在<literal>^</literal>或者<literal>|</literal>后面。
    </para>
<!-- pgdoc-cn_end sig_en=c0b4501d02f42bcd1bd807d65caac5ba -->
   </note>

   <table id="posix-constraints-table">
<!-- pgdoc-cn_start sig_en=2df09a802870d5fef6012827c3e52822 sig_cn_org=None source=14.1 
    <title>Regular Expression Constraints</title>
________________________________________________________-->
    <title>正则表达式约束</title>
<!-- pgdoc-cn_end sig_en=2df09a802870d5fef6012827c3e52822 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=d8aa13809694de031889df0ed578bf96 sig_cn_org=None source=14.1 
      <row>
       <entry>Constraint</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>约束</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=d8aa13809694de031889df0ed578bf96 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=9af90a90ea4f10e7680f181c7160abb1 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>^</literal> </entry>
       <entry> matches at the beginning of the string </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>^</literal> </entry>
       <entry>串开头的匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9af90a90ea4f10e7680f181c7160abb1 -->

<!-- pgdoc-cn_start sig_en=e0da88c8af685f9a90b12934863891ee sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>$</literal> </entry>
       <entry> matches at the end of the string </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>$</literal> </entry>
       <entry>串末尾的匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e0da88c8af685f9a90b12934863891ee -->

<!-- pgdoc-cn_start sig_en=fd20d52173b66f8d1d02bc489c1d98a3 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>positive lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=fd20d52173b66f8d1d02bc489c1d98a3 -->

<!-- pgdoc-cn_start sig_en=7ef61b2fa051d50d5fba3ef79febec97 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>negative lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7ef61b2fa051d50d5fba3ef79febec97 -->

<!-- pgdoc-cn_start sig_en=eb6f6e0056bd7000d63adfcbcd00a394 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上有一个子串匹配<replaceable>re</replaceable>端， <firstterm>positive lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=eb6f6e0056bd7000d63adfcbcd00a394 -->

<!-- pgdoc-cn_start sig_en=ebb2aeb8cca825406d3f875efefcb649 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上没有子串匹配<replaceable>re</replaceable>端， <firstterm>negative lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ebb2aeb8cca825406d3f875efefcb649 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=4032ca6a84a84095e39b3c7a8ce91fcc sig_cn_org=None source=14.1 
   <para>
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
   </para>
________________________________________________________-->
   <para>
    Lookahead 和 lookbehind 约束不能包含<firstterm>后引用</firstterm> （参阅<xref linkend="posix-escape-sequences"/>），并且其中的所有圆括号 都被认为是非捕获的。
   </para>
<!-- pgdoc-cn_end sig_en=4032ca6a84a84095e39b3c7a8ce91fcc -->
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!-- pgdoc-cn_start sig_en=1735228bf2e1fa3d6fc50c1a2fc98e4e sig_cn_org=None source=14.1 
    <title>Bracket Expressions</title>
________________________________________________________-->
    <title>方括号表达式</title>
<!-- pgdoc-cn_end sig_en=1735228bf2e1fa3d6fc50c1a2fc98e4e -->

<!-- pgdoc-cn_start sig_en=6f6bdf54adaf03d5078b73d707224730 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
   </para>
________________________________________________________-->
   <para>
    <firstterm>方括号表达式</firstterm>是一个包围在<literal>[]</literal>中的字符列表。它通常匹配列表中的任意单个字符（但见下文）。 如果列表以<literal>^</literal>开头，它匹配任意单个<emphasis>不</emphasis>在该列表参与部分中的字符。如果该列表中两个字符用<literal>-</literal>隔开， 那它就是那两个字符（包括在内）之间的所有字符范围的缩写，例如，在<acronym>ASCII</acronym>中<literal>[0-9]</literal>匹配任何十进制数字。两个范围共享一个端点是非法的，例如，<literal>a-c-e</literal>。范围与字符集关系密切， 可移植的程序应该避免依靠它们。
   </para>
<!-- pgdoc-cn_end sig_en=6f6bdf54adaf03d5078b73d707224730 -->

<!-- pgdoc-cn_start sig_en=bdb7a4905de15bbedf86853d444d7911 sig_cn_org=None source=14.1 
   <para>
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
   </para>
________________________________________________________-->
   <para>
    想在列表中包含文本<literal>]</literal>，可以让它做列表的首字符（如果使用了<literal>^</literal>，需要放在其后）。 想在列表中包含文本<literal>-</literal>，可以让它做列表的首字符或者尾字符，或者一个范围的第二个端点。 想在列表中把文本<literal>-</literal>当做范围的起点， 把它用<literal>[.</literal>和<literal>.]</literal>包围起来，这样它就成为一个排序元素（见下文）。 除了这些字符本身、一些用<literal>[</literal>的组合（见下段）以及逃逸（只在 ARE 中有效）以外，所有其它特殊字符 在方括号表达式里都失去它们的特殊含义。特别是，在 ERE 和 BRE 规则下<literal>\</literal>不是特殊的， 但在 ARE 里，它是特殊的（引入一个逃逸）。
   </para>
<!-- pgdoc-cn_end sig_en=bdb7a4905de15bbedf86853d444d7911 -->

<!-- pgdoc-cn_start sig_en=cbdff22f9db20d7eae3cc76b4251dc43 sig_cn_org=None source=14.1 
   <para>
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
   </para>
________________________________________________________-->
   <para>
    在一个方括号表达式里，一个排序元素（一个字符、一个被当做一个单一字符排序的多字符序列或者一个表示上面两种情况的排序序列名称） 包含在<literal>[.</literal>和<literal>.]</literal>里面的时候表示该排序元素的字符序列。该序列被当做该方括号列表 的一个单一元素。这允许一个包含多字符排序元素的方括号表达式去匹配多于一个字符，例如，如果排序序列包含一个<literal>ch</literal>排序元素， 那么 RE <literal>[[.ch.]]*c</literal>匹配<literal>chchcc</literal>的头五个字符。
   </para>
<!-- pgdoc-cn_end sig_en=cbdff22f9db20d7eae3cc76b4251dc43 -->

   <note>
<!-- pgdoc-cn_start sig_en=d2d397aa97d127bf65abc316611e40c4 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>当前不支持多字符排序元素。这些信息描述了将来可能有的行为。
    </para>
<!-- pgdoc-cn_end sig_en=d2d397aa97d127bf65abc316611e40c4 -->
   </note>

<!-- pgdoc-cn_start sig_en=cafa32dc90c84ee4f3217a36dcead981 sig_cn_org=None source=14.1 
   <para>
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
   </para>
________________________________________________________-->
   <para>
    在方括号表达式里，包围在<literal>[=</literal>和<literal>=]</literal>里的排序元素是一个<firstterm>等价类</firstterm>， 代表等效于那一个的所有排序元素的字符序列，包括它本身（如果没有其它等效排序元素，那么就好象封装定界符是<literal>[.</literal>和 <literal>.]</literal>）。例如，如果<literal>o</literal>和<literal>^</literal>是一个等价类的成员，那么<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>和<literal>[o^]</literal>都是同义的。一个等价类不能是一个范围的端点。
   </para>
<!-- pgdoc-cn_end sig_en=cafa32dc90c84ee4f3217a36dcead981 -->

<!-- pgdoc-cn_start sig_en=931d06e364929ee6b2c067b7dfce8bbc sig_cn_org=None source=14.1 
   <para>
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>word</literal> character class, which is the same as
    <literal>alnum</literal> plus the underscore (<literal>_</literal>)
    character, and
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
   </para>
________________________________________________________-->
   <para>
    在方括号表达式里，在<literal>[:</literal>和<literal>:]</literal>里面封装的字符类的名字代表属于该类的所有字符的列表。 
    字符类不能作为范围的端点使用。
    <acronym>POSIX</acronym>标准定义了这些字符类的名称：
    <literal>alnum</literal> (字符和数字),
    <literal>alpha</literal> (字符),
    <literal>blank</literal> (空格和制表符tab),
    <literal>cntrl</literal> (控制符),
    <literal>digit</literal> (数位数),
    <literal>graph</literal> (空格除外可打印字符),
    <literal>lower</literal> (小写字母),
    <literal>print</literal> (包含空格可打印字符),
    <literal>punct</literal> (标点符号),
    <literal>space</literal> (空白),
    <literal>upper</literal> (大写字母),
    和 <literal>xdigit</literal> (十六进制数).
    对于7位ASCII字符集中的字符来说，这些标准字符类的行为在不同平台上一般是一致的。
    一个给定的非ASCII字符是否被认为属于这些类别中的一个，取决于正则表达式函数或运算符使用的<firstterm>collation</firstterm>（见<xref linkend="collation"/>），或者默认情况下取决于数据库的<envar>LC_CTYPE</envar> locale设置（见<xref linkend="locale"/>）。
    非ASCII字符的分类在不同的平台上会有不同的分类，即使是在类似命名的locale中也是如此。 
    (但<literal>C</literal> locale从不认为任何非ASCII字符属于上述任何一类)。
    除了这些标准字符类之外，<productname>PostgreSQL</productname>定义了<literal>word</literal>字符类，等同于<literal>alnum</literal>加上下划线(<literal>_</literal>)， 以及<literal>ascii</literal>字符类，它完全包含7位ASCII字符集。
   </para>
<!-- pgdoc-cn_end sig_en=931d06e364929ee6b2c067b7dfce8bbc -->

<!-- pgdoc-cn_start sig_en=f1ca177c1eb52d1f165a46f6ccb8e4d7 sig_cn_org=None source=14.1 
   <para>
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is any character belonging to the
    <literal>word</literal> character class, that is, any letter, digit,
    or underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
   </para>
________________________________________________________-->
   <para>
    方括号表达式里有两个特例：方括号表达式<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>是约束，分别匹配一个单词开头和结束的空串。 
    单词定义为一个单词字符序列，前面和后面都没有其它单词字符。
    单词字符是属于<literal>word</literal>字符类的任何字符，也就是，任何字母、数字或下划线。
    这是一个扩展，兼容<acronym>POSIX</acronym> 1003.2， 但那里面并没有说明， 而且在准备移植到其他系统里去的软件里一定要小心使用。
    通常下文描述的约束逃逸更好些（它们并非更标准，但是更容易键入）。
   </para>
<!-- pgdoc-cn_end sig_en=f1ca177c1eb52d1f165a46f6ccb8e4d7 -->
   </sect3>

   <sect3 id="posix-escape-sequences">
<!-- pgdoc-cn_start sig_en=83b21676cad2f3f9185962d4265b4546 sig_cn_org=None source=14.1 
    <title>Regular Expression Escapes</title>
________________________________________________________-->
    <title>正则表达式逃逸</title>
<!-- pgdoc-cn_end sig_en=83b21676cad2f3f9185962d4265b4546 -->

<!-- pgdoc-cn_start sig_en=7f8846a23bd45a9a246658010a52bb04 sig_cn_org=None source=14.1 
   <para>
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
   </para>
________________________________________________________-->
   <para>
    <firstterm>逃逸</firstterm>是以<literal>\</literal>开头，后面跟着一个字母数字字符得特殊序列。 逃逸有好几种变体：字符项、类缩写、约束逃逸以及后引用。在 ARE 里， 如果一个<literal>\</literal>后面跟着一个字母数字，但是并未组成一个合法的逃逸， 那么它是非法的。在 ERE 中没有逃逸：在方括号表达式之外，一个后面跟着字母数字字符的<literal>\</literal>只是表示该字符是一个普通的字符，而且在一个方括号表达式里，<literal>\</literal>是一个普通的字符（后者实际上在 ERE 和 ARE 不兼容）。
   </para>
<!-- pgdoc-cn_end sig_en=7f8846a23bd45a9a246658010a52bb04 -->

<!-- pgdoc-cn_start sig_en=9669885f62dbe09d0611f176afa7bce0 sig_cn_org=None source=14.1 
   <para>
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
   </para>
________________________________________________________-->
   <para>
    <firstterm>字符项逃逸</firstterm>用于便于我们在 RE 中声明那些不可打印的或其他习惯的字符。它们显示在<xref linkend="posix-character-entry-escapes-table"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=9669885f62dbe09d0611f176afa7bce0 -->

<!-- pgdoc-cn_start sig_en=b6511318a4cbd6343ef3304f8567d9de sig_cn_org=None source=14.1 
   <para>
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
   </para>
________________________________________________________-->
   <para>
    <firstterm>类缩写逃逸</firstterm>用来提供一些常用的字符类缩写。它们显示在<xref linkend="posix-class-shorthand-escapes-table"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=b6511318a4cbd6343ef3304f8567d9de -->

<!-- pgdoc-cn_start sig_en=69bfa883a760b41bce14c55dab1e65f9 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
   </para>
________________________________________________________-->
   <para>
    <firstterm>约束逃逸</firstterm>是一个约束，如果满足特定的条件，它匹配该空串。它们显示在<xref linkend="posix-constraint-escapes-table"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=69bfa883a760b41bce14c55dab1e65f9 -->

<!-- pgdoc-cn_start sig_en=d2668b9cd2867697a6f2ddd9e723da52 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
    The back reference considers only the string characters matched by the
    referenced subexpression, not any constraints contained in it.  For
    example, <literal>(^\d)\1</literal> will match <literal>22</literal>.
   </para>
________________________________________________________-->
   <para>
    <firstterm>后引用</firstterm>（<literal>\</literal><replaceable>n</replaceable>）匹配数字<literal>\</literal><replaceable>n</replaceable>指定的被前面的圆括号子表达式匹配的同一个串 （参阅<xref linkend="posix-constraint-backref-table"/>）。
    例如， <literal>([bc])\1</literal>匹配<literal>bb</literal>或者<literal>cc</literal>， 但是不匹配<literal>bc</literal>或者<literal>cb</literal>。
    RE 中子表达式必须完全在后引用前面。子表达式以它们的先导圆括号的顺序编号。
    非捕获圆括号并不定义子表达式。
    反向引用仅考虑被引用的子表达式匹配的字符串字符，而不考虑其中包含的任何约束。
    例如，<literal>(^\d)\1</literal> 将匹配 <literal>22</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=d2668b9cd2867697a6f2ddd9e723da52 -->

   <table id="posix-character-entry-escapes-table">
<!-- pgdoc-cn_start sig_en=f453f9e7c00a7394cb86764dc3c37f19 sig_cn_org=None source=14.1 
    <title>Regular Expression Character-Entry Escapes</title>
________________________________________________________-->
    <title>正则表达式字符项逃逸</title>
<!-- pgdoc-cn_end sig_en=f453f9e7c00a7394cb86764dc3c37f19 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=49fbaebf725bab9427ff14c72d2125b8 sig_cn_org=None source=14.1 
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=49fbaebf725bab9427ff14c72d2125b8 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=5d2143e03437b72eae4ddb300b2e2a63 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry> alert (bell) character, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry>警告（响铃）字符，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5d2143e03437b72eae4ddb300b2e2a63 -->

<!-- pgdoc-cn_start sig_en=e3c973a783bfdd65aa018ab9eb4007c5 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry> backspace, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry>退格，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e3c973a783bfdd65aa018ab9eb4007c5 -->

<!-- pgdoc-cn_start sig_en=c41567a67c9571ede9c540cee4adca87 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry>反斜线（<literal>\</literal>）的同义词，用来减少双写反斜线</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c41567a67c9571ede9c540cee4adca87 -->

<!-- pgdoc-cn_start sig_en=ca8196f97ba58dfc60b0a178b946bb8f sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry>（其中<replaceable>X</replaceable>是任意字符）低序5位和<replaceable>X</replaceable>相同的字符，它的其他位都是零</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ca8196f97ba58dfc60b0a178b946bb8f -->

<!-- pgdoc-cn_start sig_en=72c4057624006fe5d52688864604ae93 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry>排序序列名为<literal>ESC</literal>的字符，如果无法做到该字符为八进制值 <literal>033</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=72c4057624006fe5d52688864604ae93 -->

<!-- pgdoc-cn_start sig_en=a1d39c5930161bd0f1338bf102458d8e sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry> form feed, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry>换页，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a1d39c5930161bd0f1338bf102458d8e -->

<!-- pgdoc-cn_start sig_en=7241b8400de764191884dbd03a6029e9 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry> newline, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry>新行，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7241b8400de764191884dbd03a6029e9 -->

<!-- pgdoc-cn_start sig_en=4d8a04f5952b77816dd34f8519f86c89 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry> carriage return, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry>回车，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4d8a04f5952b77816dd34f8519f86c89 -->

<!-- pgdoc-cn_start sig_en=b583b97c93c6d4475922b35f6e1300b1 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry> horizontal tab, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry>水平制表符，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b583b97c93c6d4475922b35f6e1300b1 -->

<!-- pgdoc-cn_start sig_en=16234ae6275e2d9ade76e84cd460c7b2 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
       </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry>（其中<replaceable>wxyz</replaceable>正好是四个十六进制位）十六进制值为<literal>0x</literal><replaceable>wxyz</replaceable>的字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=16234ae6275e2d9ade76e84cd460c7b2 -->

<!-- pgdoc-cn_start sig_en=3148f0211eb541c98f726b3eea3e9a5b sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
       </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry>（其中<replaceable>stuvwxyz</replaceable>正好是八个十六进制位）十六进制值为<literal>0x</literal><replaceable>stuvwxyz</replaceable>的字符
       </entry>
       </row>
<!-- pgdoc-cn_end sig_en=3148f0211eb541c98f726b3eea3e9a5b -->

<!-- pgdoc-cn_start sig_en=c66f604c0c9329213450eeeed9d1a2d1 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry> vertical tab, as in C </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry>垂直制表符，和 C 中一样</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c66f604c0c9329213450eeeed9d1a2d1 -->

<!-- pgdoc-cn_start sig_en=be2b4df57e7a0b85138716054f9748d9 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
       </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry>（其中<replaceable>hhh</replaceable>是十六进制位的任意序列）十六进制值为<literal>0x</literal><replaceable>hhh</replaceable>的字符（一个单一字符，不管用了多少个十六进制位）
       </entry>
       </row>
<!-- pgdoc-cn_end sig_en=be2b4df57e7a0b85138716054f9748d9 -->

<!-- pgdoc-cn_start sig_en=ce35a82114acd4f357e2cc74bd9ce451 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry>值为<literal>0</literal>（空字节）的字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ce35a82114acd4f357e2cc74bd9ce451 -->

<!-- pgdoc-cn_start sig_en=3f80b7ff866866ee419745775bf5a148 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry>（其中<replaceable>xy</replaceable>正好是两个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xy</replaceable>的字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=3f80b7ff866866ee419745775bf5a148 -->

<!-- pgdoc-cn_start sig_en=56f08d5b557aa5c2eeb9f5a1061b6dfb sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry>（其中<replaceable>xyz</replaceable>正好是三个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xyz</replaceable>的字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=56f08d5b557aa5c2eeb9f5a1061b6dfb -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=80ed961140f32e821200bb730f2e7349 sig_cn_org=None source=14.1 
   <para>
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
   </para>
________________________________________________________-->
   <para>
    十六进制位是<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>和<literal>A</literal>-<literal>F</literal>。八进制位是<literal>0</literal>-<literal>7</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=80ed961140f32e821200bb730f2e7349 -->

<!-- pgdoc-cn_start sig_en=d3e850285544a0fa7a65b622c415454b sig_cn_org=None source=14.1 
   <para>
    Numeric character-entry escapes specifying values outside the ASCII range
    (0&ndash;127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
   </para>
________________________________________________________-->
   <para>
    指定 ASCII 范围（0&ndash;127）之外的值的数字字符项转义的含义取决于数据库编码。
    当编码是 UTF-8 时，转义值等价于 Unicode 代码点，例如
    <literal>\u1234</literal>表示字符<literal>U+1234</literal>。对于其他多字节编码，
    字符项转义通常只是指定该字符的字节值的串接。如果该转义值不对应数据库编码
    中的任何合法字符，将不会发生错误，但是它不会匹配任何数据。
   </para>
<!-- pgdoc-cn_end sig_en=d3e850285544a0fa7a65b622c415454b -->

<!-- pgdoc-cn_start sig_en=8c387f2aa8443ef9d2074bf3cdc1ae06 sig_cn_org=None source=14.1 
   <para>
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
   </para>
________________________________________________________-->
   <para>
    字符项逃逸总是被当作普通字符。例如，<literal>\135</literal>是 ASCII 中的<literal>]</literal>， 但<literal>\135</literal>并不终止一个方括号表达式。
   </para>
<!-- pgdoc-cn_end sig_en=8c387f2aa8443ef9d2074bf3cdc1ae06 -->

   <table id="posix-class-shorthand-escapes-table">
<!-- pgdoc-cn_start sig_en=612bc8c479912e32e604b0b12477459d sig_cn_org=None source=14.1 
    <title>Regular Expression Class-Shorthand Escapes</title>
________________________________________________________-->
    <title>正则表达式类缩写逃逸</title>
<!-- pgdoc-cn_end sig_en=612bc8c479912e32e604b0b12477459d -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=49fbaebf725bab9427ff14c72d2125b8 sig_cn_org=None source=14.1 
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=49fbaebf725bab9427ff14c72d2125b8 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=af63b01d57c3e300810dbe8bd93942c9 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> matches any digit, like
        <literal>[[:digit:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> 匹配任何数字，就像
        <literal>[[:digit:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=af63b01d57c3e300810dbe8bd93942c9 -->

<!-- pgdoc-cn_start sig_en=88d63a6ef0d44da177bf7cadd77e7129 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> matches any whitespace character, like
        <literal>[[:space:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> 匹配任何空白字符，就像
        <literal>[[:space:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=88d63a6ef0d44da177bf7cadd77e7129 -->

<!-- pgdoc-cn_start sig_en=462e5f2d3779e7b8104815e34a315556 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> matches any word character, like
        <literal>[[:word:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> 匹配任何单词字符，就像
        <literal>[[:word:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=462e5f2d3779e7b8104815e34a315556 -->

<!-- pgdoc-cn_start sig_en=8efcb72cf56f1656cf1298f558b1fdfc sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> matches any non-digit, like
        <literal>[^[:digit:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> 匹配任何非数字，就像
        <literal>[^[:digit:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=8efcb72cf56f1656cf1298f558b1fdfc -->

<!-- pgdoc-cn_start sig_en=d17105e86ba8662a71812632b4784093 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> matches any non-whitespace character, like
        <literal>[^[:space:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> 匹配任何非空白字符，就像
        <literal>[^[:space:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=d17105e86ba8662a71812632b4784093 -->

<!-- pgdoc-cn_start sig_en=cc6c35dc54b5ca053c20554dcfc6c494 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> matches any non-word character, like
        <literal>[^[:word:]]</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> 匹配任何非单词字符，就像
        <literal>[^[:word:]]</literal> </entry>
       </row>
<!-- pgdoc-cn_end sig_en=cc6c35dc54b5ca053c20554dcfc6c494 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=cd15beb267e22643828bcb6631b883c0 sig_cn_org=None source=14.1 
   <para>
    The class-shorthand escapes also work within bracket expressions,
    although the definitions shown above are not quite syntactically
    valid in that context.
    For example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
   </para>
________________________________________________________-->
   <para>
    类-缩写转义也适用于括号表达式，尽管上面显示的定义在该上下文中在语法上并不完全有效。
    例如，<literal>[a-c\d]</literal> 等同于 <literal>[a-c[:digit:]]</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=cd15beb267e22643828bcb6631b883c0 -->

   <table id="posix-constraint-escapes-table">
<!-- pgdoc-cn_start sig_en=001331095a30cdfe42ab5d4849af05a2 sig_cn_org=None source=14.1 
    <title>Regular Expression Constraint Escapes</title>
________________________________________________________-->
    <title>正则表达式约束逃逸</title>
<!-- pgdoc-cn_end sig_en=001331095a30cdfe42ab5d4849af05a2 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=49fbaebf725bab9427ff14c72d2125b8 sig_cn_org=None source=14.1 
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=49fbaebf725bab9427ff14c72d2125b8 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=e7e5bb483491c0800f71afc6dd862280 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry>只在串开头匹配（与<literal>^</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e7e5bb483491c0800f71afc6dd862280 -->

<!-- pgdoc-cn_start sig_en=b846154ecdbaba69b95288bcd18b8403 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry> matches only at the beginning of a word </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry>只在一个词的开头匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b846154ecdbaba69b95288bcd18b8403 -->

<!-- pgdoc-cn_start sig_en=4f6c99de1f2a15e055b22c1e8a16ada0 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry> matches only at the end of a word </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry>只在一个词的末尾匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4f6c99de1f2a15e055b22c1e8a16ada0 -->

<!-- pgdoc-cn_start sig_en=e24f3bd4ef8ffd9ba078bfb3adfb0bb5 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry> matches only at the beginning or end of a word </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry>只在一个词的开头或末尾匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e24f3bd4ef8ffd9ba078bfb3adfb0bb5 -->

<!-- pgdoc-cn_start sig_en=4f0fa6d4870c55ba56ae2a64951c1177 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry>只在一个词的不是开头或末尾的点上匹配</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4f0fa6d4870c55ba56ae2a64951c1177 -->

<!-- pgdoc-cn_start sig_en=7c6b164e802741f972c739b106d714e8 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry>只在串的末尾匹配（与<literal>$</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7c6b164e802741f972c739b106d714e8 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=c81065d64963186b6afb197d6e3247d2 sig_cn_org=None source=14.1 
   <para>
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
   </para>
________________________________________________________-->
   <para>
    一个词被定义成在上面<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>中的声明。在方括号表达式里，约束逃逸是非法的。
   </para>
<!-- pgdoc-cn_end sig_en=c81065d64963186b6afb197d6e3247d2 -->

   <table id="posix-constraint-backref-table">
<!-- pgdoc-cn_start sig_en=f5df1249d432f9b5849211158c94296e sig_cn_org=None source=14.1 
    <title>Regular Expression Back References</title>
________________________________________________________-->
    <title>正则表达式后引用</title>
<!-- pgdoc-cn_end sig_en=f5df1249d432f9b5849211158c94296e -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=49fbaebf725bab9427ff14c72d2125b8 sig_cn_org=None source=14.1 
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=49fbaebf725bab9427ff14c72d2125b8 -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=1581c079c489b4183844355a44b7282e sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位）一个到第<replaceable>m</replaceable>个子表达式的后引用</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1581c079c489b4183844355a44b7282e -->

<!-- pgdoc-cn_start sig_en=509102579d39b160271d6a6db1293d43 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位，并且<replaceable>nn</replaceable>是一些更多的位，并且十六进制值<replaceable>mnn</replaceable>不超过目前能看到的封闭捕获圆括号的数目）一个到第<replaceable>mnn</replaceable>个子表达式的后引用</entry>
       </row>
<!-- pgdoc-cn_end sig_en=509102579d39b160271d6a6db1293d43 -->
      </tbody>
     </tgroup>
    </table>

   <note>
<!-- pgdoc-cn_start sig_en=baf98b1feab8325d22fb7dd2e8040426 sig_cn_org=None source=14.1 
    <para>
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
    </para>
________________________________________________________-->
    <para>
     在八进制字符项逃逸和后引用之间有一个历史继承的歧义存在，这个歧义是 通过下面的启发式规则解决的，像上面描述地那样。前导零总是表示这是一个八进制逃逸。 而单个非零数字，如果没有跟着任何其它位，那么总是被认为后引用。 一个多位的非零开头的序列也被认为是后引用，只要它出现在合适的子表达式后面 （也就是说，在后引用的合法范围中的数），否则就被认为是一个八进制。
    </para>
<!-- pgdoc-cn_end sig_en=baf98b1feab8325d22fb7dd2e8040426 -->
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!-- pgdoc-cn_start sig_en=bfe5245011e136156146bfe766b40e1b sig_cn_org=None source=14.1 
    <title>Regular Expression Metasyntax</title>
________________________________________________________-->
    <title>正则表达式元语法</title>
<!-- pgdoc-cn_end sig_en=bfe5245011e136156146bfe766b40e1b -->

<!-- pgdoc-cn_start sig_en=4794eb48f6b8d6f2cecc03a521c3aa35 sig_cn_org=None source=14.1 
   <para>
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
   </para>
________________________________________________________-->
   <para>
    除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。
   </para>
<!-- pgdoc-cn_end sig_en=4794eb48f6b8d6f2cecc03a521c3aa35 -->

<!-- pgdoc-cn_start sig_en=8190aff07eaaf51034be37bf21321ff4 sig_cn_org=None source=14.1 
   <para>
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
   </para>
________________________________________________________-->
   <para>
    如果一个 RE 以<literal>***:</literal>开头，那么剩下的 RE 都被当作 ARE（这在<productname>PostgreSQL</productname>中通常是无效的，因为 RE 被假定为 ARE，但是如果 ERE 或 BRE 模式通过<replaceable>flags</replaceable>参数被指定为一个正则表达式函数时，它确实能产生效果）。如果一个 RE 以<literal>***=</literal>开头， 那么剩下的 RE 被当作一个文本串，所有的字符都被认为是一个普通字符。
   </para>
<!-- pgdoc-cn_end sig_en=8190aff07eaaf51034be37bf21321ff4 -->

<!-- pgdoc-cn_start sig_en=a177cceac33fe17808453cac62cb7297 sig_cn_org=None source=14.1 
   <para>
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
   </para>
________________________________________________________-->
   <para>
    一个 ARE 可以以<firstterm>嵌入选项</firstterm>开头：一个序列<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>（这里的<replaceable>xyz</replaceable>是一个或多个字母字符）声明影响剩余 RE 的选项。 这些选项覆盖任何前面判断的选项 &mdash; 特别地，它们可以覆盖一个正则表达式操作符隐含的大小写敏感的行为，或者覆盖<replaceable>flags</replaceable>参数中的正则表达式函数。可用的选项字母在<xref linkend="posix-embedded-options-table"/>中显示。注意这些同样的选项字母也被用在正则表达式函数的<replaceable>flags</replaceable>参数中。
   </para>
<!-- pgdoc-cn_end sig_en=a177cceac33fe17808453cac62cb7297 -->

   <table id="posix-embedded-options-table">
<!-- pgdoc-cn_start sig_en=e384235ef46191bac7c4f40ee3dddd48 sig_cn_org=None source=14.1 
    <title>ARE Embedded-Option Letters</title>
________________________________________________________-->
    <title>ARE 嵌入选项字母</title>
<!-- pgdoc-cn_end sig_en=e384235ef46191bac7c4f40ee3dddd48 -->

    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=790c4c8e6a1ca7da985982274804dd0a sig_cn_org=None source=14.1 
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>选项</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=790c4c8e6a1ca7da985982274804dd0a -->
     </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=7bc99270e65ad94d1581ba987a671758 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>b</literal> </entry>
       <entry> rest of RE is a BRE </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>b</literal> </entry>
       <entry>RE的剩余部分是一个BRE </entry>
       </row>
<!-- pgdoc-cn_end sig_en=7bc99270e65ad94d1581ba987a671758 -->

<!-- pgdoc-cn_start sig_en=2e1476d25c1b73b4711f2b104fa13c4f sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>c</literal> </entry>
       <entry> case-sensitive matching (overrides operator type) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>c</literal> </entry>
       <entry>大小写敏感的匹配（覆盖操作符类型）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2e1476d25c1b73b4711f2b104fa13c4f -->

<!-- pgdoc-cn_start sig_en=7e023850413776401e635d9348ecfa09 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>e</literal> </entry>
       <entry> rest of RE is an ERE </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>e</literal> </entry>
       <entry>RE的剩余部分是一个ERE </entry>
       </row>
<!-- pgdoc-cn_end sig_en=7e023850413776401e635d9348ecfa09 -->

<!-- pgdoc-cn_start sig_en=1edcca3645a9e573e1cde70fa833a4aa sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>i</literal> </entry>
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>i</literal> </entry>
       <entry>大小写不敏感的匹配（见<xref linkend="posix-matching-rules"/>）（覆盖操作符类型）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1edcca3645a9e573e1cde70fa833a4aa -->

<!-- pgdoc-cn_start sig_en=4419992d460115e55ebc6fcad4e1e1a3 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>m</literal> </entry>
       <entry> historical synonym for <literal>n</literal> </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>m</literal> </entry>
       <entry><literal>n</literal>的历史原因的同义词 </entry>
       </row>
<!-- pgdoc-cn_end sig_en=4419992d460115e55ebc6fcad4e1e1a3 -->

<!-- pgdoc-cn_start sig_en=28387ad996647c07a95dbacbe7dafbf9 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>n</literal> </entry>
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>n</literal> </entry>
       <entry>新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=28387ad996647c07a95dbacbe7dafbf9 -->

<!-- pgdoc-cn_start sig_en=f92ecd91d933b0810852d43c0075f231 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>p</literal> </entry>
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>p</literal> </entry>
       <entry>部分新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f92ecd91d933b0810852d43c0075f231 -->

<!-- pgdoc-cn_start sig_en=52487e73edc5ddaebe36728aefca1fd2 sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>q</literal> </entry>
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>q</literal> </entry>
       <entry>RE的剩余部分是一个文字（<quote>quoted</quote>）串，全部是普通字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=52487e73edc5ddaebe36728aefca1fd2 -->

<!-- pgdoc-cn_start sig_en=623fd25d0f9f0a8aac25b5f7b3bd417f sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>s</literal> </entry>
       <entry> non-newline-sensitive matching (default) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>s</literal> </entry>
       <entry>非新行敏感的匹配（默认）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=623fd25d0f9f0a8aac25b5f7b3bd417f -->

<!-- pgdoc-cn_start sig_en=2262afca11131f5605b9f253e5a066ed sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>t</literal> </entry>
       <entry> tight syntax (default; see below) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>t</literal> </entry>
       <entry>紧语法（默认，见下文）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2262afca11131f5605b9f253e5a066ed -->

<!-- pgdoc-cn_start sig_en=aceb37a1113b077e1ec689a8783313ec sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>w</literal> </entry>
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>w</literal> </entry>
       <entry>逆部分新行敏感（<quote>怪异</quote>）的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=aceb37a1113b077e1ec689a8783313ec -->

<!-- pgdoc-cn_start sig_en=0496bd3da24da0b3707b98ea868b65eb sig_cn_org=None source=14.1 
       <row>
       <entry> <literal>x</literal> </entry>
       <entry> expanded syntax (see below) </entry>
       </row>
________________________________________________________-->
       <row>
       <entry> <literal>x</literal> </entry>
       <entry>扩展语法（见下文）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=0496bd3da24da0b3707b98ea868b65eb -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=3b6e0b07c66574a87fa54d5cb32ab6dd sig_cn_org=None source=14.1 
   <para>
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
   </para>
________________________________________________________-->
   <para>
    嵌入选项在<literal>)</literal>终止序列时发生作用。它们只在 ARE 的开始处起作用 （在任何可能存在的<literal>***:</literal>控制器后面）。
   </para>
<!-- pgdoc-cn_end sig_en=3b6e0b07c66574a87fa54d5cb32ab6dd -->

<!-- pgdoc-cn_start sig_en=f70a43d13371e22e2d516a590c4ddf2d sig_cn_org=None source=14.1 
   <para>
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:

    <itemizedlist>
     <listitem>
      <para>
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space or <literal>#</literal> within a bracket expression is retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
   </para>
________________________________________________________-->
   <para>
    除了通常的（<firstterm>紧</firstterm>）RE 语法（这种情况下所有字符都有效）， 还有一种<firstterm>扩展</firstterm>语法，可以通过声明嵌入的<literal>x</literal>选项获得。在扩展语法里，RE 中的空白字符被忽略，就像那些在<literal>#</literal>和其后的新行（或 RE 的末尾）之间的字符一样。这样就允许我们给一个复杂的 RE 分段和注释。不过这个基本规则有三种例外：

    <itemizedlist>
     <listitem>
      <para>
       空白字符或前置了<literal>\</literal>的<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       方括号表达式里的空白或者<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       在多字符符号里面不能出现空白和注释，例如<literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    为了这个目的，空白是空格、制表符、新行和任何属于<replaceable>空白</replaceable>字符类的字符。
   </para>
<!-- pgdoc-cn_end sig_en=f70a43d13371e22e2d516a590c4ddf2d -->

<!-- pgdoc-cn_start sig_en=52d55879cfb4bd3d1a7c5b9c500d4a68 sig_cn_org=None source=14.1 
   <para>
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
   </para>
________________________________________________________-->
   <para>
    最后，在 ARE 里，方括号表达式外面，序列<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>（其中<replaceable>ttt</replaceable>是任意不包含一个<literal>)</literal>)的文本）是一个注释， 它被完全忽略。同样，这样的东西是不允许出现在多字符符号的字符中间的，例如 <literal>(?:</literal>。这种注释更像是一种历史产物而不是一种有用的设施，并且它们的使用已经被废弃；请使用扩展语法来替代。   </para>
<!-- pgdoc-cn_end sig_en=52d55879cfb4bd3d1a7c5b9c500d4a68 -->

<!-- pgdoc-cn_start sig_en=e93b1a06f1bd49f2c42a8d91791edf38 sig_cn_org=None source=14.1 
   <para>
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
   </para>
________________________________________________________-->
   <para>
    如果声明了一个初始的<literal>***=</literal>控制器，那么所有这些元语法扩展<emphasis>都不能</emphasis>使用，因为这样表示把用户输入当作一个文字串而不是 RE 对待。
   </para>
<!-- pgdoc-cn_end sig_en=e93b1a06f1bd49f2c42a8d91791edf38 -->
   </sect3>

   <sect3 id="posix-matching-rules">
<!-- pgdoc-cn_start sig_en=b09f0441872c6edce1c2feaae18fafe0 sig_cn_org=None source=14.1 
    <title>Regular Expression Matching Rules</title>
________________________________________________________-->
    <title>正则表达式匹配规则</title>
<!-- pgdoc-cn_end sig_en=b09f0441872c6edce1c2feaae18fafe0 -->

<!-- pgdoc-cn_start sig_en=ff40d3ee7d7ad384fba427c052ffd51e sig_cn_org=None source=14.1 
   <para>
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
   </para>
________________________________________________________-->
   <para>
    在 RE 可以在给定串中匹配多于一个子串的情况下， RE 匹配串中最靠前的那个子串。如果 RE 可以匹配在那个位置开始 的多个子串，要么是取最长的子串，要么是最短的，具体哪种， 取决于 RE 是<firstterm>贪婪</firstterm>的还是<firstterm>非贪婪</firstterm>的。
   </para>
<!-- pgdoc-cn_end sig_en=ff40d3ee7d7ad384fba427c052ffd51e -->

<!-- pgdoc-cn_start sig_en=6a71709657d9e5400ea4ace6fb6ac867 sig_cn_org=None source=14.1 
   <para>
    Whether an RE is greedy or not is determined by the following rules:
    <itemizedlist>
     <listitem>
      <para>
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
      </para>
     </listitem>
     <listitem>
      <para>
       Adding parentheses around an RE does not change its greediness.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
      </para>
     </listitem>
     <listitem>
      <para>
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    一个 RE 是否贪婪取决于下面规则：
    <itemizedlist>
     <listitem>
      <para>
       大多数原子以及所有约束，都没有贪婪属性（因为它们毕竟无法匹配个数变化的文本）。
      </para>
     </listitem>
     <listitem>
      <para>
       在一个 RE 周围加上圆括号并不会改变其贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       带一个固定重复次数量词 （<literal>{</literal><replaceable>m</replaceable><literal>}</literal>或者<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>） 的量化原子和原子自身具有同样的贪婪性（可能是没有）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带其他普通的量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>中<replaceable>m</replaceable>等于<replaceable>n</replaceable>的情况）的量化原子是贪婪的（首选最长匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带非贪婪量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>中<replaceable>m</replaceable>等于 <replaceable>n</replaceable>的情况）的量化原子是非贪婪的（首选最短匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个分支 &mdash; 也就是说，一个没有顶级<literal>|</literal>操作符的 RE &mdash; 和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       一个由<literal>|</literal>操作符连接起来的两个或者更多分支组成的 RE 总是贪婪的。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=6a71709657d9e5400ea4ace6fb6ac867 -->

<!-- pgdoc-cn_start sig_en=19991e79d776b9df515bf3c04bd46fb3 sig_cn_org=None source=14.1 
   <para>
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
   </para>
________________________________________________________-->
   <para>
    上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子， 而且也适用于包含量化原子的分支和整个 RE。这里的意思是， 匹配是按照分支或者整个 RE <emphasis>作为一个整体</emphasis>匹配最长或者最短的可能子串。 一旦整个匹配的长度确定，那么匹配任意特定子表达式的部分就基于该子表达式的贪婪属性进行判断，在 RE 里面靠前的子表达式的优先级高于靠后的子表达式。
   </para>
<!-- pgdoc-cn_end sig_en=19991e79d776b9df515bf3c04bd46fb3 -->

<!-- pgdoc-cn_start sig_en=159a6a6ced387bfb5a346dc1cca2d2fc sig_cn_org=None source=14.1 
   <para>
    An example of what this means:
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
   </para>
________________________________________________________-->
   <para>
    一个相应的例子：
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
    在第一个例子里，RE 作为整体是贪婪的，因为<literal>Y*</literal>是贪婪的。它可以匹配从<literal>Y</literal>开始的东西，并且它匹配从这个位置开始的最长的串， 也就是，<literal>Y123</literal>。输出是这里的圆括号包围的部分，或者说是<literal>123</literal>。在第二个例子里， RE 总体上是一个非贪婪的 RE，因为<literal>Y*?</literal>是非贪婪的。它可以匹配从<literal>Y</literal>开始的最短的子串，也就是说<literal>Y1</literal>。子表达式<literal>[0-9]{1,3}</literal>是贪婪的，但是它不能修改总体匹配长度的决定； 因此它被迫只匹配<literal>1</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=159a6a6ced387bfb5a346dc1cca2d2fc -->

<!-- pgdoc-cn_start sig_en=b2623c9a2e1b46950c41ff1bd40ec734 sig_cn_org=None source=14.1 
   <para>
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
   </para>
________________________________________________________-->
   <para>
    简而言之，如果一个 RE 同时包含贪婪和非贪婪的子表达式，那么总的匹配长度要么是尽可能长，要么是尽可能短，这取决于给整个 RE 赋予的属性。给子表达式赋予的属性只影响在这个匹配里，各个子表达式之间相互允许<quote>吃掉</quote>的多少。
   </para>
<!-- pgdoc-cn_end sig_en=b2623c9a2e1b46950c41ff1bd40ec734 -->

<!-- pgdoc-cn_start sig_en=0905269d5db6e58b05f9750bb49831f7 sig_cn_org=None source=14.1 
   <para>
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
   </para>
________________________________________________________-->
   <para>
    量词<literal>{1,1}</literal>和<literal>{1,1}?</literal>可以分别用于在一个子表达式
    或者整个 RE 上强制贪婪或者非贪婪。当需要整个 RE 具有不同于从其元素中
    推导出的贪婪属性时，这很有用。例如，假设我们尝试将一个包含一些数字的
    字符串分隔成数字以及在它们之前和之后的部分，我们可能会尝试这样做：
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    这不会有用：第一个<literal>.*</literal>是贪婪的，因此它会<quote>吃掉</quote>
    尽可能多的字符而留下<literal>\d+</literal>去匹配在最后一个可能位置上的最
    后一个数字。我们可能会通过让它变成非贪婪来修复：
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    这也不会有用：因为现在 RE 作为整体来说是非贪婪的，因此它会尽快结束
    全部的匹配。我们可以通过强制 RE 整体是贪婪的来得到我们想要的：
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    独立于 RE 的组件的贪婪性之外控制 RE 的整体贪婪性为处理变长模式提供了
    很大的灵活性。
   </para>
<!-- pgdoc-cn_end sig_en=0905269d5db6e58b05f9750bb49831f7 -->

<!-- pgdoc-cn_start sig_en=a3390fa5456ef9addb4c68df6a301fee sig_cn_org=None source=14.1 
   <para>
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
   </para>
________________________________________________________-->
   <para>
    在决定更长或者更短的匹配时，匹配长度是以字符衡量的，而不是排序元素。一个空串会被认为比什么都不匹配长。例如：<literal>bb*</literal>匹配<literal>abbbc</literal>的中间三个字符；<literal>(week|wee)(night|knights)</literal>匹配<literal>weeknights</literal>的所有十个字符； 而<literal>(.*).*</literal>匹配 <literal>abc</literal>的时候，圆括号包围的子表达式匹配所有三个字符；当<literal>(a*)*</literal>被拿来匹配<literal>bc</literal>时，整个 RE 和圆括号 子表达式都匹配一个空串。
   </para>
<!-- pgdoc-cn_end sig_en=a3390fa5456ef9addb4c68df6a301fee -->

<!-- pgdoc-cn_start sig_en=1a5cb6c25759a49886ac81f158e35ec5 sig_cn_org=None source=14.1 
   <para>
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
   </para>
________________________________________________________-->
   <para>
    如果声明了大小写无关的匹配，那么效果就好像所有大小写区别在字母表中消失了。如果在多个情况中一个字母以一个普通字符的形式出现在方括号表达式外面，那么它实际上被转换成 一个包含大小写的方括号表达式，也就是说，x 变成 [xX]。 如果它出现在一个方括号表达式里面，那么它的所有大小写的同族都被加入 方括号表达式中，也就是说，<literal>x</literal>变成<literal>[xX]</literal>。当它出现在一个方括号表达式内时，它的所有大小写副本都被加入到方括号表达式中，例如， <literal>[x]</literal>会变成<literal>[xX]</literal>，而<literal>[^x]</literal>会变成<literal>[^xX]</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=1a5cb6c25759a49886ac81f158e35ec5 -->

<!-- pgdoc-cn_start sig_en=d5307e9be3b48f13c1de0b03519a23c5 sig_cn_org=None source=14.1 
   <para>
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will not cross lines unless the RE
    explicitly includes a newline)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
    Also, the character class shorthands <literal>\D</literal>
    and <literal>\W</literal> will match a newline regardless of this mode.
    (Before <productname>PostgreSQL</productname> 14, they did not match
    newlines when in newline-sensitive mode.
    Write <literal>[^[:digit:]]</literal>
    or <literal>[^[:word:]]</literal> to get the old behavior.)
   </para>
________________________________________________________-->
   <para>
    如果指定了换行敏感的匹配，<literal>.</literal>和使用<literal>^</literal>的方括号表达式 将永远不会匹配换行字符（这样，匹配就不会跨越行，除非 RE 显式地包含了换行）并且<literal>^</literal>和<literal>$</literal>除了分别匹配串开头和结尾之外，还将分别匹配换行后面和前面的空串。
    但是 ARE 逃逸<literal>\A</literal>和<literal>\Z</literal>仍然<emphasis>只</emphasis>匹配串的开头和结尾。
    此外，字符类缩写符<literal>\D</literal>和<literal>\W</literal>将匹配换行，而无论这种模式如何。
    （在<productname>PostgreSQL</productname> 14之前，它们在换行敏感模式下不匹配换行。
    写入<literal>[^[:digit:]]</literal> 或 <literal>[^[:word:]]</literal>以获取旧的行为。)
   </para>
<!-- pgdoc-cn_end sig_en=d5307e9be3b48f13c1de0b03519a23c5 -->

<!-- pgdoc-cn_start sig_en=3df4fd00cc549d4400516cde0f87d79d sig_cn_org=None source=14.1 
   <para>
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
   </para>
________________________________________________________-->
   <para>
    如果指定了部分新行敏感的匹配，那么它影响<literal>.</literal>和方括号表达式， 这个时候和新行敏感的匹配一样，但是不影响<literal>^</literal>和<literal>$</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=3df4fd00cc549d4400516cde0f87d79d -->

<!-- pgdoc-cn_start sig_en=d21382d3543e94ca4c9b27a2dd028b0d sig_cn_org=None source=14.1 
   <para>
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
   </para>
________________________________________________________-->
   <para>
    如果指定了逆新行敏感匹配，那么它影响<literal>^</literal>和<literal>$</literal>，其作用和在新行敏感的匹配里一样，但是不影响<literal>.</literal>和方括号表达式。这个并不是很有用，只是为了满足对称性而提供的。
   </para>
<!-- pgdoc-cn_end sig_en=d21382d3543e94ca4c9b27a2dd028b0d -->
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!-- pgdoc-cn_start sig_en=3cb68971994b914eb28ca458cc177574 sig_cn_org=None source=14.1 
    <title>Limits and Compatibility</title>
________________________________________________________-->
    <title>限制和兼容性</title>
<!-- pgdoc-cn_end sig_en=3cb68971994b914eb28ca458cc177574 -->

<!-- pgdoc-cn_start sig_en=dacdc9691a3948be0a90161715fc515a sig_cn_org=None source=14.1 
   <para>
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
   </para>
________________________________________________________-->
   <para>
    在这个实现里，对 RE 的长度没有特别的限制。但是，那些希望高移植性的程序应该避免使用长度超过 256 字节的 RE，因为 POSIX 兼容 的实现可以拒绝接受这样的 RE。
   </para>
<!-- pgdoc-cn_end sig_en=dacdc9691a3948be0a90161715fc515a -->

<!-- pgdoc-cn_start sig_en=63a84414bbbe1ba061de6aa920fa627e sig_cn_org=None source=14.1 
   <para>
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
   </para>
________________________________________________________-->
   <para>
    ARE 实际上和 POSIX ERE 不兼容的唯一的特性是在方括号表达式里<literal>\</literal>并不失去它特殊的含义。所有其它 ARE 特性都使用在 POSIX ERE 里面是非法或者是未定义、未声明效果的语法；指示器的<literal>***</literal>就是在 POSIX 的 BRE 和 ERE 之外的语法。
   </para>
<!-- pgdoc-cn_end sig_en=63a84414bbbe1ba061de6aa920fa627e -->

<!-- pgdoc-cn_start sig_en=4cc1c608d36291cb7e3441b57542c06a sig_cn_org=None source=14.1 
   <para>
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
   </para>
________________________________________________________-->
   <para>
    许多 ARE 扩展都是从 Perl 那里借来的（但是有些被做了修改来清理它们），以及一些 Perl 里没有出现的扩展。要注意的不兼容性包括<literal>\b</literal>、<literal>\B</literal>、对结尾的新行缺乏特别的处理、对那些被新行敏感匹配的东西附加的补齐方括号表达式、在 lookahead/lookbehind 约束里对圆括号和后引用的限制以及最长/最短 匹配（而不是第一匹配）的语义。
   </para>
<!-- pgdoc-cn_end sig_en=4cc1c608d36291cb7e3441b57542c06a -->
   </sect3>

   <sect3 id="posix-basic-regexes">
<!-- pgdoc-cn_start sig_en=5e6e434d572bfd8c16c2153361a053ac sig_cn_org=None source=14.1 
    <title>Basic Regular Expressions</title>
________________________________________________________-->
    <title>基本正则表达式</title>
<!-- pgdoc-cn_end sig_en=5e6e434d572bfd8c16c2153361a053ac -->

<!-- pgdoc-cn_start sig_en=bb38d20831aa275d488e0e675cabcd4d sig_cn_org=None source=14.1 
   <para>
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
   </para>
________________________________________________________-->
   <para>
    BREs 在几个方面和 ERE 不太一样。在 BRE 中，<literal>|</literal>、<literal>+</literal>和<literal>?</literal>都是普通字符并且没有与它们功能等价的东西。范围的定界符是<literal>\{</literal>和<literal>\}</literal>， 因为 <literal>{</literal>和<literal>}</literal>本身是普通字符。嵌套的子表达式的圆括号是<literal>\(</literal>和<literal>\)</literal>，因为<literal>(</literal>和<literal>)</literal>自身是普通字符。除非在 RE 开头或者是圆括号子表达式开头，<literal>^</literal>都是一个普通字符。 除非在 RE 结尾或者是圆括号子表达式的结尾，<literal>$</literal>是一个普通字符。如果<literal>*</literal>出现在 RE 开头或者是圆括号封装的子表达式开头 （前面可能有<literal>^</literal>），那么它是个普通字符。最后，可以用单数字的后引用，<literal>\&lt;</literal>和<literal>\&gt;</literal>分别是<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>的同义词；在 BRE 中没有其它可用的逃逸。
   </para>
<!-- pgdoc-cn_end sig_en=bb38d20831aa275d488e0e675cabcd4d -->
   </sect3>

<!-- end re_syntax.n man page -->

   <sect3 id="posix-vs-xquery">
<!-- pgdoc-cn_start sig_en=d3f781b916a017d14c02f232e471d173 sig_cn_org=c09eacd8168626a77a44b534d42be180 source=15.7 
   <title>Differences from SQL Standard and XQuery</title>
________________________________________________________-->
   <title>与SQL标准和XQuery的区别</title>
<!-- pgdoc-cn_end sig_en=d3f781b916a017d14c02f232e471d173 -->

<!-- pgdoc-cn_start sig_en=74bbb020cc4d177e4aa0847c6194dbd6 sig_cn_org=84eb1cf91a75913c37e712723b9f2c08 source=15.7 
   <indexterm zone="posix-vs-xquery">
    <primary>LIKE_REGEX</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>LIKE_REGEX</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=74bbb020cc4d177e4aa0847c6194dbd6 -->

<!-- pgdoc-cn_start sig_en=d3037460196a3db8f9f0d7c7ca4a4e62 sig_cn_org=1baa5bf66e4264ff48d4385412e72c7e source=15.7 
   <indexterm zone="posix-vs-xquery">
    <primary>OCCURRENCES_REGEX</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>OCCURRENCES_REGEX</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=d3037460196a3db8f9f0d7c7ca4a4e62 -->

<!-- pgdoc-cn_start sig_en=13e16aaa88479e671735a8383ecda417 sig_cn_org=74949533266d22375e885fece667394d source=15.7 
   <indexterm zone="posix-vs-xquery">
    <primary>POSITION_REGEX</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>POSITION_REGEX</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=13e16aaa88479e671735a8383ecda417 -->

<!-- pgdoc-cn_start sig_en=593e8e7a882899cdc5c9dc433643d515 sig_cn_org=e3de7a1c92a3e29329e43b2f8b9934f9 source=15.7 
   <indexterm zone="posix-vs-xquery">
    <primary>SUBSTRING_REGEX</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>SUBSTRING_REGEX</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=593e8e7a882899cdc5c9dc433643d515 -->

<!-- pgdoc-cn_start sig_en=d4e77ae1a0347a1572bcf43dd77184db sig_cn_org=775724064e811ed065a8d82bfdba2e29 source=15.7 
   <indexterm zone="posix-vs-xquery">
    <primary>TRANSLATE_REGEX</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>TRANSLATE_REGEX</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=d4e77ae1a0347a1572bcf43dd77184db -->

<!-- pgdoc-cn_start sig_en=57b35c0b9a60b3fdc69a778b9cb32361 sig_cn_org=None source=14.1 
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery regular expressions</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery正则表达式</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=57b35c0b9a60b3fdc69a778b9cb32361 -->

<!-- pgdoc-cn_start sig_en=3b13b5f0cd7c70989591b942e2ee993e sig_cn_org=184c8d690bfd6da4db704bb671f01c7d source=15.7 
    <para>
     Since SQL:2008, the SQL standard includes regular expression operators
     and functions that performs pattern
     matching according to the XQuery regular expression
     standard:
     <itemizedlist>
      <listitem><para><literal>LIKE_REGEX</literal></para></listitem>
      <listitem><para><literal>OCCURRENCES_REGEX</literal></para></listitem>
      <listitem><para><literal>POSITION_REGEX</literal></para></listitem>
      <listitem><para><literal>SUBSTRING_REGEX</literal></para></listitem>
      <listitem><para><literal>TRANSLATE_REGEX</literal></para></listitem>
     </itemizedlist>
     <productname>PostgreSQL</productname> does not currently implement these
     operators and functions.  You can get approximately equivalent
     functionality in each case as shown in <xref
     linkend="functions-regexp-sql-table"/>.  (Various optional clauses on
     both sides have been omitted in this table.)
    </para>
________________________________________________________-->
    <para>
     自SQL:2008以来，SQL标准包括正则表达式运算符和函数，根据XQuery正则表达式标准进行模式匹配：
     <itemizedlist>
      <listitem><para><literal>LIKE_REGEX</literal></para></listitem>
      <listitem><para><literal>OCCURRENCES_REGEX</literal></para></listitem>
      <listitem><para><literal>POSITION_REGEX</literal></para></listitem>
      <listitem><para><literal>SUBSTRING_REGEX</literal></para></listitem>
      <listitem><para><literal>TRANSLATE_REGEX</literal></para></listitem>
     </itemizedlist>
     <productname>PostgreSQL</productname>目前尚未实现这些运算符和函数。您可以在每种情况下获得近似等效的功能，如<xref
     linkend="functions-regexp-sql-table"/>中所示。（此表中已省略了双方的各种可选子句。）
    </para>
<!-- pgdoc-cn_end sig_en=3b13b5f0cd7c70989591b942e2ee993e -->

    <table id="functions-regexp-sql-table">
<!-- pgdoc-cn_start sig_en=7da53a99826181933e39f2911ef3d16a sig_cn_org=d626630fae1dae124ae98e42ecc9a529 source=15.7 
     <title>Regular Expression Functions Equivalencies</title>
________________________________________________________-->
     <title>正则表达式函数等效性</title>
<!-- pgdoc-cn_end sig_en=7da53a99826181933e39f2911ef3d16a -->

     <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=32f8d67cf8c61094c7ae633d451b516e sig_cn_org=ab64fc4e0ccecabf8ffc209acc44846e source=15.7 
       <row>
        <entry>SQL standard</entry>
        <entry>PostgreSQL</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>SQL标准</entry>
        <entry>PostgreSQL</entry>
       </row>
<!-- pgdoc-cn_end sig_en=32f8d67cf8c61094c7ae633d451b516e -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=b456a2ea2eb25828463addd6ca5478a5 sig_cn_org=640c812d002abb4f8387e8b4b3e6f8d1 source=15.7 
       <row>
        <entry><literal><replaceable>string</replaceable> LIKE_REGEX <replaceable>pattern</replaceable></literal></entry>
        <entry><literal>regexp_like(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal> or <literal><replaceable>string</replaceable> ~ <replaceable>pattern</replaceable></literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal><replaceable>string</replaceable> LIKE_REGEX <replaceable>pattern</replaceable></literal></entry>
        <entry><literal>regexp_like(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal> 或 <literal><replaceable>string</replaceable> ~ <replaceable>pattern</replaceable></literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=b456a2ea2eb25828463addd6ca5478a5 -->

       <row>
        <entry><literal>OCCURRENCES_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_count(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>POSITION_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_instr(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>SUBSTRING_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_substr(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>TRANSLATE_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable> WITH <replaceable>replacement</replaceable>)</literal></entry>
        <entry><literal>regexp_replace(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=5e796b19e6b43dffc749512df4b03526 sig_cn_org=2c7500a1d4f35f72247bf2c593d860d4 source=15.7 
    <para>
     Regular expression functions similar to those provided by PostgreSQL are
     also available in a number of other SQL implementations, whereas the
     SQL-standard functions are not as widely implemented.  Some of the
     details of the regular expression syntax will likely differ in each
     implementation.
    </para>
________________________________________________________-->
    <para>
     与PostgreSQL提供的类似的正则表达式函数在许多其他SQL实现中也可用，而SQL标准函数并不如此广泛实现。
     每个实现中正则表达式语法的一些细节可能会有所不同。
    </para>
<!-- pgdoc-cn_end sig_en=5e796b19e6b43dffc749512df4b03526 -->

<!-- pgdoc-cn_start sig_en=dd50a4af955e565edc44931902c2e2e1 sig_cn_org=28cf479db8e6f76239f461400e926951 source=15.7 
    <para>
     The SQL-standard operators and functions use XQuery regular expressions,
     which are quite close to the ARE syntax described above.
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:

     <itemizedlist>
      <listitem>
________________________________________________________-->
    <para>
    SQL标准运算符和函数使用XQuery正则表达式，这些正则表达式与上述ARE语法非常接近。现有基于POSIX的正则表达式功能和XQuery正则表达式之间的显着差异包括：
     <itemizedlist>
      <listitem>
<!-- pgdoc-cn_end sig_en=dd50a4af955e565edc44931902c2e2e1 -->
<!-- pgdoc-cn_start sig_en=23684cb003564cd363682e98f7f978cb sig_cn_org=fdebf2e9ded596bb71a0e452ab9eddf5 source=15.7 
       <para>
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
       </para>
________________________________________________________-->
       <para>
        XQuery字符类减法不受支持。一个示例是使用以下内容仅匹配英语辅音：<literal>[a-z-[aeiou]]</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=23684cb003564cd363682e98f7f978cb -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=9facfe3627269518da39fb0b691d8f8e sig_cn_org=46329bd9646fb35c43e34cd9f81db362 source=15.7 
       <para>
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
       </para>
________________________________________________________-->
       <para>
        XQuery字符类简写<literal>\c</literal>、<literal>\C</literal>、<literal>\i</literal>和<literal>\I</literal>不受支持。
       </para>
<!-- pgdoc-cn_end sig_en=9facfe3627269518da39fb0b691d8f8e -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=2140145e2269ed39431234dbf8b83b13 sig_cn_org=9b818418b00494d23f75e79ff7700613 source=15.7 
       <para>
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
       </para>
________________________________________________________-->
       <para>
        使用<literal>\p{UnicodeProperty}</literal>或其反义<literal>\P{UnicodeProperty}</literal>来定义XQuery字符类元素是不被支持的。
       </para>
<!-- pgdoc-cn_end sig_en=2140145e2269ed39431234dbf8b83b13 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=3945cc8bb0e8db2b8202907b1dac4c95 sig_cn_org=fbc3c393a49f0edab8971ef62d05b2b9 source=15.7 
       <para>
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
       </para>
________________________________________________________-->
       <para>
        POSIX解释字符类，如<literal>\w</literal>
        （参见<xref linkend="posix-class-shorthand-escapes-table"/>）
        根据当前区域设置（您可以通过将<literal>COLLATE</literal>子句附加到运算符或函数来控制）。
        XQuery通过参考Unicode字符属性来指定这些类别，因此只有遵循Unicode规则的区域设置才能获得等效行为。
       </para>
<!-- pgdoc-cn_end sig_en=3945cc8bb0e8db2b8202907b1dac4c95 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=af50d4d1757fca82f55ac4cc82be6dd4 sig_cn_org=be0d0a1b13b1658812c7e4ecd9b1a4ee source=15.7 
       <para>
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
       </para>
________________________________________________________-->
       <para>
        SQL标准（而不是XQuery本身）试图适应比POSIX更多的<quote>换行符</quote>变体。上面描述的换行符敏感匹配选项只考虑ASCII NL（<literal>\n</literal>）为换行符，但SQL要求我们将CR（<literal>\r</literal>）、CRLF（<literal>\r\n</literal>）（Windows风格的换行符）以及一些仅限于Unicode的字符，如LINE SEPARATOR（U+2028），也视为换行符。
        值得注意的是，<literal>.</literal>和<literal>\s</literal>应该根据SQL的规定将<literal>\r\n</literal>视为一个字符而不是两个字符。
       </para>
<!-- pgdoc-cn_end sig_en=af50d4d1757fca82f55ac4cc82be6dd4 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=5d8eee766e20b6d9d6313a90a169b905 sig_cn_org=484f39c068b6f5f41949dbb187a16013 source=15.7 
       <para>
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
       </para>
________________________________________________________-->
       <para>
        在描述的字符输入转义中
        <xref linkend="posix-character-entry-escapes-table"/>中，
        XQuery仅支持<literal>\n</literal>，<literal>\r</literal>，
        和<literal>\t</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=5d8eee766e20b6d9d6313a90a169b905 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=c3995771f02af9b48a9ac19acaf42201 sig_cn_org=0b83390c3b21754d9025b9b83eead3a7 source=15.7 
       <para>
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
       </para>
________________________________________________________-->
       <para>
        XQuery不支持方括号表达式中的字符类<literal>[:<replaceable>name</replaceable>:]</literal>语法。
       </para>
<!-- pgdoc-cn_end sig_en=c3995771f02af9b48a9ac19acaf42201 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=214a71a1a1431a87a2c85c1c90835e02 sig_cn_org=437ca937256522f06050bffd71da7829 source=15.7 
       <para>
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
       </para>
________________________________________________________-->
       <para>
        XQuery没有前瞻或后顾约束，也没有在<xref linkend="posix-constraint-escapes-table"/>中描述的任何约束转义。
       </para>
<!-- pgdoc-cn_end sig_en=214a71a1a1431a87a2c85c1c90835e02 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=4278fe60f7b928746eaa56f1bf159608 sig_cn_org=cccc6d29946f4806864426afb2bc645a source=15.7 
       <para>
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
       </para>
________________________________________________________-->
       <para>
        在XQuery中不存在<xref linkend="posix-metasyntax"/>中描述的元语法形式。
       </para>
<!-- pgdoc-cn_end sig_en=4278fe60f7b928746eaa56f1bf159608 -->
      </listitem>
      <listitem>
<!-- pgdoc-cn_start sig_en=3665f405e681aab5a91c3e30db9b168d sig_cn_org=8bbdfa2c0c82a758602b654b7cf27163 source=15.7 
       <para>
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
        <itemizedlist>
         <listitem>
          <para>
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        XQuery定义的正则表达式标志字母与POSIX的选项字母相关，但并不相同
        （<xref linkend="posix-embedded-options-table"/>）。虽然
        <literal>i</literal>和<literal>q</literal>选项的行为相同，其他选项则不同：
        <itemizedlist>
         <listitem>
          <para>
           XQuery的<literal>s</literal>（允许点匹配换行符）
           和<literal>m</literal>（允许<literal>^</literal>
           和<literal>$</literal>匹配换行符）标志提供
           与POSIX的<literal>n</literal>、<literal>p</literal>
           和<literal>w</literal>标志相同的行为，但它们
           <emphasis>不</emphasis>匹配POSIX的<literal>s</literal>和<literal>m</literal>标志的行为。
           特别注意，点匹配换行符是POSIX的默认行为，但不是XQuery的。
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery的<literal>x</literal>（忽略模式中的空白）标志
           与POSIX的扩展模式标志明显不同。
           POSIX的<literal>x</literal>标志还
           允许<literal>#</literal>在模式中开始一个注释，
           并且POSIX不会忽略反斜杠后的空白字符。
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=3665f405e681aab5a91c3e30db9b168d -->
      </listitem>
     </itemizedlist>
    </para>

   </sect3>
  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
<!-- pgdoc-cn_start sig_en=8c30e4f8af9fda7bd50accf62abc145f sig_cn_org=None source=14.1 
   <title>Data Type Formatting Functions</title>
________________________________________________________-->
   <title>数据类型格式化函数</title>
<!-- pgdoc-cn_end sig_en=8c30e4f8af9fda7bd50accf62abc145f -->

<!-- pgdoc-cn_start sig_en=c2b8cf98386edd12d54cc04788eaf404 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>formatting</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>formatting</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c2b8cf98386edd12d54cc04788eaf404 -->

<!-- pgdoc-cn_start sig_en=cc6b9510c6eea4fd5f689aebdb978747 sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>格式化函数提供一套强大的工具用于把各种数据类型 （日期/时间、整数、浮点、数字） 转换成格式化的字符串以及反过来从格式化的字符串转换成 指定的数据类型。<xref linkend="functions-formatting-table"/>列出了这些函数。这些函数都遵循一个公共的调用规范： 第一个参数是待格式化的值，而第二个是一个定义输出或输入格式的模板。
   </para>
<!-- pgdoc-cn_end sig_en=cc6b9510c6eea4fd5f689aebdb978747 -->

   <table id="functions-formatting-table">
<!-- pgdoc-cn_start sig_en=ea7e1b9bdf9dc176dd34ccdae850844f sig_cn_org=None source=14.1 
    <title>Formatting Functions</title>
________________________________________________________-->
    <title>格式化函数</title>
<!-- pgdoc-cn_end sig_en=ea7e1b9bdf9dc176dd34ccdae850844f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=dd863ca0f31ab959858ea44d8252bc16 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts time stamp to string according to the given format.
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将时间戳转换为字符串。
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dd863ca0f31ab959858ea44d8252bc16 -->

<!-- pgdoc-cn_start sig_en=8a3bcb3288e53290e5fc33eb44433c8a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts interval to string according to the given format.
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将间隔转换为字符串。
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8a3bcb3288e53290e5fc33eb44433c8a -->

<!-- pgdoc-cn_start sig_en=1d9e81df6a1fc3f8ef0baac2ab4c6deb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts number to string according to the given format; available
        for <type>integer</type>, <type>bigint</type>, <type>numeric</type>,
        <type>real</type>, <type>double precision</type>.
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将数字转换为字符串；适用于 <type>integer</type>， <type>bigint</type>， <type>numeric</type>，<type>real</type>， <type>double precision</type>。
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1d9e81df6a1fc3f8ef0baac2ab4c6deb -->

<!-- pgdoc-cn_start sig_en=ce56505110a5616a01d8002efeedb685 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        Converts string to date according to the given format.
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为日期。
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ce56505110a5616a01d8002efeedb685 -->

<!-- pgdoc-cn_start sig_en=33d8f251dafa4564d71cad8e941d38cc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Converts string to numeric according to the given format.
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为数字。
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=33d8f251dafa4564d71cad8e941d38cc -->

<!-- pgdoc-cn_start sig_en=13b0ea41efdb8ea95e350344d3380004 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Converts string to time stamp according to the given format.
        (See also <function>to_timestamp(double precision)</function> in
        <xref linkend="functions-datetime-table"/>.)
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为时间戳。
        （也请参见<xref linkend="functions-datetime-table"/>中的<function>to_timestamp(double precision)</function> 。）
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=13b0ea41efdb8ea95e350344d3380004 -->
     </tbody>
    </tgroup>
   </table>

   <tip>
<!-- pgdoc-cn_start sig_en=ec18d18c90c9f46a7c0b15ea7a6c538e sig_cn_org=None source=14.1 
    <para>
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
    </para>
________________________________________________________-->
    <para>
     <function>to_timestamp</function>和<function>to_date</function>存在的目的是为了处理无法用简单造型转换的输入格式。对于大部分标准的日期/时间格式，简单地把源字符串造型成所需的数据类型是可以的，并且简单很多。类似地，对于标准的数字表示形式，<function>to_number</function>也是没有必要的。
    </para>
<!-- pgdoc-cn_end sig_en=ec18d18c90c9f46a7c0b15ea7a6c538e -->
   </tip>

<!-- pgdoc-cn_start sig_en=090d74c5cf19b75e4f4526132de9fcbb sig_cn_org=None source=14.1 
   <para>
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
   </para>
________________________________________________________-->
   <para>
    在一个<function>to_char</function>输出模板串中，一些特定的模式可以被识别并且被替换成基于给定值的被恰当地格式化的数据。任何不属于模板模式的文本都简单地照字面拷贝。同样，在一个输入 模板串里（对其他函数），模板模式标识由输入数据串提供的值。如果在模板字符串中有不是模板模式的字符，输入数据字符串中的对应字符会被简单地跳过（不管它们是否等于模板字符串字符）。
   </para>
<!-- pgdoc-cn_end sig_en=090d74c5cf19b75e4f4526132de9fcbb -->

<!-- pgdoc-cn_start sig_en=587476a111a2110262664f5ad12c3c7d sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-datetime-table"/>展示了可以用于格式化日期和时间值的模版。
  </para>
<!-- pgdoc-cn_end sig_en=587476a111a2110262664f5ad12c3c7d -->

    <table id="functions-formatting-datetime-table">
<!-- pgdoc-cn_start sig_en=283b0b240d4bd655cb817c4aa70b1d97 sig_cn_org=None source=14.1 
     <title>Template Patterns for Date/Time Formatting</title>
________________________________________________________-->
     <title>用于日期/时间格式化的模板模式</title>
<!-- pgdoc-cn_end sig_en=283b0b240d4bd655cb817c4aa70b1d97 -->
     <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=ac864b532e87ccc34292f8be1f7eeb5e sig_cn_org=None source=14.1 
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ac864b532e87ccc34292f8be1f7eeb5e -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=dd363d1bc7f5d9a58b0df9c4d67a7fa1 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>HH</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>HH</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=dd363d1bc7f5d9a58b0df9c4d67a7fa1 -->
<!-- pgdoc-cn_start sig_en=2240089678cbcedd9cb66d2a80604589 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2240089678cbcedd9cb66d2a80604589 -->
<!-- pgdoc-cn_start sig_en=c01f6b7871e1c30cd06eca3f0a6913f7 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>hour of day (00&ndash;23)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>一天中的小时 (00&ndash;23)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c01f6b7871e1c30cd06eca3f0a6913f7 -->
<!-- pgdoc-cn_start sig_en=80e0f57f2aa213d142bca5d2083b3936 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minute (00&ndash;59)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>分钟 (00&ndash;59)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=80e0f57f2aa213d142bca5d2083b3936 -->
<!-- pgdoc-cn_start sig_en=60890a1035a7b4fed3562c3c66226a90 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SS</literal></entry>
        <entry>second (00&ndash;59)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SS</literal></entry>
        <entry>秒 (00&ndash;59)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=60890a1035a7b4fed3562c3c66226a90 -->
<!-- pgdoc-cn_start sig_en=c110072c010e1444dd6f4fc5425e827f sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MS</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MS</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c110072c010e1444dd6f4fc5425e827f -->
<!-- pgdoc-cn_start sig_en=e558d10ee31edd1f6426d1cc7be814a6 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>US</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>US</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e558d10ee31edd1f6426d1cc7be814a6 -->
<!-- pgdoc-cn_start sig_en=8ae15e1ea383fc8e6ddc2e94dfd155c8 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>tenth of second (0&ndash;9)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>十分之一秒 (0&ndash;9)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8ae15e1ea383fc8e6ddc2e94dfd155c8 -->
<!-- pgdoc-cn_start sig_en=002756290fbc70a251e71d5ff44e783e sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>hundredth of second (00&ndash;99)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>百分之一秒 (00&ndash;99)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=002756290fbc70a251e71d5ff44e783e -->
<!-- pgdoc-cn_start sig_en=d41cee2ac21ec557dc77654afe9ee779 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d41cee2ac21ec557dc77654afe9ee779 -->
<!-- pgdoc-cn_start sig_en=8741942df363b752133826eb7899ae88 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>tenth of a millisecond (0000&ndash;9999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>十分之一毫秒 (0000&ndash;9999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8741942df363b752133826eb7899ae88 -->
<!-- pgdoc-cn_start sig_en=87c32858428a4ed78c36e8ff1b987b41 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>hundredth of a millisecond (00000&ndash;99999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>百分之一毫秒 (00000&ndash;99999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=87c32858428a4ed78c36e8ff1b987b41 -->
<!-- pgdoc-cn_start sig_en=7b2c4bf5a9b1a4cc6b8e17b5f887a499 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7b2c4bf5a9b1a4cc6b8e17b5f887a499 -->
<!-- pgdoc-cn_start sig_en=8059187271dbc756860bc911c68d9317 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>seconds past midnight (0&ndash;86399)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>午夜后的秒 (0&ndash;86399)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8059187271dbc756860bc911c68d9317 -->
<!-- pgdoc-cn_start sig_en=790a04888c94ff811783c3f28e794719 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>meridiem indicator (without periods)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>正午指示器（不带句号）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=790a04888c94ff811783c3f28e794719 -->
<!-- pgdoc-cn_start sig_en=5726f9db8e5b90c5fa24c38c4770b947 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>meridiem indicator (with periods)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>正午指示器（带句号）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5726f9db8e5b90c5fa24c38c4770b947 -->
<!-- pgdoc-cn_start sig_en=b0e4ad0427f2deb2c32a0bdfb43732f0 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>year (4 or more digits) with comma</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>带逗号的年（4 位或者更多位） with comma</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b0e4ad0427f2deb2c32a0bdfb43732f0 -->
<!-- pgdoc-cn_start sig_en=ce7ceb061d925e673cbed488cbff0ea7 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>year (4 or more digits)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>年（4 位或者更多位）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ce7ceb061d925e673cbed488cbff0ea7 -->
<!-- pgdoc-cn_start sig_en=435b6526206019e8d8e8c50f4674850d sig_cn_org=None source=14.1 
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>last 3 digits of year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>年的最后 3 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=435b6526206019e8d8e8c50f4674850d -->
<!-- pgdoc-cn_start sig_en=280b7bfa23c05aa758f07d4416d091c4 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>YY</literal></entry>
        <entry>last 2 digits of year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>YY</literal></entry>
        <entry>年的最后 2 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=280b7bfa23c05aa758f07d4416d091c4 -->
<!-- pgdoc-cn_start sig_en=558c6d5a173b12dbbd1cc72a94f3117c sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Y</literal></entry>
        <entry>last digit of year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Y</literal></entry>
        <entry>年的最后 1 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=558c6d5a173b12dbbd1cc72a94f3117c -->
<!-- pgdoc-cn_start sig_en=349bcf09728634a470ef57c80a974123 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 周编号方式的年（4 位或更多位）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=349bcf09728634a470ef57c80a974123 -->
<!-- pgdoc-cn_start sig_en=9a6f3b82e9064cfed4d831a814205664 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 3 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9a6f3b82e9064cfed4d831a814205664 -->
<!-- pgdoc-cn_start sig_en=c9f55f79690bac2d417187ecab30ca05 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>IY</literal></entry>
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>IY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 2 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c9f55f79690bac2d417187ecab30ca05 -->
<!-- pgdoc-cn_start sig_en=4b3226858cc689dc21f03ad117f856c8 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>I</literal></entry>
        <entry>last digit of ISO 8601 week-numbering year</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>I</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 1 位数字</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4b3226858cc689dc21f03ad117f856c8 -->
<!-- pgdoc-cn_start sig_en=7c2eaa758752ccfba67bcf2e0e6871a1 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
        <entry>era indicator (without periods)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> 或 <literal>ad</literal></entry>
        <entry>纪元指示器（不带句号）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7c2eaa758752ccfba67bcf2e0e6871a1 -->
<!-- pgdoc-cn_start sig_en=094262b169afef07f4ea52237f2ce9d1 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
        <entry>era indicator (with periods)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> 或 <literal>a.d.</literal></entry>
        <entry>纪元指示器（带句号）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=094262b169afef07f4ea52237f2ce9d1 -->
<!-- pgdoc-cn_start sig_en=d1891b2781e98051ddb56c128db902d0 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>全大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d1891b2781e98051ddb56c128db902d0 -->
<!-- pgdoc-cn_start sig_en=f01b37761bbd3f2128052dd5742c05c4 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Month</literal></entry>
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Month</literal></entry>
        <entry>全首字母大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f01b37761bbd3f2128052dd5742c05c4 -->
<!-- pgdoc-cn_start sig_en=a49ac67863d6a73f88966d46aeb53471 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>month</literal></entry>
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>month</literal></entry>
        <entry>全小写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a49ac67863d6a73f88966d46aeb53471 -->
<!-- pgdoc-cn_start sig_en=78065434c8869c06e2f66cd44f5ea6af sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MON</literal></entry>
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MON</literal></entry>
        <entry>简写的大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=78065434c8869c06e2f66cd44f5ea6af -->
<!-- pgdoc-cn_start sig_en=9e64914162320c6d4ee20ddaac054ae9 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>简写的首字母大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9e64914162320c6d4ee20ddaac054ae9 -->
<!-- pgdoc-cn_start sig_en=c323f066526a91047ce6b8851acf66ff sig_cn_org=None source=14.1 
       <row>
        <entry><literal>mon</literal></entry>
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>mon</literal></entry>
        <entry>简写的小写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c323f066526a91047ce6b8851acf66ff -->
<!-- pgdoc-cn_start sig_en=ff1fa359e2488dbeaa75edd7081ff8f6 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MM</literal></entry>
        <entry>month number (01&ndash;12)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MM</literal></entry>
        <entry>月编号 (01&ndash;12)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ff1fa359e2488dbeaa75edd7081ff8f6 -->
<!-- pgdoc-cn_start sig_en=5bec9bf98e63695575c2536348bc905b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>全大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5bec9bf98e63695575c2536348bc905b -->
<!-- pgdoc-cn_start sig_en=687aad3731046c17e7d0e683229dd557 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Day</literal></entry>
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Day</literal></entry>
        <entry>全首字母大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=687aad3731046c17e7d0e683229dd557 -->
<!-- pgdoc-cn_start sig_en=fd948d9393a1a67f2b307d222ce487d0 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>day</literal></entry>
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>day</literal></entry>
        <entry>全小写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=fd948d9393a1a67f2b307d222ce487d0 -->
<!-- pgdoc-cn_start sig_en=c0f023e53cd74bf1e3ff420de89b8859 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>DY</literal></entry>
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>DY</literal></entry>
        <entry>简写的大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c0f023e53cd74bf1e3ff420de89b8859 -->
<!-- pgdoc-cn_start sig_en=7c8942246a31dc62e3d4e5c70e10f4ad sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>简写的首字母大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=7c8942246a31dc62e3d4e5c70e10f4ad -->
<!-- pgdoc-cn_start sig_en=c241a3b7ece963d34d2d388d99bf0559 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>dy</literal></entry>
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>dy</literal></entry>
        <entry>简写的小写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c241a3b7ece963d34d2d388d99bf0559 -->
<!-- pgdoc-cn_start sig_en=bea8643587326572b0c5b287c45cc027 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>day of year (001&ndash;366)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>一年中的日(001&ndash;366)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=bea8643587326572b0c5b287c45cc027 -->
<!-- pgdoc-cn_start sig_en=99f3cec665c0334e77683f65d0275c74 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>day of ISO 8601 week-numbering year (001&ndash;371; day 1 of the year is Monday of the first ISO week)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>ISO 8601 周编号方式的年中的日 （001&ndash;371; 年的第 1 日时第一个 ISO 周的周一）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=99f3cec665c0334e77683f65d0275c74 -->
<!-- pgdoc-cn_start sig_en=efebee8a830dd5fd061a1d6333d2f91b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>DD</literal></entry>
        <entry>day of month (01&ndash;31)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>DD</literal></entry>
        <entry>月中的日 (01&ndash;31)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=efebee8a830dd5fd061a1d6333d2f91b -->
<!-- pgdoc-cn_start sig_en=5f1d5e45d532e1b176115c5d8b0f9f56 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>D</literal></entry>
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>周中的日，周日 (<literal>1</literal>) 到周六 (<literal>7</literal>)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5f1d5e45d532e1b176115c5d8b0f9f56 -->
<!-- pgdoc-cn_start sig_en=170b7dfc3cb294334f50b741921e5cd4 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>ID</literal></entry>
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>ID</literal></entry>
        <entry>周中的 ISO 8601 日，周一 (<literal>1</literal>) 到周日 (<literal>7</literal>)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=170b7dfc3cb294334f50b741921e5cd4 -->
<!-- pgdoc-cn_start sig_en=deb2d7527148300e8052a519e9a8636a sig_cn_org=None source=14.1 
       <row>
        <entry><literal>W</literal></entry>
        <entry>week of month (1&ndash;5) (the first week starts on the first day of the month)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>W</literal></entry>
        <entry>月中的周 (1&ndash;5) （第一周从该月的第一天开始）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=deb2d7527148300e8052a519e9a8636a -->
<!-- pgdoc-cn_start sig_en=97dba732bf920efce2330de8e40964a9 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>WW</literal></entry>
        <entry>week number of year (1&ndash;53) (the first week starts on the first day of the year)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>WW</literal></entry>
        <entry>年中的周数 (1&ndash;53) （第一周从该年的第一天开始）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=97dba732bf920efce2330de8e40964a9 -->
<!-- pgdoc-cn_start sig_en=e492d1cf87fd3145d2f402c1ba40543c sig_cn_org=None source=14.1 
       <row>
        <entry><literal>IW</literal></entry>
        <entry>week number of ISO 8601 week-numbering year (01&ndash;53; the first Thursday of the year is in week 1)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>IW</literal></entry>
        <entry>ISO 8601 周编号方式的年中的周数 (01&ndash;53; 新的一年的第一个周四在第一周)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e492d1cf87fd3145d2f402c1ba40543c -->
<!-- pgdoc-cn_start sig_en=053e7f3573a42bcfee9bad2cc49f2856 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>CC</literal></entry>
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>CC</literal></entry>
        <entry>世纪（2 位数）（21 世纪开始于 2001-01-01）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=053e7f3573a42bcfee9bad2cc49f2856 -->
<!-- pgdoc-cn_start sig_en=8d89e71b306a6f31ce994e7e870f698a sig_cn_org=None source=14.1 
       <row>
        <entry><literal>J</literal></entry>
        <entry>Julian Date (integer days since November 24, 4714 BC at local
        midnight; see <xref linkend="datetime-julian-dates"/>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>J</literal></entry>
        <entry>儒略日期（从本地午夜的公元前 4714 年 11 月 24 日开始的整数日数；参见 <xref linkend="datetime-julian-dates"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8d89e71b306a6f31ce994e7e870f698a -->
<!-- pgdoc-cn_start sig_en=4258ad8dd3a26b4a4e7d8f7c931b7ac0 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>Q</literal></entry>
        <entry>quarter</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>Q</literal></entry>
        <entry>季度</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4258ad8dd3a26b4a4e7d8f7c931b7ac0 -->
<!-- pgdoc-cn_start sig_en=3e4e97bfbb4a17fb845869e3dc7063db sig_cn_org=None source=14.1 
       <row>
        <entry><literal>RM</literal></entry>
        <entry>month in upper case Roman numerals (I&ndash;XII; I=January)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>RM</literal></entry>
        <entry>大写形式的罗马计数法的月 (I&ndash;XII; I=一月)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=3e4e97bfbb4a17fb845869e3dc7063db -->
<!-- pgdoc-cn_start sig_en=844a07c15f624c4a99ffc9e24d83de3d sig_cn_org=None source=14.1 
       <row>
        <entry><literal>rm</literal></entry>
        <entry>month in lower case Roman numerals (i&ndash;xii; i=January)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>rm</literal></entry>
        <entry>小写形式的罗马计数法的月 (i&ndash;xii; i=一月)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=844a07c15f624c4a99ffc9e24d83de3d -->
<!-- pgdoc-cn_start sig_en=de32660ced11aa6c4ca6ef5c8968a97b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>大写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=de32660ced11aa6c4ca6ef5c8968a97b -->
<!-- pgdoc-cn_start sig_en=91e489f4cdce38d7c09b6e820f9adad1 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>tz</literal></entry>
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>tz</literal></entry>
        <entry>小写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=91e489f4cdce38d7c09b6e820f9adad1 -->
<!-- pgdoc-cn_start sig_en=1905bb83f45a57db3a9c0640ccfd360c sig_cn_org=None source=14.1 
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>time-zone hours</entry>
       </row>
________________________________________________________-->
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>时区的小时</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1905bb83f45a57db3a9c0640ccfd360c -->
<!-- pgdoc-cn_start sig_en=8571d9c74e643c63f7933666746d52b7 sig_cn_org=None source=14.1 
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>time-zone minutes</entry>
       </row>
________________________________________________________-->
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>时区的分钟</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8571d9c74e643c63f7933666746d52b7 -->
<!-- pgdoc-cn_start sig_en=e2bb95389d8a76728be7dabee90acd56 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>OF</literal></entry>
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>OF</literal></entry>
        <entry>从UTC开始的时区偏移（仅在<function>to_char</function>中支持）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e2bb95389d8a76728be7dabee90acd56 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=ffaaf85e105e3594cbb4856116fe387d sig_cn_org=None source=14.1 
   <para>
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
   </para>
________________________________________________________-->
   <para>
    修饰语可以被应用于模板模式来修改它们的行为。例如，<literal>FMMonth</literal>就是带着<literal>FM</literal>修饰语的<literal>Month</literal>模式。<xref linkend="functions-formatting-datetimemod-table"/>展示了可用于日期/时间格式化的修饰语模式。
   </para>
<!-- pgdoc-cn_end sig_en=ffaaf85e105e3594cbb4856116fe387d -->

    <table id="functions-formatting-datetimemod-table">
<!-- pgdoc-cn_start sig_en=86ecec68f1f50fc40090f31c8d815aa6 sig_cn_org=None source=14.1 
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
________________________________________________________-->
     <title>用于日期/时间格式化的模板模式修饰语</title>
<!-- pgdoc-cn_end sig_en=86ecec68f1f50fc40090f31c8d815aa6 -->
     <tgroup cols="3">
      <thead>
<!-- pgdoc-cn_start sig_en=31542fabbf45bca4174a4411ff6a9439 sig_cn_org=None source=14.1 
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
<!-- pgdoc-cn_end sig_en=31542fabbf45bca4174a4411ff6a9439 -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=4f7fb998aa4fa4e31c23bcf20a645fbd sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制前导零和填充的空格）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=4f7fb998aa4fa4e31c23bcf20a645fbd -->
<!-- pgdoc-cn_start sig_en=29b24bc84962a5aa51cb142bebd0bfc5 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写形式的序数后缀</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=29b24bc84962a5aa51cb142bebd0bfc5 -->
<!-- pgdoc-cn_start sig_en=3d2181884ef7af0af59233ed518b4a25 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写形式的序数后缀</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3d2181884ef7af0af59233ed518b4a25 -->
<!-- pgdoc-cn_start sig_en=97d8dc15881bfbe350f18253af111a7f sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>fixed format global option (see usage notes)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>固定的格式化全局选项（见使用须知）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=97d8dc15881bfbe350f18253af111a7f -->
<!-- pgdoc-cn_start sig_en=4f61821fac8f27aa3b10532e38756735 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>translation mode (use localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>翻译模式（基于<xref linkend="guc-lc-time"/>使用本地化的日和月名）</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=4f61821fac8f27aa3b10532e38756735 -->
<!-- pgdoc-cn_start sig_en=3c3c5402c23c75b43252912d415b9054 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>spell mode (not implemented)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>拼写模式（未实现）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3c3c5402c23c75b43252912d415b9054 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=f0bffb8db041574b2845499c711cf3b0 sig_cn_org=3b97917685d728b9f312c7de173e2b7d source=15.7 
   <para>
    Usage notes for date/time formatting:

    <itemizedlist>
     <listitem>
________________________________________________________-->
   <para>
   日期/时间格式化的使用注意事项：

    <itemizedlist>
     <listitem>
<!-- pgdoc-cn_end sig_en=f0bffb8db041574b2845499c711cf3b0 -->
<!-- pgdoc-cn_start sig_en=0127084d1eaddb14689ffcded0ac13cd sig_cn_org=8e1ad096aa8368f11efe8e5dea73485c source=15.7 
      <para>
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
      </para>
________________________________________________________-->
      <para>
       <literal>FM</literal>抑制了在模式输出中添加前导零和尾随空格的行为，这些前导零和尾随空格
       本来会被添加以使输出成为固定宽度。在<productname>PostgreSQL</productname>中，
       <literal>FM</literal>仅修改下一个规范，而在Oracle中<literal>FM</literal>影响所有后续
       规范，并且重复的<literal>FM</literal>修饰符切换填充模式的开启和关闭。
      </para>
<!-- pgdoc-cn_end sig_en=0127084d1eaddb14689ffcded0ac13cd -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=5afe40b8990a07a422b944583af783ed sig_cn_org=8074d696d80ccb8ce92071676916915b source=15.7 
      <para>
       <literal>TM</literal> suppresses trailing blanks whether or
       not <literal>FM</literal> is specified.
      </para>
________________________________________________________-->
      <para>
       <literal>TM</literal>抑制尾随空格，无论是否指定<literal>FM</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=5afe40b8990a07a422b944583af783ed -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=a849db79090120be8a856f68398dd358 sig_cn_org=cfdb0cbfd59bb8396245ba5062577ba4 source=15.7 
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       ignore letter case in the input; so for
       example <literal>MON</literal>, <literal>Mon</literal>,
       and <literal>mon</literal> all accept the same strings.  When using
       the <literal>TM</literal> modifier, case-folding is done according to
       the rules of the function's input collation (see
       <xref linkend="collation"/>).
      </para>
________________________________________________________-->
      <para>
       <function>to_timestamp</function>和<function>to_date</function>在输入中忽略大小写；
	   因此，例如<literal>MON</literal>，<literal>Mon</literal>和<literal>mon</literal>都接受相同的字符串。
	   当使用<literal>TM</literal>修饰符时，根据函数输入排序规则执行大小写折叠（参见<xref linkend="collation"/>）。
      </para>
<!-- pgdoc-cn_end sig_en=a849db79090120be8a856f68398dd358 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=e6a1c1131659978d12a9f0d8c8913522 sig_cn_org=4c73e423263c075649326b2ca1667d09 source=15.7 
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
      </para>
________________________________________________________-->
      <para>
       <function>to_timestamp</function>和<function>to_date</function>
       跳过输入字符串开头和日期时间值周围的多个空格，除非使用<literal>FX</literal>选项。例如，
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>和
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal>是有效的，但是
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal>会返回错误，
       因为<function>to_timestamp</function>只接受单个空格。
       <literal>FX</literal>必须作为模板中的第一项指定。
      </para>
<!-- pgdoc-cn_end sig_en=e6a1c1131659978d12a9f0d8c8913522 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=b15c8c29bc519daa41424ab8a50d088f sig_cn_org=311a9296ba02ec04fe04ca80b9861409 source=15.7 
      <para>
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>的模板字符串中，
       分隔符（空格或非字母/非数字字符）匹配输入字符串中的任何单个分隔符，或被跳过，
       除非使用<literal>FX</literal>选项。
       例如，<literal>to_timestamp('2000JUN', 'YYYY///MON')</literal>和
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal>可以工作，
       但<literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>会返回错误，
       因为输入字符串中的分隔符数量超过了模板中的分隔符数量。
      </para>
<!-- pgdoc-cn_end sig_en=b15c8c29bc519daa41424ab8a50d088f -->
<!-- pgdoc-cn_start sig_en=fe0c18b8bdcddbf82d9c3245bce5595f sig_cn_org=cc0a9555c276beeea7e8de17d5ff9743 source=15.7 
      <para>
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
      </para>
________________________________________________________-->
      <para>
       如果指定了<literal>FX</literal>，模板字符串中的分隔符将精确匹配输入字符串中的一个字符。
       但请注意，输入字符串的字符不一定与模板字符串中的分隔符相同。
       例如，<literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>可以工作，
       但<literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>会返回错误，
       因为模板字符串中的第二个空格会消耗输入字符串中的字母<literal>J</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=fe0c18b8bdcddbf82d9c3245bce5595f -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=175ea5821f7947e5b78753aeb8168378 sig_cn_org=326c75860509249e7b9817f4d52eb01a source=15.7 
      <para>
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
      </para>
________________________________________________________-->
      <para>
       一个<literal>TZH</literal>模板模式可以匹配有符号数。
       没有<literal>FX</literal>选项，减号可能会有歧义，并且可能被解释为分隔符。
       此歧义解决如下：如果模板字符串中<literal>TZH</literal>之前的分隔符数量少于输入字符串中减号之前的分隔符数量，
       则减号被解释为<literal>TZH</literal>的一部分。
       否则，减号被视为值之间的分隔符。
       例如，<literal>to_timestamp('2000 -10', 'YYYY TZH')</literal>匹配
       <literal>-10</literal>到<literal>TZH</literal>，但
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       匹配<literal>10</literal>到<literal>TZH</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=175ea5821f7947e5b78753aeb8168378 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=74a7cc08aaeaa12f4521966a9964686d sig_cn_org=84fe235ada8f9da811bdebc39cdf362d source=15.7 
      <para>
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
      </para>
________________________________________________________-->
      <para>
       普通文本允许在<function>to_char</function>模板中，并且将被直接输出。您可以将子字符串放在双引号中，
       以强制将其解释为文字文本，即使它包含模板模式。例如，在<literal>'"Hello Year "YYYY'</literal>中，
       <literal>YYYY</literal>将被年份数据替换，但<literal>Year</literal>中的单个<literal>Y</literal>不会被替换。
       在<function>to_date</function>，<function>to_number</function>和<function>to_timestamp</function>中，
       文本和双引号字符串会导致跳过字符串中包含的字符数；例如<literal>"XX"</literal>跳过两个输入字符
       （无论它们是否为<literal>XX</literal>）。
      </para>
<!-- pgdoc-cn_end sig_en=74a7cc08aaeaa12f4521966a9964686d -->
      <tip>
<!-- pgdoc-cn_start sig_en=19c32b18fe2176625b4906d7f7a6ef49 sig_cn_org=0d872dde29b3bf2d5641cc5d56194a5c source=15.7 
        <para>
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
        </para>
________________________________________________________-->
        <para>
          在<productname>PostgreSQL</productname> 12之前，可以使用非字母或非数字字符跳过输入字符串中的任意文本。例如，
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal>曾经有效。现在，您只能使用字母字符来实现这一目的。例如，
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal>和
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          跳过了<literal>y</literal>，<literal>m</literal>和<literal>d</literal>。
        </para>
<!-- pgdoc-cn_end sig_en=19c32b18fe2176625b4906d7f7a6ef49 -->
      </tip>
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=e881b4cdf8a2b5ff937a8a1ffe626d06 sig_cn_org=6d52a2727906d163f7a996f47346ee2d source=15.7 
      <para>
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!-&minus; "" font-lock sanity :-) -&minus;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
      </para>
________________________________________________________-->
      <para>
       如果您想在输出中使用双引号，必须在其前面加上反斜杠，例如<literal>'\"YYYY
       Month\"'</literal>。 <!-- "" font-lock sanity :-) -->
       反斜杠在双引号之外不起特殊作用。在双引号字符串内部，反斜杠会使下一个字符被直接解释，无论是什么（但除非下一个字符是双引号或另一个反斜杠，否则没有特殊效果）。
      </para>
<!-- pgdoc-cn_end sig_en=e881b4cdf8a2b5ff937a8a1ffe626d06 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=f4d70c2c7eb12fa4de6f39c303ff22e6 sig_cn_org=4fbcdf68002cffe85842f3da49681aab source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.,
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.,
       <literal>95</literal> becomes 1995.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       如果年份格式规范少于四位数字，例如<literal>YYY</literal>，并且提供的年份少于四位数字，
       年份将被调整为最接近2020年的年份，例如<literal>95</literal>变为1995年。
      </para>
<!-- pgdoc-cn_end sig_en=f4d70c2c7eb12fa4de6f39c303ff22e6 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=4dea3b04eef05e9226dcd1399dadd44b sig_cn_org=2a6ee845b6b3ceef71f885619146d511 source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       negative years are treated as signifying BC.  If you write both a
       negative year and an explicit <literal>BC</literal> field, you get AD
       again.  An input of year zero is treated as 1 BC.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       负年份被视为BC纪元。如果同时写入负年份和显式的<literal>BC</literal>字段，
       则再次得到AD。年份零被视为公元前1年。
      </para>
<!-- pgdoc-cn_end sig_en=4dea3b04eef05e9226dcd1399dadd44b -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=ef0ce6befa504af50ca237f7b7cefab6 sig_cn_org=f94cc13ceb9509f7ae5daeb5f5bdc852 source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001130', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1130', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov30', 'YYYYMonDD')</literal>.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       <literal>YYYY</literal>转换在处理超过4位数字的年份时有限制。您必须在<literal>YYYY</literal>后使用一些非数字字符或模板，
       否则年份总是被解释为4位数字。例如（使用年份20000）：
       <literal>to_date('200001130', 'YYYYMMDD')</literal>将被解释为4位年份；而应该在年份后使用非数字分隔符，如
       <literal>to_date('20000-1130', 'YYYY-MMDD')</literal>或
       <literal>to_date('20000Nov30', 'YYYYMonDD')</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=ef0ce6befa504af50ca237f7b7cefab6 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=79ca0f77afccabcb9ae4c2128f2001a6 sig_cn_org=2bc97ecac9fbd1a46527b3e5e852fddf source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       如果存在<literal>YYY</literal>、<literal>YYYY</literal>或<literal>Y,YYY</literal>字段，
       则会接受但忽略<literal>CC</literal>（世纪）字段。如果<literal>CC</literal>与
       <literal>YY</literal>或<literal>Y</literal>一起使用，则结果将计算为指定世纪中的那一年。
       如果指定了世纪但未指定年份，则假定为该世纪的第一年。
      </para>
<!-- pgdoc-cn_end sig_en=79ca0f77afccabcb9ae4c2128f2001a6 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=d9c984a30d073e8eed6afc3cfee1d0fb sig_cn_org=01aee9a9ad1616fb2ee32552ef05c176 source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       星期几的名称或数字（<literal>DAY</literal>，<literal>D</literal>，
       以及相关字段类型）是被接受的，但在计算结果时会被忽略。同样适用于季度
       （<literal>Q</literal>）字段。
      </para>
<!-- pgdoc-cn_end sig_en=d9c984a30d073e8eed6afc3cfee1d0fb -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=cfb0757a024de2d404d6a1e61ea943ee sig_cn_org=cca3fdf85298ed7aedaf099bdf13b09c source=15.7 
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
       <itemizedlist>
        <listitem>
         <para>
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
         </para>
        </listitem>
        <listitem>
         <para>
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
         </para>
        </listitem>
       </itemizedlist>
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，
       ISO 8601周编号日期（与公历日期不同）可以通过两种方式之一指定：
       <itemizedlist>
        <listitem>
         <para>
          年份、周数和星期几：例如<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          返回日期<literal>2006-10-19</literal>。
          如果省略星期几，则假定为1（星期一）。
         </para>
        </listitem>
        <listitem>
         <para>
          年份和年内天数：例如<literal>to_date('2006-291', 'IYYY-IDDD')</literal>也返回<literal>2006-10-19</literal>。
         </para>
        </listitem>
       </itemizedlist>
      </para>
<!-- pgdoc-cn_end sig_en=cfb0757a024de2d404d6a1e61ea943ee -->
<!-- pgdoc-cn_start sig_en=db7afb0d092209b519e930874078e50c sig_cn_org=92f477987bc6270265037fa119f64bb1 source=15.7 
      <para>
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
      </para>
________________________________________________________-->
      <para>
       尝试使用ISO 8601周编号字段和公历日期字段的混合输入日期是荒谬的，并将导致错误。
       在ISO 8601周编号年的背景下，<quote>月份</quote>或<quote>日期</quote>的概念没有意义。
       在公历年的背景下，ISO周没有意义。
      </para>
<!-- pgdoc-cn_end sig_en=db7afb0d092209b519e930874078e50c -->
      <caution>
<!-- pgdoc-cn_start sig_en=b9429897203346dc0c612c637a0071c3 sig_cn_org=e887a463a631356d6f55b1c0bda294dc source=15.7 
       <para>
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
       </para>
________________________________________________________-->
       <para>
        当<function>to_date</function>拒绝混合使用公历和ISO周编号日期字段时，
        <function>to_char</function>不会，因为输出格式规范如<literal>YYYY-MM-DD (IYYY-IDDD)</literal>可能很有用。
        但要避免编写类似<literal>IYYY-MM-DD</literal>的内容；那会在年初附近产生令人惊讶的结果。
        （有关更多信息，请参见<xref linkend="functions-datetime-extract"/>。）
       </para>
<!-- pgdoc-cn_end sig_en=b9429897203346dc0c612c637a0071c3 -->
      </caution>
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=accb2af7652209691604cd504ed427fd sig_cn_org=77c21947a43b9f6e33e2c6b7d36a8b33 source=15.7 
      <para>
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
      </para>
________________________________________________________-->
      <para>
       在<function>to_timestamp</function>函数中，毫秒（<literal>MS</literal>）或微秒（<literal>US</literal>）字段被用作小数点后的秒数位。
       例如<literal>to_timestamp('12.3', 'SS.MS')</literal>不是3毫秒，而是300，因为转换将其视为12 + 0.3秒。
       因此，对于格式<literal>SS.MS</literal>，输入值<literal>12.3</literal>、<literal>12.30</literal>和<literal>12.300</literal>指定相同数量的毫秒。
       要获得三毫秒，必须写成<literal>12.003</literal>，转换将其视为12 + 0.003 = 12.003秒。
      </para>
<!-- pgdoc-cn_end sig_en=accb2af7652209691604cd504ed427fd -->

<!-- pgdoc-cn_start sig_en=e9650dc104457e6e472e5c7122c5c79a sig_cn_org=576a771d8cf44245a649d342c2e300a3 source=15.7 
      <para>
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
      </para>
________________________________________________________-->
      <para>
       这是一个更复杂的例子：
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       是15小时，12分钟和2秒 + 20毫秒 + 1230微秒 = 2.021230秒。
      </para>
<!-- pgdoc-cn_end sig_en=e9650dc104457e6e472e5c7122c5c79a -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=7de466385fc6ec9bcdc3384d2d88d989 sig_cn_org=c95bca892c9c99bc38257f2b8ee81d8c source=15.7 
      <para>
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
      </para>
________________________________________________________-->
      <para>
        <function>to_char(..., 'ID')</function>的星期几编号与<function>extract(isodow from ...)</function>函数匹配，
        但<function>to_char(..., 'D')</function>的不匹配<function>extract(dow from ...)</function>的星期编号。
      </para>
<!-- pgdoc-cn_end sig_en=7de466385fc6ec9bcdc3384d2d88d989 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=b0641dbafdcfd3496920341355c4d924 sig_cn_org=f24649db20387627a632bccf7d6c7565 source=15.7 
      <para>
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
      </para>
________________________________________________________-->
      <para>
        <function>to_char(interval)</function> 格式化<literal>HH</literal>和<literal>HH12</literal>，
        如在12小时制时钟上显示，例如零小时和36小时都输出为<literal>12</literal>，
        而<literal>HH24</literal>输出完整的小时值，在<type>interval</type>值中可以超过23。
      </para>
<!-- pgdoc-cn_end sig_en=b0641dbafdcfd3496920341355c4d924 -->
     </listitem>

    </itemizedlist>
   </para>

<!-- pgdoc-cn_start sig_en=87e204a29b0eb7cfe120b09556ce3bfc sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-numeric-table"/>展示了可以用于格式化数字值的模版模式。
  </para>
<!-- pgdoc-cn_end sig_en=87e204a29b0eb7cfe120b09556ce3bfc -->

    <table id="functions-formatting-numeric-table">
<!-- pgdoc-cn_start sig_en=3051c1cc3108e99837aa9f4547036970 sig_cn_org=None source=14.1 
     <title>Template Patterns for Numeric Formatting</title>
________________________________________________________-->
     <title>用于数字格式化的模板模式</title>
<!-- pgdoc-cn_end sig_en=3051c1cc3108e99837aa9f4547036970 -->
     <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=ac864b532e87ccc34292f8be1f7eeb5e sig_cn_org=None source=14.1 
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ac864b532e87ccc34292f8be1f7eeb5e -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=02cfdd8517be854da247237d9a175de8 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>9</literal></entry>
        <entry>digit position (can be dropped if insignificant)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>9</literal></entry>
        <entry>数位（如果无意义可以被删除）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=02cfdd8517be854da247237d9a175de8 -->
<!-- pgdoc-cn_start sig_en=5a94e056ce70cac0b8c20976ccf51d5f sig_cn_org=None source=14.1 
       <row>
        <entry><literal>0</literal></entry>
        <entry>digit position (will not be dropped, even if insignificant)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>0</literal></entry>
        <entry>数位（即便没有意义也不会被删除）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5a94e056ce70cac0b8c20976ccf51d5f -->
<!-- pgdoc-cn_start sig_en=b314f54b01eabe4d3cffbc2ed926bfbf sig_cn_org=None source=14.1 
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>小数点</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b314f54b01eabe4d3cffbc2ed926bfbf -->
<!-- pgdoc-cn_start sig_en=8ae960ea6f5d51b2b98bbc59ae33797b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>分组（千）分隔符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8ae960ea6f5d51b2b98bbc59ae33797b -->
<!-- pgdoc-cn_start sig_en=9d0213a4075c998241303ce4da70c0b4 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>PR</literal></entry>
        <entry>negative value in angle brackets</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>PR</literal></entry>
        <entry>尖括号内的负值</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9d0213a4075c998241303ce4da70c0b4 -->
<!-- pgdoc-cn_start sig_en=8efe3365a6585d117bf6d1bb84454355 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>S</literal></entry>
        <entry>sign anchored to number (uses locale)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>S</literal></entry>
        <entry>带符号的数字（使用区域）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8efe3365a6585d117bf6d1bb84454355 -->
<!-- pgdoc-cn_start sig_en=1fc34747ac7910ca737f73cc3a5fe3c3 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>L</literal></entry>
        <entry>currency symbol (uses locale)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>L</literal></entry>
        <entry>货币符号（使用区域）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1fc34747ac7910ca737f73cc3a5fe3c3 -->
<!-- pgdoc-cn_start sig_en=5dc422b6822dfed56dd8a5be9665e920 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>D</literal></entry>
        <entry>decimal point (uses locale)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>小数点（使用区域）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5dc422b6822dfed56dd8a5be9665e920 -->
<!-- pgdoc-cn_start sig_en=56b5adfbd69e0fe8d357e9e7a256edd9 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>G</literal></entry>
        <entry>group separator (uses locale)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>G</literal></entry>
        <entry>分组分隔符（使用区域）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=56b5adfbd69e0fe8d357e9e7a256edd9 -->
<!-- pgdoc-cn_start sig_en=861052c8b7e2ace9fcf50e39f775012e sig_cn_org=None source=14.1 
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minus sign in specified position (if number &lt; 0)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>在指定位置的负号（如果数字 &lt; 0）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=861052c8b7e2ace9fcf50e39f775012e -->
<!-- pgdoc-cn_start sig_en=89d4c163792f17210cd6f90405469f42 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>PL</literal></entry>
        <entry>plus sign in specified position (if number &gt; 0)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>PL</literal></entry>
        <entry>在指定位置的正号（如果数字 &gt; 0）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=89d4c163792f17210cd6f90405469f42 -->
<!-- pgdoc-cn_start sig_en=e7bece92bf0355f1be480f13dab336e1 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SG</literal></entry>
        <entry>plus/minus sign in specified position</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SG</literal></entry>
        <entry>在指定位置的正/负号</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e7bece92bf0355f1be480f13dab336e1 -->
<!-- pgdoc-cn_start sig_en=84d7f2d8a85ee3a985fa976428f1c82a sig_cn_org=None source=14.1 
       <row>
        <entry><literal>RN</literal></entry>
        <entry>Roman numeral (input between 1 and 3999)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>RN</literal></entry>
        <entry>罗马数字（输入在 1 和 3999 之间）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=84d7f2d8a85ee3a985fa976428f1c82a -->
<!-- pgdoc-cn_start sig_en=c89e13fa3d918174e027b93eada2944b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>序数后缀</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c89e13fa3d918174e027b93eada2944b -->
<!-- pgdoc-cn_start sig_en=865e4f6b16def10fa0ea9cd392cf5786 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>V</literal></entry>
        <entry>shift specified number of digits (see notes)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>V</literal></entry>
        <entry>移动指定位数（参阅注解）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=865e4f6b16def10fa0ea9cd392cf5786 -->
<!-- pgdoc-cn_start sig_en=2257ed3f870e0d6666650a664c56e5ae sig_cn_org=None source=14.1 
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>exponent for scientific notation</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>科学记数的指数</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2257ed3f870e0d6666650a664c56e5ae -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=35adae613b56fdc525d1b871fdb1cb5a sig_cn_org=a3c3099b8fc278e8a24a1895923629ea source=15.7 
   <para>
    Usage notes for numeric formatting:

    <itemizedlist>
     <listitem>
________________________________________________________-->
   <para>
   数字格式化的使用注意事项：

    <itemizedlist>
     <listitem>
<!-- pgdoc-cn_end sig_en=35adae613b56fdc525d1b871fdb1cb5a -->
<!-- pgdoc-cn_start sig_en=5e73de851b1f661a25f6fc9626b50ddd sig_cn_org=316727c16b031bedef57a12a67ec88d2 source=15.7 
      <para>
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
      </para>
________________________________________________________-->
      <para>
       <literal>0</literal>指定一个数字位置，即使它包含前导/尾随零，也将始终打印出来。
       <literal>9</literal>也指定一个数字位置，但如果它是一个前导零，则将被替换为一个空格，
       而如果它是一个尾随零并且指定了填充模式，则将被删除。
       （对于<function>to_number()</function>，这两个模式字符是等效的。）
      </para>
<!-- pgdoc-cn_end sig_en=5e73de851b1f661a25f6fc9626b50ddd -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=5196595a250b705fa3ab73196e7590c1 sig_cn_org=573a70901cc45bf27df0d2661d4e455a source=15.7 
      <para>
       If the format provides fewer fractional digits than the number being
       formatted, <function>to_char()</function> will round the number to
       the specified number of fractional digits.
      </para>
________________________________________________________-->
      <para>
       如果格式提供的小数位数少于被格式化的数字，则<function>to_char()</function>将会将数字四舍五入到指定的小数位数。
      </para>
<!-- pgdoc-cn_end sig_en=5196595a250b705fa3ab73196e7590c1 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=6bb1411c8aca608aa54ffc80dc3aa500 sig_cn_org=b5474bd2d64bac7d6feaa0d4260f97f8 source=15.7 
      <para>
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
      </para>
________________________________________________________-->
      <para>
       模式字符<literal>S</literal>、<literal>L</literal>、<literal>D</literal>和<literal>G</literal>表示当前区域设置定义的符号、货币符号、小数点和千位分隔符字符
       (参见<xref linkend="guc-lc-monetary"/>
       和<xref linkend="guc-lc-numeric"/>)。模式字符句点和逗号表示这些确切字符，具有小数点和千位分隔符的含义，不受区域设置影响。
      </para>
<!-- pgdoc-cn_end sig_en=6bb1411c8aca608aa54ffc80dc3aa500 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=75f8963cea2820077f503f0795469715 sig_cn_org=fdb164a5e97bb7da2c01cc5b804f4962 source=15.7 
      <para>
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
      </para>
________________________________________________________-->
      <para>
       如果在<function>to_char()</function>的模式中没有明确指定符号，将为符号保留一列，并将其锚定到（出现在）数字的左侧。
	   如果<literal>S</literal>出现在一些<literal>9</literal>的左侧，它也将锚定到数字。
      </para>
<!-- pgdoc-cn_end sig_en=75f8963cea2820077f503f0795469715 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=cada50034dda6e06075dc9d7587c5d73 sig_cn_org=f17f6ef6e373ffeaa7fc6c4afcba20c2 source=15.7 
      <para>
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
      </para>
________________________________________________________-->
      <para>
       使用<literal>SG</literal>、<literal>PL</literal>或<literal>MI</literal>格式化的符号不与数字绑定；
       例如，<literal>to_char(-12, 'MI9999')</literal>会产生<literal>'-&nbsp;&nbsp;12'</literal>，
       但<literal>to_char(-12, 'S9999')</literal>会产生<literal>'&nbsp;&nbsp;-12'</literal>。
       （Oracle实现不允许在<literal>9</literal>之前使用<literal>MI</literal>，而是要求<literal>9</literal>在<literal>MI</literal>之前。）
      </para>
<!-- pgdoc-cn_end sig_en=cada50034dda6e06075dc9d7587c5d73 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=b97a3240ece8b85ddaeb4f7ccce61527 sig_cn_org=f54e14c7e69a3a5e994298957db2ca3c source=15.7 
      <para>
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
      </para>
________________________________________________________-->
      <para>
       <literal>TH</literal>不会转换小于零的值，也不会转换小数。
      </para>
<!-- pgdoc-cn_end sig_en=b97a3240ece8b85ddaeb4f7ccce61527 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=e896c344e73320dc3b50a9b7359cb98f sig_cn_org=6b9aef951313b37a16566b46b5e9e7f4 source=15.7 
      <para>
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
      </para>
________________________________________________________-->
      <para>
       <literal>PL</literal>，<literal>SG</literal>和
       <literal>TH</literal>是<productname>PostgreSQL</productname>
       的扩展。
      </para>
<!-- pgdoc-cn_end sig_en=e896c344e73320dc3b50a9b7359cb98f -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=48e01ad78c263d44f568a6fe8813a609 sig_cn_org=711e98314614153918894d27e6320a7e source=15.7 
      <para>
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
      </para>
________________________________________________________-->
      <para>
       在<function>to_number</function>函数中，如果使用非数据模板模式，如<literal>L</literal>或<literal>TH</literal>，
	   则会跳过相应数量的输入字符，无论它们是否与模板模式匹配，除非它们是数据字符（即数字、符号、小数点或逗号）。
	   例如，<literal>TH</literal>会跳过两个非数据字符。
      </para>
<!-- pgdoc-cn_end sig_en=48e01ad78c263d44f568a6fe8813a609 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=9b576a7cb70aba60036f46452342ec9c sig_cn_org=e5ca1d7c1de6b72fe3aae4bc70743607 source=15.7 
      <para>
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
      </para>
________________________________________________________-->
      <para>
       <literal>V</literal>与<function>to_char</function>一起，
       将输入值乘以<literal>10^<replaceable>n</replaceable></literal>，
       其中<replaceable>n</replaceable>是跟在<literal>V</literal>后面的数字位数。
       <literal>V</literal>与<function>to_number</function>一起以类似的方式除法。
       <function>to_char</function>和<function>to_number</function>不支持与小数点结合使用的<literal>V</literal>
       （例如，不允许使用<literal>99.9V99</literal>）。
</para>
<!-- pgdoc-cn_end sig_en=9b576a7cb70aba60036f46452342ec9c -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=2c7347d2124c7acb43985b4347fe969d sig_cn_org=2c7fd31ed95e167dfe3e2db148fb0572 source=15.7 
      <para>
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
      </para>
________________________________________________________-->
      <para>
       <literal>EEEE</literal>（科学计数法）不能与任何其他格式模式或修饰符结合使用，除了数字和小数点模式之外，必须位于格式字符串的末尾（例如，<literal>9.99EEEE</literal>是一个有效模式）。
      </para>
<!-- pgdoc-cn_end sig_en=2c7347d2124c7acb43985b4347fe969d -->
     </listitem>
    </itemizedlist>
   </para>

<!-- pgdoc-cn_start sig_en=dbbaafe30d36ea5e4304e0c12825b023 sig_cn_org=None source=14.1 
   <para>
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
   </para>
________________________________________________________-->
   <para>
    某些修饰语可以被应用到任何模板来改变其行为。例如，<literal>FM99.99</literal>是带有<literal>FM</literal>修饰语的<literal>99.99</literal>模式。<xref linkend="functions-formatting-numericmod-table"/>中展示了用于数字格式化模式修饰语。
   </para>
<!-- pgdoc-cn_end sig_en=dbbaafe30d36ea5e4304e0c12825b023 -->

    <table id="functions-formatting-numericmod-table">
<!-- pgdoc-cn_start sig_en=38e4ac948aaef2771a373f1df815c896 sig_cn_org=None source=14.1 
     <title>Template Pattern Modifiers for Numeric Formatting</title>
________________________________________________________-->
     <title>用于数字格式化的模板模式修饰语</title>
<!-- pgdoc-cn_end sig_en=38e4ac948aaef2771a373f1df815c896 -->
     <tgroup cols="3">
      <thead>
<!-- pgdoc-cn_start sig_en=31542fabbf45bca4174a4411ff6a9439 sig_cn_org=None source=14.1 
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
<!-- pgdoc-cn_end sig_en=31542fabbf45bca4174a4411ff6a9439 -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=ad5a20415f2b19b8f339ffb55b48d25b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制拖尾零和填充的空白）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=ad5a20415f2b19b8f339ffb55b48d25b -->
<!-- pgdoc-cn_start sig_en=62f6b643f2c407fc1babb025c42b8324 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>999TH</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写序数后缀</entry>
        <entry><literal>999TH</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=62f6b643f2c407fc1babb025c42b8324 -->
<!-- pgdoc-cn_start sig_en=012a82aa9a8a937be908cd98247c8aa9 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>999th</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写序数后缀</entry>
        <entry><literal>999th</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=012a82aa9a8a937be908cd98247c8aa9 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=10dd326acc3d55b327653c5decb10c23 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-examples-table"/>展示了一些使用<function>to_char</function>函数的例子。
  </para>
<!-- pgdoc-cn_end sig_en=10dd326acc3d55b327653c5decb10c23 -->

    <table id="functions-formatting-examples-table">
<!-- pgdoc-cn_start sig_en=194c73f81133974fe2180e721619a909 sig_cn_org=None source=14.1 
     <title><function>to_char</function> Examples</title>
________________________________________________________-->
     <title><function>to_char</function>例子</title>
<!-- pgdoc-cn_end sig_en=194c73f81133974fe2180e721619a909 -->
     <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=235901669821fb79cc027ac4c0ab362c sig_cn_org=None source=14.1 
       <row>
        <entry>Expression</entry>
        <entry>Result</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>表达式</entry>
        <entry>结果</entry>
       </row>
<!-- pgdoc-cn_end sig_en=235901669821fb79cc027ac4c0ab362c -->
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!-- pgdoc-cn_start sig_en=96f69ebb86b105b1971b0efd260321cd sig_cn_org=None source=14.1 
   <title>Date/Time Functions and Operators</title>
________________________________________________________-->
   <title>时间/日期函数和操作符</title>
<!-- pgdoc-cn_end sig_en=96f69ebb86b105b1971b0efd260321cd -->

<!-- pgdoc-cn_start sig_en=447ffd5250ab2b99cdf8958b4a2b8d35 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-datetime-table"/>展示了可用于处理日期/时间值的函数，其细节在随后的小节中描述。<xref linkend="operators-datetime-table"/>演示了基本算术操作符 （<literal>+</literal>、<literal>*</literal>等）的行为。 而与格式化相关的函数，可以参考<xref linkend="functions-formatting"/>。你应该很熟悉<xref linkend="datatype-datetime"/>中的日期/时间数据类型的背景知识。
  </para>
<!-- pgdoc-cn_end sig_en=447ffd5250ab2b99cdf8958b4a2b8d35 -->

<!-- pgdoc-cn_start sig_en=0bc6215430b3696466fa8c6127a49e18 sig_cn_org=None source=14.1 
  <para>
   In addition, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for the
   date/time types.  Dates and timestamps (with or without time zone) are
   all comparable, while times (with or without time zone) and intervals
   can only be compared to other values of the same data type.  When
   comparing a timestamp without time zone to a timestamp with time zone,
   the former value is assumed to be given in the time zone specified by
   the <xref linkend="guc-timezone"/> configuration parameter, and is
   rotated to UTC for comparison to the latter value (which is already
   in UTC internally).  Similarly, a date value is assumed to represent
   midnight in the <varname>TimeZone</varname> zone when comparing it
   to a timestamp.
  </para>
________________________________________________________-->
  <para>
   此外， <xref linkend="functions-comparison-op-table"/>中显示的常用比较操作符也适用于日期/时间类型。
   日期和时间戳(带或不带时区)都是可比较的，而时间(带或不带时区)和间隔只能与相同数据类型的其他值进行比较。
   将不带时区的时间戳与带时区的时间戳进行比较时，前者的值假定是在<xref linkend="guc-timezone"/>配置参数指定的时区中给出的，并被转换到UTC，以便与后者的值进行比较(其已经在内部用UTC)。
   类似地，日期值会被假定表示<varname>TimeZone</varname>区域中的午夜，当它与时间戳进行比较时。
  </para>
<!-- pgdoc-cn_end sig_en=0bc6215430b3696466fa8c6127a49e18 -->

<!-- pgdoc-cn_start sig_en=1fa1d08d47a211016eeda9c51bb72378 sig_cn_org=None source=14.1 
  <para>
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both <type>date</type> <literal>+</literal> <type>integer</type>
   and <type>integer</type> <literal>+</literal> <type>date</type>); we show
   only one of each such pair.
  </para>
________________________________________________________-->
  <para>
   所有下文描述的接受<type>time</type>或<type>timestamp</type>输入的函数和操作符实际上都有两种变体： 一种接收<type>time with time zone</type>或<type>timestamp with time zone</type>， 另外一种接受<type>time without time zone</type>或者 <type>timestamp without time zone</type>。
   为了简化，这些变种没有被独立地展示。
   此外，<literal>+</literal>和<literal>*</literal>操作符都是可交换的操作符对（例如，<type>date</type> <literal>+</literal> <type>integer</type> 和 <type>integer</type> <literal>+</literal> <type>date</type>）；我们只显示每一对中的一个。
  </para>
<!-- pgdoc-cn_end sig_en=1fa1d08d47a211016eeda9c51bb72378 -->

    <table id="operators-datetime-table">
<!-- pgdoc-cn_start sig_en=283024e1721bc392fb830cae6b20799a sig_cn_org=None source=14.1 
     <title>Date/Time Operators</title>
________________________________________________________-->
     <title>日期/时间操作符</title>
<!-- pgdoc-cn_end sig_en=283024e1721bc392fb830cae6b20799a -->

     <tgroup cols="1">
      <thead>
<!-- pgdoc-cn_start sig_en=656006cda31d1fe93de4c2121ac304f8 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=656006cda31d1fe93de4c2121ac304f8 -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=32f0b36388e672dc2be33f3d5b5c497a sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Add a number of days to a date
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         给日期加上天数
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=32f0b36388e672dc2be33f3d5b5c497a -->

<!-- pgdoc-cn_start sig_en=05a2d4479aa39f5201d59691c9b6cea1 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a date
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         为日期添加时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=05a2d4479aa39f5201d59691c9b6cea1 -->

<!-- pgdoc-cn_start sig_en=3de9c6c476e3a93448a263314c96f3d8 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add a time-of-day to a date
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在日期中添加一天中的时间
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3de9c6c476e3a93448a263314c96f3d8 -->

<!-- pgdoc-cn_start sig_en=7d51bdbe6c25082a226025a48634a8d4 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Add intervals
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         添加时间间隔
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=7d51bdbe6c25082a226025a48634a8d4 -->

<!-- pgdoc-cn_start sig_en=9e97675b82da573fe28d5345858bead6 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在时间戳中添加一个时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=9e97675b82da573fe28d5345858bead6 -->

<!-- pgdoc-cn_start sig_en=941308a1f6c77c4a517fa4fa2ebb51fb sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Add an interval to a time
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         为时间添加时间间隔
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=941308a1f6c77c4a517fa4fa2ebb51fb -->

<!-- pgdoc-cn_start sig_en=d6cf4803ee653125c2ec98152c210ca5 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Negate an interval
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         取否一个时间间隔
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=d6cf4803ee653125c2ec98152c210ca5 -->

<!-- pgdoc-cn_start sig_en=913b6f987a961065b3f78c09c52b9f9e sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Subtract dates, producing the number of days elapsed
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         减去日期，生成经过的天数
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=913b6f987a961065b3f78c09c52b9f9e -->

<!-- pgdoc-cn_start sig_en=d3f0810fc6c091e8e465ca9ebb846f20 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Subtract a number of days from a date
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从日期中减去天数
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=d3f0810fc6c091e8e465ca9ebb846f20 -->

<!-- pgdoc-cn_start sig_en=7dfee68f65d3947cbe3691a375650e3c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a date
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从日期中减去时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=7dfee68f65d3947cbe3691a375650e3c -->

<!-- pgdoc-cn_start sig_en=7b8cf75789c5505e9efdfc70b0f909a6 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract times
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=7b8cf75789c5505e9efdfc70b0f909a6 -->

<!-- pgdoc-cn_start sig_en=d083087967d5da435f32a1db43fb889f sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Subtract an interval from a time
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从时间中减去时间间隔
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=d083087967d5da435f32a1db43fb889f -->

<!-- pgdoc-cn_start sig_en=689f0f66eed31abfd835b37e31dde805 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从时间戳中减去时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=689f0f66eed31abfd835b37e31dde805 -->

<!-- pgdoc-cn_start sig_en=7559a5dda6bd13a4d99e40cf077bf0b2 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract intervals
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间间隔
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=7559a5dda6bd13a4d99e40cf077bf0b2 -->

<!-- pgdoc-cn_start sig_en=406111eb85af8a52665f23d03a1bf140 sig_cn_org=601b0cd18a9b366e7b75b5bf83e36472 source=15.7 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract timestamps (converting 24-hour intervals into days,
         similarly to <link
         linkend="function-justify-hours"><function>justify_hours()</function></link>)
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间戳（将24小时间隔转换为天数，类似于<link
         linkend="function-justify-hours"><function>justify_hours()</function></link>）
        </para>
        <para>
         <literal>时间戳 '2001-09-29 03:00' - 时间戳 '2001-07-27 12:00'</literal>
         <returnvalue>63 天 15:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=406111eb85af8a52665f23d03a1bf140 -->

<!-- pgdoc-cn_start sig_en=030cce4bc84d0f13d35516ea3e2e3937 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Multiply an interval by a scalar
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         将时间间隔乘以数量
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=030cce4bc84d0f13d35516ea3e2e3937 -->

<!-- pgdoc-cn_start sig_en=760a55523e47ac4a916f3322f2bdce7f sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Divide an interval by a scalar
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         用时间间隔除以数量
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=760a55523e47ac4a916f3322f2bdce7f -->
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!-- pgdoc-cn_start sig_en=7f7efe4a7c805b68d771b29adeb3befa sig_cn_org=None source=14.1 
     <title>Date/Time Functions</title>
________________________________________________________-->
     <title>日期/时间函数</title>
<!-- pgdoc-cn_end sig_en=7f7efe4a7c805b68d771b29adeb3befa -->
     <tgroup cols="1">
      <thead>
<!-- pgdoc-cn_start sig_en=f57151de0c2c5fd5a44795546b7b9794 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Function
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         函数
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=f57151de0c2c5fd5a44795546b7b9794 -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=91d4097ac67ba883d233e342fe7781a5 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract arguments, producing a <quote>symbolic</quote> result that
         uses years and months, rather than just days
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去参数，生成一个使用年和月，而不是只用日的<quote>符号化</quote>的结果
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=91d4097ac67ba883d233e342fe7781a5 -->

<!-- pgdoc-cn_start sig_en=bf1932d262756a2bb827bd585495dfbe sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract argument from <function>current_date</function> (at midnight)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从 <function>current_date</function> 减去参数(在午夜)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=bf1932d262756a2bb827bd585495dfbe -->

<!-- pgdoc-cn_start sig_en=c8cc3d6e4b51b51c4e0db85e4ff10fec sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间（在语句执行期间变化）；参见<xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=c8cc3d6e4b51b51c4e0db85e4ff10fec -->

<!-- pgdoc-cn_start sig_en=70f18dca3f43cd716f6db1bf1a8aa88c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Current date; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         当前日期；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=70f18dca3f43cd716f6db1bf1a8aa88c -->

<!-- pgdoc-cn_start sig_en=72a99c4d91a1af6e35d1b24506b119aa sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=72a99c4d91a1af6e35d1b24506b119aa -->

<!-- pgdoc-cn_start sig_en=da8b55a48b3bbaf5c813de0c87f60079 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=da8b55a48b3bbaf5c813de0c87f60079 -->

<!-- pgdoc-cn_start sig_en=92a479434e669776e9ecf2dc401a303c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=92a479434e669776e9ecf2dc401a303c -->

<!-- pgdoc-cn_start sig_en=ac5cecdd146742b928af3bb4204f6a68 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=ac5cecdd146742b928af3bb4204f6a68 -->

<!-- pgdoc-cn_start sig_en=503ff2bc81a42e7922363f91a210d5ac sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_bin</function> ( <type>interval</type>, <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Bin input into specified interval aligned with specified origin; see <xref linkend="functions-datetime-bin"/>
        </para>
        <para>
         <literal>date_bin('15 minutes', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00')</literal>
         <returnvalue>2001-02-16 20:35:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_bin</function> ( <type>interval</type>, <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Bin输入到指定的间隔与指定的原点对齐;参见<xref linkend="functions-datetime-bin"/>
        </para>
        <para>
         <literal>date_bin('15 minutes', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00')</literal>
         <returnvalue>2001-02-16 20:35:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=503ff2bc81a42e7922363f91a210d5ac -->

<!-- pgdoc-cn_start sig_en=e506e357cbc669753479404dbb831b4d sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get timestamp subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间戳字段 （等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=e506e357cbc669753479404dbb831b4d -->

<!-- pgdoc-cn_start sig_en=72636d55dd311d5dea0af3ea60d8b917 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get interval subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间间隔子字段（等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=72636d55dd311d5dea0af3ea60d8b917 -->

<!-- pgdoc-cn_start sig_en=46dcb27554237aabd61f0bb2f601e65d sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=46dcb27554237aabd61f0bb2f601e65d -->

<!-- pgdoc-cn_start sig_en=6400939c9858c856b21440682a159b01 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Truncate to specified precision in the specified time zone; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         在规定的时区中截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=6400939c9858c856b21440682a159b01 -->

<!-- pgdoc-cn_start sig_en=dea87c00d535715a243a3b134603fae2 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=dea87c00d535715a243a3b134603fae2 -->

<!-- pgdoc-cn_start sig_en=54f2f76b191ced03b1380e44fcd6123c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
         Get timestamp subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
         获取时间戳子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=54f2f76b191ced03b1380e44fcd6123c -->

<!-- pgdoc-cn_start sig_en=79499416aa9563c0cf2b84696c2fe1b6 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
         Get interval subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
         获取时间间隔子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=79499416aa9563c0cf2b84696c2fe1b6 -->

<!-- pgdoc-cn_start sig_en=78ce42d52b086ba42b2713e476d15d26 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite date (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限日期（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=78ce42d52b086ba42b2713e476d15d26 -->

<!-- pgdoc-cn_start sig_en=2b3548507c7895deaecb91cdb3fa404a sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite timestamp (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间戳（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=2b3548507c7895deaecb91cdb3fa404a -->

<!-- pgdoc-cn_start sig_en=55f106fb204805b90cc1f25f65b03949 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite interval (currently always true)
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间间隔 （当前总是为真）
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=55f106fb204805b90cc1f25f65b03949 -->

<!-- pgdoc-cn_start sig_en=686a31be8753d97d4e5306de0c4d5d61 sig_cn_org=81f2dd30f12be4cfe14808f8697406f0 source=15.7 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm id="function-justify-days">
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval, converting 30-day time periods to months
        </para>
        <para>
         <literal>justify_days(interval '1 year 65 days')</literal>
         <returnvalue>1 year 2 mons 5 days</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry">
            <para role="func_signature">
                <indexterm id="function-justify-days">
                    <primary>justify_days</primary>
                </indexterm>
                <function>justify_days</function> ( <type>interval</type> )
                <returnvalue>interval</returnvalue>
            </para>
            <para>
                调整间隔，将30天的时间段转换为月份
            </para>
            <para>
                <literal>justify_days(interval '1 year 65 days')</literal>
                <returnvalue>1 year 2 mons 5 days</returnvalue>
            </para>
        </entry>
</row>
<!-- pgdoc-cn_end sig_en=686a31be8753d97d4e5306de0c4d5d61 -->

<!-- pgdoc-cn_start sig_en=3007fb2c4e1b83e49122442f6533fa4e sig_cn_org=7469c59134a83ec4286b9d4d6637deae source=15.7 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm id="function-justify-hours">
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval, converting 24-hour time periods to days
        </para>
        <para>
         <literal>justify_hours(interval '50 hours 10 minutes')</literal>
         <returnvalue>2 days 02:10:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm id="function-justify-hours">
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         调整间隔，将24小时时间段转换为天数
        </para>
        <para>
         <literal>justify_hours(interval '50 hours 10 minutes')</literal>
         <returnvalue>2 days 02:10:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3007fb2c4e1b83e49122442f6533fa4e -->

<!-- pgdoc-cn_start sig_en=5883f276f2b4fa28d4629547b4fcef14 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval using <function>justify_days</function>
         and <function>justify_hours</function>, with additional sign
         adjustments
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         使用 <function>justify_days</function> 和 <function>justify_hours</function>调整时间间隔； 通过额外的符号调整
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=5883f276f2b4fa28d4629547b4fcef14 -->

<!-- pgdoc-cn_start sig_en=0066dbf40505b22c734fcf5af205f45d sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=0066dbf40505b22c734fcf5af205f45d -->

<!-- pgdoc-cn_start sig_en=3bd3ba38155646a3f3bad645da2d1a0f sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中的当前时间，有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3bd3ba38155646a3f3bad645da2d1a0f -->

<!-- pgdoc-cn_start sig_en=b51f5468e67759f4816b91ae903170c0 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=b51f5468e67759f4816b91ae903170c0 -->

<!-- pgdoc-cn_start sig_en=4c1d586ce266518531f56c41e4625d4a sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current
         transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=4c1d586ce266518531f56c41e4625d4a -->

<!-- pgdoc-cn_start sig_en=8dc410d84f3dc965a08256e5f0e49e05 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Create date from year, month and day fields
         (negative years signify BC)
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从年、月和日字段创建日期（负数年份表示BC）
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=8dc410d84f3dc965a08256e5f0e49e05 -->

<!-- pgdoc-cn_start sig_en=b8a85694ed4423722d327990d74af87c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields, each of which can default to zero
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从年、月、周、日、小时、分钟和秒字段创建时间间隔，每个字段默认为0
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=b8a85694ed4423722d327990d74af87c -->

<!-- pgdoc-cn_start sig_en=87b74f009a9a6ad650253e3503c37e13 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Create time from hour, minute and seconds fields
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从小时、分钟和秒字段创建时间
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=87b74f009a9a6ad650253e3503c37e13 -->

<!-- pgdoc-cn_start sig_en=55dd883154e093f7ff8ecee655803f16 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Create timestamp from year, month, day, hour, minute and seconds fields
         (negative years signify BC)
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从年、月、日、小时、分钟和秒字段创建时间戳（负数年份表示BC）
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=55dd883154e093f7ff8ecee655803f16 -->

<!-- pgdoc-cn_start sig_en=9e70b3d58c2d4948034a2615d015b81c sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields (negative years signify BC).
         If <parameter>timezone</parameter> is not
         specified, the current time zone is used; the examples assume the
         session time zone is <literal>Europe/London</literal>
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5, 'America/New_York')</literal>
         <returnvalue>2013-07-15 13:15:23.5+01</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         从年，月，日，小时，分钟和秒字段结合时区创建时间戳（负数年份表示BC）。
         如果没有指定<parameter>timezone</parameter>，则使用当前时区；示例假设会话时区为<literal>Europe/London</literal>
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5, 'America/New_York')</literal>
         <returnvalue>2013-07-15 13:15:23.5+01</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=9e70b3d58c2d4948034a2615d015b81c -->

<!-- pgdoc-cn_start sig_en=cab01bcbfa83d30da6d7f5daaba2ac69 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=cab01bcbfa83d30da6d7f5daaba2ac69 -->

<!-- pgdoc-cn_start sig_en=066529c70cc18c91a99b640fe886c855 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前语句的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=066529c70cc18c91a99b640fe886c855 -->

<!-- pgdoc-cn_start sig_en=0f563bfee25c7b5d719ce8f521fa6e74 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         当前的日期和时间
         （类似 <function>clock_timestamp</function>, 但是采用 <type>text</type> 字符串）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=0f563bfee25c7b5d719ce8f521fa6e74 -->

<!-- pgdoc-cn_start sig_en=60a20eeef45280ee8f99e47867ca7b98 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=60a20eeef45280ee8f99e47867ca7b98 -->

<!-- pgdoc-cn_start sig_en=05fe818d318fc6298b442f2880029609 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp with time zone
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将Unix纪元转换为带时区的时间戳(从1970-01-01 00:00:00+00开的的秒)
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=05fe818d318fc6298b442f2880029609 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=3b2274dfe14a50854f36d8a90c93528d sig_cn_org=None source=14.1 
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    除了这些函数以外，还支持 SQL 操作符<literal>OVERLAPS</literal>：
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。端点可以用一对日期、时间或者时间戳来指定；或者是用一个后面跟着一个间隔的日期、时间或时间戳来指定。当一对值被提供时，起点或终点都可以被写在前面，<literal>OVERLAPS</literal>会自动地把较早的值作为起点。每一个时间段被认为是表示半开的间隔<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>，除非<replaceable>start</replaceable>和<replaceable>end</replaceable>相等，这种情况下它表示单个时间实例。例如这表示两个只有一个共同端点的时间段不重叠。
   </para>
<!-- pgdoc-cn_end sig_en=3b2274dfe14a50854f36d8a90c93528d -->

<!-- pgdoc-cn_start sig_en=957fe6afadba0a40103b8662c42fcc71 sig_cn_org=None source=14.1 
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=957fe6afadba0a40103b8662c42fcc71 -->

<!-- pgdoc-cn_start sig_en=1e5c47a46f906e1301c9700537226705 sig_cn_org=None source=14.1 
  <para>
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days,
   keeping the time of day the same.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set
   to <literal>America/Denver</literal>:
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>
   This happens because an hour was skipped due to a change in daylight saving
   time at <literal>2005-04-03 02:00:00</literal> in time zone
   <literal>America/Denver</literal>.
  </para>
________________________________________________________-->
  <para>
   当把一个<type>interval</type>值添加到<type>timestamp with time zone</type>上（或从中减去）时， 天的部分会按照指定的天数增加或减少<type>timestamp with time zone</type>的日期，保持一天中相同的时间。
   对于横跨夏令时的变化（当会话的时区被设置为可识别DST的时区时），这意味着<literal>interval '1 day'</literal>并 不一定等于<literal>interval '24 hours'</literal>。
   例如，当会话的时区设置为<literal>America/Denver</literal>时：
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>  
   发生此情况是因为夏令时在<literal>America/Denver</literal>时区的<literal>2005-04-03 02:00:00</literal>的时间发生更改而跳过了一个小时。
  </para>
<!-- pgdoc-cn_end sig_en=1e5c47a46f906e1301c9700537226705 -->

<!-- pgdoc-cn_start sig_en=2f827e3382bffefca077dc7be02234e9 sig_cn_org=None source=14.1 
  <para>
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
  </para>
________________________________________________________-->
  <para>
   注意<function>age</function>返回的<literal>月数</literal>域可能有歧义，因为不同的月份有不同的天数。 <productname>PostgreSQL</productname>的方法是当计算部分月数时，采用两个日期中较早的月。例如：<literal>age('2004-06-01', '2004-04-30')</literal>使用4月份得到<literal>1 mon 1 day</literal>，而用5月分时会得到<literal>1 mon 2 days</literal>，因为5月有31天，而4月只有30天。
  </para>
<!-- pgdoc-cn_end sig_en=2f827e3382bffefca077dc7be02234e9 -->

<!-- pgdoc-cn_start sig_en=5a376a32bfe06b9ef3c272890559e25a sig_cn_org=None source=14.1 
  <para>
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
  </para>
________________________________________________________-->
  <para>
   日期和时间戳的减法也可能会很复杂。执行减法的一种概念上很简单的方法是，使用
   <literal>EXTRACT(EPOCH FROM ...)</literal>把每个值都转换成秒数，然后执行减法，
   这样会得到两个值之间的<emphasis>秒</emphasis>数。这种方法将会适应每个月中天数、
   时区改变和夏令时调整。使用<quote><literal>-</literal></quote>操作符的日期或时间
   戳减法会返回值之间的天数（24小时）以及时/分/秒，也会做同样的调整。
   <function>age</function>函数会返回年、月、日以及时/分/秒，执行按域的减法，然后对
   负值域进行调整。下面的查询展示了这些方法的不同。例子中的结果由
   <literal>timezone = 'US/Eastern'</literal>产生，这使得两个使用的日期之间存在着夏令
   时的变化：
  </para>
<!-- pgdoc-cn_end sig_en=5a376a32bfe06b9ef3c272890559e25a -->

<!-- pgdoc-cn_start sig_en=3c3a05caedde1ff256fa40eab1fa5392 sig_cn_org=3c3a05caedde1ff256fa40eab1fa5392 source=15.7 
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200.000000</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.9583333333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200.000000</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.9583333333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=3c3a05caedde1ff256fa40eab1fa5392 -->

  <sect2 id="functions-datetime-extract">
<!-- pgdoc-cn_start sig_en=a1b8aa0d31f624e11dbfb2e719f692c3 sig_cn_org=None source=14.1 
   <title><function>EXTRACT</function>, <function>date_part</function></title>
________________________________________________________-->
   <title><function>EXTRACT</function>, <function>date_part</function></title>
<!-- pgdoc-cn_end sig_en=a1b8aa0d31f624e11dbfb2e719f692c3 -->

<!-- pgdoc-cn_start sig_en=a13b66b0e79b3dfc7b5e20dfdc1557c6 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a13b66b0e79b3dfc7b5e20dfdc1557c6 -->
<!-- pgdoc-cn_start sig_en=f6c216e4c9ceef5fd1f7d0d7f346e92d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>extract</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>extract</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f6c216e4c9ceef5fd1f7d0d7f346e92d -->

<!-- pgdoc-cn_start sig_en=7f6f81162184f348240e2f487f61e3c0 sig_cn_org=None source=14.1 
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=7f6f81162184f348240e2f487f61e3c0 -->

<!-- pgdoc-cn_start sig_en=f87307b62d8c817c9f2d936308e8b1a2 sig_cn_org=b7e29e252684e05f3b56949db22de0b0 source=15.7 
   <para>
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>date</type>, <type>time</type>,
    or <type>interval</type>.  (Timestamps and times can be with or
    without time zone.)
    <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    Not all fields are valid for every input data type; for example, fields
    smaller than a day cannot be extracted from a <type>date</type>, while
    fields of a day or more cannot be extracted from a <type>time</type>.
    The <function>extract</function> function returns values of type
    <type>numeric</type>.
   </para>
________________________________________________________-->
   <para>
    <function>extract</function>函数从日期/时间值中检索子字段，例如年份或小时。
    <replaceable>source</replaceable>必须是<type>timestamp</type>、<type>date</type>、<type>time</type>或<type>interval</type>类型的值表达式。
    （时间戳和时间可以带有或不带有时区。）
    <replaceable>field</replaceable>是一个标识符或字符串，用于选择从源值中提取哪个字段。
    并非每种输入数据类型都适用于所有字段；例如，无法从<type>date</type>中提取小于一天的字段，而无法从<type>time</type>中提取一天或更长时间的字段。
    <function>extract</function>函数返回<type>numeric</type>类型的值。
</para>
<!-- pgdoc-cn_end sig_en=f87307b62d8c817c9f2d936308e8b1a2 -->

<!-- pgdoc-cn_start sig_en=a5e4c13136fde653195de1e4d5e70f31 sig_cn_org=a7b7948789c0c41ef71e068d9b62c52a source=15.7 
   <para>
    The following are valid field names:

    <!-&minus; alphabetical -&minus;>
    <variablelist>
     <varlistentry>
________________________________________________________-->
   <para>
    以下是有效的字段名称：

    <!-- 按字母顺序 -->
    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_end sig_en=a5e4c13136fde653195de1e4d5e70f31 -->
      <term><literal>century</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b1aab7be58a41ba397a86e6ecadbf36e sig_cn_org=f58cefb437a663ab3daf9791404fede3 source=15.7 
       <para>
        The century; for <type>interval</type> values, the year field
        divided by 100
       </para>
________________________________________________________-->
       <para>
        这个世纪；对于<type>interval</type>值，年份字段除以100
       </para>
<!-- pgdoc-cn_end sig_en=b1aab7be58a41ba397a86e6ecadbf36e -->

<!-- pgdoc-cn_start sig_en=cbafbeeaf7b94f46c8b6ff71d3b7789c sig_cn_org=cbafbeeaf7b94f46c8b6ff71d3b7789c source=15.7 
<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC');
<lineannotation>Result: </lineannotation><computeroutput>-1</computeroutput>
SELECT EXTRACT(CENTURY FROM INTERVAL '2001 years');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC');
<lineannotation>Result: </lineannotation><computeroutput>-1</computeroutput>
SELECT EXTRACT(CENTURY FROM INTERVAL '2001 years');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=cbafbeeaf7b94f46c8b6ff71d3b7789c -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1a27f92209f119b11e4ee12637df3451 sig_cn_org=4f9a049fb39261f7f3a110d861b00f22 source=15.7 
       <para>
        The day of the month (1&ndash;31); for <type>interval</type>
        values, the number of days
       </para>
________________________________________________________-->
       <para>
        月份的日期（1&ndash;31）；对于<type>interval</type>值，表示天数
       </para>
<!-- pgdoc-cn_end sig_en=1a27f92209f119b11e4ee12637df3451 -->

<!-- pgdoc-cn_start sig_en=84199f4f1cc73c333e18fdcef5918f5a sig_cn_org=84199f4f1cc73c333e18fdcef5918f5a source=15.7 
<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>
SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>
SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=84199f4f1cc73c333e18fdcef5918f5a -->

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=56514dae5f4cd46eda001a1a3be0c2d3 sig_cn_org=679fb6bc1a02e83e3f41e0ea4ea9eb63 source=15.7 
       <para>
        The year field divided by 10
       </para>
________________________________________________________-->
       <para>
        年份字段除以10
       </para>
<!-- pgdoc-cn_end sig_en=56514dae5f4cd46eda001a1a3be0c2d3 -->

<!-- pgdoc-cn_start sig_en=ff357e0969946e6fc148d785d4f06b20 sig_cn_org=ff357e0969946e6fc148d785d4f06b20 source=15.7 
<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=ff357e0969946e6fc148d785d4f06b20 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=13a501933b896956af0d31e4da5dc5a9 sig_cn_org=257309fdeb51458cf817936d0ff5a621 source=15.7 
       <para>
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
       </para>
________________________________________________________-->
       <para>
        一周的日子从星期天（<literal>0</literal>）到星期六（<literal>6</literal>）
       </para>
<!-- pgdoc-cn_end sig_en=13a501933b896956af0d31e4da5dc5a9 -->

<!-- pgdoc-cn_start sig_en=3af31621003bd9417f8b6b0797f6843c sig_cn_org=3af31621003bd9417f8b6b0797f6843c source=15.7 
<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=3af31621003bd9417f8b6b0797f6843c -->
<!-- pgdoc-cn_start sig_en=86249e082ce7fa1ef8095a2506a9d15a sig_cn_org=75cfc33e7575d684139f8ae2088b7c6b source=15.7 
       <para>
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
       </para>
________________________________________________________-->
       <para>
        请注意<function>extract</function>函数的星期几编号与<function>to_char(..., 'D')</function>函数不同。
       </para>
<!-- pgdoc-cn_end sig_en=86249e082ce7fa1ef8095a2506a9d15a -->

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=194410f4b147011bddbf38015334bf91 sig_cn_org=978d9a6cfbe712852c8fa799b5e46722 source=15.7 
       <para>
        The day of the year (1&ndash;365/366)
       </para>
________________________________________________________-->
       <para>
        一年中的日子（1-365/366）
       </para>
<!-- pgdoc-cn_end sig_en=194410f4b147011bddbf38015334bf91 -->

<!-- pgdoc-cn_start sig_en=5ff6a7e554dda812a22f8d973705839b sig_cn_org=5ff6a7e554dda812a22f8d973705839b source=15.7 
<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=5ff6a7e554dda812a22f8d973705839b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ddf5a7221042363051826d0869204217 sig_cn_org=dbfb2ad9d6b3197fbfde2059a12d0ebd source=15.7 
       <para>
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (negative for
        timestamps before that);
        for <type>date</type> and <type>timestamp</type> values, the
        nominal number of seconds since 1970-01-01 00:00:00,
        without regard to timezone or daylight-savings rules;
        for <type>interval</type> values, the total number
        of seconds in the interval
       </para>
________________________________________________________-->
       <para>
        对于<type>带有时区的时间戳</type>值，自1970-01-01 00:00:00 UTC以来的秒数（负值表示该时间戳之前的时间）；
        对于<type>date</type>和<type>timestamp</type>值，自1970-01-01 00:00:00以来的名义秒数，不考虑时区或夏令时规则；
        对于<type>interval</type>值，间隔中的总秒数
       </para>
<!-- pgdoc-cn_end sig_en=ddf5a7221042363051826d0869204217 -->

<!-- pgdoc-cn_start sig_en=f1678f57e8c6bf31ffda201d56dc567e sig_cn_org=f1678f57e8c6bf31ffda201d56dc567e source=15.7 
<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.120000</computeroutput>
SELECT EXTRACT(EPOCH FROM TIMESTAMP '2001-02-16 20:38:40.12');
<lineannotation>Result: </lineannotation><computeroutput>982355920.120000</computeroutput>
SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800.000000</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.120000</computeroutput>
SELECT EXTRACT(EPOCH FROM TIMESTAMP '2001-02-16 20:38:40.12');
<lineannotation>Result: </lineannotation><computeroutput>982355920.120000</computeroutput>
SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800.000000</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=f1678f57e8c6bf31ffda201d56dc567e -->

<!-- pgdoc-cn_start sig_en=c6827a48c08bbec9ca6d50be5256cb24 sig_cn_org=7e6697dd09daa8914cd35ec264dfe94e source=15.7 
       <para>
        You can convert an epoch value back to a <type>timestamp with time zone</type>
        with <function>to_timestamp</function>:
       </para>
________________________________________________________-->
       <para>
        您可以使用<function>to_timestamp</function>将一个时期值转换回<type>带有时区的时间戳</type>：
       </para>
<!-- pgdoc-cn_end sig_en=c6827a48c08bbec9ca6d50be5256cb24 -->
<!-- pgdoc-cn_start sig_en=3c94b703039c38a879654faec1af2c6d sig_cn_org=3c94b703039c38a879654faec1af2c6d source=15.7 
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=3c94b703039c38a879654faec1af2c6d -->

<!-- pgdoc-cn_start sig_en=442c0e33199d2f692dcd34689e897d70 sig_cn_org=075b4e681e894429d6d2f357c68947aa source=15.7 
       <para>
        Beware that applying <function>to_timestamp</function> to an epoch
        extracted from a <type>date</type> or <type>timestamp</type> value
        could produce a misleading result: the result will effectively
        assume that the original value had been given in UTC, which might
        not be the case.
       </para>
________________________________________________________-->
       <para>
        注意，将<function>to_timestamp</function>应用于从<type>date</type>或<type>timestamp</type>值中提取的时代可能会产生误导性的结果：
        结果将有效地假定原始值是以UTC时间给出的，这可能并非事实。
       </para>
<!-- pgdoc-cn_end sig_en=442c0e33199d2f692dcd34689e897d70 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2ac70b70207743d462adcb9b7acb4854 sig_cn_org=65af4933f7a9484255536e35ea84ce7d source=15.7 
       <para>
        The hour field (0&ndash;23 in timestamps, unrestricted in
        intervals)
       </para>
________________________________________________________-->
       <para>
        小时字段（时间戳中为0&ndash;23，在间隔中不受限制）
       </para>
<!-- pgdoc-cn_end sig_en=2ac70b70207743d462adcb9b7acb4854 -->

<!-- pgdoc-cn_start sig_en=b2986825ccb3fbae2be0d865c1255d9f sig_cn_org=b2986825ccb3fbae2be0d865c1255d9f source=15.7 
<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=b2986825ccb3fbae2be0d865c1255d9f -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d9333ea23fb0ef7e0c686671ef8e3702 sig_cn_org=cf7fafe0f8f8ba209787b052935405bc source=15.7 
       <para>
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
       </para>
________________________________________________________-->
       <para>
        一周的日子从星期一（<literal>1</literal>）到星期日（<literal>7</literal>）
       </para>
<!-- pgdoc-cn_end sig_en=d9333ea23fb0ef7e0c686671ef8e3702 -->

<!-- pgdoc-cn_start sig_en=3678bff15d58bcb5abc74db791f203b5 sig_cn_org=3678bff15d58bcb5abc74db791f203b5 source=15.7 
<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=3678bff15d58bcb5abc74db791f203b5 -->
<!-- pgdoc-cn_start sig_en=0313c9818ad72acaa6b37d2f14cfd2e6 sig_cn_org=4e4f7768f51583ccfb6bb481bd8b029d source=15.7 
       <para>
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
       </para>
________________________________________________________-->
       <para>
        这与<literal>dow</literal>相同，除了星期天。这匹配<acronym>ISO</acronym> 8601的星期几编号。
       </para>
<!-- pgdoc-cn_end sig_en=0313c9818ad72acaa6b37d2f14cfd2e6 -->

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=09f6808f0f27f6d53f2a3925d396846d sig_cn_org=c33caa68f86220f840fafefb383b848e source=15.7 
       <para>
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in
       </para>
________________________________________________________-->
       <para>
        日期所在的<acronym>ISO</acronym> 8601周编号年份
       </para>
<!-- pgdoc-cn_end sig_en=09f6808f0f27f6d53f2a3925d396846d -->

<!-- pgdoc-cn_start sig_en=f1ca8460b652999795dd74817cd487a2 sig_cn_org=f1ca8460b652999795dd74817cd487a2 source=15.7 
<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=f1ca8460b652999795dd74817cd487a2 -->

<!-- pgdoc-cn_start sig_en=f1cae157129dfd0fdffcaca9b59b9974 sig_cn_org=a99cdaac11cd31eee9febc2409eabfb2 source=15.7 
       <para>
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
       </para>
________________________________________________________-->
       <para>
        每个<acronym>ISO</acronym> 8601周编号年从包含1月4日的星期一开始，因此在一月初或十二月底，<acronym>ISO</acronym>年可能与格里高利年不同。
        有关更多信息，请参见<literal>week</literal>字段。
       </para>
<!-- pgdoc-cn_end sig_en=f1cae157129dfd0fdffcaca9b59b9974 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>julian</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5d51a6b6bddd3ba41ff2391cea2cefb3 sig_cn_org=410d81dda4be1b6312552b52b534fb58 source=15.7 
       <para>
        The <firstterm>Julian Date</firstterm> corresponding to the
        date or timestamp.  Timestamps
        that are not local midnight result in a fractional value.  See
        <xref linkend="datetime-julian-dates"/> for more information.
       </para>
________________________________________________________-->
       <para>
        与日期或时间戳对应的<firstterm>儒略日</firstterm>。非当地午夜的时间戳会导致小数值。
        更多信息请参见<xref linkend="datetime-julian-dates"/>。
       </para>
<!-- pgdoc-cn_end sig_en=5d51a6b6bddd3ba41ff2391cea2cefb3 -->

<!-- pgdoc-cn_start sig_en=b926b72e4249026ef8d8750c65c6370a sig_cn_org=b926b72e4249026ef8d8750c65c6370a source=15.7 
<screen>
SELECT EXTRACT(JULIAN FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2453737</computeroutput>
SELECT EXTRACT(JULIAN FROM TIMESTAMP '2006-01-01 12:00');
<lineannotation>Result: </lineannotation><computeroutput>2453737.50000000000000000000</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(JULIAN FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2453737</computeroutput>
SELECT EXTRACT(JULIAN FROM TIMESTAMP '2006-01-01 12:00');
<lineannotation>Result: </lineannotation><computeroutput>2453737.50000000000000000000</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=b926b72e4249026ef8d8750c65c6370a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=0862c82e89d310270155024a8d056d79 sig_cn_org=a0eead244420e924e4c9fcd53071fb8e source=15.7 
       <para>
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
       </para>
________________________________________________________-->
       <para>
        秒字段，包括小数部分，乘以1 000 000；注意这包括完整的秒数
       </para>
<!-- pgdoc-cn_end sig_en=0862c82e89d310270155024a8d056d79 -->

<!-- pgdoc-cn_start sig_en=968eaa0b9c9c62891099c77bfd8b41ee sig_cn_org=968eaa0b9c9c62891099c77bfd8b41ee source=15.7 
<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=968eaa0b9c9c62891099c77bfd8b41ee -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f46b8f7f25546b6379054a6a3251bf8d sig_cn_org=95251a18b2aab4df1b3f3b1348fc09f8 source=15.7 
       <para>
        The millennium; for <type>interval</type> values, the year field
        divided by 1000
       </para>
________________________________________________________-->
       <para>
        千年; 对于<type>interval</type>值，年份字段除以1000
       </para>
<!-- pgdoc-cn_end sig_en=f46b8f7f25546b6379054a6a3251bf8d -->

<!-- pgdoc-cn_start sig_en=b2594bfd7649ea3f35e5f5f1a25ad98c sig_cn_org=b2594bfd7649ea3f35e5f5f1a25ad98c source=15.7 
<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
SELECT EXTRACT(MILLENNIUM FROM INTERVAL '2001 years');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
SELECT EXTRACT(MILLENNIUM FROM INTERVAL '2001 years');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=b2594bfd7649ea3f35e5f5f1a25ad98c -->

<!-- pgdoc-cn_start sig_en=6652ecede4581df2a46a57efe9b1d422 sig_cn_org=285ae9bee973408d989c5ed572f1e691 source=15.7 
       <para>
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
       </para>
________________________________________________________-->
       <para>
        20世纪的年份在第二个千年。第三个千年从2001年1月1日开始。
       </para>
<!-- pgdoc-cn_end sig_en=6652ecede4581df2a46a57efe9b1d422 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=95a7c70bbd105036a59853482ab6fc89 sig_cn_org=6aba2e1724cdac047680b2ec66e1fa43 source=15.7 
       <para>
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
       </para>
________________________________________________________-->
       <para>
        第二个字段，包括小数部分，乘以1000。请注意，这包括完整的秒数。
       </para>
<!-- pgdoc-cn_end sig_en=95a7c70bbd105036a59853482ab6fc89 -->

<!-- pgdoc-cn_start sig_en=91afb3258c9ead714326e23e230e90ae sig_cn_org=91afb3258c9ead714326e23e230e90ae source=15.7 
<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500.000</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500.000</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=91afb3258c9ead714326e23e230e90ae -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5b2397fcedad9fd97ae0e740976612a8 sig_cn_org=ca6840f80ed2d2dc2362d18a34960754 source=15.7 
       <para>
        The minutes field (0&ndash;59)
       </para>
________________________________________________________-->
       <para>
        分钟字段（0&ndash;59）
       </para>
<!-- pgdoc-cn_end sig_en=5b2397fcedad9fd97ae0e740976612a8 -->

<!-- pgdoc-cn_start sig_en=e25152d1a2c8aa5ad003ce8f8eab2e8d sig_cn_org=e25152d1a2c8aa5ad003ce8f8eab2e8d source=15.7 
<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=e25152d1a2c8aa5ad003ce8f8eab2e8d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ab3f4b0c7442f35603e3ee91ffbca244 sig_cn_org=de631e396f45352be27a935eb1d746cc source=15.7 
       <para>
        The number of the month within the year (1&ndash;12);
        for <type>interval</type> values, the number of months modulo 12
        (0&ndash;11)
       </para>
________________________________________________________-->
       <para>
        月份在一年中的编号（1-12）；对于<type>interval</type>值，月份模12的余数（0-11）
       </para>
<!-- pgdoc-cn_end sig_en=ab3f4b0c7442f35603e3ee91ffbca244 -->

<!-- pgdoc-cn_start sig_en=323b82c4117b2e8fe903c20aabed7090 sig_cn_org=323b82c4117b2e8fe903c20aabed7090 source=15.7 
<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=323b82c4117b2e8fe903c20aabed7090 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e4dff30bf0fbea881a9a4d4024f8f156 sig_cn_org=ed98887d4f9911459bc1c738df390e41 source=15.7 
       <para>
        The quarter of the year (1&ndash;4) that the date is in
       </para>
________________________________________________________-->
       <para>
        日期所在的年份季度（1-4）
</para>
<!-- pgdoc-cn_end sig_en=e4dff30bf0fbea881a9a4d4024f8f156 -->

<!-- pgdoc-cn_start sig_en=a8cfde511215ecdec776541c2b778176 sig_cn_org=a8cfde511215ecdec776541c2b778176 source=15.7 
<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=a8cfde511215ecdec776541c2b778176 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b399f6920919595191d00ccde89c5e8c sig_cn_org=dc6f68bc0d7b5891d9a83770db536f71 source=15.7 
       <para>
        The seconds field, including any fractional seconds
       </para>
________________________________________________________-->
       <para>
        秒字段，包括任何小数秒
       </para>
<!-- pgdoc-cn_end sig_en=b399f6920919595191d00ccde89c5e8c -->

<!-- pgdoc-cn_start sig_en=87bb7732519e8d844d6c1b260ab9147b sig_cn_org=87bb7732519e8d844d6c1b260ab9147b source=15.7 
<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40.000000</computeroutput>
SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.500000</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40.000000</computeroutput>
SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.500000</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=87bb7732519e8d844d6c1b260ab9147b -->
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=74338639fe37251b62d78e130e2a0c4c sig_cn_org=0080efc06073b9012cf7fd49f5f27eea source=15.7 
       <para>
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
       </para>
________________________________________________________-->
       <para>
        与UTC的时区偏移量，以秒为单位。正值对应于UTC东部的时区，负值对应于UTC西部的时区。
        （从技术上讲，<productname>PostgreSQL</productname>不使用UTC，因为不处理闰秒。）
       </para>
<!-- pgdoc-cn_end sig_en=74338639fe37251b62d78e130e2a0c4c -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=667b99fc41b2aa12de39d1c2a450a052 sig_cn_org=730f159b977103513424cd1b50c28da5 source=15.7 
       <para>
        The hour component of the time zone offset
       </para>
________________________________________________________-->
       <para>
        时间区偏移的小时组件
       </para>
<!-- pgdoc-cn_end sig_en=667b99fc41b2aa12de39d1c2a450a052 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5425fe956b3299d56b88e39a1a7c5aaa sig_cn_org=05af43fdbd322d583bed0c2aff2b406d source=15.7 
       <para>
        The minute component of the time zone offset
       </para>
________________________________________________________-->
       <para>
        时间区偏移的分钟组件
       </para>
<!-- pgdoc-cn_end sig_en=5425fe956b3299d56b88e39a1a7c5aaa -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ddb46f88b329b6f7ca8571c361047e82 sig_cn_org=cf156052e557774e79fb0ec29b9b7726 source=15.7 
       <para>
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
       </para>
________________________________________________________-->
       <para>
        一年中<acronym>ISO</acronym> 8601周编号周的数量。根据定义，ISO周从周一开始，
        一年的第一周包含该年的1月4日。换句话说，一年的第一个星期四在该年的第1周。
       </para>
<!-- pgdoc-cn_end sig_en=ddb46f88b329b6f7ca8571c361047e82 -->
<!-- pgdoc-cn_start sig_en=1031e11cd281a4949704cc6cf20a8c1b sig_cn_org=8da86dd11b3c42a33043d239e4709c49 source=15.7 
       <para>
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
       </para>
________________________________________________________-->
       <para>
        在ISO周编号系统中，早年1月的日期可能属于前一年的第52周或第53周，而
        晚年12月的日期可能属于下一年的第一周。例如，<literal>2005-01-01</literal>
        属于2004年的第53周，<literal>2006-01-01</literal> 属于2005年的第52周，
        而<literal>2012-12-31</literal> 属于2013年的第一周。建议同时使用
        <literal>isoyear</literal> 字段和<literal>week</literal>以获得一致的结果。
       </para>
<!-- pgdoc-cn_end sig_en=1031e11cd281a4949704cc6cf20a8c1b -->

<!-- pgdoc-cn_start sig_en=87eb203fbef9590448cdc8970f171178 sig_cn_org=87eb203fbef9590448cdc8970f171178 source=15.7 
<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=87eb203fbef9590448cdc8970f171178 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5d5e8c793ff204e85e5bb9be74296521 sig_cn_org=38d77959df5d468b422c889484e55553 source=15.7 
       <para>
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
       </para>
________________________________________________________-->
       <para>
        年份字段。请记住，没有<literal>0 AD</literal>，所以要小心地从<literal>AD</literal>年中减去<literal>BC</literal>年。
       </para>
<!-- pgdoc-cn_end sig_en=5d5e8c793ff204e85e5bb9be74296521 -->

<!-- pgdoc-cn_start sig_en=94dc256c12ae07aebc38ce7f276d9766 sig_cn_org=94dc256c12ae07aebc38ce7f276d9766 source=15.7 
<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=94dc256c12ae07aebc38ce7f276d9766 -->
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

<!-- pgdoc-cn_start sig_en=0e376d20d278c1af878e4a14f755455d sig_cn_org=d1eecebcacaee3864664eb4fa2ac2351 source=15.7 
   <para>
    When processing an <type>interval</type> value,
    the <function>extract</function> function produces field values that
    match the interpretation used by the interval output function.  This
    can produce surprising results if one starts with a non-normalized
    interval representation, for example:
<screen>
SELECT INTERVAL '80 minutes';
<lineannotation>Result: </lineannotation><computeroutput>01:20:00</computeroutput>
SELECT EXTRACT(MINUTES FROM INTERVAL '80 minutes');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
   </para>
________________________________________________________-->
   <para>
    当处理<type>interval</type>值时，<function>extract</function>函数会生成与间隔输出函数使用的解释相匹配的字段值。
    如果从非规范化的间隔表示开始，可能会产生令人惊讶的结果，例如：
<screen>
SELECT INTERVAL '80 minutes';
<lineannotation>结果: </lineannotation><computeroutput>01:20:00</computeroutput>
SELECT EXTRACT(MINUTES FROM INTERVAL '80 minutes');
<lineannotation>结果: </lineannotation><computeroutput>20</computeroutput>
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=0e376d20d278c1af878e4a14f755455d -->

   <note>
<!-- pgdoc-cn_start sig_en=a729c9b22941720a1dde9430040b7aa8 sig_cn_org=None source=14.1 
    <para>
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
    </para>
________________________________________________________-->
    <para>
     当输入值为 +/-Infinity 时，<function>extract</function>对于单调增的域（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>以及<literal>millennium</literal>）返回 +/-Infinity。对于其他域返回 NULL。<productname>PostgreSQL</productname> 9.6 之前的版本对所有输入无穷的情况都返回零。
    </para>
<!-- pgdoc-cn_end sig_en=a729c9b22941720a1dde9430040b7aa8 -->
   </note>

<!-- pgdoc-cn_start sig_en=6dfbfef304df28f7873409404fc07b94 sig_cn_org=None source=14.1 
   <para>
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
   </para>
________________________________________________________-->
   <para>
    <function>extract</function>函数主要的用途是做计算性处理。对于用于显示的日期/时间值格式化，参阅<xref linkend="functions-formatting"/>。
   </para>
<!-- pgdoc-cn_end sig_en=6dfbfef304df28f7873409404fc07b94 -->

<!-- pgdoc-cn_start sig_en=7b46f121585b00c95c0437c3325efbc3 sig_cn_org=None source=14.1 
   <para>
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
    For historical reasons, the <function>date_part</function> function
    returns values of type <type>double precision</type>.  This can result in
    a loss of precision in certain uses.  Using <function>extract</function>
    is recommended instead.
   </para>
________________________________________________________-->
   <para>
    在传统的<productname>Ingres</productname>上建模的<function>date_part</function>函数等价于<acronym>SQL</acronym>标准函数<function>extract</function>：
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    请注意这里的<replaceable>field</replaceable>参数必须是一个串值，而不是一个名字。
	有效的<function>date_part</function>域名 和<function>extract</function>相同。
    由于历史原因，<function>date_part</function>函数返回<type>double precision</type>类型的值。
    这可能导致在某些使用中损失精度。
    建议使用<function>extract</function>替代。
   </para>
<!-- pgdoc-cn_end sig_en=7b46f121585b00c95c0437c3325efbc3 -->

<!-- pgdoc-cn_start sig_en=65e6b030202afd8546dddafa01f74998 sig_cn_org=65e6b030202afd8546dddafa01f74998 source=15.7 
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>
SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>
________________________________________________________-->
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>
SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>
<!-- pgdoc-cn_end sig_en=65e6b030202afd8546dddafa01f74998 -->

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

<!-- pgdoc-cn_start sig_en=82d0bbfebb0ada7d25dadc7345f4b338 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=82d0bbfebb0ada7d25dadc7345f4b338 -->

<!-- pgdoc-cn_start sig_en=8ace8e4038667a0f45443d4c90793a3a sig_cn_org=None source=14.1 
   <para>
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
   </para>
________________________________________________________-->
   <para>
    <function>date_trunc</function>函数在概念上和用于数字的<function>trunc</function>函数类似。
   </para>
<!-- pgdoc-cn_end sig_en=8ace8e4038667a0f45443d4c90793a3a -->

<!-- pgdoc-cn_start sig_en=c4c3e3f38bfa461cade6d780831d67b0 sig_cn_org=None source=14.1 
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
   </para>
________________________________________________________-->
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable>是类型<type>timestamp</type>或<type>interval</type>的值表达式（类型<type>date</type>和 <type>time</type>的值都分别被自动转换成<type>timestamp</type>, <type>timestamp with time zone</type>,或者<type>interval</type>）。<replaceable>field</replaceable>选择对输入值选用什么样的精度进行截断。返回的值是<type>timestamp</type>, <type>timestamp with time zone</type>,类型或者所有小于选定的 精度的域都设置为零（或者一，对于日期和月份）的<type>interval</type>。
   </para>
<!-- pgdoc-cn_end sig_en=c4c3e3f38bfa461cade6d780831d67b0 -->

<!-- pgdoc-cn_start sig_en=19c8e5a7e679beadc80adb26861327c8 sig_cn_org=None source=14.1 
   <para>
    Valid values for <replaceable>field</replaceable> are:
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>
________________________________________________________-->
   <para>
    <replaceable>field</replaceable>的有效值是∶
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>
<!-- pgdoc-cn_end sig_en=19c8e5a7e679beadc80adb26861327c8 -->

<!-- pgdoc-cn_start sig_en=e5e4bc4b2722be50a1c0319498cb1d68 sig_cn_org=None source=14.1 
   <para>
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
   </para>
________________________________________________________-->
   <para>
    当输入值的类型为<type>timestamp with time zone</type>时。截断是针对特定时区进行的。 例如，截断为<literal>day</literal>，产生的值是 是该区域的午夜。 默认情况下，截断是在以下方面进行的  到当前的<xref linkend="guc-timezone"/>设置，但在当前的 可以提供可选的<replaceable>time_zone</replaceable>参数。以指定不同的时区。 可以指定时区名称 <xref linkend="datatype-timezones"/>中描述的任何一种方式。
   </para>
<!-- pgdoc-cn_end sig_en=e5e4bc4b2722be50a1c0319498cb1d68 -->

<!-- pgdoc-cn_start sig_en=e5d271ebfe122c419eb0e8a9bc743df8 sig_cn_org=None source=14.1 
   <para>
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
   </para>
________________________________________________________-->
   <para>
    当处理<type>timestamp without time zone</type> 或<type>interval</type>输入时，不能指定时区。 这些总是按表面值来处理。
   </para>
<!-- pgdoc-cn_end sig_en=e5d271ebfe122c419eb0e8a9bc743df8 -->

<!-- pgdoc-cn_start sig_en=ffc46c6000d549686fb166e59679c6f2 sig_cn_org=dcda0dcb374713e8606ec1ae1da5f601 source=15.7 
   <para>
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>
SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>
SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>
SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
________________________________________________________-->
   <para>
    例子（假设本地时区是<literal>America/New_York</literal>）：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>
SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>
SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>
SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>结果：</lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=ffc46c6000d549686fb166e59679c6f2 -->
  </sect2>

  <sect2 id="functions-datetime-bin">
   <title><function>date_bin</function></title>

<!-- pgdoc-cn_start sig_en=d02156365beff7f3971fbd866b462edc sig_cn_org=None source=14.1 
   <indexterm>
    <primary>date_bin</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>date_bin</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d02156365beff7f3971fbd866b462edc -->

<!-- pgdoc-cn_start sig_en=22586bf3510f3199bdba1b437215710c sig_cn_org=None source=14.1 
   <para>
    The function <function>date_bin</function> <quote>bins</quote> the input
    timestamp into the specified interval (the <firstterm>stride</firstterm>)
    aligned with a specified origin.
   </para>
________________________________________________________-->
   <para>
    函数<function>date_bin</function> <quote>bins</quote>输入时间戳到指定的间隔(<firstterm>stride</firstterm>)与指定的原点对齐。
   </para>
<!-- pgdoc-cn_end sig_en=22586bf3510f3199bdba1b437215710c -->

<!-- pgdoc-cn_start sig_en=573c35257251392491ef53cb337a58d2 sig_cn_org=None source=14.1 
   <para>
<synopsis>
date_bin(<replaceable>stride</replaceable>, <replaceable>source</replaceable>, <replaceable>origin</replaceable>)
</synopsis>
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type> or <type>timestamp with time zone</type>.  (Values
    of type <type>date</type> are cast automatically to
    <type>timestamp</type>.)  <replaceable>stride</replaceable> is a value
    expression of type <type>interval</type>.  The return value is likewise
    of type <type>timestamp</type> or <type>timestamp with time zone</type>,
    and it marks the beginning of the bin into which the
    <replaceable>source</replaceable> is placed.
   </para>
________________________________________________________-->
   <para>
<synopsis>
date_bin(<replaceable>stride</replaceable>, <replaceable>source</replaceable>, <replaceable>origin</replaceable>)
</synopsis>
    <replaceable>source</replaceable>是<type>timestamp</type> 或 <type>timestamp with time zone</type>类型的值表达式。
    (类型<type>date</type>的值会自动转换为<type>timestamp</type>。)
    <replaceable>stride</replaceable> 是<type>interval</type>类型的值表达式。
    返回值同样是<type>timestamp</type> 或 <type>timestamp with time zone</type>类型，并且它标记着放置<replaceable>source</replaceable>的bin的开始。
   </para>
<!-- pgdoc-cn_end sig_en=573c35257251392491ef53cb337a58d2 -->

<!-- pgdoc-cn_start sig_en=d1c191eddc2360b58654584d7b88053d sig_cn_org=ec61f9860cd4cac16b897d6c4520eb21 source=15.7 
   <para>
    Examples:
<screen>
SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2020-02-11 15:30:00</computeroutput>
SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01 00:02:30');
<lineannotation>Result: </lineannotation><computeroutput>2020-02-11 15:32:30</computeroutput>
</screen>
   </para>
________________________________________________________-->
   <para>
    例子:
<screen>
SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01');
<lineannotation>结果: </lineannotation><computeroutput>2020-02-11 15:30:00</computeroutput>
SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01 00:02:30');
<lineannotation>结果: </lineannotation><computeroutput>2020-02-11 15:32:30</computeroutput>
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=d1c191eddc2360b58654584d7b88053d -->

<!-- pgdoc-cn_start sig_en=6fe9a74931510e1a5aa0ea093d97ca0e sig_cn_org=None source=14.1 
   <para>
    In the case of full units (1 minute, 1 hour, etc.), it gives the same result as
    the analogous <function>date_trunc</function> call, but the difference is
    that <function>date_bin</function> can truncate to an arbitrary interval.
   </para>
________________________________________________________-->
   <para>
    在完整单位(1分钟，1小时，等等)的情况下，它给出与类似 <function>date_trunc</function>调用相同的结果，但不同的地方是<function>date_bin</function>可以截断到任意间隔。
   </para>
<!-- pgdoc-cn_end sig_en=6fe9a74931510e1a5aa0ea093d97ca0e -->

<!-- pgdoc-cn_start sig_en=57c1131c9fd2f85b8e45be1699e5b66a sig_cn_org=None source=14.1 
   <para>
    The <parameter>stride</parameter> interval must be greater than zero and
    cannot contain units of month or larger.
   </para>
________________________________________________________-->
   <para>
    <parameter>stride</parameter> 时间间隔必须大于零，并且不能包含月或更大的单位。
   </para>
<!-- pgdoc-cn_end sig_en=57c1131c9fd2f85b8e45be1699e5b66a -->
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

<!-- pgdoc-cn_start sig_en=aba60f9f2ac715a8b2f1ab9bcca2d78d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=aba60f9f2ac715a8b2f1ab9bcca2d78d -->

<!-- pgdoc-cn_start sig_en=cf90703459d353ffd85b0d45c063c4fa sig_cn_org=None source=14.1 
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cf90703459d353ffd85b0d45c063c4fa -->

<!-- pgdoc-cn_start sig_en=d57a6d9f780bce674370050d8ea20c8d sig_cn_org=None source=14.1 
   <para>
    The <literal>AT TIME ZONE</literal> operator converts time
    stamp <emphasis>without</emphasis> time zone to/from
    time stamp <emphasis>with</emphasis> time zone, and
    <type>time with time zone</type> values to different time
    zones. <xref linkend="functions-datetime-zoneconvert-table"/> shows its
    variants.
   </para>
________________________________________________________-->
   <para>
    <literal>AT TIME ZONE</literal>把时间戳<emphasis>without</emphasis>时区转换成时间戳<emphasis>with</emphasis>时区或者反过来，并且把<type>time with time zone</type>值转换成不同的时区。<xref linkend="functions-datetime-zoneconvert-table"/>展示了它的变体。
   </para>
<!-- pgdoc-cn_end sig_en=d57a6d9f780bce674370050d8ea20c8d -->

    <table id="functions-datetime-zoneconvert-table">
<!-- pgdoc-cn_start sig_en=71d4564863f07643988d1ab286227b50 sig_cn_org=None source=14.1 
     <title><literal>AT TIME ZONE</literal> Variants</title>
________________________________________________________-->
     <title><literal>AT TIME ZONE</literal>变体</title>
<!-- pgdoc-cn_end sig_en=71d4564863f07643988d1ab286227b50 -->
     <tgroup cols="1">
      <thead>
<!-- pgdoc-cn_start sig_en=656006cda31d1fe93de4c2121ac304f8 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=656006cda31d1fe93de4c2121ac304f8 -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=069df0c89e580d93fbe78c45d3b22fe4 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>without</emphasis> time zone to
         time stamp <emphasis>with</emphasis> time zone, assuming the given
         value is in the named time zone.
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>without</emphasis>时区转换为时间戳<emphasis>with</emphasis>时区，假设给定的值在指定的时区内。
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=069df0c89e580d93fbe78c45d3b22fe4 -->

<!-- pgdoc-cn_start sig_en=6f7827da1a85579857d02cffab3624aa sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>with</emphasis> time zone to
         time stamp <emphasis>without</emphasis> time zone, as the time would
         appear in that zone.
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>with</emphasis>时区转换为时间戳<emphasis>without</emphasis>时区，因为时间将出现在该时区中
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=6f7827da1a85579857d02cffab3624aa -->

<!-- pgdoc-cn_start sig_en=f504f81c20911cdc624ea9ad4a962635 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Converts given time <emphasis>with</emphasis> time zone to a new time
         zone.  Since no date is supplied, this uses the currently active UTC
         offset for the named destination zone.
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         将给定的时间<emphasis>with</emphasis>时区转换为新的时区。由于没有提供日期，这将使用指定目的区域的当前活动UTC偏移量。
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=f504f81c20911cdc624ea9ad4a962635 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=a95b74aec01ca31b6d27cfc32252e99c sig_cn_org=None source=14.1 
   <para>
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text value (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
    The interval case is only useful for zones that have fixed offsets from
    UTC, so it is not very common in practice.
   </para>
________________________________________________________-->
   <para>
    在这些表达式里，我们需要的时区<replaceable>zone</replaceable>可以指定为文本值（例如，<literal>'America/Los_Angeles'</literal>）或者一个间隔 （例如，<literal>INTERVAL '-08:00'</literal>）。
    在文本情况下，可用的时区名字可以用<xref linkend="datatype-timezones"/>中描述的任何方式指定。
    时间区间只适用于与UTC有固定偏移量的区域，因此在实践中并不常见。
   </para>
<!-- pgdoc-cn_end sig_en=a95b74aec01ca31b6d27cfc32252e99c -->

<!-- pgdoc-cn_start sig_en=86e2c05c99df4382405666d74041bb98 sig_cn_org=ddf3e276326413b5f35f574b70cb5e65 source=15.7 
   <para>
    Examples (assuming the current <xref linkend="guc-timezone"/> setting
    is <literal>America/Los_Angeles</literal>):
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>
SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.
   </para>
________________________________________________________-->
   <para>
    例子（假设当前的<xref linkend="guc-timezone"/>设置为<literal>America/Los_Angeles</literal>）：
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>
SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    第一个例子为缺少时区的值添加时区，并使用当前的<varname>TimeZone</varname>设置显示该值。
    第二个例子将带有时区的时间戳值转移到指定的时区，并返回没有时区的值。
    这允许存储和显示与当前<varname>TimeZone</varname>设置不同的值。第三个例子将东京时间转换为芝加哥时间。
   </para>
<!-- pgdoc-cn_end sig_en=86e2c05c99df4382405666d74041bb98 -->

<!-- pgdoc-cn_start sig_en=bcc6eb169b2900cac1973f0b63c58eb4 sig_cn_org=None source=14.1 
   <para>
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
   </para>
________________________________________________________-->
   <para>
    函数<literal><function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)</literal>等效于 SQL 兼容的结构<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>。
   </para>
<!-- pgdoc-cn_end sig_en=bcc6eb169b2900cac1973f0b63c58eb4 -->
  </sect2>

  <sect2 id="functions-datetime-current">
<!-- pgdoc-cn_start sig_en=ed4d60e5f9dc220b64731d06f160a808 sig_cn_org=None source=14.1 
   <title>Current Date/Time</title>
________________________________________________________-->
   <title>当前日期/时间</title>
<!-- pgdoc-cn_end sig_en=ed4d60e5f9dc220b64731d06f160a808 -->

<!-- pgdoc-cn_start sig_en=3bf65b586a45012f4bbddd2db89fa822 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3bf65b586a45012f4bbddd2db89fa822 -->

<!-- pgdoc-cn_start sig_en=77e4fbd7e4cb108d7b2e3fadca36c277 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=77e4fbd7e4cb108d7b2e3fadca36c277 -->

<!-- pgdoc-cn_start sig_en=73ecbecc326b12b91e61aeb0c32a32f3 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了许多返回当前日期和时间的函数。这些 SQL 标准的函数全部都按照当前事务的开始时刻返回值：
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=73ecbecc326b12b91e61aeb0c32a32f3 -->

<!-- pgdoc-cn_start sig_en=027e47835e800b9b62e6a6a0d4b63fe9 sig_cn_org=None source=14.1 
    <para>
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
    </para>
________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>和<function>CURRENT_TIMESTAMP</function>传递带有时区的值；<function>LOCALTIME</function>和<function>LOCALTIMESTAMP</function>传递的值不带时区。
    </para>
<!-- pgdoc-cn_end sig_en=027e47835e800b9b62e6a6a0d4b63fe9 -->

<!-- pgdoc-cn_start sig_en=0d26ebe2d9840dedc3b3a8b26c3b63d4 sig_cn_org=None source=14.1 
    <para>
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
    </para>
________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>和 <function>LOCALTIMESTAMP</function>可以有选择地接受一个精度参数， 该精度导致结果的秒域被园整为指定小数位。如果没有精度参数，结果将被给予所能得到的全部精度。
    </para>
<!-- pgdoc-cn_end sig_en=0d26ebe2d9840dedc3b3a8b26c3b63d4 -->

<!-- pgdoc-cn_start sig_en=715a029bfb1e126ddaf6633a8cb244c2 sig_cn_org=613cb164a35ec6a248e7eb91dab02a50 source=15.7 
   <para>
    Some examples:
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>
SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23</computeroutput>
SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>
SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>
SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>
________________________________________________________-->
   <para>
    一些示例:
<screen>
SELECT CURRENT_TIME;
<lineannotation>结果: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>
SELECT CURRENT_DATE;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23</computeroutput>
SELECT CURRENT_TIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>
SELECT CURRENT_TIMESTAMP(2);
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>
SELECT LOCALTIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=715a029bfb1e126ddaf6633a8cb244c2 -->

<!-- pgdoc-cn_start sig_en=8989bc86360eff704284560b300b1ff4 sig_cn_org=None source=14.1 
   <para>
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
   </para>
________________________________________________________-->
   <para>
    因为这些函数全部都按照当前事务的开始时刻返回结果，所以它们的值在事务运行的整个期间内都不改变。 我们认为这是一个特性：目的是为了允许一个事务在<quote>当前</quote>时间上有一致的概念， 这样在同一个事务里的多个修改可以保持同样的时间戳。
   </para>
<!-- pgdoc-cn_end sig_en=8989bc86360eff704284560b300b1ff4 -->

   <note>
<!-- pgdoc-cn_start sig_en=65e2224b2b249e93a523e2f5d3016f1e sig_cn_org=None source=14.1 
    <para>
     Other database systems might advance these values more
     frequently.
    </para>
________________________________________________________-->
    <para>
     许多其它数据库系统可能会更频繁地推进这些值。
    </para>
<!-- pgdoc-cn_end sig_en=65e2224b2b249e93a523e2f5d3016f1e -->
   </note>

<!-- pgdoc-cn_start sig_en=42a7bda305926a663f2c3fe68b3c3c69 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>还提供了返回当前语句的开始时间以及
    调用该函数时的实际当前时间的函数。这些非 SQL 标准的函数列表如下：
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=42a7bda305926a663f2c3fe68b3c3c69 -->

<!-- pgdoc-cn_start sig_en=525017832d33f5e5cc638db7afb7b8a9 sig_cn_org=None source=14.1 
   <para>
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
   </para>
________________________________________________________-->
   <para>
    <function>transaction_timestamp()</function>等价于<function>CURRENT_TIMESTAMP</function>，但是其命名清楚地反映了它的返回值。<function>statement_timestamp()</function>返回当前语句的开始时刻（更准确的说是收到 客户端最后一条命令的时间）。<function>statement_timestamp()</function>和<function>transaction_timestamp()</function>在一个事务的第一条命令期间返回值相同，但是在随后的命令中却不一定相同。 <function>clock_timestamp()</function>返回真正的当前时间，因此它的值甚至在同一条 SQL 命令中都会变化。<function>timeofday()</function>是一个有历史原因的<productname>PostgreSQL</productname>函数。和<function>clock_timestamp()</function>相似，<function>timeofday()</function>也返回真实的当前时间，但是它的结果是一个格式化的<type>text</type>串，而不是<type>timestamp with time zone</type>值。<function>now()</function>是<productname>PostgreSQL</productname>的一个传统，等效于<function>transaction_timestamp()</function>。
   </para>
<!-- pgdoc-cn_end sig_en=525017832d33f5e5cc638db7afb7b8a9 -->

<!-- pgdoc-cn_start sig_en=a9d76bd717eb245a01fe51d5d4e0e79d sig_cn_org=None source=14.1 
   <para>
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -&minus; but see tip below
</programlisting>
   </para>
________________________________________________________-->
   <para>
    所有日期/时间类型还接受特殊的文字值<literal>now</literal>，用于指定当前的日期和时间（重申，被解释为当前事务的开始时刻）。 因此，下面三个都返回相同的结果：
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- 但请参阅下面的提示
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a9d76bd717eb245a01fe51d5d4e0e79d -->

    <tip>
<!-- pgdoc-cn_start sig_en=6ee68ca7541b2425c60fb8c20071adc6 sig_cn_org=None source=14.1 
     <para>
      Do not use the third form when specifying a value to be evaluated later,
      for example in a <literal>DEFAULT</literal> clause for a table column.
      The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
      (See also <xref linkend="datatype-datetime-special-values"/>.)
     </para>
________________________________________________________-->
     <para>
      当指定以后要计算的值时，不要使用第三种形式，例如在表列的<literal>DEFAULT</literal>子句中。
      系统将在分析这个常量的时候把<literal>now</literal>转换为一个<type>timestamp</type>， 这样需要默认值时就会得到创建表的时间！而前两种形式要到实际使用缺省值的时候才被计算， 因为它们是函数调用。因此它们可以给出每次插入行的时刻。
      （参见 <xref linkend="datatype-datetime-special-values"/>。）
     </para>
<!-- pgdoc-cn_end sig_en=6ee68ca7541b2425c60fb8c20071adc6 -->
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!-- pgdoc-cn_start sig_en=00806eeefb9f0b5b665d4e7dba7e9612 sig_cn_org=None source=14.1 
   <title>Delaying Execution</title>
________________________________________________________-->
   <title>延时执行</title>
<!-- pgdoc-cn_end sig_en=00806eeefb9f0b5b665d4e7dba7e9612 -->

<!-- pgdoc-cn_start sig_en=3918e2ae8af8918a5cf5dfd7c70ab9fb sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3918e2ae8af8918a5cf5dfd7c70ab9fb -->
<!-- pgdoc-cn_start sig_en=7d4b83c30a1beeeb59e61558e947cb36 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7d4b83c30a1beeeb59e61558e947cb36 -->
<!-- pgdoc-cn_start sig_en=2665217c69cf15b81e517e11230d1afe sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2665217c69cf15b81e517e11230d1afe -->
<!-- pgdoc-cn_start sig_en=1fa9ad8f6f30e5d420c8ed02fa6c5e5b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1fa9ad8f6f30e5d420c8ed02fa6c5e5b -->
<!-- pgdoc-cn_start sig_en=2f353e8581678edbe6b011f47ae4bfa7 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>delay</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>delay</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2f353e8581678edbe6b011f47ae4bfa7 -->

<!-- pgdoc-cn_start sig_en=e25092690746607eb88fdd16161d3e31 sig_cn_org=None source=14.1 
   <para>
    The following functions are available to delay execution of the server
    process:
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function> makes the current session's process
    sleep until the given number of seconds have
    elapsed.  Fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function to
    allow the sleep time to be specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>
________________________________________________________-->
   <para>
    下面的这些函数可以用于让服务器进程延时执行：
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function>使当前会话的进程休眠，直到过去给定的秒数。可以指定几分之一秒的延迟。
    <function>pg_sleep_for</function>是一个方便的函数，允许将睡眠时间指定为时间间隔。
    <function>pg_sleep_until</function>是一个方便的函数，用于需要特定的唤醒时间。例如：

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e25092690746607eb88fdd16161d3e31 -->

   <note>
<!-- pgdoc-cn_start sig_en=34bb66e45ee0a404ce73b16253d4b5d8 sig_cn_org=None source=14.1 
     <para>
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
     </para>
________________________________________________________-->
     <para>
      有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用值。休眠延迟将至少持续指
      定的时长， 也有可能由于服务器负荷而比指定的时间长。特别地，
      <function>pg_sleep_until</function>并不保证能刚好在指定的时刻被唤醒，但它不会
      在比指定时刻早的时候醒来。
     </para>
<!-- pgdoc-cn_end sig_en=34bb66e45ee0a404ce73b16253d4b5d8 -->
   </note>

   <warning>
<!-- pgdoc-cn_start sig_en=130d9b79482aafdce8fa16ce192af31a sig_cn_org=None source=14.1 
     <para>
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
     </para>
________________________________________________________-->
     <para>
      请确保在调用<function>pg_sleep</function>或者其变体时，你的会话没有持有不必要
      的锁。否则其它会话可能必须等待你的休眠会话，因而减慢整个系统速度。
     </para>
<!-- pgdoc-cn_end sig_en=130d9b79482aafdce8fa16ce192af31a -->
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!-- pgdoc-cn_start sig_en=f98f436c2776a28ed63b37a84bb8e9a9 sig_cn_org=None source=14.1 
  <title>Enum Support Functions</title>
________________________________________________________-->
  <title>枚举支持函数</title>
<!-- pgdoc-cn_end sig_en=f98f436c2776a28ed63b37a84bb8e9a9 -->

<!-- pgdoc-cn_start sig_en=8178aecd6e8681de112e3590ad0f777f sig_cn_org=None source=14.1 
  <para>
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>
________________________________________________________-->
  <para>
   对于枚举类型(在<xref linkend="datatype-enum"/>中描述）， 有一些函数允许更清洁的编码，而不需要为一个枚举类型硬写特定的值。它们被列在<xref linkend="functions-enum-table"/>中。本例假定一个枚举类型被创建为：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>
<!-- pgdoc-cn_end sig_en=8178aecd6e8681de112e3590ad0f777f -->

  <table id="functions-enum-table">
<!-- pgdoc-cn_start sig_en=f98f436c2776a28ed63b37a84bb8e9a9 sig_cn_org=None source=14.1 
    <title>Enum Support Functions</title>
________________________________________________________-->
    <title>枚举支持函数</title>
<!-- pgdoc-cn_end sig_en=f98f436c2776a28ed63b37a84bb8e9a9 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=f42c561bcf8578d4554b8bbf62f36855 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the first value of the input enum type.
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的第一个值。
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f42c561bcf8578d4554b8bbf62f36855 -->
<!-- pgdoc-cn_start sig_en=a45b721227f81e478fbbd30a40a80afe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the last value of the input enum type.
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的最后一个值。
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a45b721227f81e478fbbd30a40a80afe -->
<!-- pgdoc-cn_start sig_en=763e257123cef19918be8c952459ce3b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns all values of the input enum type in an ordered array.
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将输入枚举类型的所有值作为一个有序的数组返回。
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=763e257123cef19918be8c952459ce3b -->
<!-- pgdoc-cn_start sig_en=b4b967b00c32463b374ea5d04f42a7d8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 
        如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b4b967b00c32463b374ea5d04f42a7d8 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=9cad2acaed5f32f2ec6e57d5befa0b2c sig_cn_org=None source=14.1 
   <para>
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as used in the examples.
   </para>
________________________________________________________-->
   <para>
    请注意，除了双参数形式的<function>enum_range</function>外， 这些函数忽略传递给它们的具体值，它们只关心声明的数据类型。 
    空值或类型的一个特定值可以通过，并得到相同的结果。这些函数更多地被用于一个表列或函数参数，而不是一个硬写的类型名，如例子中所使用。
   </para>
<!-- pgdoc-cn_end sig_en=9cad2acaed5f32f2ec6e57d5befa0b2c -->
 </sect1>

 <sect1 id="functions-geometry">
<!-- pgdoc-cn_start sig_en=4d9207b46b57700874f66499dafd3835 sig_cn_org=None source=14.1 
  <title>Geometric Functions and Operators</title>
________________________________________________________-->
  <title>几何函数和操作符</title>
<!-- pgdoc-cn_end sig_en=4d9207b46b57700874f66499dafd3835 -->

<!-- pgdoc-cn_start sig_en=b4df84263a440f70bd066968b2465577 sig_cn_org=None source=14.1 
   <para>
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
   </para>
________________________________________________________-->
   <para>
    几何类型<type>point</type>、<type>box</type>、
    <type>lseg</type>、<type>line</type>、<type>path</type>、
    <type>polygon</type>和<type>circle</type>有一大堆本地支持函数和操作符，如<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>和<xref linkend="functions-geometry-conv-table"/>中所示。
   </para>
<!-- pgdoc-cn_end sig_en=b4df84263a440f70bd066968b2465577 -->

   <table id="functions-geometry-op-table">
<!-- pgdoc-cn_start sig_en=e696777e6d8c042923ebd4c98481ef2f sig_cn_org=None source=14.1 
    <title>Geometric Operators</title>
________________________________________________________-->
    <title>几何操作符</title>
<!-- pgdoc-cn_end sig_en=e696777e6d8c042923ebd4c98481ef2f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=25a0343d66a93dfbad95c42c4af6bc27 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Adds the coordinates of the second <type>point</type> to those of each
        point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第二个<type>point</type>的坐标添加到第一个参数的每个点的坐标中，从而执行翻译。
        适用于 <type>point</type>、<type>box</type>、<type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=25a0343d66a93dfbad95c42c4af6bc27 -->

<!-- pgdoc-cn_start sig_en=b3d47c3128f7d6fc25a1c677afa93f2a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Concatenates two open paths (returns NULL if either path is closed).
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        连接两个打开的路径(如果其中一个路径是关闭的，则返回NULL)。
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b3d47c3128f7d6fc25a1c677afa93f2a -->

<!-- pgdoc-cn_start sig_en=43ef01ee4f733ba2e7b17ed7e855ab45 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtracts the coordinates of the second <type>point</type> from those
        of each point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        从第一个参数的每个点的坐标中减去第二个<type>point</type>的坐标，从而执行翻译。
        适用于 <type>point</type>、 <type>box</type>、 <type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=43ef01ee4f733ba2e7b17ed7e855ab45 -->

<!-- pgdoc-cn_start sig_en=56681de6f5d755c6badbb26c6432505b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplies each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex multiplication).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin by the length
        of the vector, and rotating it counterclockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> a
        box with these operators only moves its corner points: the box is
        still considered to have sides parallel to the axes.  Hence the box's
        size is not preserved, as a true rotation would do.</para></footnote>
        <type>path</type>, <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第一个参数的每个点乘上第二个point(将点视为由实部和虚部表示的复数，并执行标准的复数乘法)。
        如果将第二个<type>point</type>解释为向量，这等价于将对象的大小和到原点的距离按向量的长度缩放，并以向量与<replaceable>x</replaceable>轴的夹角绕原点逆时针旋转。
        适用于<type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> 用这些操作符“旋转”一个盒子，只会移动它的角点:这个盒子仍然被认为有平行于轴的边。
        因此，盒子的大小并没有像真正的旋转那样得到保留。</para></footnote>
        <type>path</type>, <type>circle</type>.。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=56681de6f5d755c6badbb26c6432505b -->

<!-- pgdoc-cn_start sig_en=2b081122ccd396f574bbd82b11736540 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Divides each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex division).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin down by the
        length of the vector, and rotating it clockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnoteref
        linkend="functions-geometry-rotation-fn"/> <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第一个参数的每个点除以第二个<type>point</type>(将点视为由实部和虚部表示的复数，并执行标准的复数除法)。
        如果将第二个<type>point</type>解释为向量，这等价于将物体的大小和到原点的距离按向量的长度向下缩放，并以向量与<replaceable>x</replaceable>轴的夹角围绕原点顺时针旋转。
        适用于 <type>point</type>, <type>box</type>,<footnoteref linkend="functions-geometry-rotation-fn"/> <type>path</type>,<type>circle</type>。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2b081122ccd396f574bbd82b11736540 -->

<!-- pgdoc-cn_start sig_en=8c7925d661aaecf290bf85ca5618faf0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c7925d661aaecf290bf85ca5618faf0 -->

<!-- pgdoc-cn_start sig_en=dbb93050ec81b50bdc6ad37fe5db872d sig_cn_org=275c4cb12ba6c9dd4525aac7fd6d42cc source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the center point.
        Available for <type>box</type>, <type>lseg</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。
        适用于<type>box</type>，<type>lseg</type>，
        <type>polygon</type>，<type>circle</type>。
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbb93050ec81b50bdc6ad37fe5db872d -->

<!-- pgdoc-cn_start sig_en=d4753f58e05d40be783cc92193d2a692 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4753f58e05d40be783cc92193d2a692 -->

<!-- pgdoc-cn_start sig_en=a2b98aec6c6c83239881278281ff3ead sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the point of intersection, or NULL if there is none.
        Available for <type>lseg</type>, <type>line</type>.
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算交点，如果没有则为NULL。适用于 <type>lseg</type>, <type>line</type>。
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2b98aec6c6c83239881278281ff3ead -->

<!-- pgdoc-cn_start sig_en=3e95af3b974d4ece89c50307b7585e3e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes the intersection of two boxes, or NULL if there is none.
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的交集，如果没有则为NULL。
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3e95af3b974d4ece89c50307b7585e3e -->

<!-- pgdoc-cn_start sig_en=65630780b25f4ee068006716ade1eb16 sig_cn_org=422cbe9e0cc9d4adfccf5c85caf53701 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the closest point to the first object on the second object.
        Available for these pairs of types:
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算第一个对象上距离第二个对象最近的点。
        可用于以下类型的配对：
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=65630780b25f4ee068006716ade1eb16 -->

<!-- pgdoc-cn_start sig_en=8ea2bfe23fe3dc438f4106c492349705 sig_cn_org=1819e6059996cac0b8dc167eefe9f5e3 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the distance between the objects.
        Available for all seven geometric types, for all combinations
        of <type>point</type> with another geometric type, and for
        these additional pairs of types:
        (<type>box</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (and the commutator cases).
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>双精度</returnvalue>
       </para>
       <para>
        计算对象之间的距离。
        对于所有七种几何类型，所有<type>point(点)</type>与另一种几何类型的组合，
        以及以下这些额外的类型对：
        (<type>box(盒)</type>, <type>lseg(线段)</type>),
        (<type>lseg(线段)</type>, <type>line(线)</type>),
        (<type>polygon(多边形)</type>, <type>circle(圆)</type>)
        （以及交换位置的情况）。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8ea2bfe23fe3dc438f4106c492349705 -->

<!-- pgdoc-cn_start sig_en=483e99cb97b943b8bb02bd0bc54c59c6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object contain second?
        Available for these pairs of types:
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含第二个对象吗? 适用于这些类型对：
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=483e99cb97b943b8bb02bd0bc54c59c6 -->

<!-- pgdoc-cn_start sig_en=a9847b423f2992557b8c65ec06843656 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object contained in or on second?
        Available for these pairs of types:
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含在第二个对象之中还是在第二个对象之上? 适用于这些类型对：
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a9847b423f2992557b8c65ec06843656 -->

<!-- pgdoc-cn_start sig_en=4b2c739ed41a17cb2073d201f72d2714 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects overlap?  (One point in common makes this true.)
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象有重叠吗?(一个共同点使之为真。)
        适用于 <type>box</type>、<type>polygon</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4b2c739ed41a17cb2073d201f72d2714 -->

<!-- pgdoc-cn_start sig_en=159df4124fbf71f7b333a9c4927ad9d8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly left of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的左边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=159df4124fbf71f7b333a9c4927ad9d8 -->

<!-- pgdoc-cn_start sig_en=38a1b7f4e81b259b5df0298175c7a4bc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly right of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的右边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=38a1b7f4e81b259b5df0298175c7a4bc -->

<!-- pgdoc-cn_start sig_en=ae662beae3e162d77caed1a831e9ece7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the right of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的右侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ae662beae3e162d77caed1a831e9ece7 -->

<!-- pgdoc-cn_start sig_en=14fc3d2ac1b8c839c76bbc05db800e43 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the left of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的左侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=14fc3d2ac1b8c839c76bbc05db800e43 -->

<!-- pgdoc-cn_start sig_en=1b0ddaf5999e5d85a2210213e50baeba sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly below second?
        Available for <type>point</type>, <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象下面?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1b0ddaf5999e5d85a2210213e50baeba -->

<!-- pgdoc-cn_start sig_en=bb7da725a7ede5ceb1883a0c0a91a068 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly above second?
        Available for <type>point</type>, <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象上面?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bb7da725a7ede5ceb1883a0c0a91a068 -->

<!-- pgdoc-cn_start sig_en=0ee234db3b2dbdb4ed7936ee0e396e89 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象上面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0ee234db3b2dbdb4ed7936ee0e396e89 -->

<!-- pgdoc-cn_start sig_en=47444455879cc40794d2a606624893cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象下面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=47444455879cc40794d2a606624893cb -->

<!-- pgdoc-cn_start sig_en=501dd4d350267a6185623f2675dbca80 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object below second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象下面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=501dd4d350267a6185623f2675dbca80 -->

<!-- pgdoc-cn_start sig_en=09ea16ac69aaebcf1b70314c0abd6ceb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object above second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象上面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=09ea16ac69aaebcf1b70314c0abd6ceb -->

<!-- pgdoc-cn_start sig_en=3e05916bc182ec51f33612ba6345f396 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects intersect?
        Available for these pairs of types:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是否相交? 适用于这些类型对:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3e05916bc182ec51f33612ba6345f396 -->

<!-- pgdoc-cn_start sig_en=8f114475e19b4cf2d9fa7663f4456b04 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line horizontal?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是水平的?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8f114475e19b4cf2d9fa7663f4456b04 -->

<!-- pgdoc-cn_start sig_en=f8d557ad14b56de26433aaa2475d2dd3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points horizontally aligned (that is, have same y coordinate)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否水平对齐(即具有相同的y坐标)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8d557ad14b56de26433aaa2475d2dd3 -->

<!-- pgdoc-cn_start sig_en=33704dec4ac67b9d7c84967a33d0461a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line vertical?
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是纵向的的？
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=33704dec4ac67b9d7c84967a33d0461a -->

<!-- pgdoc-cn_start sig_en=79b6be631a35d6eee486bb46ddc9ad9f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points vertically aligned (that is, have same x coordinate)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否垂直对齐(即具有相同的x坐标)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=79b6be631a35d6eee486bb46ddc9ad9f -->

<!-- pgdoc-cn_start sig_en=624b7b051c7f8071b358f875e5f60995 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines perpendicular?
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是垂直的？
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=624b7b051c7f8071b358f875e5f60995 -->

<!-- pgdoc-cn_start sig_en=aeed29767ac42293a9b38ae741d63065 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines parallel?
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是平行的？
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aeed29767ac42293a9b38ae741d63065 -->

<!-- pgdoc-cn_start sig_en=0ca3983cf803785dbdb7008fe1bb10a1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are these objects the same?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是相同的吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0ca3983cf803785dbdb7008fe1bb10a1 -->
     </tbody>
    </tgroup>
   </table>

   <caution>
<!-- pgdoc-cn_start sig_en=ab5ec3d82400442a5ccac6b704cfd844 sig_cn_org=None source=14.1 
    <para>
     Note that the <quote>same as</quote> operator, <literal>~=</literal>,
     represents the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of the geometric types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares for equal <emphasis>areas</emphasis> only.
     The other scalar comparison operators (<literal>&lt;=</literal> and so
     on), where available for these types, likewise compare areas.
    </para>
________________________________________________________-->
    <para>
     请注意<quote>same as</quote>操作符（<literal>~=</literal>），表示<type>point</type>、<type>box</type>、<type>polygon</type>和<type>circle</type>类型的一般相等概念。
     这些类型中的某些还有一个<literal>=</literal>操作符，但是<literal>=</literal>只比较相同的<emphasis>面积</emphasis>。
     其它的标量比较操作符 （<literal>&lt;=</literal>等等），在这些类型可用的地方，同样比较区域。
    </para>
<!-- pgdoc-cn_end sig_en=ab5ec3d82400442a5ccac6b704cfd844 -->
   </caution>

   <note>
<!-- pgdoc-cn_start sig_en=8a01a1d9c2baaf576322009522f90b8d sig_cn_org=None source=14.1 
    <para>
     Before <productname>PostgreSQL</productname> 14, the point
     is strictly below/above comparison operators <type>point</type>
     <literal>&lt;&lt;|</literal> <type>point</type> and <type>point</type>
     <literal>|&gt;&gt;</literal> <type>point</type> were respectively
     called <literal>&lt;^</literal> and <literal>&gt;^</literal>.  These
     names are still available, but are deprecated and will eventually be
     removed.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>14之前， 该点严格低于/高于比较操作符 <type>point</type> <literal>&lt;&lt;|</literal> <type>point</type> 和 <type>point</type> <literal>|&gt;&gt;</literal> <type>point</type> 分别被称为 <literal>&lt;^</literal> 和 <literal>&gt;^</literal>。
     这些名字仍然可以使用，但是已被弃用并且最终将被移除。
    </para>
<!-- pgdoc-cn_end sig_en=8a01a1d9c2baaf576322009522f90b8d -->
   </note>

   <table id="functions-geometry-func-table">
<!-- pgdoc-cn_start sig_en=b0e91bdcbf8e39a3bede32af8f6b3dc1 sig_cn_org=None source=14.1 
    <title>Geometric Functions</title>
________________________________________________________-->
    <title>几何函数</title>
<!-- pgdoc-cn_end sig_en=b0e91bdcbf8e39a3bede32af8f6b3dc1 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=34c4ebbfe1b4f94c322cb1d00860df9a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes area.
        Available for <type>box</type>, <type>path</type>, <type>circle</type>.
        A <type>path</type> input must be closed, else NULL is returned.
        Also, if the <type>path</type> is self-intersecting, the result may be
        meaningless.
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算面积。适用于 <type>box</type>, <type>path</type>, <type>circle</type>。
        <type>path</type> 输入必须封闭，否则返回NULL。同样，如果 <type>path</type> 是自交叉的，结果可能是没有意义的。
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=34c4ebbfe1b4f94c322cb1d00860df9a -->

<!-- pgdoc-cn_start sig_en=0c8aa0ddccb650905126fcbd1cf42db2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center point.
        Available for <type>box</type>, <type>circle</type>.
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。适用于 <type>box</type>, <type>circle</type>。
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0c8aa0ddccb650905126fcbd1cf42db2 -->

<!-- pgdoc-cn_start sig_en=361aa47abbb69d8796c15298766b9727 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment
        (same as <function>lseg(box)</function>).
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        提取框的对角线作为线段（与 <function>lseg(box)</function>相同）。
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=361aa47abbb69d8796c15298766b9727 -->

<!-- pgdoc-cn_start sig_en=209b20dd3bb068ace282af4dfaad5a73 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes diameter of circle.
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的直径。
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=209b20dd3bb068ace282af4dfaad5a73 -->

<!-- pgdoc-cn_start sig_en=771cc0cd2a1480d52a68c22398ed518a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes vertical size of box.
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的垂直尺寸。
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=771cc0cd2a1480d52a68c22398ed518a -->

<!-- pgdoc-cn_start sig_en=56cc30b25671c90f391512d1a686db9d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path closed?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否封闭?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=56cc30b25671c90f391512d1a686db9d -->

<!-- pgdoc-cn_start sig_en=e9bdeb4508a1aa79357de7fb42e2a6db sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path open?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否开放?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e9bdeb4508a1aa79357de7fb42e2a6db -->

<!-- pgdoc-cn_start sig_en=383866b43a97cbb7dc9bb36e0e08ab0c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>。
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=383866b43a97cbb7dc9bb36e0e08ab0c -->

<!-- pgdoc-cn_start sig_en=7fc1074672ba2005f59d38d7f74b445e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7fc1074672ba2005f59d38d7f74b445e -->

<!-- pgdoc-cn_start sig_en=d387764dc0102c0ca604af5dcc76651a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to closed form.
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为封闭形式。
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d387764dc0102c0ca604af5dcc76651a -->

<!-- pgdoc-cn_start sig_en=2d631513050449be2b67e10026fc2adf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to open form.
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为开放形式。
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2d631513050449be2b67e10026fc2adf -->

<!-- pgdoc-cn_start sig_en=295d94dde855bb1618b9e9dd466b7ee5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes radius of circle.
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的半径。
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=295d94dde855bb1618b9e9dd466b7ee5 -->

<!-- pgdoc-cn_start sig_en=8bb3af1cdc3d8c1629cf5605da297322 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes slope of a line drawn through the two points.
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算通过两点所画直线的斜率。
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8bb3af1cdc3d8c1629cf5605da297322 -->

<!-- pgdoc-cn_start sig_en=fdab44ef2aa0cb6444c6250976c7743b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes horizontal size of box.
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的水平大小。
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fdab44ef2aa0cb6444c6250976c7743b -->
     </tbody>
    </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!-- pgdoc-cn_start sig_en=41d1e299c5d3e3bf0f9b97e86dbc9882 sig_cn_org=None source=14.1 
    <title>Geometric Type Conversion Functions</title>
________________________________________________________-->
    <title>几何类型转换函数</title>
<!-- pgdoc-cn_end sig_en=41d1e299c5d3e3bf0f9b97e86dbc9882 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>
     <tbody>

<!-- pgdoc-cn_start sig_en=3edb7add209f106c3f20b948af4fac14 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes box inscribed within the circle.
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算框中内刻的圆形。
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3edb7add209f106c3f20b948af4fac14 -->

<!-- pgdoc-cn_start sig_en=3e2cf8534b0e71c429a3888991dc9a89 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts point to empty box.
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将点转换为空框。
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3e2cf8534b0e71c429a3888991dc9a89 -->

<!-- pgdoc-cn_start sig_en=fa827c6ede2a12c5eed24486da69528e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts any two corner points to box.
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将任意两个角点转换为框。
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fa827c6ede2a12c5eed24486da69528e -->

<!-- pgdoc-cn_start sig_en=3ec9fd9197fea74c5413c40fc82c8514 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of polygon.
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算多边形的边界框。
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3ec9fd9197fea74c5413c40fc82c8514 -->

<!-- pgdoc-cn_start sig_en=f09b09d4a13e3002d619236cc249f162 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of two boxes.
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的边界框。
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f09b09d4a13e3002d619236cc249f162 -->

<!-- pgdoc-cn_start sig_en=844dd3ae8f253cd7157912739759a579 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Computes smallest circle enclosing box.
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        计算最小的圆形包围框。
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=844dd3ae8f253cd7157912739759a579 -->

<!-- pgdoc-cn_start sig_en=eb573cf0c9f3f9d7358c7ca10d9196d9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Constructs circle from center and radius.
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        从圆心和半径构造圆。
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eb573cf0c9f3f9d7358c7ca10d9196d9 -->

<!-- pgdoc-cn_start sig_en=cf6b10a70028cc6f392ec876dba06e73 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Converts polygon to circle.  The circle's center is the mean of the
        positions of the polygon's points, and the radius is the average
        distance of the polygon's points from that center.
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        将多边形转换为圆。圆心是多边形各点位置的平均值，半径是多边形各点到圆心的平均距离。
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cf6b10a70028cc6f392ec876dba06e73 -->

<!-- pgdoc-cn_start sig_en=4c163e8c17c3f558743a3554bd648a05 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        Converts two points to the line through them.
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        将两个点转换成通过它们的直线。
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c163e8c17c3f558743a3554bd648a05 -->

<!-- pgdoc-cn_start sig_en=8edd268c2c7b003ef049620da5f66f7c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment.
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        提取框的对角线作为线段。
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8edd268c2c7b003ef049620da5f66f7c -->

<!-- pgdoc-cn_start sig_en=28be7493459b7faa60d1c3fd55762843 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Constructs line segment from two endpoints.
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        从两个端点构造线段。
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28be7493459b7faa60d1c3fd55762843 -->

<!-- pgdoc-cn_start sig_en=b340f1fe5fb303f8652ff85680ca50fe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts polygon to a closed path with the same list of points.
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将多边形转换为具有点的相同列表的封闭路径。
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b340f1fe5fb303f8652ff85680ca50fe -->

<!-- pgdoc-cn_start sig_en=728c466fc9e9a38d49f4107add62f50b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Constructs point from its coordinates.
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        从它的坐标构造点。
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=728c466fc9e9a38d49f4107add62f50b -->

<!-- pgdoc-cn_start sig_en=bd8863b158579199898a817a0223d883 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of box.
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算框的中心。
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bd8863b158579199898a817a0223d883 -->

<!-- pgdoc-cn_start sig_en=6d57cbb159caa3172c457b527659dc53 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of circle.
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算圆心。
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6d57cbb159caa3172c457b527659dc53 -->

<!-- pgdoc-cn_start sig_en=8171f8280a69c4353873499c4d984e13 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of line segment.
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算线段的中心。
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8171f8280a69c4353873499c4d984e13 -->

<!-- pgdoc-cn_start sig_en=3b1ba2f59ed194aef88fde0cc4f453fb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of polygon (the mean of the
        positions of the polygon's points).
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算多边形的中心（多边形的点位置的平均值）。
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b1ba2f59ed194aef88fde0cc4f453fb -->

<!-- pgdoc-cn_start sig_en=4943ca8592866d3f6c2003acf9e729c3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts box to a 4-point polygon.
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将框转换为4点多边形。
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4943ca8592866d3f6c2003acf9e729c3 -->

<!-- pgdoc-cn_start sig_en=78f62d2d059773c84072dd5b2d248e7b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to a 12-point polygon.
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为12点多边形。
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=78f62d2d059773c84072dd5b2d248e7b -->

<!-- pgdoc-cn_start sig_en=5c074f720a746acec7eae60bd7d561e2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to an <replaceable>n</replaceable>-point polygon.
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为<replaceable>n</replaceable>点多边形。
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c074f720a746acec7eae60bd7d561e2 -->

<!-- pgdoc-cn_start sig_en=a050d1b9324125d56785789131c535f7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts closed path to a polygon with the same list of points.
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将封闭路径转换为具有点的相同列表的多边形。
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a050d1b9324125d56785789131c535f7 -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=2a9f3b5d2b690d02c5757116c817a4ad sig_cn_org=None source=14.1 
    <para>
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
    </para>
________________________________________________________-->
    <para>
     我们可以把一个<type>point</type>的两个组成数字当作具有索引 0 和 1 的数组访问。例如，如果<literal>t.p</literal>是一个<type>point</type>列，那么<literal>SELECT p[0] FROM t</literal>检索 X 座标而 <literal>UPDATE t SET p[1] = ...</literal>改变 Y 座标。同样，<type>box</type>或者<type>lseg</type>类型的值可以当作两个<type>point</type>值的数组值看待。
    </para>
<!-- pgdoc-cn_end sig_en=2a9f3b5d2b690d02c5757116c817a4ad -->

  </sect1>


 <sect1 id="functions-net">
<!-- pgdoc-cn_start sig_en=99f4ca28922a6a24e0f83cb37cefbdfa sig_cn_org=None source=14.1 
  <title>Network Address Functions and Operators</title>
________________________________________________________-->
  <title>网络地址函数和操作符</title>
<!-- pgdoc-cn_end sig_en=99f4ca28922a6a24e0f83cb37cefbdfa -->

<!-- pgdoc-cn_start sig_en=8c8606417488350b6b17c0171d927901 sig_cn_org=None source=14.1 
  <para>
   The IP network address types, <type>cidr</type> and <type>inet</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized operators and functions shown in
   <xref linkend="cidr-inet-operators-table"/> and
   <xref linkend="cidr-inet-functions-table"/>.
  </para>
________________________________________________________-->
  <para>
   IP网络地址类型，<type>cidr</type>和<type>inet</type>，支持<xref linkend="functions-comparison-op-table"/>所示的常用比较操作符，
   以及<xref linkend="cidr-inet-operators-table"/> 和 <xref linkend="cidr-inet-functions-table"/>所示的专用操作符和函数。
  </para>
<!-- pgdoc-cn_end sig_en=8c8606417488350b6b17c0171d927901 -->

<!-- pgdoc-cn_start sig_en=be01426211266121cce09ff0a5d92677 sig_cn_org=None source=14.1 
  <para>
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly;
   therefore, the operators and functions shown below as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is
   because the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value
   to <type>cidr</type>.  When this is done, any bits to the right of the
   netmask are silently zeroed to create a valid <type>cidr</type> value.
  </para>
________________________________________________________-->
  <para>
   任何<type>cidr</type> 值都可以隐式地转换到<type>inet</type>；因此，下面在<type>inet</type>上操作的操作符和函数也可以在<type>cidr</type>值上工作。
   (对于<type>inet</type>和<type>cidr</type>有单独的函数，这是因为这两种情况的行为应该是不同的。)
   此外，它允许将<type>inet</type>值转换为<type>cidr</type>。
   当这样做的时候，子网掩码右边的任何位都被静默地置零，以创建一个有效的<type>cidr</type>值。
  </para>
<!-- pgdoc-cn_end sig_en=be01426211266121cce09ff0a5d92677 -->

   <table id="cidr-inet-operators-table">
<!-- pgdoc-cn_start sig_en=0a61a03aae2b20c91a5cdd52611d319e sig_cn_org=None source=14.1 
    <title>IP Address Operators</title>
________________________________________________________-->
    <title>IP地址操作符</title>
<!-- pgdoc-cn_end sig_en=0a61a03aae2b20c91a5cdd52611d319e -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=6da25436d600e3be5969b585d3ad83c4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet strictly contained by subnet?
        This operator, and the next four, test for subnet inclusion.  They
        consider only the network parts of the two addresses (ignoring any
        bits to the right of the netmasks) and determine whether one network
        is identical to or a subnet of the other.
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含在子网中?这个操作符和后续的四个操作符测试子网包含情况。
        它们只考虑两个地址的网络部分(忽略网络掩码右侧的任何位)，并确定一个网络与另一个网络相同或者是相同的子网。
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6da25436d600e3be5969b585d3ad83c4 -->

<!-- pgdoc-cn_start sig_en=8712ad6d04f8d0a37d592c9050d685ab sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet contained by or equal to subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8712ad6d04f8d0a37d592c9050d685ab -->

<!-- pgdoc-cn_start sig_en=28b2bd7cbef68454ffcf969f5cfda6b8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet strictly contain subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28b2bd7cbef68454ffcf969f5cfda6b8 -->

<!-- pgdoc-cn_start sig_en=5f832038fecad2e4f50226733727aa96 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet contain or equal subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5f832038fecad2e4f50226733727aa96 -->

<!-- pgdoc-cn_start sig_en=f74e57308b903e63e66e3eb54f5f09d6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does either subnet contain or equal the other?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        其中一个子网包含或等于另一个子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f74e57308b903e63e66e3eb54f5f09d6 -->

<!-- pgdoc-cn_start sig_en=e1d7a05212d1f5ab15cccc265078efa0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e1d7a05212d1f5ab15cccc265078efa0 -->

<!-- pgdoc-cn_start sig_en=466506fc73ac345255d9b57cf65b1709 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=466506fc73ac345255d9b57cf65b1709 -->

<!-- pgdoc-cn_start sig_en=b2d5a52c67a8217e1bde0ca588ca39d4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2d5a52c67a8217e1bde0ca588ca39d4 -->

<!-- pgdoc-cn_start sig_en=952eae703aca8f17e22f58937f1d4c45 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=952eae703aca8f17e22f58937f1d4c45 -->

<!-- pgdoc-cn_start sig_en=e498f8a9a1736b4c04537639aeaf1c1c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e498f8a9a1736b4c04537639aeaf1c1c -->

<!-- pgdoc-cn_start sig_en=8c8fbe7fbc028f03b94321dee691cbdf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Subtracts an offset from an address.
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        从地址中减去偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c8fbe7fbc028f03b94321dee691cbdf -->

<!-- pgdoc-cn_start sig_en=aaf7cf4c1af05e41252deb9412ea53b7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the difference of two addresses.
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算两个地址的差值。
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aaf7cf4c1af05e41252deb9412ea53b7 -->
     </tbody>
    </tgroup>
   </table>

   <table id="cidr-inet-functions-table">
<!-- pgdoc-cn_start sig_en=31f829a3b909083121f5b996cf1aa4b9 sig_cn_org=None source=14.1 
    <title>IP Address Functions</title>
________________________________________________________-->
    <title>IP地址的函数</title>
<!-- pgdoc-cn_end sig_en=31f829a3b909083121f5b996cf1aa4b9 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=56f9604345ef67e7dfc314a7aef676c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The result is the same as the <type>inet</type> output function
        produces; it is <quote>abbreviated</quote> only in comparison to the
        result of an explicit cast to <type>text</type>, which for historical
        reasons will never suppress the netmask part.)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩略的文本显示格式。
        (结果与<type>inet</type>输出函数产生的结果相同;它只是在与显式转换为<type>text</type>的结果比较时才被<quote>abbreviated</quote>，
        由于历史原因，它永远不会抑制子网掩码部分。)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=56f9604345ef67e7dfc314a7aef676c1 -->

<!-- pgdoc-cn_start sig_en=8c97536b0fd828b9a7e0fd765fc5ac1b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The abbreviation consists of dropping all-zero octets to the right
        of the netmask; more examples are in
        <xref linkend="datatype-net-cidr-table"/>.)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩写的文本显示格式。(缩写包括在子网掩码的右侧删除所有零字节;更多的例子请见 <xref linkend="datatype-net-cidr-table"/>。)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c97536b0fd828b9a7e0fd765fc5ac1b -->

<!-- pgdoc-cn_start sig_en=16075452a31ed063948e8981e8af8e84 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the broadcast address for the address's network.
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算广播地址。
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=16075452a31ed063948e8981e8af8e84 -->

<!-- pgdoc-cn_start sig_en=8d2b3df8ef0791182c318836a4aa53f2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the address's family: <literal>4</literal> for IPv4,
        <literal>6</literal> for IPv6.
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回地址的系列: <literal>4</literal> 对应 IPv4, <literal>6</literal> 对应 IPv6。
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8d2b3df8ef0791182c318836a4aa53f2 -->

<!-- pgdoc-cn_start sig_en=885cbfd2f5a40b858995a94a8e08c079 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the IP address as text, ignoring the netmask.
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回IP地址文本，忽略子网掩码。
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=885cbfd2f5a40b858995a94a8e08c079 -->

<!-- pgdoc-cn_start sig_en=9ff7516093ecb634a6b862df9e2a2e53 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the host mask for the address's network.
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算主机掩码。
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9ff7516093ecb634a6b862df9e2a2e53 -->

<!-- pgdoc-cn_start sig_en=179f5543c1fd5671a0fa5dcfb9cad82d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Computes the smallest network that includes both of the given networks.
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        计算包含两个给定网络的最小网络。
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=179f5543c1fd5671a0fa5dcfb9cad82d -->

<!-- pgdoc-cn_start sig_en=c626ea00fa594082fbad9bfc4a9c49b5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the addresses belong to the same IP family.
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试地址是否属于同一IP族。
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c626ea00fa594082fbad9bfc4a9c49b5 -->

<!-- pgdoc-cn_start sig_en=2dfe45c51653bd12ba8bfac0380c8504 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the netmask length in bits.
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        以比特位返回子网掩码长度。
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2dfe45c51653bd12ba8bfac0380c8504 -->

<!-- pgdoc-cn_start sig_en=90e50641d5d90835a0d9234f24f95597 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the network mask for the address's network.
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算网络掩码。
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=90e50641d5d90835a0d9234f24f95597 -->

<!-- pgdoc-cn_start sig_en=e9e96add6c7bee1e396c97e78a5498fb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Returns the network part of the address, zeroing out
        whatever is to the right of the netmask.
        (This is equivalent to casting the value to <type>cidr</type>.)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        返回地址的网络部分，将子网掩码右边的部分归零。(这相当于将值转换为<type>cidr</type>。)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e9e96add6c7bee1e396c97e78a5498fb -->

<!-- pgdoc-cn_start sig_en=bb9ac113fb93f4a459da28eb9d76a8cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Sets the netmask length for an <type>inet</type> value.
        The address part does not change.
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        设置<type>inet</type>值的子网掩码长度。地址部分不改变。
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bb9ac113fb93f4a459da28eb9d76a8cb -->

<!-- pgdoc-cn_start sig_en=4f4d545051e2e751e0716bd063e1fa5e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Sets the netmask length for a <type>cidr</type> value.
        Address bits to the right of the new netmask are set to zero.
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        设置<type>cidr</type>值的子网掩码长度。新子网掩码右侧的地址位设置为零。
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4f4d545051e2e751e0716bd063e1fa5e -->

<!-- pgdoc-cn_start sig_en=d82d1764e605bf86dcc1e9b7b83f0867 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the unabbreviated IP address and netmask length as text.
        (This has the same result as an explicit cast to <type>text</type>.)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本形式返回未缩写的IP地址和子网掩码长度。(这与显式转换为<type>text</type>的结果相同。)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d82d1764e605bf86dcc1e9b7b83f0867 -->
     </tbody>
    </tgroup>
   </table>

  <tip>
<!-- pgdoc-cn_start sig_en=806237c3462e502a2a7c428dcf9727a5 sig_cn_org=None source=14.1 
   <para>
    The <function>abbrev</function>, <function>host</function>,
    and <function>text</function> functions are primarily intended to offer
    alternative display formats for IP addresses.
   </para>
________________________________________________________-->
   <para>
    <function>abbrev</function>、<function>host</function>和<function>text</function>函数主要用于为IP地址提供另一种显示格式。
   </para>
<!-- pgdoc-cn_end sig_en=806237c3462e502a2a7c428dcf9727a5 -->
  </tip>

<!-- pgdoc-cn_start sig_en=f659ea85228ed2f6e30207ed3792a87f sig_cn_org=None source=14.1 
  <para>
   The MAC address types, <type>macaddr</type> and <type>macaddr8</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized functions shown in
   <xref linkend="macaddr-functions-table"/>.
   In addition, they support the bitwise logical operators
   <literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>
   (NOT, AND and OR), just as shown above for IP addresses.
  </para>
________________________________________________________-->
  <para>
   MAC地址类型， <type>macaddr</type> 和<type>macaddr8</type>，支持<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符以及<xref linkend="macaddr-functions-table"/>中所示的特殊函数。
   此外，它们支持位元逻辑操作符<literal>~</literal>, <literal>&amp;</literal> 和 <literal>|</literal> (NOT, AND 和 OR)，就像上面对IP地址所示的那样。
  </para>
<!-- pgdoc-cn_end sig_en=f659ea85228ed2f6e30207ed3792a87f -->

   <table id="macaddr-functions-table">
<!-- pgdoc-cn_start sig_en=e308be14a8764cedb5a5999ada3cd87c sig_cn_org=None source=14.1 
    <title>MAC Address Functions</title>
________________________________________________________-->
    <title>MAC 地址函数</title>
<!-- pgdoc-cn_end sig_en=e308be14a8764cedb5a5999ada3cd87c -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c988a834e6c5438796c7c1bdb89577d4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        Sets the last 3 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        将地址的最后3个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c988a834e6c5438796c7c1bdb89577d4 -->

<!-- pgdoc-cn_start sig_en=100b9d1c5ef047095fc7aca16e36b540 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the last 5 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的最后5个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=100b9d1c5ef047095fc7aca16e36b540 -->

<!-- pgdoc-cn_start sig_en=474ab09eb96c02cabe79487c07e21702 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the 7th bit of the address to one, creating what is known as
        modified EUI-64, for inclusion in an IPv6 address.
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的第7位设置为1，创建所谓的modified EUI-64，用于包含在IPv6地址中。
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=474ab09eb96c02cabe79487c07e21702 -->
     </tbody>
    </tgroup>
   </table>

  </sect1>


 <sect1 id="functions-textsearch">
<!-- pgdoc-cn_start sig_en=2b7b42ba99d9717d017acb170fd50cd4 sig_cn_org=None source=14.1 
  <title>Text Search Functions and Operators</title>
________________________________________________________-->
  <title>文本搜索函数和操作符</title>
<!-- pgdoc-cn_end sig_en=2b7b42ba99d9717d017acb170fd50cd4 -->

<!-- pgdoc-cn_start sig_en=2ed86fef54b185924867091ad240711d sig_cn_org=None source=14.1 
   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2ed86fef54b185924867091ad240711d -->

<!-- pgdoc-cn_start sig_en=173c18a133d3fa77eee3b442a09a7586 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=173c18a133d3fa77eee3b442a09a7586 -->

<!-- pgdoc-cn_start sig_en=c9cc6cf1d8efb25d6f8255c2f77a2f2b sig_cn_org=None source=14.1 
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   总结了为全文搜索提供的函数和操作符。<productname>PostgreSQL</productname>的文本搜索功能的详细解释可参考<xref linkend="textsearch"/>。
  </para>
<!-- pgdoc-cn_end sig_en=c9cc6cf1d8efb25d6f8255c2f77a2f2b -->

   <table id="textsearch-operators-table">
<!-- pgdoc-cn_start sig_en=8d98202c490ca70f0a8768b5c7c8a574 sig_cn_org=None source=14.1 
    <title>Text Search Operators</title>
________________________________________________________-->
    <title>文本搜索操作符</title>
<!-- pgdoc-cn_end sig_en=8d98202c490ca70f0a8768b5c7c8a574 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=dbddfc55903b5a76b92da6b685254bf7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>tsvector</type> match <type>tsquery</type>?
        (The arguments can be given in either order.)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>tsvector</type>匹配<type>tsquery</type>吗?(参数可以按任意顺序给出。)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbddfc55903b5a76b92da6b685254bf7 -->

<!-- pgdoc-cn_start sig_en=0a9b99939adafb19dd716e6427cea03a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does text string, after implicit invocation
        of <function>to_tsvector()</function>, match <type>tsquery</type>?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        隐式调用<function>to_tsvector()</function>后的文本字符串匹配<type>tsquery</type>么 ?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0a9b99939adafb19dd716e6427cea03a -->

<!-- pgdoc-cn_start sig_en=ac1129a5ec430328a9171be754b1c9f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is a deprecated synonym for <literal>@@</literal>.
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这是<literal>@@</literal>已弃用的同义词。
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ac1129a5ec430328a9171be754b1c9f0 -->

<!-- pgdoc-cn_start sig_en=2ee1f3a9169fcfd6ae8285fbe3416b68 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Concatenates two <type>tsvector</type>s.  If both inputs contain
        lexeme positions, the second input's positions are adjusted
        accordingly.
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        连接两个<type>tsvector</type>。如果两个输入都包含词素位置，则相应地调整第二个输入的位置。
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ee1f3a9169fcfd6ae8285fbe3416b68 -->

<!-- pgdoc-cn_start sig_en=e813036f0cd20f94f780721863191fda sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs two <type>tsquery</type>s together, producing a query that
        matches documents that match both input queries.
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e813036f0cd20f94f780721863191fda -->

<!-- pgdoc-cn_start sig_en=ceaf0c2b39081c499813a9f46dd18fb5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs two <type>tsquery</type>s together, producing a query that
        matches documents that match either input query.
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ceaf0c2b39081c499813a9f46dd18fb5 -->

<!-- pgdoc-cn_start sig_en=0472d8971dcdb8846953be8c6b2621dd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Negates a <type>tsquery</type>, producing a query that matches
        documents that do not match the input query.
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        否定<type>tsquery</type>，生成一个与输入查询不匹配的匹配文档的查询。
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0472d8971dcdb8846953be8c6b2621dd -->

<!-- pgdoc-cn_start sig_en=a35323d552d316d00c7a0b119df435ca sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query, which matches if the two input queries
        match at successive lexemes.
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，如果两个输入查询在连续的词素上匹配，该查询将进行匹配。
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a35323d552d316d00c7a0b119df435ca -->

<!-- pgdoc-cn_start sig_en=09d5224e57a06297200d1cc2a4126dcd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first <type>tsquery</type> contain the second?  (This considers
        only whether all the lexemes appearing in one query appear in the
        other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含了第二个吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=09d5224e57a06297200d1cc2a4126dcd -->

<!-- pgdoc-cn_start sig_en=eec4edb6ebc63acc6ddaf1e6d9f0097e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first <type>tsquery</type> contained in the second?  (This
        considers only whether all the lexemes appearing in one query appear
        in the other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含在第二个中吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，而忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eec4edb6ebc63acc6ddaf1e6d9f0097e -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=8c7b6cf8d9fe39b59546abc8efc9fca9 sig_cn_org=None source=14.1 
    <para>
     In addition to these specialized operators, the usual comparison
     operators shown in <xref linkend="functions-comparison-op-table"/> are
     available for types <type>tsvector</type> and <type>tsquery</type>.
     These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
    </para>
________________________________________________________-->
    <para>
     除了这些专用操作符之外， <xref linkend="functions-comparison-op-table"/> 中所示的常用比较操作符也适用于<type>tsvector</type>和<type>tsquery</type>类型。
     它们对于文本搜索不是很有用，但是允许使用。例如，建在这些类型列上的唯一索引。
    </para>
<!-- pgdoc-cn_end sig_en=8c7b6cf8d9fe39b59546abc8efc9fca9 -->

   <table id="textsearch-functions-table">
<!-- pgdoc-cn_start sig_en=2c3257b1f117c5cfd534c2da45d34e44 sig_cn_org=None source=14.1 
    <title>Text Search Functions</title>
________________________________________________________-->
    <title>文本搜索函数</title>
<!-- pgdoc-cn_end sig_en=2c3257b1f117c5cfd534c2da45d34e44 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=a4c35891abb7ff38290f6eaa5b44814e sig_cn_org=569f0d910a27949923d4b2645e6aad3f source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts an array of text strings to a <type>tsvector</type>.
        The given strings are used as lexemes as-is, without further
        processing.  Array elements must not be empty strings
        or <literal>NULL</literal>.
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将文本字符串数组转换为<type>tsvector</type>。
        给定的字符串被直接用作词元，不经过进一步处理。数组元素不得为空字符串
        或<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a4c35891abb7ff38290f6eaa5b44814e -->

<!-- pgdoc-cn_start sig_en=a59a0b0aedc8dba670366348e3127cf3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        Returns the OID of the current default text search configuration
        (as set by <xref linkend="guc-default-text-search-config"/>).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        返回当前默认文本搜索配置的OID(由 <xref linkend="guc-default-text-search-config"/> 所设定的).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a59a0b0aedc8dba670366348e3127cf3 -->

<!-- pgdoc-cn_start sig_en=a95db2fcb1a70ad9833d702e8e90dc65 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes in the <type>tsvector</type>.
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsvector</type>中的词位数。
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a95db2fcb1a70ad9833d702e8e90dc65 -->

<!-- pgdoc-cn_start sig_en=6ada92ab3492957726a469a39f5cca89 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes plus operators in
        the <type>tsquery</type>.
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsquery</type>中词位和操作符的数目。
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6ada92ab3492957726a469a39f5cca89 -->

<!-- pgdoc-cn_start sig_en=df003f209fb6d2bc0ba04fa8037e84d1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches documents containing all non-stopwords in the text.
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
        字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配文本中包含所有非停止词的文档。
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=df003f209fb6d2bc0ba04fa8037e84d1 -->

<!-- pgdoc-cn_start sig_en=2cfc076b1cbf7ab77b313c28219e8ed8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches phrases containing all non-stopwords in the text.
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
        字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配包含文本中所有非停止词的短语。
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2cfc076b1cbf7ab77b313c28219e8ed8 -->

<!-- pgdoc-cn_start sig_en=a01622d6c1466b04b32500fae7897e7e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according
        to the specified or default configuration.  Quoted word sequences are
        converted to phrase tests.  The word <quote>or</quote> is understood
        as producing an OR operator, and a dash produces a NOT operator;
        other punctuation is ignored.
        This approximates the behavior of some common web search tools.
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。引用的单词序列被转换为短语测试。
        <quote>or</quote>一词被理解为产生OR操作符，而破折号产生NOT操作符;其他标点符号被忽略。这类似于一些常见的网络搜索工具的行为。
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a01622d6c1466b04b32500fae7897e7e -->

<!-- pgdoc-cn_start sig_en=d2d5eede88011fdf325d0e5cb4bd0256 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Produces a representation of the indexable portion of
        a <type>tsquery</type>.  A result that is empty or
        just <literal>T</literal> indicates a non-indexable query.
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        生成<type>tsquery</type>的可转位部分的表示。结果为空或仅为<literal>T</literal>表示不可索引查询。
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d2d5eede88011fdf325d0e5cb4bd0256 -->

<!-- pgdoc-cn_start sig_en=21b4b339cc8224cdfc24c2160acd6a96 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to each element
        of the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将指定的<parameter>weight</parameter>赋给<parameter>vector</parameter>的每个元素。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=21b4b339cc8224cdfc24c2160acd6a96 -->

<!-- pgdoc-cn_start sig_en=469a401f95c0d1c65ef928ed7720ef06 sig_cn_org=6787006bea5ca8911c008205b01525fe source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to elements
        of the <parameter>vector</parameter> that are listed
        in <parameter>lexemes</parameter>.
        The strings in <parameter>lexemes</parameter> are taken as lexemes
        as-is, without further processing.  Strings that do not match any
        lexeme in <parameter>vector</parameter> are ignored.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>为特定词元设置权重</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        为<parameter>vector</parameter>中列出的<parameter>lexemes</parameter>赋予指定的<parameter>weight</parameter>。
        <parameter>lexemes</parameter>中的字符串被视为词元，不经过进一步处理。不匹配<parameter>vector</parameter>中任何词元的字符串将被忽略。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=469a401f95c0d1c65ef928ed7720ef06 -->

<!-- pgdoc-cn_start sig_en=fcf1ee40882fc552dc75c22cd7d7e1ea sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes positions and weights from the <type>tsvector</type>.
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<type>tsvector</type>中移除位置和权重。
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fcf1ee40882fc552dc75c22cd7d7e1ea -->

<!-- pgdoc-cn_start sig_en=4d1397a5742272592f2fa0505a0d1b43 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  The words must be combined
        by valid <type>tsquery</type> operators.
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。单词必须由有效的<type>tsquery</type>操作符组合。
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4d1397a5742272592f2fa0505a0d1b43 -->

<!-- pgdoc-cn_start sig_en=cceaa64ae3a03ba82a2c461cf2821aa2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsvector</type>, normalizing words according
        to the specified or default configuration.  Position information is
        included in the result.
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。结果中包含位置信息。
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cceaa64ae3a03ba82a2c461cf2821aa2 -->

<!-- pgdoc-cn_start sig_en=ba04b6e4d06018fe418d8d7785db66ba sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts each string value in the JSON document to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of string
        values.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>; observe the difference in the examples.)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将JSON文档中的每个字符串值转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
        然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对字符串值之间存在一个停止词一样生成。
        (注意，当输入为<type>jsonb</type>时，JSON对象的字段的<quote>document order</quote>取决于实现;请观察这些例子中的差异。)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ba04b6e4d06018fe418d8d7785db66ba -->

<!-- pgdoc-cn_start sig_en=5c958faf9f42dd81456da2efae344882 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects each item in the JSON document that is requested by
        the <parameter>filter</parameter> and converts each one to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of selected
        items.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>.)
        The <parameter>filter</parameter> must be a <type>jsonb</type>
        array containing zero or more of these keywords:
        <literal>"string"</literal> (to include all string values),
        <literal>"numeric"</literal> (to include all numeric values),
        <literal>"boolean"</literal> (to include all boolean values),
        <literal>"key"</literal> (to include all keys), or
        <literal>"all"</literal> (to include all the above).
        As a special case, the <parameter>filter</parameter> can also be a
        simple JSON value that is one of these keywords.
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        选择<parameter>filter</parameter>请求的JSON文档中的每个项，并将每个项转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
        然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对选定的项目之间存在一个停止词一样生成。
        (注意，当输入为<type>jsonb</type>时，JSON对象字段的<quote>document order</quote>取决于实现。)
        <parameter>filter</parameter>必须是一个<type>jsonb</type>数组，其中包含0个或多个关键字:
        <literal>"string"</literal>(包括所有字符串值)，
        <literal>"numeric"</literal>(包括所有数值)，
        <literal>"boolean"</literal>(包括所有布尔值)，
        <literal>"key"</literal>(包括所有键)，或
        <literal>"all"</literal>(包括以上所有关键字)。
        作为一种特殊情况，该<parameter>filter</parameter>也可以是这些关键字之一的简单JSON值。
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c958faf9f42dd81456da2efae344882 -->

<!-- pgdoc-cn_start sig_en=2b41158c284eaf3b1b29ceb52e7d080b sig_cn_org=bad16349fc340f1d7f05583d6b58ffe7 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrence of the given <parameter>lexeme</parameter>
        from the <parameter>vector</parameter>.
        The <parameter>lexeme</parameter> string is treated as a lexeme as-is,
        without further processing.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<parameter>vector</parameter>中删除给定的<parameter>lexeme</parameter>的任何出现。
        <parameter>lexeme</parameter>字符串被视为原样的词元，不经过进一步处理。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2b41158c284eaf3b1b29ceb52e7d080b -->

<!-- pgdoc-cn_start sig_en=f8c7ff90fee11234e140788b8b0ce9db sig_cn_org=8a2811649d1cbb93e6053ccb6bbeae69 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrences of the lexemes
        in <parameter>lexemes</parameter>
        from the <parameter>vector</parameter>.
        The strings in <parameter>lexemes</parameter> are taken as lexemes
        as-is, without further processing.  Strings that do not match any
        lexeme in <parameter>vector</parameter> are ignored.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<parameter>vector</parameter>中删除<parameter>lexemes</parameter>中的任何出现。
        <parameter>lexemes</parameter>中的字符串被视为词元，不经过进一步处理。
        不匹配<parameter>vector</parameter>中任何词元的字符串将被忽略。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8c7ff90fee11234e140788b8b0ce9db -->

<!-- pgdoc-cn_start sig_en=b93882e21912093493ae4ca35fd49b57 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects only elements with the given <parameter>weights</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        只从<parameter>vector</parameter>中选择具有给定<parameter>weights</parameter>的元素。
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b93882e21912093493ae4ca35fd49b57 -->

<!-- pgdoc-cn_start sig_en=240e3669415130876d72846fe2fa8064 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, the match(es) for
        the <parameter>query</parameter> in
        the <parameter>document</parameter>, which must be raw text not
        a <type>tsvector</type>.  Words in the document are normalized
        according to the specified or default configuration before matching to
        the query.  Use of this function is discussed in
        <xref linkend="textsearch-headline"/>, which also describes the
        available <parameter>options</parameter>.
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示<parameter>document</parameter>中<parameter>query</parameter>的匹配项，该匹配项必须是原始文本，而不是<type>tsvector</type>。
        在匹配查询之前，文档中的单词将根据指定的或默认的配置进行规范化。
        <xref linkend="textsearch-headline"/>中讨论了该函数的使用，还描述了可用的<parameter>options</parameter>。
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=240e3669415130876d72846fe2fa8064 -->

<!-- pgdoc-cn_start sig_en=ca44ba2b761cffb419a6cf746496777f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, match(es) for
        the <parameter>query</parameter> that occur in string values
        within the JSON <parameter>document</parameter>.
        See <xref linkend="textsearch-headline"/> for more details.
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示匹配JSON<parameter>document</parameter>中字符串值中的<parameter>query</parameter>。
        更多细节请参阅 <xref linkend="textsearch-headline"/>。
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ca44ba2b761cffb419a6cf746496777f -->

<!-- pgdoc-cn_start sig_en=3a0e030015e1949362fb3f03ed74e739 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>.  See
        <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。详情请参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3a0e030015e1949362fb3f03ed74e739 -->

<!-- pgdoc-cn_start sig_en=0902efeb8385d12f33fae2b1660eee14 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>, using a cover density
        algorithm.  See <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        使用覆盖密度算法计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。
        详情参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0902efeb8385d12f33fae2b1660eee14 -->

<!-- pgdoc-cn_start sig_en=eb7d0ebf7501d3030c3bfc0ad7560785 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces occurrences of <parameter>target</parameter>
        with <parameter>substitute</parameter>
        within the <parameter>query</parameter>.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        在<parameter>query</parameter>中使用 <parameter>substitute</parameter>替换出现的<parameter>target</parameter>。
        详情参见 <xref linkend="textsearch-query-rewriting"/> 。
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eb7d0ebf7501d3030c3bfc0ad7560785 -->

<!-- pgdoc-cn_start sig_en=3b674182e73e58517e78952b0c32c8eb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces portions of the <parameter>query</parameter> according to
        target(s) and substitute(s) obtained by executing
        a <command>SELECT</command> command.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        根据目标替换部分<parameter>query</parameter>，并替换通过执行<command>SELECT</command>命令获得的查询。
        详情参见<xref linkend="textsearch-query-rewriting"/>。
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b674182e73e58517e78952b0c32c8eb -->

<!-- pgdoc-cn_start sig_en=707ac66bc250d3c3c4dda2c7bd3e0f57 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter>
        and <parameter>query2</parameter> at successive lexemes (same
        as <literal>&lt;-&gt;</literal> operator).
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，在连续的词位上搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项(与<literal>&lt;-&gt;</literal>操作符相同)。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=707ac66bc250d3c3c4dda2c7bd3e0f57 -->

<!-- pgdoc-cn_start sig_en=406b56b9138a1c779ee6f1e60d5f4284 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter> and
        <parameter>query2</parameter> that occur exactly
        <parameter>distance</parameter> lexemes apart.
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，用于搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项，这些匹配项恰好出现在<parameter>distance</parameter>词位之间。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=406b56b9138a1c779ee6f1e60d5f4284 -->

<!-- pgdoc-cn_start sig_en=d28bbc677a22a0deabfe1806292eb7bc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Converts a <type>tsvector</type> to an array of lexemes.
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<type>tsvector</type>转换为词位的数组。
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d28bbc677a22a0deabfe1806292eb7bc -->

<!-- pgdoc-cn_start sig_en=d87e7c8b8c83abc7c1c2c1c7261f840e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        Expands a <type>tsvector</type> into a set of rows, one per lexeme.
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        将<type>tsvector</type>展开为一组行，每个行对应一个词位。
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d87e7c8b8c83abc7c1c2c1c7261f840e -->
     </tbody>
    </tgroup>
   </table>

  <note>
<!-- pgdoc-cn_start sig_en=bc36c9664687eb608bea0d014fb1e76e sig_cn_org=None source=14.1 
   <para>
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
   </para>
________________________________________________________-->
   <para>
    所有接受一个可选的<type>regconfig</type>参数的文本搜索函数在该参数被忽略时，使用由<xref linkend="guc-default-text-search-config"/>指定的配置。
   </para>
<!-- pgdoc-cn_end sig_en=bc36c9664687eb608bea0d014fb1e76e -->
  </note>

<!-- pgdoc-cn_start sig_en=d27f8c398438328b5ee42bbd33e2793c sig_cn_org=None source=14.1 
  <para>
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are primarily helpful for development and
   debugging of new text search configurations.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="textsearch-functions-debug-table"/>中的函数被单独列出，因为它们通常不被用于日常的文本搜索操作。 
   它们主要有助于开发和调试新的文本搜索配置。
  </para>
<!-- pgdoc-cn_end sig_en=d27f8c398438328b5ee42bbd33e2793c -->

   <table id="textsearch-functions-debug-table">
<!-- pgdoc-cn_start sig_en=6bf39dd61d5395c1f7964993423aed97 sig_cn_org=None source=14.1 
    <title>Text Search Debugging Functions</title>
________________________________________________________-->
    <title>文本搜索调试函数</title>
<!-- pgdoc-cn_end sig_en=6bf39dd61d5395c1f7964993423aed97 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c83543a8fde9df6ca843c00bde715b04 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
        Extracts and normalizes tokens from
        the <parameter>document</parameter> according to the specified or
        default text search configuration, and returns information about how
        each token was processed.
        See <xref linkend="textsearch-configuration-testing"/> for details.
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
        根据指定的或默认的文本搜索配置从<parameter>document</parameter>中提取和标准化标记，并返回关于每个标记是如何处理的信息。
        详请参见<xref linkend="textsearch-configuration-testing"/>。
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c83543a8fde9df6ca843c00bde715b04 -->

<!-- pgdoc-cn_start sig_en=76edc436d29590a8b0c12a5e043d172f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns an array of replacement lexemes if the input token is known to
        the dictionary, or an empty array if the token is known to the
        dictionary but it is a stop word, or NULL if it is not a known word.
        See <xref linkend="textsearch-dictionary-testing"/> for details.
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        如果字典知道输入标记，则返回替换词位数组;如果字典知道标记，但它是停止词，则返回空数组;如果它不是已知词，则返回NULL。
        详情参见<xref linkend="textsearch-dictionary-testing"/>。
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=76edc436d29590a8b0c12a5e043d172f -->

<!-- pgdoc-cn_start sig_en=ca4329327b848c08319cb427badcecba sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using the
        named parser.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用命名的解析器从<parameter>document</parameter>中提取标记。详情参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ca4329327b848c08319cb427badcecba -->

<!-- pgdoc-cn_start sig_en=6f12c34ebc5e88a4b568283cd5519f02 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using a
        parser specified by OID.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用OID指定的解析器从<parameter>document</parameter>中提取标记。
        详请参见 <xref linkend="textsearch-parser-testing"/> 。
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f12c34ebc5e88a4b568283cd5519f02 -->

<!-- pgdoc-cn_start sig_en=c9028fbcd5400bb8abc1e39454be6f7a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token the named parser can
        recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述命名解析器可以识别的每种类型的标记。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c9028fbcd5400bb8abc1e39454be6f7a -->

<!-- pgdoc-cn_start sig_en=a2073ff2e5fafe525581f6fd19cb0905 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token a parser specified
        by OID can recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述OID指定的解析器可以识别的每种标记类型。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2073ff2e5fafe525581f6fd19cb0905 -->

<!-- pgdoc-cn_start sig_en=dddbc81cb78b254a7ca4b60645f7b9ff sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
        Executes the <parameter>sqlquery</parameter>, which must return a
        single <type>tsvector</type> column, and returns statistics about each
        distinct lexeme contained in the data.
        See <xref linkend="textsearch-statistics"/> for details.
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
        执行<parameter>sqlquery</parameter>，该查询必须返回单个<type>tsvector</type>列，并返回关于数据中包含的每个不同词位的统计信息。
        详请参见<xref linkend="textsearch-statistics"/>。
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dddbc81cb78b254a7ca4b60645f7b9ff -->
     </tbody>
    </tgroup>
   </table>

 </sect1>

 <sect1 id="functions-uuid">
<!-- pgdoc-cn_start sig_en=8a4587f8a57e7577032ce6feca97dfec sig_cn_org=None source=14.1 
  <title>UUID Functions</title>
________________________________________________________-->
  <title>UUID 函数</title>
<!-- pgdoc-cn_end sig_en=8a4587f8a57e7577032ce6feca97dfec -->

<!-- pgdoc-cn_start sig_en=b3a1344681cd82410648ee4e028a3fd9 sig_cn_org=None source=14.1 
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>generating</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>生成</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b3a1344681cd82410648ee4e028a3fd9 -->

<!-- pgdoc-cn_start sig_en=45fd51ebd750e3b1e1cff3819e01275f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=45fd51ebd750e3b1e1cff3819e01275f -->

<!-- pgdoc-cn_start sig_en=72a71f83d70fa14d8bfde02717ecfe32 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> includes one function to generate a UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   This function returns a version 4 (random) UUID.  This is the most commonly
   used type of UUID and is appropriate for most applications.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> 包含一个函数来生成UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   此函数返回一个版本4(随机)的UUID。这是最常用的UUID类型，适用于大多数应用程序。
  </para>
<!-- pgdoc-cn_end sig_en=72a71f83d70fa14d8bfde02717ecfe32 -->

<!-- pgdoc-cn_start sig_en=ed633269ef2ef5c0a1f46d35141fa955 sig_cn_org=None source=14.1 
  <para>
   The <xref linkend="uuid-ossp"/> module provides additional functions that
   implement other standard algorithms for generating UUIDs.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="uuid-ossp"/>模块提供了额外的功能，用于实现生成UUIDs的其他标准算法。
  </para>
<!-- pgdoc-cn_end sig_en=ed633269ef2ef5c0a1f46d35141fa955 -->

<!-- pgdoc-cn_start sig_en=0181759a6a48a596ea673f1db157ebc9 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> also provides the usual comparison
   operators shown in <xref linkend="functions-comparison-op-table"/> for
   UUIDs.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>还为UUIDs提供了<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符。
  </para>
<!-- pgdoc-cn_end sig_en=0181759a6a48a596ea673f1db157ebc9 -->
 </sect1>

 <sect1 id="functions-xml">

<!-- pgdoc-cn_start sig_en=b3cf889fce6cfad7145afc761d208ed4 sig_cn_org=None source=14.1 
  <title>XML Functions</title>
________________________________________________________-->
  <title>XML 函数</title>
<!-- pgdoc-cn_end sig_en=b3cf889fce6cfad7145afc761d208ed4 -->

<!-- pgdoc-cn_start sig_en=592245bef804eeec59fd40701abdb587 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>XML 函数</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=592245bef804eeec59fd40701abdb587 -->

<!-- pgdoc-cn_start sig_en=12c1e64a222baedd53bf4ff0fd2ff8b1 sig_cn_org=None source=14.1 
  <para>
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
  </para>
________________________________________________________-->
  <para>
   本节中描述的函数以及类函数的表达式都在类型<type>xml</type>的值上操作。类型<type>xml</type>的详细信息请参见<xref linkend="datatype-xml"/>。用于在值和类型<type>xml</type>之间转换的类函数的表达式<function>xmlparse</function>和<function>xmlserialize</function>记录在这里，而不是在本节中。
</para>
<!-- pgdoc-cn_end sig_en=12c1e64a222baedd53bf4ff0fd2ff8b1 -->

<!-- pgdoc-cn_start sig_en=dfe8ddd371bfc8656b98a6231e597ff9 sig_cn_org=None source=14.1 
  <para>
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure -&minus;with-libxml</command>.
  </para>
________________________________________________________-->
  <para>
   使用大部分这些函数要求<productname>PostgreSQL</productname>使用了<command>configure --with-libxml</command>进行编译。
  </para>
<!-- pgdoc-cn_end sig_en=dfe8ddd371bfc8656b98a6231e597ff9 -->

  <sect2 id="functions-producing-xml">
<!-- pgdoc-cn_start sig_en=20e2e794355b23f29a0548eeef61849a sig_cn_org=None source=14.1 
   <title>Producing XML Content</title>
________________________________________________________-->
   <title>产生 XML 内容</title>
<!-- pgdoc-cn_end sig_en=20e2e794355b23f29a0548eeef61849a -->

<!-- pgdoc-cn_start sig_en=f8cdd967255e1280f9a7100aec402c80 sig_cn_org=None source=14.1 
   <para>
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
   </para>
________________________________________________________-->
   <para>
    有一组函数和类函数的表达式可以用来从 SQL 数据产生 XML 内容。它们特别适合于将查询结果格式化成 XML 文档以便于在客户端应用中处理。
   </para>
<!-- pgdoc-cn_end sig_en=f8cdd967255e1280f9a7100aec402c80 -->

   <sect3>
    <title><literal>xmlcomment</literal></title>

<!-- pgdoc-cn_start sig_en=77cf98b3516f638e09c7e1a06914b4e6 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=77cf98b3516f638e09c7e1a06914b4e6 -->

<!-- pgdoc-cn_start sig_en=77144ccb49400483333f02c77eb69ccc sig_cn_org=None source=14.1 
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=77144ccb49400483333f02c77eb69ccc -->

<!-- pgdoc-cn_start sig_en=c6439b2446cf8ae9dd294fdc05f4b5e3 sig_cn_org=None source=14.1 
    <para>
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>-&minus;</literal></quote> or end with a
     <quote><literal>-</literal></quote>, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
    </para>
________________________________________________________-->
    <para>
     函数<function>xmlcomment</function>创建了一个 XML 值，它包含一个使用指定文本作为内容的 XML 注释。
     该文本不包含<quote><literal>--</literal></quote>或者也不会以一个<quote><literal>-</literal></quote>结尾，否则该结果的结构不是一个合法的 XML 注释。如果参数为空，结果也为空。
    </para>
<!-- pgdoc-cn_end sig_en=c6439b2446cf8ae9dd294fdc05f4b5e3 -->

<!-- pgdoc-cn_start sig_en=34e3cb9aee5b19a70e44ae1a3e3c0ba1 sig_cn_org=None source=14.1 
    <para>
     Example:
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <!-&minus;hello-&minus;>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=34e3cb9aee5b19a70e44ae1a3e3c0ba1 -->
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

<!-- pgdoc-cn_start sig_en=796bb2cd83e2339c0c0e001c873f7d2d sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=796bb2cd83e2339c0c0e001c873f7d2d -->

<!-- pgdoc-cn_start sig_en=ea708e6c487ec30a1d607b1dad64af66 sig_cn_org=None source=14.1 
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=ea708e6c487ec30a1d607b1dad64af66 -->

<!-- pgdoc-cn_start sig_en=92aa1cc3b0fa5f0f6102222e8e1f1ee7 sig_cn_org=None source=14.1 
    <para>
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
    </para>
________________________________________________________-->
    <para>
     函数<function>xmlconcat</function>将由单个 XML 值组成的列表串接成一个单独的值，这个值包含一个 XML 内容片断。空值会被忽略，只有当没有参数为非空时结果才为空。
    </para>
<!-- pgdoc-cn_end sig_en=92aa1cc3b0fa5f0f6102222e8e1f1ee7 -->

<!-- pgdoc-cn_start sig_en=34f2a3b85cc54acc96f2086759950e23 sig_cn_org=None source=14.1 
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <abc/><bar>foo</bar>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=34f2a3b85cc54acc96f2086759950e23 -->

<!-- pgdoc-cn_start sig_en=69f5c528a0201e2f9e2746331b3ceea3 sig_cn_org=None source=14.1 
    <para>
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
    </para>
________________________________________________________-->
    <para>
     如果 XML 声明存在，它们会按照下面的方式被组合。如果所有的参数值都有相同的 XML 版本声明，该版本将被用在结果中，否则将不使用版本。如果所有参数值有独立声明值<quote>yes</quote>，那么该值将被用在结果中。如果所有参数值都有一个独立声明值并且至少有一个为<quote>no</quote>，则<quote>no</quote>被用在结果中。否则结果中将没有独立声明。如果结果被决定要要求一个独立声明但是没有版本声明，将会使用一个版本 1.0 的版本声明，因为 XML 要求一个 XML 声明要包含一个版本声明。编码声明会被忽略并且在所有情况中都会被移除。
    </para>
<!-- pgdoc-cn_end sig_en=69f5c528a0201e2f9e2746331b3ceea3 -->

<!-- pgdoc-cn_start sig_en=cd35e8fd5e950d398718793a6be6f99c sig_cn_org=None source=14.1 
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=cd35e8fd5e950d398718793a6be6f99c -->
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

<!-- pgdoc-cn_start sig_en=014aa4731fc6f80362541b3b232d465a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=014aa4731fc6f80362541b3b232d465a -->

<!-- pgdoc-cn_start sig_en=ef396f4b3be938d6711057bbe3c4c437 sig_cn_org=None source=14.1 
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=ef396f4b3be938d6711057bbe3c4c437 -->

<!-- pgdoc-cn_start sig_en=4456179761905d494ea812f0b61aa6ed sig_cn_org=None source=14.1 
    <para>
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
     The <replaceable>name</replaceable>
     and <replaceable>attname</replaceable> items shown in the syntax are
     simple identifiers, not values.  The <replaceable>attvalue</replaceable>
     and <replaceable>content</replaceable> items are expressions, which can
     yield any <productname>PostgreSQL</productname> data type.  The
     argument(s) within <literal>XMLATTRIBUTES</literal> generate attributes
     of the XML element; the <replaceable>content</replaceable> value(s) are
     concatenated to form its content.
    </para>
________________________________________________________-->
    <para>
     表达式<function>xmlelement</function>使用给定名称、属性和内容产生一个 XML 元素。
     语法中显示的<replaceable>name</replaceable>和<replaceable>attname</replaceable>项是简单的标识符，而不是值。
     <replaceable>attvalue</replaceable>和<replaceable>content</replaceable>项是表达式，它们可以生成任何<productname>PostgreSQL</productname>数据类型。
     <literal>XMLATTRIBUTES</literal>的参数生成XML元素的属性；将<replaceable>content</replaceable>值连接起来形成其内容。
    </para>
<!-- pgdoc-cn_end sig_en=4456179761905d494ea812f0b61aa6ed -->

<!-- pgdoc-cn_start sig_en=34d7020e876090715e8ba769a6e08c0f sig_cn_org=None source=14.1 
    <para>
     Examples:
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=34d7020e876090715e8ba769a6e08c0f -->

<!-- pgdoc-cn_start sig_en=c41b1f5764e845915856cffcd46b77d5 sig_cn_org=None source=14.1 
    <para>
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     不是合法 XML 名字的元素名和属性名将被逃逸，逃逸的方法是将违反的字符用序列<literal>_x<replaceable>HHHH</replaceable>_</literal>替换，其中<replaceable>HHHH</replaceable>是被替换字符的 Unicode 代码点的十六进制表示。例如：
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=c41b1f5764e845915856cffcd46b77d5 -->

<!-- pgdoc-cn_start sig_en=f5e1a7d031ce660e2dc52a601971b37d sig_cn_org=None source=14.1 
    <para>
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     But these are not:
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>
________________________________________________________-->
    <para>
     如果属性值是一个列引用，则不需要指定一个显式的属性名，在这种情况下列的名字将被默认用于属性的名字。在其他情况下，属性必须被给定一个显式名称。因此这个例子是合法的：
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     但是下面这些不合法：
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=f5e1a7d031ce660e2dc52a601971b37d -->

<!-- pgdoc-cn_start sig_en=b150032768cf5668538db976d47c06ca sig_cn_org=None source=14.1 
    <para>
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"><abc/><!-&minus;test-&minus;><xyz/></foo>
]]></screen>

     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
________________________________________________________-->
    <para>
     如果指定了元素内容，它们将被根据其数据类型格式化。如果内容本身也是类型<type>xml</type>，就可以构建复杂的 XML 文档。例如：
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

     其他类型的内容将被格式化为合法的 XML 字符数据。这意味着字符 &lt;, &gt;, 和 &amp; 将被转换为实体。二进制数据（数据类型<type>bytea</type>）将被表示成 base64 或十六进制编码，具体取决于配置参数<xref linkend="guc-xmlbinary"/>的设置。为了使PostgreSQL的映射与SQL:2006及以后的SQL:2006中指定的映射保持一致，个别数据类型的特殊行为将不断发展，正如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>
<!-- pgdoc-cn_end sig_en=b150032768cf5668538db976d47c06ca -->
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

<!-- pgdoc-cn_start sig_en=b43619bcc536ab814865cb534a928fa8 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b43619bcc536ab814865cb534a928fa8 -->

<!-- pgdoc-cn_start sig_en=a2896e304e168867725bb42c314e7c19 sig_cn_org=None source=14.1 
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=a2896e304e168867725bb42c314e7c19 -->

<!-- pgdoc-cn_start sig_en=c220d6622d87c49bc156ddf1d7d30af0 sig_cn_org=None source=14.1 
    <para>
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for <function>xmlelement</function>,
     each <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expressions can have any data
     type.
    </para>
________________________________________________________-->
    <para>
     表达式<function>xmlforest</function>使用给定名称和内容产生一个元素的 XML 森林（序列）。
     对于<function>xmlelement</function>，每个<replaceable>name</replaceable>都必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。
    </para>
<!-- pgdoc-cn_end sig_en=c220d6622d87c49bc156ddf1d7d30af0 -->

<!-- pgdoc-cn_start sig_en=6d80e25fd3f4eb3532770eeca5b4827b sig_cn_org=None source=14.1 
    <para>
     Examples:
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
    </para>
________________________________________________________-->
    <para>
     例子：
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------&zwsp;-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     如我们在第二个例子中所见，如果内容值是一个列引用，元素名称可以被忽略，这种情况下默认使用列名。否则，必须指定一个名字。
    </para>
<!-- pgdoc-cn_end sig_en=6d80e25fd3f4eb3532770eeca5b4827b -->

<!-- pgdoc-cn_start sig_en=4628da0c9bd4861ba9ae6ee131dbb391 sig_cn_org=None source=14.1 
    <para>
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
    </para>
________________________________________________________-->
    <para>
     如上文<function>xmlelement</function>所示，非法 XML 名字的元素名会被逃逸。相似地，内容数据也会被逃逸来产生合法的 XML 内容，除非它已经是一个<type>xml</type>类型。
    </para>
<!-- pgdoc-cn_end sig_en=4628da0c9bd4861ba9ae6ee131dbb391 -->

<!-- pgdoc-cn_start sig_en=dc819818dda54220db287244b2f41444 sig_cn_org=None source=14.1 
    <para>
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
    </para>
________________________________________________________-->
    <para>
     注意如果 XML 森林由多于一个元素组成，那么它不是合法的 XML 文档，因此在<function>xmlelement</function>中包装<function>xmlforest</function>表达式会有用处。
    </para>
<!-- pgdoc-cn_end sig_en=dc819818dda54220db287244b2f41444 -->
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

<!-- pgdoc-cn_start sig_en=c3f81f4e2999fa442fa6123019b45ff9 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c3f81f4e2999fa442fa6123019b45ff9 -->

<!-- pgdoc-cn_start sig_en=0950b419ef3df5187ddb5de1a84f24c8 sig_cn_org=None source=14.1 
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=0950b419ef3df5187ddb5de1a84f24c8 -->

<!-- pgdoc-cn_start sig_en=c9109841140d5247f90ee7a237cc2a64 sig_cn_org=None source=14.1 
    <para>
     The <function>xmlpi</function> expression creates an XML
     processing instruction.
     As for <function>xmlelement</function>,
     the <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expression can have any data type.
     The <replaceable>content</replaceable>, if present, must not contain the
     character sequence <literal>?&gt;</literal>.
    </para>
________________________________________________________-->
    <para>
     表达式<function>xmlpi</function>创建一个 XML 处理指令。
     对于<function>xmlelement</function>，<replaceable>name</replaceable>必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。如果存在，<replaceable>content</replaceable>不能包含字符序列<literal>?&gt;</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=c9109841140d5247f90ee7a237cc2a64 -->

<!-- pgdoc-cn_start sig_en=dd1c57496a77c8099f01991a580c3a0e sig_cn_org=None source=14.1 
    <para>
     Example:
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?php echo "hello world";?>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=dd1c57496a77c8099f01991a580c3a0e -->
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

<!-- pgdoc-cn_start sig_en=4558850d62059c05df26882fa61ed97d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=4558850d62059c05df26882fa61ed97d -->

<!-- pgdoc-cn_start sig_en=7dabd19062714281eb3eb328f1a15ded sig_cn_org=None source=14.1 
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=7dabd19062714281eb3eb328f1a15ded -->

<!-- pgdoc-cn_start sig_en=414c05e8115fbc491e419fad714d0eb2 sig_cn_org=None source=14.1 
    <para>
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
    </para>
________________________________________________________-->
    <para>
     表达式<function>xmlroot</function>修改一个 XML 值的根结点的属性。如果指定了一个版本，它会替换根节点的版本声明中的值；如果指定了一个独立设置，它会替换根节点的独立声明中的值。
    </para>
<!-- pgdoc-cn_end sig_en=414c05e8115fbc491e419fad714d0eb2 -->

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

<!-- pgdoc-cn_start sig_en=c54bf6d28e3da0c4ed9bf8eeb3632baa sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c54bf6d28e3da0c4ed9bf8eeb3632baa -->

<!-- pgdoc-cn_start sig_en=e03ae333b657a53e592a93c93927a75b sig_cn_org=None source=14.1 
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=e03ae333b657a53e592a93c93927a75b -->

<!-- pgdoc-cn_start sig_en=42d03ae6cecb600674453a1011575fa3 sig_cn_org=None source=14.1 
    <para>
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
    </para>
________________________________________________________-->
    <para>
     和这里描述的其他函数不同，函数<function>xmlagg</function>是一个聚集函数。它将聚集函数调用的输入值串接起来，非常像<function>xmlconcat</function>所做的事情，除了串接是跨行发生的而不是在单一行的多个表达式上发生。聚集表达式的更多信息请见<xref linkend="functions-aggregate"/>。
    </para>
<!-- pgdoc-cn_end sig_en=42d03ae6cecb600674453a1011575fa3 -->

<!-- pgdoc-cn_start sig_en=07dc8917bd77820bceaae9c0fa4a6f33 sig_cn_org=None source=14.1 
    <para>
     Example:
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo>abc</foo><bar/>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=07dc8917bd77820bceaae9c0fa4a6f33 -->

<!-- pgdoc-cn_start sig_en=86416626912799325180da282c8d33ed sig_cn_org=None source=14.1 
    <para>
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     为了决定串接的顺序，可以为聚集调用增加一个<literal>ORDER BY</literal>子句，如<xref linkend="syntax-aggregates"/>中所述。例如：

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=86416626912799325180da282c8d33ed -->

<!-- pgdoc-cn_start sig_en=ec3aadea5d72de56a7eb09d37f0c6993 sig_cn_org=None source=14.1 
    <para>
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
________________________________________________________-->
    <para>
     我们推荐在以前的版本中使用下列非标准方法，并且它们在特定情况下仍然有用：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=ec3aadea5d72de56a7eb09d37f0c6993 -->
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!-- pgdoc-cn_start sig_en=0307483d6398c9fd27a49e45adcda3fe sig_cn_org=None source=14.1 
    <title>XML Predicates</title>
________________________________________________________-->
    <title>XML 谓词</title>
<!-- pgdoc-cn_end sig_en=0307483d6398c9fd27a49e45adcda3fe -->

<!-- pgdoc-cn_start sig_en=4a973507cf95cb697b58f19bacb9655e sig_cn_org=None source=14.1 
    <para>
     The expressions described in this section check properties
     of <type>xml</type> values.
    </para>
________________________________________________________-->
    <para>
     这一节描述的表达式检查<type>xml</type>值的属性。
    </para>
<!-- pgdoc-cn_end sig_en=4a973507cf95cb697b58f19bacb9655e -->

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

<!-- pgdoc-cn_start sig_en=f775abedda87279d87c139b0f5963ab8 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f775abedda87279d87c139b0f5963ab8 -->

<!-- pgdoc-cn_start sig_en=c13378f6514d6055e811d690b7e54c62 sig_cn_org=None source=14.1 
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=c13378f6514d6055e811d690b7e54c62 -->

<!-- pgdoc-cn_start sig_en=96f4bbf41b2a2bdbed42391fd1c6d4a3 sig_cn_org=None source=14.1 
    <para>
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
    </para>
________________________________________________________-->
    <para>
     如果参数 XML 值是一个正确的 XML 文档，则<literal>IS DOCUMENT</literal>返回真，如果不是则返回假（即它是一个内容片断），或者是参数为空时返回空。文档和内容片断之间的区别请见<xref linkend="datatype-xml"/>。
    </para>
<!-- pgdoc-cn_end sig_en=96f4bbf41b2a2bdbed42391fd1c6d4a3 -->
   </sect3>

   <sect3>
    <title><literal>IS NOT DOCUMENT</literal></title>

<!-- pgdoc-cn_start sig_en=e0b5458920575ed575d7f599d2fe69e8 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e0b5458920575ed575d7f599d2fe69e8 -->

<!-- pgdoc-cn_start sig_en=a453423ab761e71cc0e10e309be265bd sig_cn_org=None source=14.1 
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=a453423ab761e71cc0e10e309be265bd -->

<!-- pgdoc-cn_start sig_en=a439043f016a5a22dc9fc033d2583a6e sig_cn_org=None source=14.1 
    <para>
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
    </para>
________________________________________________________-->
    <para>
     如果参数中的XML值是一个正确的XML文档，那么表达式<literal>IS NOT DOCUMENT</literal>返回假，否则返回真（也就是说它是一个内容片段），如果参数为空则返回空。
    </para>
<!-- pgdoc-cn_end sig_en=a439043f016a5a22dc9fc033d2583a6e -->
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

<!-- pgdoc-cn_start sig_en=44718dbdfb191d53a0e7e0d55bcddc5d sig_cn_org=None source=14.1 
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=44718dbdfb191d53a0e7e0d55bcddc5d -->

<!-- pgdoc-cn_start sig_en=213d4611b0cbebc6f92794b7197e8c85 sig_cn_org=None source=14.1 
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=213d4611b0cbebc6f92794b7197e8c85 -->

<!-- pgdoc-cn_start sig_en=71de55a42dba213d9c25439d2f4643b1 sig_cn_org=None source=14.1 
    <para>
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
    </para>
________________________________________________________-->
    <para>
     函数<function>xmlexists</function>评价一个XPath 1.0表达式(第一个参数)，以传递的XML值作为其上下文项。 如果评价的结果产生一个空节点集，该函数返回false，如果产生任何其他值，则返回true。 如果任何参数为空，则函数返回null。 作为上下文项传递的非空值必须是一个XML文档，而不是内容片段或任何非XML值。
    </para>
<!-- pgdoc-cn_end sig_en=71de55a42dba213d9c25439d2f4643b1 -->

<!-- pgdoc-cn_start sig_en=5e6cfe050497c8a5429aa903263e9a30 sig_cn_org=None source=14.1 
    <para>
     Example:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子：
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=5e6cfe050497c8a5429aa903263e9a30 -->

<!-- pgdoc-cn_start sig_en=2ed75552d1f31f7db787d2c92cdc8e80 sig_cn_org=None source=14.1 
    <para>
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
________________________________________________________-->
    <para>
     <literal>BY REF</literal>和<literal>BY VALUE</literal>子句在<productname>PostgreSQL</productname>中被接受，但在<xref linkend="functions-xml-limits-postgresql"/>中被忽略。
    </para>
<!-- pgdoc-cn_end sig_en=2ed75552d1f31f7db787d2c92cdc8e80 -->

<!-- pgdoc-cn_start sig_en=83251dbbb206bef72dae6b4cf4a70c42 sig_cn_org=None source=14.1 
    <para>
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
________________________________________________________-->
    <para>
     在SQL标准中，<function>xmlexists</function>函数评估XML查询语言中的表达式，但<productname>PostgreSQL</productname>只允许使用XPath 1.0表达式，在<xref linkend="functions-xml-limits-xpath1"/>中讨论过。
    </para>
<!-- pgdoc-cn_end sig_en=83251dbbb206bef72dae6b4cf4a70c42 -->
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

<!-- pgdoc-cn_start sig_en=a7fc2d16ac5e8c93b7a063c174c8aa54 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a7fc2d16ac5e8c93b7a063c174c8aa54 -->

<!-- pgdoc-cn_start sig_en=5c80c302e0eb5885e69a03902e5de946 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5c80c302e0eb5885e69a03902e5de946 -->

<!-- pgdoc-cn_start sig_en=7ee5fd82e693653acd905e6ff824967f sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=7ee5fd82e693653acd905e6ff824967f -->

<!-- pgdoc-cn_start sig_en=623321c01b196eab8cb191f4f3a73897 sig_cn_org=None source=14.1 
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=623321c01b196eab8cb191f4f3a73897 -->

<!-- pgdoc-cn_start sig_en=fcee23bb5aee4c1824016b3439978ec2 sig_cn_org=None source=14.1 
    <para>
     These functions check whether a <type>text</type> string represents
     well-formed XML, returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
    </para>
________________________________________________________-->
    <para>
     这些函数检查一个<type>text</type>串是不是一个良构的 XML，返回一个布尔结果。<function>xml_is_well_formed_document</function>检查一个良构的文档，而<function>xml_is_well_formed_content</function>检查良构的内容。如果<xref linkend="guc-xmloption"/>配置参数被设置为<literal>DOCUMENT</literal>，<function>xml_is_well_formed</function>会做第一个函数的工作；如果配置参数被设置为<literal>CONTENT</literal>，<function>xml_is_well_formed</function>会做第二个函数的工作。这意味着<function>xml_is_well_formed</function>对于检查一个到类型<type>xml</type>的简单造型是否会成功非常有用，而其他两个函数对于检查<function>XMLPARSE</function>的对应变体是否会成功有用。
    </para>
<!-- pgdoc-cn_end sig_en=fcee23bb5aee4c1824016b3439978ec2 -->

<!-- pgdoc-cn_start sig_en=afa41e9a48c41e6abe7032e30896dee3 sig_cn_org=c6b64143539ac1ef509ffa4e08b4f9e5 source=15.7 
    <para>
     Examples:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 f
(1 row)
]]></screen>

     The last example shows that the checks include whether
     namespaces are correctly matched.
    </para>
________________________________________________________-->
    <para>
     例子:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document
-----------------------------
 f
(1 row)
]]></screen>

     最后一个例子显示了检查是否正确匹配命名空间。
    </para>
<!-- pgdoc-cn_end sig_en=afa41e9a48c41e6abe7032e30896dee3 -->
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!-- pgdoc-cn_start sig_en=dd63f3f816c524c42fd209545d2a4f6e sig_cn_org=None source=14.1 
   <title>Processing XML</title>
________________________________________________________-->
   <title>处理 XML</title>
<!-- pgdoc-cn_end sig_en=dd63f3f816c524c42fd209545d2a4f6e -->

<!-- pgdoc-cn_start sig_en=53581efe2c6b01ed42b3e055a3e11ddc sig_cn_org=None source=14.1 
   <para>
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
   </para>
________________________________________________________-->
   <para>
    要处理数据类型<type>xml</type>的值， PostgreSQL 提供了函数<function>xpath</function>和<function>xpath_exists</function>，它们计算 XPath 1.0 表达式以及<function>XMLTABLE</function>表函数。
   </para>
<!-- pgdoc-cn_end sig_en=53581efe2c6b01ed42b3e055a3e11ddc -->

   <sect3 id="functions-xml-processing-xpath">
    <title><literal>xpath</literal></title>

<!-- pgdoc-cn_start sig_en=53adddd692ae4b08a400a5323cfd9d48 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>XPath</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>XPath</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=53adddd692ae4b08a400a5323cfd9d48 -->

<!-- pgdoc-cn_start sig_en=0514ccca36dba70848195d3a2cf90f42 sig_cn_org=None source=14.1 
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=0514ccca36dba70848195d3a2cf90f42 -->

<!-- pgdoc-cn_start sig_en=e0afee95b7113708553943ce66e73d25 sig_cn_org=None source=14.1 
    <para>
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <parameter>xpath</parameter> (given as text)
     against the XML value
     <parameter>xml</parameter>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
    </para>
________________________________________________________-->
    <para>
     函数<function>xpath</function>根据 XML 值<parameter>xml</parameter>计算 XPath 1.0 表达式<parameter>xpath</parameter> (以文本形式给出)。
     它返回一个 XML 值的数组，该数组对应于该 XPath 表达式产生的结点集合。
     如果该 XPath 表达式返回一个标量值而不是一个结点集合，将会返回一个单一元素的数组。
    </para>
<!-- pgdoc-cn_end sig_en=e0afee95b7113708553943ce66e73d25 -->

<!-- pgdoc-cn_start sig_en=8f78b1574ac954e9f75e07c9762611c1 sig_cn_org=None source=14.1 
    <para>
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
    </para>
________________________________________________________-->
    <para>
     第二个参数必须是一个良构的 XML 文档。特殊地，它必须有一个单一根结点元素。
   </para>
<!-- pgdoc-cn_end sig_en=8f78b1574ac954e9f75e07c9762611c1 -->

<!-- pgdoc-cn_start sig_en=eff840ac538380575baf3418ae7993d2 sig_cn_org=None source=14.1 
    <para>
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
    </para>
________________________________________________________-->
    <para>
     该函数可选的第三个参数是一个名字空间映射的数组。这个数组应该是一个二维<type>text</type>数组，其第二轴长度等于2（即它应该是一个数组的数组，其中每一个都由刚好 2 个元素组成）。每个数组项的第一个元素是名字空间的名称（别名），第二个元素是名字空间的 URI。并不要求在这个数组中提供的别名和在 XML 文档本身中使用的那些名字空间相同（换句话说，在 XML 文档中和在<function>xpath</function>函数环境中，别名都是<emphasis>本地的</emphasis>）。
    </para>
<!-- pgdoc-cn_end sig_en=eff840ac538380575baf3418ae7993d2 -->

<!-- pgdoc-cn_start sig_en=c7862f4215424e2a20cd8b187f1926e3 sig_cn_org=079de9e1b348c963a624574e41779dd5 source=15.7 
    <para>
     Example:
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
________________________________________________________-->
    <para>
     示例:
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=c7862f4215424e2a20cd8b187f1926e3 -->

<!-- pgdoc-cn_start sig_en=93cd1f00e4da21d66d75bc7d4e003746 sig_cn_org=None source=14.1 
    <para>
     To deal with default (anonymous) namespaces, do something like this:
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
________________________________________________________-->
    <para>
     要处理默认（匿名）命名空间，做这样的事情：
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=93cd1f00e4da21d66d75bc7d4e003746 -->
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
    <title><literal>xpath_exists</literal></title>

<!-- pgdoc-cn_start sig_en=a34fda42507dddceccdcf6d6cc521e0e sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a34fda42507dddceccdcf6d6cc521e0e -->

<!-- pgdoc-cn_start sig_en=6be8abcd1cc6a76c1d4a976c8be0e43a sig_cn_org=None source=14.1 
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=6be8abcd1cc6a76c1d4a976c8be0e43a -->

<!-- pgdoc-cn_start sig_en=5ba214fc325b79ecd0a9fdb986629737 sig_cn_org=None source=14.1 
    <para>
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
    </para>
________________________________________________________-->
    <para>
     函数<function>xpath_exists</function>是<function>xpath</function>函数的一种特殊形式。这个函数不是返回满足 XPath 1.0 表达式的单一 XML 值，它返回一个布尔值表示查询是否被满足(具体来说，它是否产生了空节点集以外的任何值)。这个函数等价于标准的<literal>XMLEXISTS</literal>谓词，不过它还提供了对一个名字空间映射参数的支持。
    </para>
<!-- pgdoc-cn_end sig_en=5ba214fc325b79ecd0a9fdb986629737 -->

<!-- pgdoc-cn_start sig_en=e546edb98ca498b8199ab4bc9b428976 sig_cn_org=6be978ec4c64f3e7133390f52b2c6215 source=15.7 
    <para>
     Example:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
________________________________________________________-->
    <para>
     示例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists
--------------
 t
(1 row)
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=e546edb98ca498b8199ab4bc9b428976 -->
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
    <title><literal>xmltable</literal></title>

<!-- pgdoc-cn_start sig_en=3dc6032425d3e0ff24db2bf28e14172c sig_cn_org=None source=14.1 
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=3dc6032425d3e0ff24db2bf28e14172c -->

<!-- pgdoc-cn_start sig_en=80160c0d5893eb0d9cd21e50ef24eee0 sig_cn_org=None source=14.1 
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=80160c0d5893eb0d9cd21e50ef24eee0 -->

<!-- pgdoc-cn_start sig_en=b5ee242ebe625ff5abf2648e2f4aea96 sig_cn_org=None source=14.1 
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=b5ee242ebe625ff5abf2648e2f4aea96 -->

<!-- pgdoc-cn_start sig_en=8eab82bf61e307ef68b8ed241737ae58 sig_cn_org=None source=14.1 
    <para>
     The <function>xmltable</function> expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's <literal>FROM</literal> clause.
    </para>
________________________________________________________-->
    <para>
     <function>xmltable</function>表达式基于给定的XML值产生一个表、一个抽取行的XPath过滤器以及一个列定义集合。
     虽然它在语法上类似于函数，但它只能作为一个表出现在查询的<literal>FROM</literal>子句中。
    </para>
<!-- pgdoc-cn_end sig_en=8eab82bf61e307ef68b8ed241737ae58 -->

<!-- pgdoc-cn_start sig_en=8751d50e2b0252220fe5d1604cb044fc sig_cn_org=None source=14.1 
    <para>
     The optional <literal>XMLNAMESPACES</literal> clause gives a
     comma-separated list of namespace definitions, where
     each <replaceable>namespace_uri</replaceable> is a <type>text</type>
     expression and each <replaceable>namespace_name</replaceable> is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
    </para>
________________________________________________________-->
    <para>
     可选的<literal>XMLNAMESPACES</literal>子句是一个逗号分隔的名字空间定义列表。
     其中每个<replaceable>namespace_uri</replaceable>是一个<type>text</type>表达式，每个<replaceable>namespace_name</replaceable>是一个简单的标识符。
     它指定文档中使用的XML名字空间极其别名。当前不支持默认的名字空间说明。
    </para>
<!-- pgdoc-cn_end sig_en=8751d50e2b0252220fe5d1604cb044fc -->

<!-- pgdoc-cn_start sig_en=cebd37059729fcb428bb54a22dae158c sig_cn_org=None source=14.1 
    <para>
     The required <replaceable>row_expression</replaceable> argument is an
     XPath 1.0 expression (given as <type>text</type>) that is evaluated,
     passing the XML value <replaceable>document_expression</replaceable> as
     its context item, to obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
    </para>
________________________________________________________-->
    <para>
     所需的<replaceable>row_expression</replaceable>参数是一个求值的XPath 1.0表达式(以<type>text</type>形式给出)，通过传递XML值<replaceable>document_expression</replaceable>作为其上下文项，得到一组XML节点。
     这些节点就是<function>xmltable</function>转换为输出行的内容。如果<replaceable>document_expression</replaceable>为空，或者<replaceable>row_expression</replaceable>产生空节点集或节点集以外的任何值，则不会产生行。
    </para>
<!-- pgdoc-cn_end sig_en=cebd37059729fcb428bb54a22dae158c -->

<!-- pgdoc-cn_start sig_en=2ffededa0108826d1d5ef19a2ff64ee8 sig_cn_org=None source=14.1 
    <para>
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
________________________________________________________-->
    <para>
     <replaceable>document_expression</replaceable>提供了上下文。<replaceable>row_expression</replaceable>的项。
     它必须是一个格式良好的XML文档；不接受片段/森林。<literal>BY REF</literal>和<literal>BY VALUE</literal>子句 如上文所讨论的那样，被接受但被忽略了，正如在<xref linkend="functions-xml-limits-postgresql"/>中所讨论的。
    </para>
<!-- pgdoc-cn_end sig_en=2ffededa0108826d1d5ef19a2ff64ee8 -->

<!-- pgdoc-cn_start sig_en=5e72abaa3a562c1e364e2e6d2a4c8c42 sig_cn_org=None source=14.1 
    <para>
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
________________________________________________________-->
    <para>
     在SQL标准中，<function>xmltable</function>函数 评估XML查询语言中的表达式。
     但<productname>PostgreSQL</productname>只允许使用XPath 1.0的 表达式，正如在 <xref linkend="functions-xml-limits-xpath1"/>所讨论的。
    </para>
<!-- pgdoc-cn_end sig_en=5e72abaa3a562c1e364e2e6d2a4c8c42 -->

<!-- pgdoc-cn_start sig_en=df352afac8e6d42d09117061394b276a sig_cn_org=None source=14.1 
    <para>
     The required <literal>COLUMNS</literal> clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless <literal>FOR ORDINALITY</literal> is specified, in which case
     type <type>integer</type> is implicit).  The path, default and
     nullability clauses are optional.
    </para>
________________________________________________________-->
    <para>
     需要的<literal>COLUMNS</literal>子句指定将在输出表中生成的列。有关格式，请参阅上面的语法摘要。
     每个列都需要一个名称，作为一个数据类型(除非指定了 <literal>FOR ORDINALITY</literal>，在这种情况下类型 <type>integer</type>是隐式的)。
     路径、默认值以及为空性子句是可选的。	 
    </para>
<!-- pgdoc-cn_end sig_en=df352afac8e6d42d09117061394b276a -->

<!-- pgdoc-cn_start sig_en=fc9e9f5d8e40cf54e4c376bf6a276036 sig_cn_org=None source=14.1 
    <para>
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
    </para>
________________________________________________________-->
    <para>
     被标记为<literal>FOR ORDINALITY</literal>的列将按照从<replaceable>row_expression</replaceable>的结果节点集中检索到的节点的顺序，从1开始，填充行号。最多只能有一个列被标记为<literal>FOR ORDINALITY</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=fc9e9f5d8e40cf54e4c376bf6a276036 -->

    <note>
<!-- pgdoc-cn_start sig_en=558abc1ed317f1db5dccbd10ebdde6ef sig_cn_org=None source=14.1 
     <para>
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
     </para>
________________________________________________________-->
     <para>
      XPath 1.0 并没有为节点集中的节点指定顺序，因此依赖特定结果顺序的代码将取决于实现。 详情请参见 <xref linkend="xml-xpath-1-specifics"/>。
     </para>
<!-- pgdoc-cn_end sig_en=558abc1ed317f1db5dccbd10ebdde6ef -->
    </note>

<!-- pgdoc-cn_start sig_en=9f2b2069194edffd311b4115a5c91e2b sig_cn_org=None source=14.1 
    <para>
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
    </para>
________________________________________________________-->
    <para>
     列的<replaceable>column_expression</replaceable>是一个XPath 1.0表达式，它对每一行都要进行求值，并以<replaceable>row_expression</replaceable>结果中的当前节点作为其上下文项，以找到列的值。 如果没有给出<replaceable>column_expression</replaceable>，那么列名被用作隐式路径。
    </para>
<!-- pgdoc-cn_end sig_en=9f2b2069194edffd311b4115a5c91e2b -->

<!-- pgdoc-cn_start sig_en=0e1154521058a546ee29389bc17ef573 sig_cn_org=None source=14.1 
    <para>
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
    </para>
________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非XML值（在XPath 1.0中仅限于string、boolean或double），而该列的PostgreSQL类型不是<type>xml</type>，那么该列将被设置为将值的字符串表示法分配给PostgreSQL类型。 (如果值是布尔值，如果输出列的类型类别是数字，那么它的字符串表示方式将被认为是<literal>1</literal>或<literal>0</literal>，否则<literal>true</literal>或 <literal>false</literal>。)
    </para>
<!-- pgdoc-cn_end sig_en=0e1154521058a546ee29389bc17ef573 -->

<!-- pgdoc-cn_start sig_en=8601ec83a21438f64f14f805d51b5eff sig_cn_org=None source=14.1 
    <para>
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
     <footnote>
      <para>
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
      </para>
     </footnote>
    </para>
________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非空的XML节点集，并且该列的PostgreSQL类型是<type>xml</type>，那么如果该列是文档或内容形式的，那么该列将被精确地分配表达式结果。
     <footnote>
      <para>
       在顶层包含一个以上的元素节点的结果，或者在元素之外的非空格文本，就是内容形式的一个例子。
       一个XPath结果可以是这两种形式的，例如，如果它返回的是一个从包含它的元素中选择的属性节点。
       这样的结果将被放到内容形式中，每个不允许的节点都会被替换为它的字符串值，就像XPath 1.0<function>string</function> 函数定义的那样。       
      </para>
     </footnote>
    </para>
<!-- pgdoc-cn_end sig_en=8601ec83a21438f64f14f805d51b5eff -->

<!-- pgdoc-cn_start sig_en=05c3eae503d8f0dfcaeaa4102780475f sig_cn_org=None source=14.1 
    <para>
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
    </para>
________________________________________________________-->
    <para>
     分配给<type>xml</type>输出列的非XML结果会产生内容，一个带有结果字符串值的单个文本节点。分配给任何其他类型的列的XML结果不能有一个以上的节点，否则会产生错误。如果正好有一个节点，则该列将被设置为将该节点的字符串值（如XPath 1.0 <function>string</function>函数定义的那样）分配给PostgreSQL类型。
    </para>
<!-- pgdoc-cn_end sig_en=05c3eae503d8f0dfcaeaa4102780475f -->

<!-- pgdoc-cn_start sig_en=a6db74b0f131ffa28598fd9a9c8b6cf4 sig_cn_org=None source=14.1 
    <para>
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
    </para>
________________________________________________________-->
    <para>
     一个XML元素的字符串值是字符串值的协整，按文档的顺序。该元素中包含的所有文本节点及其子节点。字符串 元素的值是一个没有下级文本节点的元素的值是一个 空字符串（不是<literal>NULL</literal>）。任何<literal>xsi:nil</literal>属性都会被忽略。请注意，两个非文本之间的<literal>text()</literal>节点只用空格，而两个非文本 元素，并且保留了<literal>text()</literal>上的前导白格。节点不被扁平化。XPath 1.0中的<function>string</function>函数可以参考XPath 1.0中的 定义其他XML节点类型和非XML值的字符串值的规则。
    </para>
<!-- pgdoc-cn_end sig_en=a6db74b0f131ffa28598fd9a9c8b6cf4 -->

<!-- pgdoc-cn_start sig_en=00809139cd81cb06ff69522f9b6fcedf sig_cn_org=None source=14.1 
    <para>
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
________________________________________________________-->
    <para>
     这里介绍的转换规则并不完全是SQL标准中的转换规则，如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>
<!-- pgdoc-cn_end sig_en=00809139cd81cb06ff69522f9b6fcedf -->

<!-- pgdoc-cn_start sig_en=1fd8050d09b91c463f517db2642fdec5 sig_cn_org=None source=14.1 
    <para>
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
    </para>
________________________________________________________-->
    <para>
     如果路径表达式为给定行返回一个空节点集（通常情况下，当它不匹配时），该列将被设置为<literal>NULL</literal>，除非指定了<replaceable>default_expression</replaceable>；然后使用评价该表达式产生的值。
    </para>
<!-- pgdoc-cn_end sig_en=1fd8050d09b91c463f517db2642fdec5 -->

<!-- pgdoc-cn_start sig_en=c9ed43ceb50f5c20ef8d2860f5553dbc sig_cn_org=None source=14.1 
    <para>
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
    </para>
________________________________________________________-->
    <para>
     <replaceable>default_expression</replaceable>，而不是在调用<function>xmltable</function>时立即被评价，而是在每次需要列的默认值时，都会被评价。 如果表达式符合稳定或不可更改的条件，则可以跳过重复评价。 这意味着，你可以在<replaceable>default_expression</replaceable>中使用像<function>nextval</function>这样的不稳定函数。
    </para>
<!-- pgdoc-cn_end sig_en=c9ed43ceb50f5c20ef8d2860f5553dbc -->

<!-- pgdoc-cn_start sig_en=aed7a8f5767dbe2d8d7e91e293acae76 sig_cn_org=None source=14.1 
    <para>
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT
     NULL</literal> column does not match anything and there is
     no <literal>DEFAULT</literal> or
     the <replaceable>default_expression</replaceable> also evaluates to null,
     an error is reported.
    </para>
________________________________________________________-->
    <para>
     列可能会被标记为<literal>NOT NULL</literal>。如果一个<literal>NOT NULL</literal>列的<replaceable>column_expression</replaceable>不匹配任何东西并且没有<literal>DEFAULT</literal>或者<replaceable>default_expression</replaceable>也计算为空，则会报告一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=aed7a8f5767dbe2d8d7e91e293acae76 -->

<!-- pgdoc-cn_start sig_en=9d65fd99234702d600fb4437237e55bb sig_cn_org=0cc3b2204bbb5cb7c3a6b4999006ef88 source=15.7 
    <para>
     Examples:
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-&minus; xyxxz -&minus;>2a2<?aaaaa?> <!-&minus;x-&minus;>  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
   Hello2a2   bbbxxxCC
]]></screen>
    </para>
________________________________________________________-->
    <para>
     例子:
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT '未指定');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     下面的例子展示了多个text()节点的连接，列名作为XPath过滤器的使用，以及对空格、XML注释和处理指令的处理:

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-&minus; xyxxz -&minus;>2a2<?aaaaa?> <!-&minus;x-&minus;>  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
   Hello2a2   bbbxxxCC
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=9d65fd99234702d600fb4437237e55bb -->

<!-- pgdoc-cn_start sig_en=5f765a7e50cb9ae108f3638c530177db sig_cn_org=None source=14.1 
    <para>
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-&minus;-&minus;-+-&minus;-&minus;-
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
________________________________________________________-->
    <para>
     下面的例子展示了如何使用<literal>XMLNAMESPACES</literal>子句指定用在XML文档以及XPath表达式中的名字空间列表：

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
<!-- pgdoc-cn_end sig_en=5f765a7e50cb9ae108f3638c530177db -->
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!-- pgdoc-cn_start sig_en=5bfc4148594eebd133817b59aad3ed01 sig_cn_org=None source=14.1 
   <title>Mapping Tables to XML</title>
________________________________________________________-->
   <title>将表映射到 XML</title>
<!-- pgdoc-cn_end sig_en=5bfc4148594eebd133817b59aad3ed01 -->

<!-- pgdoc-cn_start sig_en=dc898ac752e91542401de284a63e00fe sig_cn_org=None source=14.1 
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dc898ac752e91542401de284a63e00fe -->

<!-- pgdoc-cn_start sig_en=9a9e513379f1c7eab88d02de31f1bae1 sig_cn_org=None source=14.1 
   <para>
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
________________________________________________________-->
   <para>
    下面的函数将会把关系表的内容映射成 XML 值。它们可以被看成是 XML 导出功能：
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=9a9e513379f1c7eab88d02de31f1bae1 -->

<!-- pgdoc-cn_start sig_en=9063b4c3c15003f82c50d1f4737541a6 sig_cn_org=None source=14.1 
   <para>
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>table</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualification and
    double quotes (see <xref linkend="datatype-oid"/> for details).
    <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
   </para>
________________________________________________________-->
   <para>
    <function>table_to_xml</function>映射由参数<parameter>table</parameter>传递的命名表的内容。
    <type>regclass</type>类型接受使用常见标记标识表的字符串，包括可选的模式限定和双引号(详见<xref linkend="datatype-oid"/> )。
    <function>query_to_xml</function>执行由参数<parameter>query</parameter>传递的查询并且映射结果集。
    <function>cursor_to_xml</function>从<parameter>cursor</parameter>指定的游标中取出指定数量的行。
    如果需要映射一个大型的表，我们推荐这种变体，因为每一个函数都是在内存中构建结果值的。
   </para>
<!-- pgdoc-cn_end sig_en=9063b4c3c15003f82c50d1f4737541a6 -->

<!-- pgdoc-cn_start sig_en=ab2679968e957f2117a5f5c4125fea5e sig_cn_org=None source=14.1 
   <para>
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
   </para>
________________________________________________________-->
   <para>
    如果<parameter>tableforest</parameter>为假，则结果的 XML 文档看起来像这样：
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    如果<parameter>tableforest</parameter>为真，结果是一个看起来像这样的 XML 内容片断：
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    如果没有表名可用，在映射一个查询或一个游标时，在第一种格式中使用串<literal>table</literal>，在第二种格式中使用<literal>row</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=ab2679968e957f2117a5f5c4125fea5e -->

<!-- pgdoc-cn_start sig_en=6dbbd19fb594a1a974b65e3ea58edfcb sig_cn_org=None source=14.1 
   <para>
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
   </para>
________________________________________________________-->
   <para>
    这几种格式的选择由用户决定。第一种格式是一个正确的 XML 文档，它在很多应用中都很重要。如果结果值要被重组为一个文档，第二种格式在<function>cursor_to_xml</function>函数中更有用。前文讨论的产生 XML 内容的函数（特别是<function>xmlelement</function>）可以被用来把结果修改成符合用户的要求。
   </para>
<!-- pgdoc-cn_end sig_en=6dbbd19fb594a1a974b65e3ea58edfcb -->

<!-- pgdoc-cn_start sig_en=af15fc1439652bff701de1b039deb1b4 sig_cn_org=None source=14.1 
   <para>
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
   </para>
________________________________________________________-->
   <para>
    数据值会被以前文的函数<function>xmlelement</function>中描述的相同方法映射。
   </para>
<!-- pgdoc-cn_end sig_en=af15fc1439652bff701de1b039deb1b4 -->

<!-- pgdoc-cn_start sig_en=9f76832e6907bd787d076f5d1f5a846b sig_cn_org=None source=14.1 
   <para>
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
   </para>
________________________________________________________-->
   <para>
    参数<parameter>nulls</parameter>决定空值是否会被包含在输出中。如果为真，列中的空值被表示为：
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    其中<literal>xsi</literal>是 XML 模式实例的 XML 名字空间前缀。一个合适的名字空间声明将被加入到结果值中。如果为假，包含空值的列将被从输出中忽略掉。
   </para>
<!-- pgdoc-cn_end sig_en=9f76832e6907bd787d076f5d1f5a846b -->

<!-- pgdoc-cn_start sig_en=19b5885c20e3c57ce5b039f49b7aad37 sig_cn_org=None source=14.1 
   <para>
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
   </para>
________________________________________________________-->
   <para>
    参数<parameter>targetns</parameter>指定想要的结果的 XML 名字空间。如果没有想要的特定名字空间，将会传递一个空串。
   </para>
<!-- pgdoc-cn_end sig_en=19b5885c20e3c57ce5b039f49b7aad37 -->

<!-- pgdoc-cn_start sig_en=9a879fe625030aabcdc0b1b5a0d95d9e sig_cn_org=None source=14.1 
   <para>
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
   </para>
________________________________________________________-->
   <para>
    下面的函数返回 XML 模式文档，这些文档描述上述对应函数所执行的映射：
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    最重要的是相同的参数被传递来获得匹配的 XML 数据映射和 XML 模式文档。
   </para>
<!-- pgdoc-cn_end sig_en=9a879fe625030aabcdc0b1b5a0d95d9e -->

<!-- pgdoc-cn_start sig_en=3dba796185863d50e6317ade3cd3c6d7 sig_cn_org=None source=14.1 
   <para>
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
________________________________________________________-->
   <para>
    下面的函数产生 XML 数据映射和对应的 XML 模式，并把产生的结果链接在一起放在一个文档（或森林）中。在要求自包含和自描述的结果是它们非常有用：
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=3dba796185863d50e6317ade3cd3c6d7 -->

<!-- pgdoc-cn_start sig_en=db4f920ef566ad2e47fa9b249e514a07 sig_cn_org=None source=14.1 
   <para>
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have <literal>USAGE</literal> (lookup) privilege for.
   </para>
________________________________________________________-->
   <para>
    另外，下面的函数可用于产生相似的整个模式或整个当前数据库的映射：
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    这些函数会忽略当前用户不可读的表。数据库范围的函数还会忽略当前用户没有<literal>USAGE</literal> (查找)权限的模式。
   </para>
<!-- pgdoc-cn_end sig_en=db4f920ef566ad2e47fa9b249e514a07 -->

<!-- pgdoc-cn_start sig_en=b141278dc40ef62cc52dd4710deec54a sig_cn_org=None source=14.1 
   <para>
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
   </para>
________________________________________________________-->
   <para>
    请注意，这可能会产生大量数据，这些数据需要在内存中构建。
    当请求大型模式或数据库的内容映射时，可能值得考虑单独映射表，甚至可能通过游标。
   </para>
<!-- pgdoc-cn_end sig_en=b141278dc40ef62cc52dd4710deec54a -->

<!-- pgdoc-cn_start sig_en=71491c2cefda211169d453be88d56b67 sig_cn_org=None source=14.1 
   <para>
    The result of a schema content mapping looks like this:

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
   </para>
________________________________________________________-->
   <para>
    一个模式内容映射的结果看起来像这样：

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    其中一个表映射的格式取决于上文解释的<parameter>tableforest</parameter>参数。
   </para>
<!-- pgdoc-cn_end sig_en=71491c2cefda211169d453be88d56b67 -->

<!-- pgdoc-cn_start sig_en=8008034a714fe23d9d583a20a0715b9c sig_cn_org=None source=14.1 
   <para>
    The result of a database content mapping looks like this:

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    where the schema mapping is as above.
   </para>
________________________________________________________-->
   <para>
    一个数据库内容映射的结果看起来像这样：

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    其中的模式映射如上所述。
   </para>
<!-- pgdoc-cn_end sig_en=8008034a714fe23d9d583a20a0715b9c -->

<!-- pgdoc-cn_start sig_en=808261b07772cd092abcf59fb464fbd8 sig_cn_org=None source=14.1 
   <para>
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
   </para>
________________________________________________________-->
   <para>
    作为一个使用这些函数产生的输出的例子，<xref linkend="xslt-xml-html"/>展示了一个 XSLT 样式表，它将<function>table_to_xml_and_xmlschema</function>的输出转换为一个包含表数据的扁平转印的 HTML 文档。以一种相似的方式，这些函数的结果可以被转换成其他基于 XML 的格式。
   </para>
<!-- pgdoc-cn_end sig_en=808261b07772cd092abcf59fb464fbd8 -->

   <example id="xslt-xml-html">
<!-- pgdoc-cn_start sig_en=60f1c4a922b862f2bbd0f68535630bf9 sig_cn_org=None source=14.1 
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
________________________________________________________-->
    <title>转换 SQL/XML 输出到 HTML 的 XSLT 样式表</title>
<!-- pgdoc-cn_end sig_en=60f1c4a922b862f2bbd0f68535630bf9 -->
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
<!-- pgdoc-cn_start sig_en=f714a4c4f73e1a25feead1bdea0ab62e sig_cn_org=None source=14.1 
  <title>JSON Functions and Operators</title>
________________________________________________________-->
  <title>JSON 函数和操作符</title>
<!-- pgdoc-cn_end sig_en=f714a4c4f73e1a25feead1bdea0ab62e -->

<!-- pgdoc-cn_start sig_en=db25181d796895ccd98827f23003cd7d sig_cn_org=None source=14.1 
  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>functions and operators</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>函数和操作符</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=db25181d796895ccd98827f23003cd7d -->

<!-- pgdoc-cn_start sig_en=df0b2dff725a2caff2223ee73a78ef53 sig_cn_org=None source=14.1 
  <para>
   This section describes:

   <itemizedlist>
    <listitem>
     <para>
      functions and operators for processing and creating JSON data
     </para>
    </listitem>
    <listitem>
     <para>
      the SQL/JSON path language
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   本节描述:

   <itemizedlist>
    <listitem>
     <para>
      用于处理和创建JSON数据的函数和运算器
     </para>
    </listitem>
    <listitem>
     <para>
      SQL/JSON路径语言
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=df0b2dff725a2caff2223ee73a78ef53 -->

<!-- pgdoc-cn_start sig_en=8b5ee100a2f55da3529e4ceee2a5e9a7 sig_cn_org=None source=14.1 
  <para>
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
  </para>
________________________________________________________-->
  <para>
   要了解有关SQL/JSON标准的更多信息，请参阅<xref linkend="sqltr-19075-6"/>。有关<productname>PostgreSQL</productname>中支持的JSON类型的详细信息，见 <xref linkend="datatype-json"/>。
  </para>
<!-- pgdoc-cn_end sig_en=8b5ee100a2f55da3529e4ceee2a5e9a7 -->

  <sect2 id="functions-json-processing">
<!-- pgdoc-cn_start sig_en=b987c9cdecf9ab4a13e7bcc57fc1fd2e sig_cn_org=None source=14.1 
   <title>Processing and Creating JSON Data</title>
________________________________________________________-->
   <title>处理和创建JSON数据</title>
<!-- pgdoc-cn_end sig_en=b987c9cdecf9ab4a13e7bcc57fc1fd2e -->

<!-- pgdoc-cn_start sig_en=6e8ea53b370fba5a3d9043f2eb0f495f sig_cn_org=ba76bdc2176103d05f5b8e574171f498 source=15.7 
  <para>
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
   In addition, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, though not for <type>json</type>.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   <xref linkend="json-indexing"/>.
   See also <xref linkend="functions-aggregate"/> for the aggregate
   function <function>json_agg</function> which aggregates record
   values as JSON, the aggregate function
   <function>json_object_agg</function> which aggregates pairs of values
   into a JSON object, and their <type>jsonb</type> equivalents,
   <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-json-op-table"/>显示了可用于JSON数据类型的运算符（参见<xref linkend="datatype-json"/>）。
   此外，<xref linkend="functions-comparison-op-table"/>中显示的常规比较运算符可用于<type>jsonb</type>，但不适用于<type>json</type>。
   比较运算符遵循B树操作的排序规则，详见<xref linkend="json-indexing"/>。
   另请参阅<xref linkend="functions-aggregate"/>，了解聚合函数<function>json_agg</function>，将记录值聚合为JSON，
   聚合函数<function>json_object_agg</function>将值对聚合为JSON对象，以及它们的<type>jsonb</type>等效函数，
   <function>jsonb_agg</function>和<function>jsonb_object_agg</function>。
</para>
<!-- pgdoc-cn_end sig_en=6e8ea53b370fba5a3d9043f2eb0f495f -->

  <table id="functions-json-op-table">
<!-- pgdoc-cn_start sig_en=5abf9ab116d6693c33b3583a54a45d0a sig_cn_org=None source=14.1 
    <title><type>json</type> and <type>jsonb</type> Operators</title>
________________________________________________________-->
    <title><type>json</type> 和 <type>jsonb</type> 操作符</title>
<!-- pgdoc-cn_end sig_en=5abf9ab116d6693c33b3583a54a45d0a -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=924365c21b883bf75d87541dbbfe7cbe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素(数组元素从0开始索引，但负整数从末尾开始计数)。
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=924365c21b883bf75d87541dbbfe7cbe -->

<!-- pgdoc-cn_start sig_en=35ea93fab6aec92aeb3848064ac3d144 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key.
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段。
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=35ea93fab6aec92aeb3848064ac3d144 -->

<!-- pgdoc-cn_start sig_en=26501a9a1590ae5a1be15098626fbf15 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array,
        as <type>text</type>.
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素，作为<type>text</type>。
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=26501a9a1590ae5a1be15098626fbf15 -->

<!-- pgdoc-cn_start sig_en=42fad09a998cdd183ac9bf11782a1013 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key, as <type>text</type>.
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段，作为<type>text</type>。
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=42fad09a998cdd183ac9bf11782a1013 -->

<!-- pgdoc-cn_start sig_en=a50eb4628121a440754df22a9867810e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取指定路径下的JSON子对象，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a50eb4628121a440754df22a9867810e -->

<!-- pgdoc-cn_start sig_en=afca6b8985d7c4dd3ffe7099dadc8757 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>text</type>。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=afca6b8985d7c4dd3ffe7099dadc8757 -->
     </tbody>
    </tgroup>
   </table>

  <note>
<!-- pgdoc-cn_start sig_en=e9c33d2e9fc9fa8d4cdb5a9a14609414 sig_cn_org=None source=14.1 
   <para>
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
   </para>
________________________________________________________-->
   <para>
    如果JSON输入没有匹配请求的正确结构，字段/元素/路径提取操作符返回NULL，而不是失败;例如，如果不存在这样的键或数组元素。
   </para>
<!-- pgdoc-cn_end sig_en=e9c33d2e9fc9fa8d4cdb5a9a14609414 -->
  </note>

<!-- pgdoc-cn_start sig_en=5732a2061fb80c3bcf32b402ce277387 sig_cn_org=None source=14.1 
  <para>
   Some further operators exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively search indexed
   <type>jsonb</type> data.
  </para>
________________________________________________________-->
  <para>
   还有一些操作符仅适用于<type>jsonb</type>，如表<xref linkend="functions-jsonb-op-table"/>所示。
   第<xref linkend="json-indexing"/>描述了如何使用这些操作符来有效地搜索索引的<type>jsonb</type>数据。
  </para>
<!-- pgdoc-cn_end sig_en=5732a2061fb80c3bcf32b402ce277387 -->

  <table id="functions-jsonb-op-table">
<!-- pgdoc-cn_start sig_en=f88b03073e20c0c8e97901d54885f50a sig_cn_org=None source=14.1 
    <title>Additional <type>jsonb</type> Operators</title>
________________________________________________________-->
    <title>附加的 <type>jsonb</type> 操作符</title>
<!-- pgdoc-cn_end sig_en=f88b03073e20c0c8e97901d54885f50a -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=81c14014137803afeaaf6171d85153c0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first JSON value contain the second?
        (See <xref linkend="json-containment"/> for details about containment.)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个JSON值是否包含第二个?(请参见<xref linkend="json-containment"/>以了解包含的详细信息。)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=81c14014137803afeaaf6171d85153c0 -->

<!-- pgdoc-cn_start sig_en=c194b86bcb9ef74452cf9e40dbcf2e2d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first JSON value contained in the second?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第二个JSON中是否包含第一个JSON值?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c194b86bcb9ef74452cf9e40dbcf2e2d -->

<!-- pgdoc-cn_start sig_en=74f99440d7503ed35dff19c9da292632 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the text string exist as a top-level key or array element within
        the JSON value?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本字符串是否作为JSON值中的顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74f99440d7503ed35dff19c9da292632 -->

<!-- pgdoc-cn_start sig_en=787516944c83ca95179d8148e2638d32 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do any of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的字符串是否作为顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=787516944c83ca95179d8148e2638d32 -->

<!-- pgdoc-cn_start sig_en=efbc017aa46cac98ce9107e2a76f9f85 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do all of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的所有字符串都作为顶级键或数组元素存在吗?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=efbc017aa46cac98ce9107e2a76f9f85 -->

<!-- pgdoc-cn_start sig_en=d7fd2163d92fef0f5e039a1ca284352e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Concatenates two <type>jsonb</type> values.
        Concatenating two arrays generates an array containing all the
        elements of each input.  Concatenating two objects generates an
        object containing the union of their
        keys, taking the second object's value when there are duplicate keys.
        All other cases are treated by converting a non-array input into a
        single-element array, and then proceeding as for two arrays.
        Does not operate recursively: only the top-level array or object
        structure is merged.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || '3'::jsonb</literal>
        <returnvalue>[1, 2, 3]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '42'::jsonb</literal>
        <returnvalue>[{"a": "b"}, 42]</returnvalue>
       </para>
       <para>
        To append an array to another array as a single entry, wrap it
        in an additional layer of array, for example:
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</literal>
        <returnvalue>[1, 2, [3, 4]]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        连接两个<type>jsonb</type>值。
        连接两个数组将生成一个包含每个输入的所有元素的数组。
        连接两个对象将生成一个包含它们键的并集的对象，当存在重复的键时取第二个对象的值。
        所有其他情况都通过将非数组输入转换为单元素数组来处理，然后按照两个数组的方式进行处理。
        不递归操作:只有顶级数组或对象结构被合并。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || '3'::jsonb</literal>
        <returnvalue>[1, 2, 3]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '42'::jsonb</literal>
        <returnvalue>[{"a": "b"}, 42]</returnvalue>
       </para>
       <para>
        要将一个数组作为单个条目附加到另一个数组中，请将其包装在另一个数组附加层中，例如:
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</literal>
        <returnvalue>[1, 2, [3, 4]]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d7fd2163d92fef0f5e039a1ca284352e -->

<!-- pgdoc-cn_start sig_en=120a54065f5ca8734f5aba9c8633db5e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从JSON对象中删除键(以及它的值)，或从JSON数组中删除匹配的字符串值。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=120a54065f5ca8734f5aba9c8633db5e -->

<!-- pgdoc-cn_start sig_en=c267b858046963bc6008367acf286154 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all matching keys or array elements from the left operand.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从左操作数中删除所有匹配的键或数组元素。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c267b858046963bc6008367acf286154 -->

<!-- pgdoc-cn_start sig_en=98b27206e1576e73bf8105a6572ba61b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除具有指定索引的数组元素(负整数从末尾计数)。如果JSON值不是数组，则抛出错误。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=98b27206e1576e73bf8105a6572ba61b -->

<!-- pgdoc-cn_start sig_en=359ad3bfca9e38dda5649152ae9886c0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除指定路径上的字段或数组元素，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=359ad3bfca9e38dda5649152ae9886c0 -->

<!-- pgdoc-cn_start sig_en=761b0b84439c5f08842a9485d2d06bf1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does JSON path return any item for the specified JSON value?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON路径是否为指定的JSON值返回任何项?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=761b0b84439c5f08842a9485d2d06bf1 -->

<!-- pgdoc-cn_start sig_en=6dec588b0236f2662d17c482b5c2c88c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the
        specified JSON value.  Only the first item of the result is taken into
        account.  If the result is not Boolean, then <literal>NULL</literal>
        is returned.
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只考虑结果的第一项。如果结果不是布尔值，则返回<literal>NULL</literal>。
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6dec588b0236f2662d17c482b5c2c88c -->
     </tbody>
    </tgroup>
   </table>

  <note>
<!-- pgdoc-cn_start sig_en=d4c9826b8c8ab76d33cbd19279072796 sig_cn_org=None source=14.1 
   <para>
    The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
________________________________________________________-->
   <para>
    <type>jsonpath</type>操作符<literal>@?</literal> 和 <literal>@@</literal>抑制以下错误:缺少对象字段或数组元素，意外的JSON项目类型，日期时间和数字错误。
    还可以告诉以下描述的与<type>jsonpath</type>相关的函数来抑制这些类型的错误。
    在搜索不同结构的JSON文档集合时，此行为可能会有所帮助。
   </para>
<!-- pgdoc-cn_end sig_en=d4c9826b8c8ab76d33cbd19279072796 -->
  </note>

<!-- pgdoc-cn_start sig_en=ef4649f00b9d9846ea6a7ce6c6383c81 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for constructing <type>json</type> and <type>jsonb</type> values.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-json-creation-table"/> 显示可用于构造<type>json</type>和<type>jsonb</type>值的函数。
  </para>
<!-- pgdoc-cn_end sig_en=ef4649f00b9d9846ea6a7ce6c6383c81 -->

  <table id="functions-json-creation-table">
<!-- pgdoc-cn_start sig_en=f46e45ba16893767a7fc34c93299cad3 sig_cn_org=None source=14.1 
    <title>JSON Creation Functions</title>
________________________________________________________-->
    <title>JSON 创建函数</title>
<!-- pgdoc-cn_end sig_en=f46e45ba16893767a7fc34c93299cad3 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=fcf002adb095ab872dccd2a3840d549a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Converts any SQL value to <type>json</type> or <type>jsonb</type>.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to <type>json</type>, the cast function will be used to perform the
        conversion;<footnote>
         <para>
          For example, the <xref linkend="hstore"/> extension has a cast
          from <type>hstore</type> to <type>json</type>, so that
          <type>hstore</type> values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
         </para>
        </footnote>
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        将任何SQL值转换为<type>json</type>或<type>jsonb</type>。数组和组合递归地转换为数组和对象(多维数组在JSON中变成数组的数组)。
        否则，如果存在从SQL数据类型到<type>json</type>的类型转换，则造型函数将用于执行转换;
        <footnote>
         <para>
          例如，<xref linkend="hstore"/>扩展有一个从<type>hstore</type>到<type>json</type>的转换，这样通过json创建函数转换的<type>hstore</type>值将被表示为json对象，而不是原始字符串值
         </para>
        </footnote>
        否则，将生成一个标量json值。对于除数字、布尔值或空值之外的任何标量，将使用文本表示，并根据需要进行转义，使其成为有效的JSON字符串值。
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fcf002adb095ab872dccd2a3840d549a -->

<!-- pgdoc-cn_start sig_en=5efed7d1c800b0bdd54a5029a25bc237 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts an SQL array to a JSON array.  The behavior is the same
        as <function>to_json</function> except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL数组转换为JSON数组。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级数组元素之间添加。
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5efed7d1c800b0bdd54a5029a25bc237 -->

<!-- pgdoc-cn_start sig_en=0270182f2c35f7e5e04fd73e3f36b0a5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts an SQL composite value to a JSON object.  The behavior is the
        same as <function>to_json</function> except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL组合值转换为JSON对象。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级元素之间添加。
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0270182f2c35f7e5e04fd73e3f36b0a5 -->

<!-- pgdoc-cn_start sig_en=5ee48ce661615ab61262cd748726e677 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建可能异构类型的JSON数组。每个参数都按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5ee48ce661615ab61262cd748726e677 -->

<!-- pgdoc-cn_start sig_en=3a74fcd813d8191e4f404f5897f38c6a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建一个JSON对象。按照惯例，参数列表由交替的键和值组成。
        关键参数强制转换为文本;值参数按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3a74fcd813d8191e4f404f5897f38c6a -->

<!-- pgdoc-cn_start sig_en=8693d13aa0a8f89d177f8857aa069bbf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从文本数组构建JSON对象。该数组必须有两个维度，一个维度的成员数为偶数，在这种情况下，它们被视为交替的键/值对;
        另一个维度的成员数为二维，每个内部数组恰好有两个元素，它们被视为键/值对。所有值都转换为JSON字符串。
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8693d13aa0a8f89d177f8857aa069bbf -->

<!-- pgdoc-cn_start sig_en=c11c3b0e626a65cffacd00c6d3f4c5cc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        This form of <function>json_object</function> takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这种形式的<function>json_object</function>从单独的文本数组中成对地获取键和值。否则，它与单参数形式相同。
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c11c3b0e626a65cffacd00c6d3f4c5cc -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=a6687a23d958cba57210787ed749c6a8 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-json-processing-table"/> 显示可用于处理<type>json</type>和<type>jsonb</type>值的函数。
  </para>
<!-- pgdoc-cn_end sig_en=a6687a23d958cba57210787ed749c6a8 -->

  <table id="functions-json-processing-table">
<!-- pgdoc-cn_start sig_en=a4f5a3e2bf77c608cf37d52c3c0680be sig_cn_org=None source=14.1 
    <title>JSON Processing Functions</title>
________________________________________________________-->
    <title>JSON 处理函数</title>
<!-- pgdoc-cn_end sig_en=a4f5a3e2bf77c608cf37d52c3c0680be -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=6859c5cbf29cc05b9d234eb5504cb623 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of JSON values.
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组JSON值。
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6859c5cbf29cc05b9d234eb5504cb623 -->

<!-- pgdoc-cn_start sig_en=70b3027ee6b649d2eb1665b0a1714661 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of <type>text</type> values.
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 foo
 bar
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组<type>文本</type>值。
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=70b3027ee6b649d2eb1665b0a1714661 -->

<!-- pgdoc-cn_start sig_en=20e43a6629375a6b2adb5f232167fa97 sig_cn_org=722e04f6b01ec3bfbbd411ac8ece0678 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of elements in the top-level JSON array.
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para>
       <para>
        <literal>jsonb_array_length('[]')</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回顶层JSON数组中的元素数量。
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para>
       <para>
        <literal>jsonb_array_length('[]')</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=20e43a6629375a6b2adb5f232167fa97 -->

<!-- pgdoc-cn_start sig_en=a65034e14c74fdee655e5d9451191a91 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        将顶级JSON对象展开为一组键/值对。
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a65034e14c74fdee655e5d9451191a91 -->

<!-- pgdoc-cn_start sig_en=bf2020562229d04138e895a467afc905 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
        The returned <parameter>value</parameter>s will be of
        type <type>text</type>.
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        将顶级JSON对象扩展为一组键/值对。返回的<parameter>值</parameter>的类型为<type>文本</type>。
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bf2020562229d04138e895a467afc905 -->

<!-- pgdoc-cn_start sig_en=26f16d0bf6b036018d0160bbf1b0e8a1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the <literal>#&gt;</literal>
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        在指定路径下提取JSON子对象。(这在功能上相当于<literal>#&gt;</literal>操作符，但在某些情况下，将路径写成可变参数列表会更方便。)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=26f16d0bf6b036018d0160bbf1b0e8a1 -->

<!-- pgdoc-cn_start sig_en=44a7f27f640b51b05341171038929804 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
        (This is functionally equivalent to the <literal>#&gt;&gt;</literal>
        operator.)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>文本</type>。(这在功能上等同于<literal>#&gt;&gt;</literal>操作符。)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=44a7f27f640b51b05341171038929804 -->

<!-- pgdoc-cn_start sig_en=b4717b9d85273f268a6f77ba64a371d9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of keys in the top-level JSON object.
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f1
 f2
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回顶级JSON对象中的键集合。
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b4717b9d85273f268a6f77ba64a371d9 -->

<!-- pgdoc-cn_start sig_en=eaee778ddae7d475058da9e6284f2bdc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        of the <parameter>base</parameter> argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of <parameter>base</parameter> is just
        <literal>NULL</literal>, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if <parameter>base</parameter> isn't <literal>NULL</literal> then
        the values it contains will be used for unmatched columns.
       </para>
       <para>
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           A JSON null value is converted to an SQL null in all cases.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is of type <type>json</type>
           or <type>jsonb</type>, the JSON value is just reproduced exactly.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        While the example below uses a constant JSON value, typical use would
        be to reference a <type>json</type> or <type>jsonb</type> column
        laterally from another table in the query's <literal>FROM</literal>
        clause.  Writing <function>json_populate_record</function> in
        the <literal>FROM</literal> clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        将顶级JSON对象扩展为具有<parameter>基本</parameter>参数的复合类型的行。JSON对象将被扫描，查找名称与输出行类型的列名匹配的字段，并将它们的值插入到输出的这些列中。
        (不对应任何输出列名的字段将被忽略。)在典型的使用中，<parameter>基本</parameter>的值仅为<literal>NULL</literal>，这意味着任何不匹配任何对象字段的输出列都将被填充为空。
        但是，如果<parameter>base</parameter>不为<literal>NULL</literal>，那么它包含的值将用于不匹配的列。
       </para>
       <para>
        要将JSON值转换为输出列的SQL类型，需要按次序应用以下规则:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           在所有情况下，JSON空值都会转换为SQL空值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列的类型是<type>json</type>或<type>jsonb</type>，则会精确地重制JSON值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列是复合(行)类型，且JSON值是JSON对象，则该对象的字段将转换为输出行类型的列，通过这些规则的递归应用程序。
          </para>
         </listitem>
         <listitem>
          <para>
           同样，如果输出列是数组类型，而JSON值是JSON数组，则通过这些规则的递归应用程序将JSON数组的元素转换为输出数组的元素。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，如果JSON值是字符串，则将字符串的内容提供给输入转换函数，用以确定列的数据类型。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，JSON值的普通文本表示将被提供给输入转换函数，以确定列的数据类型。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        虽然下面的示例使用一个常量JSON值，典型的用法是在查询的<literal>FROM</literal>子句中从另一个表侧面地引用<type>json</type>或<type>jsonb</type>列。
        在<literal>FROM</literal>子句中编写<function>json_populate_record</function>是一种很好的实践，因为提取的所有列都可以使用，而不需要重复的函数调用。
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eaee778ddae7d475058da9e6284f2bdc -->

<!-- pgdoc-cn_start sig_en=347b416aab24368881fbe7bba0206c41 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the <parameter>base</parameter> argument.
        Each element of the JSON array is processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
-&minus;-+-&minus;-
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将对象的顶级JSON数组展开为一组具有<parameter>基本</parameter>参数的复合类型的行。
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=347b416aab24368881fbe7bba0206c41 -->

<!-- pgdoc-cn_start sig_en=bd9dd4cb3d54a0bda361aa736192f0ff sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        defined by an <literal>AS</literal> clause.  (As with all functions
        returning <type>record</type>, the calling query must explicitly
        define the structure of the record with an <literal>AS</literal>
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for <function>json[b]_populate_record</function>.  Since there is no
        input record value, unmatched columns are always filled with nulls.
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        将顶级JSON对象展开为具有由 <literal>AS</literal>子句定义的复合类型的行。
        (与所有返回<type>record</type>的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        输出记录由JSON对象的字段填充，与上面描述的<function>json[b]_populate_record</function>的方式相同。
        由于没有输入记录值，不匹配的列总是用空值填充。
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bd9dd4cb3d54a0bda361aa736192f0ff -->

<!-- pgdoc-cn_start sig_en=309d8a34c35c07af5f17180b7fd2f8d9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an <literal>AS</literal> clause.  (As
        with all functions returning <type>record</type>, the calling query
        must explicitly define the structure of the record with
        an <literal>AS</literal> clause.)  Each element of the JSON array is
        processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        将顶级JSON对象数组展开为一组由<literal>AS</literal>子句定义的复合类型的行。
        (与所有返回record的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=309d8a34c35c07af5f17180b7fd2f8d9 -->

<!-- pgdoc-cn_start sig_en=1e331c7065c738cc6bf9bb4c59ecc1fe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with the item designated by <parameter>path</parameter>
        replaced by <parameter>new_value</parameter>, or with
        <parameter>new_value</parameter> added if
        <parameter>create_if_missing</parameter> is true (which is the
        default) and the item designated by <parameter>path</parameter>
        does not exist.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and <parameter>create_if_missing</parameter> is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回<parameter>target</parameter>，将<parameter>path</parameter>指定的项替换为<parameter>new_value</parameter>，
        如果<parameter>create_if_missing</parameter>为真(此为默认值)并且<parameter>path</parameter>指定的项不存在，则添加<parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的<parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组索引，并且<parameter>create_if_missing</parameter>为真，那么如果索引为负，新值将添加到数组的开头，如果索引为正，则添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1e331c7065c738cc6bf9bb4c59ecc1fe -->

<!-- pgdoc-cn_start sig_en=df006b586d87a98be567c46c55a1711c sig_cn_org=5a529c11ba780b6b8fe2e155851930fa source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        If <parameter>new_value</parameter> is not <literal>NULL</literal>,
        behaves identically to <literal>jsonb_set</literal>. Otherwise behaves
        according to the value
        of <parameter>null_value_treatment</parameter> which must be one
        of <literal>'raise_exception'</literal>,
        <literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, or
        <literal>'return_target'</literal>. The default is
        <literal>'use_json_null'</literal>.
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1": null, "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        如果<parameter>new_value</parameter>不是<literal>NULL</literal>，则行为与<literal>jsonb_set</literal>完全相同。否则，根据<parameter>null_value_treatment</parameter>的值进行处理，其值必须是<literal>'raise_exception'</literal>、<literal>'use_json_null'</literal>、<literal>'delete_key'</literal>或<literal>'return_target'</literal>之一。默认值为<literal>'use_json_null'</literal>。
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1": null, "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=df006b586d87a98be567c46c55a1711c -->

<!-- pgdoc-cn_start sig_en=28c6a8b678d29827d563f0545cd5bf6a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with <parameter>new_value</parameter> inserted.  If the item
        designated by the <parameter>path</parameter> is an array
        element, <parameter>new_value</parameter> will be inserted before
        that item if <parameter>insert_after</parameter> is false (which
        is the default), or after it
        if <parameter>insert_after</parameter> is true.  If the item
        designated by the <parameter>path</parameter> is an object
        field, <parameter>new_value</parameter> will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回插入<parameter>new_value</parameter>的<parameter>target</parameter>。
        如果<parameter>path</parameter>指派的项是一个数组元素，如果 <parameter>insert_after</parameter>为假(此为默认值)，则<parameter>new_value</parameter>将被插入到该项之前，如果 <parameter>insert_after</parameter>为真则在该项之后。
        如果由<parameter>path</parameter>指派的项是一个对象字段，则只在对象不包含该键时才插入 <parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的 <parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组下标，则如果下标为负，则将新值添加到数组的开头;如果下标为正，则将新值添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28c6a8b678d29827d563f0545cd5bf6a -->

<!-- pgdoc-cn_start sig_en=1b81b8973b7c803ff6f99b5e0ac09bf9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从给定的JSON值中删除所有具有空值的对象字段，递归地。非对象字段的空值是未受影响的。
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1b81b8973b7c803ff6f99b5e0ac09bf9 -->

<!-- pgdoc-cn_start sig_en=9aca190c1eaedb946c796369ac505012 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the JSON path returns any item for the specified JSON
        value.
        If the <parameter>vars</parameter> argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the <type>jsonpath</type> expression.
        If the <parameter>silent</parameter> argument is specified and
        is <literal>true</literal>, the function suppresses the same errors
        as the <literal>@?</literal> and <literal>@@</literal> operators do.
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查JSON路径是否返回指定JSON值的任何项。如果指定了<parameter>vars</parameter>参数，则它必须是一个JSON对象，并且它的字段提供要替换到<type>jsonpath</type>表达式中的名称值。
        如果指定了<parameter>silent</parameter>参数并为<literal>true</literal>，函数会抑制与<literal>@?</literal> 和 <literal>@@</literal>运算符相同的错误。
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9aca190c1eaedb946c796369ac505012 -->

<!-- pgdoc-cn_start sig_en=4bb5f7fb3597356a375227e54512ffa3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the specified
        JSON value.  Only the first item of the result is taken into account.
        If the result is not Boolean, then <literal>NULL</literal> is returned.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只有结果的第一项被考虑在内。
        如果结果不是布尔值，则返回<literal>NULL</literal>。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4bb5f7fb3597356a375227e54512ffa3 -->

<!-- pgdoc-cn_start sig_en=bddc2114e05dbad33df8f7ba911f18c0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2
 3
 4
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bddc2114e05dbad33df8f7ba911f18c0 -->

<!-- pgdoc-cn_start sig_en=8c7d16419fd59f313ea74c102970bd37 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        以JSON数组的形式返回由JSON路径为指定的JSON值返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c7d16419fd59f313ea74c102970bd37 -->

<!-- pgdoc-cn_start sig_en=bd90a9a60e1c1d3e6057c6f13ffdb64f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns the first JSON item returned by the JSON path for the
        specified JSON value.  Returns <literal>NULL</literal> if there are no
        results.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的第一个JSON项。如果没有结果则返回<literal>NULL</literal>。
        可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与 <function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bd90a9a60e1c1d3e6057c6f13ffdb64f -->

<!-- pgdoc-cn_start sig_en=67b8fff24a7295c4a40f207b6604c564 sig_cn_org=6813d90108a532a3474f0e39467e0888 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        These functions act like their counterparts described above without
        the <literal>_tz</literal> suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value <literal>2015-08-02</literal> as a timestamp with time
        zone, so the result depends on the current
        <xref linkend="guc-timezone"/> setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00-05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这些函数的作用类似于上面描述的没有<literal>_tz</literal>后缀的对应函数，不同之处在于这些函数支持需要时区感知转换的日期/时间值的比较。
        下面的示例需要将仅日期值<literal>2015-08-02</literal>解释为带有时区的时间戳，因此结果取决于当前的<xref linkend="guc-timezone"/>设置。
        由于这种依赖性，这些函数被标记为稳定的，这意味着这些函数不能用于索引。它们的对应函数是不可变的，因此可以用于索引；但如果要求进行这样的比较，它们将抛出错误。
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00-05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=67b8fff24a7295c4a40f207b6604c564 -->

<!-- pgdoc-cn_start sig_en=630afe9021b76f0c6cee25b43930ce36 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given JSON value to pretty-printed, indented text.
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的JSON值转换为精美打印的，缩进的文本。
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=630afe9021b76f0c6cee25b43930ce36 -->

<!-- pgdoc-cn_start sig_en=5e277fedc6c7f4e7a2e7870807107a84 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        <literal>object</literal>, <literal>array</literal>,
        <literal>string</literal>, <literal>number</literal>,
        <literal>boolean</literal>, and <literal>null</literal>.
        (The <literal>null</literal> result should not be confused
        with an SQL NULL; see the examples.)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本字符串形式返回顶级JSON值的类型。可能的类型有<literal>object</literal>, <literal>array</literal>,<literal>string</literal>, <literal>number</literal>,<literal>boolean</literal>, 和 <literal>null</literal>。
        (<literal>null</literal>的结果不应该与SQL NULL 混淆;参见示例。)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5e277fedc6c7f4e7a2e7870807107a84 -->
     </tbody>
    </tgroup>
   </table>
 </sect2>

 <sect2 id="functions-sqljson-path">
<!-- pgdoc-cn_start sig_en=eb69ecbdd700adcb339550617f41eda3 sig_cn_org=None source=14.1 
  <title>The SQL/JSON Path Language</title>
________________________________________________________-->
  <title>SQL/JSON 路径语言</title>
<!-- pgdoc-cn_end sig_en=eb69ecbdd700adcb339550617f41eda3 -->

<!-- pgdoc-cn_start sig_en=4c33f07e9e2831d7b8af681888f867b7 sig_cn_org=None source=14.1 
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON path language</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON 路径语言</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4c33f07e9e2831d7b8af681888f867b7 -->

<!-- pgdoc-cn_start sig_en=bbfa9fab3ccef157283e7752842d15fb sig_cn_org=None source=14.1 
  <para>
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
  </para>
________________________________________________________-->
  <para>
   SQL/JSON路径表达式指定了要从JSON数据中检索的项目，类似于SQL访问XML时使用的XPath表达式。
   在<productname>PostgreSQL</productname>中，路径表达式作为<type>jsonpath</type>数据类型实现，可以使用<xref linkend="datatype-jsonpath"/>中描述的任何元素。
  </para>
<!-- pgdoc-cn_end sig_en=bbfa9fab3ccef157283e7752842d15fb -->

<!-- pgdoc-cn_start sig_en=ec7f47033024d7c5eb5e2b4cb9f470b2 sig_cn_org=None source=14.1 
  <para>
   JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
  </para>
________________________________________________________-->
  <para>
   JSON查询函数和操作符将提供的路径表达式传递给<firstterm>path engine</firstterm>进行评估。
   如果表达式与被查询的JSON数据匹配，则返回相应的JSON项或项集。
   路径表达式是用SQL/JSON路径语言编写的，也可以包括算术表达式和函数。
  </para>
<!-- pgdoc-cn_end sig_en=ec7f47033024d7c5eb5e2b4cb9f470b2 -->

<!-- pgdoc-cn_start sig_en=d56cf87233b917ed5a2186a5ace960f1 sig_cn_org=None source=14.1 
  <para>
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
  </para>
________________________________________________________-->
  <para>
   路径表达式由<type>jsonpath</type>数据类型允许的元素序列组成。路径表达式通常从左向右求值，但你可以使用圆括号来更改操作的顺序。
   如果计算成功，将生成一系列JSON项，并将计算结果返回到JSON查询函数，该函数将完成指定的计算。
  </para>
<!-- pgdoc-cn_end sig_en=d56cf87233b917ed5a2186a5ace960f1 -->

<!-- pgdoc-cn_start sig_en=50eceff879428a9d76da1e19e6f87d84 sig_cn_org=None source=14.1 
  <para>
   To refer to the JSON value being queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> variable
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each operator that follows deals with the
   result of the previous evaluation step.
  </para>
________________________________________________________-->
  <para>
   要引用正在查询的JSON值(<firstterm>context item</firstterm>项)，在路径表达式中使用<literal>$</literal>变量。
   它后面可以跟着一个或多个<link linkend="type-jsonpath-accessors">accessor operators</link>，这些操作符在JSON结构中逐级向下检索上下文项的子项。
   后面的每个操作符处理前一个求值步骤的结果。
  </para>
<!-- pgdoc-cn_end sig_en=50eceff879428a9d76da1e19e6f87d84 -->

<!-- pgdoc-cn_start sig_en=13ecaf3fd7d61152d2ff1c418b84690b sig_cn_org=None source=14.1 
  <para>
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>
________________________________________________________-->
  <para>
   例如，假设你有一些你想要解析的来自GPS跟踪器的JSON数据，例如:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=13ecaf3fd7d61152d2ff1c418b84690b -->

<!-- pgdoc-cn_start sig_en=462134be9e79256f44215d7d8788611b sig_cn_org=None source=14.1 
  <para>
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator to descend through surrounding JSON objects:
<programlisting>
$.track.segments
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为了检索可用的轨迹段，你需要使用<literal>.<replaceable>key</replaceable></literal>访问操作符来向下浏览周边的JSON对象:
<programlisting>
$.track.segments
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=462134be9e79256f44215d7d8788611b -->

<!-- pgdoc-cn_start sig_en=9ee4aa408d6089e9d33d6dd01456e769 sig_cn_org=None source=14.1 
  <para>
   To retrieve the contents of an array, you typically use the
   <literal>[*]</literal> operator. For example,
   the following path will return the location coordinates for all
   the available track segments:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要检索数组的内容，通常使用<literal>[*]</literal>操作符。例如，下面的路径将返回所有可用轨道段的位置坐标:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=9ee4aa408d6089e9d33d6dd01456e769 -->

<!-- pgdoc-cn_start sig_en=14c73b2c953135469c523cbde8d68bf8 sig_cn_org=None source=14.1 
  <para>
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Recall that JSON array indexes are 0-relative:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要只返回第一个段的坐标，可以在<literal>[]</literal>访问操作符中指定相应的下标。重新调用相对于0的JSON数组索引:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=14c73b2c953135469c523cbde8d68bf8 -->

<!-- pgdoc-cn_start sig_en=f1d216fc0b8b9c4ad16302d0711b90b7 sig_cn_org=None source=14.1 
  <para>
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
<programlisting>
$.track.segments.size()
</programlisting>
   More examples of using <type>jsonpath</type> operators
   and methods within path expressions appear below in
   <xref linkend="functions-sqljson-path-operators"/>.
  </para>
________________________________________________________-->
  <para>
   每个路径求值步骤的结果可以由<xref linkend="functions-sqljson-path-operators"/>中列出的一个或多个<type>jsonpath</type>操作符和方法来处理。
   每个方法名之前必须有一个点。例如，你可以得到一个数组的大小:
<programlisting>
$.track.segments.size()
</programlisting>
   在路径表达式中使用<type>jsonpath</type>操作符和方法的更多示例见下面<xref linkend="functions-sqljson-path-operators"/>。
  </para>
<!-- pgdoc-cn_end sig_en=f1d216fc0b8b9c4ad16302d0711b90b7 -->

<!-- pgdoc-cn_start sig_en=1a83ba1b4db56082f2b7fc466485470f sig_cn_org=None source=14.1 
  <para>
   When defining a path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similarly to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在定义路径时，还可以使用一个或多个与SQL中的<literal>WHERE</literal>子句类似的<firstterm>filter expressions</firstterm>。
   过滤器表达式以问号开头，并在圆括号中提供条件:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1a83ba1b4db56082f2b7fc466485470f -->

<!-- pgdoc-cn_start sig_en=6855348acafbc5844a4b4c2576117081 sig_cn_org=None source=14.1 
  <para>
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned <literal>true</literal>.
  </para>
________________________________________________________-->
  <para>
   过滤表达式必须在它们应该应用的路径求值步骤之后写入。该步骤的结果将被筛选，以只包括满足所提供条件的那些项。
   SQL/JSON定义了三值逻辑，因此条件可以是 <literal>true</literal>, <literal>false</literal>,或 <literal>unknown</literal>。
   <literal>unknown</literal>值发挥与SQL <literal>NULL</literal>相同的角色，可以使用<literal>is unknown</literal>谓词进行测试。
   进一步的路径求值步骤只使用筛选器表达式返回<literal>true</literal>的那些项。
  </para>
<!-- pgdoc-cn_end sig_en=6855348acafbc5844a4b4c2576117081 -->

<!-- pgdoc-cn_start sig_en=d52059d09c765922435f62fd7ea33684 sig_cn_org=None source=14.1 
  <para>
   The functions and operators that can be used in filter expressions are
   listed in <xref linkend="functions-sqljson-filter-ex-table"/>.  Within a
   filter expression, the <literal>@</literal> variable denotes the value
   being filtered (i.e., one result of the preceding path step).  You can
   write accessor operators after <literal>@</literal> to retrieve component
   items.
  </para>
________________________________________________________-->
  <para>
   可以在过滤表达式中使用的函数和操作符罗列在<xref linkend="functions-sqljson-filter-ex-table"/>中。
   在一个过滤表达式中，<literal>@</literal>变量表示被过滤的值(也就是说，前面路径步骤的一个结果)。你可以在 <literal>@</literal>后面写访问操作符来检索组件项。
  </para>
<!-- pgdoc-cn_end sig_en=d52059d09c765922435f62fd7ea33684 -->

<!-- pgdoc-cn_start sig_en=29c154a5d0537cc080969c2638fa4108 sig_cn_org=None source=14.1 
  <para>
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   例如，假设你想要检索所有高于130的心率值。你可以使用下面的表达式来实现这一点:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=29c154a5d0537cc080969c2638fa4108 -->

<!-- pgdoc-cn_start sig_en=53f7eab966e4e1d1e96641bf111ac230 sig_cn_org=None source=14.1 
  <para>
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before returning the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为了获得具有这些值的片段的开始时间，必须在返回开始时间之前过滤掉不相关的片段，所以过滤表达式应用于上一步，条件中使用的路径不同:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=53f7eab966e4e1d1e96641bf111ac230 -->

<!-- pgdoc-cn_start sig_en=2a3d477b46b92d4969febe33a5344ab8 sig_cn_org=None source=14.1 
  <para>
   You can use several filter expressions in sequence, if required. For
   example, the following expression selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
________________________________________________________-->
  <para>
   如果需要，可以按顺序使用几个过滤器表达式。例如，下面的表达式选择所有包含有相关坐标和高心率值的位置的段的开始时间:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=2a3d477b46b92d4969febe33a5344ab8 -->

<!-- pgdoc-cn_start sig_en=aa5d92e03d641f6ecab87040d8999d5b sig_cn_org=None source=14.1 
  <para>
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   也允许在不同嵌套层级中使用过滤器表达式。下面的例子首先根据位置筛选所有的片段，然后返回这些片段的高心率值，如果适用的话:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=aa5d92e03d641f6ecab87040d8999d5b -->

<!-- pgdoc-cn_start sig_en=5252de6e7a2a0e634174ea7559688fec sig_cn_org=None source=14.1 
  <para>
   You can also nest filter expressions within each other:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
  </para>
________________________________________________________-->
  <para>
   你也可以在彼此之间嵌套过滤器表达式:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   如果包含任何具有高心率值的片段，则该表达式返回曲目的大小，否则返回空序列。
  </para>
<!-- pgdoc-cn_end sig_en=5252de6e7a2a0e634174ea7559688fec -->

<!-- pgdoc-cn_start sig_en=e1889c8ff06afcefc0e1905fe3b10427 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname>'s implementation of the SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的SQL/JSON路径语言的实现与SQL/JSON标准有以下偏差:
  </para>
<!-- pgdoc-cn_end sig_en=e1889c8ff06afcefc0e1905fe3b10427 -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=64aa4620bed4b1acf66207d2caf0a496 sig_cn_org=None source=14.1 
    <para>
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
________________________________________________________-->
    <para>
     路径表达式可以是布尔谓词，尽管SQL/JSON标准只允许在过滤器中使用谓词。
     这是实现<literal>@@</literal>操作符所必需的。例如，下面的<type>jsonpath</type>表达式在<productname>PostgreSQL</productname>中是有效的:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=64aa4620bed4b1acf66207d2caf0a496 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=d80b37178264ff69b6d9608a549c0439 sig_cn_org=None source=14.1 
    <para>
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
    </para>
________________________________________________________-->
    <para>
     在解释<literal>like_regex</literal>过滤器中使用的正则表达式模式方面有一些小的差异，如<xref linkend="jsonpath-regular-expressions"/>中所述。
    </para>
<!-- pgdoc-cn_end sig_en=d80b37178264ff69b6d9608a549c0439 -->
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
<!-- pgdoc-cn_start sig_en=b1231e36571a2031bf4f65626eb2ae11 sig_cn_org=None source=14.1 
   <title>Strict and Lax Modes</title>
________________________________________________________-->
   <title>严格的(Strict) 和 不严格的(Lax) 模式</title>
<!-- pgdoc-cn_end sig_en=b1231e36571a2031bf4f65626eb2ae11 -->
<!-- pgdoc-cn_start sig_en=e6ae18da52bf782a81b71bcd79d3f8df sig_cn_org=None source=14.1 
    <para>
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
    </para>
________________________________________________________-->
    <para>
     当查询JSON数据时，路径表达式可能与实际的JSON数据结构不匹配。
     试图访问不存在的对象成员或数组元素会导致结构错误。SQL/JSON路径表达式有两种处理结构错误的模式:
    </para>
<!-- pgdoc-cn_end sig_en=e6ae18da52bf782a81b71bcd79d3f8df -->

   <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=473c3cbae0329971ed7272cadacb9d39 sig_cn_org=None source=14.1 
     <para>
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
     </para>
________________________________________________________-->
     <para>
      不严格的(lax)(默认)&mdash;路径引擎隐式地将查询的数据适配到指定的路径。任何剩余的结构错误都将被抑制并转换为空SQL/JSON序列。
     </para>
<!-- pgdoc-cn_end sig_en=473c3cbae0329971ed7272cadacb9d39 -->
    </listitem>
    <listitem>
<!-- pgdoc-cn_start sig_en=6f44df31876ed2761ba07518ac76a494 sig_cn_org=None source=14.1 
     <para>
      strict &mdash; if a structural error occurs, an error is raised.
     </para>
________________________________________________________-->
     <para>
      严格的(strict) &mdash;如果发生了结构错误，则会引发错误。
     </para>
<!-- pgdoc-cn_end sig_en=6f44df31876ed2761ba07518ac76a494 -->
    </listitem>
   </itemizedlist>

<!-- pgdoc-cn_start sig_en=617d827bd5c0872c5e516de73c6ce99c sig_cn_org=None source=14.1 
   <para>
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
    <itemizedlist>
     <listitem>
      <para>
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
      </para>
     </listitem>
     <listitem>
      <para>
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    如果JSON数据不符合期望的模式，不严格的(lax)模式有助于匹配JSON文档结构和路径表达式。
    如果操作不匹配特定操作的要求，可以自动将其包装为SQL/JSON数组，也可以在执行该操作之前将其元素转换为SQL/JSON序列来解包装。
    此外，比较操作符会自动以lax模式打开它们的操作数，因此你可以开包即用的就能比较SQL/JSON数组。
    大小为1的数组被认为等于它的唯一元素。只有在以下情况下才不会自动展开:
    <itemizedlist>
     <listitem>
      <para>
       路径表达式包含<literal>type()</literal>或<literal>size()</literal>方法，它们分别返回数组中的元素类型和数量。
      </para>
     </listitem>
     <listitem>
      <para>
       查询的JSON数据包含嵌套的数组。在本例中，只有最外层的数组被打开，而所有内部数组保持不变。
       因此，隐式展开在每个路径求值步骤中只能向下进行一级。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=617d827bd5c0872c5e516de73c6ce99c -->

<!-- pgdoc-cn_start sig_en=9790a5088254d1cc23614030be2d3e5d sig_cn_org=None source=14.1 
   <para>
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，当查询上面列出的GPS数据时，当使用不严格的(lax)模式时，你可以从它存储了一组片段的事实中抽象出来:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=9790a5088254d1cc23614030be2d3e5d -->

<!-- pgdoc-cn_start sig_en=449282597f575b96250539c3516d547e sig_cn_org=None source=14.1 
   <para>
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在严格的(strict)模式中，指定的路径必须与查询的JSON文档的结构完全匹配才能返回SQL/JSON项，因此使用该路径表达式会导致错误。
	要得到与不严格的(lax)模式相同的结果，你必须显式地打开<literal>segments</literal>数组:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=449282597f575b96250539c3516d547e -->

<!-- pgdoc-cn_start sig_en=e773d2ce07a34002b93ffdcd6882c1ad sig_cn_org=None source=14.1 
   <para>
    The <literal>.**</literal> accessor can lead to surprising results
    when using the lax mode. For instance, the following query selects every
    <literal>HR</literal> value twice:
<programlisting>
lax $.**.HR
</programlisting>
    This happens because the <literal>.**</literal> accessor selects both
    the <literal>segments</literal> array and each of its elements, while
    the <literal>.HR</literal> accessor automatically unwraps arrays when
    using the lax mode. To avoid surprising results, we recommend using
    the <literal>.**</literal> accessor only in the strict mode. The
    following query selects each <literal>HR</literal> value just once:
<programlisting>
strict $.**.HR
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <literal>.**</literal>访问器在使用lax模式时可能导致令人惊讶的结果。
    例如，下面的查询选择每个<literal>HR</literal>值两次:
<programlisting>
lax $.**.HR
</programlisting>
    发生这个，是因为<literal>.**</literal>访问器会全部选择<literal>segments</literal>数组和它的每个元素。
    而当使用lax模式时，<literal>.HR</literal>访问器会自动打开数组。
    为了避免意外的结果，我们建议仅在严格模式下使用<literal>.**</literal>访问器。
    下面的查询选择每个<literal>HR</literal>值仅一次:
<programlisting>
strict $.**.HR
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e773d2ce07a34002b93ffdcd6882c1ad -->

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
<!-- pgdoc-cn_start sig_en=b5f6f5a6ee05835673c18b5f4f343d3f sig_cn_org=None source=14.1 
   <title>SQL/JSON Path Operators and Methods</title>
________________________________________________________-->
   <title>SQL/JSON 路径操作符和方法</title>
<!-- pgdoc-cn_end sig_en=b5f6f5a6ee05835673c18b5f4f343d3f -->

<!-- pgdoc-cn_start sig_en=f00ac74a9b75dd0a0ceefdd4dbdccaab sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-op-table"/>显示了jsonpath中可用的操作符和方法。
	请注意，虽然一元操作符和方法可以应用于由前一个路径步骤产生的多个值，二元操作符(加法等)只能应用于单个值。
   </para>
<!-- pgdoc-cn_end sig_en=f00ac74a9b75dd0a0ceefdd4dbdccaab -->

   <table id="functions-sqljson-op-table">
<!-- pgdoc-cn_start sig_en=273053aa1b02110267244532e9418e86 sig_cn_org=None source=14.1 
    <title><type>jsonpath</type> Operators and Methods</title>
________________________________________________________-->
    <title><type>jsonpath</type> 操作符和方法</title>
<!-- pgdoc-cn_end sig_en=273053aa1b02110267244532e9418e86 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=8f18909aaf9777f0894c53a749107980 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator/Method
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符/方法
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8f18909aaf9777f0894c53a749107980 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=ac707cdbf4a77b3e3906d30c2fc10750 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        加法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ac707cdbf4a77b3e3906d30c2fc10750 -->

<!-- pgdoc-cn_start sig_en=50e548cc229c3a4993af60a0b37180f2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        一元加号(无操作);与加法不同，这个可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=50e548cc229c3a4993af60a0b37180f2 -->

<!-- pgdoc-cn_start sig_en=27dfaa301cbed282ecd780322e2fc38f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        减法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=27dfaa301cbed282ecd780322e2fc38f -->

<!-- pgdoc-cn_start sig_en=6a70698d9a88c46121e2e26e57c02e30 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Negation; unlike subtraction, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        否定;与减法不同，它可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6a70698d9a88c46121e2e26e57c02e30 -->

<!-- pgdoc-cn_start sig_en=ac67d1c6e8adaadad2f49f3e520d0c48 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        乘法
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ac67d1c6e8adaadad2f49f3e520d0c48 -->

<!-- pgdoc-cn_start sig_en=7db400d5ce4f872ff0fd08b675da1b30 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Division
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        除法
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7db400d5ce4f872ff0fd08b675da1b30 -->

<!-- pgdoc-cn_start sig_en=e549bdb7517e87502601979248574966 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        模数 (余数)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e549bdb7517e87502601979248574966 -->

<!-- pgdoc-cn_start sig_en=59b79e8b844127462dd744fe3aaed949 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        Type of the JSON item (see <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        JSON项的类型 (参见 <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=59b79e8b844127462dd744fe3aaed949 -->

<!-- pgdoc-cn_start sig_en=2ca4f213aa518b14201e70efb9d815c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Size of the JSON item (number of array elements, or 1 if not an
        array)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        JSON项的大小(数组元素的数量，如果不是数组则为1)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ca4f213aa518b14201e70efb9d815c1 -->

<!-- pgdoc-cn_start sig_en=964b6af4485064e16414a3da10b7a308 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Approximate floating-point number converted from a JSON number or
        string
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        从JSON数字或字符串转换过来的近似浮点数
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=964b6af4485064e16414a3da10b7a308 -->

<!-- pgdoc-cn_start sig_en=91a57b879f2d3928c1f1f8dd5789436e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        大于或等于给定数字的最接近的整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=91a57b879f2d3928c1f1f8dd5789436e -->

<!-- pgdoc-cn_start sig_en=894376a3946a2edd5c7f77320c851809 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        小于或等于给定数字的最近整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=894376a3946a2edd5c7f77320c851809 -->

<!-- pgdoc-cn_start sig_en=dfb7fb4a106e03d38cfa812e92b89869 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Absolute value of the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        给定数字的绝对值
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dfb7fb4a106e03d38cfa812e92b89869 -->

<!-- pgdoc-cn_start sig_en=91efb86da8596b7d17582c8660eb1bb1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=91efb86da8596b7d17582c8660eb1bb1 -->

<!-- pgdoc-cn_start sig_en=22dee06d16e591b167222f31dcaf140a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string using the
        specified <function>to_timestamp</function> template
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        使用指定的<function>to_timestamp</function>模板从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22dee06d16e591b167222f31dcaf140a -->

<!-- pgdoc-cn_start sig_en=34eee59ff872a271100e82989d0505d8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        The object's key-value pairs, represented as an array of objects
        containing three fields: <literal>"key"</literal>,
        <literal>"value"</literal>, and <literal>"id"</literal>;
        <literal>"id"</literal> is a unique identifier of the object the
        key-value pair belongs to
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        对象的键值对，表示为包含三个字段的对象数组:<literal>"key"</literal>， <literal>"value"</literal>，和<literal>"id"</literal>;<literal>"id"</literal>是键值对所归属对象的唯一标识符
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=34eee59ff872a271100e82989d0505d8 -->
     </tbody>
    </tgroup>
   </table>

    <note>
<!-- pgdoc-cn_start sig_en=7846cb4d14cb9388d083761bf2568e98 sig_cn_org=None source=14.1 
     <para>
      The result type of the <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal>
      methods can be <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, or <type>timestamp</type>.
      Both methods determine their result type dynamically.
     </para>
________________________________________________________-->
     <para>
      <literal>datetime()</literal> 和<literal>datetime(<replaceable>template</replaceable>)</literal>方法的结果类型可以是<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 或 <type>timestamp</type>。
      这两个方法都动态地确定它们的结果类型。
     </para>
<!-- pgdoc-cn_end sig_en=7846cb4d14cb9388d083761bf2568e98 -->
<!-- pgdoc-cn_start sig_en=d29e6add11ff1da8d739ab9ab030fbec sig_cn_org=None source=14.1 
     <para>
      The <literal>datetime()</literal> method sequentially tries to
      match its input string to the ISO formats
      for <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, and <type>timestamp</type>. It stops on
      the first matching format and emits the corresponding data type.
     </para>
________________________________________________________-->
     <para>
      <literal>datetime()</literal>方法依次尝试将其输入字符串与<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 和 <type>timestamp</type>的ISO格式进行匹配。
      它在第一个匹配格式时停止，并发出相应的数据类型。
     </para>
<!-- pgdoc-cn_end sig_en=d29e6add11ff1da8d739ab9ab030fbec -->
<!-- pgdoc-cn_start sig_en=241a4858d719c71e75c5f35ce3f2be72 sig_cn_org=None source=14.1 
     <para>
      The <literal>datetime(<replaceable>template</replaceable>)</literal>
      method determines the result type according to the fields used in the
      provided template string.
     </para>
________________________________________________________-->
     <para>
      <literal>datetime(<replaceable>template</replaceable>)</literal>方法根据所提供的模板字符串中使用的字段确定结果类型。
     </para>
<!-- pgdoc-cn_end sig_en=241a4858d719c71e75c5f35ce3f2be72 -->
<!-- pgdoc-cn_start sig_en=b0fddb3379c11f346687394f380392da sig_cn_org=None source=14.1 
     <para>
      The <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal> methods
      use the same parsing rules as the <literal>to_timestamp</literal> SQL
      function does (see <xref linkend="functions-formatting"/>), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
     </para>
________________________________________________________-->
     <para>
      <literal>datetime()</literal>和<literal>datetime(<replaceable>template</replaceable>)</literal>方法使用与<literal>to_timestamp</literal> SQL函数相同的解析规则(see <xref linkend="functions-formatting"/>)，但有三个例外。
      首先，这些方法不允许不匹配的模板模式。
      其次，模板字符串中只允许以下分隔符:减号、句点、solidus(斜杠)、逗号、撇号、分号、冒号和空格。
      第三，模板字符串中的分隔符必须与输入字符串完全匹配。
     </para>
<!-- pgdoc-cn_end sig_en=b0fddb3379c11f346687394f380392da -->
<!-- pgdoc-cn_start sig_en=91132b85c7ff232578752d1760b32a08 sig_cn_org=None source=14.1 
     <para>
      If different date/time types need to be compared, an implicit cast is
      applied. A <type>date</type> value can be cast to <type>timestamp</type>
      or <type>timestamptz</type>, <type>timestamp</type> can be cast to
      <type>timestamptz</type>, and <type>time</type> to <type>timetz</type>.
      However, all but the first of these conversions depend on the current
      <xref linkend="guc-timezone"/> setting, and thus can only be performed
      within timezone-aware <type>jsonpath</type> functions.
     </para>
________________________________________________________-->
     <para>
      如果需要比较不同的日期/时间类型，则应用隐式转换。
      <type>date</type>值可以转换为<type>timestamp</type>或 <type>timestamptz</type>, <type>timestamp</type>可以转换为<type>timestamptz</type>, <type>time</type>可以转换为<type>timetz</type>。
      但是，除了第一个转换外，其他所有转换都依赖于当前<xref linkend="guc-timezone"/>设置，因此只能在时区感知的<type>jsonpath</type>函数中执行。
     </para>
<!-- pgdoc-cn_end sig_en=91132b85c7ff232578752d1760b32a08 -->
    </note>

<!-- pgdoc-cn_start sig_en=a5831db9e5137d0fb371ed029e8b5285 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/> shows the available
    filter expression elements.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/>显示了适用的过滤器表达式元素。
   </para>
<!-- pgdoc-cn_end sig_en=a5831db9e5137d0fb371ed029e8b5285 -->

   <table id="functions-sqljson-filter-ex-table">
<!-- pgdoc-cn_start sig_en=964084c1d39168cf80ff4227c8a47b17 sig_cn_org=None source=14.1 
    <title><type>jsonpath</type> Filter Expression Elements</title>
________________________________________________________-->
    <title><type>jsonpath</type> 过滤器表达式元素</title>
<!-- pgdoc-cn_end sig_en=964084c1d39168cf80ff4227c8a47b17 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=742922b45e3262a4d52a3244810ea1f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate/Value
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词/值
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=742922b45e3262a4d52a3244810ea1f0 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=88f27259595c4daf87987514994f5176 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等比较(这个，和其他比较操作符，适用于所有JSON标量值)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=88f27259595c4daf87987514994f5176 -->

<!-- pgdoc-cn_start sig_en=9bff8f671e4ec6f96050b5761e695722 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Non-equality comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9bff8f671e4ec6f96050b5761e695722 -->

<!-- pgdoc-cn_start sig_en=2d2d987ea468657deaeab47e1bf427fa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2d2d987ea468657deaeab47e1bf427fa -->

<!-- pgdoc-cn_start sig_en=96a4b89b5d9bf8b82d672ab97d719ec4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=96a4b89b5d9bf8b82d672ab97d719ec4 -->

<!-- pgdoc-cn_start sig_en=05a7add993e05a7b283a6974ac0ee395 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=05a7add993e05a7b283a6974ac0ee395 -->

<!-- pgdoc-cn_start sig_en=d5fe5bd5a55ce44800f02d3351c6c0dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5fe5bd5a55ce44800f02d3351c6c0dc -->

<!-- pgdoc-cn_start sig_en=ab9a2cd0edd9b0ad72aba8d745a40cbb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>true</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>真</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ab9a2cd0edd9b0ad72aba8d745a40cbb -->

<!-- pgdoc-cn_start sig_en=099c090d47042abb0c8fbe811a9b0d29 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>false</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>假</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=099c090d47042abb0c8fbe811a9b0d29 -->

<!-- pgdoc-cn_start sig_en=01ecfdaca777fa1ecce38513b3655d44 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON constant <literal>null</literal> (note that, unlike in SQL,
        comparison to <literal>null</literal> works normally)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON常数<literal>null</literal>(注意，与SQL不同，与<literal>null</literal>比较可以正常工作)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=01ecfdaca777fa1ecce38513b3655d44 -->

<!-- pgdoc-cn_start sig_en=28e0acc9b8c74a55f27f09320755434a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28e0acc9b8c74a55f27f09320755434a -->

<!-- pgdoc-cn_start sig_en=60c06437da602ff9531129e159e4d760 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=60c06437da602ff9531129e159e4d760 -->

<!-- pgdoc-cn_start sig_en=f31a85ac6fbb6122356b7309a06b966c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f31a85ac6fbb6122356b7309a06b966c -->

<!-- pgdoc-cn_start sig_en=676ea2a922bf24561db3801d201eef46 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a Boolean condition is <literal>unknown</literal>.
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔条件是否为 <literal>unknown</literal>。
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=676ea2a922bf24561db3801d201eef46 -->

<!-- pgdoc-cn_start sig_en=2e445943e1e1a04a4fe50544979d1656 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of <literal>flag</literal> characters (see
        <xref linkend="jsonpath-regular-expressions"/>).
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第一个操作数是否与第二个操作数给出的正则表达式匹配，可选使用由一串<literal>flag</literal>字符描述的修改(参见<xref linkend="jsonpath-regular-expressions"/>)。
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2e445943e1e1a04a4fe50544979d1656 -->

<!-- pgdoc-cn_start sig_en=a2d0da5f46ac96da49f2cfe8ecb75b37 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the second operand is an initial substring of the first
        operand.
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第二个操作数是否为第一个操作数的初始子串。
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2d0da5f46ac96da49f2cfe8ecb75b37 -->

<!-- pgdoc-cn_start sig_en=e992ffa798e54f1f03b943f574bf7119 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns <literal>unknown</literal> if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试路径表达式是否至少匹配一个SQL/JSON项。
        如果路径表达式会导致错误，则返回<literal>unknown</literal>;第二个例子使用这个方法来避免在严格模式下出现无此键(no-such-key)错误。
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e992ffa798e54f1f03b943f574bf7119 -->
     </tbody>
    </tgroup>
   </table>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
<!-- pgdoc-cn_start sig_en=ff6cbf9e0c8b3d74fd305eb11be1fd2a sig_cn_org=None source=14.1 
    <title>SQL/JSON Regular Expressions</title>
________________________________________________________-->
    <title>SQL/JSON 正则表达式</title>
<!-- pgdoc-cn_end sig_en=ff6cbf9e0c8b3d74fd305eb11be1fd2a -->

<!-- pgdoc-cn_start sig_en=4a0f1ffcb7cd4630c6b397dca0259095 sig_cn_org=None source=14.1 
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4a0f1ffcb7cd4630c6b397dca0259095 -->

<!-- pgdoc-cn_start sig_en=50b9a4847ed6aa2cba317e606b297180 sig_cn_org=None source=14.1 
    <para>
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>
________________________________________________________-->
    <para>
     SQL/JSON路径表达式允许通过<literal>like_regex</literal>过滤器将文本匹配为正则表达式。
     例如，下面的SQL/JSON路径查询将不区分大小写地匹配以英语元音开头的数组中的所有字符串:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=50b9a4847ed6aa2cba317e606b297180 -->

<!-- pgdoc-cn_start sig_en=ea02d6515326b0297d4c90e47fb78971 sig_cn_org=None source=14.1 
    <para>
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
    </para>
________________________________________________________-->
    <para>
     可选的<literal>flag</literal>字符串可以包括一个或多个字符<literal>i</literal>用于不区分大小写的匹配，<literal>m</literal>允许<literal>^</literal>和<literal>$</literal>在换行时匹配，<literal>s</literal>允许<literal>.</literal>匹配换行符，<literal>q</literal>引用整个模式(将行为简化为一个简单的子字符串匹配)。
    </para>
<!-- pgdoc-cn_end sig_en=ea02d6515326b0297d4c90e47fb78971 -->

<!-- pgdoc-cn_start sig_en=740327ca163352f9446607c66c6e56f9 sig_cn_org=None source=14.1 
    <para>
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
    </para>
________________________________________________________-->
    <para>
     SQL/JSON标准借用了来自<literal>LIKE_REGEX</literal>操作符的正则表达式定义，其使用了XQuery标准。
     PostgreSQL目前不支持<literal>LIKE_REGEX</literal>操作符。因此，<literal>like_regex</literal>过滤器是使用<xref linkend="functions-posix-regexp"/>中描述的POSIX正则表达式引擎来实现的。
     这导致了与标准SQL/JSON行为的各种细微差异，这在<xref linkend="posix-vs-xquery"/>中进行了分类。
     但是请注意，这里描述的标志字母不兼容并不适用于SQL/JSON，因为它将XQuery标志字母翻译为符合POSIX引擎的预期。
    </para>
<!-- pgdoc-cn_end sig_en=740327ca163352f9446607c66c6e56f9 -->

<!-- pgdoc-cn_start sig_en=6e5297021f7ea14d96ca474f4d5e4364 sig_cn_org=None source=14.1 
    <para>
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match string values of the root document that contain
     only digits:
<programlisting>
$.* ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
________________________________________________________-->
    <para>
     请记住，<literal>like_regex</literal>的模式参数是一个JSON路径字符串文字，根据<xref linkend="datatype-jsonpath"/>给出的规则编写。
     这特别意味着在正则表达式中要使用的任何反斜杠都必须加倍。例如，匹配只包含数字的根文档的字符串值:
<programlisting>
$.* ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=6e5297021f7ea14d96ca474f4d5e4364 -->
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
<!-- pgdoc-cn_start sig_en=07bda52c81257191e266f3c87bc1f144 sig_cn_org=None source=14.1 
  <title>Sequence Manipulation Functions</title>
________________________________________________________-->
  <title>序列操作函数</title>
<!-- pgdoc-cn_end sig_en=07bda52c81257191e266f3c87bc1f144 -->

<!-- pgdoc-cn_start sig_en=812589096260862416e87a989b05fc51 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>sequence</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>sequence</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=812589096260862416e87a989b05fc51 -->

<!-- pgdoc-cn_start sig_en=b87896672b2269725bc0d9af3be30722 sig_cn_org=None source=14.1 
  <para>
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
  </para>
________________________________________________________-->
  <para>
   本节描述对<firstterm>sequence objects</firstterm>进行操作的函数，也称为序列生成器或序列。
   序列对象是使用<xref linkend="sql-createsequence"/>创建的特殊单行表。
   序列对象通常用于为表中的行生成惟一标识符。在<xref linkend="functions-sequence-table"/>中列出的序列函数，提供了简单的、多用户安全方法，用于从序列对象中获取连续的序列值。
  </para>
<!-- pgdoc-cn_end sig_en=b87896672b2269725bc0d9af3be30722 -->

   <table id="functions-sequence-table">
<!-- pgdoc-cn_start sig_en=a901e213e71cac7db5055d5f060de5e6 sig_cn_org=None source=14.1 
    <title>Sequence Functions</title>
________________________________________________________-->
    <title>序列函数</title>
<!-- pgdoc-cn_end sig_en=a901e213e71cac7db5055d5f060de5e6 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=f5cfc9fc2e2740c8b167318727c003b1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Advances the sequence object to its next value and returns that value.
        This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely
        receive a distinct sequence value.
        If the sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        appropriate parameters in the <xref linkend="sql-createsequence"/>
        command.
      </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        将序列对象推进到下一个值并返回该值。这是自动完成的:即使多个会话并发地执行<function>nextval</function>，每个会话也会安全地接收到不同的序列值。
        如果序列对象是用默认形参创建的，则连续的<function>nextval</function>调用将返回以1开始的连续值。
        其他行为可以通过在<xref linkend="sql-createsequence"/>命令中使用适当的参数获得。
      </para>
       <para>
        这个函数需要<literal>USAGE</literal>或<literal>UPDATE</literal>特权在序列上。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f5cfc9fc2e2740c8b167318727c003b1 -->

<!-- pgdoc-cn_start sig_en=5c7145a376b7ad39af4abf3135970955 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Sets the sequence object's current value, and optionally
        its <literal>is_called</literal> flag.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value that will be reported
        by <function>currval</function> is also set to the specified value.
        In the three-parameter form, <literal>is_called</literal> can be set
        to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same
        effect as the two-parameter form. If it is set
        to <literal>false</literal>, the next <function>nextval</function>
        will return exactly the specified value, and sequence advancement
        commences with the following <function>nextval</function>.
        Furthermore, the value reported by <function>currval</function> is not
        changed in this case.  For example,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        The result returned by <function>setval</function> is just the value of its
        second argument.
       </para>
       <para>
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        设置序列对象的当前值，以及可选的它的<literal>is_called</literal>标志。
        双参数形式将序列的<literal>last_value</literal>字段设置为指定的值，并将其<literal>is_called</literal>字段设置为<literal>true</literal>，意味着下一个<function>nextval</function>将在返回值之前推进序列。
        <function>currval</function>将报告的值也设置为指定的值。在三参数形式中，<literal>is_called</literal>可以设置为<literal>true</literal> 或 <literal>false</literal>。
        <literal>true</literal>与双参数形式具有相同的效果。
        如果设置为<literal>false</literal>，下一个<function>nextval</function>将返回指定的值，序列推进从下面的<function>nextval</function>开始。
        而且，<function>currval</function>报告的值在这种情况下不会改变。例如,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        <function>setval</function>返回的结果就是它的第二个参数的值。
       </para>
       <para>
        这个函数在序列上需要<literal>UPDATE</literal>特权。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c7145a376b7ad39af4abf3135970955 -->

<!-- pgdoc-cn_start sig_en=5126763decef4087d2409d41ad645f57 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently obtained
        by <function>nextval</function> for this sequence in the current
        session.  (An error is reported if <function>nextval</function> has
        never been called for this sequence in this session.)  Because this is
        returning a session-local value, it gives a predictable answer whether
        or not other sessions have executed <function>nextval</function> since
        the current session did.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中为该序列最近获取的值。(如果在这个会话中没有为这个序列调用<function>nextval</function>会报告错误。)
        因为它返回的是一个会话本地值，所以它给出了一个可预测的答案，即自当前会话以来，其他会话是否执行了<function>nextval</function>。
       </para>
       <para>
        这个函数需要序列上的<literal>USAGE</literal> 或 <literal>SELECT</literal>特权。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5126763decef4087d2409d41ad645f57 -->

<!-- pgdoc-cn_start sig_en=618844abfc470cb013425abe6fa7515a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中最近返回的值。这个函数与<function>currval</function>相同，不同之处在于它没有使用序列名作为参数，而是引用当前会话中<function>nextval</function>最近应用到的序列。
        如果在当前会话中还没有调用<function>nextval</function>，那么调用<function>lastval</function>是一个错误。
       </para>
       <para>
        该函数在最后使用的序列上需要<literal>USAGE</literal>或<literal>SELECT</literal>特权。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=618844abfc470cb013425abe6fa7515a -->
     </tbody>
    </tgroup>
   </table>

  <caution>
<!-- pgdoc-cn_start sig_en=246956b15302a8801661d6635d512900 sig_cn_org=0f1ccbdb1b92af1418de627e65371783 source=15.7 
   <para>
    To avoid blocking concurrent transactions that obtain numbers from
    the same sequence, the value obtained by <function>nextval</function>
    is not reclaimed for re-use if the calling transaction later aborts.
    This means that transaction aborts or database crashes can result in
    gaps in the sequence of assigned values.  That can happen without a
    transaction abort, too.  For example an <command>INSERT</command> with
    an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
    tuple, including doing any required <function>nextval</function>
    calls, before detecting any conflict that would cause it to follow
    the <literal>ON CONFLICT</literal> rule instead.
    Thus, <productname>PostgreSQL</productname> sequence
    objects <emphasis>cannot be used to obtain <quote>gapless</quote>
    sequences</emphasis>.
   </para>
________________________________________________________-->
   <para>
    为了避免阻塞从相同序列获取数字的并发事务，<function>nextval</function>获得的值如果调用事务后续中止，就不会被重新使用。
    这意味着事务中止或数据库崩溃可能导致分配值序列中的间隙。这也可能发生在没有事务中止的情况下。
    例如，带有<literal>ON CONFLICT</literal>子句的<command>INSERT</command>将计算要插入的元组，包括执行任何必需的<function>nextval</function>调用，
    然后才检测到可能导致其遵循<literal>ON CONFLICT</literal>规则的任何冲突。
    因此，<productname>PostgreSQL</productname>序列对象<emphasis>不能用于获取<quote>无间隙</quote>序列</emphasis>。
</para>
<!-- pgdoc-cn_end sig_en=246956b15302a8801661d6635d512900 -->

<!-- pgdoc-cn_start sig_en=92c286379ca285b30af231fdc0c692a2 sig_cn_org=931e29fe8b499776f988cfeaab9ab542 source=15.7 
   <para>
    Likewise, sequence state changes made by <function>setval</function>
    are immediately visible to other transactions, and are not undone if
    the calling transaction rolls back.
   </para>
________________________________________________________-->
   <para>
    同样，<function>setval</function>函数所做的序列状态更改立即对其他事务可见，
    并且如果调用事务回滚，则不会被撤消。
   </para>
<!-- pgdoc-cn_end sig_en=92c286379ca285b30af231fdc0c692a2 -->

<!-- pgdoc-cn_start sig_en=c49dcea03f3b113458c69099e985c67c sig_cn_org=9c22eea993cbb7da0223edeb9e797764 source=15.7 
   <para>
    If the database cluster crashes before committing a transaction
    containing a <function>nextval</function>
    or <function>setval</function> call, the sequence state change might
    not have made its way to persistent storage, so that it is uncertain
    whether the sequence will have its original or updated state after the
    cluster restarts.  This is harmless for usage of the sequence within
    the database, since other effects of uncommitted transactions will not
    be visible either.  However, if you wish to use a sequence value for
    persistent outside-the-database purposes, make sure that the
    <function>nextval</function> call has been committed before doing so.
   </para>
________________________________________________________-->
   <para>
    如果在包含<function>nextval</function>或<function>setval</function>调用的事务提交之前，
    数据库集群崩溃，那么序列状态更改可能尚未传递到持久存储，
    因此在集群重新启动后，无法确定序列是保持其原始状态还是更新状态。
    对于数据库内部使用序列而言，这是无害的，因为未提交事务的其他影响也不会可见。
    但是，如果您希望将序列值用于持久性的数据库外部用途，请确保在这样做之前已经提交了<function>nextval</function>调用。
   </para>
<!-- pgdoc-cn_end sig_en=c49dcea03f3b113458c69099e985c67c -->
  </caution>

<!-- pgdoc-cn_start sig_en=1fe69b9268cfbb147c55ae24be1cf56c sig_cn_org=None source=14.1 
  <para>
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  See <xref linkend="datatype-oid"/>
   for details.
  </para>
________________________________________________________-->
  <para>
   序列函数所要操作的序列由<type>regclass</type>参数指定，该参数只是<structname>pg_class</structname>系统目录中序列的OID。
   你不必手工查找OID，不过，因为<type>regclass</type>数据类型的输入转换器将为您完成这项工作。
   详见<xref linkend="datatype-oid"/>
  </para>
<!-- pgdoc-cn_end sig_en=1fe69b9268cfbb147c55ae24be1cf56c -->
 </sect1>


 <sect1 id="functions-conditional">
<!-- pgdoc-cn_start sig_en=d50d3eb6256c6dab3a7a12b5f620bbff sig_cn_org=None source=14.1 
  <title>Conditional Expressions</title>
________________________________________________________-->
  <title>条件表达式</title>
<!-- pgdoc-cn_end sig_en=d50d3eb6256c6dab3a7a12b5f620bbff -->

<!-- pgdoc-cn_start sig_en=d04c864b28bb08cb67bc35357341713b sig_cn_org=None source=14.1 
  <indexterm>
   <primary>CASE</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>CASE</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d04c864b28bb08cb67bc35357341713b -->

<!-- pgdoc-cn_start sig_en=727fc1720d63673a9a7ffba78e7d6fdf sig_cn_org=None source=14.1 
  <indexterm>
   <primary>conditional expression</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>条件表达式</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=727fc1720d63673a9a7ffba78e7d6fdf -->

<!-- pgdoc-cn_start sig_en=26070d495fae41cbb88b91f899772a7d sig_cn_org=None source=14.1 
  <para>
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   本节描述在<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的条件表达式。
  </para>
<!-- pgdoc-cn_end sig_en=26070d495fae41cbb88b91f899772a7d -->

  <tip>
<!-- pgdoc-cn_start sig_en=cd9d3ba2b64f6226ee72600986eb3c2e sig_cn_org=None source=14.1 
   <para>
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
   </para>
________________________________________________________-->
   <para>
    如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个服务器端函数。
   </para>
<!-- pgdoc-cn_end sig_en=cd9d3ba2b64f6226ee72600986eb3c2e -->
  </tip>

   <note>
<!-- pgdoc-cn_start sig_en=3e58c11af0a8834302b06cb3cf55b2fa sig_cn_org=None source=14.1 
    <para>
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
    </para>
________________________________________________________-->
    <para>
     尽管<token>COALESCE</token>、<token>GREATEST</token>和<token>LEAST</token>在语法上类似于函数，但它们不是普通的函数，因此不能使用显式<token>VARIADIC</token>数组参数。
    </para>
<!-- pgdoc-cn_end sig_en=3e58c11af0a8834302b06cb3cf55b2fa -->
   </note>

  <sect2 id="functions-case">
   <title><literal>CASE</literal></title>

<!-- pgdoc-cn_start sig_en=02deac8bb5307decca79c275b92277ef sig_cn_org=None source=14.1 
  <para>
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
  </para>
________________________________________________________-->
  <para>
   <acronym>SQL</acronym> <token>CASE</token>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句：

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token>子句可以用于任何表达式可以出现的地方。每一个<replaceable>condition</replaceable>是一个返回<type>boolean</type>结果的表达式。如果结果为真，那么<token>CASE</token>表达式的结果就是符合条件的<replaceable>result</replaceable>，并且剩下的<token>CASE</token>表达式不会被处理。如果条件的结果不为真，那么以相同方式搜寻任何随后的<token>WHEN</token>子句。如果没有<token>WHEN</token> <replaceable>condition</replaceable>为真，那么<token>CASE</token>表达式的值就是在<token>ELSE</token>子句里的<replaceable>result</replaceable>。如果省略了<token>ELSE</token>子句而且没有条件为真，结果为空。
  </para>
<!-- pgdoc-cn_end sig_en=02deac8bb5307decca79c275b92277ef -->

<!-- pgdoc-cn_start sig_en=ff72dd1287efdd0005b993f4947b4c78 sig_cn_org=None source=14.1 
   <para>
    An example:
<screen>
SELECT * FROM test;

 a
-&minus;-
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
________________________________________________________-->
   <para>
    例子：
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=ff72dd1287efdd0005b993f4947b4c78 -->

<!-- pgdoc-cn_start sig_en=a74652145a41bbe876e7fa0a688fb289 sig_cn_org=None source=14.1 
  <para>
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
  </para>
________________________________________________________-->
  <para>
   所有<replaceable>result</replaceable>表达式的数据类型都必须可以转换成单一的输出类型。 参阅<xref linkend="typeconv-union-case"/>获取细节。
  </para>
<!-- pgdoc-cn_end sig_en=a74652145a41bbe876e7fa0a688fb289 -->

<!-- pgdoc-cn_start sig_en=d4c24e5957bc6daa20b6f3c86f887ae7 sig_cn_org=None source=14.1 
  <para>
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
  </para>
________________________________________________________-->
  <para>
   下面这个<quote>简单</quote>形式的<token>CASE</token>表达式是上述通用形式的一个变种：

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   第一个<replaceable>expression</replaceable>会被计算，然后与所有在<token>WHEN</token>子句中的每一个<replaceable>value</replaceable>对比，直到找到一个相等的。如果没有找到匹配的，则返回在<token>ELSE</token>子句中的<replaceable>result</replaceable>（或者控制）。 这类似于 C 里的<function>switch</function>语句。
  </para>
<!-- pgdoc-cn_end sig_en=d4c24e5957bc6daa20b6f3c86f887ae7 -->

<!-- pgdoc-cn_start sig_en=15c62c97754d64fc185ebb444cbcb61c sig_cn_org=None source=14.1 
   <para>
    The example above can be written using the simple
    <token>CASE</token> syntax:
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
________________________________________________________-->
   <para>
    上面的例子可以用简单<token>CASE</token>语法来写：
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=15c62c97754d64fc185ebb444cbcb61c -->

<!-- pgdoc-cn_start sig_en=672f6b491a4d8be283324aab1648f058 sig_cn_org=None source=14.1 
   <para>
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <token>CASE</token>表达式并不计算任何无助于判断结果的子表达式。例如，下面是一个可以避免被零除错误的方法：
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=672f6b491a4d8be283324aab1648f058 -->

   <note>
<!-- pgdoc-cn_start sig_en=e879b9ef8999f9731191b2c790d43bbb sig_cn_org=None source=14.1 
    <para>
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
    </para>
________________________________________________________-->
    <para>
     如<xref linkend="syntax-express-eval"/>中所述，在有几种情况中一个表达式的子表达式
     会被计算多次，因此<quote><token>CASE</token>只计算必要的表达式</quote>这
     一原则并非不可打破。例如一个常量子表达式<literal>1/0</literal>通常将会在规划时导致一次
     除零错误，即便它位于一个执行时永远也不会进入的<token>CASE</token>分支时也是
     如此。
    </para>
<!-- pgdoc-cn_end sig_en=e879b9ef8999f9731191b2c790d43bbb -->
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</literal></title>

<!-- pgdoc-cn_start sig_en=f98f1d67bf9d968137fa8b078657817e sig_cn_org=None source=14.1 
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f98f1d67bf9d968137fa8b078657817e -->

<!-- pgdoc-cn_start sig_en=3f86f1927bb2c09b1ab10e59f1776ac0 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>NVL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>NVL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3f86f1927bb2c09b1ab10e59f1776ac0 -->

<!-- pgdoc-cn_start sig_en=8c45ddcfbe915de8c9729bb8780549a2 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=8c45ddcfbe915de8c9729bb8780549a2 -->

<!-- pgdoc-cn_start sig_en=867896367a879c7db8e700e5c744a5dc sig_cn_org=None source=14.1 
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
________________________________________________________-->
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!-- pgdoc-cn_end sig_en=867896367a879c7db8e700e5c744a5dc -->

<!-- pgdoc-cn_start sig_en=12ff2485b9f1f23a0cc436f825be45c3 sig_cn_org=None source=14.1 
  <para>
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
  </para>
________________________________________________________-->
  <para>
   <function>COALESCE</function>函数返回它的第一个非空参数的值。当且仅当所有参数都为空时才会返回空。它常用于在为显示目的检索数据时用缺省值替换空值。例如：
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   如果<varname>description</varname>不为空，这将会返回它的值，否则如果<varname>short_description</varname>非空则返回<varname>short_description</varname>的值，如果前两个都为空则返回<literal>(none)</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=12ff2485b9f1f23a0cc436f825be45c3 -->

<!-- pgdoc-cn_start sig_en=5be5d54468fa1de20a5d020c200886a2 sig_cn_org=None source=14.1 
   <para>
    The arguments must all be convertible to a common data type, which
    will be the type of the result (see
    <xref linkend="typeconv-union-case"/> for details).
   </para>
________________________________________________________-->
   <para>
    所有参数都必须转换为一个公共数据类型，它将是结果的类型 (详请参见 <xref linkend="typeconv-union-case"/> )。
   </para>
<!-- pgdoc-cn_end sig_en=5be5d54468fa1de20a5d020c200886a2 -->

<!-- pgdoc-cn_start sig_en=706ddfc203e7800c1850cc0fdb9a00f1 sig_cn_org=None source=14.1 
   <para>
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
   </para>
________________________________________________________-->
   <para>
    和<token>CASE</token>表达式一样，<function>COALESCE</function>将不会 计算无助于判断结果的参数；也就是说，在第一个非空参数右边的参数不会被计算。这个 SQL 标准函数提供了类似于<function>NVL</function>和<function>IFNULL</function>的能力，它们被用在某些其他数据库系统中。
   </para>
<!-- pgdoc-cn_end sig_en=706ddfc203e7800c1850cc0fdb9a00f1 -->
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</literal></title>

<!-- pgdoc-cn_start sig_en=b7ed24dcff1db6d8e3918f7711357b0d sig_cn_org=None source=14.1 
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b7ed24dcff1db6d8e3918f7711357b0d -->

<!-- pgdoc-cn_start sig_en=42c6387579d810045c5d33b2d9ae21a6 sig_cn_org=None source=14.1 
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=42c6387579d810045c5d33b2d9ae21a6 -->

<!-- pgdoc-cn_start sig_en=90f9d1f27f56d96e97424d9e5230a303 sig_cn_org=None source=14.1 
  <para>
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
  </para>
________________________________________________________-->
  <para>
   当<replaceable>value1</replaceable>和<replaceable>value2</replaceable>相等时，<function>NULLIF</function>返回一个空值。 
   否则它返回<replaceable>value1</replaceable>。 这些可以用于执行前文给出的<function>COALESCE</function>例子的逆操作：
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   在这个例子中，如果<literal>value</literal>是<literal>(none)</literal>，将返回空值，否则返回<literal>value</literal>的值。
  </para>
<!-- pgdoc-cn_end sig_en=90f9d1f27f56d96e97424d9e5230a303 -->

<!-- pgdoc-cn_start sig_en=60cf20e8fd3317d348af6729f7e3c58a sig_cn_org=None source=14.1 
  <para>
   The two arguments must be of comparable types.
   To be specific, they are compared exactly as if you had
   written <literal><replaceable>value1</replaceable>
   = <replaceable>value2</replaceable></literal>, so there must be a
   suitable <literal>=</literal> operator available.
  </para>
________________________________________________________-->
  <para>
   这两个参数必须具有可比较的类型。具体来说，它们的比较与你写的 <literal><replaceable>value1</replaceable> = <replaceable>value2</replaceable></literal>完全一样，因此必须有一个合适的<literal>=</literal>操作符可用。
  </para>
<!-- pgdoc-cn_end sig_en=60cf20e8fd3317d348af6729f7e3c58a -->

<!-- pgdoc-cn_start sig_en=7aacaddcb187c5fc0f7390f86608d961 sig_cn_org=None source=14.1 
  <para>
   The result has the same type as the first argument &mdash; but there is
   a subtlety.  What is actually returned is the first argument of the
   implied <literal>=</literal> operator, and in some cases that will have
   been promoted to match the second argument's type.  For
   example, <literal>NULLIF(1, 2.2)</literal> yields <type>numeric</type>,
   because there is no <type>integer</type> <literal>=</literal>
   <type>numeric</type> operator,
   only <type>numeric</type> <literal>=</literal> <type>numeric</type>.
  </para>
________________________________________________________-->
  <para>
   结果的类型与第一个参数相同，但有一点细微的区别。实际上返回的是隐含 <literal>=</literal>操作符的第一个参数，在某些情况下，它将被提升以匹配第二个参数的类型。
   例如，<literal>NULLIF(1, 2.2)</literal> 生成 <type>numeric</type>，因为没有<type>integer</type> <literal>=</literal> <type>numeric</type>操作符，只有<type>numeric</type> <literal>=</literal> <type>numeric</type>。
  </para>
<!-- pgdoc-cn_end sig_en=7aacaddcb187c5fc0f7390f86608d961 -->

  </sect2>

  <sect2 id="functions-greatest-least">
<!-- pgdoc-cn_start sig_en=b4aa144b5d1a9d3a62d8be5e697f4ba6 sig_cn_org=None source=14.1 
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
________________________________________________________-->
   <title><literal>GREATEST</literal>和<literal>LEAST</literal></title>
<!-- pgdoc-cn_end sig_en=b4aa144b5d1a9d3a62d8be5e697f4ba6 -->

<!-- pgdoc-cn_start sig_en=03851a89303587bedfdbcadc43edce40 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=03851a89303587bedfdbcadc43edce40 -->
<!-- pgdoc-cn_start sig_en=688b0b1d4ba0c7c3595a23f954f944b7 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=688b0b1d4ba0c7c3595a23f954f944b7 -->

<!-- pgdoc-cn_start sig_en=056460db5b1ee907b34bafebea7de116 sig_cn_org=None source=14.1 
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
________________________________________________________-->
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!-- pgdoc-cn_end sig_en=056460db5b1ee907b34bafebea7de116 -->
<!-- pgdoc-cn_start sig_en=be499f3fd1f54ea78497ecdba92e755a sig_cn_org=None source=14.1 
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
________________________________________________________-->
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!-- pgdoc-cn_end sig_en=be499f3fd1f54ea78497ecdba92e755a -->

<!-- pgdoc-cn_start sig_en=2e10471ab6a6aee3782669d63caf4606 sig_cn_org=None source=14.1 
   <para>
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
   </para>
________________________________________________________-->
   <para>
    <function>GREATEST</function>和<function>LEAST</function>函数从一个任意的数字表达式列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型 （参阅<xref linkend="typeconv-union-case"/>获取细节）。列表中的 NULL 数值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。
   </para>
<!-- pgdoc-cn_end sig_en=2e10471ab6a6aee3782669d63caf4606 -->

<!-- pgdoc-cn_start sig_en=2ef1ead43d40df3b08d82da10dcb379a sig_cn_org=None source=14.1 
   <para>
    Note that <function>GREATEST</function> and <function>LEAST</function> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
   </para>
________________________________________________________-->
   <para>
    请注意<function>GREATEST</function>和<function>LEAST</function>都不是 SQL 标准，但却是很常见的扩展。某些其他数据库让它们在任何参数为 NULL 时返回 NULL，而不是在所有参数都为 NULL 时才返回 NULL。
   </para>
<!-- pgdoc-cn_end sig_en=2ef1ead43d40df3b08d82da10dcb379a -->
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!-- pgdoc-cn_start sig_en=06f4e922a20dec41efc8e68435b03fc0 sig_cn_org=None source=14.1 
  <title>Array Functions and Operators</title>
________________________________________________________-->
  <title>数组函数和操作符</title>
<!-- pgdoc-cn_end sig_en=06f4e922a20dec41efc8e68435b03fc0 -->

<!-- pgdoc-cn_start sig_en=9ab506c9c83e5c04d69bf9bec032e922 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="array-operators-table"/> shows the specialized operators
   available for array types.
   In addition to those, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   arrays.  The comparison operators compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="array-operators-table"/>显示了可以用于数组类型的专用的操作符。
   除此之外，<xref linkend="functions-comparison-op-table"/>中所示的常用比较运算符也适用于数组。
   比较操作符逐个元素的比较数组内容，使用默认的元素数据类型的B-tree比较函数，并根据第一个差值进行排序。
   多维数组的元素按照行序进行访问（最后的下标变化最快）。
   如果两个数组的内容相同但维数不等，那么维度信息中的第一个不同将决定排序顺序。
  </para>
<!-- pgdoc-cn_end sig_en=9ab506c9c83e5c04d69bf9bec032e922 -->

   <table id="array-operators-table">
<!-- pgdoc-cn_start sig_en=823792f7f1d0543f10fa3ce2560e22f1 sig_cn_org=None source=14.1 
    <title>Array Operators</title>
________________________________________________________-->
    <title>数组操作符</title>
<!-- pgdoc-cn_end sig_en=823792f7f1d0543f10fa3ce2560e22f1 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=2ca00386253bdd386fc5ee8fd217054c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first array contain the second, that is, does each element
        appearing in the second array equal some element of the first array?
        (Duplicates are not treated specially,
        thus <literal>ARRAY[1]</literal> and <literal>ARRAY[1,1]</literal> are
        each considered to contain the other.)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组是否包含第二个数组，也就是说，出现在第二个数组中的每个元素是否等于第一个数组中的某个元素?
        (重复值不需要特殊处理，因此<literal>ARRAY[1]</literal> 和 <literal>ARRAY[1,1]</literal>被认为包含对方。)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ca00386253bdd386fc5ee8fd217054c -->

<!-- pgdoc-cn_start sig_en=abfaffe8ea5d22f82ed753cfd0fd1b52 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first array contained by the second?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组包含在第二个数组中么?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=abfaffe8ea5d22f82ed753cfd0fd1b52 -->

<!-- pgdoc-cn_start sig_en=f0085a2701373d96589dfcaf88a4b200 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the arrays overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些数组有重叠么，也就是说，它们有共同的元素么?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f0085a2701373d96589dfcaf88a4b200 -->

<!-- pgdoc-cn_start sig_en=2594a296f6712c0e7094b70af7a5a242 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Concatenates the two arrays.  Concatenating a null or empty array is a
        no-op; otherwise the arrays must have the same number of dimensions
        (as illustrated by the first example) or differ in number of
        dimensions by one (as illustrated by the second).
        If the arrays are not of identical element types, they will be coerced
        to a common type (see <xref linkend="typeconv-union-case"/>).
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9.9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9.9}}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        连接两个数组。连接空(null)或空数组是一个无操作(no-op);否则，数组必须具有相同的维度数(如第一个示例所示)，或者维度数相差一个(如第二个示例所示)。
        如果数组不是完全相同的元素类型，它们将被强制转换成一个共同的类型(参见<xref linkend="typeconv-union-case"/>)。		
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9.9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9.9}}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2594a296f6712c0e7094b70af7a5a242 -->

<!-- pgdoc-cn_start sig_en=f8bb7a5233e5521180bf08c1b3097cc4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the front of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        将元素连接到数组的前面(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8bb7a5233e5521180bf08c1b3097cc4 -->

<!-- pgdoc-cn_start sig_en=50d1cf1a3d946017ef08a48d5ed99f97 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the end of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        将元素连接到数组的末尾(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=50d1cf1a3d946017ef08a48d5ed99f97 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=2ec0da8a72b93a9c0bcfd2ed2c14b15a sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
  </para>
________________________________________________________-->
  <para>
   参阅<xref linkend="arrays"/>获取有关数组操作符行为的更多细节。有关哪些操作符支持被索引的操作，请参阅<xref linkend="indexes-types"/>。
  </para>
<!-- pgdoc-cn_end sig_en=2ec0da8a72b93a9c0bcfd2ed2c14b15a -->

<!-- pgdoc-cn_start sig_en=2145095305ce992ef5def47207d3db6d sig_cn_org=None source=14.1 
  <para>
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="array-functions-table"/>展示了可以用于数组类型的函数。 参阅<xref linkend="arrays"/>获取更多信息以及使用这些函数的例子。
  </para>
<!-- pgdoc-cn_end sig_en=2145095305ce992ef5def47207d3db6d -->

   <table id="array-functions-table">
<!-- pgdoc-cn_start sig_en=215d196c65eb7e7fd2ebf07f718472c9 sig_cn_org=None source=14.1 
    <title>Array Functions</title>
________________________________________________________-->
    <title>数组函数</title>
<!-- pgdoc-cn_end sig_en=215d196c65eb7e7fd2ebf07f718472c9 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=5adbacc7353e1643e9da8b2253034ebb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Appends an element to the end of an array (same as
        the <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>
        operator).
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        向一个数组的末端追加一个元素 (等同于 <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type> 操作符)。
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5adbacc7353e1643e9da8b2253034ebb -->

<!-- pgdoc-cn_start sig_en=762ed76fea989519f9ae0d2fbc5c987a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anycompatiblearray</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Concatenates two arrays (same as
        the <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>
        operator).
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anycompatiblearray</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        连接两个数组(等同于 <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type> 操作符)。
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=762ed76fea989519f9ae0d2fbc5c987a -->

<!-- pgdoc-cn_start sig_en=89fbb584f9a8461c5469ac21728c5d3c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a text representation of the array's dimensions.
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回数组维度的文本表示形式。
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=89fbb584f9a8461c5469ac21728c5d3c -->

<!-- pgdoc-cn_start sig_en=588e5cc459f80277af5bca8d2afc3b56 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns an array filled with copies of the given value, having
        dimensions of the lengths specified by the second argument.
        The optional third argument supplies lower-bound values for each
        dimension (which default to all <literal>1</literal>).
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        返回一个包含给定值的拷贝的数组，其维数与第二个参数指定的长度相同。
        可选的第三个参数提供每个维度的下界值(默认为全部为 <literal>1</literal>)。
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=588e5cc459f80277af5bca8d2afc3b56 -->

<!-- pgdoc-cn_start sig_en=dad32f51e21c728aced80ed5025eba3a sig_cn_org=095bcf01e3d385742e6829e194a85fbb source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the length of the requested array dimension.
        (Produces NULL instead of 0 for empty or missing array dimensions.)
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>array_length(array[]::int[], 1)</literal>
        <returnvalue>NULL</returnvalue>
       </para>
       <para>
        <literal>array_length(array['text'], 2)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的长度。
        （对于空或缺失的数组维度，返回NULL而不是0。）
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>array_length(array[]::int[], 1)</literal>
        <returnvalue>NULL</returnvalue>
       </para>
       <para>
        <literal>array_length(array['text'], 2)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dad32f51e21c728aced80ed5025eba3a -->

<!-- pgdoc-cn_start sig_en=b0650b3721af8d529b554a9e1d3afede sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the lower bound of the requested array dimension.
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的下界。
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b0650b3721af8d529b554a9e1d3afede -->

<!-- pgdoc-cn_start sig_en=1cf6113075807ab4c6396e6a076b52f5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of dimensions of the array.
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组的维度数。
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1cf6113075807ab4c6396e6a076b52f5 -->

<!-- pgdoc-cn_start sig_en=d488c00aa4745f4d742f05021d900a7c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the subscript of the first occurrence of the second argument
        in the array, or <literal>NULL</literal> if it's not present.
        If the third argument is given, the search begins at that subscript.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回阵列中第二个参数中第一次发生的下标，如果它不存在，则返回<literal>NULL</literal>。
        如果给出了第三个参数，则搜索从该下标开始。数组必须是一维的。比较是使用<literal>IS NOT DISTINCT FROM</literal>语义进行的，所以可以搜索<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d488c00aa4745f4d742f05021d900a7c -->

<!-- pgdoc-cn_start sig_en=2068365640895acf4206ef01e9c2764b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the subscripts of all occurrences of the second
        argument in the array given as first argument.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
        <literal>NULL</literal> is returned only if the array
        is <literal>NULL</literal>; if the value is not found in the array, an
        empty array is returned.
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回作为第一个参数的数组中第二个参数所有出现的下标的数组。
        数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以搜索<literal>NULL</literal>。
        只有当数组为<literal>NULL</literal>时才返回<literal>NULL</literal>;如果在数组中没有找到该值，则返回空数组。
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2068365640895acf4206ef01e9c2764b -->

<!-- pgdoc-cn_start sig_en=e10623e51413396c72dc04ac4566bf8f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anycompatible</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Prepends an element to the beginning of an array (same as
        the <type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>
        operator).
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anycompatible</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        在数组的开头添加一个元素(等同于<type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>操作符)。
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e10623e51413396c72dc04ac4566bf8f -->

<!-- pgdoc-cn_start sig_en=01bd70f474f1bda38d33847e44348c01 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Removes all elements equal to the given value from the array.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to remove <literal>NULL</literal>s.
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        从数组中移除与给定值相等的所有元素。数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以删除<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=01bd70f474f1bda38d33847e44348c01 -->

<!-- pgdoc-cn_start sig_en=ab4c287fb24b8dee259383a4d993f041 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        Replaces each array element equal to the second argument with the
        third argument.
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
        将等于第二个参数的每个数组元素替换为第三个参数。
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ab4c287fb24b8dee259383a4d993f041 -->

<!-- pgdoc-cn_start sig_en=f8966b4bfa82aa5c7f8412a1cb988d99 sig_cn_org=a253d5735666e7e21d337a2194d01f93 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-array-to-string">
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts each array element to its text representation, and
        concatenates those separated by
        the <parameter>delimiter</parameter> string.
        If <parameter>null_string</parameter> is given and is
        not <literal>NULL</literal>, then <literal>NULL</literal> array
        entries are represented by that string; otherwise, they are omitted.
        See also <link linkend="function-string-to-array"><function>string_to_array</function></link>.
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-array-to-string">
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将每个数组元素转换为其文本表示，并将它们用<parameter>delimiter</parameter>字符串分隔连接起来。
        如果提供了<parameter>null_string</parameter>且不是<literal>NULL</literal>，则<literal>NULL</literal>数组条目将用该字符串表示；否则将被省略。
        另请参见<link linkend="function-string-to-array"><function>string_to_array</function></link>。
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f8966b4bfa82aa5c7f8412a1cb988d99 -->

<!-- pgdoc-cn_start sig_en=f884cf6d681d5bec1ec774a43399e5be sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the upper bound of the requested array dimension.
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的上界。
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f884cf6d681d5bec1ec774a43399e5be -->

<!-- pgdoc-cn_start sig_en=84567a9adf43db857b603e8b3c31479a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the total number of elements in the array, or 0 if the array
        is empty.
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组中元素的总数，如果数组为空则返回0。
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=84567a9adf43db857b603e8b3c31479a -->

<!-- pgdoc-cn_start sig_en=c23d6aa49141d2caebe28857eaffdba2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_array</primary>
        </indexterm>
        <function>trim_array</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Trims an array by removing the last <parameter>n</parameter> elements.
        If the array is multidimensional, only the first dimension is trimmed.
       </para>
       <para>
        <literal>trim_array(ARRAY[1,2,3,4,5,6], 2)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_array</primary>
        </indexterm>
        <function>trim_array</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        通过删除最后的<parameter>n</parameter>元素来裁剪数组。
        如果数组是多维的，则只裁剪第一个维度。
       </para>
       <para>
        <literal>trim_array(ARRAY[1,2,3,4,5,6], 2)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c23d6aa49141d2caebe28857eaffdba2 -->

<!-- pgdoc-cn_start sig_en=1c5ca630a28caeb977ca292bb374b9fb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands an array into a set of rows.
        The array's elements are read out in storage order.
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para>
       <para>
        <literal>unnest(ARRAY[['foo','bar'],['baz','quux']])</literal>
        <returnvalue></returnvalue>
<programlisting>
 foo
 bar
 baz
 quux
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将数组展开到一组行。
        数组的元素按存储顺序读出。
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para>
       <para>
        <literal>unnest(ARRAY[['foo','bar'],['baz','quux']])</literal>
        <returnvalue></returnvalue>
<programlisting>
 foo
 bar
 baz
 quux
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1c5ca630a28caeb977ca292bb374b9fb -->

<!-- pgdoc-cn_start sig_en=79922e73aa89254222863109e3833fb3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        Expands multiple arrays (possibly of different data types) into a set of
        rows.  If the arrays are not all the same length then the shorter ones
        are padded with <literal>NULL</literal>s.  This form is only allowed
        in a query's FROM clause; see <xref linkend="queries-tablefunctions"/>.
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        将多个数组(可能是不同的数据类型)展开到一组行中。
        如果数组的长度不完全相同，那么较短的数组将用<literal>NULL</literal>填充。
        这种形式只在查询的FROM子句中允许;参见<xref linkend="queries-tablefunctions"/>。
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=79922e73aa89254222863109e3833fb3 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=4dd80b536bed499264c517c0ca55c156 sig_cn_org=None source=14.1 
   <para>
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
   </para>
________________________________________________________-->
   <para>
    也可参见<xref linkend="functions-aggregate"/>了解用于数组的聚集函数<function>array_agg</function>。
   </para>
<!-- pgdoc-cn_end sig_en=4dd80b536bed499264c517c0ca55c156 -->
  </sect1>

 <sect1 id="functions-range">
<!-- pgdoc-cn_start sig_en=27727edc46e310086e0877399150c65c sig_cn_org=None source=14.1 
  <title>Range/Multirange Functions and Operators</title>
________________________________________________________-->
  <title>范围/多范围函数和运算符</title>
<!-- pgdoc-cn_end sig_en=27727edc46e310086e0877399150c65c -->

<!-- pgdoc-cn_start sig_en=93617274fb154324a11dabae9adf2c56 sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="rangetypes"/> for an overview of range types.
  </para>
________________________________________________________-->
  <para>
   范围类型的概述可参见 <xref linkend="rangetypes"/> 。
  </para>
<!-- pgdoc-cn_end sig_en=93617274fb154324a11dabae9adf2c56 -->

<!-- pgdoc-cn_start sig_en=0d14cec7d4f98cb364bda40f8cc538f9 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="range-operators-table"/> shows the specialized operators
   available for range types.
   <xref linkend="multirange-operators-table"/> shows the specialized operators
   available for multirange types.
   In addition to those, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for range
   and multirange types.  The comparison operators order first by the range lower
   bounds, and only if those are equal do they compare the upper bounds.  The
   multirange operators compare each range until one is unequal. This
   does not usually result in a useful overall ordering, but the operators are
   provided to allow unique indexes to be constructed on ranges.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="range-operators-table"/>显示了范围类型的专用操作符。
   <xref linkend="multirange-operators-table"/>显示了多范围类型的专用操作符。
   除此之外，<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符也适用于范围类型和多范围类型。
   比较操作符首先按范围下界排序，只有当它们相等时才比较上界。
   多范围操作符比较每个范围直到某一个为不相等。
   这通常不会导致有用的总体排序，但提供的操作符允许在范围上构造惟一索引。
  </para>
<!-- pgdoc-cn_end sig_en=0d14cec7d4f98cb364bda40f8cc538f9 -->

   <table id="range-operators-table">
<!-- pgdoc-cn_start sig_en=f7753b92120189b2b2959a2cb1d8e4ac sig_cn_org=None source=14.1 
    <title>Range Operators</title>
________________________________________________________-->
    <title>范围操作符</title>
<!-- pgdoc-cn_end sig_en=f7753b92120189b2b2959a2cb1d8e4ac -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=00e8433915d5915305a1e679842f995b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range contain the second?
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围中包含第二个(范围)吗?
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=00e8433915d5915305a1e679842f995b -->

<!-- pgdoc-cn_start sig_en=b1c172b2ec79369343df42b2c9f639f9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range contain the element?
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否包含元素?
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b1c172b2ec79369343df42b2c9f639f9 -->

<!-- pgdoc-cn_start sig_en=314a3278a89c1b6f7c07f023f72ecfbf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range contained by the second?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围包含在第二个(范围)中吗?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=314a3278a89c1b6f7c07f023f72ecfbf -->

<!-- pgdoc-cn_start sig_en=99f8a7875ef3fc0bcf50b06d309713db sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the element contained in the range?
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        元素是否包含在范围内?
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=99f8a7875ef3fc0bcf50b06d309713db -->

<!-- pgdoc-cn_start sig_en=7e80900cfbf2edcc955279674b017279 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the ranges overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否重叠，也就是说，是否有相同的元素?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e80900cfbf2edcc955279674b017279 -->

<!-- pgdoc-cn_start sig_en=f6fd94ff4b86a4373758855e5d355218 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly left of the second?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否严格地在第二个(范围)的左侧?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f6fd94ff4b86a4373758855e5d355218 -->

<!-- pgdoc-cn_start sig_en=577a829f7d617483d6950e75915253dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly right of the second?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否严格符合第二个(范围)?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=577a829f7d617483d6950e75915253dc -->

<!-- pgdoc-cn_start sig_en=41641165e0d0ebe83535aad95adbb180 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the right of the second?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否没有扩展到第二个(范围)的右侧?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=41641165e0d0ebe83535aad95adbb180 -->

<!-- pgdoc-cn_start sig_en=6638d72c23dc61a1b36102eebb69cbaf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the left of the second?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否没有扩展到第二个(范围)的左侧?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6638d72c23dc61a1b36102eebb69cbaf -->

<!-- pgdoc-cn_start sig_en=dbffb313b951fdfeebfc727c3f8e9119 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are the ranges adjacent?
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是相邻的么？
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbffb313b951fdfeebfc727c3f8e9119 -->

<!-- pgdoc-cn_start sig_en=23c9fc2783354775cd56434cb5619c80 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the union of the ranges.  The ranges must overlap or be
        adjacent, so that the union is a single range (but
        see <function>range_merge()</function>).
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的并集。范围必须重叠或相邻，这样的并集就是一个单一的范围(请参见<function>range_merge()</function>)。
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=23c9fc2783354775cd56434cb5619c80 -->

<!-- pgdoc-cn_start sig_en=b2a8b96b333f080abed278a0ae50b5df sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the intersection of the ranges.
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的交集。
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2a8b96b333f080abed278a0ae50b5df -->

<!-- pgdoc-cn_start sig_en=1a4bd392e82c95a2568e644766c50fb0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the difference of the ranges.  The second range must not be
        contained in the first in such a way that the difference would not be
        a single range.
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的差异。第二个范围必须不能包含在第一个(范围)中，以使差异不是一个单一的范围。
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1a4bd392e82c95a2568e644766c50fb0 -->
     </tbody>
    </tgroup>
   </table>

   <table id="multirange-operators-table">
<!-- pgdoc-cn_start sig_en=f1a23a2683cc1efb7d878a70e2a91e7b sig_cn_org=None source=14.1 
    <title>Multirange Operators</title>
________________________________________________________-->
    <title>多范围操作符</title>
<!-- pgdoc-cn_end sig_en=f1a23a2683cc1efb7d878a70e2a91e7b -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fb35e599e1a11d09e6f5b9cc5fc7368a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=e473d147ac81317cf17ad8f0f7c9c130 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first multirange contain the second?
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围是否包含第二个？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e473d147ac81317cf17ad8f0f7c9c130 -->

<!-- pgdoc-cn_start sig_en=69a001a66717ac2396e2dd6819eec741 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the multirange contain the range?
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否包含范围？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69a001a66717ac2396e2dd6819eec741 -->

<!-- pgdoc-cn_start sig_en=b7a876fe9ffdb18d093cde10af004e84 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the multirange contain the element?
       </para>
       <para>
        <literal>'{[2011-01-01,2011-03-01)}'::tsmultirange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否包含元素？
       </para>
       <para>
        <literal>'{[2011-01-01,2011-03-01)}'::tsmultirange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b7a876fe9ffdb18d093cde10af004e84 -->

<!-- pgdoc-cn_start sig_en=4f55431f9f68e3fa23f4f877a511f8f3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range contain the multirange?
       </para>
       <para>
        <literal>'[2,4)'::int4range @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否包含多范围？
       </para>
       <para>
        <literal>'[2,4)'::int4range @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4f55431f9f68e3fa23f4f877a511f8f3 -->

<!-- pgdoc-cn_start sig_en=75ae7ed0da99e340a9bb863c1c1d5f93 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first multirange contained by the second?
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围是否被第二个所包括？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=75ae7ed0da99e340a9bb863c1c1d5f93 -->

<!-- pgdoc-cn_start sig_en=3cb32fe9e928f555717a41996788fd44 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange contained by the range?
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否被范围所包括。
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cb32fe9e928f555717a41996788fd44 -->

<!-- pgdoc-cn_start sig_en=00829b7d61e32a43daf270b3260f8eb0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range contained by the multirange?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否被多范围所包括？
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=00829b7d61e32a43daf270b3260f8eb0 -->

<!-- pgdoc-cn_start sig_en=40aaf4bd94160ddb0b495965909a9e26 sig_cn_org=7c3c394b8b1004ea07125d00d25ed946 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the element contained by the multirange?
       </para>
       <para>
        <literal>4 &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        元素是否包含在多范围内？
       </para>
       <para>
        <literal>4 &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=40aaf4bd94160ddb0b495965909a9e26 -->

<!-- pgdoc-cn_start sig_en=1670f7e4726c35797e68dd9460cb05ea sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the multiranges overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否重叠，也就是说，有任何共同的元素么?
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1670f7e4726c35797e68dd9460cb05ea -->

<!-- pgdoc-cn_start sig_en=232e111274c35638d72793cf08855a83 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the multirange overlap the range?
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否与范围重叠？
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=232e111274c35638d72793cf08855a83 -->

<!-- pgdoc-cn_start sig_en=1321a59d754ecbe259f2543b67603a88 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range overlap the multirange?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否与多范围重叠？
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1321a59d754ecbe259f2543b67603a88 -->

<!-- pgdoc-cn_start sig_en=b0c1c46304e105786ecb636523b7b0b0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first multirange strictly left of the second?
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围是否完全在第二个左边？
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b0c1c46304e105786ecb636523b7b0b0 -->

<!-- pgdoc-cn_start sig_en=80cbd7508f6a9bbf92af971e78ab1564 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange strictly left of the range?
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否完全在范围左边？
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=80cbd7508f6a9bbf92af971e78ab1564 -->

<!-- pgdoc-cn_start sig_en=cf8d866e3e7edd35bfc7b1fa50124a26 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range strictly left of the multirange?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否完全的在多范围左边？
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cf8d866e3e7edd35bfc7b1fa50124a26 -->

<!-- pgdoc-cn_start sig_en=163ec338fced5e89b2cc5eb50c23e20d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first multirange strictly right of the second?
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围是否完全在第二个的右边？
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=163ec338fced5e89b2cc5eb50c23e20d -->

<!-- pgdoc-cn_start sig_en=9a50586645d76fefbafc792cb19bff1a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange strictly right of the range?
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否完全在范围右边？
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9a50586645d76fefbafc792cb19bff1a -->

<!-- pgdoc-cn_start sig_en=1284168b311c06bc969915b8ae8692a3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range strictly right of the multirange?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否完全在多范围右边。
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1284168b311c06bc969915b8ae8692a3 -->

<!-- pgdoc-cn_start sig_en=d78ec592ebe57d57b3018e6994d7eecb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first multirange not extend to the right of the second?
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围不扩展到第二个的右边吗?
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d78ec592ebe57d57b3018e6994d7eecb -->

<!-- pgdoc-cn_start sig_en=e88e95ad853e773bf6a83a2154e04622 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the multirange not extend to the right of the range?
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围不扩展到范围的右边吗?
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e88e95ad853e773bf6a83a2154e04622 -->

<!-- pgdoc-cn_start sig_en=77bac8a9d69d585ac5895db16807bb67 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range not extend to the right of the multirange?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围不扩展到多范围的右边吗?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=77bac8a9d69d585ac5895db16807bb67 -->

<!-- pgdoc-cn_start sig_en=9df7d207eee1a8c7588f66ea6f1b30bc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first multirange not extend to the left of the second?
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个多范围不扩展到第二个的左边吗?
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9df7d207eee1a8c7588f66ea6f1b30bc -->

<!-- pgdoc-cn_start sig_en=aedd5ddb94f615b6910f76cb812803c8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the multirange not extend to the left of the range?
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围不扩展到范围的左边吗?
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aedd5ddb94f615b6910f76cb812803c8 -->

<!-- pgdoc-cn_start sig_en=b44853708bc89305066da21db6f44a80 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range not extend to the left of the multirange?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围不扩展到多范围的左边吗?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b44853708bc89305066da21db6f44a80 -->

<!-- pgdoc-cn_start sig_en=22dd33d4515ff4158721104f20930e42 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are the multiranges adjacent?
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是相邻的吗?
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22dd33d4515ff4158721104f20930e42 -->

<!-- pgdoc-cn_start sig_en=dc128eaa2dd42ec6f5154513cbc237ae sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange adjacent to the range?
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围与范围是相邻的吗？
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dc128eaa2dd42ec6f5154513cbc237ae -->

<!-- pgdoc-cn_start sig_en=f84c46a886ad432145afa21b9529a567 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range adjacent to the multirange?
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围与多范围是相邻的吗？
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f84c46a886ad432145afa21b9529a567 -->

<!-- pgdoc-cn_start sig_en=ba8db03246d44ecac80e4edb42fb4d4a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>+</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Computes the union of the multiranges.  The multiranges need not overlap
        or be adjacent.
       </para>
       <para>
        <literal>'{[5,10)}'::nummultirange + '{[15,20)}'::nummultirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>+</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        计算多范围的并集。多范围不需要重叠或相邻。
       </para>
       <para>
        <literal>'{[5,10)}'::nummultirange + '{[15,20)}'::nummultirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ba8db03246d44ecac80e4edb42fb4d4a -->

<!-- pgdoc-cn_start sig_en=995c5fde16e9d3fb3666e25c35425d93 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>*</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Computes the intersection of the multiranges.
       </para>
       <para>
        <literal>'{[5,15)}'::int8multirange * '{[10,20)}'::int8multirange</literal>
        <returnvalue>{[10,15)}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>*</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        计算多范围的交集。
       </para>
       <para>
        <literal>'{[5,15)}'::int8multirange * '{[10,20)}'::int8multirange</literal>
        <returnvalue>{[10,15)}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=995c5fde16e9d3fb3666e25c35425d93 -->

<!-- pgdoc-cn_start sig_en=352bdf2aa437f4c47196631b6b26d9b8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Computes the difference of the multiranges.
       </para>
       <para>
        <literal>'{[5,20)}'::int8multirange - '{[10,15)}'::int8multirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        计算多范围的差异。
       </para>
       <para>
        <literal>'{[5,20)}'::int8multirange - '{[10,15)}'::int8multirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=352bdf2aa437f4c47196631b6b26d9b8 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=47782a06a5923dcb24a950438d34c3c0 sig_cn_org=None source=14.1 
  <para>
   The left-of/right-of/adjacent operators always return false when an empty
   range or multirange is involved; that is, an empty range is not considered to
   be either before or after any other range.
  </para>
________________________________________________________-->
  <para>
   当涉及一个空范围或多范围时，左部/右部/相邻操作符总是返回假；即一个空范围被认为不在任何其他范围前面或者后面。
  </para>
<!-- pgdoc-cn_end sig_en=47782a06a5923dcb24a950438d34c3c0 -->

<!-- pgdoc-cn_start sig_en=6a21f7af5a8d3a8319d02bd76f1eaf67 sig_cn_org=None source=14.1 
  <para>
   Elsewhere empty ranges and multiranges are treated as the additive identity:
   anything unioned with an empty value is itself. Anything minus an empty
   value is itself. An empty multirange has exactly the same points as an empty
   range. Every range contains the empty range. Every multirange contains as many
   empty ranges as you like.
  </para>
________________________________________________________-->
  <para>
   在其他地方，空范围和多范围被视为添加标识:与空值的任何交集都是它自己。
   任何减去空值的都是它自己。
   空的多范围与空的范围具有完全相同的点。
   每个范围都包含空范围。
   每个多范围包含任意多个空范围。
  </para>
<!-- pgdoc-cn_end sig_en=6a21f7af5a8d3a8319d02bd76f1eaf67 -->

<!-- pgdoc-cn_start sig_en=f83e52a0eaaf487e140fd118d3d06bf4 sig_cn_org=None source=14.1 
  <para>
   The range union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented. There are separate operators for union and difference that take
   multirange parameters and return a multirange, and they do not fail even if
   their arguments are disjoint. So if you need a union or difference operation
   for ranges that may be disjoint, you can avoid errors by first casting your
   ranges to multiranges.
  </para>
________________________________________________________-->
  <para>
   范围交集和差异操作符将失败，如果结果范围需要包含两个不相交的子范围，因为这样的范围无法表示。
   有用于交集和差分的单独运算符，可接受多范围参数并返回多范围，即使它们的参数不相交也不会失败。
   因此，如果需要对可能不相交的范围进行交集或差异操作，你可以通过首先将范围转换为多范围来避免错误。
  </para>
<!-- pgdoc-cn_end sig_en=f83e52a0eaaf487e140fd118d3d06bf4 -->

<!-- pgdoc-cn_start sig_en=7a5165a5030b8980c0679e1117e70290 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
   <xref linkend="multirange-functions-table"/> shows the functions
   available for use with multirange types.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="range-functions-table"/> 显示可用于范围类型的函数。
   <xref linkend="multirange-functions-table"/>显示可用于多范围类型的函数。
  </para>
<!-- pgdoc-cn_end sig_en=7a5165a5030b8980c0679e1117e70290 -->

   <table id="range-functions-table">
<!-- pgdoc-cn_start sig_en=3c7d367e264f303e85cd11a811562331 sig_cn_org=None source=14.1 
    <title>Range Functions</title>
________________________________________________________-->
    <title>范围函数</title>
<!-- pgdoc-cn_end sig_en=3c7d367e264f303e85cd11a811562331 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=2644c012f426709898f801b9a8332ffb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the lower bound of the range (<literal>NULL</literal> if the
        range is empty or the lower bound is infinite).
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取范围的下界(如果范围为空或下界为无限，则为<literal>NULL</literal>)。
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2644c012f426709898f801b9a8332ffb -->

<!-- pgdoc-cn_start sig_en=6c9b5c62ba6754997fa61942cbd9b910 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the upper bound of the range (<literal>NULL</literal> if the
        range is empty or the upper bound is infinite).
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取范围的上限(如果范围为空或上限为无限，则为<literal>NULL</literal>)。
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6c9b5c62ba6754997fa61942cbd9b910 -->

<!-- pgdoc-cn_start sig_en=497479d99a1918bcfe53240ea95088a4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range empty?
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围为空吗?
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=497479d99a1918bcfe53240ea95088a4 -->

<!-- pgdoc-cn_start sig_en=14d04f2ade7386e2641508848c3a9e3b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound inclusive?
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的下界是否包含在内?
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=14d04f2ade7386e2641508848c3a9e3b -->

<!-- pgdoc-cn_start sig_en=5d034873312b85c2df0eee2564c85a41 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound inclusive?
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的上界是否包含在内?
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5d034873312b85c2df0eee2564c85a41 -->

<!-- pgdoc-cn_start sig_en=06869b51a1d2d557ad3f23637816783f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound infinite?
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的下界是无限的吗?
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=06869b51a1d2d557ad3f23637816783f -->

<!-- pgdoc-cn_start sig_en=78339fcd929c3e17f9edecd511604ad7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound infinite?
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的上界是无限的吗?
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=78339fcd929c3e17f9edecd511604ad7 -->

<!-- pgdoc-cn_start sig_en=8ac8e4f4b633befc7e9d9fbb52453298 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the smallest range that includes both of the given ranges.
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算包含两个给定范围的最小范围。
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8ac8e4f4b633befc7e9d9fbb52453298 -->
     </tbody>
    </tgroup>
   </table>

   <table id="multirange-functions-table">
<!-- pgdoc-cn_start sig_en=23f2441a595dace46949202898068aff sig_cn_org=None source=14.1 
    <title>Multirange Functions</title>
________________________________________________________-->
    <title>多范围函数</title>
<!-- pgdoc-cn_end sig_en=23f2441a595dace46949202898068aff -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=565ba7cc99620f7f42d5cc05a2916c5f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the lower bound of the multirange (<literal>NULL</literal> if the
        multirange is empty or the lower bound is infinite).
       </para>
       <para>
        <literal>lower('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取多范围的下界 (<literal>NULL</literal> 如果多范围为空或下界为无穷的)。
       </para>
       <para>
        <literal>lower('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=565ba7cc99620f7f42d5cc05a2916c5f -->

<!-- pgdoc-cn_start sig_en=2531a79653b9dc3d4bfa5e5ace1eee20 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the upper bound of the multirange (<literal>NULL</literal> if the
        multirange is empty or the upper bound is infinite).
       </para>
       <para>
        <literal>upper('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取多范围的上界 (<literal>NULL</literal> 如果多范围为空或上界为无穷的)。
       </para>
       <para>
        <literal>upper('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2531a79653b9dc3d4bfa5e5ace1eee20 -->

<!-- pgdoc-cn_start sig_en=53576831089cab4f6ecec4cb15ab9e45 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange empty?
       </para>
       <para>
        <literal>isempty('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围是否为空？
       </para>
       <para>
        <literal>isempty('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=53576831089cab4f6ecec4cb15ab9e45 -->

<!-- pgdoc-cn_start sig_en=1e6b47215f95a65c5ec43ce6505270ef sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange's lower bound inclusive?
       </para>
       <para>
        <literal>lower_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围的下界是否包括？
       </para>
       <para>
        <literal>lower_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1e6b47215f95a65c5ec43ce6505270ef -->

<!-- pgdoc-cn_start sig_en=d89815f79abfa1690f63104c7d4a5ed4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange's upper bound inclusive?
       </para>
       <para>
        <literal>upper_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围的上界是否包括？
       </para>
       <para>
        <literal>upper_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d89815f79abfa1690f63104c7d4a5ed4 -->

<!-- pgdoc-cn_start sig_en=3a2124cab9d687c87a9f7ee633041cc1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange's lower bound infinite?
       </para>
       <para>
        <literal>lower_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围的下界是无限的么？
       </para>
       <para>
        <literal>lower_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3a2124cab9d687c87a9f7ee633041cc1 -->

<!-- pgdoc-cn_start sig_en=28e944c2aec4ef52293970fc6cd80b8f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the multirange's upper bound infinite?
       </para>
       <para>
        <literal>upper_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        多范围的上界是无限的么?
       </para>
       <para>
        <literal>upper_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28e944c2aec4ef52293970fc6cd80b8f -->

<!-- pgdoc-cn_start sig_en=eca67a70828395553436c401e8a02ffa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anymultirange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the smallest range that includes the entire multirange.
       </para>
       <para>
        <literal>range_merge('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anymultirange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算包含整个多范围的最小范围。
       </para>
       <para>
        <literal>range_merge('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eca67a70828395553436c401e8a02ffa -->

<!-- pgdoc-cn_start sig_en=7b9d2cf2c5b7b88e70b1ea727857228c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>multirange (function)</primary>
        </indexterm>
        <function>multirange</function> ( <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Returns a multirange containing just the given range.
       </para>
       <para>
        <literal>multirange('[1,2)'::int4range)</literal>
        <returnvalue>{[1,2)}</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>multirange (function)</primary>
        </indexterm>
        <function>multirange</function> ( <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        返回仅包含给定范围的多范围。
       </para>
       <para>
        <literal>multirange('[1,2)'::int4range)</literal>
        <returnvalue>{[1,2)}</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7b9d2cf2c5b7b88e70b1ea727857228c -->

<!-- pgdoc-cn_start sig_en=0227c220e0a64d208df88752c0b29eec sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for multirange</secondary>
        </indexterm>
        <function>unnest</function> ( <type>anymultirange</type> )
        <returnvalue>setof anyrange</returnvalue>
       </para>
       <para>
        Expands a multirange into a set of ranges.
        The ranges are read out in storage order (ascending).
       </para>
       <para>
        <literal>unnest('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue></returnvalue>
<programlisting>
 [1,2)
 [3,4)
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for multirange</secondary>
        </indexterm>
        <function>unnest</function> ( <type>anymultirange</type> )
        <returnvalue>setof anyrange</returnvalue>
       </para>
       <para>
        扩展多范围为一组范围。
        范围按存储顺序读出(升序)。
       </para>
       <para>
        <literal>unnest('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue></returnvalue>
<programlisting>
 [1,2)
 [3,4)
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0227c220e0a64d208df88752c0b29eec -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=fa411eb7566e8d2ee94e1a90dc9060f7 sig_cn_org=None source=14.1 
  <para>
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range or multirange.
  </para>
________________________________________________________-->
  <para>
   <function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>、 和 <function>upper_inf</function> 函数对空范围(empty range)或多范围都返回假(false)。
  </para>
<!-- pgdoc-cn_end sig_en=fa411eb7566e8d2ee94e1a90dc9060f7 -->
  </sect1>

 <sect1 id="functions-aggregate">
<!-- pgdoc-cn_start sig_en=3ace9aa56a8bc975efb162241768b2f9 sig_cn_org=None source=14.1 
  <title>Aggregate Functions</title>
________________________________________________________-->
  <title>聚集函数</title>
<!-- pgdoc-cn_end sig_en=3ace9aa56a8bc975efb162241768b2f9 -->

<!-- pgdoc-cn_start sig_en=597155ceb95bdcd54c19b49117a22366 sig_cn_org=None source=14.1 
  <indexterm zone="functions-aggregate">
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-aggregate">
   <primary>聚集函数</primary>
   <secondary>内建</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=597155ceb95bdcd54c19b49117a22366 -->

<!-- pgdoc-cn_start sig_en=4b67cd437f1227744b083d0e593e201b sig_cn_org=None source=14.1 
  <para>
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   while statistical aggregates are in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
  </para>
________________________________________________________-->
  <para>
   <firstterm>聚集函数</firstterm>从一个输入值的集合计算出一个单一值。
   内建的通用聚集函数在<xref linkend="functions-aggregate-table"/>中列出，而统计性聚集是在<xref linkend="functions-aggregate-statistics-table"/>中列出。
   内建的组内有序集聚集函数在<xref linkend="functions-orderedset-table"/>中列出，而内建的组内假想集聚集在<xref linkend="functions-hypothetical-table"/>中列出。
   与聚集函数紧密相关的分组操作在<xref linkend="functions-grouping-table"/>中列出。
   <xref linkend="syntax-aggregates"/>中会解释针对聚集函数的特殊语法考虑。额外的介绍信息请参考<xref linkend="tutorial-agg"/>。
  </para>
<!-- pgdoc-cn_end sig_en=4b67cd437f1227744b083d0e593e201b -->

<!-- pgdoc-cn_start sig_en=173bf081dbcb43f8094e38e25336fd0d sig_cn_org=None source=14.1 
  <para>
   Aggregate functions that support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
  </para>
________________________________________________________-->
  <para>
   支持<firstterm>部分模式</firstterm>的聚合函数具备参与各种优化的条件，例如并行聚合。
  </para>
<!-- pgdoc-cn_end sig_en=173bf081dbcb43f8094e38e25336fd0d -->

   <table id="functions-aggregate-table">
<!-- pgdoc-cn_start sig_en=b8514ef2c985592aa9d0294febe0efd5 sig_cn_org=None source=14.1 
    <title>General-Purpose Aggregate Functions</title>
________________________________________________________-->
    <title>通用聚集函数</title>
<!-- pgdoc-cn_end sig_en=b8514ef2c985592aa9d0294febe0efd5 -->
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=51e6694061f62cbd0db5ed40056d2488 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
<!-- pgdoc-cn_end sig_en=51e6694061f62cbd0db5ed40056d2488 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=21d7252142ceabfcb7f1f5b0c31f71eb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into an array.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将所有输入值，包括空值，收集到一个数组中。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=21d7252142ceabfcb7f1f5b0c31f71eb -->

<!-- pgdoc-cn_start sig_en=98560e06a052448e02b7d0f55dab617c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates all the input arrays into an array of one higher
        dimension.  (The inputs must all have the same dimensionality, and
        cannot be empty or null.)
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将所有输入数组连接到一个更高维度的数组中。(输入必须都具有相同的维度，并且不能为空的(empty)或空值(null)。)
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=98560e06a052448e02b7d0f55dab617c -->

<!-- pgdoc-cn_start sig_en=6f081112b141e66b3299ebcb4d8a7f1b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the average (arithmetic mean) of all the non-null input
        values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        计算所有非空输入值的平均值(算术平均值)。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f081112b141e66b3299ebcb4d8a7f1b -->

<!-- pgdoc-cn_start sig_en=6312b42c789a44c61479c4d5841983ad sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise AND of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        计算所有非空输入值的逐位AND。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6312b42c789a44c61479c4d5841983ad -->

<!-- pgdoc-cn_start sig_en=a0633c2b1edde8968af0110732e2af5e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise OR of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        计算所有非空输入值的逐位OR。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a0633c2b1edde8968af0110732e2af5e -->

<!-- pgdoc-cn_start sig_en=a9a5711068ec392cd5a6818a09f5d66a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_xor</primary>
        </indexterm>
        <function>bit_xor</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise exclusive OR of all non-null input values.
        Can be useful as a checksum for an unordered set of values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_xor</primary>
        </indexterm>
        <function>bit_xor</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        计算所有非空输入值的按位OR。
        可用作一组无序的值集合的校验和。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a9a5711068ec392cd5a6818a09f5d66a -->

<!-- pgdoc-cn_start sig_en=065c43f24c32b4072bb17cda8e95796b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if all non-null input values are true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果全部非空输入值都为真则返回真，否则返回假。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=065c43f24c32b4072bb17cda8e95796b -->

<!-- pgdoc-cn_start sig_en=a719eef6113a18dab9d447d93a164c3a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if any non-null input value is true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果任何非空输入值为真则返回真，否则返回假。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a719eef6113a18dab9d447d93a164c3a -->

<!-- pgdoc-cn_start sig_en=52f1360be7882fbb7150a496687ef0fb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算输入行的数量。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=52f1360be7882fbb7150a496687ef0fb -->

<!-- pgdoc-cn_start sig_en=6b6c050797e92f69912c3d0881be278d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows in which the input value is not
        null.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算输入值不为空的输入行的数量。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6b6c050797e92f69912c3d0881be278d -->

<!-- pgdoc-cn_start sig_en=7d4ff10a75919602d729f1f0c886824b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is the SQL standard's equivalent to <function>bool_and</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这是对应<function>bool_and</function>的SQL标准的等效物。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=7d4ff10a75919602d729f1f0c886824b -->

<!-- pgdoc-cn_start sig_en=381891a75f4adf3d9b6ef90effb1acef sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into a JSON array.
        Values are converted to JSON as per <function>to_json</function>
        or <function>to_jsonb</function>.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        收集所有输入值，包括空值，到一个JSON数组。根据<function>to_json</function>或<function>to_jsonb</function>将值转换为JSON。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=381891a75f4adf3d9b6ef90effb1acef -->

<!-- pgdoc-cn_start sig_en=52400094cf69e8433d888922ce2aaa8a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
        Values can be null, but not keys.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
        值可以为空，但键不能（为空）。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=52400094cf69e8433d888922ce2aaa8a -->

<!-- pgdoc-cn_start sig_en=9e577bc5cb2e2ffbfa9f4fa130a4e33e sig_cn_org=28d04cfc4063721764ecf1813f593293 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>max</primary>
        </indexterm>
        <function>max</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the maximum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>, <type>xid8</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>最大值</primary>
        </indexterm>
        <function>max</function> ( <replaceable>见文本</replaceable> )
        <returnvalue><replaceable>与输入类型相同</replaceable></returnvalue>
       </para>
       <para>
        计算非空输入值的最大值。适用于任何数字、字符串、日期/时间或枚举类型，
        以及<type>inet</type>、<type>interval</type>、
        <type>money</type>、<type>oid</type>、<type>pg_lsn</type>、
        <type>tid</type>、<type>xid8</type>，
        以及这些类型的数组。
       </para></entry>
       <entry>是</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9e577bc5cb2e2ffbfa9f4fa130a4e33e -->

<!-- pgdoc-cn_start sig_en=3b76ffee11cb658719f9ad080556e2a8 sig_cn_org=64ad4462cf2fbb16dd9e4e20d06d89c4 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min</primary>
        </indexterm>
        <function>min</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the minimum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>, <type>xid8</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>最小值</primary>
        </indexterm>
        <function>min</function> ( <replaceable>见文本</replaceable> )
        <returnvalue><replaceable>与输入类型相同</replaceable></returnvalue>
       </para>
       <para>
        计算非空输入值的最小值。适用于任何数字、字符串、日期/时间或枚举类型，
        以及<type>inet</type>、<type>interval</type>、
        <type>money</type>、<type>oid</type>、<type>pg_lsn</type>、
        <type>tid</type>、<type>xid8</type>，
        以及这些类型的数组。
       </para></entry>
       <entry>是</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b76ffee11cb658719f9ad080556e2a8 -->

<!-- pgdoc-cn_start sig_en=3beb5a7f6515b7cc4410cd49faf1e08a sig_cn_org=7ce2afee13e548c97da0d3991416fdea source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_agg</primary>
        </indexterm>
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Computes the union of the non-null input values.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>时间范围并集</primary>
        </indexterm>
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        计算非空输入值的并集。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3beb5a7f6515b7cc4410cd49faf1e08a -->

<!-- pgdoc-cn_start sig_en=b090dc3dc72f3b36d48af3ad2ceb42e8 sig_cn_org=815085f3a6fd0d32d9a17e28eef8ef3a source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_intersect_agg</primary>
        </indexterm>
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        Computes the intersection of the non-null input values.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>时间范围交集</primary>
        </indexterm>
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
        计算非空输入值的交集。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b090dc3dc72f3b36d48af3ad2ceb42e8 -->

<!-- pgdoc-cn_start sig_en=944a3182094fd67a79e94647140f917d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the non-null input values into a string.  Each value
        after the first is preceded by the
        corresponding <parameter>delimiter</parameter> (if it's not null).
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        连接非空输入值到字符串中。第一个值之后的每个值前面都有相应的<parameter>分隔符(delimiter)</parameter>(如果它不为空)。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=944a3182094fd67a79e94647140f917d -->

<!-- pgdoc-cn_start sig_en=2ddb257189e52a54a0d1c296d1f9ace4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
        Computes the sum of the non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
        计算非空输入值的总和。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ddb257189e52a54a0d1c296d1f9ace4 -->

<!-- pgdoc-cn_start sig_en=01b9fd83ae6359518d6364af1b97bd8d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
        Concatenates the non-null XML input values (see
        <xref linkend="functions-xml-xmlagg"/>).
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
        连接非空的XML输入值(参见<xref linkend="functions-xml-xmlagg"/>)。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=01b9fd83ae6359518d6364af1b97bd8d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=9f70ecfa109c3b74f6c2748889648a96 sig_cn_org=None source=14.1 
  <para>
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
  </para>
________________________________________________________-->
  <para>
   应该注意的是，除了<function>count</function>之外，这些函数在没有选择行时返回空值。
   特别地，行数的<function>sum</function>返回空(null)，而不是预期的零，<function>array_agg</function>在没有输入行时返回空(null)而不是空数组。
   <function>coalesce</function>函数可以在必要时用零或空数组代替空(null)。
  </para>
<!-- pgdoc-cn_end sig_en=9f70ecfa109c3b74f6c2748889648a96 -->

<!-- pgdoc-cn_start sig_en=b78b99b25f3e864e4518c2c92eb5d424 sig_cn_org=None source=14.1 
  <para>
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
  </para>
________________________________________________________-->
  <para>
   聚合函数 <function>array_agg</function>,<function>json_agg</function>, <function>jsonb_agg</function>,<function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,和 <function>xmlagg</function>,以及类似的用户定义的聚合函数，根据输入值的顺序产生富有意义的不同的结果值。 
   默认情况下，这种排序是不指定的，但可以通过在聚合调用中写入<literal>ORDER BY</literal>子句来控制，如<xref linkend="syntax-aggregates"/>所示。
   或者，从排序的子查询提供输入值通常也可以。例如：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   注意，如果外部查询级别包含其他处理，例如关联，则此方法可能会失败，因为这可能导致子查询的输出在计算聚合之前重新排序。
  </para>
<!-- pgdoc-cn_end sig_en=b78b99b25f3e864e4518c2c92eb5d424 -->

  <note>
<!-- pgdoc-cn_start sig_en=6f63b31e460a0cded628ff2372f984cf sig_cn_org=None source=14.1 
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=6f63b31e460a0cded628ff2372f984cf -->
<!-- pgdoc-cn_start sig_en=250ce5e4b6e4c8bf0f3aedccf2df3a81 sig_cn_org=None source=14.1 
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=250ce5e4b6e4c8bf0f3aedccf2df3a81 -->
<!-- pgdoc-cn_start sig_en=9111099a38094ca4348dce1de2443327 sig_cn_org=None source=14.1 
    <para>
      The boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to the standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      <productname>PostgreSQL</productname>
      supports <function>every</function>, but not <function>any</function>
      or <function>some</function>, because there is an ambiguity built into
      the standard syntax:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
    </para>
________________________________________________________-->
    <para>
      布尔聚合 <function>bool_and</function> 和 <function>bool_or</function> 对应于标准SQL聚合 <function>every</function> 和 <function>any</function> 或 <function>some</function>.
      <productname>PostgreSQL</productname> 支持 <function>every</function>, 但不支持 <function>any</function> 或 <function>some</function>, 因为标准语法中存在模糊性:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      这里<function>ANY</function>可以被认为是引入子查询，或者是聚合函数，如果子查询返回一行布尔值。因此，不能为这些聚合提供标准名称。
    </para>
<!-- pgdoc-cn_end sig_en=9111099a38094ca4348dce1de2443327 -->
  </note>

  <note>
<!-- pgdoc-cn_start sig_en=1de64c3cdd6d922739438e86ba6934a4 sig_cn_org=None source=14.1 
   <para>
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index that includes all rows in
    the table.
   </para>
________________________________________________________-->
   <para>
    习惯使用其他SQL数据库管理系统的用户可能会对<function>count</function>聚合应用于整个表时的性能感到失望。一个类似下面的查询:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    将需要与表大小成比例的工作:<productname>PostgreSQL</productname>将需要扫描整个表或包含表中所有行的索引。
   </para>
<!-- pgdoc-cn_end sig_en=1de64c3cdd6d922739438e86ba6934a4 -->
  </note>

<!-- pgdoc-cn_start sig_en=1adbdd40e97d310eed81b140225d10cf sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Functions shown as
   accepting <replaceable>numeric_type</replaceable> are available for all
   the types <type>smallint</type>, <type>integer</type>,
   <type>bigint</type>, <type>numeric</type>, <type>real</type>,
   and <type>double precision</type>.
   Where the description mentions
   <parameter>N</parameter>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <parameter>N</parameter> is zero.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-aggregate-statistics-table"/>显示了统计分析中常用的聚合函数。
   (这些被分离出来仅仅是为了避免使更常用的聚合列表混乱。)
   显示为接受<replaceable>numeric_type</replaceable>的函数可用于所有类型<type>smallint</type>, <type>integer</type>,<type>bigint</type>, <type>numeric</type>, <type>real</type>, 和 <type>double precision</type>。
   在描述中提及<parameter>N</parameter>时，它意味着所有输入表达式都非空的输入行数。在所有情况下，如果计算没有意义，则返回null，例如当<parameter>N</parameter>为0时。
  </para>
<!-- pgdoc-cn_end sig_en=1adbdd40e97d310eed81b140225d10cf -->

<!-- pgdoc-cn_start sig_en=6b6ec0f099599b727e22c0c1049eba0f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>statistics</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>统计</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6b6ec0f099599b727e22c0c1049eba0f -->
<!-- pgdoc-cn_start sig_en=9395a7e8b4b1dc9fe7deb3ee1aeac3de sig_cn_org=None source=14.1 
  <indexterm>
   <primary>linear regression</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>线性回归</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9395a7e8b4b1dc9fe7deb3ee1aeac3de -->

   <table id="functions-aggregate-statistics-table">
<!-- pgdoc-cn_start sig_en=d736d0f930227a054370633183190140 sig_cn_org=None source=14.1 
    <title>Aggregate Functions for Statistics</title>
________________________________________________________-->
    <title>用于统计的聚集函数</title>
<!-- pgdoc-cn_end sig_en=d736d0f930227a054370633183190140 -->
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=51e6694061f62cbd0db5ed40056d2488 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
<!-- pgdoc-cn_end sig_en=51e6694061f62cbd0db5ed40056d2488 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=bbfe93a3f0b3e728f99a8d824ea98c2a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算相关系数。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=bbfe93a3f0b3e728f99a8d824ea98c2a -->

<!-- pgdoc-cn_start sig_en=809fcc99d7e484c97e71486d1c4a9ee0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the population covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总体协方差。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=809fcc99d7e484c97e71486d1c4a9ee0 -->

<!-- pgdoc-cn_start sig_en=3b675dae81a333acc65eb92b2a16189a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the sample covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算样本协方差。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3b675dae81a333acc65eb92b2a16189a -->

<!-- pgdoc-cn_start sig_en=3576d114170075a7ed79202d55c3922a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the independent variable,
        <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算自变量的平均值,<literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3576d114170075a7ed79202d55c3922a -->

<!-- pgdoc-cn_start sig_en=d24a7f858f7fe4c66a3dbe1b3dd50caa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the dependent variable,
        <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算因变量的平均值，<literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=d24a7f858f7fe4c66a3dbe1b3dd50caa -->

<!-- pgdoc-cn_start sig_en=af69c33b2b4e7061fa017556eafd7a46 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of rows in which both inputs are non-null.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算两个输入都非空的行数。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=af69c33b2b4e7061fa017556eafd7a46 -->

<!-- pgdoc-cn_start sig_en=006d587dc5f4961d04b8564656882791 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the y-intercept of the least-squares-fit linear equation
        determined by the
        (<parameter>X</parameter>, <parameter>Y</parameter>) pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算由(<parameter>X</parameter>，<parameter>Y</parameter>)对决定的最小二乘拟合的线性方程的Y-截距。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=006d587dc5f4961d04b8564656882791 -->

<!-- pgdoc-cn_start sig_en=03ec1669a37bfa9d7d319d46a17c4888 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the square of the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算相关系数的平方。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=03ec1669a37bfa9d7d319d46a17c4888 -->

<!-- pgdoc-cn_start sig_en=9af4b7d7385f3bb7a37a56cf7c2b50ea sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the slope of the least-squares-fit linear equation determined
        by the (<parameter>X</parameter>, <parameter>Y</parameter>)
        pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算由(<parameter>X</parameter>, <parameter>Y</parameter>)对决定的最小二乘拟合的线性方程的斜率。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9af4b7d7385f3bb7a37a56cf7c2b50ea -->

<!-- pgdoc-cn_start sig_en=c215d8b45bf2a79ade9d020b462cd86e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the independent
        variable,
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算自变量的<quote>平方和</quote>
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c215d8b45bf2a79ade9d020b462cd86e -->

<!-- pgdoc-cn_start sig_en=ec30a34f871a35c6c61d5b18e98f29ed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of products</quote> of independent times
        dependent variables,
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算独立变量乘以因变量的<quote>sum of products</quote>，
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=ec30a34f871a35c6c61d5b18e98f29ed -->

<!-- pgdoc-cn_start sig_en=b6d7bbffdc21a239d39ebba912aae125 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the dependent
        variable,
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算因变量的<quote>平方和</quote>，
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b6d7bbffdc21a239d39ebba912aae125 -->

<!-- pgdoc-cn_start sig_en=b4648ad551a401899558a08b18ed0ab5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>stddev_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        这是<function>stddev_samp</function>的一个历史别称。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b4648ad551a401899558a08b18ed0ab5 -->

<!-- pgdoc-cn_start sig_en=000cf76e8c5f17f8feefa66e8abe3ed3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的总体标准差。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=000cf76e8c5f17f8feefa66e8abe3ed3 -->

<!-- pgdoc-cn_start sig_en=e665f4c70e9c35b4a8b207a049a0543b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的样本标准差。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=e665f4c70e9c35b4a8b207a049a0543b -->

<!-- pgdoc-cn_start sig_en=0d21f7b142f2977a990060719aec592a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>var_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        这是 <function>var_samp</function> 的一个历史别称。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=0d21f7b142f2977a990060719aec592a -->

<!-- pgdoc-cn_start sig_en=16431b4236cc97989830d7b36f70832f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population variance of the input values (square of the
        population standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的总体方差(总体标准差的平方)。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=16431b4236cc97989830d7b36f70832f -->

<!-- pgdoc-cn_start sig_en=a33713bd15ca6825b2b78cc3cd12ee03 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample variance of the input values (square of the sample
        standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的样本方差(样本标准差的平方)。
       </para></entry>
       <entry>Yes</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a33713bd15ca6825b2b78cc3cd12ee03 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=ec7ebce2f359d43dd70b6ad655b29f6f sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.  Their aggregated input is introduced by
   <literal>ORDER BY</literal>, and they may also take a <firstterm>direct
   argument</firstterm> that is not aggregated, but is computed only once.
   All these functions ignore null values in their aggregated input.
   For those that take a <parameter>fraction</parameter> parameter, the
   fraction value must be between 0 and 1; an error is thrown if not.
   However, a null <parameter>fraction</parameter> value simply produces a
   null result.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-orderedset-table"/>显示了一些使用<firstterm>ordered-set aggregate</firstterm>语法的聚合函数。
   这些函数有时被称为<quote>inverse distribution</quote>函数。
   它们的聚合输入是通过<literal>ORDER BY</literal>引入的，它们还可以接受未聚合的<firstterm>direct argument</firstterm>，但只计算一次。
   所有这些函数在其聚合的输入中都忽略空(null)值。
   对于使用<parameter>fraction(fraction)</parameter>参数的函数，分数值必须在0到1之间;否则将抛出一个错误。但是，空<parameter>分数</parameter>值简单地产生一个空结果。
  </para>
<!-- pgdoc-cn_end sig_en=ec7ebce2f359d43dd70b6ad655b29f6f -->

<!-- pgdoc-cn_start sig_en=f5758c02560dda4f7577345ad754fafd sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>内建</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f5758c02560dda4f7577345ad754fafd -->
<!-- pgdoc-cn_start sig_en=e5743ab9db8838a9bdfefeba3dbf8495 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>逆分布</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=e5743ab9db8838a9bdfefeba3dbf8495 -->

   <table id="functions-orderedset-table">
<!-- pgdoc-cn_start sig_en=bf0beb90f1c86a714f68fba2f35648cc sig_cn_org=None source=14.1 
    <title>Ordered-Set Aggregate Functions</title>
________________________________________________________-->
    <title>有序集聚集函数</title>
<!-- pgdoc-cn_end sig_en=bf0beb90f1c86a714f68fba2f35648cc -->
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=51e6694061f62cbd0db5ed40056d2488 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
<!-- pgdoc-cn_end sig_en=51e6694061f62cbd0db5ed40056d2488 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c5ea775c3189a3b7a9c2a36177c6351d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>mode</firstterm>, the most frequent
        value of the aggregated argument (arbitrarily choosing the first one
        if there are multiple equally-frequent values).  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        计算<firstterm>mode</firstterm>，即聚合参数最频繁的值(如果有多个相同频繁的值，第一个可以任意选择)。聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c5ea775c3189a3b7a9c2a36177c6351d -->

<!-- pgdoc-cn_start sig_en=f218948f8ed737037f11238d47cf6d58 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the <firstterm>continuous percentile</firstterm>, a value
        corresponding to the specified <parameter>fraction</parameter>
        within the ordered set of aggregated argument values.  This will
        interpolate between adjacent input items if needed.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        计算<firstterm>continuous percentile</firstterm>，该值对应于聚合参数值的有序集合中的指定<parameter>分数(fraction)</parameter>。
        如果需要，这将在相邻的输入项之间插入。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f218948f8ed737037f11238d47cf6d58 -->

<!-- pgdoc-cn_start sig_en=d459433f3c1d8ec37a5af701dc45b447 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
        Computes multiple continuous percentiles.  The result is an array of
        the same dimensions as the <parameter>fractions</parameter>
        parameter, with each non-null element replaced by the (possibly
        interpolated) value corresponding to that percentile.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
        计算多个连续的百分位数。结果是一个与<parameter>分数(fractions)</parameter>参数具有相同维数的数组，每个非空元素都被对应于该百分位的(可能插值的)值所替换。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=d459433f3c1d8ec37a5af701dc45b447 -->

<!-- pgdoc-cn_start sig_en=5c3a6ddf123023b0daea9add1a365432 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>discrete percentile</firstterm>, the first
        value within the ordered set of aggregated argument values whose
        position in the ordering equals or exceeds the
        specified <parameter>fraction</parameter>.  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        计算<firstterm>离散百分比(discrete percentile)</firstterm>，即聚合参数值的有序集合中的第一个值，该值在排序中的位置等于或超过指定的<parameter>fraction</parameter>。
        聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=5c3a6ddf123023b0daea9add1a365432 -->

<!-- pgdoc-cn_start sig_en=c2ffea2c14b87fcebc3b15f23ebb69e1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Computes multiple discrete percentiles.  The result is an array of the
        same dimensions as the <parameter>fractions</parameter> parameter,
        with each non-null element replaced by the input value corresponding
        to that percentile.
        The aggregated argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        计算多个离散百分位数。
        结果是一个与<parameter>fractions</parameter>参数具有相同维数的数组，每个非空元素都被对应于该百分位的输入值替换。
        聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c2ffea2c14b87fcebc3b15f23ebb69e1 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=2694954154fdc260fad6c2d78501c9de sig_cn_org=None source=14.1 
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>内建</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2694954154fdc260fad6c2d78501c9de -->

<!-- pgdoc-cn_start sig_en=e5041f72a77eb678d60a3dcf516a4d1e sig_cn_org=None source=14.1 
  <para>
   Each of the <quote>hypothetical-set</quote> aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate's result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows represented by the <replaceable>sorted_args</replaceable>.
   For each of these functions, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
  </para>
________________________________________________________-->
  <para>
   列在<xref linkend="functions-hypothetical-table"/>中的每个<quote>hypothetical-set</quote>聚合都与<xref linkend="functions-window"/>中定义的同名窗口函数相关联。
   在每种情况下，聚合的结果都是相关的窗口函数将为由<replaceable>args</replaceable>构造的<quote>hypothetical</quote>行返回的值，如果将这样的行添加到<replaceable>sorted_args</replaceable>表示的已排序行组中。
   对于这些函数中的每一个，<replaceable>args</replaceable>中给出的直接参数列表必须与<replaceable>sorted_args</replaceable>中给出的聚合参数的数量和类型匹配。
   与大多数内置聚合不同，这些聚合不是严格的，也就是说它们不会删除包含空值的输入行。空值根据<literal>ORDER BY</literal>子句中指定的规则排序。
  </para>
<!-- pgdoc-cn_end sig_en=e5041f72a77eb678d60a3dcf516a4d1e -->

   <table id="functions-hypothetical-table">
<!-- pgdoc-cn_start sig_en=9fa8890fb35b10f71a14527ac18ac20b sig_cn_org=None source=14.1 
    <title>Hypothetical-Set Aggregate Functions</title>
________________________________________________________-->
    <title>假想集聚集函数</title>
<!-- pgdoc-cn_end sig_en=9fa8890fb35b10f71a14527ac18ac20b -->
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=51e6694061f62cbd0db5ed40056d2488 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
<!-- pgdoc-cn_end sig_en=51e6694061f62cbd0db5ed40056d2488 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=6990aae5f217d1837ab851e5db41350d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, with gaps; that is, the row
        number of the first row in its peer group.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算假设行的排名，包括间隔，就是说在它的对等组中第一行的行号。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6990aae5f217d1837ab851e5db41350d -->

<!-- pgdoc-cn_start sig_en=fdc35563b52d3e2eee3ea634bc2a7913 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算假设行的排名，没有间隔；这个功能有效地计数对等组。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=fdc35563b52d3e2eee3ea634bc2a7913 -->

<!-- pgdoc-cn_start sig_en=16574499954346309f55cd75863d16e8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the relative rank of the hypothetical row, that is
        (<function>rank</function> - 1) / (total rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算假设行的相关排行，也就是(<function>rank</function> - 1) / (total rows - 1)。取值范围为 0 到 1（含）。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=16574499954346309f55cd75863d16e8 -->

<!-- pgdoc-cn_start sig_en=16c60f5b8954559925081cb730ba9776 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the cumulative distribution, that is (number of rows
        preceding or peers with hypothetical row) / (total rows).  The value
        thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
       <entry>No</entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算累积分布，也就是(前面或具有假设行的对等行数)/(总行数)。取值范围为 1/<parameter>N</parameter> 到 1。
       </para></entry>
       <entry>No</entry>
      </row>
<!-- pgdoc-cn_end sig_en=16c60f5b8954559925081cb730ba9776 -->
     </tbody>
    </tgroup>
   </table>

  <table id="functions-grouping-table">
<!-- pgdoc-cn_start sig_en=54e45ad85a98f58696a3b3d161b9fd0c sig_cn_org=None source=14.1 
   <title>Grouping Operations</title>
________________________________________________________-->
   <title>分组操作</title>
<!-- pgdoc-cn_end sig_en=54e45ad85a98f58696a3b3d161b9fd0c -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=44e189ecbce4a0589710a8d0092727c0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns a bit mask indicating which <literal>GROUP BY</literal>
        expressions are not included in the current grouping set.
        Bits are assigned with the rightmost argument corresponding to the
        least-significant bit; each bit is 0 if the corresponding expression
        is included in the grouping criteria of the grouping set generating
        the current result row, and 1 if it is not included.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个位掩码以指示哪个<literal>GROUP BY</literal>表达式没有包含在当前分组集中。
        比特位被分配给最右边的参数对应于最低有效位;如果对应的表达式包含在生成当前结果行的分组集的分组条件中，则每个位为0，如果不包含则为1。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=44e189ecbce4a0589710a8d0092727c0 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=c7d3da3f37a201f7fd683f06714150f0 sig_cn_org=None source=14.1 
   <para>
    The grouping operations shown in
    <xref linkend="functions-grouping-table"/> are used in conjunction with
    grouping sets (see <xref linkend="queries-grouping-sets"/>) to distinguish
    result rows.  The arguments to the <literal>GROUPING</literal> function
    are not actually evaluated, but they must exactly match expressions given
    in the <literal>GROUP BY</literal> clause of the associated query level.
    For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
    Here, the <literal>grouping</literal> value <literal>0</literal> in the
    first four rows shows that those have been grouped normally, over both the
    grouping columns.  The value <literal>1</literal> indicates
    that <literal>model</literal> was not grouped by in the next-to-last two
    rows, and the value <literal>3</literal> indicates that
    neither <literal>make</literal> nor <literal>model</literal> was grouped
    by in the last row (which therefore is an aggregate over all the input
    rows).
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-grouping-table"/>所示的分组操作与分组集(参见<xref linkend="queries-grouping-sets"/>)共同使用，以区分结果行。
    <literal>GROUPING</literal>函数的参数实际上并不求值，但它们必须与相关查询级别的<literal>GROUP BY</literal>子句中给出的表达式完全匹配。例如:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
    在这里，前四行中的<literal>grouping</literal>值<literal>0</literal>表明这些已经正常分组，在两个分组列上。
    值<literal>1</literal>表示<literal>model</literal>没有在倒数两行中分组，值<literal>3</literal>表示无论是<literal>make</literal>还是<literal>model</literal>都没有在最后一行中分组(因此，这是所有输入行的聚合)。
   </para>
<!-- pgdoc-cn_end sig_en=c7d3da3f37a201f7fd683f06714150f0 -->

 </sect1>

 <sect1 id="functions-window">
<!-- pgdoc-cn_start sig_en=76ea9c961a8f82e30eea3e8fd99e47b4 sig_cn_org=None source=14.1 
  <title>Window Functions</title>
________________________________________________________-->
  <title>窗口函数</title>
<!-- pgdoc-cn_end sig_en=76ea9c961a8f82e30eea3e8fd99e47b4 -->

<!-- pgdoc-cn_start sig_en=05948078d4d76dd4473866d7f9ff0ebe sig_cn_org=None source=14.1 
  <indexterm zone="functions-window">
   <primary>window function</primary>
   <secondary>built-in</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-window">
   <primary>窗口函数</primary>
   <secondary>内建</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=05948078d4d76dd4473866d7f9ff0ebe -->

<!-- pgdoc-cn_start sig_en=a0e01ff9325a906b13af221b754248bc sig_cn_org=None source=14.1 
  <para>
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
  </para>
________________________________________________________-->
  <para>
   <firstterm>Window functions</firstterm>提供了跨越与当前查询行相关的行集执行计算的能力。
   该特性的介绍请参见<xref linkend="tutorial-window"/>，语法细节请参见<xref linkend="syntax-window-functions"/>。
  </para>
<!-- pgdoc-cn_end sig_en=a0e01ff9325a906b13af221b754248bc -->

<!-- pgdoc-cn_start sig_en=889ea64c264fcf730a5465ef6ecec1f2 sig_cn_org=None source=14.1 
  <para>
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
  </para>
________________________________________________________-->
  <para>
   内置的窗口函数罗列在<xref linkend="functions-window-table"/>中。注意，这些函数<emphasis>必须</emphasis>使用窗口函数语法来调用，也就是说，需要一个<literal>OVER</literal>子句。
  </para>
<!-- pgdoc-cn_end sig_en=889ea64c264fcf730a5465ef6ecec1f2 -->

<!-- pgdoc-cn_start sig_en=327013f319db55c664ed2d50b20f08a5 sig_cn_org=None source=14.1 
  <para>
   In addition to these functions, any built-in or user-defined
   ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as plain aggregates
   and return a single row for the entire set.
  </para>
________________________________________________________-->
  <para>
   除了这些函数之外，任何内置的或用户定义的普通聚合(例如非有序集或假设集聚合)都可以作为窗口函数使用;关于内置聚合的列表，参见<xref linkend="functions-aggregate"/>。
   聚合函数只有在调用之后有一个<literal>OVER</literal>子句时才作为窗口函数;否则，它们充当普通的聚合，并为整个集合返回一行。
  </para>
<!-- pgdoc-cn_end sig_en=327013f319db55c664ed2d50b20f08a5 -->

   <table id="functions-window-table">
<!-- pgdoc-cn_start sig_en=5155d65e5858ac703c2d160365a56c1f sig_cn_org=None source=14.1 
    <title>General-Purpose Window Functions</title>
________________________________________________________-->
    <title>通用窗口函数</title>
<!-- pgdoc-cn_end sig_en=5155d65e5858ac703c2d160365a56c1f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=1ae75ec592b9e839807d1efa229b7f4b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of the current row within its partition, counting
        from 1.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回其分区内的当前行数，从1开始计数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1ae75ec592b9e839807d1efa229b7f4b -->

<!-- pgdoc-cn_start sig_en=2dccd66d4758ece9b0a4c0c5739d0c0a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, with gaps; that is,
        the <function>row_number</function> of the first row in its peer
        group.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回当前行的排名，包含间隔;即对等组中第一行的<function>row_number</function>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2dccd66d4758ece9b0a4c0c5739d0c0a -->

<!-- pgdoc-cn_start sig_en=35e5e8f28db23548b354f1b22ae8af34 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回当前行的排名，不包括间隔;这个功能有效地计数对等组。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=35e5e8f28db23548b354f1b22ae8af34 -->

<!-- pgdoc-cn_start sig_en=01e9b93491e8696a670e5b59a102b790 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the relative rank of the current row, that is
        (<function>rank</function> - 1) / (total partition rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回当前行的相对排名，即(<function>rank</function> - 1) / (总的分区行数 - 1)。因此，该值的范围从0到1(包含在内)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=01e9b93491e8696a670e5b59a102b790 -->

<!-- pgdoc-cn_start sig_en=4cfe99d100f8173fc79af3ba790da5f8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the cumulative distribution, that is (number of partition rows
        preceding or peers with current row) / (total partition rows).
        The value thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回累积分布，也就是(当前行之前或对等的分区行数)/(总的分区行数)。取值范围为1/<parameter>N</parameter> 到 1。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4cfe99d100f8173fc79af3ba790da5f8 -->

<!-- pgdoc-cn_start sig_en=03078bed06919d6e6eb4b5e06844d845 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns an integer ranging from 1 to the argument value, dividing the
        partition as equally as possible.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个从1到参数值的整数，并将分区划分为尽可能相等的值。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=03078bed06919d6e6eb4b5e06844d845 -->

<!-- pgdoc-cn_start sig_en=2287b092a6a86f96325a9228c4ded5e1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows before the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of a type compatible with
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
        返回分区中在当前行之前<parameter>offset</parameter>行的<parameter>value</parameter>;如果没有这样的行，则返回<parameter>default</parameter>(必须与<parameter>value</parameter>相兼容的类型)。
        <parameter>offset</parameter>和<parameter>default</parameter>都是针对当前行求值的。
        如果省略，<parameter>offset</parameter>默认为1，<parameter>default</parameter>为<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2287b092a6a86f96325a9228c4ded5e1 -->

<!-- pgdoc-cn_start sig_en=686a1a0f57cd71f061530ecced0aa88a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows after the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of a type compatible with
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
        返回分区中在当前行之后<parameter>offset</parameter>行的<parameter>value</parameter>；
        如果没有这样的行，则返回<parameter>default</parameter>(必须与<parameter>value</parameter>兼容的类型)。
        <parameter>offset</parameter>和<parameter>default</parameter>都是针对当前行求值的。
        如果省略，<parameter>offset</parameter>默认为1，<parameter>default</parameter>为<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=686a1a0f57cd71f061530ecced0aa88a -->

<!-- pgdoc-cn_start sig_en=78a88868c12a5e5b42c51558d8dfee38 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the first row of the window frame.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的第一行求得的<parameter>value</parameter>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=78a88868c12a5e5b42c51558d8dfee38 -->

<!-- pgdoc-cn_start sig_en=d626633a729591e163f0693f7ab4df9f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the last row of the window frame.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的最后一行求得的<parameter>value</parameter>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d626633a729591e163f0693f7ab4df9f -->

<!-- pgdoc-cn_start sig_en=051ae881283196fd79195d3721f5456d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the <parameter>n</parameter>'th
        row of the window frame (counting from 1);
        returns <literal>NULL</literal> if there is no such row.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的第<parameter>n</parameter>行求得的<parameter>value</parameter>(从1开始计数);如果没有这样的行，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=051ae881283196fd79195d3721f5456d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=77472d76ef0598a90071039eb11aa2e1 sig_cn_org=None source=14.1 
  <para>
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all rows of a peer group.
  </para>
________________________________________________________-->
  <para>
   在<xref linkend="functions-window-table"/>中列出的所有函数都依赖于相关窗口定义的<literal>ORDER BY</literal>子句指定的排序顺序。
   仅考虑<literal>ORDER BY</literal>列时不能区分的行被称为是<firstterm>同等行</firstterm>。
   定义的这四个排名函数（包括 <function>cume_dist</function>），对于对等组的所有行的答案相同。
  </para>
<!-- pgdoc-cn_end sig_en=77472d76ef0598a90071039eb11aa2e1 -->

<!-- pgdoc-cn_start sig_en=cc40dd4ba9bf077729170c37dc2eba8f sig_cn_org=None source=14.1 
  <para>
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
  </para>
________________________________________________________-->
  <para>
   注意<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>只考虑<quote>窗口帧</quote>内的行，它默认情况下包含从分区的开始行直到当前行的最后一个同等行。
   这对<function>last_value</function>可能不会给出有用的结果，有时对<function>nth_value</function>也一样。
   你可以通过向<literal>OVER</literal>子句增加一个合适的帧声明（<literal>RANGE</literal>或<literal>GROUPS</literal>）来重定义帧。
   关于帧声明的更多信息请参考<xref linkend="syntax-window-functions"/>。
  </para>
<!-- pgdoc-cn_end sig_en=cc40dd4ba9bf077729170c37dc2eba8f -->

<!-- pgdoc-cn_start sig_en=ec23cdfa867e59dc82e8bf295576b449 sig_cn_org=None source=14.1 
  <para>
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
  </para>
________________________________________________________-->
  <para>
   当一个聚集函数被用作窗口函数时，它将在当前行的窗口帧内的行上聚集。 
   一个使用<literal>ORDER BY</literal>和默认窗口帧定义的聚集产生一种<quote>运行时求和</quote>类型的行为，这可能是或者不是想要的结果。
   为了获取在整个分区上的聚集，忽略<literal>ORDER BY</literal>或者使用<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>。 
   其它窗口帧声明可以用来获得其它的效果。
  </para>
<!-- pgdoc-cn_end sig_en=ec23cdfa867e59dc82e8bf295576b449 -->

  <note>
<!-- pgdoc-cn_start sig_en=0c84d7e4b3215d2d04887ebcdea27ac4 sig_cn_org=None source=14.1 
   <para>
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
   </para>
________________________________________________________-->
   <para>
    SQL 标准为<function>lead</function>、<function>lag</function>、<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>定义了一个<literal>RESPECT NULLS</literal>或<literal>IGNORE NULLS</literal>选项。 
    这在<productname>PostgreSQL</productname>中没有实现：行为总是与标准的默认相同，即<literal>RESPECT NULLS</literal>。 
    同样，标准中用于<function>nth_value</function>的<literal>FROM FIRST</literal>或<literal>FROM LAST</literal>选项没有实现： 只有支持默认的<literal>FROM FIRST</literal>行为（你可以通过反转<literal>ORDER BY</literal>的排序达到<literal>FROM LAST</literal>的结果）。
   </para>
<!-- pgdoc-cn_end sig_en=0c84d7e4b3215d2d04887ebcdea27ac4 -->
  </note>

 </sect1>

 <sect1 id="functions-subquery">
<!-- pgdoc-cn_start sig_en=27fa3395fddc88741a0de720d601b219 sig_cn_org=None source=14.1 
  <title>Subquery Expressions</title>
________________________________________________________-->
  <title>子查询表达式</title>
<!-- pgdoc-cn_end sig_en=27fa3395fddc88741a0de720d601b219 -->

<!-- pgdoc-cn_start sig_en=42e1e7b13e903a725d100654907bdd4e sig_cn_org=None source=14.1 
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=42e1e7b13e903a725d100654907bdd4e -->

<!-- pgdoc-cn_start sig_en=e112457ec3c0c110bdf4a242708ce495 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>IN</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=e112457ec3c0c110bdf4a242708ce495 -->

<!-- pgdoc-cn_start sig_en=d06509a0a775ad686a405fba14faf4bb sig_cn_org=None source=14.1 
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d06509a0a775ad686a405fba14faf4bb -->

<!-- pgdoc-cn_start sig_en=15ddaaa6b7964ddd2b4fdb0628c6247d sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=15ddaaa6b7964ddd2b4fdb0628c6247d -->

<!-- pgdoc-cn_start sig_en=83d1961d0dbb44e43e41e38229c934a2 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=83d1961d0dbb44e43e41e38229c934a2 -->

<!-- pgdoc-cn_start sig_en=b782584ca300058388ece89102039160 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b782584ca300058388ece89102039160 -->

<!-- pgdoc-cn_start sig_en=c9e8d4ca8828f744894f935ad75e95ac sig_cn_org=None source=14.1 
  <indexterm>
   <primary>subquery</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>subquery</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c9e8d4ca8828f744894f935ad75e95ac -->

<!-- pgdoc-cn_start sig_en=7d05184d398429b479c37afcea1a4689 sig_cn_org=None source=14.1 
  <para>
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
________________________________________________________-->
  <para>
   本节描述<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的子查询表达式。所有本节中成文的表达式都返回布尔值（真/假）结果。
  </para>
<!-- pgdoc-cn_end sig_en=7d05184d398429b479c37afcea1a4689 -->

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<!-- pgdoc-cn_start sig_en=33e077f903cf9e3059e1f563357baeb3 sig_cn_org=None source=14.1 
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=33e077f903cf9e3059e1f563357baeb3 -->

<!-- pgdoc-cn_start sig_en=a0d9550ea03bcc2055f9fb0a42848eef sig_cn_org=None source=14.1 
  <para>
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</command> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</quote>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</quote>.
  </para>
________________________________________________________-->
  <para>
   <token>EXISTS</token>的参数是一个任意的<command>SELECT</command>语句， 或者说<firstterm>子查询</firstterm>。系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么<token>EXISTS</token>的结果就为<quote>真</quote>； 如果子查询没有返回行，那么<token>EXISTS</token>的结果是<quote>假</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=a0d9550ea03bcc2055f9fb0a42848eef -->

<!-- pgdoc-cn_start sig_en=5467fe4c421593a81dd08b686a624874 sig_cn_org=None source=14.1 
  <para>
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
  </para>
________________________________________________________-->
  <para>
   子查询可以引用来自周围的查询的变量，这些变量在该子查询的任何一次计算中都起常量的作用。
  </para>
<!-- pgdoc-cn_end sig_en=5467fe4c421593a81dd08b686a624874 -->

<!-- pgdoc-cn_start sig_en=b870e8e0961941c436882b9bf3f99da6 sig_cn_org=None source=14.1 
  <para>
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
  </para>
________________________________________________________-->
  <para>
   这个子查询通常只是运行到能判断它是否可以返回至少一行为止， 而不是等到全部结束。在这里写任何有副作用的子查询都是不明智的（例如调用序列函数）；这些副作用是否发生是很难判断的。
  </para>
<!-- pgdoc-cn_end sig_en=b870e8e0961941c436882b9bf3f99da6 -->

<!-- pgdoc-cn_start sig_en=2894062d78b9e48b44a98bce04938cc9 sig_cn_org=None source=14.1 
  <para>
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</literal> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
  </para>
________________________________________________________-->
  <para>
   因为结果只取决于是否会返回行，而不取决于这些行的内容， 所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用<literal>EXISTS(SELECT 1 WHERE ...)</literal>的形式写所有的<literal>EXISTS</literal>测试。不过这条规则有例外，例如那些使用<token>INTERSECT</token>的子查询。
  </para>
<!-- pgdoc-cn_end sig_en=2894062d78b9e48b44a98bce04938cc9 -->

<!-- pgdoc-cn_start sig_en=2289ebffdf0e10ea0a07caa5d34aec85 sig_cn_org=None source=14.1 
  <para>
   This simple example is like an inner join on <literal>col2</literal>, but
   it produces at most one output row for each <literal>tab1</literal> row,
   even if there are several matching <literal>tab2</literal> rows:
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
________________________________________________________-->
  <para>
   下面这个简单的例子类似在<literal>col2</literal>上的一次内联接，但是它为每个 <literal>tab1</literal>的行生成最多一个输出，即使存在多个匹配<literal>tab2</literal>的行也如此∶
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=2289ebffdf0e10ea0a07caa5d34aec85 -->
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<!-- pgdoc-cn_start sig_en=b97b8e329ade4588e82c2e24bf373063 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=b97b8e329ade4588e82c2e24bf373063 -->

<!-- pgdoc-cn_start sig_en=6ce52aba41a672f623a9d029ccca35e9 sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
________________________________________________________-->
  <para>
   右手边是一个圆括弧括起来的子查询， 它必须正好只返回一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果找到任何等于子查询行的情况，那么<token>IN</token>的结果就是<quote>真</quote>。 如果没有找到相等行，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>
<!-- pgdoc-cn_end sig_en=6ce52aba41a672f623a9d029ccca35e9 -->

<!-- pgdoc-cn_start sig_en=c10644c57b1f99b5fcb315993188f2ae sig_cn_org=None source=14.1 
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>IN</token>结构的结果将是空值，而不是假。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>
<!-- pgdoc-cn_end sig_en=c10644c57b1f99b5fcb315993188f2ae -->

<!-- pgdoc-cn_start sig_en=890366e2a4e52f6a416380cbb2137a79 sig_cn_org=None source=14.1 
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>
<!-- pgdoc-cn_end sig_en=890366e2a4e52f6a416380cbb2137a79 -->

<!-- pgdoc-cn_start sig_en=46cbb5520e2a950bee3cef387ec09eb0 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=46cbb5520e2a950bee3cef387ec09eb0 -->

<!-- pgdoc-cn_start sig_en=3cfe387faa898d96ff20224034d36287 sig_cn_org=None source=14.1 
  <para>
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
________________________________________________________-->
  <para>
   这种形式的<token>IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到任意相等的子查询行，则<token>IN</token>的结果为<quote>真</quote>。如果没有找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>
<!-- pgdoc-cn_end sig_en=3cfe387faa898d96ff20224034d36287 -->

<!-- pgdoc-cn_start sig_en=d4a20dbd38e213addd99e21c9855fa13 sig_cn_org=None source=14.1 
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
  </para>
________________________________________________________-->
  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>IN</token>的结果是空值。
  </para>
<!-- pgdoc-cn_end sig_en=d4a20dbd38e213addd99e21c9855fa13 -->
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<!-- pgdoc-cn_start sig_en=612f3404200728f023d5005d29568fdb sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=612f3404200728f023d5005d29568fdb -->

<!-- pgdoc-cn_start sig_en=9c8e2289b74562ac1394f5ff7056806c sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
________________________________________________________-->
  <para>
   右手边是一个用圆括弧包围的子查询，它必须返回正好一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果只找到不相等的子查询行（包括子查询不返回行的情况），那么<token>NOT IN</token>的结果是<quote>真</quote>。 如果找到任何相等行，则结果为<quote>假</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=9c8e2289b74562ac1394f5ff7056806c -->

<!-- pgdoc-cn_start sig_en=6bac2fd9b6a986020b448f127df676ca sig_cn_org=None source=14.1 
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>NOT IN</token>结构的结果将是空值，而不是真。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>
<!-- pgdoc-cn_end sig_en=6bac2fd9b6a986020b448f127df676ca -->

<!-- pgdoc-cn_start sig_en=890366e2a4e52f6a416380cbb2137a79 sig_cn_org=None source=14.1 
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>
<!-- pgdoc-cn_end sig_en=890366e2a4e52f6a416380cbb2137a79 -->

<!-- pgdoc-cn_start sig_en=7cf18b9e883eb23f81a4e9300a20b275 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=7cf18b9e883eb23f81a4e9300a20b275 -->

<!-- pgdoc-cn_start sig_en=c07eb57b239a113f7ff400de8949cd32 sig_cn_org=None source=14.1 
  <para>
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
________________________________________________________-->
  <para>
   这种形式的<token>NOT IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到不等于子查询行的行，则<token>NOT IN</token>的结果为<quote>真</quote>。如果找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>
<!-- pgdoc-cn_end sig_en=c07eb57b239a113f7ff400de8949cd32 -->

<!-- pgdoc-cn_start sig_en=01b5819e094ed2b2123510c517f2b771 sig_cn_org=None source=14.1 
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
  </para>
________________________________________________________-->
  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>NOT IN</token>的结果是空值。
  </para>
<!-- pgdoc-cn_end sig_en=01b5819e094ed2b2123510c517f2b771 -->
  </sect2>

  <sect2 id="functions-subquery-any-some">
<!-- pgdoc-cn_start sig_en=fc51157f54b829ab08a374e63774c51a sig_cn_org=None source=14.1 
   <title><literal>ANY</literal>/<literal>SOME</literal></title>
________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal></title>
<!-- pgdoc-cn_end sig_en=fc51157f54b829ab08a374e63774c51a -->

<!-- pgdoc-cn_start sig_en=eed949c068036105c447016ed6afa08f sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=eed949c068036105c447016ed6afa08f -->

<!-- pgdoc-cn_start sig_en=bfc60a7a7c8570701d5bf65adf0b61c1 sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the subquery returns no rows).
  </para>
________________________________________________________-->
  <para>
   这种形式的右手边是一个圆括弧括起来的子查询， 它必须返回正好一个列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果获得任何真值结果，那么<token>ANY</token>的结果就是<quote>真</quote>。 如果没有找到真值结果，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>
<!-- pgdoc-cn_end sig_en=bfc60a7a7c8570701d5bf65adf0b61c1 -->

<!-- pgdoc-cn_start sig_en=561ab2470d80099e235a0bba282bf4f7 sig_cn_org=None source=14.1 
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
  </para>
________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。<token>IN</token>等价于<literal>= ANY</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=561ab2470d80099e235a0bba282bf4f7 -->

<!-- pgdoc-cn_start sig_en=7dd84376392f67f9d5a5d4c9af104b2c sig_cn_org=None source=14.1 
  <para>
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   请注意如果没有任何成功并且至少有一个右手边行为该操作符结果生成空值， 那么<token>ANY</token>结构的结果将是空值，而不是假。 这个行为是遵照 SQL 处理空值布尔组合的一般规则制定的。
  </para>
<!-- pgdoc-cn_end sig_en=7dd84376392f67f9d5a5d4c9af104b2c -->

<!-- pgdoc-cn_start sig_en=890366e2a4e52f6a416380cbb2137a79 sig_cn_org=None source=14.1 
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>
<!-- pgdoc-cn_end sig_en=890366e2a4e52f6a416380cbb2137a79 -->

<!-- pgdoc-cn_start sig_en=ce9c332607cccd55113efe9e90381b7d sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=ce9c332607cccd55113efe9e90381b7d -->

<!-- pgdoc-cn_start sig_en=002922963e56d0303eae30d5a2922b7c sig_cn_org=None source=14.1 
  <para>
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</quote> if the comparison
   returns true for any subquery row.
   The result is <quote>false</quote> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if no comparison with a subquery row returns true,
   and at least one comparison returns NULL.
  </para>
________________________________________________________-->
  <para>
   这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。右手边是一个圆括弧括起来的子查询， 它必须返回和左手边列表给出的表达式一样多的列。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果比较为任何子查询行返回真，则<token>ANY</token>的结果为<quote>真</quote>。如果比较对每一个子查询行都返回假，则结果为<quote>假</quote>（包括子查询不返回行的情况）。如果比较不对任何行返回真并且至少对一行返回 NULL，则结果为 NULL。
  </para>
<!-- pgdoc-cn_end sig_en=002922963e56d0303eae30d5a2922b7c -->

<!-- pgdoc-cn_start sig_en=bf1b6e4186c48bff323e997beee49174 sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
<!-- pgdoc-cn_end sig_en=bf1b6e4186c48bff323e997beee49174 -->
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<!-- pgdoc-cn_start sig_en=928c2bccaf2f31a482d7e83bcb40fd56 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=928c2bccaf2f31a482d7e83bcb40fd56 -->

<!-- pgdoc-cn_start sig_en=73f4463bc6e7b48b494bc9472057a01b sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any false result is found.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
________________________________________________________-->
  <para>
   ALL 的这种形式的右手边是一个圆括弧括起来的子查询， 它必须只返回一列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。该操作符必须生成布尔结果。 如果所有行得到真（包括子查询没有返回任何行的情况），<token>ALL</token>的结果就是<quote>真</quote>。如果没有存在任何假值结果，那么结果是<quote>假</quote>。如果比较为任何行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>
<!-- pgdoc-cn_end sig_en=73f4463bc6e7b48b494bc9472057a01b -->

<!-- pgdoc-cn_start sig_en=494af3d6c6f1743afacf8152b4374c9a sig_cn_org=None source=14.1 
  <para>
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
  </para>
________________________________________________________-->
  <para>
   <token>NOT IN</token>等价于<literal>&lt;&gt; ALL</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=494af3d6c6f1743afacf8152b4374c9a -->

<!-- pgdoc-cn_start sig_en=890366e2a4e52f6a416380cbb2137a79 sig_cn_org=None source=14.1 
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>
<!-- pgdoc-cn_end sig_en=890366e2a4e52f6a416380cbb2137a79 -->

<!-- pgdoc-cn_start sig_en=83b9af8f877612bc021ce01d9dfd9dce sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=83b9af8f877612bc021ce01d9dfd9dce -->

<!-- pgdoc-cn_start sig_en=fce85106839356bef700a97dfe57ab2b sig_cn_org=None source=14.1 
  <para>
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</quote> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</quote> if the comparison returns false for any
   subquery row.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
________________________________________________________-->
  <para>
   <token>ALL</token>的这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，它必须返回和左手边行中表达式一样多的列。 左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果对所有子查询行该比较都返回真，那么<token>ALL</token>的结果就是<quote>真</quote>（包括子查询没有返回任何行的情况）。如果对任何子查询行比较返回假，则结果为<quote>假</quote>。如果比较对任何子查询行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>
<!-- pgdoc-cn_end sig_en=fce85106839356bef700a97dfe57ab2b -->

<!-- pgdoc-cn_start sig_en=bf1b6e4186c48bff323e997beee49174 sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
<!-- pgdoc-cn_end sig_en=bf1b6e4186c48bff323e997beee49174 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=93ea83f2e793c6e1ab9b3b7197be67b0 sig_cn_org=None source=14.1 
   <title>Single-Row Comparison</title>
________________________________________________________-->
   <title>单一行比较</title>
<!-- pgdoc-cn_end sig_en=93ea83f2e793c6e1ab9b3b7197be67b0 -->

<!-- pgdoc-cn_start sig_en=4d3c553bb206327c70ef9bac15003469 sig_cn_org=None source=14.1 
   <indexterm zone="functions-subquery">
    <primary>comparison</primary>
    <secondary>subquery result row</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-subquery">
    <primary>比较</primary>
    <secondary>子查询结果行</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=4d3c553bb206327c70ef9bac15003469 -->

<!-- pgdoc-cn_start sig_en=1a2b8d974b8e215b967b9496c4500921 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=1a2b8d974b8e215b967b9496c4500921 -->

<!-- pgdoc-cn_start sig_en=41f4541f0100ba1894ff0e0f8fcc4527 sig_cn_org=None source=14.1 
  <para>
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
  </para>
________________________________________________________-->
  <para>
   左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，该查询必须返回和左手边行中表达式数目完全一样的列。 另外，该子查询不能返回超过一行的数量（如果它返回零行，那么结果就是空值）。 左手边被计算并逐行与右手边的子查询结果行比较。
  </para>
<!-- pgdoc-cn_end sig_en=41f4541f0100ba1894ff0e0f8fcc4527 -->

<!-- pgdoc-cn_start sig_en=bf1b6e4186c48bff323e997beee49174 sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
<!-- pgdoc-cn_end sig_en=bf1b6e4186c48bff323e997beee49174 -->
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
<!-- pgdoc-cn_start sig_en=d43256f8f132f133f8d2b6146f747b92 sig_cn_org=None source=14.1 
  <title>Row and Array Comparisons</title>
________________________________________________________-->
  <title>行和数组比较</title>
<!-- pgdoc-cn_end sig_en=d43256f8f132f133f8d2b6146f747b92 -->

<!-- pgdoc-cn_start sig_en=e112457ec3c0c110bdf4a242708ce495 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>IN</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=e112457ec3c0c110bdf4a242708ce495 -->

<!-- pgdoc-cn_start sig_en=d06509a0a775ad686a405fba14faf4bb sig_cn_org=None source=14.1 
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d06509a0a775ad686a405fba14faf4bb -->

<!-- pgdoc-cn_start sig_en=15ddaaa6b7964ddd2b4fdb0628c6247d sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=15ddaaa6b7964ddd2b4fdb0628c6247d -->

<!-- pgdoc-cn_start sig_en=83d1961d0dbb44e43e41e38229c934a2 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=83d1961d0dbb44e43e41e38229c934a2 -->

<!-- pgdoc-cn_start sig_en=b782584ca300058388ece89102039160 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b782584ca300058388ece89102039160 -->

<!-- pgdoc-cn_start sig_en=8b10865708413934a8859b01888753ea sig_cn_org=None source=14.1 
  <indexterm>
   <primary>composite type</primary>
   <secondary>comparison</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>组合类型</primary>
   <secondary>比较</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=8b10865708413934a8859b01888753ea -->

<!-- pgdoc-cn_start sig_en=c3ac78b692d4737baf116007e9171ab5 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>row-wise comparison</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>逐行比较</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c3ac78b692d4737baf116007e9171ab5 -->

<!-- pgdoc-cn_start sig_en=c5ac199d342bac2676156b00d05dbfa4 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>comparison</primary>
   <secondary>composite type</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>逐行</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c5ac199d342bac2676156b00d05dbfa4 -->

<!-- pgdoc-cn_start sig_en=42e3bd98c155b8e0fedd92ccf97fcf5b sig_cn_org=None source=14.1 
  <indexterm>
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>行构造器</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=42e3bd98c155b8e0fedd92ccf97fcf5b -->

<!-- pgdoc-cn_start sig_en=80d94d3fddb1dec27bd8e934b9af1d3e sig_cn_org=None source=14.1 
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=80d94d3fddb1dec27bd8e934b9af1d3e -->

<!-- pgdoc-cn_start sig_en=ae91bf504adc59ab01bc7198690ef95e sig_cn_org=None source=14.1 
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ae91bf504adc59ab01bc7198690ef95e -->

<!-- pgdoc-cn_start sig_en=2d8781b7bcc41494cc6f9044fecd1022 sig_cn_org=None source=14.1 
  <para>
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
________________________________________________________-->
  <para>
   本节描述几个特殊的结构，用于在值的组之间进行多重比较。这些形式语法上和前面一节的子查询形式相关，但是不涉及子查询。 这种形式涉及的数组子表达式是<productname>PostgreSQL</productname>的扩展； 其它的是<acronym>SQL</acronym>兼容的。所有本节记录的表达式形式都返回布尔（Boolean）结果（真/假）。
  </para>
<!-- pgdoc-cn_end sig_en=2d8781b7bcc41494cc6f9044fecd1022 -->

  <sect2 id="functions-comparisons-in-scalar">
   <title><literal>IN</literal></title>

<!-- pgdoc-cn_start sig_en=8f018489b5d2bcace5e200afbb566fb5 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!-- pgdoc-cn_end sig_en=8f018489b5d2bcace5e200afbb566fb5 -->

<!-- pgdoc-cn_start sig_en=cc1f323a69ebe0a6dee6c3d1f08ecf73 sig_cn_org=a4d896dc3c7f34e817e95fd44208f77e source=15.7 
  <para>
   The right-hand side is a parenthesized list
   of expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>
________________________________________________________-->
  <para>
   右侧是一个用括号括起来的表达式列表。如果左侧表达式的结果等于右侧任何一个表达式的结果，则结果为<quote>true</quote>。
   这是一个简写表示法，如下所示：

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
或
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
或
...
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=cc1f323a69ebe0a6dee6c3d1f08ecf73 -->

<!-- pgdoc-cn_start sig_en=b7c05049972af55dae8d4f245ea92da3 sig_cn_org=None source=14.1 
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>IN</token>结构的结果将为空值，而不是假。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>
<!-- pgdoc-cn_end sig_en=b7c05049972af55dae8d4f245ea92da3 -->
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<!-- pgdoc-cn_start sig_en=50c8c2572fdbaeaa0eddbd6b01861b47 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!-- pgdoc-cn_end sig_en=50c8c2572fdbaeaa0eddbd6b01861b47 -->

<!-- pgdoc-cn_start sig_en=365d1d8d7020f208690d6310ad2b1f9e sig_cn_org=358a3e8961d097b459b735f4105b2307 source=15.7 
  <para>
   The right-hand side is a parenthesized list
   of expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>
________________________________________________________-->
  <para>
   右侧是一个用括号括起来的表达式列表。如果左侧表达式的结果与所有右侧表达式都不相等，则结果为<quote>true</quote>。
   这是一个简写表示法，用于

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=365d1d8d7020f208690d6310ad2b1f9e -->

<!-- pgdoc-cn_start sig_en=e61a7a50d0c950397afc7bc9ec545d97 sig_cn_org=None source=14.1 
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>NOT IN</token>结构的结果将为空值， 而不是我们可能天真地认为的真值。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>
<!-- pgdoc-cn_end sig_en=e61a7a50d0c950397afc7bc9ec545d97 -->

  <tip>
<!-- pgdoc-cn_start sig_en=60ae761e47ead39b6c571c2cd2d333e4 sig_cn_org=None source=14.1 
  <para>
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
  </para>
________________________________________________________-->
  <para>
   <literal>x NOT IN y</literal>在所有情况下都等效于<literal>NOT (x IN y)</literal>。但是，在处理空值的时候，用<token>NOT IN</token>比用<token>IN</token>更可能迷惑新手。最好尽可能用正逻辑来表达你的条件。
  </para>
<!-- pgdoc-cn_end sig_en=60ae761e47ead39b6c571c2cd2d333e4 -->
  </tip>
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=9041412023c03167dae1c96a280c1e31 sig_cn_org=None source=14.1 
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
<!-- pgdoc-cn_end sig_en=9041412023c03167dae1c96a280c1e31 -->

<!-- pgdoc-cn_start sig_en=b1859b60872caca1cd48bb5665d980a7 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=b1859b60872caca1cd48bb5665d980a7 -->

<!-- pgdoc-cn_start sig_en=4658a6304fca096efb8445ed1f8e9999 sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the array has zero elements).
  </para>
________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式被计算并且使用给出的<replaceable>操作符</replaceable>对数组的每个元素进行比较，这个操作符必须得到布尔结果。如果得到了任何真值结果，那么<token>ANY</token>的结果是<quote>真</quote>。 如果没有找到真值结果（包括数组只有零个元素的情况），那么结果是<quote>假</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=4658a6304fca096efb8445ed1f8e9999 -->

<!-- pgdoc-cn_start sig_en=c449bec7c7f13f462722ea1027935623 sig_cn_org=None source=14.1 
  <para>
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   如果数组表达式得到一个空数组，<token>ANY</token>的结果将为空值。如果左手边的表达式得到空值，<token>ANY</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到真值比较结果，<token>ANY</token>的结果将是空值而不是假（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>
<!-- pgdoc-cn_end sig_en=c449bec7c7f13f462722ea1027935623 -->

<!-- pgdoc-cn_start sig_en=bdd3c035b4d36ed6e65a405f0293a75d sig_cn_org=None source=14.1 
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
  </para>
________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。
  </para>
<!-- pgdoc-cn_end sig_en=bdd3c035b4d36ed6e65a405f0293a75d -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=16d21c0d1fe9fcdb8c5ba5208b8eab00 sig_cn_org=None source=14.1 
   <title><literal>ALL</literal> (array)</title>
________________________________________________________-->
   <title><literal>ALL</literal> (array)</title>
<!-- pgdoc-cn_end sig_en=16d21c0d1fe9fcdb8c5ba5208b8eab00 -->

<!-- pgdoc-cn_start sig_en=79df293c47df49fec69417180a766ba3 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>
<!-- pgdoc-cn_end sig_en=79df293c47df49fec69417180a766ba3 -->

<!-- pgdoc-cn_start sig_en=340cf83bc83174d6a73dab7c103ee5dd sig_cn_org=None source=14.1 
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</quote> if any false result is found.
  </para>
________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>与数组的每个元素进行比较，这个操作符必须得到一个布尔结果。如果所有比较都得到真值结果，那么<token>ALL</token>的结果是 <quote>真</quote>（包括数组只有零个元素的情况）。如果有任何假值结果，那么结果是<quote>假</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=340cf83bc83174d6a73dab7c103ee5dd -->

<!-- pgdoc-cn_start sig_en=e8d414364ee81e6e02edec9dd23a90bf sig_cn_org=None source=14.1 
  <para>
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
________________________________________________________-->
  <para>
   如果数组表达式得到一个空数组，<token>ALL</token>的结果将为空值。如果左手边的表达式得到空值，<token>ALL</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到假值比较结果，<token>ALL</token>的结果将是空值而不是真（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>
<!-- pgdoc-cn_end sig_en=e8d414364ee81e6e02edec9dd23a90bf -->
  </sect2>

  <sect2 id="row-wise-comparison">
<!-- pgdoc-cn_start sig_en=9a7235754aae7366d95509dfb21f77d7 sig_cn_org=None source=14.1 
   <title>Row Constructor Comparison</title>
________________________________________________________-->
   <title>行构造器比较</title>
<!-- pgdoc-cn_end sig_en=9a7235754aae7366d95509dfb21f77d7 -->

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

<!-- pgdoc-cn_start sig_en=e82cf80c0c415e9e00473556b6fa129f sig_cn_org=21f7bbdb839982d70d481cfa30832350 source=15.7 
  <para>
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The two row constructors must have the same number of fields.
   The given <replaceable>operator</replaceable> is applied to each pair
   of corresponding fields.  (Since the fields could be of different
   types, this means that a different specific operator could be selected
   for each pair.)
   All the selected operators must be members of some B-tree operator
   class, or be the negator of an <literal>=</literal> member of a B-tree
   operator class, meaning that row constructor comparison is only
   possible when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal>, or
   <literal>&gt;=</literal>,
   or has semantics similar to one of these.
  </para>
________________________________________________________-->
  <para>
   每一边都是一个行构造器，
   如在<xref linkend="sql-syntax-row-constructors"/>中描述的那样。
   这两个行构造器必须具有相同数量的字段。
   给定的<replaceable>operator</replaceable>应用于每一对
   对应的字段。（由于字段可能是不同类型的，这意味着每对可能选择不同的具体操作符。）
   所有选定的操作符必须是某个B树操作符类的成员，或者是B树操作符类的<literal>=</literal>成员的否定形式，
   这意味着只有当<replaceable>operator</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>或
   <literal>&gt;=</literal>时才可能进行行构造器比较，
   或者具有类似于这些操作符的语义。
</para>
<!-- pgdoc-cn_end sig_en=e82cf80c0c415e9e00473556b6fa129f -->

<!-- pgdoc-cn_start sig_en=4a6dd8db4e39514ad46b1851d6681472 sig_cn_org=None source=14.1 
  <para>
   The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
  </para>
________________________________________________________-->
  <para>
   <literal>=</literal>和<literal>&lt;&gt;</literal>情况略有不同。如果两行的所有对应成员都是非空且相等则这两行被认为相等；如果任何对应成员是非空但是不相等则这两行不相等；否则行比较的结果为未知（空值）。
  </para>
<!-- pgdoc-cn_end sig_en=4a6dd8db4e39514ad46b1851d6681472 -->

<!-- pgdoc-cn_start sig_en=e611a3df752f7476dbe264af65d81852 sig_cn_org=None source=14.1 
  <para>
   For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and
   <literal>&gt;=</literal> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>
   yields true, not null, because the third pair of elements are not
   considered.
  </para>
________________________________________________________-->
  <para>
   对于<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况，行元素被从左至右比较，在找到一处不等的或为空的元素对就立刻停下来。如果这一对元素都为空值，则行比较的结果为未知（空值）；否则这一对元素的比较结果决定行比较的结果。例如，<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>得到真，而不是空值，因为第三对元素并没有被考虑。
  </para>
<!-- pgdoc-cn_end sig_en=e611a3df752f7476dbe264af65d81852 -->

  <note>
<!-- pgdoc-cn_start sig_en=4d86a04d7dff1dbdf4cabfb312ae1392 sig_cn_org=None source=14.1 
   <para>
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;=</literal>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</literal>
    was implemented as
    <literal>a &lt; c AND b &lt; d</literal>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</literal>.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.2之前，<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况不是按照每个 SQL 声明来处理的。一个像<literal>ROW(a,b) &lt; ROW(c,d)</literal>的比较会被实现为<literal>a &lt; c AND b &lt; d</literal>，而结果行为等价于<literal>a &lt; c OR (a = c AND b &lt; d)</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=4d86a04d7dff1dbdf4cabfb312ae1392 -->
  </note>

<!-- pgdoc-cn_start sig_en=2a433823806a8d765e6f689e7adafbe9 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=2a433823806a8d765e6f689e7adafbe9 -->

<!-- pgdoc-cn_start sig_en=a619a004d83da7e9f4a0ed726934e7e3 sig_cn_org=None source=14.1 
  <para>
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
  </para>
________________________________________________________-->
  <para>
   这个结构与<literal>&lt;&gt;</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>
<!-- pgdoc-cn_end sig_en=a619a004d83da7e9f4a0ed726934e7e3 -->

<!-- pgdoc-cn_start sig_en=5b5865495e2cdc9c475e8f01f35d1437 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=5b5865495e2cdc9c475e8f01f35d1437 -->

<!-- pgdoc-cn_start sig_en=e6a5517e363a6cb478e8dc85f750ca40 sig_cn_org=None source=14.1 
  <para>
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
  </para>
________________________________________________________-->
  <para>
   这个结构与<literal>=</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>
<!-- pgdoc-cn_end sig_en=e6a5517e363a6cb478e8dc85f750ca40 -->

  </sect2>

  <sect2 id="composite-type-comparison">
<!-- pgdoc-cn_start sig_en=f99d0040b0492e066b705115d8ced3f2 sig_cn_org=None source=14.1 
   <title>Composite Type Comparison</title>
________________________________________________________-->
   <title>组合类型比较</title>
<!-- pgdoc-cn_end sig_en=f99d0040b0492e066b705115d8ced3f2 -->

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

<!-- pgdoc-cn_start sig_en=495594970004c1381504f6bf0064c3b9 sig_cn_org=None source=14.1 
  <para>
   The SQL specification requires row-wise comparison to return NULL if the
   result depends on comparing two NULL values or a NULL and a non-NULL.
   <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison"/>) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery"/>).
   In other contexts where two composite-type values are compared, two
   NULL field values are considered equal, and a NULL is considered larger
   than a non-NULL.  This is necessary in order to have consistent sorting
   and indexing behavior for composite types.
  </para>
________________________________________________________-->
  <para>
   SQL 规范要求在结果依赖于比较两个 NULL 值或者一个 NULL 与一个非 NULL 时逐行比较返回 NULL。
   <productname>PostgreSQL</productname>只有在比较两个行构造器（如<xref linkend="row-wise-comparison"/>）的结果或者比较一个行构造器与一个子查询的输出时才这样做（如<xref linkend="functions-subquery"/>中所述）。
   在其他比较两个组合类型值的环境中，两个 NULL 域值被认为相等，并且一个 NULL 被认为大于一个非 NULL。
   为了得到组合类型的一致的排序和索引行为，这样做是必要的。
  </para>
<!-- pgdoc-cn_end sig_en=495594970004c1381504f6bf0064c3b9 -->

<!-- pgdoc-cn_start sig_en=d08b6232c9339be3e4093a2c2fbb4093 sig_cn_org=None source=14.1 
  <para>
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</literal> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison"/>).
  </para>
________________________________________________________-->
  <para>
   每一边都会被计算并且它们会被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>或者
   <literal>&gt;=</literal>时或者具有与这些类似的语义时，允许组合类型的比较（更准确地说，如果一个操作符是一个 B 树操作符类的成员，或者是一个 B 树操作符类的<literal>=</literal>成员的否定词，它就可以是一个行比较操作符）。
   上述操作符的行为与用于行构造器（见<xref linkend="row-wise-comparison"/>）的<literal>IS [ NOT ] DISTINCT FROM</literal>相同。
  </para>
<!-- pgdoc-cn_end sig_en=d08b6232c9339be3e4093a2c2fbb4093 -->

<!-- pgdoc-cn_start sig_en=d7e97708063c1019b5dc10a593c9f8ce sig_cn_org=None source=14.1 
  <para>
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</literal>,
   <literal>*&lt;&gt;</literal>,
   <literal>*&lt;</literal>,
   <literal>*&lt;=</literal>,
   <literal>*&gt;</literal>, and
   <literal>*&gt;=</literal>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally
   for materialized views and might be useful for other specialized
   purposes such as replication and B-Tree deduplication (see <xref
   linkend="btree-deduplication"/>).  They are not intended to be
   generally useful for writing queries, though.
  </para>
________________________________________________________-->
  <para>
   为了支持包含无默认 B 树操作符类的元素的行匹配，为组合类型比较定义了下列操作符：
   <literal>*=</literal>、
   <literal>*&lt;&gt;</literal>、
   <literal>*&lt;</literal>、
   <literal>*&lt;=</literal>、
   <literal>*&gt;</literal>以及
   <literal>*&gt;=</literal>。
   这些操作符比较两行的内部二进制表达。即使两行用相等操作符的比较为真，两行也可能具有不同的二进制表达。
   行在这些比较操作符之下的排序是决定性的，其他倒没什么意义。
   这些操作符在内部被用于物化视图并且可能对其他如复制和B-树复制(参见 <xref linkend="btree-deduplication"/>)之类的特殊功能有用，但是它们并不打算用在书写查询这类普通用途中。
  </para>
<!-- pgdoc-cn_end sig_en=d7e97708063c1019b5dc10a593c9f8ce -->
  </sect2>
 </sect1>

 <sect1 id="functions-srf">
<!-- pgdoc-cn_start sig_en=7b9fcd11e19a8218067ac7cee0bf102d sig_cn_org=None source=14.1 
  <title>Set Returning Functions</title>
________________________________________________________-->
  <title>集合返回函数</title>
<!-- pgdoc-cn_end sig_en=7b9fcd11e19a8218067ac7cee0bf102d -->

<!-- pgdoc-cn_start sig_en=d20bb0dfabfbc8f4c2b22eb049829748 sig_cn_org=None source=14.1 
  <indexterm zone="functions-srf">
   <primary>set returning functions</primary>
   <secondary>functions</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="functions-srf">
   <primary>集合返回函数</primary>
   <secondary>函数</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d20bb0dfabfbc8f4c2b22eb049829748 -->

<!-- pgdoc-cn_start sig_en=d983b9235c63a2cbc4543f5338aaaaf8 sig_cn_org=None source=14.1 
  <para>
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"/> and
   <xref linkend="functions-srf-subscripts"/>.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"/> for ways to combine multiple
   set-returning functions.
  </para>
________________________________________________________-->
  <para>
   本节描述那些可能返回多于一行的函数。目前这个类中被使用最广泛的是级数生成函数， 如<xref linkend="functions-srf-series"/>和<xref linkend="functions-srf-subscripts"/>所述。其他更特殊的集合返回函数在本手册的其他地方描述。
   组合多集合返回函数的方法可见<xref linkend="queries-tablefunctions"/>。
  </para>
<!-- pgdoc-cn_end sig_en=d983b9235c63a2cbc4543f5338aaaaf8 -->

   <table id="functions-srf-series">
<!-- pgdoc-cn_start sig_en=d64f2513da7f57c928fb63e565b8a6e0 sig_cn_org=None source=14.1 
    <title>Series Generating Functions</title>
________________________________________________________-->
    <title>系列生成函数</title>
<!-- pgdoc-cn_end sig_en=d64f2513da7f57c928fb63e565b8a6e0 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=bf0331361e57c065ea7aea59d409916d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_series</primary>
        </indexterm>
        <function>generate_series</function> ( <parameter>start</parameter> <type>integer</type>, <parameter>stop</parameter> <type>integer</type> <optional>, <parameter>step</parameter> <type>integer</type> </optional> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>bigint</type>, <parameter>stop</parameter> <type>bigint</type> <optional>, <parameter>step</parameter> <type>bigint</type> </optional> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>numeric</type>, <parameter>stop</parameter> <type>numeric</type> <optional>, <parameter>step</parameter> <type>numeric</type> </optional> )
        <returnvalue>setof numeric</returnvalue>
       </para>
       <para>
        Generates a series of values from <parameter>start</parameter>
        to <parameter>stop</parameter>, with a step size
        of <parameter>step</parameter>.  <parameter>step</parameter>
        defaults to 1.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_series</primary>
        </indexterm>
        <function>generate_series</function> ( <parameter>start</parameter> <type>integer</type>, <parameter>stop</parameter> <type>integer</type> <optional>, <parameter>step</parameter> <type>integer</type> </optional> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>bigint</type>, <parameter>stop</parameter> <type>bigint</type> <optional>, <parameter>step</parameter> <type>bigint</type> </optional> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>numeric</type>, <parameter>stop</parameter> <type>numeric</type> <optional>, <parameter>step</parameter> <type>numeric</type> </optional> )
        <returnvalue>setof numeric</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>到<parameter>stop</parameter>生成一系列的值，步长为<parameter>step</parameter>。 <parameter>step</parameter>默认为1。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bf0331361e57c065ea7aea59d409916d -->

<!-- pgdoc-cn_start sig_en=e2a11c40a16d036f027e8539695222a1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp</type>, <parameter>stop</parameter> <type>timestamp</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp with time zone</type>, <parameter>stop</parameter> <type>timestamp with time zone</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp with time zone</returnvalue>
       </para>
       <para>
        Generates a series of values from <parameter>start</parameter>
        to <parameter>stop</parameter>, with a step size
        of <parameter>step</parameter>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp</type>, <parameter>stop</parameter> <type>timestamp</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp with time zone</type>, <parameter>stop</parameter> <type>timestamp with time zone</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp with time zone</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>到<parameter>stop</parameter>生成一系列的值，步长为<parameter>step</parameter>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e2a11c40a16d036f027e8539695222a1 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=fbbe23430cc7524ec28974a42e6e31c2 sig_cn_org=None source=14.1 
  <para>
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned if any input is <literal>NULL</literal>.
   It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
             1.1
             2.4
             3.7
(3 rows)

-&minus; this example relies on the date-plus-integer operator:
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   当<parameter>step</parameter>为正时，如果<parameter>start</parameter>大于<parameter>stop</parameter>则返回零行。
   相反，当<parameter>step</parameter>为负时，如果<parameter>start</parameter>小于<parameter>stop</parameter>则返回零行。
   如果任何输入为<literal>NULL</literal>也会返回零行。<parameter>step</parameter>为零是一个错误。下面是一些例子：
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- this example relies on the date-plus-integer operator:
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=fbbe23430cc7524ec28974a42e6e31c2 -->

   <table id="functions-srf-subscripts">
<!-- pgdoc-cn_start sig_en=023af69e0c85bf2d8ebca18c353d20bf sig_cn_org=None source=14.1 
    <title>Subscript Generating Functions</title>
________________________________________________________-->
    <title>下标生成函数</title>
<!-- pgdoc-cn_end sig_en=023af69e0c85bf2d8ebca18c353d20bf -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=ca999c209a20e5f9c5a9c9c526d06751 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_subscripts</primary>
        </indexterm>
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Generates a series comprising the valid subscripts of
        the <parameter>dim</parameter>'th dimension of the given array.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_subscripts</primary>
        </indexterm>
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        生成一个包含给定数组第<parameter>dim</parameter>维度的有效下标的序列。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ca999c209a20e5f9c5a9c9c526d06751 -->

<!-- pgdoc-cn_start sig_en=f17685dba746a385511b791a4e5d779d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type>,  <parameter>reverse</parameter> <type>boolean</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Generates a series comprising the valid subscripts of
        the <parameter>dim</parameter>'th dimension of the given array.
        When <parameter>reverse</parameter> is true, returns the series in
        reverse order.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type>,  <parameter>reverse</parameter> <type>boolean</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        生成一个包含给定数组第<parameter>dim</parameter>维度的有效下标的序列。当<parameter>reverse</parameter>为真时，以相反的顺序返回序列。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f17685dba746a385511b791a4e5d779d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=ba1bd72aa6d06d45efd32843052e8bf6 sig_cn_org=None source=14.1 
  <para>
   <function>generate_subscripts</function> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or if any input is <literal>NULL</literal>.
   Some examples follow:
<programlisting>
-&minus; basic usage:
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s
-&minus;-
 1
 2
 3
 4
(4 rows)

-&minus; presenting an array, the subscript and the subscripted
-&minus; value requires a subquery:
SELECT * FROM arrays;
         a
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-&minus; unnest a 2D array:
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2
-&minus;-&minus;-&minus;-&minus;-
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   <function>generate_subscripts</function>是一个快捷函数，它为给定数组的指定维度生成一组合法的下标。
   对于不具有请求维度的数组返回零行，对于任何输入为<literal>NULL</literal>数组也返回零行。下面是一些例子：
<programlisting>
-- basic usage:
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s
---
 1
 2
 3
 4
(4 rows)

-- presenting an array, the subscript and the subscripted
-- value requires a subquery:
SELECT * FROM arrays;
         a
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- unnest a 2D array:
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=ba1bd72aa6d06d45efd32843052e8bf6 -->

<!-- pgdoc-cn_start sig_en=d3acbc2e37d0c0e5bd5c2bdb41539aa9 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d3acbc2e37d0c0e5bd5c2bdb41539aa9 -->

<!-- pgdoc-cn_start sig_en=56790666daf1cb405a02956522279c85 sig_cn_org=None source=14.1 
  <para>
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the function's output column(s), which starts from 1 and
   increments by 1 for each row of the function's output.
   This is most useful in the case of set returning
   functions such as <function>unnest()</function>.

<programlisting>
-&minus; set returning function WITH ORDINALITY:
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   当<literal>FROM</literal>子句中的函数以<literal>WITH ORDINALITY</literal>作为后缀时，将在函数的输出列上附加一个<type>bigint</type>列，该列从1开始，函数输出的每一行加1。
   这在 <function>unnest()</function>等集合返回函数的情况下最有用。

<programlisting>
-- set returning function WITH ORDINALITY:
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=56790666daf1cb405a02956522279c85 -->

 </sect1>

 <sect1 id="functions-info">
<!-- pgdoc-cn_start sig_en=c6a426e850e18c5925a0583b3cde2424 sig_cn_org=None source=14.1 
  <title>System Information Functions and Operators</title>
________________________________________________________-->
  <title>系统信息函数和运算符</title>
<!-- pgdoc-cn_end sig_en=c6a426e850e18c5925a0583b3cde2424 -->

<!-- pgdoc-cn_start sig_en=bf6dc4d92419895cbe46a13bf88c0700 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-info-session-table"/> shows several
   functions that extract session and system information.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-info-session-table"/>展示了多个可以抽取会话和系统信息的函数。
  </para>
<!-- pgdoc-cn_end sig_en=bf6dc4d92419895cbe46a13bf88c0700 -->

<!-- pgdoc-cn_start sig_en=e03dd424871fa8e4a770048c59de2efa sig_cn_org=eb0b343d509d3193e2732156de8e4021 source=15.7 
  <para>
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-functions"/> for more
   information.
  </para>
________________________________________________________-->
  <para>
   除了本节列出的函数外，还有许多与统计系统相关的函数，这些函数也提供系统信息。有关更多信息，请参见<xref linkend="monitoring-stats-functions"/>。
  </para>
<!-- pgdoc-cn_end sig_en=e03dd424871fa8e4a770048c59de2efa -->

   <table id="functions-info-session-table">
<!-- pgdoc-cn_start sig_en=6c12243ac5be8886a7450e20cf4c0442 sig_cn_org=None source=14.1 
    <title>Session Information Functions</title>
________________________________________________________-->
    <title>会话信息函数</title>
<!-- pgdoc-cn_end sig_en=6c12243ac5be8886a7450e20cf4c0442 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=8dbe8b9b9248d6d6e9f7eb3e59d7e2dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_catalog</primary>
        </indexterm>
        <function>current_catalog</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>current_database</primary>
        </indexterm>
        <function>current_database</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the name of the current database.  (Databases are
        called <quote>catalogs</quote> in the SQL standard,
        so <function>current_catalog</function> is the standard's
        spelling.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_catalog</primary>
        </indexterm>
        <function>current_catalog</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>current_database</primary>
        </indexterm>
        <function>current_database</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前数据库的名称。(在SQL标准中数据库被称为<quote>catalogs</quote>，因此<function>current_catalog</function>是该标准的拼写方式。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8dbe8b9b9248d6d6e9f7eb3e59d7e2dc -->

<!-- pgdoc-cn_start sig_en=5f9e61dba5fd3a07f8261f328dfe01cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_query</primary>
        </indexterm>
        <function>current_query</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the text of the currently executing query, as submitted
        by the client (which might contain more than one statement).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_query</primary>
        </indexterm>
        <function>current_query</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回当前所执行查询的文本，由客户端提交的(可能包含一个以上的语句)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5f9e61dba5fd3a07f8261f328dfe01cb -->

<!-- pgdoc-cn_start sig_en=e3cddfbfd2a0a79e172f345562ebfc9c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_role</primary>
        </indexterm>
        <function>current_role</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        This is equivalent to <function>current_user</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_role</primary>
        </indexterm>
        <function>current_role</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        这个等同于 <function>current_user</function>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e3cddfbfd2a0a79e172f345562ebfc9c -->

<!-- pgdoc-cn_start sig_en=a53c4c05a6dfeada631b24a5f2dfe0cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schema</primary>
        </indexterm>
        <indexterm>
         <primary>schema</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schema</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <function>current_schema</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the name of the schema that is first in the search path (or a
        null value if the search path is empty).  This is the schema that will
        be used for any tables or other named objects that are created without
        specifying a target schema.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schema</primary>
        </indexterm>
        <indexterm>
         <primary>schema</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schema</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <function>current_schema</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回在搜索路径中的第一个模式的名称(如果搜索路径为空则返回空值)。
        这个模式将用于没有指定目标模式就创建的任何表或其他已命名对象。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a53c4c05a6dfeada631b24a5f2dfe0cb -->

<!-- pgdoc-cn_start sig_en=d4e338fb663063a8292fc7d5bed0905f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schemas</primary>
        </indexterm>
        <indexterm>
         <primary>search path</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schemas</function> ( <parameter>include_implicit</parameter> <type>boolean</type> )
        <returnvalue>name[]</returnvalue>
       </para>
       <para>
        Returns an array of the names of all schemas presently in the
        effective search path, in their priority order.  (Items in the current
        <xref linkend="guc-search-path"/> setting that do not correspond to
        existing, searchable schemas are omitted.)  If the Boolean argument
        is <literal>true</literal>, then implicitly-searched system schemas
        such as <literal>pg_catalog</literal> are included in the result.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schemas</primary>
        </indexterm>
        <indexterm>
         <primary>search path</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schemas</function> ( <parameter>include_implicit</parameter> <type>boolean</type> )
        <returnvalue>name[]</returnvalue>
       </para>
       <para>
        返回当前在有效搜索路径中的所有模式的名称的数组，以优先级顺序。
        (当前 <xref linkend="guc-search-path"/>设置中与已存在的、可搜索模式不相符的项将被省略。)
        如果布尔参数为<literal>true</literal>，则类似<literal>pg_catalog</literal>的隐式搜索的系统模式将包含在结果中。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4e338fb663063a8292fc7d5bed0905f -->

<!-- pgdoc-cn_start sig_en=e343ce105b792451ec30124062e032c8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_user</primary>
        </indexterm>
        <indexterm>
         <primary>user</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the user name of the current execution context.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_user</primary>
        </indexterm>
        <indexterm>
         <primary>user</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前执行上下文的用户名。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e343ce105b792451ec30124062e032c8 -->

<!-- pgdoc-cn_start sig_en=d5291f0bba92539b66df6ddad8686be8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_addr</primary>
        </indexterm>
        <function>inet_client_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address of the current client,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_addr</primary>
        </indexterm>
        <function>inet_client_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回当前客户端的IP地址，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5291f0bba92539b66df6ddad8686be8 -->

<!-- pgdoc-cn_start sig_en=bc768de37eb4cd9b687a664845b3449e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_port</primary>
        </indexterm>
        <function>inet_client_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the IP port number of the current client,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_port</primary>
        </indexterm>
        <function>inet_client_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回当前客户端的IP端口号，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bc768de37eb4cd9b687a664845b3449e -->

<!-- pgdoc-cn_start sig_en=5273509b3711cb1e544585b1fa8ee84e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_addr</primary>
        </indexterm>
        <function>inet_server_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address on which the server accepted the current
        connection,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_addr</primary>
        </indexterm>
        <function>inet_server_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回服务器接受当前连接的IP地址，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5273509b3711cb1e544585b1fa8ee84e -->

<!-- pgdoc-cn_start sig_en=199618f84ee9d2d3a405b3a3cc6e4953 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_port</primary>
        </indexterm>
        <function>inet_server_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the IP port number on which the server accepted the current
        connection,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_port</primary>
        </indexterm>
        <function>inet_server_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回服务器接受当前连接的IP端口号，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=199618f84ee9d2d3a405b3a3cc6e4953 -->

<!-- pgdoc-cn_start sig_en=827b758e03745b35ca4e30142d39b61f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backend_pid</primary>
        </indexterm>
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of the server process attached to the current
        session.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backend_pid</primary>
        </indexterm>
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回附加到当前会话的服务器进程的进程ID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=827b758e03745b35ca4e30142d39b61f -->

<!-- pgdoc-cn_start sig_en=8799d910a94416f9475c89ba853601bc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_blocking_pids</primary>
        </indexterm>
        <function>pg_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the process ID(s) of the sessions that are
        blocking the server process with the specified process ID from
        acquiring a lock, or an empty array if there is no such server process
        or it is not blocked.
       </para>
       <para>
        One server process blocks another if it either holds a lock that
        conflicts with the blocked process's lock request (hard block), or is
        waiting for a lock that would conflict with the blocked process's lock
        request and is ahead of it in the wait queue (soft block).  When using
        parallel queries the result always lists client-visible process IDs
        (that is, <function>pg_backend_pid</function> results) even if the
        actual lock is held or awaited by a child worker process.  As a result
        of that, there may be duplicated PIDs in the result.  Also note that
        when a prepared transaction holds a conflicting lock, it will be
        represented by a zero process ID.
       </para>
       <para>
        Frequent calls to this function could have some impact on database
        performance, because it needs exclusive access to the lock manager's
        shared state for a short time.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_blocking_pids</primary>
        </indexterm>
        <function>pg_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回阻止服务器进程的会话的进程ID数组，该进程ID与指定的进程ID一起获取锁定，如果没有这样的服务器进程或者没有被阻塞，则返回一个空数组。
       </para>
       <para>
        如果一个服务器进程持有一个与被阻塞进程的锁请求冲突的锁(硬阻塞)，或者正在等待一个与被阻塞进程的锁请求冲突并且在等待队列中位于其前面的锁(软阻塞)，那么这个服务器进程就会阻塞另一个服务器进程。
        当使用并行查询时结果总是列出客户端可见的进程ID(即<function>pg_backend_pid</function>的结果)，即使实际的锁是由子工作进程持有或等待的。
        因此，结果中可能存在重复的pid。还要注意当准备好的事务持有冲突锁时，它将用零进程ID表示。
       </para>
       <para>
        频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要在短时间内独占访问锁管理器的共享状态。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8799d910a94416f9475c89ba853601bc -->

<!-- pgdoc-cn_start sig_en=f5cc804496f5a2a9afd5a3a5d11c4518 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conf_load_time</primary>
        </indexterm>
        <function>pg_conf_load_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the server configuration files were last loaded.
        If the current session was alive at the time, this will be the time
        when the session itself re-read the configuration files (so the
        reading will vary a little in different sessions).  Otherwise it is
        the time when the postmaster process re-read the configuration files.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conf_load_time</primary>
        </indexterm>
        <function>pg_conf_load_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回服务器配置文件最后加载的时间。如果当前会话当时是活跃的，那么这将是会话本身重新读取配置文件的时间(因此在不同的会话中读取会稍有不同)。
        否则，就是postmaster进程重新读取配置文件的时间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f5cc804496f5a2a9afd5a3a5d11c4518 -->

<!-- pgdoc-cn_start sig_en=d260b7bafaa0af92fd0da008e2a6fd0c sig_cn_org=82ff92d37e8c83e750cbb24140430353 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_logfile</primary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
          <primary>current_logfiles</primary>
          <secondary>and the pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>current_logfiles file and the pg_current_logfile
         function</secondary>
        </indexterm>
        <function>pg_current_logfile</function> ( <optional> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the path name of the log file currently in use by the logging
        collector.  The path includes the <xref linkend="guc-log-directory"/>
        directory and the individual log file name.  The result
        is <literal>NULL</literal> if the logging collector is disabled.
        When multiple log files exist, each in a different
        format, <function>pg_current_logfile</function> without an argument
        returns the path of the file having the first format found in the
        ordered list: <literal>stderr</literal>,
        <literal>csvlog</literal>, <literal>jsonlog</literal>.
        <literal>NULL</literal> is returned if no log file has any of these
        formats.
        To request information about a specific log file format, supply
        either <literal>csvlog</literal>, <literal>jsonlog</literal> or
        <literal>stderr</literal> as the
        value of the optional parameter. The result is <literal>NULL</literal>
        if the log format requested is not configured in
        <xref linkend="guc-log-destination"/>.
        The result reflects the contents of
        the <filename>current_logfiles</filename> file.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_logfile</primary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>pg_current_logfile函数</secondary>
        </indexterm>
        <indexterm>
          <primary>current_logfiles</primary>
          <secondary>和pg_current_logfile函数</secondary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>current_logfiles文件和pg_current_logfile函数</secondary>
        </indexterm>
        <function>pg_current_logfile</function> ( <optional> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回当前由日志收集器使用的日志文件的路径名。路径包括<xref linkend="guc-log-directory"/>目录和单独的日志文件名。
        如果日志收集器已禁用，则结果为<literal>NULL</literal>。
        当存在多个日志文件，每个以不同格式存在时，不带参数的<function>pg_current_logfile</function>返回有序列表中找到的第一个格式的文件路径：
        <literal>stderr</literal>，<literal>csvlog</literal>，<literal>jsonlog</literal>。
        如果没有任何日志文件具有这些格式，则返回<literal>NULL</literal>。
        要请求有关特定日志文件格式的信息，请将<literal>csvlog</literal>，<literal>jsonlog</literal>或<literal>stderr</literal>作为可选参数的值。
        如果请求的日志格式未在<xref linkend="guc-log-destination"/>中配置，则结果为<literal>NULL</literal>。
        结果反映<filename>current_logfiles</filename>文件的内容。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d260b7bafaa0af92fd0da008e2a6fd0c -->

<!-- pgdoc-cn_start sig_en=4b63e260fd08f371de9f189329075995 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_my_temp_schema</primary>
        </indexterm>
        <function>pg_my_temp_schema</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the current session's temporary schema, or zero if
        it has none (because it has not created any temporary tables).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_my_temp_schema</primary>
        </indexterm>
        <function>pg_my_temp_schema</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回当前会话的临时模式的OID，如果没有则返回0(因为它没有创建任何临时表)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4b63e260fd08f371de9f189329075995 -->

<!-- pgdoc-cn_start sig_en=4c20a1215b2f0815e360807082cdb4a1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_other_temp_schema</primary>
        </indexterm>
        <function>pg_is_other_temp_schema</function> ( <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if the given OID is the OID of another session's
        temporary schema.  (This can be useful, for example, to exclude other
        sessions' temporary tables from a catalog display.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_other_temp_schema</primary>
        </indexterm>
        <function>pg_is_other_temp_schema</function> ( <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果给定的OID是另一个会话的临时模式的OID则返回真。(这可能是有用的，例如，在目录显示中排除其他会话的临时表。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c20a1215b2f0815e360807082cdb4a1 -->

<!-- pgdoc-cn_start sig_en=97832c306d211669f851ae41c8c5740c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_jit_available</primary>
        </indexterm>
        <function>pg_jit_available</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if a <acronym>JIT</acronym> compiler extension is
        available (see <xref linkend="jit"/>) and the
        <xref linkend="guc-jit"/> configuration parameter is set to
        <literal>on</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_jit_available</primary>
        </indexterm>
        <function>pg_jit_available</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果<acronym>JIT</acronym>编译器扩展可用(参见<xref linkend="jit"/>)，并且<xref linkend="guc-jit"/>配置参数设置为<literal>on</literal>，则返回真。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=97832c306d211669f851ae41c8c5740c -->

<!-- pgdoc-cn_start sig_en=4d0e25df44dbb2ddeeff855a806f838d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_listening_channels</primary>
        </indexterm>
        <function>pg_listening_channels</function> ()
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of names of asynchronous notification channels that
        the current session is listening to.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_listening_channels</primary>
        </indexterm>
        <function>pg_listening_channels</function> ()
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回当前会话正在侦听的异步通知通道的名称集。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4d0e25df44dbb2ddeeff855a806f838d -->

<!-- pgdoc-cn_start sig_en=a0a79da9f135fc7e6a7bb3805acefdad sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_notification_queue_usage</primary>
        </indexterm>
        <function>pg_notification_queue_usage</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the fraction (0&ndash;1) of the asynchronous notification
        queue's maximum size that is currently occupied by notifications that
        are waiting to be processed.
        See <xref linkend="sql-listen"/> and <xref linkend="sql-notify"/>
        for more information.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_notification_queue_usage</primary>
        </indexterm>
        <function>pg_notification_queue_usage</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回当前被等待处理的通知所占用的异步通知队列最大尺寸的分数(0&ndash;1)。更多信息请参见<xref linkend="sql-listen"/> 和 <xref linkend="sql-notify"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a0a79da9f135fc7e6a7bb3805acefdad -->

<!-- pgdoc-cn_start sig_en=51da06d1ee067d2b7ceeb040bd80ae92 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_postmaster_start_time</primary>
        </indexterm>
        <function>pg_postmaster_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the server started.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_postmaster_start_time</primary>
        </indexterm>
        <function>pg_postmaster_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回服务器启动时的时间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=51da06d1ee067d2b7ceeb040bd80ae92 -->

<!-- pgdoc-cn_start sig_en=4109a031fff6a702756767abf6177e69 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_safe_snapshot_blocking_pids</primary>
        </indexterm>
        <function>pg_safe_snapshot_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the process ID(s) of the sessions that are blocking
        the server process with the specified process ID from acquiring a safe
        snapshot, or an empty array if there is no such server process or it
        is not blocked.
       </para>
       <para>
        A session running a <literal>SERIALIZABLE</literal> transaction blocks
        a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal> transaction
        from acquiring a snapshot until the latter determines that it is safe
        to avoid taking any predicate locks.  See
        <xref linkend="xact-serializable"/> for more information about
        serializable and deferrable transactions.
       </para>
       <para>
        Frequent calls to this function could have some impact on database
        performance, because it needs access to the predicate lock manager's
        shared state for a short time.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_safe_snapshot_blocking_pids</primary>
        </indexterm>
        <function>pg_safe_snapshot_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回一个进程ID数组，该进程ID是阻塞服务器进程获取安全快照的会话的进程ID数组，如果没有这样的服务器进程或者没有阻塞，则返回一个空数组。
       </para>
       <para>
        运行<literal>SERIALIZABLE</literal>事务的会话会阻止<literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>事务获取快照，直到后者确定可以安全地避免获取谓词锁。
        关于可序列化和可延迟事务的更多信息，请参见<xref linkend="xact-serializable"/>。
       </para>
       <para>
        频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要在短时间内访问谓词锁管理器的共享状态。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4109a031fff6a702756767abf6177e69 -->

<!-- pgdoc-cn_start sig_en=c90dd95a410d9088a2b44e9860c1b83d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_trigger_depth</primary>
        </indexterm>
        <function>pg_trigger_depth</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the current nesting level
        of <productname>PostgreSQL</productname> triggers (0 if not called,
        directly or indirectly, from inside a trigger).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_trigger_depth</primary>
        </indexterm>
        <function>pg_trigger_depth</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回当前嵌套层次的<productname>PostgreSQL</productname>触发器(如果没有调用则为 0，直接或间接，从一个触发器内部开始)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c90dd95a410d9088a2b44e9860c1b83d -->

<!-- pgdoc-cn_start sig_en=80816f72d4356d4fdfa621f450c5f06a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>session_user</primary>
        </indexterm>
        <function>session_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the session user's name.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>session_user</primary>
        </indexterm>
        <function>session_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回会话用户名.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=80816f72d4356d4fdfa621f450c5f06a -->

<!-- pgdoc-cn_start sig_en=341fafed0a7a353cb94bc66893d43f71 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>user</primary>
        </indexterm>
        <function>user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        This is equivalent to <function>current_user</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>user</primary>
        </indexterm>
        <function>user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        这个相当于 <function>current_user</function>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=341fafed0a7a353cb94bc66893d43f71 -->

<!-- pgdoc-cn_start sig_en=ccc833da241820ed8ba2f3bcc113144e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>version</primary>
        </indexterm>
        <function>version</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a string describing the <productname>PostgreSQL</productname>
        server's version.  You can also get this information from
        <xref linkend="guc-server-version"/>, or for a machine-readable
        version use <xref linkend="guc-server-version-num"/>.  Software
        developers should use <varname>server_version_num</varname> (available
        since 8.2) or <xref linkend="libpq-PQserverVersion"/> instead of
        parsing the text version.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>version</primary>
        </indexterm>
        <function>version</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回描述<productname>PostgreSQL</productname>服务器的版本的字符串。
        你还可以从 <xref linkend="guc-server-version"/>中获得此信息，或者对于机器可读的版本，使用<xref linkend="guc-server-version-num"/>。
        软件开发人员可以使用<varname>server_version_num</varname>(从8.2起可用)或<xref linkend="libpq-PQserverVersion"/>，而不是解析文本版本。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ccc833da241820ed8ba2f3bcc113144e -->
     </tbody>
    </tgroup>
   </table>

   <note>
<!-- pgdoc-cn_start sig_en=fa8a73bde749cfaeff0d8a66c2425ed5 sig_cn_org=None source=14.1 
    <para>
     <function>current_catalog</function>,
     <function>current_role</function>,
     <function>current_schema</function>,
     <function>current_user</function>,
     <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.
    </para>
________________________________________________________-->
    <para>
     <function>current_catalog</function>、<function>current_role</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>和<function>user</function>在<acronym>SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号。
     在 PostgreSQL 中，圆括号可以有选择性地被用于<function>current_schema</function>，但是不能和其他的一起用。
    </para>
<!-- pgdoc-cn_end sig_en=fa8a73bde749cfaeff0d8a66c2425ed5 -->
   </note>

<!-- pgdoc-cn_start sig_en=18ab6ae215f1e06c2c5995ec38ccbf89 sig_cn_org=None source=14.1 
   <para>
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization"/>.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role"/>.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
    <function>current_role</function> and <function>user</function> are
    synonyms for <function>current_user</function>.  (The SQL standard draws
    a distinction between <function>current_role</function>
    and <function>current_user</function>, but <productname>PostgreSQL</productname>
    does not, since it unifies users and roles into a single kind of entity.)
   </para>
________________________________________________________-->
   <para>
    <function>session_user</function>通常是发起当前数据库连接的用户，不过超级用户可以用<xref linkend="sql-set-session-authorization"/>修改这个设置。
    <function>current_user</function>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<xref linkend="sql-set-role"/>改变。
    它也会在函数执行的过程中随着属性<literal>SECURITY DEFINER</literal>的改变而改变。
    在 Unix 的说法里，那么会话用户是<quote>真实用户</quote>，而当前用户是<quote>有效用户</quote>。
    <function>current_role</function>以及<function>user</function>是<function>current_user</function>的同义词（SQL标准在<function>current_role</function>和<function>current_user</function>之间做了区分，但<productname>PostgreSQL</productname>不区分，因为它把用户和角色统一成了一种实体）。
   </para>
<!-- pgdoc-cn_end sig_en=18ab6ae215f1e06c2c5995ec38ccbf89 -->

<!-- pgdoc-cn_start sig_en=3e3e91876681c62926a39d161892d4ee sig_cn_org=None source=14.1 
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3e3e91876681c62926a39d161892d4ee -->

<!-- pgdoc-cn_start sig_en=598e2c8e7c0cf989119cfc140d52f04e sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-info-access-table"/> lists functions that
   allow querying object access privileges programmatically.
   (See <xref linkend="ddl-priv"/> for more information about
   privileges.)
   In these functions, the user whose privileges are being inquired about
   can be specified by name or by OID
   (<structname>pg_authid</structname>.<structfield>oid</structfield>), or if
   the name is given as <literal>public</literal> then the privileges of the
   PUBLIC pseudo-role are checked.  Also, the <parameter>user</parameter>
   argument can be omitted entirely, in which case
   the <function>current_user</function> is assumed.
   The object that is being inquired about can be specified either by name or
   by OID, too.  When specifying by name, a schema name can be included if
   relevant.
   The access privilege of interest is specified by a text string, which must
   evaluate to one of the appropriate privilege keywords for the object's type
   (e.g., <literal>SELECT</literal>).  Optionally, <literal>WITH GRANT
   OPTION</literal> can be added to a privilege type to test whether the
   privilege is held with grant option. Also, multiple privilege types can be
   listed separated by commas, in which case the result will be true if any of
   the listed privileges is held. (Case of the privilege string is not
   significant, and extra whitespace is allowed between but not within
   privilege names.)
   Some examples:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-info-access-table"/>列出那些允许编程查询对象访问权限的函数。参阅<xref linkend="ddl-priv"/>获取更多有关权限的信息。
   在这些函数中，可以通过名称或OID (<structname>pg_authid</structname>.<structfield>oid</structfield>)指定被查询权限的用户，或者如果名称被指定为<literal>public</literal>，则检查PUBLIC伪角色的权限。
   同样，<parameter>user</parameter>参数可以完全省略，在这种情况下，假设为<function>current_user</function>。被查询的对象也可以通过名称或OID来指定。
   通过名称指定时，可以包含相关的模式名称。感兴趣的访问权限由一个文本字符串指定，它必须计算为对象类型的一个适当的权限关键字(例如，<literal>SELECT</literal>)。
   还可以将 <literal>WITH GRANT OPTION</literal>添加到特权类型中，以测试该特权是否由授予选项持有。
   同样，可以用逗号分隔列出多个特权类型，在这种情况下，如果所列出的特权中有任何一个被持有，结果将为真。
   (特权字符串的大小写不重要，特权名之间允许有额外的空格，但在特权名中不允许。)一些例子:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=598e2c8e7c0cf989119cfc140d52f04e -->

   <table id="functions-info-access-table">
<!-- pgdoc-cn_start sig_en=9e5d990436ab46a1e1606712d5a4482f sig_cn_org=None source=14.1 
    <title>Access Privilege Inquiry Functions</title>
________________________________________________________-->
    <title>访问权限查询函数</title>
<!-- pgdoc-cn_end sig_en=9e5d990436ab46a1e1606712d5a4482f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=9643e2bf638e88b1759852b4ea045167 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_any_column_privilege</primary>
        </indexterm>
        <function>has_any_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for any column of table?
        This succeeds either if the privilege is held for the whole table, or
        if there is a column-level grant of the privilege for at least one
        column.
        Allowable privilege types are
        <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, and <literal>REFERENCES</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_any_column_privilege</primary>
        </indexterm>
        <function>has_any_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否对表的任何列有权限?
        如果对整个表持有特权，或者对至少一个列有列级的特权授予，则会成功。
        允许的权限类型为<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, 和 <literal>REFERENCES</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9643e2bf638e88b1759852b4ea045167 -->

<!-- pgdoc-cn_start sig_en=50bf303ca9607b6b7c311dc2f440929f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_column_privilege</primary>
        </indexterm>
        <function>has_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>column</parameter> <type>text</type> or <type>smallint</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for the specified table column?
        This succeeds either if the privilege is held for the whole table, or
        if there is a column-level grant of the privilege for the column.
        The column can be specified by name or by attribute number
        (<structname>pg_attribute</structname>.<structfield>attnum</structfield>).
        Allowable privilege types are
        <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, and <literal>REFERENCES</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_column_privilege</primary>
        </indexterm>
        <function>has_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>column</parameter> <type>text</type> or <type>smallint</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对指定的表列有特权么?如果对整个表持有特权，或者对列授予了列级别的特权，则会成功。
        可以通过名称或属性编号(<structname>pg_attribute</structname>.<structfield>attnum</structfield>)指定列。
        允许的特权类型为<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, 和 <literal>REFERENCES</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=50bf303ca9607b6b7c311dc2f440929f -->

<!-- pgdoc-cn_start sig_en=9430fe1b0aa01ac8570dcd86a44070e3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_database_privilege</primary>
        </indexterm>
        <function>has_database_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>database</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for database?
        Allowable privilege types are
        <literal>CREATE</literal>,
        <literal>CONNECT</literal>,
        <literal>TEMPORARY</literal>, and
        <literal>TEMP</literal> (which is equivalent to
        <literal>TEMPORARY</literal>).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_database_privilege</primary>
        </indexterm>
        <function>has_database_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>database</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对数据库有特权吗?允许的特权类型为<literal>CREATE</literal>,<literal>CONNECT</literal>,<literal>TEMPORARY</literal>, 和<literal>TEMP</literal> (相当于 <literal>TEMPORARY</literal>)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9430fe1b0aa01ac8570dcd86a44070e3 -->

<!-- pgdoc-cn_start sig_en=2f64ed382f15cd454bf245987388ede4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_foreign_data_wrapper_privilege</primary>
        </indexterm>
        <function>has_foreign_data_wrapper_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>fdw</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for foreign-data wrapper?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_foreign_data_wrapper_privilege</primary>
        </indexterm>
        <function>has_foreign_data_wrapper_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>fdw</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否拥有外部数据包装的特权?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2f64ed382f15cd454bf245987388ede4 -->

<!-- pgdoc-cn_start sig_en=064ed96f7fa5d1a93ca7022d72b9cbdd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_function_privilege</primary>
        </indexterm>
        <function>has_function_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>function</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for function?
        The only allowable privilege type is <literal>EXECUTE</literal>.
       </para>
       <para>
        When specifying a function by name rather than by OID, the allowed
        input is the same as for the <type>regprocedure</type> data type (see
        <xref linkend="datatype-oid"/>).
        An example is:
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_function_privilege</primary>
        </indexterm>
        <function>has_function_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>function</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对函数有特权吗?唯一允许的特权类型是<literal>EXECUTE</literal>。
       </para>
       <para>
        当通过名称而不是OID指定函数时，允许的输入与<type>regprocedure</type>数据类型相同(参见<xref linkend="datatype-oid"/>)。一个例子为：
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=064ed96f7fa5d1a93ca7022d72b9cbdd -->

<!-- pgdoc-cn_start sig_en=c7828d9e46f146b71ebab181a8c9853a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_language_privilege</primary>
        </indexterm>
        <function>has_language_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>language</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for language?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_language_privilege</primary>
        </indexterm>
        <function>has_language_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>language</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对语言有特权吗?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c7828d9e46f146b71ebab181a8c9853a -->

<!-- pgdoc-cn_start sig_en=9102ad033d5a7cfb82b54607016e01c6 sig_cn_org=1736f985d541f0ab455f69a300ccd2da source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_parameter_privilege</primary>
        </indexterm>
        <function>has_parameter_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>parameter</parameter> <type>text</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for configuration parameter?
        The parameter name is case-insensitive.
        Allowable privilege types are <literal>SET</literal>
        and <literal>ALTER SYSTEM</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_parameter_privilege</primary>
        </indexterm>
        <function>has_parameter_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>parameter</parameter> <type>text</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否具有配置参数的权限？
        参数名称不区分大小写。
        允许的权限类型为<literal>SET</literal>和<literal>ALTER SYSTEM</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9102ad033d5a7cfb82b54607016e01c6 -->

<!-- pgdoc-cn_start sig_en=b0940ec0a85c037e0240a01749d8058b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_schema_privilege</primary>
        </indexterm>
        <function>has_schema_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>schema</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for schema?
        Allowable privilege types are
        <literal>CREATE</literal> and
        <literal>USAGE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_schema_privilege</primary>
        </indexterm>
        <function>has_schema_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>schema</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对模式有特权吗?允许的特权类型是<literal>CREATE</literal> 和<literal>USAGE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b0940ec0a85c037e0240a01749d8058b -->

<!-- pgdoc-cn_start sig_en=eb5073fa20a3aa2f748110338d18b563 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_sequence_privilege</primary>
        </indexterm>
        <function>has_sequence_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>sequence</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for sequence?
        Allowable privilege types are
        <literal>USAGE</literal>,
        <literal>SELECT</literal>, and
        <literal>UPDATE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_sequence_privilege</primary>
        </indexterm>
        <function>has_sequence_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>sequence</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否有顺序特权?允许的特权类型有<literal>USAGE</literal>, <literal>SELECT</literal>, 和<literal>UPDATE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eb5073fa20a3aa2f748110338d18b563 -->

<!-- pgdoc-cn_start sig_en=c224d11ff2a64d4de31bc1af4e703b4e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_server_privilege</primary>
        </indexterm>
        <function>has_server_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>server</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for foreign server?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_server_privilege</primary>
        </indexterm>
        <function>has_server_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>server</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否对外部服务器有特权?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c224d11ff2a64d4de31bc1af4e703b4e -->

<!-- pgdoc-cn_start sig_en=e1a8e6724ad55bd469cb30e75d0f19c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_table_privilege</primary>
        </indexterm>
        <function>has_table_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for table?
        Allowable privilege types
        are <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, <literal>DELETE</literal>,
        <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>,
        and <literal>TRIGGER</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_table_privilege</primary>
        </indexterm>
        <function>has_table_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对表有特权吗?允许的特权类型有<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, <literal>DELETE</literal>,<literal>TRUNCATE</literal>, <literal>REFERENCES</literal>,和 <literal>TRIGGER</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e1a8e6724ad55bd469cb30e75d0f19c1 -->

<!-- pgdoc-cn_start sig_en=9a223ac446a1f643b918403458ac4525 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_tablespace_privilege</primary>
        </indexterm>
        <function>has_tablespace_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>tablespace</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for tablespace?
        The only allowable privilege type is <literal>CREATE</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_tablespace_privilege</primary>
        </indexterm>
        <function>has_tablespace_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>tablespace</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对表空间有特权吗?唯一允许的特权类型是<literal>CREATE</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9a223ac446a1f643b918403458ac4525 -->

<!-- pgdoc-cn_start sig_en=f4bdcf8196b7d549fe27791ab8db14aa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_type_privilege</primary>
        </indexterm>
        <function>has_type_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>type</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for data type?
        The only allowable privilege type is <literal>USAGE</literal>.
        When specifying a type by name rather than by OID, the allowed input
        is the same as for the <type>regtype</type> data type (see
        <xref linkend="datatype-oid"/>).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_type_privilege</primary>
        </indexterm>
        <function>has_type_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>type</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对数据类型有特权吗?唯一允许的特权类型是 <literal>USAGE</literal>。
        当通过名称而不是OID指定类型时，允许的输入与<type>regtype</type>数据类型相同(参见<xref linkend="datatype-oid"/>)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f4bdcf8196b7d549fe27791ab8db14aa -->

<!-- pgdoc-cn_start sig_en=25992e5c5c6fe24964b98702cb4566b8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_has_role</primary>
        </indexterm>
        <function>pg_has_role</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>role</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for role?
        Allowable privilege types are
        <literal>MEMBER</literal> and <literal>USAGE</literal>.
        <literal>MEMBER</literal> denotes direct or indirect membership in
        the role (that is, the right to do <command>SET ROLE</command>), while
        <literal>USAGE</literal> denotes whether the privileges of the role
        are immediately available without doing <command>SET ROLE</command>.
        This function does not allow the special case of
        setting <parameter>user</parameter> to <literal>public</literal>,
        because the PUBLIC pseudo-role can never be a member of real roles.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_has_role</primary>
        </indexterm>
        <function>pg_has_role</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>role</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对角色有特权么?允许的特权类型是<literal>MEMBER</literal> 和 <literal>USAGE</literal>。
        <literal>MEMBER</literal>表示角色中的直接或间接成员关系(即执行<command>SET ROLE</command>的权利)，而<literal>USAGE</literal>表示不执行<command>SET ROLE</command>情况下是否立即可用角色的特权。
        此函数不允许特殊情况下将<parameter>user</parameter>设置为<literal>public</literal>，因为PUBLIC伪角色永远不能成为真实角色的成员。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=25992e5c5c6fe24964b98702cb4566b8 -->

<!-- pgdoc-cn_start sig_en=3d2f878c11aec8a9b796411573c4b7e8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_security_active</primary>
        </indexterm>
        <function>row_security_active</function> (
          <parameter>table</parameter> <type>text</type> or <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is row-level security active for the specified table in the context of
        the current user and current environment?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_security_active</primary>
        </indexterm>
        <function>row_security_active</function> (
          <parameter>table</parameter> <type>text</type> or <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        在当前用户和当前环境的上下文之中，指定表的行级安全是活动的吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3d2f878c11aec8a9b796411573c4b7e8 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=ae459a07e6f8528cf969fa947d796a88 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-aclitem-op-table"/> shows the operators
   available for the <type>aclitem</type> type, which is the catalog
   representation of access privileges.  See <xref linkend="ddl-priv"/>
   for information about how to read access privilege values.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-aclitem-op-table"/> 显示了<type>aclitem</type>类型的可用操作符，它是访问权限的目录表示。 
   有关如何读取访问权限值的信息，请参阅 <xref linkend="ddl-priv"/>。
  </para>
<!-- pgdoc-cn_end sig_en=ae459a07e6f8528cf969fa947d796a88 -->

    <table id="functions-aclitem-op-table">
<!-- pgdoc-cn_start sig_en=8378c0231d128d1cde7f74b07d210a3a sig_cn_org=None source=14.1 
     <title><type>aclitem</type> Operators</title>
________________________________________________________-->
     <title><type>aclitem</type> 操作符</title>
<!-- pgdoc-cn_end sig_en=8378c0231d128d1cde7f74b07d210a3a -->
     <tgroup cols="1">
      <thead>
<!-- pgdoc-cn_start sig_en=656006cda31d1fe93de4c2121ac304f8 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=656006cda31d1fe93de4c2121ac304f8 -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=c08d035b6c850c69889f470a4e63f462 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclitemeq</primary>
         </indexterm>
         <type>aclitem</type> <literal>=</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Are <type>aclitem</type>s equal?  (Notice that
         type <type>aclitem</type> lacks the usual set of comparison
         operators; it has only equality.  In turn, <type>aclitem</type>
         arrays can only be compared for equality.)
        </para>
        <para>
         <literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal>
         <returnvalue>f</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclitemeq</primary>
         </indexterm>
         <type>aclitem</type> <literal>=</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         <type>aclitem</type>相等吗?(注意，<type>aclitem</type>类型缺少比较操作符的通常集合;它只有相等。
         反而言之，<type>aclitem</type>数组只能进行相等比较。)
        </para>
        <para>
         <literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal>
         <returnvalue>f</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=c08d035b6c850c69889f470a4e63f462 -->

<!-- pgdoc-cn_start sig_en=b09c38a69f61ee083629763e4f761221 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclcontains</primary>
         </indexterm>
         <type>aclitem[]</type> <literal>@&gt;</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Does array contain the specified privileges?  (This is true if there
         is an array entry that matches the <type>aclitem</type>'s grantee and
         grantor, and has at least the specified set of privileges.)
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclcontains</primary>
         </indexterm>
         <type>aclitem[]</type> <literal>@&gt;</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         数组是否包含指定的特权?(如果有一个数组条目与<type>aclitem</type>的被授权人和授予人相匹配，并且至少具有特权的指定集，则此选项为真。)
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=b09c38a69f61ee083629763e4f761221 -->

<!-- pgdoc-cn_start sig_en=4025924d06d769528269018056fc2df2 sig_cn_org=None source=14.1 
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>aclitem[]</type> <literal>~</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         This is a deprecated alias for <literal>@&gt;</literal>.
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>aclitem[]</type> <literal>~</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         这是<literal>@&gt;</literal>的已弃用别名。
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
<!-- pgdoc-cn_end sig_en=4025924d06d769528269018056fc2df2 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=9b00377677e4c3792e35a57c7459d7bc sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-aclitem-fn-table"/> shows some additional
    functions to manage the <type>aclitem</type> type.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-aclitem-fn-table"/> 显示了一些额外的函数来管理<type>aclitem</type>类型。
   </para>
<!-- pgdoc-cn_end sig_en=9b00377677e4c3792e35a57c7459d7bc -->

   <table id="functions-aclitem-fn-table">
<!-- pgdoc-cn_start sig_en=5124c97e9f17a99f4640464d86d8f7d0 sig_cn_org=None source=14.1 
    <title><type>aclitem</type> Functions</title>
________________________________________________________-->
    <title><type>aclitem</type> 函数</title>
<!-- pgdoc-cn_end sig_en=5124c97e9f17a99f4640464d86d8f7d0 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=83f4607dc601577e5054368c7da6e9cf sig_cn_org=2b65bba831b71448bc14d2ad8406977d source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acldefault</primary>
        </indexterm>
        <function>acldefault</function> (
          <parameter>type</parameter> <type>"char"</type>,
          <parameter>ownerId</parameter> <type>oid</type> )
        <returnvalue>aclitem[]</returnvalue>
       </para>
       <para>
        Constructs an <type>aclitem</type> array holding the default access
        privileges for an object of type <parameter>type</parameter> belonging
        to the role with OID <parameter>ownerId</parameter>.  This represents
        the access privileges that will be assumed when an object's ACL entry
        is null.  (The default access privileges are described in
        <xref linkend="ddl-priv"/>.)
        The <parameter>type</parameter> parameter must be one of
        'c' for <literal>COLUMN</literal>,
        'r' for <literal>TABLE</literal> and table-like objects,
        's' for <literal>SEQUENCE</literal>,
        'd' for <literal>DATABASE</literal>,
        'f' for <literal>FUNCTION</literal> or <literal>PROCEDURE</literal>,
        'l' for <literal>LANGUAGE</literal>,
        'L' for <literal>LARGE OBJECT</literal>,
        'n' for <literal>SCHEMA</literal>,
        'p' for <literal>PARAMETER</literal>,
        't' for <literal>TABLESPACE</literal>,
        'F' for <literal>FOREIGN DATA WRAPPER</literal>,
        'S' for <literal>FOREIGN SERVER</literal>,
        or
        'T' for <literal>TYPE</literal> or <literal>DOMAIN</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acldefault</primary>
        </indexterm>
        <function>acldefault</function> (
          <parameter>type</parameter> <type>"char"</type>,
          <parameter>ownerId</parameter> <type>oid</type> )
        <returnvalue>aclitem[]</returnvalue>
       </para>
       <para>
        构造一个<type>aclitem</type>数组，保存属于具有OID <parameter>ownerId</parameter>的角色的对象类型<parameter>type</parameter>的默认访问权限。
        这表示当对象的ACL条目为空时将假定的访问权限。(默认访问权限在<xref linkend="ddl-priv"/>中描述。)
        <parameter>type</parameter>参数必须是以下之一：
        'c'表示<literal>COLUMN</literal>,
        'r'表示<literal>TABLE</literal>和类似表的对象，
        's'表示<literal>SEQUENCE</literal>,
        'd'表示<literal>DATABASE</literal>,
        'f'表示<literal>FUNCTION</literal>或<literal>PROCEDURE</literal>,
        'l'表示<literal>LANGUAGE</literal>,
        'L'表示<literal>LARGE OBJECT</literal>,
        'n'表示<literal>SCHEMA</literal>,
        'p'表示<literal>PARAMETER</literal>,
        't'表示<literal>TABLESPACE</literal>,
        'F'表示<literal>FOREIGN DATA WRAPPER</literal>,
        'S'表示<literal>FOREIGN SERVER</literal>,
        或
        'T'表示<literal>TYPE</literal>或<literal>DOMAIN</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=83f4607dc601577e5054368c7da6e9cf -->

<!-- pgdoc-cn_start sig_en=91655c37e391d9fb82581fafba9c5b6c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>aclexplode</primary>
        </indexterm>
        <function>aclexplode</function> ( <type>aclitem[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>grantor</parameter> <type>oid</type>,
        <parameter>grantee</parameter> <type>oid</type>,
        <parameter>privilege_type</parameter> <type>text</type>,
        <parameter>is_grantable</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns the <type>aclitem</type> array as a set of rows.
        If the grantee is the pseudo-role PUBLIC, it is represented by zero in
        the <parameter>grantee</parameter> column.  Each granted privilege is
        represented as <literal>SELECT</literal>, <literal>INSERT</literal>,
        etc.  Note that each privilege is broken out as a separate row, so
        only one keyword appears in the <parameter>privilege_type</parameter>
        column.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>aclexplode</primary>
        </indexterm>
        <function>aclexplode</function> ( <type>aclitem[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>grantor</parameter> <type>oid</type>,
        <parameter>grantee</parameter> <type>oid</type>,
        <parameter>privilege_type</parameter> <type>text</type>,
        <parameter>is_grantable</parameter> <type>boolean</type> )
       </para>
       <para>
        以行集的形式返回<type>aclitem</type>数组。如果受让人是伪角色PUBLIC，则在<parameter>grantee</parameter>列中用0表示。
        每个被授予的特权都表示为<literal>SELECT</literal>, <literal>INSERT</literal>等。
        注意，每个特权被分割成单独的一行，因此在<parameter>privilege_type</parameter>列中只出现一个关键字。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=91655c37e391d9fb82581fafba9c5b6c -->

<!-- pgdoc-cn_start sig_en=91f34cb9ff06dfcaf1b569ab781455fc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>makeaclitem</primary>
        </indexterm>
        <function>makeaclitem</function> (
          <parameter>grantee</parameter> <type>oid</type>,
          <parameter>grantor</parameter> <type>oid</type>,
          <parameter>privileges</parameter> <type>text</type>,
          <parameter>is_grantable</parameter> <type>boolean</type> )
        <returnvalue>aclitem</returnvalue>
       </para>
       <para>
        Constructs an <type>aclitem</type> with the given properties.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>makeaclitem</primary>
        </indexterm>
        <function>makeaclitem</function> (
          <parameter>grantee</parameter> <type>oid</type>,
          <parameter>grantor</parameter> <type>oid</type>,
          <parameter>privileges</parameter> <type>text</type>,
          <parameter>is_grantable</parameter> <type>boolean</type> )
        <returnvalue>aclitem</returnvalue>
       </para>
       <para>
        使用给定的属性构造 <type>aclitem</type> 。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=91f34cb9ff06dfcaf1b569ab781455fc -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=a478ad07880075e8d9b3e5c6435f22ee sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-info-schema-table"/> shows functions that
   determine whether a certain object is <firstterm>visible</firstterm> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  Thus, to list the names of all visible tables:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
   For functions and operators, an object in the search path is said to be
   visible if there is no object of the same name <emphasis>and argument data
   type(s)</emphasis> earlier in the path.  For operator classes and families,
   both the name and the associated index access method are considered.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-info-schema-table"/>展示了决定是否一个特定对象在当前模式搜索路径中<firstterm>可见</firstterm>的函数。
   例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。
   这等价于在语句中表可以被用名称引用但不加显式的模式限定。因此，要列出所有可见表的名字：
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
   对于函数和操作符，如果路径前面没有相同名称<emphasis>and argument data type(s)</emphasis>的对象，那么搜索路径中的对象就是可见的。
   对于操作符类和操作符族，要考虑名称和关联的索引访问方法。
  </para>
<!-- pgdoc-cn_end sig_en=a478ad07880075e8d9b3e5c6435f22ee -->

<!-- pgdoc-cn_start sig_en=589cc78a344924f7d76276294551305f sig_cn_org=None source=14.1 
   <indexterm>
    <primary>search path</primary>
    <secondary>object visibility</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>搜索路径</primary>
    <secondary>对象可见性</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=589cc78a344924f7d76276294551305f -->

   <table id="functions-info-schema-table">
<!-- pgdoc-cn_start sig_en=9e71029f226204e53f1cc577a394712f sig_cn_org=None source=14.1 
    <title>Schema Visibility Inquiry Functions</title>
________________________________________________________-->
    <title>模式可见性查询函数</title>
<!-- pgdoc-cn_end sig_en=9e71029f226204e53f1cc577a394712f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=b22f79ff89508ad4959a9c5fb4bba146 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_is_visible</primary>
        </indexterm>
        <function>pg_collation_is_visible</function> ( <parameter>collation</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is collation visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_is_visible</primary>
        </indexterm>
        <function>pg_collation_is_visible</function> ( <parameter>collation</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        排序规则在搜索路径中可见吗？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b22f79ff89508ad4959a9c5fb4bba146 -->

<!-- pgdoc-cn_start sig_en=3bfad5eceacca57f5250b666f592d516 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conversion_is_visible</primary>
        </indexterm>
        <function>pg_conversion_is_visible</function> ( <parameter>conversion</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is conversion visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conversion_is_visible</primary>
        </indexterm>
        <function>pg_conversion_is_visible</function> ( <parameter>conversion</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        转换在搜索路径中可见吗？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3bfad5eceacca57f5250b666f592d516 -->

<!-- pgdoc-cn_start sig_en=b46dd6f49de6e77214717b9a93bf5970 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_function_is_visible</primary>
        </indexterm>
        <function>pg_function_is_visible</function> ( <parameter>function</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is function visible in search path?
        (This also works for procedures and aggregates.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_function_is_visible</primary>
        </indexterm>
        <function>pg_function_is_visible</function> ( <parameter>function</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        函数在搜索路径中可见吗？(这也适用于过程和聚合。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b46dd6f49de6e77214717b9a93bf5970 -->

<!-- pgdoc-cn_start sig_en=437e427514e7f7fe92b3b25165a1522b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opclass_is_visible</primary>
        </indexterm>
        <function>pg_opclass_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator class visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opclass_is_visible</primary>
        </indexterm>
        <function>pg_opclass_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符类在搜索路径中可见吗？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=437e427514e7f7fe92b3b25165a1522b -->

<!-- pgdoc-cn_start sig_en=ae7921a0d727e21fe0b8d6cad47e1354 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_operator_is_visible</primary>
        </indexterm>
        <function>pg_operator_is_visible</function> ( <parameter>operator</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_operator_is_visible</primary>
        </indexterm>
        <function>pg_operator_is_visible</function> ( <parameter>operator</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符在搜索路径中可见吗？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ae7921a0d727e21fe0b8d6cad47e1354 -->

<!-- pgdoc-cn_start sig_en=9ebf5da2f068f83656861719a6b91c1e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opfamily_is_visible</primary>
        </indexterm>
        <function>pg_opfamily_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator family visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opfamily_is_visible</primary>
        </indexterm>
        <function>pg_opfamily_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符族在搜索路径中可见吗？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9ebf5da2f068f83656861719a6b91c1e -->

<!-- pgdoc-cn_start sig_en=b5dc09f466075c099a047d5fe334abcd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_statistics_obj_is_visible</primary>
        </indexterm>
        <function>pg_statistics_obj_is_visible</function> ( <parameter>stat</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is statistics object visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_statistics_obj_is_visible</primary>
        </indexterm>
        <function>pg_statistics_obj_is_visible</function> ( <parameter>stat</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        统计对象在搜索路径中可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b5dc09f466075c099a047d5fe334abcd -->

<!-- pgdoc-cn_start sig_en=94713589a0420882da1a8dfe72a51e7e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_is_visible</primary>
        </indexterm>
        <function>pg_table_is_visible</function> ( <parameter>table</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is table visible in search path?
        (This works for all types of relations, including views, materialized
        views, indexes, sequences and foreign tables.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_is_visible</primary>
        </indexterm>
        <function>pg_table_is_visible</function> ( <parameter>table</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        表在搜索路径中可见吗？(这适用于所有类型的关系，包括视图、物化视图、索引、序列和外部表。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=94713589a0420882da1a8dfe72a51e7e -->

<!-- pgdoc-cn_start sig_en=f5e739d9b57e36e9c11b103f3d90fc53 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_config_is_visible</primary>
        </indexterm>
        <function>pg_ts_config_is_visible</function> ( <parameter>config</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search configuration visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_config_is_visible</primary>
        </indexterm>
        <function>pg_ts_config_is_visible</function> ( <parameter>config</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索配置在搜索路径可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f5e739d9b57e36e9c11b103f3d90fc53 -->

<!-- pgdoc-cn_start sig_en=30b63b6d9d4d1261bef638e30bcd0313 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_dict_is_visible</primary>
        </indexterm>
        <function>pg_ts_dict_is_visible</function> ( <parameter>dict</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search dictionary visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_dict_is_visible</primary>
        </indexterm>
        <function>pg_ts_dict_is_visible</function> ( <parameter>dict</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索字典在搜索路径可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=30b63b6d9d4d1261bef638e30bcd0313 -->

<!-- pgdoc-cn_start sig_en=3daf3e27729e8ddcccc62ea8b280a22a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_parser_is_visible</primary>
        </indexterm>
        <function>pg_ts_parser_is_visible</function> ( <parameter>parser</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search parser visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_parser_is_visible</primary>
        </indexterm>
        <function>pg_ts_parser_is_visible</function> ( <parameter>parser</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索解析器在搜索路径中可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3daf3e27729e8ddcccc62ea8b280a22a -->

<!-- pgdoc-cn_start sig_en=22771032210184d7439a6749dbd1708a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_template_is_visible</primary>
        </indexterm>
        <function>pg_ts_template_is_visible</function> ( <parameter>template</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search template visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_template_is_visible</primary>
        </indexterm>
        <function>pg_ts_template_is_visible</function> ( <parameter>template</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索模板在搜索路径可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=22771032210184d7439a6749dbd1708a -->

<!-- pgdoc-cn_start sig_en=1bd5a6501c6e69a403d20847440b7d6d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_type_is_visible</primary>
        </indexterm>
        <function>pg_type_is_visible</function> ( <parameter>type</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is type (or domain) visible in search path?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_type_is_visible</primary>
        </indexterm>
        <function>pg_type_is_visible</function> ( <parameter>type</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        类型(或域)在搜索路径中可见吗?
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1bd5a6501c6e69a403d20847440b7d6d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=bb4ad2e066e069d4da012175749bab4c sig_cn_org=None source=14.1 
   <para>
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</type>, <type>regtype</type>,
    <type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>,
    or <type>regdictionary</type>),
    for example:
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
   </para>
________________________________________________________-->
   <para>
    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<type>regclass</type>、<type>regtype</type>、<type>regprocedure</type>、<type>regoperator</type>、<type>regconfig</type>或<type>regdictionary</type>）将会很方便。例如：
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    注意以这种方式测试一个非模式限定的类型名没什么意义 &mdash; 如果该名称完全能被识别，它必须是可见的。
   </para>
<!-- pgdoc-cn_end sig_en=bb4ad2e066e069d4da012175749bab4c -->

<!-- pgdoc-cn_start sig_en=f8d7e742f5f4aa4c5141bd8f4d6b8f02 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-info-catalog-table"/> lists functions that
   extract information from the system catalogs.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-info-catalog-table"/> 列出从系统目录中提取信息的函数。
  </para>
<!-- pgdoc-cn_end sig_en=f8d7e742f5f4aa4c5141bd8f4d6b8f02 -->

   <table id="functions-info-catalog-table">
<!-- pgdoc-cn_start sig_en=efc6f53aa04d238e2d9d8838eb9efc0f sig_cn_org=None source=14.1 
    <title>System Catalog Information Functions</title>
________________________________________________________-->
    <title>系统目录信息函数</title>
<!-- pgdoc-cn_end sig_en=efc6f53aa04d238e2d9d8838eb9efc0f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=6a2046f98e38e7fc53ff59b2f387daee sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format_type</primary>
        </indexterm>
        <function>format_type</function> ( <parameter>type</parameter> <type>oid</type>, <parameter>typemod</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the SQL name for a data type that is identified by its type
        OID and possibly a type modifier.  Pass NULL for the type modifier if
        no specific modifier is known.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format_type</primary>
        </indexterm>
        <function>format_type</function> ( <parameter>type</parameter> <type>oid</type>, <parameter>typemod</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回由其类型OID和可能的类型修饰符标识的数据类型的SQL名称。如果没有已知的类型修饰符，则传递NULL值给类型修饰符。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6a2046f98e38e7fc53ff59b2f387daee -->

<!-- pgdoc-cn_start sig_en=4bbd7fbdbdb83512fee6249d74856abf sig_cn_org=f275a17a06ece494e49822893faf1f4b source=15.7 
      <row>
       <entry id="pg-char-to-encoding" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_char_to_encoding</primary>
        </indexterm>
        <function>pg_char_to_encoding</function> ( <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Converts the supplied encoding name into an integer representing the
        internal identifier used in some system catalog tables.
        Returns <literal>-1</literal> if an unknown encoding name is provided.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-char-to-encoding" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_char_to_encoding</primary>
        </indexterm>
        <function>pg_char_to_encoding</function> ( <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        将提供的编码名称转换为表示在某些系统目录表中使用的内部标识符的整数。
        如果提供了未知的编码名称，则返回<literal>-1</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4bbd7fbdbdb83512fee6249d74856abf -->

<!-- pgdoc-cn_start sig_en=4e248927adca96a7363027c4983c7f4b sig_cn_org=7947d3023753d294247ac96088d2de6d source=15.7 
      <row>
       <entry id="pg-encoding-to-char" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_encoding_to_char</primary>
        </indexterm>
        <function>pg_encoding_to_char</function> ( <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Converts the integer used as the internal identifier of an encoding in some
        system catalog tables into a human-readable string.
        Returns an empty string if an invalid encoding number is provided.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-encoding-to-char" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_encoding_to_char</primary>
        </indexterm>
        <function>pg_encoding_to_char</function> ( <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        将在某些系统目录表中用作编码内部标识符的整数转换为可读的字符串。
        如果提供了无效的编码编号，则返回空字符串。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4e248927adca96a7363027c4983c7f4b -->

<!-- pgdoc-cn_start sig_en=85a73743cb7af19190c1c12d199f07d7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_catalog_foreign_keys</primary>
        </indexterm>
        <function>pg_get_catalog_foreign_keys</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>fktable</parameter> <type>regclass</type>,
          <parameter>fkcols</parameter> <type>text[]</type>,
          <parameter>pktable</parameter> <type>regclass</type>,
          <parameter>pkcols</parameter> <type>text[]</type>,
          <parameter>is_array</parameter> <type>boolean</type>,
          <parameter>is_opt</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns a set of records describing the foreign key relationships
        that exist within the <productname>PostgreSQL</productname> system
        catalogs.
        The <parameter>fktable</parameter> column contains the name of the
        referencing catalog, and the <parameter>fkcols</parameter> column
        contains the name(s) of the referencing column(s).  Similarly,
        the <parameter>pktable</parameter> column contains the name of the
        referenced catalog, and the <parameter>pkcols</parameter> column
        contains the name(s) of the referenced column(s).
        If <parameter>is_array</parameter> is true, the last referencing
        column is an array, each of whose elements should match some entry
        in the referenced catalog.
        If <parameter>is_opt</parameter> is true, the referencing column(s)
        are allowed to contain zeroes instead of a valid reference.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_catalog_foreign_keys</primary>
        </indexterm>
        <function>pg_get_catalog_foreign_keys</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>fktable</parameter> <type>regclass</type>,
          <parameter>fkcols</parameter> <type>text[]</type>,
          <parameter>pktable</parameter> <type>regclass</type>,
          <parameter>pkcols</parameter> <type>text[]</type>,
          <parameter>is_array</parameter> <type>boolean</type>,
          <parameter>is_opt</parameter> <type>boolean</type> )
       </para>
       <para>
        返回一组记录，描述存在于<productname>PostgreSQL</productname>系统目录中的外键关系。
        <parameter>fktable</parameter> 列包含引用目录的名称，<parameter>fkcols</parameter>列包含引用列的名称。
        类似地，<parameter>pktable</parameter>列包含被引用目录的名称，而<parameter>pkcols</parameter>列包含被引用列的名称。
        如果<parameter>is_array</parameter>为真，则最后一个引用列是一个数组，其每个元素都应该与引用目录中的某个条目匹配。
        如果<parameter>is_opt</parameter>为真，则允许引用列包含零而不是有效引用。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=85a73743cb7af19190c1c12d199f07d7 -->

<!-- pgdoc-cn_start sig_en=bfd57d274e76d28ede5e252e748d2311 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_constraintdef</primary>
        </indexterm>
        <function>pg_get_constraintdef</function> ( <parameter>constraint</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a constraint.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_constraintdef</primary>
        </indexterm>
        <function>pg_get_constraintdef</function> ( <parameter>constraint</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构为了约束的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bfd57d274e76d28ede5e252e748d2311 -->

<!-- pgdoc-cn_start sig_en=efd05145ee75416e9ff1012aec21490b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_expr</primary>
        </indexterm>
        <function>pg_get_expr</function> ( <parameter>expr</parameter> <type>pg_node_tree</type>, <parameter>relation</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Decompiles the internal form of an expression stored in the system
        catalogs, such as the default value for a column.  If the expression
        might contain Vars, specify the OID of the relation they refer to as
        the second parameter; if no Vars are expected, passing zero is
        sufficient.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_expr</primary>
        </indexterm>
        <function>pg_get_expr</function> ( <parameter>expr</parameter> <type>pg_node_tree</type>, <parameter>relation</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        反编译存储在系统目录中的表达式的内部形式，例如列的默认值。
        如果表达式可能包含变量，则指定它们所指向的关系的OID作为第二个参数;如果没有预期的变量，传递0就可以了。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=efd05145ee75416e9ff1012aec21490b -->

<!-- pgdoc-cn_start sig_en=f54e2e5389b7193da5d0892ae7ee43a3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_functiondef</primary>
        </indexterm>
        <function>pg_get_functiondef</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a function or procedure.
        (This is a decompiled reconstruction, not the original text
        of the command.)
        The result is a complete <command>CREATE OR REPLACE FUNCTION</command>
        or <command>CREATE OR REPLACE PROCEDURE</command> statement.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_functiondef</primary>
        </indexterm>
        <function>pg_get_functiondef</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构为了函数或过程的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
        结果是一个完整的<command>CREATE OR REPLACE FUNCTION</command> 或 <command>CREATE OR REPLACE PROCEDURE</command>语句。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f54e2e5389b7193da5d0892ae7ee43a3 -->

<!-- pgdoc-cn_start sig_en=220cd112ba8be4e8a88a4605534bf0c1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_arguments</primary>
        </indexterm>
        <function>pg_get_function_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the argument list of a function or procedure, in the form
        it would need to appear in within <command>CREATE FUNCTION</command>
        (including default values).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_arguments</primary>
        </indexterm>
        <function>pg_get_function_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重新构造函数或过程的参数列表，以其在 <command>CREATE FUNCTION</command>里面需要出现的形式(包括默认值)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=220cd112ba8be4e8a88a4605534bf0c1 -->

<!-- pgdoc-cn_start sig_en=537c494d7fbd965df50050943142da5f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_identity_arguments</primary>
        </indexterm>
        <function>pg_get_function_identity_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the argument list necessary to identify a function or
        procedure, in the form it would need to appear in within commands such
        as <command>ALTER FUNCTION</command>.  This form omits default values.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_identity_arguments</primary>
        </indexterm>
        <function>pg_get_function_identity_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重新构造标识函数或过程所需的参数列表，以其应出现在<command>ALTER FUNCTION</command>等命令中的形式。这个表单省略默认值。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=537c494d7fbd965df50050943142da5f -->

<!-- pgdoc-cn_start sig_en=88af6276ecc0a0a6b511bb1a1f403720 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_result</primary>
        </indexterm>
        <function>pg_get_function_result</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the <literal>RETURNS</literal> clause of a function, in
        the form it would need to appear in within <command>CREATE
        FUNCTION</command>.  Returns <literal>NULL</literal> for a procedure.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_result</primary>
        </indexterm>
        <function>pg_get_function_result</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构函数的<literal>RETURNS</literal>子句，以其需要出现在<command>CREATE FUNCTION</command>中的形式。对于过程，返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=88af6276ecc0a0a6b511bb1a1f403720 -->

<!-- pgdoc-cn_start sig_en=d5c69941fe3bd537a7ed969da83b8844 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_indexdef</primary>
        </indexterm>
        <function>pg_get_indexdef</function> ( <parameter>index</parameter> <type>oid</type> <optional>, <parameter>column</parameter> <type>integer</type>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for an index.
        (This is a decompiled reconstruction, not the original text
        of the command.)  If <parameter>column</parameter> is supplied and is
        not zero, only the definition of that column is reconstructed.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_indexdef</primary>
        </indexterm>
        <function>pg_get_indexdef</function> ( <parameter>index</parameter> <type>oid</type> <optional>, <parameter>column</parameter> <type>integer</type>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对索引的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)如果提供了<parameter>column</parameter>而且不为零，则只重构该列的定义。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5c69941fe3bd537a7ed969da83b8844 -->

<!-- pgdoc-cn_start sig_en=7b7511d7b8d5f9f3082cafcccab5c944 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_keywords</primary>
        </indexterm>
        <function>pg_get_keywords</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>catcode</parameter> <type>"char"</type>,
        <parameter>barelabel</parameter> <type>boolean</type>,
        <parameter>catdesc</parameter> <type>text</type>,
        <parameter>baredesc</parameter> <type>text</type> )
       </para>
       <para>
        Returns a set of records describing the SQL keywords recognized by the
        server.  The <parameter>word</parameter> column contains the
        keyword.  The <parameter>catcode</parameter> column contains a
        category code: <literal>U</literal> for an unreserved
        keyword, <literal>C</literal> for a keyword that can be a column
        name, <literal>T</literal> for a keyword that can be a type or
        function name, or <literal>R</literal> for a fully reserved keyword.
        The <parameter>barelabel</parameter> column
        contains <literal>true</literal> if the keyword can be used as
        a <quote>bare</quote> column label in <command>SELECT</command> lists,
        or <literal>false</literal> if it can only be used
        after <literal>AS</literal>.
        The <parameter>catdesc</parameter> column contains a
        possibly-localized string describing the keyword's category.
        The <parameter>baredesc</parameter> column contains a
        possibly-localized string describing the keyword's column label status.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_keywords</primary>
        </indexterm>
        <function>pg_get_keywords</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>catcode</parameter> <type>"char"</type>,
        <parameter>barelabel</parameter> <type>boolean</type>,
        <parameter>catdesc</parameter> <type>text</type>,
        <parameter>baredesc</parameter> <type>text</type> )
       </para>
       <para>
        返回一组描述服务器识别的SQL关键字的记录。<parameter>word</parameter>列包含关键字。
        <parameter>catcode</parameter>列包含一个类别代码:<literal>U</literal>表示无保留关键字，<literal>C</literal>表示可以是列名的关键字，<literal>T</literal>表示可以是类型或函数名的关键字，或者<literal>R</literal>表示完全保留关键字。
        如果关键字可以在<command>SELECT</command>列表中用作<quote>bare</quote>列标签，则<parameter>barelabel</parameter>列包含<literal>true</literal>，或者<literal>false</literal>，如果它只能在<literal>AS</literal>之后使用。
        <parameter>catdesc</parameter>列包含可能本地化字符串，描述关键字的类别。
        <parameter>baredesc</parameter>列包含可能本地化的字符串，描述关键字的列标签状态。		
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7b7511d7b8d5f9f3082cafcccab5c944 -->

<!-- pgdoc-cn_start sig_en=ca141405a8b8d9efb794012b9722bf61 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_ruledef</primary>
        </indexterm>
        <function>pg_get_ruledef</function> ( <parameter>rule</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a rule.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_ruledef</primary>
        </indexterm>
        <function>pg_get_ruledef</function> ( <parameter>rule</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对规则的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ca141405a8b8d9efb794012b9722bf61 -->

<!-- pgdoc-cn_start sig_en=aca4ad4960ee570a6fb9b4c46be10f7b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_serial_sequence</primary>
        </indexterm>
        <function>pg_get_serial_sequence</function> ( <parameter>table</parameter> <type>text</type>, <parameter>column</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the name of the sequence associated with a column,
        or NULL if no sequence is associated with the column.
        If the column is an identity column, the associated sequence is the
        sequence internally created for that column.
        For columns created using one of the serial types
        (<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>),
        it is the sequence created for that serial column definition.
        In the latter case, the association can be modified or removed
        with <command>ALTER SEQUENCE OWNED BY</command>.
        (This function probably should have been
        called <function>pg_get_owned_sequence</function>; its current name
        reflects the fact that it has historically been used with serial-type
        columns.)  The first parameter is a table name with optional
        schema, and the second parameter is a column name.  Because the first
        parameter potentially contains both schema and table names, it is
        parsed per usual SQL rules, meaning it is lower-cased by default.
        The second parameter, being just a column name, is treated literally
        and so has its case preserved.  The result is suitably formatted
        for passing to the sequence functions (see
        <xref linkend="functions-sequence"/>).
       </para>
       <para>
        A typical use is in reading the current value of the sequence for an
        identity or serial column, for example:
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_serial_sequence</primary>
        </indexterm>
        <function>pg_get_serial_sequence</function> ( <parameter>table</parameter> <type>text</type>, <parameter>column</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回与列相关联的序列名称，如果没有序列与该列相关联则返回NULL。
        如果列是标识列，则关联序列是在内部为该列创建的序列。
        对于使用一种串行类型(<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>)创建的列，它是为该串行列定义创建的序列。
        在后一种情况下，可以使用<command>ALTER SEQUENCE OWNED BY</command>修改或删除关联。
        (这个函数可能应该被称为<function>pg_get_owned_sequence</function>;它的当前名称反映了它在历史上曾与串行类型的列一起使用。)
        第一个参数是具有可选模式的表名，第二个参数是列名。
        由于第一个参数可能包含模式名和表名，因此按照通常的SQL规则解析它，这意味着默认情况下它是小写的。
        第二个参数只是一个列名，按照字面来处理，因此保留了它的大小写。结果经过了适当的格式化，可以传递给序列函数(参见<xref linkend="functions-sequence"/>)。
       </para>
       <para>
        典型的用法是读取序列的当前值以获取标识或串行列，示例如下:
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aca4ad4960ee570a6fb9b4c46be10f7b -->

<!-- pgdoc-cn_start sig_en=4e91b2652c39595f434ec120196ad873 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_statisticsobjdef</primary>
        </indexterm>
        <function>pg_get_statisticsobjdef</function> ( <parameter>statobj</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for an extended statistics object.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_statisticsobjdef</primary>
        </indexterm>
        <function>pg_get_statisticsobjdef</function> ( <parameter>statobj</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对扩展统计对象的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4e91b2652c39595f434ec120196ad873 -->

<!-- pgdoc-cn_start sig_en=ba0520779f09b0c0bfcb476692e293f6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_triggerdef</primary>
        </indexterm>
<function>pg_get_triggerdef</function> ( <parameter>trigger</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a trigger.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_triggerdef</primary>
        </indexterm>
<function>pg_get_triggerdef</function> ( <parameter>trigger</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对触发器的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ba0520779f09b0c0bfcb476692e293f6 -->

<!-- pgdoc-cn_start sig_en=7f299474935b135ae759c0d1112f0a9f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_userbyid</primary>
        </indexterm>
        <function>pg_get_userbyid</function> ( <parameter>role</parameter> <type>oid</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns a role's name given its OID.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_userbyid</primary>
        </indexterm>
        <function>pg_get_userbyid</function> ( <parameter>role</parameter> <type>oid</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        根据OID返回角色名。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7f299474935b135ae759c0d1112f0a9f -->

<!-- pgdoc-cn_start sig_en=3563314dadcb33979a32b96aa7fae3df sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_viewdef</primary>
        </indexterm>
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view.  (This is a decompiled reconstruction, not
        the original text of the command.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_viewdef</primary>
        </indexterm>
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对视图或物化视图的<command>SELECT</command>命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3563314dadcb33979a32b96aa7fae3df -->

<!-- pgdoc-cn_start sig_en=abc9abdcbe3b8eeb996a7a13df22e17d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type>, <parameter>wrap_column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view.  (This is a decompiled reconstruction, not
        the original text of the command.)  In this form of the function,
        pretty-printing is always enabled, and long lines are wrapped to try
        to keep them shorter than the specified number of columns.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type>, <parameter>wrap_column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对视图或物化视图的底层<command>SELECT</command>命令。(这是一个反编译的重构，而不是命令的原始文本。)
        在这种形式的函数中，总是启用美观打印，并对长行进行换行，以尽量使它们小于指定的列数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=abc9abdcbe3b8eeb996a7a13df22e17d -->

<!-- pgdoc-cn_start sig_en=8fcfb944d4112694be7f0d0014dac4c9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>text</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view, working from a textual name for the view
        rather than its OID.  (This is deprecated; use the OID variant
        instead.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>text</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据视图的文本名称而不是它的OID，重构针对视图或物化视图的底层<command>SELECT</command>命令。(这是弃用;请使用OID变体。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8fcfb944d4112694be7f0d0014dac4c9 -->

<!-- pgdoc-cn_start sig_en=c83227b6e7ccad1cd23444bf7115b91a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_column_has_property</primary>
        </indexterm>
        <function>pg_index_column_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>column</parameter> <type>integer</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index column has the named property.
        Common index column properties are listed in
        <xref linkend="functions-info-index-column-props"/>.
        (Note that extension access methods can define additional property
        names for their indexes.)
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID or column
        number does not identify a valid object.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_column_has_property</primary>
        </indexterm>
        <function>pg_index_column_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>column</parameter> <type>integer</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试一个索引列是否具有命名属性。<xref linkend="functions-info-index-column-props"/>列出了常用索引列属性。
        (注意，扩展访问方法可以为其索引定义额外的属性名。)
        如果属性名未知或不适用于特定对象，或者OID或列号不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c83227b6e7ccad1cd23444bf7115b91a -->

<!-- pgdoc-cn_start sig_en=a81b0c1784cfdb4fff3c6c629f19bb83 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_has_property</primary>
        </indexterm>
        <function>pg_index_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index has the named property.
        Common index properties are listed in
        <xref linkend="functions-info-index-props"/>.
        (Note that extension access methods can define additional property
        names for their indexes.)
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID does not
        identify a valid object.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_has_property</primary>
        </indexterm>
        <function>pg_index_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试一个索引是否具有命名属性。<xref linkend="functions-info-index-props"/>列出了常用的索引属性。
        (注意，扩展访问方法可以为其索引定义额外的属性名。)
        如果属性名未知或不适用于特定对象，或者OID不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a81b0c1784cfdb4fff3c6c629f19bb83 -->

<!-- pgdoc-cn_start sig_en=2294aa280b5cd5c331e0b97a60b7e777 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexam_has_property</primary>
        </indexterm>
        <function>pg_indexam_has_property</function> ( <parameter>am</parameter> <type>oid</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index access method has the named property.
        Access method properties are listed in
        <xref linkend="functions-info-indexam-props"/>.
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID does not
        identify a valid object.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexam_has_property</primary>
        </indexterm>
        <function>pg_indexam_has_property</function> ( <parameter>am</parameter> <type>oid</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试索引访问方法是否具有命名属性。访问方法属性如<xref linkend="functions-info-indexam-props"/>所示。
        如果属性名未知或不适用于特定对象，或者OID不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2294aa280b5cd5c331e0b97a60b7e777 -->

<!-- pgdoc-cn_start sig_en=975af33d887b5b289cc1a0b6df4a2098 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_options_to_table</primary>
        </indexterm>
        <function>pg_options_to_table</function> ( <parameter>options_array</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>option_name</parameter> <type>text</type>,
        <parameter>option_value</parameter> <type>text</type> )
       </para>
       <para>
        Returns the set of storage options represented by a value from
        <structname>pg_class</structname>.<structfield>reloptions</structfield> or
        <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_options_to_table</primary>
        </indexterm>
        <function>pg_options_to_table</function> ( <parameter>options_array</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>option_name</parameter> <type>text</type>,
        <parameter>option_value</parameter> <type>text</type> )
       </para>
       <para>
        返回源自<structname>pg_class</structname>.<structfield>reloptions</structfield> 或 <structname>pg_attribute</structname>.<structfield>attoptions</structfield>的值表示的存储选项集。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=975af33d887b5b289cc1a0b6df4a2098 -->

<!-- pgdoc-cn_start sig_en=bf45cc3313c9d1e8a54f66112c62ca78 sig_cn_org=7a9fe226035c4f9c7a2bb02aae29959c source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_settings_get_flags</primary>
        </indexterm>
        <function>pg_settings_get_flags</function> ( <parameter>guc</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns an array of the flags associated with the given GUC, or
        <literal>NULL</literal> if it does not exist. The result is
        an empty array if the GUC exists but there are no flags to show.
        Only the most useful flags listed in
        <xref linkend="functions-pg-settings-flags"/> are exposed.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_settings_get_flags</primary>
        </indexterm>
        <function>pg_settings_get_flags</function> ( <parameter>guc</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        返回与给定GUC相关联的标志数组，如果不存在则返回<literal>NULL</literal>。
        如果GUC存在但没有要显示的标志，则结果为空数组。
        仅公开列出在<xref linkend="functions-pg-settings-flags"/>中最有用的标志。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bf45cc3313c9d1e8a54f66112c62ca78 -->

<!-- pgdoc-cn_start sig_en=c4aaace9b5ed5dd5ebc8dc228bcd22f3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_databases</primary>
        </indexterm>
        <function>pg_tablespace_databases</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>setof oid</returnvalue>
       </para>
       <para>
        Returns the set of OIDs of databases that have objects stored in the
        specified tablespace.  If this function returns any rows, the
        tablespace is not empty and cannot be dropped.  To identify the specific
        objects populating the tablespace, you will need to connect to the
        database(s) identified by <function>pg_tablespace_databases</function>
        and query their <structname>pg_class</structname> catalogs.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_databases</primary>
        </indexterm>
        <function>pg_tablespace_databases</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>setof oid</returnvalue>
       </para>
       <para>
        返回具有存储在指定表空间中的对象的数据库的OIDs集。
        如果这个函数返回了任何行，那么表空间就不是空的，且不能被删除。
        要识别填充表空间的特定对象，需要连接到由<function>pg_tablespace_databases</function>标识的数据库，并查询它们的<structname>pg_class</structname>目录。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c4aaace9b5ed5dd5ebc8dc228bcd22f3 -->

<!-- pgdoc-cn_start sig_en=79efbd714ecda7a504c10dcad3741d39 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_location</primary>
        </indexterm>
        <function>pg_tablespace_location</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the file system path that this tablespace is located in.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_location</primary>
        </indexterm>
        <function>pg_tablespace_location</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回表空间所在的文件系统路径。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=79efbd714ecda7a504c10dcad3741d39 -->

<!-- pgdoc-cn_start sig_en=4d4c7b2f626e43155fab00576b88cab6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_typeof</primary>
        </indexterm>
        <function>pg_typeof</function> ( <type>"any"</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        Returns the OID of the data type of the value that is passed to it.
        This can be helpful for troubleshooting or dynamically constructing
        SQL queries.  The function is declared as
        returning <type>regtype</type>, which is an OID alias type (see
        <xref linkend="datatype-oid"/>); this means that it is the same as an
        OID for comparison purposes but displays as a type name.
       </para>
       <para>
        For example:
<programlisting>
SELECT pg_typeof(33);
 pg_typeof
-&minus;-&minus;-&minus;-&minus;-&minus;-
 integer

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen
-&minus;-&minus;-&minus;-&minus;
      4
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_typeof</primary>
        </indexterm>
        <function>pg_typeof</function> ( <type>"any"</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        返回传递值给它的数据类型的OID。这对于故障排除或动态构造SQL查询很有帮助。
        函数声明为返回<type>regtype</type>，它是一个OID别名类型(see <xref linkend="datatype-oid"/>);
        这意味着，为了比较，它与OID相同，但显示为类型名。
       </para>
       <para>
        例如:
<programlisting>
SELECT pg_typeof(33);
 pg_typeof
-----------
 integer

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen
--------
      4
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4d4c7b2f626e43155fab00576b88cab6 -->

<!-- pgdoc-cn_start sig_en=73b2d1544546352ffe99e8c5f8830e13 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>COLLATION FOR</primary>
        </indexterm>
        <function>COLLATION FOR</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the name of the collation of the value that is passed to it.
        The value is quoted and schema-qualified if necessary.  If no
        collation was derived for the argument expression,
        then <literal>NULL</literal> is returned.  If the argument is not of a
        collatable data type, then an error is raised.
       </para>
       <para>
        For example:
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "default"

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "de_DE"
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>COLLATION FOR</primary>
        </indexterm>
        <function>COLLATION FOR</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回传递值给它的排序规则的名称。如果需要，该值会被引号括起来，并使用模式限定。
        如果没有为参数表达式派生排序规则，则返回<literal>NULL</literal>。如果参数不是可排序数据类型，则会引发错误。
       </para>
       <para>
        例如:
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for
------------------
 "default"

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for
------------------
 "de_DE"
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=73b2d1544546352ffe99e8c5f8830e13 -->

<!-- pgdoc-cn_start sig_en=7637c2aff05975d5d1b6de0e4940dc0f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regclass</primary>
        </indexterm>
        <function>to_regclass</function> ( <type>text</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Translates a textual relation name to its OID.  A similar result is
        obtained by casting the string to type <type>regclass</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regclass</primary>
        </indexterm>
        <function>to_regclass</function> ( <type>text</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        将文本关系名转换为它的OID。通过将字符串类型转换为<type>regclass</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7637c2aff05975d5d1b6de0e4940dc0f -->

<!-- pgdoc-cn_start sig_en=55c014483ebe3b527c9cf04f95aff2ee sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regcollation</primary>
        </indexterm>
        <function>to_regcollation</function> ( <type>text</type> )
        <returnvalue>regcollation</returnvalue>
       </para>
       <para>
        Translates a textual collation name to its OID.  A similar result is
        obtained by casting the string to type <type>regcollation</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regcollation</primary>
        </indexterm>
        <function>to_regcollation</function> ( <type>text</type> )
        <returnvalue>regcollation</returnvalue>
       </para>
       <para>
        将文本排序规则名称转换为它的OID。通过将字符串类型转换为<type>regcollation</type>(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=55c014483ebe3b527c9cf04f95aff2ee -->

<!-- pgdoc-cn_start sig_en=bbe105ff37065617801dde0b1a20a366 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regnamespace</primary>
        </indexterm>
        <function>to_regnamespace</function> ( <type>text</type> )
        <returnvalue>regnamespace</returnvalue>
       </para>
       <para>
        Translates a textual schema name to its OID.  A similar result is
        obtained by casting the string to type <type>regnamespace</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regnamespace</primary>
        </indexterm>
        <function>to_regnamespace</function> ( <type>text</type> )
        <returnvalue>regnamespace</returnvalue>
       </para>
       <para>
        将文本模式名转换为它的OID。通过将字符串转换为<type>regnamespace</type>类型(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bbe105ff37065617801dde0b1a20a366 -->

<!-- pgdoc-cn_start sig_en=954a466d7f8c7957535aa3a6db11c78e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoper</primary>
        </indexterm>
        <function>to_regoper</function> ( <type>text</type> )
        <returnvalue>regoper</returnvalue>
       </para>
       <para>
        Translates a textual operator name to its OID.  A similar result is
        obtained by casting the string to type <type>regoper</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found or is ambiguous.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoper</primary>
        </indexterm>
        <function>to_regoper</function> ( <type>text</type> )
        <returnvalue>regoper</returnvalue>
       </para>
       <para>
        将文本操作符名称转换为它的OID。通过将字符串类型转换为<type>regoper</type>(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果找不到名称或名称有多义性，该函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=954a466d7f8c7957535aa3a6db11c78e -->

<!-- pgdoc-cn_start sig_en=d97cec677e45098c2d205e3065e68e1a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoperator</primary>
        </indexterm>
        <function>to_regoperator</function> ( <type>text</type> )
        <returnvalue>regoperator</returnvalue>
       </para>
       <para>
        Translates a textual operator name (with parameter types) to its OID.  A similar result is
        obtained by casting the string to type <type>regoperator</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoperator</primary>
        </indexterm>
        <function>to_regoperator</function> ( <type>text</type> )
        <returnvalue>regoperator</returnvalue>
       </para>
       <para>
        将文本操作符名称(带有参数类型)转换为其OID。通过将字符串转换为<type>regoperator</type>类型(参见<xref linkend="datatype-oid"/>节)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d97cec677e45098c2d205e3065e68e1a -->

<!-- pgdoc-cn_start sig_en=048b21b4e6141e064d70322ca97418dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regproc</primary>
        </indexterm>
        <function>to_regproc</function> ( <type>text</type> )
        <returnvalue>regproc</returnvalue>
       </para>
       <para>
        Translates a textual function or procedure name to its OID.  A similar result is
        obtained by casting the string to type <type>regproc</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found or is ambiguous.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regproc</primary>
        </indexterm>
        <function>to_regproc</function> ( <type>text</type> )
        <returnvalue>regproc</returnvalue>
       </para>
       <para>
        将文本函数或过程名转换为其OID。通过将字符串转换为<type>regproc</type>类型(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果找不到名称或名称有多义性，该函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=048b21b4e6141e064d70322ca97418dc -->

<!-- pgdoc-cn_start sig_en=d0a08edfe14810839953260700af8afd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regprocedure</primary>
        </indexterm>
        <function>to_regprocedure</function> ( <type>text</type> )
        <returnvalue>regprocedure</returnvalue>
       </para>
       <para>
        Translates a textual function or procedure name (with argument types) to its OID.  A similar result is
        obtained by casting the string to type <type>regprocedure</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regprocedure</primary>
        </indexterm>
        <function>to_regprocedure</function> ( <type>text</type> )
        <returnvalue>regprocedure</returnvalue>
       </para>
       <para>
        将文本函数或过程名(带有参数类型)转换为其OID。通过将字符串类型转换为<type>regprocedure</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d0a08edfe14810839953260700af8afd -->

<!-- pgdoc-cn_start sig_en=d780e67c4556afadb07e02d927015a19 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regrole</primary>
        </indexterm>
        <function>to_regrole</function> ( <type>text</type> )
        <returnvalue>regrole</returnvalue>
       </para>
       <para>
        Translates a textual role name to its OID.  A similar result is
        obtained by casting the string to type <type>regrole</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regrole</primary>
        </indexterm>
        <function>to_regrole</function> ( <type>text</type> )
        <returnvalue>regrole</returnvalue>
       </para>
       <para>
        将文本角色名转换为它的OID。通过将字符串类型转换为<type>regrole</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d780e67c4556afadb07e02d927015a19 -->

<!-- pgdoc-cn_start sig_en=a225219537621e4daeb437ce2473e9b5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regtype</primary>
        </indexterm>
        <function>to_regtype</function> ( <type>text</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        Translates a textual type name to its OID.  A similar result is
        obtained by casting the string to type <type>regtype</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regtype</primary>
        </indexterm>
        <function>to_regtype</function> ( <type>text</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        将文本类型名转换为它的OID。通过将字符串类型转换为<type>regtype</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a225219537621e4daeb437ce2473e9b5 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=af880d327c99d67a39a8ab6a8dd828cb sig_cn_org=None source=14.1 
  <para>
   Most of the functions that reconstruct (decompile) database objects
   have an optional <parameter>pretty</parameter> flag, which
   if <literal>true</literal> causes the result to
   be <quote>pretty-printed</quote>.  Pretty-printing suppresses unnecessary
   parentheses and adds whitespace for legibility.
   The pretty-printed format is more readable, but the default format
   is more likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</productname>; so avoid using pretty-printed output
   for dump purposes.  Passing <literal>false</literal> for
   the <parameter>pretty</parameter> parameter yields the same result as
   omitting the parameter.
  </para>
________________________________________________________-->
  <para>
   大多数重构(反编译)数据库对象的函数都有一个可选的 <parameter>pretty</parameter>标志，如果为<literal>true</literal>，结果将被<quote>pretty-printed</quote>。
   美观打印会抑制不必要的圆括号，并为易读性增加空格。
   美观打印的格式可读性更好，但是默认格式更有可能被<productname>PostgreSQL</productname>的未来版本以同样的方式解释;
   因此，避免为转储目的使用美观打印的输出。为<parameter>pretty</parameter>参数传递<literal>false</literal>会产生与省略参数相同的结果。
  </para>
<!-- pgdoc-cn_end sig_en=af880d327c99d67a39a8ab6a8dd828cb -->

  <table id="functions-info-index-column-props">
<!-- pgdoc-cn_start sig_en=79dd5135aea70a3c2dc625dca0cb56c7 sig_cn_org=None source=14.1 
   <title>Index Column Properties</title>
________________________________________________________-->
   <title>索引列属性</title>
<!-- pgdoc-cn_end sig_en=79dd5135aea70a3c2dc625dca0cb56c7 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 sig_cn_org=None source=14.1 
     <row><entry>Name</entry><entry>Description</entry></row>
________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
<!-- pgdoc-cn_end sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=e7501b485d501cbecb8cf1aa50b437cf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>asc</literal></entry>
      <entry>Does the column sort in ascending order on a forward scan?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>asc</literal></entry>
      <entry>在向前扫描时列是按照升序排列吗？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=e7501b485d501cbecb8cf1aa50b437cf -->
<!-- pgdoc-cn_start sig_en=fe43b67d6fc4d4c2de6df6f69bc0d367 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>desc</literal></entry>
      <entry>Does the column sort in descending order on a forward scan?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>desc</literal></entry>
      <entry>在向前扫描时列是按照降序排列吗？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=fe43b67d6fc4d4c2de6df6f69bc0d367 -->
<!-- pgdoc-cn_start sig_en=5e9c8c464bf72489ae6d8a035a0868d8 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>Does the column sort with nulls first on a forward scan?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>在向前扫描时列排序会把空值排在前面吗？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=5e9c8c464bf72489ae6d8a035a0868d8 -->
<!-- pgdoc-cn_start sig_en=52e5ccffd5be9273a5b5b3b42c10aa2e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>Does the column sort with nulls last on a forward scan?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>在向前扫描时列排序会把空值排在最后吗？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=52e5ccffd5be9273a5b5b3b42c10aa2e -->
<!-- pgdoc-cn_start sig_en=cb8878a079b46768f431df2c90e9e5ce sig_cn_org=None source=14.1 
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>Does the column possess any defined sort ordering?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>列具有已定义的排序顺序吗？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=cb8878a079b46768f431df2c90e9e5ce -->
<!-- pgdoc-cn_start sig_en=14adfea4eec12242e601f12dd874a8f9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>Can the column be scanned in order by a <quote>distance</quote>
      operator, for example <literal>ORDER BY col &lt;-&gt; constant</literal> ?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>列能否通过一个<quote>distance</quote>操作符（例如<literal>ORDER BY col &lt;-&gt; constant</literal>）有序地扫描？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=14adfea4eec12242e601f12dd874a8f9 -->
<!-- pgdoc-cn_start sig_en=cd8fbed06b2761a19d841fb058d0d205 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>Can the column value be returned by an index-only scan?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>列值是否可以通过一次只用索引扫描返回？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=cd8fbed06b2761a19d841fb058d0d205 -->
<!-- pgdoc-cn_start sig_en=6e6d7afc270e0a6ce6c9bd1dd9cea366 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>Does the column natively support <literal>col = ANY(array)</literal>
      searches?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>列是否天然支持<literal>col = ANY(array)</literal>搜索？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6e6d7afc270e0a6ce6c9bd1dd9cea366 -->
<!-- pgdoc-cn_start sig_en=5468213a4d9c54d365230c94ad6b750c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>Does the column support <literal>IS NULL</literal> and
      <literal>IS NOT NULL</literal> searches?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>列是否支持<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>搜索？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=5468213a4d9c54d365230c94ad6b750c -->
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-index-props">
<!-- pgdoc-cn_start sig_en=bb42c5fc560e342003596dfe502f5e9b sig_cn_org=None source=14.1 
   <title>Index Properties</title>
________________________________________________________-->
   <title>索引性质</title>
<!-- pgdoc-cn_end sig_en=bb42c5fc560e342003596dfe502f5e9b -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 sig_cn_org=None source=14.1 
     <row><entry>Name</entry><entry>Description</entry></row>
________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
<!-- pgdoc-cn_end sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=829a6e0b14d63f42c91a2773d506a858 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>Can the index be used in a <literal>CLUSTER</literal> command?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>索引是否可以用于<literal>CLUSTER</literal>命令？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=829a6e0b14d63f42c91a2773d506a858 -->
<!-- pgdoc-cn_start sig_en=327d17b58d7f95c83d0b6bcd12e5c633 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>Does the index support plain (non-bitmap) scans?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>索引是否支持普通扫描（非位图）？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=327d17b58d7f95c83d0b6bcd12e5c633 -->
<!-- pgdoc-cn_start sig_en=45c1a59c19f99f63e4e51bbee0a131ad sig_cn_org=None source=14.1 
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>Does the index support bitmap scans?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>索引是否支持位图扫描？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=45c1a59c19f99f63e4e51bbee0a131ad -->
<!-- pgdoc-cn_start sig_en=8069f771c5978f89fe63f512e550c239 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>Can the scan direction be changed in mid-scan (to
             support <literal>FETCH BACKWARD</literal> on a cursor without
             needing materialization)?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>在扫描中扫描方向能否被更改（为了支持游标上无需物化的<literal>FETCH BACKWARD</literal>）？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=8069f771c5978f89fe63f512e550c239 -->
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-indexam-props">
<!-- pgdoc-cn_start sig_en=eb91199df88f8105ad8ea776891a2a0c sig_cn_org=None source=14.1 
   <title>Index Access Method Properties</title>
________________________________________________________-->
   <title>索引访问方法性质</title>
<!-- pgdoc-cn_end sig_en=eb91199df88f8105ad8ea776891a2a0c -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 sig_cn_org=None source=14.1 
     <row><entry>Name</entry><entry>Description</entry></row>
________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
<!-- pgdoc-cn_end sig_en=6d3a21fab3ec10aa40f89ee13b5cf447 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=d00df4284ebf5b948a698f2a52be1ced sig_cn_org=None source=14.1 
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>Does the access method support <literal>ASC</literal>,
      <literal>DESC</literal> and related keywords in
      <literal>CREATE INDEX</literal>?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>访问方法是否支持<literal>ASC</literal>、<literal>DESC</literal>以及<literal>CREATE INDEX</literal>中的有关关键词？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=d00df4284ebf5b948a698f2a52be1ced -->
<!-- pgdoc-cn_start sig_en=427dfccf49a167b33610d69648436aa2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>Does the access method support unique indexes?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>访问方法是否支持唯一索引？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=427dfccf49a167b33610d69648436aa2 -->
<!-- pgdoc-cn_start sig_en=b2a268b4190aa700487e4abc54360129 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>Does the access method support indexes with multiple columns?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>访问方法是否支持多列索引？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=b2a268b4190aa700487e4abc54360129 -->
<!-- pgdoc-cn_start sig_en=28039d27136f0343f98e0eb69e0ffeeb sig_cn_org=None source=14.1 
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>Does the access method support exclusion constraints?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>访问方法是否支持排除约束？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=28039d27136f0343f98e0eb69e0ffeeb -->
<!-- pgdoc-cn_start sig_en=662abd6b84607a9cf8be51bebe5af156 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>Does the access method support the <literal>INCLUDE</literal>
        clause of <literal>CREATE INDEX</literal>?
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>访问方法是否支持<literal>CREATE INDEX</literal>的<literal>INCLUDE</literal>子句？
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=662abd6b84607a9cf8be51bebe5af156 -->
    </tbody>
   </tgroup>
  </table>

  <table id="functions-pg-settings-flags">
<!-- pgdoc-cn_start sig_en=c06a46c8466cf1d32a853f4bb01dacae sig_cn_org=19fec2256bc20d439ae3c359a018d7aa source=15.7 
   <title>GUC Flags</title>
________________________________________________________-->
   <title>GUC标志</title>
<!-- pgdoc-cn_end sig_en=c06a46c8466cf1d32a853f4bb01dacae -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=e261594a4ff6d0cb6c7cf33a2c75dcd0 sig_cn_org=a581638af7c3ccaedb42b421cf69e898 source=15.7 
     <row><entry>Flag</entry><entry>Description</entry></row>
________________________________________________________-->
     <row><entry>标志</entry><entry>描述</entry></row>
<!-- pgdoc-cn_end sig_en=e261594a4ff6d0cb6c7cf33a2c75dcd0 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=6aa817eab67ef74823580b21e27c2c6d sig_cn_org=26f23b904ae69d2928df1ed1cc5dc61c source=15.7 
     <row>
      <entry><literal>EXPLAIN</literal></entry>
      <entry>Parameters with this flag are included in
       <command>EXPLAIN (SETTINGS)</command> commands.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>EXPLAIN</literal></entry>
      <entry>带有此标志的参数包含在<command>EXPLAIN (SETTINGS)</command>命令中。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6aa817eab67ef74823580b21e27c2c6d -->
<!-- pgdoc-cn_start sig_en=5b829b4354e12742663cbb4b482c7357 sig_cn_org=b0d172cfc6d977da21912f891b602229 source=15.7 
     <row>
      <entry><literal>NO_SHOW_ALL</literal></entry>
      <entry>Parameters with this flag are excluded from
       <command>SHOW ALL</command> commands.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NO_SHOW_ALL</literal></entry>
      <entry>具有此标志的参数将被排除在<command>SHOW ALL</command>命令之外。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5b829b4354e12742663cbb4b482c7357 -->
<!-- pgdoc-cn_start sig_en=d0943539cd08f45ff25297a33dcdb6f3 sig_cn_org=92561b6357c3d3ee1b743ecfe3d6a4b5 source=15.7 
     <row>
      <entry><literal>NO_RESET_ALL</literal></entry>
      <entry>Parameters with this flag are excluded from
       <command>RESET ALL</command> commands.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NO_RESET_ALL</literal></entry>
      <entry>具有此标志的参数将被排除在<command>RESET ALL</command>命令之外。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d0943539cd08f45ff25297a33dcdb6f3 -->
<!-- pgdoc-cn_start sig_en=8ceabd4029f6a13a687adcef5df5ec64 sig_cn_org=3606a00bc65a31d23ab89921b9699c04 source=15.7 
     <row>
      <entry><literal>NOT_IN_SAMPLE</literal></entry>
      <entry>Parameters with this flag are not included in
       <filename>postgresql.conf</filename> by default.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NOT_IN_SAMPLE</literal></entry>
      <entry>带有此标志的参数默认情况下不包含在
       <filename>postgresql.conf</filename>中。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=8ceabd4029f6a13a687adcef5df5ec64 -->
<!-- pgdoc-cn_start sig_en=eaa51db105a0438979718ed3718b10e0 sig_cn_org=581ff6252485776b0b2843ec3ffaeb07 source=15.7 
     <row>
      <entry><literal>RUNTIME_COMPUTED</literal></entry>
      <entry>Parameters with this flag are runtime-computed ones.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RUNTIME_COMPUTED</literal></entry>
      <entry>具有此标志的参数是在运行时计算的参数。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=eaa51db105a0438979718ed3718b10e0 -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=34795deaddb1c024772a10219a1e6ebe sig_cn_org=None source=14.1 
  <para>
   <xref linkend="functions-info-object-table"/> lists functions related to
   database object identification and addressing.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="functions-info-object-table"/>列出了与数据库对象
   标识和定位有关的函数。
  </para>
<!-- pgdoc-cn_end sig_en=34795deaddb1c024772a10219a1e6ebe -->

   <table id="functions-info-object-table">
<!-- pgdoc-cn_start sig_en=783e97aa51e466f9933638076d12c4c2 sig_cn_org=None source=14.1 
    <title>Object Information and Addressing Functions</title>
________________________________________________________-->
    <title>对象信息和定位函数</title>
<!-- pgdoc-cn_end sig_en=783e97aa51e466f9933638076d12c4c2 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c5843ccb7e64e52c62e5d17acd2d999e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_describe_object</primary>
        </indexterm>
        <function>pg_describe_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a textual description of a database object identified by
        catalog OID, object OID, and sub-object ID (such as a column number
        within a table; the sub-object ID is zero when referring to a whole
        object).  This description is intended to be human-readable, and might
        be translated, depending on server configuration.  This is especially
        useful to determine the identity of an object referenced in the
        <structname>pg_depend</structname> catalog. This function returns
        <literal>NULL</literal> values for undefined objects.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_describe_object</primary>
        </indexterm>
        <function>pg_describe_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回由目录OID、对象OID和子对象ID(例如表中的列号)标识的数据库对象的文本描述;当引用整个对象时，子对象ID为0)。
        这个描述是人类可读的，并且可以根据服务器配置进行翻译。这对于决定<structname>pg_depend</structname>目录中引用的对象的标识特别有用。
        此函数对于未定义的对象返回<literal>NULL</literal>值
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c5843ccb7e64e52c62e5d17acd2d999e -->

<!-- pgdoc-cn_start sig_en=519c5e72d4fe626d463e161500649019 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object</primary>
        </indexterm>
        <function>pg_identify_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>schema</parameter> <type>text</type>,
        <parameter>name</parameter> <type>text</type>,
        <parameter>identity</parameter> <type>text</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by catalog OID, object OID and sub-object
        ID.
        This information is intended to be machine-readable, and is never
        translated.
        <parameter>type</parameter> identifies the type of database object;
        <parameter>schema</parameter> is the schema name that the object
        belongs in, or <literal>NULL</literal> for object types that do not
        belong to schemas;
        <parameter>name</parameter> is the name of the object, quoted if
        necessary, if the name (along with schema name, if pertinent) is
        sufficient to uniquely identify the object,
        otherwise <literal>NULL</literal>;
        <parameter>identity</parameter> is the complete object identity, with
        the precise format depending on object type, and each name within the
        format being schema-qualified and quoted as necessary. Undefined
        objects are identified with <literal>NULL</literal> values.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object</primary>
        </indexterm>
        <function>pg_identify_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>schema</parameter> <type>text</type>,
        <parameter>name</parameter> <type>text</type>,
        <parameter>identity</parameter> <type>text</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由目录OID、对象OID和子对象ID指定的数据库对象。
        这些信息是为了机器可读的，永远不会被翻译。
        <parameter>type</parameter>标识数据库对象的类型;
        <parameter>schema</parameter>是对象所属的模式名，<literal>NULL</literal>表示不属于模式的对象类型;
        <parameter>name</parameter>是对象的名称，如果有必要，用引号括起来，如果名称(随着模式名称，如果相关)足以唯一地标识对象，否则为<literal>NULL</literal>;
        <parameter>identity</parameter>是完整的对象标识，其精确格式依赖于对象类型，格式中的每个名称都是模式限定的，并在必要时用引号括起来。
        未定义的对象由<literal>NULL</literal>值标识。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=519c5e72d4fe626d463e161500649019 -->

<!-- pgdoc-cn_start sig_en=37f1de57ce29e7083acb4760fc3e446f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object_as_address</primary>
        </indexterm>
        <function>pg_identify_object_as_address</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>object_names</parameter> <type>text[]</type>,
        <parameter>object_args</parameter> <type>text[]</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by catalog OID, object OID and sub-object
        ID.
        The returned information is independent of the current server, that
        is, it could be used to identify an identically named object in
        another server.
        <parameter>type</parameter> identifies the type of database object;
        <parameter>object_names</parameter> and
        <parameter>object_args</parameter>
        are text arrays that together form a reference to the object.
        These three values can be passed
        to <function>pg_get_object_address</function> to obtain the internal
        address of the object.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object_as_address</primary>
        </indexterm>
        <function>pg_identify_object_as_address</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>object_names</parameter> <type>text[]</type>,
        <parameter>object_args</parameter> <type>text[]</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由目录OID、对象OID和子对象ID指定的数据库对象。
        返回的信息独立于当前服务器，也就是说，它可以用于标识另一个服务器中具有相同名称的对象。
        <parameter>type</parameter>标识数据库对象的类型;<parameter>object_names</parameter>和<parameter>object_args</parameter>是文本数组，它们一起构成对对象的引用。
        这三个值可以传递给<function>pg_get_object_address</function>以获得对象的内部地址。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=37f1de57ce29e7083acb4760fc3e446f -->

<!-- pgdoc-cn_start sig_en=f39a23ba48236c2fc2c0222e6118b725 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_object_address</primary>
        </indexterm>
        <function>pg_get_object_address</function> ( <parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>classid</parameter> <type>oid</type>,
        <parameter>objid</parameter> <type>oid</type>,
        <parameter>objsubid</parameter> <type>integer</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by a type code and object name and argument
        arrays.
        The returned values are the ones that would be used in system catalogs
        such as <structname>pg_depend</structname>; they can be passed to
        other system functions such as <function>pg_describe_object</function>
        or <function>pg_identify_object</function>.
        <parameter>classid</parameter> is the OID of the system catalog
        containing the object;
        <parameter>objid</parameter> is the OID of the object itself, and
        <parameter>objsubid</parameter> is the sub-object ID, or zero if none.
        This function is the inverse
        of <function>pg_identify_object_as_address</function>.
        Undefined objects are identified with <literal>NULL</literal> values.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_object_address</primary>
        </indexterm>
        <function>pg_get_object_address</function> ( <parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>classid</parameter> <type>oid</type>,
        <parameter>objid</parameter> <type>oid</type>,
        <parameter>objsubid</parameter> <type>integer</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由类型代码、对象名称和参数数组指定的数据库对象。
        返回的值将在系统目录中使用，例如<structname>pg_depend</structname>;
        它们可以传递给其他系统函数，比如 <function>pg_describe_object</function>或<function>pg_identify_object</function>。
        <parameter>classid</parameter>是包含该对象的系统目录的OID;<parameter>objid</parameter>是对象本身的OID, <parameter>objsubid</parameter>是子对象的ID，如果没有则为零。
        这个函数是<function>pg_identify_object_as_address</function>的反向函数。
        未定义的对象以<literal>NULL</literal>值标识。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f39a23ba48236c2fc2c0222e6118b725 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=cd013a7d883eba5313e1c70efcd73ad9 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>注释</primary>
    <secondary sortas="database objects">关于数据库对象</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cd013a7d883eba5313e1c70efcd73ad9 -->

<!-- pgdoc-cn_start sig_en=0b5ed657aa83d9e0d3d89f304b30cb38 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-info-comment-table"/>
    extract comments previously stored with the <xref linkend="sql-comment"/>
    command.  A null value is returned if no
    comment could be found for the specified parameters.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-info-comment-table"/>中展示的函数抽取注释，注释是由<xref linkend="sql-comment"/>命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </para>
<!-- pgdoc-cn_end sig_en=0b5ed657aa83d9e0d3d89f304b30cb38 -->

   <table id="functions-info-comment-table">
<!-- pgdoc-cn_start sig_en=1e8e54eee6086d752ef932f8b5b27af3 sig_cn_org=None source=14.1 
    <title>Comment Information Functions</title>
________________________________________________________-->
    <title>注释信息函数</title>
<!-- pgdoc-cn_end sig_en=1e8e54eee6086d752ef932f8b5b27af3 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=69455072decf8cb6fca7c2b112a69909 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>col_description</primary>
        </indexterm>
        <function>col_description</function> ( <parameter>table</parameter> <type>oid</type>, <parameter>column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a table column, which is specified by the OID
        of its table and its column number.
        (<function>obj_description</function> cannot be used for table
        columns, since columns do not have OIDs of their own.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>col_description</primary>
        </indexterm>
        <function>col_description</function> ( <parameter>table</parameter> <type>oid</type>, <parameter>column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回表列的注释，该注释由该表的OID和列号指定。(<function>obj_description</function>不能用于表的列，因为列没有自己的oid。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69455072decf8cb6fca7c2b112a69909 -->

<!-- pgdoc-cn_start sig_en=713c4148edc2db2b60bac967c91c127d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>obj_description</primary>
        </indexterm>
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a database object specified by its OID and the
        name of the containing system catalog.  For
        example, <literal>obj_description(123456, 'pg_class')</literal> would
        retrieve the comment for the table with OID 123456.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>obj_description</primary>
        </indexterm>
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回OID指定的数据库对象的注释和包含该对象的系统目录的名称。
        例如，<literal>obj_description(123456, 'pg_class')</literal>将检索OID为123456的表的注释。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=713c4148edc2db2b60bac967c91c127d -->

<!-- pgdoc-cn_start sig_en=90d049996340c0633c59c98f0a6b38d7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a database object specified by its OID alone.
        This is <emphasis>deprecated</emphasis> since there is no guarantee
        that OIDs are unique across different system catalogs; therefore, the
        wrong comment might be returned.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回仅由其OID指定的数据库对象的注释。
        这个已被<emphasis>弃用(deprecated)</emphasis>因为无法保证oid在不同的系统目录中是唯一的;因此，可能会返回错误的注释。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=90d049996340c0633c59c98f0a6b38d7 -->

<!-- pgdoc-cn_start sig_en=04940d2cddf41a1377c3c6d1a74c1341 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>shobj_description</primary>
        </indexterm>
        <function>shobj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a shared database object specified by its OID
        and the name of the containing system catalog.  This is just
        like <function>obj_description</function> except that it is used for
        retrieving comments on shared objects (that is, databases, roles, and
        tablespaces).  Some system catalogs are global to all databases within
        each cluster, and the descriptions for objects in them are stored
        globally as well.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>shobj_description</primary>
        </indexterm>
        <function>shobj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回共享数据库对象的注释，该对象由其OID和包含的系统编目的名称指定。
        这与<function>obj_description</function>类似，只是它用于检索共享对象(也就是数据库、角色和表空间)上的注释。
        有些系统编目对每个集群中的所有数据库都是全局的，其中对象的描述也全局存储。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=04940d2cddf41a1377c3c6d1a74c1341 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=bdd8f1297cf0b899903950464b473029 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-pg-snapshot"/>
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-pg-snapshot"/>中展示的函数以一种可导出的形式提供了服务器事务信息。
    这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </para>
<!-- pgdoc-cn_end sig_en=bdd8f1297cf0b899903950464b473029 -->

   <table id="functions-pg-snapshot">
<!-- pgdoc-cn_start sig_en=e707215afa7273265c8ec45e563bb70c sig_cn_org=None source=14.1 
    <title>Transaction ID and Snapshot Information Functions</title>
________________________________________________________-->
    <title>事务ID和快照信息功能</title>
<!-- pgdoc-cn_end sig_en=e707215afa7273265c8ec45e563bb70c -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=ea3034061d290289d11efe5e9e45844f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id</primary>
        </indexterm>
        <function>pg_current_xact_id</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the current transaction's ID.  It will assign a new one if the
        current transaction does not have one already (because it has not
        performed any database updates).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id</primary>
        </indexterm>
        <function>pg_current_xact_id</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回当前事务的ID。如果当前事务还没有一个ID(因为它还没有执行任何数据库更新)，它将分配一个新的事务。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ea3034061d290289d11efe5e9e45844f -->

<!-- pgdoc-cn_start sig_en=d8188edcc7ba6abd217bc96f5b4d18ed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id_if_assigned</primary>
        </indexterm>
        <function>pg_current_xact_id_if_assigned</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the current transaction's ID, or <literal>NULL</literal> if no
        ID is assigned yet.  (It's best to use this variant if the transaction
        might otherwise be read-only, to avoid unnecessary consumption of an
        XID.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id_if_assigned</primary>
        </indexterm>
        <function>pg_current_xact_id_if_assigned</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回当前事务的ID，如果还没有分配ID则返回<literal>NULL</literal>。
        (如果事务可能是只读的，最好使用这种变体，以避免不必要地消耗XID。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d8188edcc7ba6abd217bc96f5b4d18ed -->

<!-- pgdoc-cn_start sig_en=62eb753ebc035abceffd4da55812617a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_status</primary>
        </indexterm>
        <function>pg_xact_status</function> ( <type>xid8</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reports the commit status of a recent transaction.
        The result is one of <literal>in progress</literal>,
        <literal>committed</literal>, or <literal>aborted</literal>,
        provided that the transaction is recent enough that the system retains
        the commit status of that transaction.
        If it is old enough that no references to the transaction survive in
        the system and the commit status information has been discarded, the
        result is <literal>NULL</literal>.
        Applications might use this function, for example, to determine
        whether their transaction committed or aborted after the application
        and database server become disconnected while
        a <literal>COMMIT</literal> is in progress.
        Note that prepared transactions are reported as <literal>in
        progress</literal>; applications must check <link
        linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>
        if they need to determine whether a transaction ID belongs to a
        prepared transaction.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_status</primary>
        </indexterm>
        <function>pg_xact_status</function> ( <type>xid8</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        报告最近的事务的提交状态。如果事务为最近的，系统会保留事务的提交状态，则结果是 <literal>in progress</literal>、<literal>committed</literal>或<literal>aborted</literal>。
        如果该事务的时间足够久，并且系统中没有对该事务的引用，而且提交状态信息已经被丢弃，则结果为<literal>NULL</literal>。
        应用可以使用此函数，例如，确定在进行<literal>COMMIT</literal>时，应用程序和数据库服务器断开连接后，它们的事务是已提交还是中止。
        注意，准备好的事务报告为<literal>in progress</literal>的事务;如果应用需要确定一个事务ID是否属于一个准备好的事务，则必须检查<link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=62eb753ebc035abceffd4da55812617a -->

<!-- pgdoc-cn_start sig_en=f82adec0cd3f949a3b5bc4f5796b1ad4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_snapshot</primary>
        </indexterm>
        <function>pg_current_snapshot</function> ()
        <returnvalue>pg_snapshot</returnvalue>
       </para>
       <para>
        Returns a current <firstterm>snapshot</firstterm>, a data structure
        showing which transaction IDs are now in-progress.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_snapshot</primary>
        </indexterm>
        <function>pg_current_snapshot</function> ()
        <returnvalue>pg_snapshot</returnvalue>
       </para>
       <para>
        返回当前<firstterm>snapshot</firstterm>，显示哪些事务IDs正在进行中的数据结构。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f82adec0cd3f949a3b5bc4f5796b1ad4 -->

<!-- pgdoc-cn_start sig_en=075d683891808d8a6adc5d9024a24c12 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xip</primary>
        </indexterm>
        <function>pg_snapshot_xip</function> ( <type>pg_snapshot</type> )
        <returnvalue>setof xid8</returnvalue>
       </para>
       <para>
        Returns the set of in-progress transaction IDs contained in a snapshot.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xip</primary>
        </indexterm>
        <function>pg_snapshot_xip</function> ( <type>pg_snapshot</type> )
        <returnvalue>setof xid8</returnvalue>
       </para>
       <para>
        返回快照中包含的正在进行的事务IDs集。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=075d683891808d8a6adc5d9024a24c12 -->

<!-- pgdoc-cn_start sig_en=88d147e3deef5d0da1448027a21f94c3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmax</primary>
        </indexterm>
        <function>pg_snapshot_xmax</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the <structfield>xmax</structfield> of a snapshot.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmax</primary>
        </indexterm>
        <function>pg_snapshot_xmax</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回快照的<structfield>xmax</structfield>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=88d147e3deef5d0da1448027a21f94c3 -->

<!-- pgdoc-cn_start sig_en=c47279c7cd92ac2d59961c6bee127bef sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmin</primary>
        </indexterm>
        <function>pg_snapshot_xmin</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the <structfield>xmin</structfield> of a snapshot.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmin</primary>
        </indexterm>
        <function>pg_snapshot_xmin</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回快照的<structfield>xmin</structfield>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c47279c7cd92ac2d59961c6bee127bef -->

<!-- pgdoc-cn_start sig_en=97760f9830e0dd40e95008ef6b665bf6 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_visible_in_snapshot</primary>
        </indexterm>
        <function>pg_visible_in_snapshot</function> ( <type>xid8</type>, <type>pg_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the given transaction ID <firstterm>visible</firstterm> according
        to this snapshot (that is, was it completed before the snapshot was
        taken)?  Note that this function will not give the correct answer for
        a subtransaction ID.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_visible_in_snapshot</primary>
        </indexterm>
        <function>pg_visible_in_snapshot</function> ( <type>xid8</type>, <type>pg_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        根据此快照，给定的事务ID是否<firstterm>可见(visible)</firstterm>(也就是说，它是否在快照拍摄之前完成)?
        注意，这个函数不会给出子事务ID的正确答案。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=97760f9830e0dd40e95008ef6b665bf6 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=b2431d2e4f5a652dc78e628ad0a6d40b sig_cn_org=None source=14.1 
   <para>
    The internal transaction ID type <type>xid</type> is 32 bits wide and
    wraps around every 4 billion transactions.  However,
    the functions shown in <xref linkend="functions-pg-snapshot"/> use a
    64-bit type <type>xid8</type> that does not wrap around during the life
    of an installation, and can be converted to <type>xid</type> by casting if
    required.  The data type <type>pg_snapshot</type> stores information about
    transaction ID visibility at a particular moment in time.  Its components
    are described in <xref linkend="functions-pg-snapshot-parts"/>.
    <type>pg_snapshot</type>'s textual representation is
    <literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
   </para>
________________________________________________________-->
   <para>
    内部事务ID类型<type>xid</type>是32位宽的，可捆卷(wraps around)每40亿个事务。
    但是，<xref linkend="functions-pg-snapshot"/>中所示的函数使用的是64位类型的<type>xid8</type>，它在安装过程中不捆卷(wraps around)，如果需要，可以通过强制转换将其转换为<type>xid</type>。
    数据类型<type>pg_snapshot</type>存储特定时刻事务ID可见性的信息。
    其组成如<xref linkend="functions-pg-snapshot-parts"/>所描述。<type>pg_snapshot</type>的文本表示形式是<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>。
    例如<literal>10:20:10,14,15</literal>表示<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=b2431d2e4f5a652dc78e628ad0a6d40b -->

   <table id="functions-pg-snapshot-parts">
<!-- pgdoc-cn_start sig_en=56cabd6d1ed6212d92f4a5351e2f1968 sig_cn_org=None source=14.1 
    <title>Snapshot Components</title>
________________________________________________________-->
    <title>快照组件</title>
<!-- pgdoc-cn_end sig_en=56cabd6d1ed6212d92f4a5351e2f1968 -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=3039eb4daaf614c29fd970202490056a sig_cn_org=None source=14.1 
      <row>
       <entry>Name</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>名称</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3039eb4daaf614c29fd970202490056a -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=8a528607373f055c87698313e57a6158 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>xmin</structfield></entry>
       <entry>
         Lowest transaction ID that was still active.  All transaction IDs
         less than <structfield>xmin</structfield> are either committed and visible,
         or rolled back and dead.
       </entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>xmin</structfield></entry>
       <entry>
         仍然处于活动状态的最低事务ID。所有小于<structfield>xmin</structfield>的事务IDs要么提交且可见，要么回滚并死亡。
       </entry>
      </row>
<!-- pgdoc-cn_end sig_en=8a528607373f055c87698313e57a6158 -->

<!-- pgdoc-cn_start sig_en=aff69732e862391123a2cb1c307139ee sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>xmax</structfield></entry>
       <entry>
         One past the highest completed transaction ID.  All transaction IDs
         greater than or equal to <structfield>xmax</structfield> had not yet
         completed as of the time of the snapshot, and thus are invisible.
       </entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>xmax</structfield></entry>
       <entry>
         比最高完成的事务ID还高出一个值。所有大于或等于<structfield>xmax</structfield>的事务IDs到快照时还没有完成，因此不可见。
       </entry>
      </row>
<!-- pgdoc-cn_end sig_en=aff69732e862391123a2cb1c307139ee -->

<!-- pgdoc-cn_start sig_en=3217ed15921c212d2338a22aaaae2686 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>xip_list</structfield></entry>
       <entry>
        Transactions in progress at the time of the snapshot.  A transaction
        ID that is <literal>xmin &lt;= <replaceable>X</replaceable> &lt;
        xmax</literal> and not in this list was already completed at the time
        of the snapshot, and thus is either visible or dead according to its
        commit status.  This list does not include the transaction IDs of
        subtransactions.
       </entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>xip_list</structfield></entry>
       <entry>
        快照时正在进行的事务。一个事务ID为<literal>xmin &lt;= <replaceable>X</replaceable> &lt; xmax</literal>且不在快照时已经完成的列表中，因此根据其提交状态，该事务ID要么是可见的，要么是死的。此列表不包括子事务的事务IDs。
       </entry>
      </row>
<!-- pgdoc-cn_end sig_en=3217ed15921c212d2338a22aaaae2686 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=d0363488944b444ae8029014c09333c9 sig_cn_org=None source=14.1 
   <para>
    In releases of <productname>PostgreSQL</productname> before 13 there was
    no <type>xid8</type> type, so variants of these functions were provided
    that used <type>bigint</type> to represent a 64-bit XID, with a
    correspondingly distinct snapshot data type <type>txid_snapshot</type>.
    These older functions have <literal>txid</literal> in their names.  They
    are still supported for backward compatibility, but may be removed from a
    future release. See <xref linkend="functions-txid-snapshot"/>.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>13以前的版本中，没有<type>xid8</type>类型，因此提供了这些函数的变体，使用<type>bigint</type>表示64位XID，并相应地提供不同的快照数据类型<type>txid_snapshot</type>。
    这些旧的函数在它们的名字中有<literal>txid</literal>。
    它们仍然支持向后兼容性，但可能会从未来的版本中删除。参见<xref linkend="functions-txid-snapshot"/>。
   </para>
<!-- pgdoc-cn_end sig_en=d0363488944b444ae8029014c09333c9 -->

   <table id="functions-txid-snapshot">
<!-- pgdoc-cn_start sig_en=2c9000f20445d339ace75765cad6cf47 sig_cn_org=None source=14.1 
    <title>Deprecated Transaction ID and Snapshot Information Functions</title>
________________________________________________________-->
    <title>已弃用的事务ID和快照信息功能</title>
<!-- pgdoc-cn_end sig_en=2c9000f20445d339ace75765cad6cf47 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=2ad16eca0809a07be1969559cf7b21ed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current</primary>
        </indexterm>
        <function>txid_current</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_current_xact_id()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current</primary>
        </indexterm>
        <function>txid_current</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_xact_id()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2ad16eca0809a07be1969559cf7b21ed -->

<!-- pgdoc-cn_start sig_en=53190f2ad8d195acaccb19ca2c559f6a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_if_assigned</primary>
        </indexterm>
        <function>txid_current_if_assigned</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_current_xact_id_if_assigned()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_if_assigned</primary>
        </indexterm>
        <function>txid_current_if_assigned</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_xact_id_if_assigned()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=53190f2ad8d195acaccb19ca2c559f6a -->

<!-- pgdoc-cn_start sig_en=bf6d62514546717cbc2aca1385198f1e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_snapshot</primary>
        </indexterm>
        <function>txid_current_snapshot</function> ()
        <returnvalue>txid_snapshot</returnvalue>
       </para>
       <para>
        See <function>pg_current_snapshot()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_snapshot</primary>
        </indexterm>
        <function>txid_current_snapshot</function> ()
        <returnvalue>txid_snapshot</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_snapshot()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=bf6d62514546717cbc2aca1385198f1e -->

<!-- pgdoc-cn_start sig_en=5e6fb91801ccdfc120c669532af58b64 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xip</primary>
        </indexterm>
        <function>txid_snapshot_xip</function> ( <type>txid_snapshot</type> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xip()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xip</primary>
        </indexterm>
        <function>txid_snapshot_xip</function> ( <type>txid_snapshot</type> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xip()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5e6fb91801ccdfc120c669532af58b64 -->

<!-- pgdoc-cn_start sig_en=af1d6617063d8297b7356a8bb4d883f8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmax</primary>
        </indexterm>
        <function>txid_snapshot_xmax</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xmax()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmax</primary>
        </indexterm>
        <function>txid_snapshot_xmax</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xmax()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=af1d6617063d8297b7356a8bb4d883f8 -->

<!-- pgdoc-cn_start sig_en=8c78f1cc77d202c43e539020ad402283 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmin</primary>
        </indexterm>
        <function>txid_snapshot_xmin</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xmin()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmin</primary>
        </indexterm>
        <function>txid_snapshot_xmin</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xmin()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c78f1cc77d202c43e539020ad402283 -->

<!-- pgdoc-cn_start sig_en=cff20581910b7bf1282e4d6212bcf461 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_visible_in_snapshot</primary>
        </indexterm>
        <function>txid_visible_in_snapshot</function> ( <type>bigint</type>, <type>txid_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        See <function>pg_visible_in_snapshot()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_visible_in_snapshot</primary>
        </indexterm>
        <function>txid_visible_in_snapshot</function> ( <type>bigint</type>, <type>txid_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        参见 <function>pg_visible_in_snapshot()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cff20581910b7bf1282e4d6212bcf461 -->

<!-- pgdoc-cn_start sig_en=7fe28d347e122670f77d4e62aa38305d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_status</primary>
        </indexterm>
        <function>txid_status</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        See <function>pg_xact_status()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_status</primary>
        </indexterm>
        <function>txid_status</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        参见 <function>pg_xact_status()</function>.
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7fe28d347e122670f77d4e62aa38305d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=f4fe54ade6a800b0f2a37dc252379291 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-commit-timestamp"/>
    provide information about when past transactions were committed.
    They only provide useful data when the
    <xref linkend="guc-track-commit-timestamp"/> configuration option is
    enabled, and only for transactions that were committed after it was
    enabled.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-commit-timestamp"/>中的函数提供了关于过去的事务何时被提交的信息。
    它们只在启用<xref linkend="guc-track-commit-timestamp"/>配置选项时提供有用的数据，并且只针对在启用该选项后提交的事务。
   </para>
<!-- pgdoc-cn_end sig_en=f4fe54ade6a800b0f2a37dc252379291 -->

   <table id="functions-commit-timestamp">
<!-- pgdoc-cn_start sig_en=ef6dc22acf288172b51a9f50e2113316 sig_cn_org=None source=14.1 
    <title>Committed Transaction Information Functions</title>
________________________________________________________-->
    <title>已提交事务信息函数</title>
<!-- pgdoc-cn_end sig_en=ef6dc22acf288172b51a9f50e2113316 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=d7b752c8ec76a5431fb575a39813e168 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp</function> ( <type>xid</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the commit timestamp of a transaction.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp</function> ( <type>xid</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回事务的提交时间戳。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d7b752c8ec76a5431fb575a39813e168 -->

<!-- pgdoc-cn_start sig_en=0c60dbf38ab7dcce9b9015e613fcf4c2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp_origin</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp_origin</function> ( <type>xid</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>timestamp</parameter> <type>timestamp with time zone</type>,
         <parameter>roident</parameter> <type>oid</type>)
       </para>
       <para>
         Returns the commit timestamp and replication origin of a transaction.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp_origin</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp_origin</function> ( <type>xid</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>timestamp</parameter> <type>timestamp with time zone</type>,
         <parameter>roident</parameter> <type>oid</type>)
       </para>
       <para>
         返回事务的提交时间戳和复制起源。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0c60dbf38ab7dcce9b9015e613fcf4c2 -->

<!-- pgdoc-cn_start sig_en=6ef991a504b3ac550772ad76bebdf80e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_committed_xact</primary>
        </indexterm>
        <function>pg_last_committed_xact</function> ()
        <returnvalue>record</returnvalue>
        ( <parameter>xid</parameter> <type>xid</type>,
        <parameter>timestamp</parameter> <type>timestamp with time zone</type>,
        <parameter>roident</parameter> <type>oid</type> )
       </para>
       <para>
        Returns the transaction ID, commit timestamp and replication origin
        of the latest committed transaction.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_committed_xact</primary>
        </indexterm>
        <function>pg_last_committed_xact</function> ()
        <returnvalue>record</returnvalue>
        ( <parameter>xid</parameter> <type>xid</type>,
        <parameter>timestamp</parameter> <type>timestamp with time zone</type>,
        <parameter>roident</parameter> <type>oid</type> )
       </para>
       <para>
        返回最近提交的事务的事务ID、提交时间戳和复制源头。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6ef991a504b3ac550772ad76bebdf80e -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=afbb923d61e2130700af31f19d001597 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-controldata"/>
    print information initialized during <command>initdb</command>, such
    as the catalog version. They also show information about write-ahead
    logging and checkpoint processing. This information is cluster-wide,
    not specific to any one database. These functions provide most of the same
    information, from the same source, as the
    <xref linkend="app-pgcontroldata"/> application.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-controldata"/>中所展示的函数能打印<command>initdb</command>期间初始化的信息，例如目录版本。
    它们也能显示有关预写式日志和检查点处理的信息。这些信息是集簇范围内的，不与任何特定的一个数据库相关。
    这些函数提供大致相同的信息，对于同一种来源，就像<xref linkend="app-pgcontroldata"/>应用。
   </para>
<!-- pgdoc-cn_end sig_en=afbb923d61e2130700af31f19d001597 -->

   <table id="functions-controldata">
<!-- pgdoc-cn_start sig_en=d546446c6c39819ab9a27c536c20d64f sig_cn_org=None source=14.1 
    <title>Control Data Functions</title>
________________________________________________________-->
    <title>控制数据函数</title>
<!-- pgdoc-cn_end sig_en=d546446c6c39819ab9a27c536c20d64f -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=aa2484c746ae975fd47cef4da398cf36 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_checkpoint</primary>
        </indexterm>
        <function>pg_control_checkpoint</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about current checkpoint state, as shown in
        <xref linkend="functions-pg-control-checkpoint"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_checkpoint</primary>
        </indexterm>
        <function>pg_control_checkpoint</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关当前检查点状态的信息, 如 <xref linkend="functions-pg-control-checkpoint"/>所展示。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aa2484c746ae975fd47cef4da398cf36 -->

<!-- pgdoc-cn_start sig_en=b8527eb9cd2d42b44ebdcceb04382bed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_system</primary>
        </indexterm>
        <function>pg_control_system</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about current control file state, as shown in
        <xref linkend="functions-pg-control-system"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_system</primary>
        </indexterm>
        <function>pg_control_system</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关当前控制文件状态的信息，如 <xref linkend="functions-pg-control-system"/> 所展示。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b8527eb9cd2d42b44ebdcceb04382bed -->

<!-- pgdoc-cn_start sig_en=7162ff8f5b80d77ecb3d98c22faf5cc1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_init</primary>
        </indexterm>
        <function>pg_control_init</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about cluster initialization state, as shown in
        <xref linkend="functions-pg-control-init"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_init</primary>
        </indexterm>
        <function>pg_control_init</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关集群初始化状态的信息，如 <xref linkend="functions-pg-control-init"/>所展示。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7162ff8f5b80d77ecb3d98c22faf5cc1 -->

<!-- pgdoc-cn_start sig_en=228ff17d5ccaeb7324fca5d7584fb1cf sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_recovery</primary>
        </indexterm>
        <function>pg_control_recovery</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about recovery state, as shown in
        <xref linkend="functions-pg-control-recovery"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_recovery</primary>
        </indexterm>
        <function>pg_control_recovery</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关恢复状态的信息,如 <xref linkend="functions-pg-control-recovery"/>所展示。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=228ff17d5ccaeb7324fca5d7584fb1cf -->
     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-checkpoint">
<!-- pgdoc-cn_start sig_en=7fcca564160e01b1fef05b054267141c sig_cn_org=None source=14.1 
    <title><function>pg_control_checkpoint</function> Output Columns</title>
________________________________________________________-->
    <title><function>pg_control_checkpoint</function> 输出列</title>
<!-- pgdoc-cn_end sig_en=7fcca564160e01b1fef05b054267141c -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=5fdf3db1cd90d4fed13488368361aad9 sig_cn_org=None source=14.1 
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
<!-- pgdoc-cn_end sig_en=5fdf3db1cd90d4fed13488368361aad9 -->
     </thead>

     <tbody>

<!-- pgdoc-cn_start sig_en=204ee776e0123734b39e5cc33ba76e67 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>checkpoint_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>checkpoint_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=204ee776e0123734b39e5cc33ba76e67 -->

<!-- pgdoc-cn_start sig_en=45d75382190c53584c63d07c81ca0d07 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>redo_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>redo_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=45d75382190c53584c63d07c81ca0d07 -->

<!-- pgdoc-cn_start sig_en=1f477f3d5557b6840425c469773e0586 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>redo_wal_file</structfield></entry>
       <entry><type>text</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>redo_wal_file</structfield></entry>
       <entry><type>text</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1f477f3d5557b6840425c469773e0586 -->

<!-- pgdoc-cn_start sig_en=7e8e2fa07164ee9d759905b9453168ca sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e8e2fa07164ee9d759905b9453168ca -->

<!-- pgdoc-cn_start sig_en=e37fbb84f1770a07eed1b943ffa79bf9 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>prev_timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>prev_timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e37fbb84f1770a07eed1b943ffa79bf9 -->

<!-- pgdoc-cn_start sig_en=c9cffd9861df106d3498857fe00da137 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>full_page_writes</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>full_page_writes</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c9cffd9861df106d3498857fe00da137 -->

<!-- pgdoc-cn_start sig_en=ba40d261d11678267ac097b1b7b942e7 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>next_xid</structfield></entry>
       <entry><type>text</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>next_xid</structfield></entry>
       <entry><type>text</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ba40d261d11678267ac097b1b7b942e7 -->

<!-- pgdoc-cn_start sig_en=0013c863c8b7cf2ede9e76aec050aaba sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>next_oid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>next_oid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0013c863c8b7cf2ede9e76aec050aaba -->

<!-- pgdoc-cn_start sig_en=b6c8a14b08fecd40b4332da13b95c703 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>next_multixact_id</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>next_multixact_id</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b6c8a14b08fecd40b4332da13b95c703 -->

<!-- pgdoc-cn_start sig_en=a2dfd724b45e6b388db7391632eee5e0 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>next_multi_offset</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>next_multi_offset</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2dfd724b45e6b388db7391632eee5e0 -->

<!-- pgdoc-cn_start sig_en=9660509fac067575a0b6475c78a7eb2e sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9660509fac067575a0b6475c78a7eb2e -->

<!-- pgdoc-cn_start sig_en=93c0a811099e1b2fb8bbbd1bbcdd4ce7 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_xid_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_xid_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=93c0a811099e1b2fb8bbbd1bbcdd4ce7 -->

<!-- pgdoc-cn_start sig_en=17a8f4881706fcda53f6bdc9f23b3865 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_active_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_active_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=17a8f4881706fcda53f6bdc9f23b3865 -->

<!-- pgdoc-cn_start sig_en=99168fadf9e488c1f9ba348eae6fdb3a sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_multi_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_multi_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=99168fadf9e488c1f9ba348eae6fdb3a -->

<!-- pgdoc-cn_start sig_en=74bd6b568750958ceb098de92e65d7b5 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_multi_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_multi_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74bd6b568750958ceb098de92e65d7b5 -->

<!-- pgdoc-cn_start sig_en=18eb5b8e8bbb539d84f6ce3182182025 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>oldest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>oldest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=18eb5b8e8bbb539d84f6ce3182182025 -->

<!-- pgdoc-cn_start sig_en=e5ff86b279f819bde9184409acab05a0 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>newest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>newest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e5ff86b279f819bde9184409acab05a0 -->

<!-- pgdoc-cn_start sig_en=3f865ff4bb430f4bc15df9c11a170622 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>checkpoint_time</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>checkpoint_time</structfield></entry>
       <entry><type>带时区的时间戳</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3f865ff4bb430f4bc15df9c11a170622 -->

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-system">
<!-- pgdoc-cn_start sig_en=5b50121828ab50875f94f8ebd9bda20f sig_cn_org=None source=14.1 
    <title><function>pg_control_system</function> Output Columns</title>
________________________________________________________-->
    <title><function>pg_control_system</function> 输出列</title>
<!-- pgdoc-cn_end sig_en=5b50121828ab50875f94f8ebd9bda20f -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=5fdf3db1cd90d4fed13488368361aad9 sig_cn_org=None source=14.1 
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
<!-- pgdoc-cn_end sig_en=5fdf3db1cd90d4fed13488368361aad9 -->
     </thead>

     <tbody>

<!-- pgdoc-cn_start sig_en=6f3f01132c03fc0f6c992867909c3b05 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>pg_control_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>pg_control_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f3f01132c03fc0f6c992867909c3b05 -->

<!-- pgdoc-cn_start sig_en=f657c30e78480726e31846f429a09e25 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>catalog_version_no</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>catalog_version_no</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f657c30e78480726e31846f429a09e25 -->

<!-- pgdoc-cn_start sig_en=dbb7fdf177c41b18ad2a7cd0957c3450 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>system_identifier</structfield></entry>
       <entry><type>bigint</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>system_identifier</structfield></entry>
       <entry><type>bigint</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbb7fdf177c41b18ad2a7cd0957c3450 -->

<!-- pgdoc-cn_start sig_en=96e9f3d1aebdf9a53e91bbfa1ffbbfd7 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>pg_control_last_modified</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>pg_control_last_modified</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=96e9f3d1aebdf9a53e91bbfa1ffbbfd7 -->

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-init">
<!-- pgdoc-cn_start sig_en=9eae23c663d0f28dea3f09384294195c sig_cn_org=None source=14.1 
    <title><function>pg_control_init</function> Output Columns</title>
________________________________________________________-->
    <title><function>pg_control_init</function> 输出列</title>
<!-- pgdoc-cn_end sig_en=9eae23c663d0f28dea3f09384294195c -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=5fdf3db1cd90d4fed13488368361aad9 sig_cn_org=None source=14.1 
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
<!-- pgdoc-cn_end sig_en=5fdf3db1cd90d4fed13488368361aad9 -->
     </thead>

     <tbody>

<!-- pgdoc-cn_start sig_en=fe1eb36be229932677050a75fb657f46 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>max_data_alignment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>max_data_alignment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fe1eb36be229932677050a75fb657f46 -->

<!-- pgdoc-cn_start sig_en=174adea43c2e7a199a905a59dc0c1fa4 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>database_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>database_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=174adea43c2e7a199a905a59dc0c1fa4 -->

<!-- pgdoc-cn_start sig_en=5ce666e3a3f578b718adb028bdcb2c10 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>blocks_per_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>blocks_per_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5ce666e3a3f578b718adb028bdcb2c10 -->

<!-- pgdoc-cn_start sig_en=792f9635f35c4650006f21f7de4b09af sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>wal_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>wal_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=792f9635f35c4650006f21f7de4b09af -->

<!-- pgdoc-cn_start sig_en=40c2bbb65d7f4962f0015bab3ab3f3c3 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>bytes_per_wal_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>bytes_per_wal_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=40c2bbb65d7f4962f0015bab3ab3f3c3 -->

<!-- pgdoc-cn_start sig_en=44fab07d81986fc457f783f343d2bd37 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>max_identifier_length</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>max_identifier_length</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=44fab07d81986fc457f783f343d2bd37 -->

<!-- pgdoc-cn_start sig_en=ece7fec59b031eae6dbf2dd268aacf82 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>max_index_columns</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>max_index_columns</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ece7fec59b031eae6dbf2dd268aacf82 -->

<!-- pgdoc-cn_start sig_en=57b3ce15c90bdd7f46d2757992d9dba9 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>max_toast_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>max_toast_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=57b3ce15c90bdd7f46d2757992d9dba9 -->

<!-- pgdoc-cn_start sig_en=9dff15a8470587affd5aa0a25e12f684 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>large_object_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>large_object_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9dff15a8470587affd5aa0a25e12f684 -->

<!-- pgdoc-cn_start sig_en=6b2a28a731a06a5fa0824c6abd800acf sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>float8_pass_by_value</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>float8_pass_by_value</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6b2a28a731a06a5fa0824c6abd800acf -->

<!-- pgdoc-cn_start sig_en=6ffbc2c45c1c3c89570a3a6febc59cbf sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>data_page_checksum_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>data_page_checksum_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6ffbc2c45c1c3c89570a3a6febc59cbf -->

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-recovery">
<!-- pgdoc-cn_start sig_en=52bd3e9256dcef61b0068decfcd9a58a sig_cn_org=None source=14.1 
    <title><function>pg_control_recovery</function> Output Columns</title>
________________________________________________________-->
    <title><function>pg_control_recovery</function> 输出列</title>
<!-- pgdoc-cn_end sig_en=52bd3e9256dcef61b0068decfcd9a58a -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=5fdf3db1cd90d4fed13488368361aad9 sig_cn_org=None source=14.1 
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
<!-- pgdoc-cn_end sig_en=5fdf3db1cd90d4fed13488368361aad9 -->
     </thead>

     <tbody>

<!-- pgdoc-cn_start sig_en=607f220b3f69a53556367f1355647230 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>min_recovery_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>min_recovery_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=607f220b3f69a53556367f1355647230 -->

<!-- pgdoc-cn_start sig_en=31df256171b6a57357f3976876b102da sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>min_recovery_end_timeline</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>min_recovery_end_timeline</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=31df256171b6a57357f3976876b102da -->

<!-- pgdoc-cn_start sig_en=29cb046cc348be14be203a03d2bd88a1 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>backup_start_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>backup_start_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=29cb046cc348be14be203a03d2bd88a1 -->

<!-- pgdoc-cn_start sig_en=f78bbbdc93e5fa5e8ae158fb3d7c370a sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>backup_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>backup_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f78bbbdc93e5fa5e8ae158fb3d7c370a -->

<!-- pgdoc-cn_start sig_en=d7be7eb546774bead07ea52229173624 sig_cn_org=None source=14.1 
      <row>
       <entry><structfield>end_of_backup_record_required</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><structfield>end_of_backup_record_required</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d7be7eb546774bead07ea52229173624 -->

     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-admin">
<!-- pgdoc-cn_start sig_en=a249d00a7bac192b9c8811cf8be8b854 sig_cn_org=None source=14.1 
   <title>System Administration Functions</title>
________________________________________________________-->
   <title>系统管理函数</title>
<!-- pgdoc-cn_end sig_en=a249d00a7bac192b9c8811cf8be8b854 -->

<!-- pgdoc-cn_start sig_en=e146fb84d27f1e6298386a3f737278b9 sig_cn_org=None source=14.1 
   <para>
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</productname> installation.
   </para>
________________________________________________________-->
   <para>
    这一节描述的函数被用来控制和监视一个<productname>PostgreSQL</productname>安装。
   </para>
<!-- pgdoc-cn_end sig_en=e146fb84d27f1e6298386a3f737278b9 -->

  <sect2 id="functions-admin-set">
<!-- pgdoc-cn_start sig_en=57ff10879a02beddd5029324b393a0e1 sig_cn_org=None source=14.1 
   <title>Configuration Settings Functions</title>
________________________________________________________-->
   <title>配置设定函数</title>
<!-- pgdoc-cn_end sig_en=57ff10879a02beddd5029324b393a0e1 -->

<!-- pgdoc-cn_start sig_en=cd2ecdb45685ffb287a27ce854a5793d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SET</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SET</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cd2ecdb45685ffb287a27ce854a5793d -->

<!-- pgdoc-cn_start sig_en=5e91e0c56ce8a218c08bb33997e23171 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5e91e0c56ce8a218c08bb33997e23171 -->

<!-- pgdoc-cn_start sig_en=b18296604b3c8f15cfcb5c251021cc81 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b18296604b3c8f15cfcb5c251021cc81 -->

<!-- pgdoc-cn_start sig_en=55abed6e66b9f429b36f348829d31a1b sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-admin-set-table"/> shows the functions
    available to query and alter run-time configuration parameters.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-set-table"/>展示了那些可以用于查询以及修改运行时配置参数的函数。
   </para>
<!-- pgdoc-cn_end sig_en=55abed6e66b9f429b36f348829d31a1b -->

   <table id="functions-admin-set-table">
<!-- pgdoc-cn_start sig_en=57ff10879a02beddd5029324b393a0e1 sig_cn_org=None source=14.1 
    <title>Configuration Settings Functions</title>
________________________________________________________-->
    <title>配置设定函数</title>
<!-- pgdoc-cn_end sig_en=57ff10879a02beddd5029324b393a0e1 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=dbcc2657eabdafd26c8bacb33fc0a364 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <function>current_setting</function> ( <parameter>setting_name</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the current value of the
        setting <parameter>setting_name</parameter>.  If there is no such
        setting, <function>current_setting</function> throws an error
        unless <parameter>missing_ok</parameter> is supplied and
        is <literal>true</literal> (in which case NULL is returned).
        This function corresponds to
        the <acronym>SQL</acronym> command <xref linkend="sql-show"/>.
       </para>
       <para>
        <literal>current_setting('datestyle')</literal>
        <returnvalue>ISO, MDY</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <function>current_setting</function> ( <parameter>setting_name</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回设置的<parameter>setting_name</parameter>的当前值。
        如果没有这样的设置，<function>current_setting</function>将抛出一个错误，除非<parameter>missing_ok</parameter>被提供并且为<literal>true</literal>(在此情况下返回NULL)。
        这个函数对应于<acronym>SQL</acronym>命令<xref linkend="sql-show"/>。
       </para>
       <para>
        <literal>current_setting('datestyle')</literal>
        <returnvalue>ISO, MDY</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbcc2657eabdafd26c8bacb33fc0a364 -->

<!-- pgdoc-cn_start sig_en=e46efe190070ab25b8588787aa39bd43 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <function>set_config</function> (
          <parameter>setting_name</parameter> <type>text</type>,
          <parameter>new_value</parameter> <type>text</type>,
          <parameter>is_local</parameter> <type>boolean</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Sets the parameter <parameter>setting_name</parameter>
        to <parameter>new_value</parameter>, and returns that value.
        If <parameter>is_local</parameter> is <literal>true</literal>, the new
        value will only apply during the current transaction. If you want the
        new value to apply for the rest of the current session,
        use <literal>false</literal> instead. This function corresponds to
        the SQL command <xref linkend="sql-set"/>.
       </para>
       <para>
        <literal>set_config('log_statement_stats', 'off', false)</literal>
        <returnvalue>off</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <function>set_config</function> (
          <parameter>setting_name</parameter> <type>text</type>,
          <parameter>new_value</parameter> <type>text</type>,
          <parameter>is_local</parameter> <type>boolean</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将参数<parameter>setting_name</parameter>设置为<parameter>new_value</parameter>，并返回该值。
        如果<parameter>is_local</parameter>为<literal>true</literal>，新值将仅在当前事务期间应用。
        如果您希望新值应用于当前会话的其余部分，请使用<literal>false</literal>代替。这个函数对应于SQL命令<xref linkend="sql-set"/>。
       </para>
       <para>
        <literal>set_config('log_statement_stats', 'off', false)</literal>
        <returnvalue>off</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e46efe190070ab25b8588787aa39bd43 -->
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-signal">
<!-- pgdoc-cn_start sig_en=a020cb644811e207e9da8d005a37f9d4 sig_cn_org=None source=14.1 
   <title>Server Signaling Functions</title>
________________________________________________________-->
   <title>服务器信号函数</title>
<!-- pgdoc-cn_end sig_en=a020cb644811e207e9da8d005a37f9d4 -->

<!-- pgdoc-cn_start sig_en=26113a658d6c0d54a016317f9eca787f sig_cn_org=None source=14.1 
   <indexterm>
    <primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>信号</primary>
    <secondary sortas="backend">后端进程</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=26113a658d6c0d54a016317f9eca787f -->

<!-- pgdoc-cn_start sig_en=2b32fcac2e1302d7c57e68afcc534698 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref
    linkend="functions-admin-signal-table"/> send control signals to
    other server processes.  Use of these functions is restricted to
    superusers by default but access may be granted to others using
    <command>GRANT</command>, with noted exceptions.
   </para>
________________________________________________________-->
   <para>
    在<xref linkend="functions-admin-signal-table"/>中展示的函数向其它服务器进程发送控制信号。默认情况下这些函数只能被超级用户使用，但是如果需要，可以利用<command>GRANT</command>把访问特权授予给其他用户。
   </para>
<!-- pgdoc-cn_end sig_en=2b32fcac2e1302d7c57e68afcc534698 -->

<!-- pgdoc-cn_start sig_en=b44f32c9456e8ceb0c80189352e2bc00 sig_cn_org=None source=14.1 
   <para>
    Each of these functions returns <literal>true</literal> if
    the signal was successfully sent and <literal>false</literal>
    if sending the signal failed.
   </para>
________________________________________________________-->
   <para>
    每个这样的函数如果信号成功发出则返回<literal>true</literal>，如果发送信号失败则返回<literal>false</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=b44f32c9456e8ceb0c80189352e2bc00 -->

   <table id="functions-admin-signal-table">
<!-- pgdoc-cn_start sig_en=a020cb644811e207e9da8d005a37f9d4 sig_cn_org=None source=14.1 
    <title>Server Signaling Functions</title>
________________________________________________________-->
    <title>服务器信号函数</title>
<!-- pgdoc-cn_end sig_en=a020cb644811e207e9da8d005a37f9d4 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=92978ec5914a6344db16c7b80454e815 sig_cn_org=c05c1b79b10f009ebfe10e4fcdd91747 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_cancel_backend</primary>
        </indexterm>
        <function>pg_cancel_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Cancels the current query of the session whose backend process has the
        specified process ID.  This is also allowed if the
        calling role is a member of the role whose backend is being canceled or
        the calling role has privileges of <literal>pg_signal_backend</literal>,
        however only superusers can cancel superuser backends.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_cancel_backend</primary>
        </indexterm>
        <function>pg_cancel_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        取消具有指定进程ID的后端进程的会话的当前查询。如果调用角色是被取消的后端进程所属角色的成员，
        或者调用角色具有<literal>pg_signal_backend</literal>的权限，则也允许执行此操作，但只有超级用户可以取消超级用户后端进程。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=92978ec5914a6344db16c7b80454e815 -->

<!-- pgdoc-cn_start sig_en=dc30f5564d99603738e8e5eac3eeba78 sig_cn_org=f1c0d970ad8985cd38d94cc644dbfcac source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_log_backend_memory_contexts</primary>
        </indexterm>
        <function>pg_log_backend_memory_contexts</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Requests to log the memory contexts of the backend with the
        specified process ID.  This function can send the request to
        backends and auxiliary processes except logger.  These memory contexts
        will be logged at
        <literal>LOG</literal> message level. They will appear in
        the server log based on the log configuration set
        (see <xref linkend="runtime-config-logging"/> for more information),
        but will not be sent to the client regardless of
        <xref linkend="guc-client-min-messages"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_log_backend_memory_contexts</primary>
        </indexterm>
        <function>pg_log_backend_memory_contexts</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        请求记录具有指定进程ID的后端的内存上下文。此函数可以将请求发送到后端和辅助进程，但不包括记录器。这些内存上下文将以
        <literal>LOG</literal>消息级别记录。它们将根据设置的日志配置出现在服务器日志中
        (有关更多信息，请参见<xref linkend="runtime-config-logging"/>)，
        但无论如何都不会发送给客户端
        (<xref linkend="guc-client-min-messages"/>)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dc30f5564d99603738e8e5eac3eeba78 -->

<!-- pgdoc-cn_start sig_en=af685d131327d580f530aa95bdfe1bd0 sig_cn_org=6783857a530ec82e1f8408a0ac01b9cb source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_reload_conf</primary>
        </indexterm>
        <function>pg_reload_conf</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Causes all processes of the <productname>PostgreSQL</productname>
        server to reload their configuration files.  (This is initiated by
        sending a <systemitem>SIGHUP</systemitem> signal to the postmaster
        process, which in turn sends <systemitem>SIGHUP</systemitem> to each
        of its children.) You can use the
        <link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link>,
        <link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link> and
        <link linkend="view-pg-ident-file-mappings"><structname>pg_ident_file_mappings</structname></link> views
        to check the configuration files for possible errors, before reloading.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_reload_conf</primary>
        </indexterm>
        <function>pg_reload_conf</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        使<productname>PostgreSQL</productname>服务器的所有进程重新加载其配置文件。
		（这是通过向postmaster进程发送<systemitem>SIGHUP</systemitem>信号来启动的，
		postmaster进程又向其每个子进程发送<systemitem>SIGHUP</systemitem>。）
		您可以使用<link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link>、
		<link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>和
		<link linkend="view-pg-ident-file-mappings"><structname>pg_ident_file_mappings</structname></link>视图来检查可能存在的错误，
		然后再重新加载配置文件。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=af685d131327d580f530aa95bdfe1bd0 -->

<!-- pgdoc-cn_start sig_en=7db56730d558607bdd28bb4d4ffe5a7b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_rotate_logfile</primary>
        </indexterm>
        <function>pg_rotate_logfile</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Signals the log-file manager to switch to a new output file
        immediately.  This works only when the built-in log collector is
        running, since otherwise there is no log-file manager subprocess.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_rotate_logfile</primary>
        </indexterm>
        <function>pg_rotate_logfile</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        通知日志文件管理器立即切换到一个新的输出文件。
        这仅在内置日志采集器运行时有效，因为否则没有日志文件管理器子进程。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7db56730d558607bdd28bb4d4ffe5a7b -->

<!-- pgdoc-cn_start sig_en=7bb966c7b669834d6378665c8acf147a sig_cn_org=5954e1fb9a665234d025ac54409e15db source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_terminate_backend</primary>
        </indexterm>
        <function>pg_terminate_backend</function> ( <parameter>pid</parameter> <type>integer</type>, <parameter>timeout</parameter> <type>bigint</type> <literal>DEFAULT</literal> <literal>0</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Terminates the session whose backend process has the
        specified process ID.  This is also allowed if the calling role
        is a member of the role whose backend is being terminated or the
        calling role has privileges of <literal>pg_signal_backend</literal>,
        however only superusers can terminate superuser backends.
       </para>
       <para>
        If <parameter>timeout</parameter> is not specified or zero, this
        function returns <literal>true</literal> whether the process actually
        terminates or not, indicating only that the sending of the signal was
        successful.  If the <parameter>timeout</parameter> is specified (in
        milliseconds) and greater than zero, the function waits until the
        process is actually terminated or until the given time has passed. If
        the process is terminated, the function
        returns <literal>true</literal>.  On timeout, a warning is emitted and
        <literal>false</literal> is returned.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_terminate_backend</primary>
        </indexterm>
        <function>pg_terminate_backend</function> ( <parameter>pid</parameter> <type>integer</type>, <parameter>timeout</parameter> <type>bigint</type> <literal>DEFAULT</literal> <literal>0</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        终止具有指定进程ID的后端进程的会话。如果调用角色是正在终止的后端的角色的成员，或者调用角色具有<literal>pg_signal_backend</literal>的权限，则也允许执行此操作，但只有超级用户才能终止超级用户后端。
       </para>
       <para>
        如果未指定或超时<parameter>timeout</parameter>为零，则此函数无论进程是否实际终止，都将返回<literal>true</literal>，仅表示信号发送成功。如果指定了<parameter>timeout</parameter>（以毫秒为单位）且大于零，则函数将等待直到进程实际终止或直到给定时间已过。如果进程被终止，函数将返回<literal>true</literal>。在超时时，会发出警告并返回<literal>false</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7bb966c7b669834d6378665c8acf147a -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=59ce5b4d4982063363cae3948056ca18 sig_cn_org=None source=14.1 
   <para>
    <function>pg_cancel_backend</function> and <function>pg_terminate_backend</function>
    send signals (<systemitem>SIGINT</systemitem> or <systemitem>SIGTERM</systemitem>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</application> on Unix or the <application>Task
    Manager</application> on <productname>Windows</productname>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
   </para>
________________________________________________________-->
   <para>
    <function>pg_cancel_backend</function>和<function>pg_terminate_backend</function>向由进程 ID 标识的后端进程发送信号（分别是<systemitem>SIGINT</systemitem>或<systemitem>SIGTERM</systemitem>）。
    一个活动后端的进程 ID可以从<structname>pg_stat_activity</structname>视图的<structfield>pid</structfield>列中找到，或者通过在服务器上列出<command>postgres</command>进程（在 Unix 上使用<application>ps</application>或者在<productname>Windows</productname>上使用<application>任务管理器</application>）得到。
    一个活动后端的角色可以在<structname>pg_stat_activity</structname>视图的<structfield>usename</structfield>列中找到。
   </para>
<!-- pgdoc-cn_end sig_en=59ce5b4d4982063363cae3948056ca18 -->

<!-- pgdoc-cn_start sig_en=1ff2368218e86aebcdf53ddc619493d1 sig_cn_org=ba846556c2558d01655a61d66ceded31 source=15.7 
   <para>
    <function>pg_log_backend_memory_contexts</function> can be used
    to log the memory contexts of a backend process. For example:
<programlisting>
postgres=# SELECT pg_log_backend_memory_contexts(pg_backend_pid());
 pg_log_backend_memory_contexts
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
</programlisting>
One message for each memory context will be logged. For example:
<screen>
LOG:  logging memory contexts of PID 10377
STATEMENT:  SELECT pg_log_backend_memory_contexts(pg_backend_pid());
LOG:  level: 0; TopMemoryContext: 80800 total in 6 blocks; 14432 free (5 chunks); 66368 used
LOG:  level: 1; pgstat TabStatusArray lookup hash table: 8192 total in 1 blocks; 1408 free (0 chunks); 6784 used
LOG:  level: 1; TopTransactionContext: 8192 total in 1 blocks; 7720 free (1 chunks); 472 used
LOG:  level: 1; RowDescriptionContext: 8192 total in 1 blocks; 6880 free (0 chunks); 1312 used
LOG:  level: 1; MessageContext: 16384 total in 2 blocks; 5152 free (0 chunks); 11232 used
LOG:  level: 1; Operator class cache: 8192 total in 1 blocks; 512 free (0 chunks); 7680 used
LOG:  level: 1; smgr relation table: 16384 total in 2 blocks; 4544 free (3 chunks); 11840 used
LOG:  level: 1; TransactionAbortContext: 32768 total in 1 blocks; 32504 free (0 chunks); 264 used
...
LOG:  level: 1; ErrorContext: 8192 total in 1 blocks; 7928 free (3 chunks); 264 used
LOG:  Grand total: 1651920 bytes in 201 blocks; 622360 free (88 chunks); 1029560 used
</screen>
    If there are more than 100 child contexts under the same parent, the first
    100 child contexts are logged, along with a summary of the remaining contexts.
    Note that frequent calls to this function could incur significant overhead,
    because it may generate a large number of log messages.
   </para>
________________________________________________________-->
   <para>
    <function>pg_log_backend_memory_contexts</function>可以用来记录后端进程的内存上下文。例如：
<programlisting>
postgres=# SELECT pg_log_backend_memory_contexts(pg_backend_pid());
 pg_log_backend_memory_contexts
--------------------------------
 t
(1 row)
</programlisting>
每个内存上下文将被记录一条消息。例如：
<screen>
LOG:  logging memory contexts of PID 10377
STATEMENT:  SELECT pg_log_backend_memory_contexts(pg_backend_pid());
LOG:  level: 0; TopMemoryContext: 80800 total in 6 blocks; 14432 free (5 chunks); 66368 used
LOG:  level: 1; pgstat TabStatusArray lookup hash table: 8192 total in 1 blocks; 1408 free (0 chunks); 6784 used
LOG:  level: 1; TopTransactionContext: 8192 total in 1 blocks; 7720 free (1 chunks); 472 used
LOG:  level: 1; RowDescriptionContext: 8192 total in 1 blocks; 6880 free (0 chunks); 1312 used
LOG:  level: 1; MessageContext: 16384 total in 2 blocks; 5152 free (0 chunks); 11232 used
LOG:  level: 1; Operator class cache: 8192 total in 1 blocks; 512 free (0 chunks); 7680 used
LOG:  level: 1; smgr relation table: 16384 total in 2 blocks; 4544 free (3 chunks); 11840 used
LOG:  level: 1; TransactionAbortContext: 32768 total in 1 blocks; 32504 free (0 chunks); 264 used
...
LOG:  level: 1; ErrorContext: 8192 total in 1 blocks; 7928 free (3 chunks); 264 used
LOG:  Grand total: 1651920 bytes in 201 blocks; 622360 free (88 chunks); 1029560 used
</screen>
    如果在同一父级下有超过100个子上下文，则将记录前100个子上下文，并附上其余上下文的摘要。
    请注意，频繁调用此函数可能会产生显著的开销，因为它可能会生成大量的日志消息。
   </para>
<!-- pgdoc-cn_end sig_en=1ff2368218e86aebcdf53ddc619493d1 -->

  </sect2>

  <sect2 id="functions-admin-backup">
<!-- pgdoc-cn_start sig_en=88bdcb0ba3c46bac5795ec01cf3e0601 sig_cn_org=None source=14.1 
   <title>Backup Control Functions</title>
________________________________________________________-->
   <title>备份控制函数</title>
<!-- pgdoc-cn_end sig_en=88bdcb0ba3c46bac5795ec01cf3e0601 -->

<!-- pgdoc-cn_start sig_en=c98a1b12cc9469a774694495f4c1412c sig_cn_org=None source=14.1 
   <indexterm>
    <primary>backup</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>backup</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c98a1b12cc9469a774694495f4c1412c -->

<!-- pgdoc-cn_start sig_en=d2f6fe5c7c6f47de34244062a16ae145 sig_cn_org=a3f0d7300b9535afd25963d10f8f950d source=15.7 
   <para>
    The functions shown in <xref
    linkend="functions-admin-backup-table"/> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    <function>pg_backup_start</function>,
    <function>pg_backup_stop</function>,
    and <function>pg_wal_lsn_diff</function>).
   </para>
________________________________________________________-->
   <para>
    在<xref linkend="functions-admin-backup-table"/>中显示的函数有助于进行在线备份。
    这些函数在恢复过程中无法执行（除了<function>pg_backup_start</function>、
    <function>pg_backup_stop</function>和<function>pg_wal_lsn_diff</function>）。
</para>
<!-- pgdoc-cn_end sig_en=d2f6fe5c7c6f47de34244062a16ae145 -->

<!-- pgdoc-cn_start sig_en=9d8195404cbed8f789b8336198821d4e sig_cn_org=None source=14.1 
   <para>
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving"/>.
   </para>
________________________________________________________-->
   <para>
    有关正确使用这些函数的详细信息，参见<xref linkend="continuous-archiving"/>。
   </para>
<!-- pgdoc-cn_end sig_en=9d8195404cbed8f789b8336198821d4e -->

   <table id="functions-admin-backup-table">
<!-- pgdoc-cn_start sig_en=88bdcb0ba3c46bac5795ec01cf3e0601 sig_cn_org=None source=14.1 
    <title>Backup Control Functions</title>
________________________________________________________-->
    <title>备份控制函数</title>
<!-- pgdoc-cn_end sig_en=88bdcb0ba3c46bac5795ec01cf3e0601 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=54c5cb41a92f79080dcd4e1159f06422 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_restore_point</primary>
        </indexterm>
        <function>pg_create_restore_point</function> ( <parameter>name</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Creates a named marker record in the write-ahead log that can later be
        used as a recovery target, and returns the corresponding write-ahead
        log location.  The given name can then be used with
        <xref linkend="guc-recovery-target-name"/> to specify the point up to
        which recovery will proceed.  Avoid creating multiple restore points
        with the same name, since recovery will stop at the first one whose
        name matches the recovery target.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_restore_point</primary>
        </indexterm>
        <function>pg_create_restore_point</function> ( <parameter>name</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        在预写式日志中创建一个命名标记记录，稍后可以将其用作恢复目标，并返回相应的预写日志位置。
        然后可以将给定的名称与 <xref linkend="guc-recovery-target-name"/>一起使用，以指定进行恢复的点。
        要避免创建多个名称相同的恢复点，因为恢复将在第一个名称与恢复目标匹配的恢复点停止。
       </para>
       <para>
        默认情况下，该函数仅限超级用户使用，但可以授权给其他用户执行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=54c5cb41a92f79080dcd4e1159f06422 -->

<!-- pgdoc-cn_start sig_en=52b0295e9dad121ead290dc483975ff0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_flush_lsn</primary>
        </indexterm>
        <function>pg_current_wal_flush_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log flush location (see notes below).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_flush_lsn</primary>
        </indexterm>
        <function>pg_current_wal_flush_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预写式日志刷新位置(参见下面的说明)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=52b0295e9dad121ead290dc483975ff0 -->

<!-- pgdoc-cn_start sig_en=82ac184d79a2e9e20bee157bd9cc4c7b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_insert_lsn</primary>
        </indexterm>
        <function>pg_current_wal_insert_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log insert location (see notes below).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_insert_lsn</primary>
        </indexterm>
        <function>pg_current_wal_insert_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预式日志插入位置(参见下面的说明)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=82ac184d79a2e9e20bee157bd9cc4c7b -->

<!-- pgdoc-cn_start sig_en=92f8d4bd4612ef77963b675115947274 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_lsn</primary>
        </indexterm>
        <function>pg_current_wal_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log write location (see notes below).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_lsn</primary>
        </indexterm>
        <function>pg_current_wal_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预写式日志写位置(参见下面的说明)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=92f8d4bd4612ef77963b675115947274 -->

<!-- pgdoc-cn_start sig_en=09162f0992478ddede9c18f2d481bc32 sig_cn_org=1859b0e4ad52fc19c9fb7c707b0a47ca source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_start</primary>
        </indexterm>
        <function>pg_backup_start</function> (
          <parameter>label</parameter> <type>text</type>
          <optional>, <parameter>fast</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Prepares the server to begin an on-line backup.  The only required
        parameter is an arbitrary user-defined label for the backup.
        (Typically this would be the name under which the backup dump file
        will be stored.)
        If the optional second parameter is given as <literal>true</literal>,
        it specifies executing <function>pg_backup_start</function> as quickly
        as possible.  This forces an immediate checkpoint which will cause a
        spike in I/O operations, slowing any concurrently executing queries.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_start</primary>
        </indexterm>
        <function>pg_backup_start</function> (
          <parameter>label</parameter> <type>text</type>
          <optional>, <parameter>fast</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        准备服务器开始在线备份。唯一必需的参数是备份的任意用户定义标签。
        （通常这将是备份转储文件存储的名称。）
        如果将可选的第二个参数指定为<literal>true</literal>，
        它将尽快执行<function>pg_backup_start</function>。这将强制立即进行检查点，
        这将导致I/O操作的激增，从而减慢任何同时执行的查询。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户，但可以授予其他用户执行权限以运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=09162f0992478ddede9c18f2d481bc32 -->

<!-- pgdoc-cn_start sig_en=8345177bbd4b7afb8fb0976f96b3dbfb sig_cn_org=bad377f7acda440396a0bdfd4ea6bea0 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_stop</primary>
        </indexterm>
        <function>pg_backup_stop</function> (
          <optional><parameter>wait_for_archive</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>labelfile</parameter> <type>text</type>,
        <parameter>spcmapfile</parameter> <type>text</type> )
       </para>
       <para>
        Finishes performing an on-line backup.  The desired contents of the
        backup label file and the tablespace map file are returned as part of
        the result of the function and must be written to files in the
        backup area.  These files must not be written to the live data directory
        (doing so will cause PostgreSQL to fail to restart in the event of a
        crash).
       </para>
       <para>
        There is an optional parameter of type <type>boolean</type>.
        If false, the function will return immediately after the backup is
        completed, without waiting for WAL to be archived.  This behavior is
        only useful with backup software that independently monitors WAL
        archiving.  Otherwise, WAL required to make the backup consistent might
        be missing and make the backup useless.  By default or when this
        parameter is true, <function>pg_backup_stop</function> will wait for
        WAL to be archived when archiving is enabled.  (On a standby, this
        means that it will wait only when <varname>archive_mode</varname> =
        <literal>always</literal>.  If write activity on the primary is low,
        it may be useful to run <function>pg_switch_wal</function> on the
        primary in order to trigger an immediate segment switch.)
       </para>
       <para>
        When executed on a primary, this function also creates a backup
        history file in the write-ahead log archive area.  The history file
        includes the label given to <function>pg_backup_start</function>, the
        starting and ending write-ahead log locations for the backup, and the
        starting and ending times of the backup.  After recording the ending
        location, the current write-ahead log insertion point is automatically
        advanced to the next write-ahead log file, so that the ending
        write-ahead log file can be archived immediately to complete the
        backup.
       </para>
       <para>
        The result of the function is a single record.
        The <parameter>lsn</parameter> column holds the backup's ending
        write-ahead log location (which again can be ignored).  The second
        column returns the contents of the backup label file, and the third
        column returns the contents of the tablespace map file.  These must be
        stored as part of the backup and are required as part of the restore
        process.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_stop</primary>
        </indexterm>
        <function>pg_backup_stop</function> (
          <optional><parameter>wait_for_archive</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>labelfile</parameter> <type>text</type>,
        <parameter>spcmapfile</parameter> <type>text</type> )
       </para>
       <para>
        完成在线备份。函数的结果中返回备份标签文件和表空间映射文件的期望内容，并必须写入备份区域的文件中。
        这些文件不得写入实时数据目录（这样做将导致PostgreSQL在崩溃时无法重新启动）。
       </para>
       <para>
        有一个类型为<type>boolean</type>的可选参数。
        如果为false，则在备份完成后立即返回，而无需等待WAL进行归档。
        此行为仅适用于独立监视WAL归档的备份软件。否则，可能会缺少使备份一致所需的WAL，使备份无效。
        默认情况下或当此参数为true时，<function>pg_backup_stop</function>将在启用归档时等待WAL进行归档。
        （在备用机上，这意味着仅当<varname>archive_mode</varname> = <literal>always</literal>时才会等待。
        如果主机上的写入活动较低，则可能有必要在主机上运行<function>pg_switch_wal</function>以触发立即段切换。）
       </para>
       <para>
        在主机上执行时，此函数还会在预写式日志归档区域中创建一个备份历史文件。
        历史文件包括给定给<function>pg_backup_start</function>的标签、备份的起始和结束预写式日志位置，以及备份的起始和结束时间。
        在记录结束位置后，当前的预写式日志插入点会自动前进到下一个预写式日志文件，以便立即归档结束的预写式日志文件以完成备份。
       </para>
       <para>
        函数的结果是一个记录。
        <parameter>lsn</parameter>列保存备份的结束预写式日志位置（可以忽略）。
        第二列返回备份标签文件的内容，第三列返回表空间映射文件的内容。
        这些必须作为备份的一部分存储，并作为恢复过程的一部分。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户，但可以授予其他用户EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8345177bbd4b7afb8fb0976f96b3dbfb -->

<!-- pgdoc-cn_start sig_en=cdbf158e9a8b5486dc826e8cdd199f80 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_switch_wal</primary>
        </indexterm>
        <function>pg_switch_wal</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Forces the server to switch to a new write-ahead log file, which
        allows the current file to be archived (assuming you are using
        continuous archiving).  The result is the ending write-ahead log
        location plus 1 within the just-completed write-ahead log file.  If
        there has been no write-ahead log activity since the last write-ahead
        log switch, <function>pg_switch_wal</function> does nothing and
        returns the start location of the write-ahead log file currently in
        use.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_switch_wal</primary>
        </indexterm>
        <function>pg_switch_wal</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        强制服务器切换到一个新的预写式日志文件，这允许对当前文件进行归档(假设你正在使用连续归档)。
        其结果是在刚刚完成的预写式日志文件中结束预写式日志位置加1。
        如果自从上次预写式日志切换以来没有提前写日志活动，<function>pg_switch_wal</function>将不做任何操作，并返回当前正在使用的提前写日志文件的起始位置。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cdbf158e9a8b5486dc826e8cdd199f80 -->

<!-- pgdoc-cn_start sig_en=7a8fdc10a223eb5be3f7d77a4afa3e8f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name</primary>
        </indexterm>
        <function>pg_walfile_name</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts a write-ahead log location to the name of the WAL file
        holding that location.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name</primary>
        </indexterm>
        <function>pg_walfile_name</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将预写式日志位置转换为保持该位置的WAL文件的名称。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7a8fdc10a223eb5be3f7d77a4afa3e8f -->

<!-- pgdoc-cn_start sig_en=69fa7ec7e5c890678283deaf7b9d30c7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name_offset</primary>
        </indexterm>
        <function>pg_walfile_name_offset</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>file_name</parameter> <type>text</type>,
        <parameter>file_offset</parameter> <type>integer</type> )
       </para>
       <para>
        Converts a write-ahead log location to a WAL file name and byte offset
        within that file.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name_offset</primary>
        </indexterm>
        <function>pg_walfile_name_offset</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>file_name</parameter> <type>text</type>,
        <parameter>file_offset</parameter> <type>integer</type> )
       </para>
       <para>
        将预写式日志位置转换为WAL文件名和该文件中的字节偏移量。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69fa7ec7e5c890678283deaf7b9d30c7 -->

<!-- pgdoc-cn_start sig_en=e152fc5092e3aa1b4d50b25c12f4f410 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_lsn_diff</primary>
        </indexterm>
        <function>pg_wal_lsn_diff</function> ( <parameter>lsn1</parameter> <type>pg_lsn</type>, <parameter>lsn2</parameter> <type>pg_lsn</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Calculates the difference in bytes (<parameter>lsn1</parameter> - <parameter>lsn2</parameter>) between two write-ahead log
        locations.  This can be used
        with <structname>pg_stat_replication</structname> or some of the
        functions shown in <xref linkend="functions-admin-backup-table"/> to
        get the replication lag.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_lsn_diff</primary>
        </indexterm>
        <function>pg_wal_lsn_diff</function> ( <parameter>lsn1</parameter> <type>pg_lsn</type>, <parameter>lsn2</parameter> <type>pg_lsn</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        计算两个预写式日志位置之间的字节(<parameter>lsn1</parameter> - <parameter>lsn2</parameter>)差异。
        这可以与<structname>pg_stat_replication</structname>或<xref linkend="functions-admin-backup-table"/>中所示的一些函数一起使用，以获得复制延迟。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e152fc5092e3aa1b4d50b25c12f4f410 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=aefd6b12bdd4aa7d1a424e24671800b9 sig_cn_org=None source=14.1 
   <para>
    <function>pg_current_wal_lsn</function> displays the current write-ahead
    log write location in the same format used by the above functions.
    Similarly, <function>pg_current_wal_insert_lsn</function> displays the
    current write-ahead log insertion location
    and <function>pg_current_wal_flush_lsn</function> displays the current
    write-ahead log flush location. The insertion location is
    the <quote>logical</quote> end of the write-ahead log at any instant,
    while the write location is the end of what has actually been written out
    from the server's internal buffers, and the flush location is the last
    location known to be written to durable storage. The write location is the
    end of what can be examined from outside the server, and is usually what
    you want if you are interested in archiving partially-complete write-ahead
    log files.  The insertion and flush locations are made available primarily
    for server debugging purposes.  These are all read-only operations and do
    not require superuser permissions.
   </para>
________________________________________________________-->
   <para>
    <function>pg_current_wal_lsn</function> 显示当前预写式日志写位置，与上述函数所用的格式相同。
    类似地，<function>pg_current_wal_insert_lsn</function>显示当前预写式日志插入位置，<function>pg_current_wal_flush_lsn</function>显示当前预写式日志刷新位置。
    插入位置是预写式日志在任何时刻的<quote>逻辑(logical)</quote> 结束，而写位置是已经从服务器内部缓冲区实际写入的内容的结束，而刷新位置是已知的要写入持久化存储的最后一个位置。
    写位置是可以从服务器外部检查的最后位置，如果你对归档部分完成的预写式日志文件感兴趣，那么它通常就是你想要的位置。
    插入和刷新位置主要用于服务器调试目的。这些都是只读操作，不需要超级用户权限。
   </para>
<!-- pgdoc-cn_end sig_en=aefd6b12bdd4aa7d1a424e24671800b9 -->

<!-- pgdoc-cn_start sig_en=f325dca100fb56817dc76b5675c388ac sig_cn_org=b190666909a976e1120e94232804b84d source=15.7 
   <para>
    You can use <function>pg_walfile_name_offset</function> to extract the
    corresponding write-ahead log file name and byte offset from
    a <type>pg_lsn</type> value.  For example:
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset((pg_backup_stop()).lsn);
        file_name         | file_offset
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    Similarly, <function>pg_walfile_name</function> extracts just the write-ahead log file name.
    When the given write-ahead log location is exactly at a write-ahead log file boundary, both
    these functions return the name of the preceding write-ahead log file.
    This is usually the desired behavior for managing write-ahead log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived.
   </para>
________________________________________________________-->
   <para>
    您可以使用<function>pg_walfile_name_offset</function>从<type>pg_lsn</type>值中提取相应的预写式日志文件名和字节偏移量。例如：
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset((pg_backup_stop()).lsn);
        file_name         | file_offset
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    类似地，<function>pg_walfile_name</function>仅提取预写式日志文件名。
    当给定的预写式日志位置恰好位于预写式日志文件边界时，这两个函数都会返回前一个预写式日志文件的名称。
    这通常是管理预写式日志归档行为的期望行为，因为前一个文件是当前需要归档的最后一个文件。
   </para>
<!-- pgdoc-cn_end sig_en=f325dca100fb56817dc76b5675c388ac -->

  </sect2>

  <sect2 id="functions-recovery-control">
<!-- pgdoc-cn_start sig_en=e80b25d40aab29a470199bf3954b3767 sig_cn_org=None source=14.1 
   <title>Recovery Control Functions</title>
________________________________________________________-->
   <title>恢复控制函数</title>
<!-- pgdoc-cn_end sig_en=e80b25d40aab29a470199bf3954b3767 -->

<!-- pgdoc-cn_start sig_en=511d1d5be5e55f222e87991943c162ac sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref
    linkend="functions-recovery-info-table"/> provide information
    about the current status of a standby server.
    These functions may be executed both during recovery and in normal running.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-recovery-info-table"/>中展示的函数提供有关后备服务器当前状态的信息。
    这些函数可以在恢复或普通运行过程中被执行。
   </para>
<!-- pgdoc-cn_end sig_en=511d1d5be5e55f222e87991943c162ac -->

   <table id="functions-recovery-info-table">
<!-- pgdoc-cn_start sig_en=998163deda21a37828bdf6ef6a2ed57d sig_cn_org=None source=14.1 
    <title>Recovery Information Functions</title>
________________________________________________________-->
    <title>恢复信息函数</title>
<!-- pgdoc-cn_end sig_en=998163deda21a37828bdf6ef6a2ed57d -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=d38affb29f505d3b7b48155011711a10 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_recovery</primary>
        </indexterm>
        <function>pg_is_in_recovery</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if recovery is still in progress.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_recovery</primary>
        </indexterm>
        <function>pg_is_in_recovery</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果恢复仍在进行则返回真。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d38affb29f505d3b7b48155011711a10 -->

<!-- pgdoc-cn_start sig_en=dedefe6f3161d1d5a21237fde1e0eeaa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_receive_lsn</primary>
        </indexterm>
        <function>pg_last_wal_receive_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the last write-ahead log location that has been received and
        synced to disk by streaming replication. While streaming replication
        is in progress this will increase monotonically. If recovery has
        completed then this will remain static at the location of the last WAL
        record received and synced to disk during recovery. If streaming
        replication is disabled, or if it has not yet started, the function
        returns <literal>NULL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_receive_lsn</primary>
        </indexterm>
        <function>pg_last_wal_receive_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回已接收并通过流复制同步到磁盘的最后一个预写式日志位置。
        当流复制正在进行时这将单调地增加。如果恢复已经完成，那么在恢复期间，接收到的最后一条WAL记录的位置将保持静态，并同步到磁盘。
        如果流复制已禁用，或者尚未启动，函数将返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dedefe6f3161d1d5a21237fde1e0eeaa -->

<!-- pgdoc-cn_start sig_en=0608b6534af13cfc628c365dd84724b3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_replay_lsn</primary>
        </indexterm>
        <function>pg_last_wal_replay_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the last write-ahead log location that has been replayed
        during recovery.  If recovery is still in progress this will increase
        monotonically.  If recovery has completed then this will remain
        static at the location of the last WAL record applied during recovery.
        When the server has been started normally without recovery, the
        function returns <literal>NULL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_replay_lsn</primary>
        </indexterm>
        <function>pg_last_wal_replay_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回恢复期间重新播放的最后一个预写式日志位置。如果恢复仍在进行中这将会单调地增加。
        如果恢复已经完成，那么恢复期间应用的最后WAL记录的位置将保持静态。当服务器正常启动且没有恢复时，函数返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0608b6534af13cfc628c365dd84724b3 -->

<!-- pgdoc-cn_start sig_en=31b713c2d39fd1831dc32778ef04b2b2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_xact_replay_timestamp</primary>
        </indexterm>
        <function>pg_last_xact_replay_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time stamp of the last transaction replayed during
        recovery.  This is the time at which the commit or abort WAL record
        for that transaction was generated on the primary.  If no transactions
        have been replayed during recovery, the function
        returns <literal>NULL</literal>.  Otherwise, if recovery is still in
        progress this will increase monotonically.  If recovery has completed
        then this will remain static at the time of the last transaction
        applied during recovery.  When the server has been started normally
        without recovery, the function returns <literal>NULL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_xact_replay_timestamp</primary>
        </indexterm>
        <function>pg_last_xact_replay_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回恢复期间重放的最后一个事务的时间戳。这是在主服务器上为该事务生成提交或中止 WAL记录的时间。
        如果在恢复期间没有重放任何事务，该函数将返回<literal>NULL</literal>。否则，如果恢复仍在进行中，这将单调地增加。
        如果恢复已经完成，那么在恢复期间应用最后一个事务时，这将会保持静态。
        当服务器正常启动且没有恢复时，函数返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=31b713c2d39fd1831dc32778ef04b2b2 -->

<!-- pgdoc-cn_start sig_en=6151e5737e3250143e907c045b99be23 sig_cn_org=abf7cfedaac2846ab1d3c4c692ca9b5e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_wal_resource_managers</primary>
        </indexterm>
        <function>pg_get_wal_resource_managers</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>rm_id</parameter> <type>integer</type>,
        <parameter>rm_name</parameter> <type>text</type>,
        <parameter>rm_builtin</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns the currently-loaded WAL resource managers in the system. The
        column <parameter>rm_builtin</parameter> indicates whether it's a
        built-in resource manager, or a custom resource manager loaded by an
        extension.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_wal_resource_managers</primary>
        </indexterm>
        <function>pg_get_wal_resource_managers</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>rm_id</parameter> <type>integer</type>,
        <parameter>rm_name</parameter> <type>text</type>,
        <parameter>rm_builtin</parameter> <type>boolean</type> )
       </para>
       <para>
        返回系统中当前加载的WAL资源管理器。列<parameter>rm_builtin</parameter>指示它是内置资源管理器还是由扩展加载的自定义资源管理器。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6151e5737e3250143e907c045b99be23 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=107864d2f6a2a5db2733bbc31d3ac889 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref
    linkend="functions-recovery-control-table"/> control the progress of recovery.
    These functions may be executed only during recovery.
   </para>
________________________________________________________-->
   <para>
    控制恢复进度的功能如 <xref linkend="functions-recovery-control-table"/>所示。这些函数只能在恢复过程中执行。
   </para>
<!-- pgdoc-cn_end sig_en=107864d2f6a2a5db2733bbc31d3ac889 -->

   <table id="functions-recovery-control-table">
<!-- pgdoc-cn_start sig_en=e80b25d40aab29a470199bf3954b3767 sig_cn_org=None source=14.1 
    <title>Recovery Control Functions</title>
________________________________________________________-->
    <title>恢复控制函数</title>
<!-- pgdoc-cn_end sig_en=e80b25d40aab29a470199bf3954b3767 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=e7b0d4179cfa27529dd236a981b929b5 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_wal_replay_paused</primary>
        </indexterm>
        <function>pg_is_wal_replay_paused</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if recovery pause is requested.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_wal_replay_paused</primary>
        </indexterm>
        <function>pg_is_wal_replay_paused</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果请求了恢复暂停了则返回真。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e7b0d4179cfa27529dd236a981b929b5 -->

<!-- pgdoc-cn_start sig_en=f91d5f194d1ace2b39ea4b269c926898 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_wal_replay_pause_state</primary>
        </indexterm>
        <function>pg_get_wal_replay_pause_state</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns recovery pause state.  The return values are <literal>
        not paused</literal> if pause is not requested, <literal>
        pause requested</literal> if pause is requested but recovery is
        not yet paused, and <literal>paused</literal> if the recovery is
        actually paused.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_wal_replay_pause_state</primary>
        </indexterm>
        <function>pg_get_wal_replay_pause_state</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回恢复暂停状态。
        如果没有请求pause，返回值是<literal>not paused</literal>，如果请求暂停但恢复还没有暂停，返回值是<literal>pause requested</literal>，如果恢复实际已经暂停，返回值是<literal>paused</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f91d5f194d1ace2b39ea4b269c926898 -->

<!-- pgdoc-cn_start sig_en=28816861bc2edb840f49a51129251aba sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_promote</primary>
        </indexterm>
        <function>pg_promote</function> ( <parameter>wait</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal>, <parameter>wait_seconds</parameter> <type>integer</type> <literal>DEFAULT</literal> <literal>60</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Promotes a standby server to primary status.
        With <parameter>wait</parameter> set to <literal>true</literal> (the
        default), the function waits until promotion is completed
        or <parameter>wait_seconds</parameter> seconds have passed, and
        returns <literal>true</literal> if promotion is successful
        and <literal>false</literal> otherwise.
        If <parameter>wait</parameter> is set to <literal>false</literal>, the
        function returns <literal>true</literal> immediately after sending a
        <literal>SIGUSR1</literal> signal to the postmaster to trigger
        promotion.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_promote</primary>
        </indexterm>
        <function>pg_promote</function> ( <parameter>wait</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal>, <parameter>wait_seconds</parameter> <type>integer</type> <literal>DEFAULT</literal> <literal>60</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        将备用服务器提升为主服务器状态。
        当<parameter>wait</parameter>设置为<literal>true</literal>(默认值)时，函数将等待直到升级完成或<parameter>wait_seconds</parameter>秒数已过，如果升级成功则返回<literal>true</literal>，否则返回<literal>false</literal>。
        如果<parameter>wait</parameter>设置为<literal>false</literal>，则该函数在向postmaster发送<literal>SIGUSR1</literal>信号以触发升级后立即返回<literal>true</literal>。
       </para>
       <para>
        默认情况下这个函数仅限超级用户使用，但可以授权给其他用户执行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=28816861bc2edb840f49a51129251aba -->

<!-- pgdoc-cn_start sig_en=464fa21b5c11d3107c6ee930bd9d6fbb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_pause</primary>
        </indexterm>
        <function>pg_wal_replay_pause</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Request to pause recovery.  A request doesn't mean that recovery stops
        right away.  If you want a guarantee that recovery is actually paused,
        you need to check for the recovery pause state returned by
        <function>pg_get_wal_replay_pause_state()</function>.  Note that
        <function>pg_is_wal_replay_paused()</function> returns whether a request
        is made.  While recovery is paused, no further database changes are applied.
        If hot standby is active, all new queries will see the same consistent
        snapshot of the database, and no further query conflicts will be generated
        until recovery is resumed.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_pause</primary>
        </indexterm>
        <function>pg_wal_replay_pause</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        请求暂停恢复。
        请求不意味着恢复马上停止。
        如果你想要保证恢复实际上是暂停的，你需要检查<function>pg_get_wal_replay_pause_state()</function>返回的恢复暂停状态。
        注意，<function>pg_is_wal_replay_paused()</function>返回是否作出请求。
        在恢复暂停时，不会应用进一步的数据库更改。
        如果热备是激活的，所有新查询将看到相同的一致的数据库快照，并且在恢复继续之前不会生成进一步的查询冲突。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=464fa21b5c11d3107c6ee930bd9d6fbb -->

<!-- pgdoc-cn_start sig_en=c5ffa6ea7ebe1b2fe066e01d1d75f927 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_resume</primary>
        </indexterm>
        <function>pg_wal_replay_resume</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Restarts recovery if it was paused.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_resume</primary>
        </indexterm>
        <function>pg_wal_replay_resume</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        如果暂停了，则重新启动恢复。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c5ffa6ea7ebe1b2fe066e01d1d75f927 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=03389aa188e859bf3ae7b0d3d10b9b26 sig_cn_org=None source=14.1 
   <para>
    <function>pg_wal_replay_pause</function> and
    <function>pg_wal_replay_resume</function> cannot be executed while
    a promotion is ongoing. If a promotion is triggered while recovery
    is paused, the paused state ends and promotion continues.
   </para>
________________________________________________________-->
   <para>
    <function>pg_wal_replay_pause</function>和<function>pg_wal_replay_resume</function>不能在提升(promotion)进行时执行。
    如果在恢复暂停时触发了提升(promotion)，则暂停状态结束，升级继续进行。
   </para>
<!-- pgdoc-cn_end sig_en=03389aa188e859bf3ae7b0d3d10b9b26 -->

<!-- pgdoc-cn_start sig_en=47a7a771c96f63a8dfdaf94b8ec566d3 sig_cn_org=None source=14.1 
   <para>
    If streaming replication is disabled, the paused state may continue
    indefinitely without a problem. If streaming replication is in
    progress then WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
   </para>
________________________________________________________-->
   <para>
    如果禁用了流复制，则暂停状态可能会无限期地持续下去，不会出现问题。
    如果正在进行流复制，那么将继续接收WAL记录，这将最终填满可用磁盘空间，这取决于暂停持续时间、WAL生成速度和可用磁盘空间。
   </para>
<!-- pgdoc-cn_end sig_en=47a7a771c96f63a8dfdaf94b8ec566d3 -->

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
<!-- pgdoc-cn_start sig_en=8be3706e6eca0f772f9faea560793d1d sig_cn_org=None source=14.1 
   <title>Snapshot Synchronization Functions</title>
________________________________________________________-->
   <title>快照同步函数</title>
<!-- pgdoc-cn_end sig_en=8be3706e6eca0f772f9faea560793d1d -->

<!-- pgdoc-cn_start sig_en=a8c02b6287707845d615bd31f9452d90 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</firstterm> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</command> commands,
    so that one session sees the effects of that transaction and the other
    does not.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许数据库会话同步它们的快照。一个<firstterm>快照</firstterm>决定对于正在使用该快照的事务哪些数据是可见的。当两个或者更多个会话需要看到数据库中的相同内容时，就需要同步快照。如果两个会话独立开始其事务，就总是有可能有某个第三事务在两个<command>START TRANSACTION</command>命令的执行之间提交，这样其中一个会话就可以看到该事务的效果而另一个则看不到。
   </para>
<!-- pgdoc-cn_end sig_en=a8c02b6287707845d615bd31f9452d90 -->

<!-- pgdoc-cn_start sig_en=bb9bfb81d3e0054e4743ae8bf82776f7 sig_cn_org=None source=14.1 
   <para>
    To solve this problem, <productname>PostgreSQL</productname> allows a transaction to
    <firstterm>export</firstterm> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</firstterm> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
   </para>
________________________________________________________-->
   <para>
    为了解决这个问题，<productname>PostgreSQL</productname>允许一个事务<firstterm>导出</firstterm>它正在使用的快照。只要导出的事务仍然保持打开，其他事务可以<firstterm>导入</firstterm>它的快照，并且因此可以保证它们可以看到和第一个事务看到的完全一样的数据库视图。但是注意这些事务中的任何一个对数据库所作的更改对其他事务仍然保持不可见，和未提交事务所作的修改一样。因此这些事务是针对以前存在的数据同步，而对由它们自己所作的更改则采取正常的动作。
   </para>
<!-- pgdoc-cn_end sig_en=bb9bfb81d3e0054e4743ae8bf82776f7 -->

<!-- pgdoc-cn_start sig_en=dd3b3ec3065948de97e4262a4142f6af sig_cn_org=None source=14.1 
   <para>
    Snapshots are exported with the <function>pg_export_snapshot</function> function,
    shown in <xref linkend="functions-snapshot-synchronization-table"/>, and
    imported with the <xref linkend="sql-set-transaction"/> command.
   </para>
________________________________________________________-->
   <para>
    如<xref linkend="functions-snapshot-synchronization-table"/>中所示，快照通过<function>pg_export_snapshot</function>函数导出，并且通过<xref linkend="sql-set-transaction"/>命令导入。
   </para>
<!-- pgdoc-cn_end sig_en=dd3b3ec3065948de97e4262a4142f6af -->

   <table id="functions-snapshot-synchronization-table">
<!-- pgdoc-cn_start sig_en=8be3706e6eca0f772f9faea560793d1d sig_cn_org=None source=14.1 
    <title>Snapshot Synchronization Functions</title>
________________________________________________________-->
    <title>快照同步函数</title>
<!-- pgdoc-cn_end sig_en=8be3706e6eca0f772f9faea560793d1d -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=902609457a210ff29de3f525399a189b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_export_snapshot</primary>
        </indexterm>
        <function>pg_export_snapshot</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Saves the transaction's current snapshot and returns
        a <type>text</type> string identifying the snapshot.  This string must
        be passed (outside the database) to clients that want to import the
        snapshot.  The snapshot is available for import only until the end of
        the transaction that exported it.
       </para>
       <para>
        A transaction can export more than one snapshot, if needed.  Note that
        doing so is only useful in <literal>READ COMMITTED</literal>
        transactions, since in <literal>REPEATABLE READ</literal> and higher
        isolation levels, transactions use the same snapshot throughout their
        lifetime.  Once a transaction has exported any snapshots, it cannot be
        prepared with <xref linkend="sql-prepare-transaction"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_export_snapshot</primary>
        </indexterm>
        <function>pg_export_snapshot</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        保存事务的当前快照并返回<type>text</type>字符串以标识该快照。
        必须将此字符串传递(在数据库之外)给希望导入快照的客户端。快照仅在导出它的事务结束之前才可用于导入。
       </para>
       <para>
        如果需要的话，一个事务可以导出多个快照。
        请注意，这样做仅在<literal>READ COMMITTED</literal>事务中有用，因为在<literal>REPEATABLE READ</literal>和更高的隔离级别中，事务在它们的生命周期中使用相同的快照。
        一旦事务导出了快照，它就不能用 <xref linkend="sql-prepare-transaction"/>进行准备。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=902609457a210ff29de3f525399a189b -->
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-replication">
<!-- pgdoc-cn_start sig_en=81e3916dd1d62c3d6bb4eb7108334036 sig_cn_org=None source=14.1 
   <title>Replication Management Functions</title>
________________________________________________________-->
   <title>复制管理函数</title>
<!-- pgdoc-cn_end sig_en=81e3916dd1d62c3d6bb4eb7108334036 -->

<!-- pgdoc-cn_start sig_en=ea79d5af9e1a01d74f2424272ac34c7b sig_cn_org=None source=14.1 
   <para>
    The functions shown
    in <xref linkend="functions-replication-table"/> are for
    controlling and interacting with replication features.
    See <xref linkend="streaming-replication"/>,
    <xref linkend="streaming-replication-slots"/>, and
    <xref linkend="replication-origins"/>
    for information about the underlying features.
    Use of functions for replication origin is only allowed to the
    superuser by default, but may be allowed to other users by using the
    <literal>GRANT</literal> command.
    Use of functions for replication slots is restricted to superusers
    and users having <literal>REPLICATION</literal> privilege.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-replication-table"/>中展示的函数用于控制以及与复制特性交互。
    有关底层特性的信息请见<xref linkend="streaming-replication"/>、<xref linkend="streaming-replication-slots"/>以及<xref linkend="replication-origins"/>。
    复制原点函数的使用仅限于超级用户。 
    默认只允许超级用户使用复制源的函数，但可以通过<literal>GRANT</literal>命令允许其他用户使用。
    复制槽的函数只限于超级用户和拥有<literal>REPLICATION</literal>权限的用户。
   </para>
<!-- pgdoc-cn_end sig_en=ea79d5af9e1a01d74f2424272ac34c7b -->

<!-- pgdoc-cn_start sig_en=386438fee512aa7cfc861ad56cb3da91 sig_cn_org=None source=14.1 
   <para>
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication"/>.
   </para>
________________________________________________________-->
   <para>
    很多这些函数在复制协议中都有等价的命令，见
    <xref linkend="protocol-replication"/>。
   </para>
<!-- pgdoc-cn_end sig_en=386438fee512aa7cfc861ad56cb3da91 -->

<!-- pgdoc-cn_start sig_en=ce2f254c1a35f1c267aaf89182cc69d8 sig_cn_org=None source=14.1 
   <para>
    The functions described in
    <xref linkend="functions-admin-backup"/>,
    <xref linkend="functions-recovery-control"/>, and
    <xref linkend="functions-snapshot-synchronization"/>
    are also relevant for replication.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-backup"/>、
    <xref linkend="functions-recovery-control"/>和
    <xref linkend="functions-snapshot-synchronization"/>
    中描述的函数也与复制相关。
   </para>
<!-- pgdoc-cn_end sig_en=ce2f254c1a35f1c267aaf89182cc69d8 -->

   <table id="functions-replication-table">
<!-- pgdoc-cn_start sig_en=81e3916dd1d62c3d6bb4eb7108334036 sig_cn_org=None source=14.1 
    <title>Replication Management Functions</title>
________________________________________________________-->
    <title>复制管理函数</title>
<!-- pgdoc-cn_end sig_en=81e3916dd1d62c3d6bb4eb7108334036 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=3021b68e783f45508047d7e61491a32d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <function>pg_create_physical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. The optional second parameter,
        when <literal>true</literal>, specifies that the <acronym>LSN</acronym> for this
        replication slot be reserved immediately; otherwise
        the <acronym>LSN</acronym> is reserved on first connection from a streaming
        replication client. Streaming changes from a physical slot is only
        possible with the streaming-replication protocol &mdash;
        see <xref linkend="protocol-replication"/>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by the current session. Temporary slots are also
        released upon any error. This function corresponds
        to the replication protocol command <literal>CREATE_REPLICATION_SLOT
        ... PHYSICAL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <function>pg_create_physical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        创建一个新的名为<parameter>slot_name</parameter>的物理复制槽。
        第二个参数是可选的，当它为<literal>true</literal>时，立即为这个物理槽指定要被保留的<acronym>LSN</acronym>。
        否则该<acronym>LSN</acronym>会被保留在来自一个流复制客户端的第一个连接上。
        来自一个物理槽的流改变只可能出现在使用流复制协议时 &mdash; 见<xref linkend="protocol-replication"/>。
        当可选的第三参数<parameter>temporary</parameter>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。
        临时槽也会在发生任何错误时被释放。这个函数对应于复制协议命令<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3021b68e783f45508047d7e61491a32d -->

<!-- pgdoc-cn_start sig_en=8609376f82dc6d5daafe496d5b86a603 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <function>pg_drop_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</literal>. For logical slots, this must
        be called while connected to the same database the slot was created on.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <function>pg_drop_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        丢弃名为<parameter>slot_name</parameter>的物理或逻辑复制槽。
        和复制协议命令<literal>DROP_REPLICATION_SLOT</literal>相同。对于逻辑槽，
        在连接到在其中创建该槽的同一个数据库时，必须调用这个函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8609376f82dc6d5daafe496d5b86a603 -->

<!-- pgdoc-cn_start sig_en=a281867e639fbf9489ccdf4329dea268 sig_cn_org=075dae39c487deaf323bbf269df98b05 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <function>pg_create_logical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type>, <parameter>twophase</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by the current session. Temporary slots are also
        released upon any error. The optional fourth parameter,
        <parameter>twophase</parameter>, when set to true, specifies
        that the decoding of prepared transactions is enabled for this
        slot. A call to this function has the same effect as the replication
        protocol command <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <function>pg_create_logical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type>, <parameter>twophase</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        创建一个名为<parameter>slot_name</parameter>的新逻辑（解码）复制插槽，使用输出插件<parameter>plugin</parameter>。可选的第三个参数<parameter>temporary</parameter>，当设置为true时，指定插槽不应永久存储到磁盘，仅供当前会话使用。临时插槽也会在任何错误发生时释放。可选的第四个参数<parameter>twophase</parameter>，当设置为true时，指定为此插槽启用已准备事务的解码。调用此函数的效果与复制协议命令<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>相同。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a281867e639fbf9489ccdf4329dea268 -->

<!-- pgdoc-cn_start sig_en=8ba375adb9d3d6a06be3a3585b764ade sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_physical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Copies an existing physical replication slot named <parameter>src_slot_name</parameter>
        to a physical replication slot named <parameter>dst_slot_name</parameter>.
        The copied physical slot starts to reserve WAL from the same <acronym>LSN</acronym> as the
        source slot.
        <parameter>temporary</parameter> is optional. If <parameter>temporary</parameter>
        is omitted, the same value as the source slot is used.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_physical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        将一个名为<parameter>src_slot_name</parameter>的现有物理复制槽复制到一个名为<parameter>dst_slot_name</parameter>的物理复制槽。
        被复制的物理槽开始从与源槽相同的<acronym>LSN</acronym>开始保留WAL。<parameter>temporary</parameter>是可选的。
        如果省略了<parameter>temporary</parameter>，则使用与源槽相同的值。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8ba375adb9d3d6a06be3a3585b764ade -->

<!-- pgdoc-cn_start sig_en=3be23e7bc03399dbb21540461015dbe2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_logical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type> </optional></optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Copies an existing logical replication slot
        named <parameter>src_slot_name</parameter> to a logical replication
        slot named <parameter>dst_slot_name</parameter>, optionally changing
        the output plugin and persistence.  The copied logical slot starts
        from the same <acronym>LSN</acronym> as the source logical slot.  Both
        <parameter>temporary</parameter> and <parameter>plugin</parameter> are
        optional; if they are omitted, the values of the source slot are used.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_logical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type> </optional></optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        复制一个名为<parameter>src_slot_name</parameter>的现有逻辑复制槽到一个名为<parameter>dst_slot_name</parameter>的逻辑复制槽，选择性的改变输出插件和持久性。
        被复制的逻辑槽从与源逻辑槽相同的<acronym>LSN</acronym>开始。<parameter>temporary</parameter>和<parameter>plugin</parameter>都是可选的。
        如果它们被省略了，使用与源逻辑槽相同的值。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3be23e7bc03399dbb21540461015dbe2 -->

<!-- pgdoc-cn_start sig_en=0cf3f50b97b453d59ba84c760f784931 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point from which changes have been consumed last.  If
        <parameter>upto_lsn</parameter>
        and <parameter>upto_nchanges</parameter> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</parameter> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        返回槽<parameter>slot_name</parameter>中的改变，从最后一次使用更改的点开始。
        如果<parameter>upto_lsn</parameter>和<parameter>upto_nchanges</parameter>为 NULL，逻辑解码将一直继续到 WAL 的末尾。
        如果<parameter>upto_lsn</parameter>为非 NULL，解码将只包括那些在指定 LSN 之前提交的事务。
        如果<parameter>upto_nchanges</parameter>为非 NULL，解码将在其产生的行数超过指定值后停止。
        不过要注意，被返回的实际行数可能更大，因为对这个限制的检查只会在增加了解码每个新的提交事务产生的行之后进行。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0cf3f50b97b453d59ba84c760f784931 -->

<!-- pgdoc-cn_start sig_en=ed68d266d0162de07ca62be1dbca4a07 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
         <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
         <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变不会被消费， 即在未来的调用中还会返回这些改变。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ed68d266d0162de07ca62be1dbca4a07 -->

<!-- pgdoc-cn_start sig_en=45775836053809a0536720caae0f5c25 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=45775836053809a0536720caae0f5c25 -->

<!-- pgdoc-cn_start sig_en=d2b9e18a516ea7b6b7b5dee4cbb9ca61 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_peek_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_peek_changes()</function>函数，不过改变会以<type>bytea</type>返回。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d2b9e18a516ea7b6b7b5dee4cbb9ca61 -->

<!-- pgdoc-cn_start sig_en=c40ae9afc47fe82696c3dfe586f06133 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <function>pg_replication_slot_advance</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>end_lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Advances the current confirmed position of a replication slot named
        <parameter>slot_name</parameter>. The slot will not be moved backwards,
        and it will not be moved beyond the current insert location. Returns
        the name of the slot and the actual position that it was advanced to.
        The updated slot position information is written out at the next
        checkpoint if any advancing is done. So in the event of a crash, the
        slot may return to an earlier position.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <function>pg_replication_slot_advance</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>end_lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        将复制槽的当前确认的位置提前到名为<parameter>slot_name</parameter>的复制槽的当前确认位置。
        该槽不会向后移动，也不会移动到当前插入位置之外。返回该槽的名称和它被推进到的真实位置。
        如果有任何进展，则在下一个检查点中写出更新后的槽位置信息。所以如果发生崩溃，该槽位可能会返回到之前的位置。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c40ae9afc47fe82696c3dfe586f06133 -->

<!-- pgdoc-cn_start sig_en=1416c5499bd21b3485fd6ab1eb327f71 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-create" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <function>pg_replication_origin_create</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Creates a replication origin with the given external
        name, and returns the internal ID assigned to it.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-create" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <function>pg_replication_origin_create</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        用给定的外部名称创建一个复制源，并且返回分配给它的内部 ID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1416c5499bd21b3485fd6ab1eb327f71 -->

<!-- pgdoc-cn_start sig_en=d6098a1141475840aba7b3089f173100 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-drop" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <function>pg_replication_origin_drop</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Deletes a previously-created replication origin, including any
        associated replay progress.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-drop" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <function>pg_replication_origin_drop</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        删除一个以前创建的复制源，包括任何相关的重放进度。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d6098a1141475840aba7b3089f173100 -->

<!-- pgdoc-cn_start sig_en=8f393ceff60e147ea74683117490ab0e sig_cn_org=8f393ceff60e147ea74683117490ab0e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <function>pg_replication_origin_oid</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Looks up a replication origin by name and returns the internal ID. If
        no such replication origin is found, <literal>NULL</literal> is
        returned.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <function>pg_replication_origin_oid</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        通过名称查找复制源并返回其内部ID。如果未找到这样的复制源，则返回 <literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8f393ceff60e147ea74683117490ab0e -->

<!-- pgdoc-cn_start sig_en=af2a2eeb8af3631d209a5a1a4c8cba8d sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-session-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_setup</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Marks the current session as replaying from the given
        origin, allowing replay progress to be tracked.
        Can only be used if no origin is currently selected.
        Use <function>pg_replication_origin_session_reset</function> to undo.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_setup</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前会话标记为从给定的原点回放，从而允许跟踪回放进度。
        只能在当前没有选择原点时使用。使用<function>pg_replication_origin_session_reset</function> 命令来撤销。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=af2a2eeb8af3631d209a5a1a4c8cba8d -->

<!-- pgdoc-cn_start sig_en=51a851f4a25a55f16764999f0fbac8ce sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <function>pg_replication_origin_session_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Cancels the effects
        of <function>pg_replication_origin_session_setup()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <function>pg_replication_origin_session_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        取消<function>pg_replication_origin_session_setup()</function>的效果。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=51a851f4a25a55f16764999f0fbac8ce -->

<!-- pgdoc-cn_start sig_en=52afc95261ec1dbcc2041fc243914ed4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_is_setup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if a replication origin has been selected in the
        current session.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_is_setup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果在当前会话中选择了复制源则返回真。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=52afc95261ec1dbcc2041fc243914ed4 -->

<!-- pgdoc-cn_start sig_en=13bfeae97cc791fcf973e6d38b97f156 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-session-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <function>pg_replication_origin_session_progress</function> ( <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the replay location for the replication origin selected in
        the current session. The parameter <parameter>flush</parameter>
        determines whether the corresponding local transaction will be
        guaranteed to have been flushed to disk or not.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <function>pg_replication_origin_session_progress</function> ( <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前会话中选择的复制源的重放位置。参数<parameter>flush</parameter>决定对应的本地事务是否被确保已经刷入磁盘。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=13bfeae97cc791fcf973e6d38b97f156 -->

<!-- pgdoc-cn_start sig_en=eeedc1980608186c99f58e036af86ddf sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-xact-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <function>pg_replication_origin_xact_setup</function> ( <parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamp with time zone</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Marks the current transaction as replaying a transaction that has
        committed at the given <acronym>LSN</acronym> and timestamp. Can
        only be called when a replication origin has been selected
        using <function>pg_replication_origin_session_setup</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <function>pg_replication_origin_xact_setup</function> ( <parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamp with time zone</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前事务标记为重放在给定<acronym>LSN</acronym>和时间戳上提交的事务。
        只能在使用<function>pg_replication_origin_session_setup</function>选择复制源时调用。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=eeedc1980608186c99f58e036af86ddf -->

<!-- pgdoc-cn_start sig_en=f2a18baf89f10f6a774fb43778bf0ab4 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-xact-reset" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <function>pg_replication_origin_xact_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Cancels the effects of
        <function>pg_replication_origin_xact_setup()</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-reset" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <function>pg_replication_origin_xact_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        取消<function>pg_replication_origin_xact_setup()</function>的效果。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f2a18baf89f10f6a774fb43778bf0ab4 -->

<!-- pgdoc-cn_start sig_en=00715d5c58a915938695048e61e12cf5 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-advance" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <function>pg_replication_origin_advance</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Sets replication progress for the given node to the given
        location. This is primarily useful for setting up the initial
        location, or setting a new location after configuration changes and
        similar. Be aware that careless use of this function can lead to
        inconsistently replicated data.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-advance" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <function>pg_replication_origin_advance</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将给定节点的复制进度设置为给定的位置。这主要用于设置初始位置，或在配置更改或类似的变更后设置新位置。
        请注意这个函数的不当使用可能会导致不一致的复制数据。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=00715d5c58a915938695048e61e12cf5 -->

<!-- pgdoc-cn_start sig_en=89c5d63dbc888d8426b4fe840d0a66b6 sig_cn_org=None source=14.1 
      <row>
       <entry id="pg-replication-origin-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <function>pg_replication_origin_progress</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the replay location for the given replication origin. The
        parameter <parameter>flush</parameter> determines whether the
        corresponding local transaction will be guaranteed to have been
        flushed to disk or not.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <function>pg_replication_origin_progress</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回给定复制元的重放位置。参数<parameter>flush</parameter>决定对应的本地事务是否被确保已经刷入磁盘。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=89c5d63dbc888d8426b4fe840d0a66b6 -->

<!-- pgdoc-cn_start sig_en=931e9557ed49731f2c871d32edb5385a sig_cn_org=245db842ba50171c66051d4e05a411c1 source=15.7 
      <row>
       <entry id="pg-logical-emit-message" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Emits a logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through
        WAL. The <parameter>transactional</parameter> parameter specifies if
        the message should be part of the current transaction, or if it should
        be written immediately and decoded as soon as the logical decoder
        reads the record. The <parameter>prefix</parameter> parameter is a
        textual prefix that can be used by logical decoding plugins to easily
        recognize messages that are interesting for them.
        The <parameter>content</parameter> parameter is the content of the
        message, given either in text or binary form.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry id="pg-logical-emit-message" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        发出逻辑解码消息。这可以用于通过WAL将通用消息传递给逻辑解码插件。
        <parameter>transactional</parameter>参数指定消息是否应该是当前事务的一部分，
        还是应该立即写入并在逻辑解码器读取记录时立即解码。
        <parameter>prefix</parameter>参数是一个文本前缀，逻辑解码插件可以使用它轻松识别对它们有趣的消息。
        <parameter>content</parameter>参数是消息的内容，可以以文本或二进制形式给出。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=931e9557ed49731f2c871d32edb5385a -->
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
<!-- pgdoc-cn_start sig_en=507a6d4a5f0e8af462b04fa0a09741d5 sig_cn_org=None source=14.1 
   <title>Database Object Management Functions</title>
________________________________________________________-->
   <title>数据库对象管理函数</title>
<!-- pgdoc-cn_end sig_en=507a6d4a5f0e8af462b04fa0a09741d5 -->

<!-- pgdoc-cn_start sig_en=cace6d0a536256aa5135969f42715376 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-admin-dbsize"/> calculate
    the disk space usage of database objects, or assist in presentation
    or understanding of usage results.  <literal>bigint</literal> results
    are measured in bytes.  If an OID that does
    not represent an existing object is passed to one of these
    functions, <literal>NULL</literal> is returned.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dbsize"/>中所示的函数计算数据库对象的磁盘空间使用情况，或帮助表示或理解使用结果。
    <literal>bigint</literal>结果以字节为单位。
    如果将不代表已有对象的OID传递给这些函数之一，则返回<literal>NULL</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=cace6d0a536256aa5135969f42715376 -->

   <table id="functions-admin-dbsize">
<!-- pgdoc-cn_start sig_en=aeab3ea0524dca2262cda1ac4a95f03e sig_cn_org=None source=14.1 
    <title>Database Object Size Functions</title>
________________________________________________________-->
    <title>数据库对象尺寸函数</title>
<!-- pgdoc-cn_end sig_en=aeab3ea0524dca2262cda1ac4a95f03e -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=be20c96c1d4e49e7e09c3dab03b7eaf3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_size</primary>
        </indexterm>
        <function>pg_column_size</function> ( <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Shows the number of bytes used to store any individual data value.  If
        applied directly to a table column value, this reflects any
        compression that was done.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_size</primary>
        </indexterm>
        <function>pg_column_size</function> ( <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        显示用于存储任何单个数据值的字节数。如果直接应用于表的列值，则反映所做的任何压缩。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=be20c96c1d4e49e7e09c3dab03b7eaf3 -->

<!-- pgdoc-cn_start sig_en=2bb7a1f1b5b9cd39c9a1a5a767928ad1 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_compression</primary>
        </indexterm>
        <function>pg_column_compression</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Shows the compression algorithm that was used to compress
        an individual variable-length value. Returns <literal>NULL</literal>
        if the value is not compressed.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_compression</primary>
        </indexterm>
        <function>pg_column_compression</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        显示用于压缩单个变长值的压缩算法。
        如果值没有被压缩，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2bb7a1f1b5b9cd39c9a1a5a767928ad1 -->

<!-- pgdoc-cn_start sig_en=79e9236dd5afb235749133a91b40861c sig_cn_org=048051ff41253981545ba0d8911d0c51 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_size</primary>
        </indexterm>
        <function>pg_database_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_database_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by the database with the specified
        name or OID.  To use this function, you must
        have <literal>CONNECT</literal> privilege on the specified database
        (which is granted by default) or have privileges of
        the <literal>pg_read_all_stats</literal> role.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_size</primary>
        </indexterm>
        <function>pg_database_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_database_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算具有指定名称或OID的数据库使用的总磁盘空间。要使用此函数，您必须对指定数据库具有<literal>CONNECT</literal>权限
        （默认情况下授予），或者具有<literal>pg_read_all_stats</literal>角色的权限。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=79e9236dd5afb235749133a91b40861c -->

<!-- pgdoc-cn_start sig_en=96f69e460999418c253a9fee8b8bc5d7 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexes_size</primary>
        </indexterm>
        <function>pg_indexes_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by indexes attached to the
        specified table.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexes_size</primary>
        </indexterm>
        <function>pg_indexes_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算附加到指定表的索引所使用的总磁盘空间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=96f69e460999418c253a9fee8b8bc5d7 -->

<!-- pgdoc-cn_start sig_en=7322ee9f207e48fede723003c43ae47a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_size</primary>
        </indexterm>
        <function>pg_relation_size</function> ( <parameter>relation</parameter> <type>regclass</type> <optional>, <parameter>fork</parameter> <type>text</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the disk space used by one <quote>fork</quote> of the
        specified relation.  (Note that for most purposes it is more
        convenient to use the higher-level
        functions <function>pg_total_relation_size</function>
        or <function>pg_table_size</function>, which sum the sizes of all
        forks.)  With one argument, this returns the size of the main data
        fork of the relation.  The second argument can be provided to specify
        which fork to examine:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           <literal>main</literal> returns the size of the main
           data fork of the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fsm</literal> returns the size of the Free Space Map
           (see <xref linkend="storage-fsm"/>) associated with the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>vm</literal> returns the size of the Visibility Map
           (see <xref linkend="storage-vm"/>) associated with the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>init</literal> returns the size of the initialization
           fork, if any, associated with the relation.
          </para>
         </listitem>
        </itemizedlist>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_size</primary>
        </indexterm>
        <function>pg_relation_size</function> ( <parameter>relation</parameter> <type>regclass</type> <optional>, <parameter>fork</parameter> <type>text</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定关系的一个<quote>fork</quote>所使用的磁盘空间。
        (注意在大多数情况下，使用更高级的函数 <function>pg_total_relation_size</function>或<function>pg_table_size</function>更方便，它们将所有分叉(forks)的大小相加。)
        使用一个参数，这将返回关系的主数据分叉的大小。第二个参数可以用来指定要检查哪个分叉:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           <literal>main</literal>返回关系的主数据分叉的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fsm</literal> 返回与该关系关联的空闲空间映射(参见<xref linkend="storage-fsm"/>)的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>vm</literal> 返回与该关系相关联的可见性映射(参见<xref linkend="storage-vm"/>)的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>init</literal> 返回初始化分叉的大小，如果有的话，与关系相关。
          </para>
         </listitem>
        </itemizedlist>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7322ee9f207e48fede723003c43ae47a -->

<!-- pgdoc-cn_start sig_en=572b4ad7837ca5143123ddc4e57eb5d3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_bytes</primary>
        </indexterm>
        <function>pg_size_bytes</function> ( <type>text</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Converts a size in human-readable format (as returned
        by <function>pg_size_pretty</function>) into bytes.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_bytes</primary>
        </indexterm>
        <function>pg_size_bytes</function> ( <type>text</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        将人可阅读的格式的大小(由<function>pg_size_pretty</function>返回)转换为字节。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=572b4ad7837ca5143123ddc4e57eb5d3 -->

<!-- pgdoc-cn_start sig_en=38e59331a2d652656361299eefbd0328 sig_cn_org=2ade2fe9f944ee89d7192811af3e877b source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_pretty</primary>
        </indexterm>
        <function>pg_size_pretty</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_size_pretty</function> ( <type>numeric</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts a size in bytes into a more easily human-readable format with
        size units (bytes, kB, MB, GB, TB, or PB as appropriate).  Note that the
        units are powers of 2 rather than powers of 10, so 1kB is 1024 bytes,
        1MB is 1024<superscript>2</superscript> = 1048576 bytes, and so on.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_pretty</primary>
        </indexterm>
        <function>pg_size_pretty</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_size_pretty</function> ( <type>numeric</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将字节大小转换为更易于人类阅读的格式，带有大小单位（字节，kB，MB，GB，TB或PB）。请注意，单位是2的幂，而不是10的幂，因此1kB是1024字节，
        1MB是1024<superscript>2</superscript> = 1048576字节，依此类推。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=38e59331a2d652656361299eefbd0328 -->

<!-- pgdoc-cn_start sig_en=9ff1315907797970d04c09d55ce6571a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_size</primary>
        </indexterm>
        <function>pg_table_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the disk space used by the specified table, excluding indexes
        (but including its TOAST table if any, free space map, and visibility
        map).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_size</primary>
        </indexterm>
        <function>pg_table_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定表所使用的磁盘空间，不包括索引(但包括它的TOAST表，如果有的话，空闲空间映射，以及可见性映射)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9ff1315907797970d04c09d55ce6571a -->

<!-- pgdoc-cn_start sig_en=b047cbdd906e41696004d0cb6908b6dd sig_cn_org=01cbc209c8ad92e9fae2208aa5a5db32 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_size</primary>
        </indexterm>
        <function>pg_tablespace_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_tablespace_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used in the tablespace with the
        specified name or OID. To use this function, you must
        have <literal>CREATE</literal> privilege on the specified tablespace
        or have privileges of the <literal>pg_read_all_stats</literal> role,
        unless it is the default tablespace for the current database.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_size</primary>
        </indexterm>
        <function>pg_tablespace_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_tablespace_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算具有指定名称或OID的表空间中使用的总磁盘空间。
        要使用此函数，您必须对指定的表空间具有<literal>CREATE</literal>权限，
        或者具有<literal>pg_read_all_stats</literal>角色的权限，
        除非它是当前数据库的默认表空间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=b047cbdd906e41696004d0cb6908b6dd -->

<!-- pgdoc-cn_start sig_en=dd765d88404761b4143bc822f7445815 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_total_relation_size</primary>
        </indexterm>
        <function>pg_total_relation_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by the specified table, including
        all indexes and <acronym>TOAST</acronym> data.  The result is
        equivalent to <function>pg_table_size</function>
        <literal>+</literal> <function>pg_indexes_size</function>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_total_relation_size</primary>
        </indexterm>
        <function>pg_total_relation_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定表所使用的总磁盘空间，包括所有索引和<acronym>TOAST</acronym>数据。
        结果等价<function>pg_table_size</function> <literal>+</literal> <function>pg_indexes_size</function>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dd765d88404761b4143bc822f7445815 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=f900c23f07e0a6b5969e4adb8a70c647 sig_cn_org=None source=14.1 
   <para>
    The functions above that operate on tables or indexes accept a
    <type>regclass</type> argument, which is simply the OID of the table or index
    in the <structname>pg_class</structname> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</type> data type's input
    converter will do the work for you.  See <xref linkend="datatype-oid"/>
    for details.
   </para>
________________________________________________________-->
   <para>
    上述操作表和索引的函数接受一个<type>regclass</type>参数，它是该表或索引在<structname>pg_class</structname>系统目录中的 OID。
    你不必手工去查找该 OID，因为<type>regclass</type>数据类型的输入转换器会为你代劳。
    只写包围在单引号内的表名，这样它看起来像一个文字常量。
    为了与普通<acronym>SQL</acronym>名称的处理相兼容，该字符串将被转换为小写形式，除非其中在表名周围包含双引号。
    详见<xref linkend="datatype-oid"/>。
   </para>
<!-- pgdoc-cn_end sig_en=f900c23f07e0a6b5969e4adb8a70c647 -->

<!-- pgdoc-cn_start sig_en=89c361b368f2abbdd1064808b1fcd822 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-admin-dblocation"/> assist
    in identifying the specific disk files associated with database objects.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dblocation"/>中展示的函数帮助标识数据库对象相关的磁盘文件。
   </para>
<!-- pgdoc-cn_end sig_en=89c361b368f2abbdd1064808b1fcd822 -->

   <table id="functions-admin-dblocation">
<!-- pgdoc-cn_start sig_en=d50cf67c0fd7812d0b851f2457335fec sig_cn_org=None source=14.1 
    <title>Database Object Location Functions</title>
________________________________________________________-->
    <title>数据库对象位置函数</title>
<!-- pgdoc-cn_end sig_en=d50cf67c0fd7812d0b851f2457335fec -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=44fdbbbe225a6eac62594293e0dd1e82 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filenode</primary>
        </indexterm>
        <function>pg_relation_filenode</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the <quote>filenode</quote> number currently assigned to the
        specified relation.  The filenode is the base component of the file
        name(s) used for the relation (see
        <xref linkend="storage-file-layout"/> for more information).
        For most relations the result is the same as
        <structname>pg_class</structname>.<structfield>relfilenode</structfield>,
        but for certain system catalogs <structfield>relfilenode</structfield>
        is zero and this function must be used to get the correct value.  The
        function returns NULL if passed a relation that does not have storage,
        such as a view.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filenode</primary>
        </indexterm>
        <function>pg_relation_filenode</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回当前分配给指定关系的<quote>filenode</quote>数字。文件节点是用于该关系的文件名称的基本组件(更多信息请参阅<xref linkend="storage-file-layout"/> )。
        对于大多数关系，其结果与<structname>pg_class</structname>.<structfield>relfilenode</structfield>相同，但对于某些系统目录，<structfield>relfilenode</structfield>为0，并且必须使用这个函数来获得正确的值。
        如果传递的是一个没有存储的关系，例如一个视图，那么函数将返回NULL。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=44fdbbbe225a6eac62594293e0dd1e82 -->

<!-- pgdoc-cn_start sig_en=8625f7856ffae117ee18ca6154bdc351 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filepath</primary>
        </indexterm>
        <function>pg_relation_filepath</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the entire file path name (relative to the database cluster's
        data directory, <varname>PGDATA</varname>) of the relation.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filepath</primary>
        </indexterm>
        <function>pg_relation_filepath</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回关系的完整文件路径名称(相对于数据库集群的数据目录，关系的<varname>PGDATA</varname>)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8625f7856ffae117ee18ca6154bdc351 -->

<!-- pgdoc-cn_start sig_en=8ab144db7d95c29ba983139fb701480e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_filenode_relation</primary>
        </indexterm>
        <function>pg_filenode_relation</function> ( <parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Returns a relation's OID given the tablespace OID and filenode it is
        stored under.  This is essentially the inverse mapping of
        <function>pg_relation_filepath</function>.  For a relation in the
        database's default tablespace, the tablespace can be specified as zero.
        Returns <literal>NULL</literal> if no relation in the current database
        is associated with the given values.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_filenode_relation</primary>
        </indexterm>
        <function>pg_filenode_relation</function> ( <parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        返回一个给定表空间OID和存储它的文件节点的关系的OID。这本质上是<function>pg_relation_filepath</function>的反向映射。
        对于数据库默认表空间中的关系，表空间可以指定为0。如果当前数据库中没有与给定值相关联的关系，则返回 <literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8ab144db7d95c29ba983139fb701480e -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=4fe5d8fd6a5ea27e69081ddf116a80e6 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-admin-collation"/> lists functions used to manage
    collations.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-collation"/> 列出用于管理排序规则的函数。
   </para>
<!-- pgdoc-cn_end sig_en=4fe5d8fd6a5ea27e69081ddf116a80e6 -->

   <table id="functions-admin-collation">
<!-- pgdoc-cn_start sig_en=d374d3394d85950eb78363ffa53d0a5b sig_cn_org=None source=14.1 
    <title>Collation Management Functions</title>
________________________________________________________-->
    <title>排序规则管理函数</title>
<!-- pgdoc-cn_end sig_en=d374d3394d85950eb78363ffa53d0a5b -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=055ca75dedd5b038f07c975bcba9b89d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_actual_version</primary>
        </indexterm>
        <function>pg_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the actual version of the collation object as it is currently
        installed in the operating system.  If this is different from the
        value in
        <structname>pg_collation</structname>.<structfield>collversion</structfield>,
        then objects depending on the collation might need to be rebuilt.  See
        also <xref linkend="sql-altercollation"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_actual_version</primary>
        </indexterm>
        <function>pg_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回当前安装在操作系统中的该排序规则对象的实际版本。
        如果这个版本与<structname>pg_collation</structname>.<structfield>collversion</structfield>中的值不同，则依赖于该排序规则的对象可能需要被重建。
        还可以参考<xref linkend="sql-altercollation"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=055ca75dedd5b038f07c975bcba9b89d -->

<!-- pgdoc-cn_start sig_en=d59004f0a78659eeab335d896a43624d sig_cn_org=9f5e71fe06972d1a0e6ccb7b2af8812d source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_collation_actual_version</primary>
        </indexterm>
        <function>pg_database_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the actual version of the database's collation as it is currently
        installed in the operating system.  If this is different from the
        value in
        <structname>pg_database</structname>.<structfield>datcollversion</structfield>,
        then objects depending on the collation might need to be rebuilt.  See
        also <xref linkend="sql-alterdatabase"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_collation_actual_version</primary>
        </indexterm>
        <function>pg_database_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回数据库当前在操作系统中安装的排序规则的实际版本。如果这与<structname>pg_database</structname>。
        <structfield>datcollversion</structfield>中的值不同，则依赖于排序规则的对象可能需要重新构建。
        参见<xref linkend="sql-alterdatabase"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d59004f0a78659eeab335d896a43624d -->

<!-- pgdoc-cn_start sig_en=0ed444d746cb53e2a89899d59f6d0cba sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_import_system_collations</primary>
        </indexterm>
        <function>pg_import_system_collations</function> ( <parameter>schema</parameter> <type>regnamespace</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Adds collations to the system
        catalog <structname>pg_collation</structname> based on all the locales
        it finds in the operating system.  This is
        what <command>initdb</command> uses; see
        <xref linkend="collation-managing"/> for more details.  If additional
        locales are installed into the operating system later on, this
        function can be run again to add collations for the new locales.
        Locales that match existing entries
        in <structname>pg_collation</structname> will be skipped.  (But
        collation objects based on locales that are no longer present in the
        operating system are not removed by this function.)
        The <parameter>schema</parameter> parameter would typically
        be <literal>pg_catalog</literal>, but that is not a requirement; the
        collations could be installed into some other schema as well.  The
        function returns the number of new collation objects it created.
        Use of this function is restricted to superusers.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_import_system_collations</primary>
        </indexterm>
        <function>pg_import_system_collations</function> ( <parameter>schema</parameter> <type>regnamespace</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        基于在操作系统中找到的所有区域环境(locales)，加入排序规则到系统目录<literal>pg_collation</literal>中。
        这是 <command>initdb</command> 会用到的的，更多细节请参考<xref linkend="collation-managing"/>。
        如果后来在操作系统上安装了额外的区域环境，可以再次运行这个函数加入新区域环境的排序规则。
        匹配<structname>pg_collation</structname>中现有条目的区域环境将被跳过（但是这个函数不会移除以在操作系统中不再存在的区域环境为基础的排序规则对象）。
        <parameter>schema</parameter>参数通常是<literal>pg_catalog</literal>，但这不是一种要求，排序规则也可以被安装到其他的方案中。
        该函数返回其创建的新排序规则对象的数量。
        此函数仅限超级用户使用。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0ed444d746cb53e2a89899d59f6d0cba -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=f66f255a7a01233c24f2f8a09f54decc sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-info-partition"/> lists functions that provide
    information about the structure of partitioned tables.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-info-partition"/> 列出提供有关分区表结构信息的函数。
   </para>
<!-- pgdoc-cn_end sig_en=f66f255a7a01233c24f2f8a09f54decc -->

   <table id="functions-info-partition">
<!-- pgdoc-cn_start sig_en=c2d23d5576582eec513b52c2d8a4e88b sig_cn_org=None source=14.1 
    <title>Partitioning Information Functions</title>
________________________________________________________-->
    <title>分区信息函数</title>
<!-- pgdoc-cn_end sig_en=c2d23d5576582eec513b52c2d8a4e88b -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=0f00bfb0a0c6f6de67ef05d57063c62a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_tree</primary>
        </indexterm>
        <function>pg_partition_tree</function> ( <type>regclass</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>relid</parameter> <type>regclass</type>,
        <parameter>parentrelid</parameter> <type>regclass</type>,
        <parameter>isleaf</parameter> <type>boolean</type>,
        <parameter>level</parameter> <type>integer</type> )
       </para>
       <para>
        Lists the tables or indexes in the partition tree of the
        given partitioned table or partitioned index, with one row for each
        partition.  Information provided includes the OID of the partition,
        the OID of its immediate parent, a boolean value telling if the
        partition is a leaf, and an integer telling its level in the hierarchy.
        The level value is 0 for the input table or index, 1 for its
        immediate child partitions, 2 for their partitions, and so on.
        Returns no rows if the relation does not exist or is not a partition
        or partitioned table.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_tree</primary>
        </indexterm>
        <function>pg_partition_tree</function> ( <type>regclass</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>relid</parameter> <type>regclass</type>,
        <parameter>parentrelid</parameter> <type>regclass</type>,
        <parameter>isleaf</parameter> <type>boolean</type>,
        <parameter>level</parameter> <type>integer</type> )
       </para>
       <para>
        列出给定分区表或分区索引的分区树中的表或索引，每行对应一个分区。 
        提供的信息包括分区的OID、其直接父的OID、一个布尔值以告知分区是否是叶子，以及一个整数用来告诉分区在层次结构中的级别。
        对于输入表或索引，级别值为0，其直接子分区的为1，它们的分区为2，以此类推。
        如果关系不存在，或者不是分区或分区表，则不返回行。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0f00bfb0a0c6f6de67ef05d57063c62a -->

<!-- pgdoc-cn_start sig_en=ead70f06a4f1e371e3abb401d518196b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_ancestors</primary>
        </indexterm>
        <function>pg_partition_ancestors</function> ( <type>regclass</type> )
        <returnvalue>setof regclass</returnvalue>
       </para>
       <para>
        Lists the ancestor relations of the given partition,
        including the relation itself.  Returns no rows if the relation
        does not exist or is not a partition or partitioned table.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_ancestors</primary>
        </indexterm>
        <function>pg_partition_ancestors</function> ( <type>regclass</type> )
        <returnvalue>setof regclass</returnvalue>
       </para>
       <para>
        列出给定分区的祖先关系，包括关系本身。如果关系不存在，或者不是分区或分区表，则不返回行。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ead70f06a4f1e371e3abb401d518196b -->

<!-- pgdoc-cn_start sig_en=035e3ebcf2e30fc3b21fd0572dfcee9b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_root</primary>
        </indexterm>
        <function>pg_partition_root</function> ( <type>regclass</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Returns the top-most parent of the partition tree to which the given
        relation belongs.  Returns <literal>NULL</literal> if the relation
        does not exist or is not a partition or partitioned table.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_root</primary>
        </indexterm>
        <function>pg_partition_root</function> ( <type>regclass</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        返回给定关系所属的分区树的最顶级父节点。如果关系不存在，或者不是分区或分区表，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=035e3ebcf2e30fc3b21fd0572dfcee9b -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=4eff5faf8c4ede5ae650727185cd36fb sig_cn_org=None source=14.1 
   <para>
    For example, to check the total size of the data contained in a
    partitioned table <structname>measurement</structname>, one could use the
    following query:
<programlisting>
SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
  FROM pg_partition_tree('measurement');
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，要检查分区表<structname>measurement</structname>中包含的数据的总大小，可以使用以下查询:
<programlisting>
SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
  FROM pg_partition_tree('measurement');
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4eff5faf8c4ede5ae650727185cd36fb -->

  </sect2>

  <sect2 id="functions-admin-index">
<!-- pgdoc-cn_start sig_en=ad52f0ce322208f304b2ca63ce07700e sig_cn_org=None source=14.1 
   <title>Index Maintenance Functions</title>
________________________________________________________-->
   <title>索引维护函数</title>
<!-- pgdoc-cn_end sig_en=ad52f0ce322208f304b2ca63ce07700e -->

<!-- pgdoc-cn_start sig_en=e7de88d28faff6b01a4a219cd9168c39 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="functions-admin-index-table"/> shows the functions
    available for index maintenance tasks.  (Note that these maintenance
    tasks are normally done automatically by autovacuum; use of these
    functions is only required in special cases.)
    These functions cannot be executed during recovery.
    Use of these functions is restricted to superusers and the owner
    of the given index.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-index-table"/> 显示了索引维护任务可以使用的函数。
    (注意，这些维护任务通常由自动清理(autovacuum)自动完成;只有在特殊情况下才需要使用这些函数。)
    这些函数在恢复过程中无法执行。这些函数的使用局限于超级用户和给定索引的所有者。
   </para>
<!-- pgdoc-cn_end sig_en=e7de88d28faff6b01a4a219cd9168c39 -->

   <table id="functions-admin-index-table">
<!-- pgdoc-cn_start sig_en=ad52f0ce322208f304b2ca63ce07700e sig_cn_org=None source=14.1 
    <title>Index Maintenance Functions</title>
________________________________________________________-->
    <title>索引维护函数</title>
<!-- pgdoc-cn_end sig_en=ad52f0ce322208f304b2ca63ce07700e -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=301aab57dd5afbb1f488b05d7a794aee sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_new_values</primary>
        </indexterm>
        <function>brin_summarize_new_values</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Scans the specified BRIN index to find page ranges in the base table
        that are not currently summarized by the index; for any such range it
        creates a new summary index tuple by scanning those table pages.
        Returns the number of new page range summaries that were inserted
        into the index.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_new_values</primary>
        </indexterm>
        <function>brin_summarize_new_values</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        扫描指定的BRIN索引以查找基表中当前没有被索引归纳的页面范围;
        对于任何这样的范围，它都通过扫描这些表页来创建一个新的摘要索引元组。
        返回插入到索引中的新页面范围摘要的数量。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=301aab57dd5afbb1f488b05d7a794aee -->

<!-- pgdoc-cn_start sig_en=9643eedcdfe3697c375c839266e543a2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_range</primary>
        </indexterm>
        <function>brin_summarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Summarizes the page range covering the given block, if not already
        summarized.  This is
        like <function>brin_summarize_new_values</function> except that it
        only processes the page range that covers the given table block number.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_range</primary>
        </indexterm>
        <function>brin_summarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        归纳(Summarizes)覆盖给定块的页面范围(如果还没有归纳的话)。
        这类似于<function>brin_summarize_new_values</function>，只是它只处理覆盖给定表块数的页范围。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9643eedcdfe3697c375c839266e543a2 -->

<!-- pgdoc-cn_start sig_en=5fdc2b8a2160e7c0ffd86de47aa86d28 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_desummarize_range</primary>
        </indexterm>
        <function>brin_desummarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Removes the BRIN index tuple that summarizes the page range covering
        the given table block, if there is one.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_desummarize_range</primary>
        </indexterm>
        <function>brin_desummarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        删除归纳了覆盖给定表块的页面范围的BRIN索引元组，如果有的话。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5fdc2b8a2160e7c0ffd86de47aa86d28 -->

<!-- pgdoc-cn_start sig_en=2aeab9d05a7c9830b895e3e1969cddbd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gin_clean_pending_list</primary>
        </indexterm>
        <function>gin_clean_pending_list</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Cleans up the <quote>pending</quote> list of the specified GIN index
        by moving entries in it, in bulk, to the main GIN data structure.
        Returns the number of pages removed from the pending list.
        If the argument is a GIN index built with
        the <literal>fastupdate</literal> option disabled, no cleanup happens
        and the result is zero, because the index doesn't have a pending list.
        See <xref linkend="gin-fast-update"/> and <xref linkend="gin-tips"/>
        for details about the pending list and <literal>fastupdate</literal>
        option.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gin_clean_pending_list</primary>
        </indexterm>
        <function>gin_clean_pending_list</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        清理指定GIN索引的<quote>pending</quote>列表，通过移除里面的条目，以大批的方式，到主要的GIN数据结构。
        返回从挂起列表中删除的页数。如果参数是使用禁用<literal>fastupdate</literal>选项构建的GIN索引，则不会发生清理，结果为零，因为索引没有挂起的列表。
        关于挂起列表和<literal>fastupdate</literal>选项的详细信息，请参见<xref linkend="gin-fast-update"/> 和 <xref linkend="gin-tips"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2aeab9d05a7c9830b895e3e1969cddbd -->
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-genfile">
<!-- pgdoc-cn_start sig_en=a441f201f8d4f7f6fdfbe439f3971afa sig_cn_org=None source=14.1 
   <title>Generic File Access Functions</title>
________________________________________________________-->
   <title>通用文件访问函数</title>
<!-- pgdoc-cn_end sig_en=a441f201f8d4f7f6fdfbe439f3971afa -->

<!-- pgdoc-cn_start sig_en=acdc6b1fe83d5ac8022ef5aeeb16b090 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref
    linkend="functions-admin-genfile-table"/> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</varname> can be
    accessed, unless the user is a superuser or is granted the role
    <literal>pg_read_server_files</literal>.  Use a relative path for files in
    the cluster directory, and a path matching the <varname>log_directory</varname>
    configuration setting for log files.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-admin-genfile-table"/>中展示的函数提供了对数据库服务器所在机器上的文件的本地访问。
    只能访问数据库集簇目录以及<varname>log_directory</varname>中的文件，除非用户是超级用户或者被授予了角色<literal>pg_read_server_files</literal>。 
    使用相对路径访问集簇目录里面的文件，以及匹配 <varname>log_directory</varname>配置设置的路径访问日志文件。
   </para>
<!-- pgdoc-cn_end sig_en=acdc6b1fe83d5ac8022ef5aeeb16b090 -->

<!-- pgdoc-cn_start sig_en=df1ec313135491fbc898368b5339fb3d sig_cn_org=None source=14.1 
   <para>
    Note that granting users the EXECUTE privilege on
    <function>pg_read_file()</function>, or related functions, allows them the
    ability to read any file on the server that the database server process can
    read; these functions bypass all in-database privilege checks.  This means
    that, for example, a user with such access is able to read the contents of
    the <structname>pg_authid</structname> table where authentication
    information is stored, as well as read any table data in the database.
    Therefore, granting access to these functions should be carefully
    considered.
   </para>
________________________________________________________-->
   <para>
    注意在<function>pg_read_file()</function>或者相关函数上，向用户授予EXECUTE特权，
    以允许他们有能力读取服务器上该数据库服务器进程能读取的任何文件；这些函数会绕过所有的数据库内特权检查。
    这意味着，例如，具有这种访问的用户能够读取<structname>pg_authid</structname>表中存储着认证信息的内容，也能读取数据库中的任何表数据。
    因此，授予对这些函数的访问应该要很仔细地考虑。
   </para>
<!-- pgdoc-cn_end sig_en=df1ec313135491fbc898368b5339fb3d -->

<!-- pgdoc-cn_start sig_en=4fb9551a637615f0b4856c12221a3105 sig_cn_org=None source=14.1 
   <para>
    Some of these functions take an optional <parameter>missing_ok</parameter>
    parameter, which specifies the behavior when the file or directory does
    not exist.  If <literal>true</literal>, the function
    returns <literal>NULL</literal> or an empty result set, as appropriate.
    If <literal>false</literal>, an error is raised.  The default
    is <literal>false</literal>.
   </para>
________________________________________________________-->
   <para>
    这些函数中的一些函数有可选的<parameter>missing_ok</parameter>参数，可以指定当文件或目录不存在时的行为。
    如果为<literal>true</literal>，函数返回<literal>NULL</literal>或着空结果集，根据适合情况。
    如果为<literal>false</literal>，会产生一个错误。默认为<literal>false</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=4fb9551a637615f0b4856c12221a3105 -->

   <table id="functions-admin-genfile-table">
<!-- pgdoc-cn_start sig_en=a441f201f8d4f7f6fdfbe439f3971afa sig_cn_org=None source=14.1 
    <title>Generic File Access Functions</title>
________________________________________________________-->
    <title>通用文件访问函数</title>
<!-- pgdoc-cn_end sig_en=a441f201f8d4f7f6fdfbe439f3971afa -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=cde0b650a846a1589b5b0d8858f77aed sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_dir</primary>
        </indexterm>
        <function>pg_ls_dir</function> ( <parameter>dirname</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the names of all files (and directories and other special
        files) in the specified
        directory. The <parameter>include_dot_dirs</parameter> parameter
        indicates whether <quote>.</quote> and <quote>..</quote> are to be
        included in the result set; the default is to exclude them.  Including
        them can be useful when <parameter>missing_ok</parameter>
        is <literal>true</literal>, to distinguish an empty directory from a
        non-existent directory.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_dir</primary>
        </indexterm>
        <function>pg_ls_dir</function> ( <parameter>dirname</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回指定目录中所有文件(和目录以及其他指定文件)的名称。
        <parameter>include_dot_dirs</parameter>参数标示在结果集中是否包括<quote>.</quote> 和 <quote>..</quote>；默认为不包括它们。
        要包括它们在<parameter>missing_ok</parameter>为 <literal>true</literal>时能够有用，以从不存在的目录中辨别一个空目录。
       </para>
       <para>
        这个函数默认限制为超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cde0b650a846a1589b5b0d8858f77aed -->

<!-- pgdoc-cn_start sig_en=0ae8a48f1462353b1587b70166be2708 sig_cn_org=db045b651d73fc4ceef59a425052bf3e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logdir</primary>
        </indexterm>
        <function>pg_ls_logdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's log directory.  Filenames beginning with
        a dot, directories, and other special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and roles with privileges of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logdir</primary>
        </indexterm>
        <function>pg_ls_logdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器日志目录中每个普通文件的名称、大小和最后修改时间（mtime）。以点开头的文件名、目录和其他特殊文件将被排除。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户和具有<literal>pg_monitor</literal>角色特权的角色，但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0ae8a48f1462353b1587b70166be2708 -->

<!-- pgdoc-cn_start sig_en=dff77819f5761b158261de3529205c13 sig_cn_org=ee6992aa5ba1b1959fdc2aa5d9d14528 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_waldir</primary>
        </indexterm>
        <function>pg_ls_waldir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's write-ahead log (WAL) directory.
        Filenames beginning with a dot, directories, and other special files
        are excluded.
       </para>
       <para>
        This function is restricted to superusers and roles with privileges of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_waldir</primary>
        </indexterm>
        <function>pg_ls_waldir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的预写式日志（WAL）目录中每个普通文件的名称、大小和最后修改时间（mtime）。
        以点开头的文件名、目录和其他特殊文件将被排除。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户和具有<literal>pg_monitor</literal>角色特权的角色，
        但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dff77819f5761b158261de3529205c13 -->

<!-- pgdoc-cn_start sig_en=2a25c81613b0b2c51f45bf6f92a2a1be sig_cn_org=d4751e3f12efd5d03ee17c7e39324af9 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logicalmapdir</primary>
        </indexterm>
        <function>pg_ls_logicalmapdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's <filename>pg_logical/mappings</filename>
        directory. Filenames beginning with a dot, directories, and other
        special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logicalmapdir</primary>
        </indexterm>
        <function>pg_ls_logicalmapdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的<filename>pg_logical/mappings</filename>目录中每个普通文件的名称、大小和最后修改时间（mtime）。
        以点开头的文件名、目录和其他特殊文件将被排除。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户和<literal>pg_monitor</literal>角色的成员，但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2a25c81613b0b2c51f45bf6f92a2a1be -->

<!-- pgdoc-cn_start sig_en=377a7a17046870d997374b6d21110d5c sig_cn_org=b596a7dbf1b2aca3f1cc5e59f69bb30e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logicalsnapdir</primary>
        </indexterm>
        <function>pg_ls_logicalsnapdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's <filename>pg_logical/snapshots</filename>
        directory. Filenames beginning with a dot, directories, and other
        special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logicalsnapdir</primary>
        </indexterm>
        <function>pg_ls_logicalsnapdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的<filename>pg_logical/snapshots</filename>目录中每个普通文件的名称、大小和最后修改时间（mtime）。
        以点开头的文件名、目录和其他特殊文件将被排除。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户和<literal>pg_monitor</literal>角色的成员，但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=377a7a17046870d997374b6d21110d5c -->

<!-- pgdoc-cn_start sig_en=2424fabd4099308d44a2b005206a78a9 sig_cn_org=67c863c91e2b463cb497382b0b7237cf source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_replslotdir</primary>
        </indexterm>
        <function>pg_ls_replslotdir</function> ( <parameter>slot_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's <filename>pg_replslot/slot_name</filename>
        directory, where <parameter>slot_name</parameter> is the name of the
        replication slot provided as input of the function. Filenames beginning
        with a dot, directories, and other special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_replslotdir</primary>
        </indexterm>
        <function>pg_ls_replslotdir</function> ( <parameter>slot_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的<filename>pg_replslot/slot_name</filename>目录中每个普通文件的名称、大小和最后修改时间（mtime），
        其中<parameter>slot_name</parameter>是作为函数输入提供的复制槽的名称。以点开头的文件名、目录和其他特殊文件将被排除。
       </para>
       <para>
        默认情况下，此函数仅限于超级用户和<literal>pg_monitor</literal>角色的成员，但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2424fabd4099308d44a2b005206a78a9 -->

<!-- pgdoc-cn_start sig_en=2c2c0d0c0793c755e4c55bccad4989fd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_archive_statusdir</primary>
        </indexterm>
        <function>pg_ls_archive_statusdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's WAL archive status directory
        (<filename>pg_wal/archive_status</filename>).  Filenames beginning
        with a dot, directories, and other special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_archive_statusdir</primary>
        </indexterm>
        <function>pg_ls_archive_statusdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的WAL归档状态目录(<filename>pg_wal/archive_status</filename>)中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2c2c0d0c0793c755e4c55bccad4989fd -->

<!-- pgdoc-cn_start sig_en=2238487269fb30757bfc3b2e8db9be0c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">

        <indexterm>
         <primary>pg_ls_tmpdir</primary>
        </indexterm>
        <function>pg_ls_tmpdir</function> ( <optional> <parameter>tablespace</parameter> <type>oid</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the temporary file directory for the
        specified <parameter>tablespace</parameter>.
        If <parameter>tablespace</parameter> is not provided,
        the <literal>pg_default</literal> tablespace is examined.  Filenames
        beginning with a dot, directories, and other special files are
        excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">

        <indexterm>
         <primary>pg_ls_tmpdir</primary>
        </indexterm>
        <function>pg_ls_tmpdir</function> ( <optional> <parameter>tablespace</parameter> <type>oid</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回针对指定<parameter>tablespace</parameter>的临时文件目录中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        如果<parameter>tablespace</parameter>没有提供，<literal>pg_default</literal> 表空间为被检验的。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2238487269fb30757bfc3b2e8db9be0c -->

<!-- pgdoc-cn_start sig_en=0edddfe13da377fc816d69585b90a3e8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_file</primary>
        </indexterm>
        <function>pg_read_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns all or part of a text file, starting at the
        given byte <parameter>offset</parameter>, returning at
        most <parameter>length</parameter> bytes (less if the end of file is
        reached first).  If <parameter>offset</parameter> is negative, it is
        relative to the end of the file.  If <parameter>offset</parameter>
        and <parameter>length</parameter> are omitted, the entire file is
        returned.  The bytes read from the file are interpreted as a string in
        the database's encoding; an error is thrown if they are not valid in
        that encoding.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_file</primary>
        </indexterm>
        <function>pg_read_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回一个文本文件的全部或部分，开始于给定的字节<parameter>offset</parameter>，在最大的<parameter>length</parameter>字节返回（如果文件的结尾先达到了则减少）。
        如果<parameter>offset</parameter>为负，他于文件的结尾有关。如果<parameter>offset</parameter>和<parameter>length</parameter> 被省略，整个文件被返回。
        从文件中读的字节在服务器的编码中解释为字符串；如果它们在哪些编码中不是有效的则抛出错误。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0edddfe13da377fc816d69585b90a3e8 -->

<!-- pgdoc-cn_start sig_en=d4c8b4b33bc954c3899b7f0b00b9a017 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_binary_file</primary>
        </indexterm>
        <function>pg_read_binary_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Returns all or part of a file.  This function is identical to
        <function>pg_read_file</function> except that it can read arbitrary
        binary data, returning the result as <type>bytea</type>
        not <type>text</type>; accordingly, no encoding checks are performed.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para>
       <para>
        In combination with the <function>convert_from</function> function,
        this function can be used to read a text file in a specified encoding
        and convert to the database's encoding:
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_binary_file</primary>
        </indexterm>
        <function>pg_read_binary_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        返回文件的全部或部分。这个函数与<function>pg_read_file</function> 是完全相同的，除了它可以读任意的二进制数据，返回结果为<type>bytea</type>而不是<type>text</type>；
        因此，没有编码检查会被执行。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para>
       <para>
        与 <function>convert_from</function>函数组合，这个函数能被用于以指定的编码读文本文件并转换到数据库的编码：
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4c8b4b33bc954c3899b7f0b00b9a017 -->

<!-- pgdoc-cn_start sig_en=444dba1084c0a111a862976ff8462026 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_file</primary>
        </indexterm>
        <function>pg_stat_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>size</parameter> <type>bigint</type>,
        <parameter>access</parameter> <type>timestamp with time zone</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type>,
        <parameter>change</parameter> <type>timestamp with time zone</type>,
        <parameter>creation</parameter> <type>timestamp with time zone</type>,
        <parameter>isdir</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns a record containing the file's size, last access time stamp,
        last modification time stamp, last file status change time stamp (Unix
        platforms only), file creation time stamp (Windows only), and a flag
        indicating if it is a directory.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_file</primary>
        </indexterm>
        <function>pg_stat_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>size</parameter> <type>bigint</type>,
        <parameter>access</parameter> <type>timestamp with time zone</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type>,
        <parameter>change</parameter> <type>timestamp with time zone</type>,
        <parameter>creation</parameter> <type>timestamp with time zone</type>,
        <parameter>isdir</parameter> <type>boolean</type> )
       </para>
       <para>
        返回一个记录，包含文件的大小、最后访问时间戳、最后修改时间戳，最后文件状态变更时间戳(仅在UNIX平台)、文件建立时间戳(仅Windows)，和一个标志旗如果它是一个目录。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=444dba1084c0a111a862976ff8462026 -->

     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-advisory-locks">
<!-- pgdoc-cn_start sig_en=75568272d8045f5a4884cde0822ea506 sig_cn_org=None source=14.1 
   <title>Advisory Lock Functions</title>
________________________________________________________-->
   <title>咨询锁函数</title>
<!-- pgdoc-cn_end sig_en=75568272d8045f5a4884cde0822ea506 -->

<!-- pgdoc-cn_start sig_en=b95c9c98ba34bdace7c93e4d77d8cc00 sig_cn_org=None source=14.1 
   <para>
    The functions shown in <xref linkend="functions-advisory-locks-table"/>
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks"/>.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-advisory-locks-table"/>中展示的函数管理咨询锁。
    有关正确使用这些函数的细节请参考<xref linkend="advisory-locks"/>。
   </para>
<!-- pgdoc-cn_end sig_en=b95c9c98ba34bdace7c93e4d77d8cc00 -->

<!-- pgdoc-cn_start sig_en=33a7054b124670ac2eee72879a6231b8 sig_cn_org=None source=14.1 
   <para>
    All these functions are intended to be used to lock application-defined
    resources, which can be identified either by a single 64-bit key value or
    two 32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a conflicting lock on the same resource
    identifier, the functions will either wait until the resource becomes
    available, or return a <literal>false</literal> result, as appropriate for
    the function.
    Locks can be either shared or exclusive: a shared lock does not conflict
    with other shared locks on the same resource, only with exclusive locks.
    Locks can be taken at session level (so that they are held until released
    or the session ends) or at transaction level (so that they are held until
    the current transaction ends; there is no provision for manual release).
    Multiple session-level lock requests stack, so that if the same resource
    identifier is locked three times there must then be three unlock requests
    to release the resource in advance of session end.
   </para>
________________________________________________________-->
   <para>
    所有这些函数都打算用于锁定应用程序定义的资源，可以通过一个64位键值或两个32位键值来标识(注意这两个键空间不能重叠)。
    如果另一个会话已经在相同的资源标识符上持有一个冲突的锁，函数将等待直到资源变成可用，或者返回一个<literal>false</literal>结果，合适于函数的。
    锁可以是共享或排他的:共享锁不会与同一资源上的其他共享锁发生冲突，只会与排他锁发生冲突。
    锁可以在会话级(这样它们被保持直到释放或会话结束)或在事务级(这样它们被保持直到当前事务结束;没有手动释放的供应)。
    多个会话级锁请求堆栈，因此如果同一个资源标识符被锁定三次，那么必须有三个解锁请求来释放资源，在会话结束之前。
   </para>
<!-- pgdoc-cn_end sig_en=33a7054b124670ac2eee72879a6231b8 -->

   <table id="functions-advisory-locks-table">
<!-- pgdoc-cn_start sig_en=75568272d8045f5a4884cde0822ea506 sig_cn_org=None source=14.1 
    <title>Advisory Lock Functions</title>
________________________________________________________-->
    <title>咨询锁函数</title>
<!-- pgdoc-cn_end sig_en=75568272d8045f5a4884cde0822ea506 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=d215617a77b84cb7920ce0d3163c3bb9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock</primary>
        </indexterm>
        <function>pg_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains an exclusive session-level advisory lock, waiting if necessary.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock</primary>
        </indexterm>
        <function>pg_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个排他的会话级咨询锁，如有必要则等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d215617a77b84cb7920ce0d3163c3bb9 -->

<!-- pgdoc-cn_start sig_en=7e5bf3d92a5d4f8e560abcc9142c2c79 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains a shared session-level advisory lock, waiting if necessary.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个共享的会话级咨询锁，如有必要则等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e5bf3d92a5d4f8e560abcc9142c2c79 -->

<!-- pgdoc-cn_start sig_en=e5ef8e41f5e9012f43877abc61466794 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock</primary>
        </indexterm>
        <function>pg_advisory_unlock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Releases a previously-acquired exclusive session-level advisory lock.
        Returns <literal>true</literal> if the lock is successfully released.
        If the lock was not held, <literal>false</literal> is returned, and in
        addition, an SQL warning will be reported by the server.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock</primary>
        </indexterm>
        <function>pg_advisory_unlock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        释放以前获取的排他会话级咨询锁。如果锁成功释放则返回<literal>true</literal>。
        如果锁没有被持有，则返回<literal>false</literal>，此外，服务器将报告一个SQL警告。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e5ef8e41f5e9012f43877abc61466794 -->

<!-- pgdoc-cn_start sig_en=48fd87d10a88c5ddc957e9a2ff2a6106 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_all</primary>
        </indexterm>
        <function>pg_advisory_unlock_all</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Releases all session-level advisory locks held by the current session.
        (This function is implicitly invoked at session end, even if the
        client disconnects ungracefully.)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_all</primary>
        </indexterm>
        <function>pg_advisory_unlock_all</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        释放当前会话所持有的所有会话级咨询锁。(即使客户端异常断开连接，这个函数也会在会话结束时被隐式调用。)
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=48fd87d10a88c5ddc957e9a2ff2a6106 -->

<!-- pgdoc-cn_start sig_en=3cc9402f05ba77666357a96b7694d375 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_shared</primary>
        </indexterm>
        <function>pg_advisory_unlock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Releases a previously-acquired shared session-level advisory lock.
        Returns <literal>true</literal> if the lock is successfully released.
        If the lock was not held, <literal>false</literal> is returned, and in
        addition, an SQL warning will be reported by the server.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_shared</primary>
        </indexterm>
        <function>pg_advisory_unlock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        释放以前获取的共享会话级咨询锁。如果锁成功释放则返回<literal>true</literal>。
        如果锁没有被持有，则返回<literal>false</literal>，此外，服务器将报告一个SQL警告。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3cc9402f05ba77666357a96b7694d375 -->

<!-- pgdoc-cn_start sig_en=7b2b9974b9207d1a618c3ed13e17577e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains an exclusive transaction-level advisory lock, waiting if
        necessary.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个排他的事务级咨询锁，如有必要则等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7b2b9974b9207d1a618c3ed13e17577e -->

<!-- pgdoc-cn_start sig_en=2360bb80fb6ebcbe7e870b9064f3e2dc sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains a shared transaction-level advisory lock, waiting if
        necessary.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个共享的事务级咨询锁，如有必要则等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=2360bb80fb6ebcbe7e870b9064f3e2dc -->

<!-- pgdoc-cn_start sig_en=3d63196017b55ed0831dd11385ac8d9c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock</primary>
        </indexterm>
        <function>pg_try_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains an exclusive session-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock</primary>
        </indexterm>
        <function>pg_try_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个排他的会话级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=3d63196017b55ed0831dd11385ac8d9c -->

<!-- pgdoc-cn_start sig_en=aa6efad08bbdabf5fadb405f50c07854 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains a shared session-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个共享的会话级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aa6efad08bbdabf5fadb405f50c07854 -->

<!-- pgdoc-cn_start sig_en=140ef5c1f65a0c3acd9bae9015d5c1ff sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains an exclusive transaction-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个排他的事务级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=140ef5c1f65a0c3acd9bae9015d5c1ff -->

<!-- pgdoc-cn_start sig_en=35e59ff6750126ae46c934698acc0efe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains a shared transaction-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个共享的事务级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=35e59ff6750126ae46c934698acc0efe -->
     </tbody>
    </tgroup>
   </table>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
<!-- pgdoc-cn_start sig_en=965893d4b4a1c249ddd8a87d973a20c7 sig_cn_org=None source=14.1 
   <title>Trigger Functions</title>
________________________________________________________-->
   <title>触发器函数</title>
<!-- pgdoc-cn_end sig_en=965893d4b4a1c249ddd8a87d973a20c7 -->

<!-- pgdoc-cn_start sig_en=78aea9c1a0da819494584837188048f3 sig_cn_org=None source=14.1 
  <para>
   While many uses of triggers involve user-written trigger functions,
   <productname>PostgreSQL</productname> provides a few built-in trigger
   functions that can be used directly in user-defined triggers.  These
   are summarized in <xref linkend="builtin-triggers-table"/>.
   (Additional built-in trigger functions exist, which implement foreign
   key constraints and deferred index constraints.  Those are not documented
   here since users need not use them directly.)
  </para>
________________________________________________________-->
  <para>
   虽然很多触发器的使用都涉及到用户编写的触发器函数，但<productname>PostgreSQL</productname>提供了一些可以直接在用户定义触发器中使用的内置触发器函数。
   这些总结在了<xref linkend="builtin-triggers-table"/>中。
   (另外还有一些内置的触发器函数存在，它们实现了外键约束和延期索引约束。因为用户不需要直接使用它们，所以这里就不做论述了。)
  </para>
<!-- pgdoc-cn_end sig_en=78aea9c1a0da819494584837188048f3 -->

<!-- pgdoc-cn_start sig_en=5b236e4bf229457fa8b8e42ea3a4d225 sig_cn_org=None source=14.1 
  <para>
   For more information about creating triggers, see
   <xref linkend="sql-createtrigger"/>.
  </para>
________________________________________________________-->
  <para>
   有关创建触发器的更多信息，请参考<xref linkend="sql-createtrigger"/>。
  </para>
<!-- pgdoc-cn_end sig_en=5b236e4bf229457fa8b8e42ea3a4d225 -->

   <table id="builtin-triggers-table">
<!-- pgdoc-cn_start sig_en=5f8a032a781a8a951240df8e2c699abf sig_cn_org=None source=14.1 
    <title>Built-In Trigger Functions</title>
________________________________________________________-->
    <title>内置触发器函数</title>
<!-- pgdoc-cn_end sig_en=5f8a032a781a8a951240df8e2c699abf -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=a955e8d0b2eb342dfaf700deec4aaa17 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example Usage
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        Example Usage
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a955e8d0b2eb342dfaf700deec4aaa17 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c747ff690c673c2b736206949f42f217 sig_cn_org=None source=14.1 
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>suppress_redundant_updates_trigger</primary>
        </indexterm>
        <function>suppress_redundant_updates_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Suppresses do-nothing update operations.  See below for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... suppress_redundant_updates_trigger()</literal>
       </para></entry>
      </row>
________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>suppress_redundant_updates_trigger</primary>
        </indexterm>
        <function>suppress_redundant_updates_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        阻止不做事的更新操作。详见下文。
       </para>
       <para>
        <literal>CREATE TRIGGER ... suppress_redundant_updates_trigger()</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c747ff690c673c2b736206949f42f217 -->

<!-- pgdoc-cn_start sig_en=d4b9a2d5d889bbbb25cce36372e9c564 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger</primary>
        </indexterm>
        <function>tsvector_update_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Automatically updates a <type>tsvector</type> column from associated
        plain-text document column(s).  The text search configuration to use
        is specified by name as a trigger argument.  See
        <xref linkend="textsearch-update-triggers"/> for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger</primary>
        </indexterm>
        <function>tsvector_update_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        自动从相关的纯文本文档列更新<type>tsvector</type>列。
        要使用的文本搜索配置是以名称指定为触发器参数。详情请参见<xref linkend="textsearch-update-triggers"/>。
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4b9a2d5d889bbbb25cce36372e9c564 -->

<!-- pgdoc-cn_start sig_en=9c874a62a70a6e8c421ef6480726cae3 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger_column</primary>
        </indexterm>
        <function>tsvector_update_trigger_column</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Automatically updates a <type>tsvector</type> column from associated
        plain-text document column(s).  The text search configuration to use
        is taken from a <type>regconfig</type> column of the table.  See
        <xref linkend="textsearch-update-triggers"/> for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, tsconfigcol, title, body)</literal>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger_column</primary>
        </indexterm>
        <function>tsvector_update_trigger_column</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        自动从相关的纯文本文档列更新<type>tsvector</type>列。
        要使用的文本搜索配置取自表的<type>regconfig</type>列。详情请参见<xref linkend="textsearch-update-triggers"/>。        
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, tsconfigcol, title, body)</literal>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9c874a62a70a6e8c421ef6480726cae3 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=8950a9c03180353bf2b0644dd8289044 sig_cn_org=None source=14.1 
   <para>
      The <function>suppress_redundant_updates_trigger</function> function,
      when applied as a row-level <literal>BEFORE UPDATE</literal> trigger,
      will prevent any update that does not actually change the data in the
      row from taking place.  This overrides the normal behavior which always
      performs a physical row update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
    </para>
________________________________________________________-->
   <para>
      <function>suppress_redundant_updates_trigger</function>函数，在作为行级<literal>BEFORE UPDATE</literal>触发器应用时，将阻止任何没有实际更改行中数据的更新发生。
      这会覆盖那种始终执行物理行更新而无论数据是否已更改的常规行为。
      (这种常规的行为使更新运行得更快，因为不需要检查，而且在某些情况下也很有用。)
    </para>
<!-- pgdoc-cn_end sig_en=8950a9c03180353bf2b0644dd8289044 -->

<!-- pgdoc-cn_start sig_en=6abc4f207d96c6e5b6bd97aac0b50b3a sig_cn_org=None source=14.1 
    <para>
      Ideally, you should avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</function>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by updates do actually change,
      use of this trigger will make updates run slower on average.
    </para>
________________________________________________________-->
    <para>
      理想的情况下，你应该避免运行实际上并没有改变记录中数据的更新。 
      冗余更新会花费大量不必要的时间，尤其是如果有大量索引要改变， 并将最终不得不清理被死亡行占用的空间。
      但是，在客户端代码中检测这种情况并不总是容易的，甚至不可能做到。 而写表达式来检测它们容易产生错误。
      作为替代，使用<function>suppress_redundant_updates_trigger</function>可以跳过不改变数据的更新。 但是，你需要小心使用它。
      触发器需要很短但不能忽略的时间来处理每条记录，所以如果受更新影响的大多数记录确实变化了，此触发器的使用将使更新比平均水平运行得更慢。
    </para>
<!-- pgdoc-cn_end sig_en=6abc4f207d96c6e5b6bd97aac0b50b3a -->

<!-- pgdoc-cn_start sig_en=718c8db1012ad80f6d8439a08eb8e2e7 sig_cn_org=None source=14.1 
    <para>
      The <function>suppress_redundant_updates_trigger</function> function can be
      added to a table like this:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      In most cases, you need to fire this trigger last for each row, so that
      it does not override other triggers that might wish to alter the row.
      Bearing in mind that triggers fire in name order, you would therefore
      choose a trigger name that comes after the name of any other trigger
      you might have on the table.  (Hence the <quote>z</quote> prefix in the
      example.)
    </para>
________________________________________________________-->
    <para>
      <function>suppress_redundant_updates_trigger</function>函数可以像这样添加到表中:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      在大多数情况下，你需要为每一行最后触发这个触发器，这样它就不会覆盖可能希望更改该行的其他触发器。
      请记住，触发器是按照名称顺序触发的，你将为此选择一个触发器名称，该名称位于表中可能存在的任何其他触发器的名称之后。
      (因此在示例中使用了<quote>z</quote>前缀。)
    </para>
<!-- pgdoc-cn_end sig_en=718c8db1012ad80f6d8439a08eb8e2e7 -->
  </sect1>

  <sect1 id="functions-event-triggers">
<!-- pgdoc-cn_start sig_en=ed6cc85b14d4010d0ac7fa14ba06ee65 sig_cn_org=None source=14.1 
   <title>Event Trigger Functions</title>
________________________________________________________-->
   <title>事件触发器函数</title>
<!-- pgdoc-cn_end sig_en=ed6cc85b14d4010d0ac7fa14ba06ee65 -->

<!-- pgdoc-cn_start sig_en=5b6e6058d10ea54091a215d3a423e84e sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides these helper functions
    to retrieve information from event triggers.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了这些助手函数来从事件触发器检索信息。
   </para>
<!-- pgdoc-cn_end sig_en=5b6e6058d10ea54091a215d3a423e84e -->

<!-- pgdoc-cn_start sig_en=3cd278f9b0fed5e17f95c5aaeaabf96d sig_cn_org=None source=14.1 
   <para>
    For more information about event triggers,
    see <xref linkend="event-triggers"/>.
   </para>
________________________________________________________-->
   <para>
    更多有关事件触发器的信息请见<xref linkend="event-triggers"/>。
   </para>
<!-- pgdoc-cn_end sig_en=3cd278f9b0fed5e17f95c5aaeaabf96d -->

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
<!-- pgdoc-cn_start sig_en=b4fb8f3c8364635466ab3632c20bcfdc sig_cn_org=None source=14.1 
   <title>Capturing Changes at Command End</title>
________________________________________________________-->
   <title>在命令结束处捕捉更改</title>
<!-- pgdoc-cn_end sig_en=b4fb8f3c8364635466ab3632c20bcfdc -->

<!-- pgdoc-cn_start sig_en=9286669ab02dfd71ad162572aad66a75 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9286669ab02dfd71ad162572aad66a75 -->

<!-- pgdoc-cn_start sig_en=e2e6c5a1a39aed37f2565c6e68748740 sig_cn_org=None source=14.1 
<synopsis>
<function>pg_event_trigger_ddl_commands</function> () <returnvalue>setof record</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>pg_event_trigger_ddl_commands</function> () <returnvalue>setof record</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=e2e6c5a1a39aed37f2565c6e68748740 -->

<!-- pgdoc-cn_start sig_en=c986e3af050f94496eec42eb9ffa2d17 sig_cn_org=None source=14.1 
   <para>
    <function>pg_event_trigger_ddl_commands</function> returns a list of
    <acronym>DDL</acronym> commands executed by each user action,
    when invoked in a function attached to a
    <literal>ddl_command_end</literal> event trigger.  If called in any other
    context, an error is raised.
    <function>pg_event_trigger_ddl_commands</function> returns one row for each
    base command executed; some commands that are a single SQL sentence
    may return more than one row.  This function returns the following
    columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belongs in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g., attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>Command tag</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belongs in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>True if the command is part of an extension script</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         A complete representation of the command, in internal format.
         This cannot be output directly, but it can be passed to other
         functions to obtain different pieces of information about the
         command.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    当在一个<literal>ddl_command_end</literal>事件触发器的函数中调用时，<function>pg_event_trigger_ddl_commands</function>返回被每一个用户动作执行的<acronym>DDL</acronym>命令的列表。
    如果在其他任何环境中调用这个函数，会发生错误。
    <function>pg_event_trigger_ddl_commands</function>为每一个被执行的基本命令返回一行，某些只有一个单一 SQL 句子的命令可能会返回多于一行。
    这个函数返回下面的列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>对象的子-id（例如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>命令标签</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         该对象所属的模式的名称（如果有），如果没有则为<literal>NULL</literal>。
         没有引号。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象标识的文本表现形式，用模式限定。如果必要，出现在
         该标识中的每一个标识符都会被引用。
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>如果该命令是一个扩展脚本的一部分则为真</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         以内部格式表达的该命令的一个完整表现形式。这不能被直接输出，
         但是可以把它传递给其他函数来得到有关于该命令不同部分的信息。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=c986e3af050f94496eec42eb9ffa2d17 -->
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
<!-- pgdoc-cn_start sig_en=5a934aadda3068b1045e0f5dcdb33741 sig_cn_org=None source=14.1 
   <title>Processing Objects Dropped by a DDL Command</title>
________________________________________________________-->
   <title>处理被 DDL 命令删除的对象</title>
<!-- pgdoc-cn_end sig_en=5a934aadda3068b1045e0f5dcdb33741 -->

<!-- pgdoc-cn_start sig_en=38979154bb73679d3bb758462617aa87 sig_cn_org=None source=14.1 
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=38979154bb73679d3bb758462617aa87 -->

<!-- pgdoc-cn_start sig_en=ff0c28398df59e7e094abb6ffa9c7cff sig_cn_org=None source=14.1 
<synopsis>
<function>pg_event_trigger_dropped_objects</function> () <returnvalue>setof record</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>pg_event_trigger_dropped_objects</function> () <returnvalue>setof record</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=ff0c28398df59e7e094abb6ffa9c7cff -->

<!-- pgdoc-cn_start sig_en=69dced0dd0904a904e49ff1cd5111a42 sig_cn_org=None source=14.1 
   <para>
    <function>pg_event_trigger_dropped_objects</function> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</literal> event it is called.
    If called in any other context, an error is raised.
    This function returns the following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belonged in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g., attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>True if this was one of the root object(s) of the deletion</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         True if there was a normal dependency relationship
         in the dependency graph leading to this object
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         True if this was a temporary object
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</literal>.
         No quoting is applied, and name is never schema-qualified.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         An array that, together with <literal>object_type</literal> and
         <literal>address_args</literal>, can be used by
         the <function>pg_get_object_address</function> function to
         recreate the object address in a remote server containing an
         identically named object of the same kind.
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         Complement for <literal>address_names</literal>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>返回被调用<literal>sql_drop</literal>事件的命令删除的所有对象的列表。
    如果调用在任何其他上下文中，会引发一个错误。这个函数返回以下列:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>子对象ID（如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>如果这是删除中的一个根对象则为真</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         指示在依赖图中有一个普通依赖关系指向该对象的标志
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         如果该对象是一个临时对象则为真
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象所属模式的名称（如果存在）；否则为<literal>NULL</literal>。不应用引用。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         如果模式和名称的组合能被用于对象的一个唯一标识符，则是对象的名称；否则是<literal>NULL</literal>。不应用引用，并且名称不是模式限定的。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         一个数组，它可以和<literal>object_type</literal>及<literal>address_args</literal>，
         一起通过<function>pg_get_object_address</function>函数在一台包含有同类相同名称对象的远程服务器上重建该对象地址。
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         上述<literal>address_names</literal>的补充。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=69dced0dd0904a904e49ff1cd5111a42 -->

<!-- pgdoc-cn_start sig_en=bd15a881301633495fc18c2e666ff72b sig_cn_org=None source=14.1 
   <para>
    The <function>pg_event_trigger_dropped_objects</function> function can be used
    in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END;
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>可以被这样用在一个事件触发器中：
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END;
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=bd15a881301633495fc18c2e666ff72b -->
  </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
<!-- pgdoc-cn_start sig_en=73697cb90ef49824e09c360bd9768491 sig_cn_org=None source=14.1 
   <title>Handling a Table Rewrite Event</title>
________________________________________________________-->
   <title>处理表重写事件</title>
<!-- pgdoc-cn_end sig_en=73697cb90ef49824e09c360bd9768491 -->

<!-- pgdoc-cn_start sig_en=8a22baaa071a9e99275dfc2ab5c8c14d sig_cn_org=None source=14.1 
   <para>
    The functions shown in
    <xref linkend="functions-event-trigger-table-rewrite"/>
    provide information about a table for which a
    <literal>table_rewrite</literal> event has just been called.
    If called in any other context, an error is raised.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="functions-event-trigger-table-rewrite"/>
    中所示的函数提供刚刚被调用过<literal>table_rewrite</literal>
    事件的表的信息。如果在任何其他环境中调用，会发生错误。
   </para>
<!-- pgdoc-cn_end sig_en=8a22baaa071a9e99275dfc2ab5c8c14d -->

   <table id="functions-event-trigger-table-rewrite">
<!-- pgdoc-cn_start sig_en=d90404071dbd952e5416e6876388a570 sig_cn_org=None source=14.1 
    <title>Table Rewrite Information Functions</title>
________________________________________________________-->
    <title>表重写信息函数</title>
<!-- pgdoc-cn_end sig_en=d90404071dbd952e5416e6876388a570 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=d3ba0a69d539d9fe382641147c746bda sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_oid</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_oid</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the table about to be rewritten.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_oid</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_oid</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回将要重写的表的OID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d3ba0a69d539d9fe382641147c746bda -->

<!-- pgdoc-cn_start sig_en=9631aad89708bc7189111883124c8d8d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_reason</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_reason</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns a code explaining the reason(s) for rewriting.  The exact
        meaning of the codes is release dependent.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_reason</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_reason</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回解释重写原因的代码。代码的确切含义取决于版本。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9631aad89708bc7189111883124c8d8d -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=d4005682c3f70b8f3e0651c3a7087f6a sig_cn_org=None source=14.1 
   <para>
    These functions can be used in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
________________________________________________________-->
   <para>
    这些函数可以在事件触发器中使用，就像这样:
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=d4005682c3f70b8f3e0651c3a7087f6a -->
  </sect2>
  </sect1>

  <sect1 id="functions-statistics">
<!-- pgdoc-cn_start sig_en=e8272ba9c1f991f198cd66c245dc2626 sig_cn_org=None source=14.1 
   <title>Statistics Information Functions</title>
________________________________________________________-->
   <title>统计信息函数</title>
<!-- pgdoc-cn_end sig_en=e8272ba9c1f991f198cd66c245dc2626 -->

<!-- pgdoc-cn_start sig_en=ce5dfa9895ec436afc489155e356782e sig_cn_org=None source=14.1 
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ce5dfa9895ec436afc489155e356782e -->

<!-- pgdoc-cn_start sig_en=188bbf866caee2f3dbdf8862dc05f297 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides a function to inspect complex
    statistics defined using the <command>CREATE STATISTICS</command> command.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了一个函数来检查使用<command>CREATE STATISTICS</command>命令定义的复杂统计。
   </para>
<!-- pgdoc-cn_end sig_en=188bbf866caee2f3dbdf8862dc05f297 -->

  <sect2 id="functions-statistics-mcv">
<!-- pgdoc-cn_start sig_en=176a1a84b78455cc030cd6e8432191fa sig_cn_org=None source=14.1 
   <title>Inspecting MCV Lists</title>
________________________________________________________-->
   <title>检查MCV列表</title>
<!-- pgdoc-cn_end sig_en=176a1a84b78455cc030cd6e8432191fa -->

<!-- pgdoc-cn_start sig_en=9c7ae4eaef35a9aebc7c63ae11666a4a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_mcv_list_items</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_mcv_list_items</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9c7ae4eaef35a9aebc7c63ae11666a4a -->

<!-- pgdoc-cn_start sig_en=1cd6ad9c039ce4d131484b7815edaadf sig_cn_org=None source=14.1 
<synopsis>
<function>pg_mcv_list_items</function> ( <type>pg_mcv_list</type> ) <returnvalue>setof record</returnvalue>
</synopsis>
________________________________________________________-->
<synopsis>
<function>pg_mcv_list_items</function> ( <type>pg_mcv_list</type> ) <returnvalue>setof record</returnvalue>
</synopsis>
<!-- pgdoc-cn_end sig_en=1cd6ad9c039ce4d131484b7815edaadf -->

<!-- pgdoc-cn_start sig_en=1d11aea2b65133d2a4ae4fe5ba188205 sig_cn_org=None source=14.1 
   <para>
    <function>pg_mcv_list_items</function> returns a set of records describing
    all items stored in a multi-column <acronym>MCV</acronym> list.  It
    returns the following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>integer</type></entry>
        <entry>index of the item in the <acronym>MCV</acronym> list</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>values stored in the MCV item</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>flags identifying <literal>NULL</literal> values</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>frequency of this <acronym>MCV</acronym> item</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>base frequency of this <acronym>MCV</acronym> item</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>返回一组记录，描述存储在多列<acronym>MCV</acronym>列表中的所有项目。它返回以下列:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>integer</type></entry>
        <entry> <acronym>MCV</acronym> 列表中的项目索引</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>存储在MCV项目中的值</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>标识<literal>NULL</literal>值的标志</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的频率</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的基本频率</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=1d11aea2b65133d2a4ae4fe5ba188205 -->

<!-- pgdoc-cn_start sig_en=b3a306426433fce65a6a478c2b86b499 sig_cn_org=None source=14.1 
   <para>
    The <function>pg_mcv_list_items</function> function can be used like this:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

    Values of the <type>pg_mcv_list</type> type can be obtained only from the
    <structname>pg_statistic_ext_data</structname>.<structfield>stxdmcv</structfield>
    column.
   </para>
________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>函数可以这样使用:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

    <type>pg_mcv_list</type>类型的值只能从<structname>pg_statistic_ext_data</structname>.<structfield>stxdmcv</structfield>列中获取。
   </para>
<!-- pgdoc-cn_end sig_en=b3a306426433fce65a6a478c2b86b499 -->
  </sect2>

  </sect1>

</chapter>
