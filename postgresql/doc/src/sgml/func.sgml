<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
<!--==========================orignal english content==========================
  <title>Functions and Operators</title>
____________________________________________________________________________-->
  <title>函数和操作符</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  This chapter
   describes most of them, although additional special-purpose functions
   appear in relevant sections of the manual.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming"/>.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>为内建的数据类型提供了大量的函数和操作符。 
   本章描述了其中的大部分内容，不过在手册的相关章节中还显示了更多的特殊用途函数。
   用户也可以定义它们自己的函数和操作符， 如<xref linkend="server-programming"/>所述。
   <application>psql</application>命令<command>\df</command>和<command>\do</command>可以分别被用于显示所有可用的函数和操作符的列表。
  </para>

<!--==========================orignal english content==========================
  <para>
   The notation used throughout this chapter to describe the argument and
   result data types of a function or operator is like this:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   which says that the function <function>repeat</function> takes one text and
   one integer argument and returns a result of type text.  The right arrow
   is also used to indicate the result of an example, thus:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   本章中用于描述函数或操作符的参数和结果数据类型的符号如下所示:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   函数<function>repeat</function>接受一个文本和一个整型参数，并返回文本类型的结果。右箭头也用于指示举例的结果，因此:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.
  </para>
____________________________________________________________________________-->
  <para>
   如果你关心移植性，那么请注意，我们在本章描述的大多数函数和操作符， 除了最琐碎的算术和比较操作符以及一些做了明确标记的函数以外，都没有在<acronym>SQL</acronym>标准里声明。某些这种扩展的功能也出现在许多其它<acronym>SQL</acronym>数据库管理系统中，并且在很多情况下多个实现的这种功能是相互兼容的和一致的。
  </para>


  <sect1 id="functions-logical">
<!--==========================orignal english content==========================
   <title>Logical Operators</title>
____________________________________________________________________________-->
   <title>逻辑操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The usual logical operators are available:

    <indexterm>
     <primary>AND (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>OR (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>NOT (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    常用的逻辑操作符有：

    <indexterm>
     <primary>AND（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>OR（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>NOT（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym>使用三值的逻辑系统，包括真、假和<literal>null</literal>，<literal>null</literal>表示<quote>未知</quote>。观察下面的真值表：

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operands
    without affecting the result.  (However, it is not guaranteed that
    the left operand is evaluated before the right operand.  See <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.)
   </para>
____________________________________________________________________________-->
   <para>
    操作符<literal>AND</literal>和<literal>OR</literal>是可交换的，也就是说，你可以交换左右操作数而不影响结果。
    （但是，不能保证左操作数在右操作数之前计算。参见<xref linkend="syntax-express-eval"/>获取有关子表达式计算顺序的更多信息。）
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--==========================orignal english content==========================
   <title>Comparison Functions and Operators</title>
____________________________________________________________________________-->
   <title>比较函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    常见的比较操作符都可用，如<xref linkend="functions-comparison-op-table"/>所示。
   </para>

   <table id="functions-comparison-op-table">
<!--==========================orignal english content==========================
    <title>Comparison Operators</title>
____________________________________________________________________________-->
    <title>比较操作符</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operator</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than or equal to</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than or equal to</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     <literal>&lt;&gt;</literal> is the standard SQL notation for <quote>not
     equal</quote>.  <literal>!=</literal> is an alias, which is converted
     to <literal>&lt;&gt;</literal> at a very early stage of parsing.
     Hence, it is not possible to implement <literal>!=</literal>
     and <literal>&lt;&gt;</literal> operators that do different things.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>&lt;&gt;</literal> 表示 <quote>not equal</quote> 的标准的SQL符号。
     <literal>!=</literal> 是一个别名, 在解析的早期阶段被转换为 <literal>&lt;&gt;</literal> 。
     因此, 它不可能实现 <literal>!=</literal> 和 <literal>&lt;&gt;</literal> 操作符以做不同的事情。
   </note>

<!--==========================orignal english content==========================
   <para>
    These comparison operators are available for all built-in data types
    that have a natural ordering, including numeric, string, and date/time
    types.  In addition, arrays, composite types, and ranges can be compared
    if their component data types are comparable.
   </para>
____________________________________________________________________________-->
   <para>
    这些比较操作符适用于所有具有自然排序的内置数据类型，包括数字、字符串、和日期/时间类型。 
    此外，如果它们的组件数据类型具有可比性，则可以比较阵列、复合类型和范围。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is usually possible to compare values of related data
    types as well; for example <type>integer</type> <literal>&gt;</literal>
    <type>bigint</type> will work.  Some cases of this sort are implemented
    directly by <quote>cross-type</quote> comparison operators, but if no
    such operator is available, the parser will coerce the less-general type
    to the more-general type and apply the latter's comparison operator.
   </para>
____________________________________________________________________________-->
   <para>
    通常也可以比较相关数据类型的值；例如<type>integer</type> <literal>&gt;</literal> <type>bigint</type> 将起作用。
    这种排序的某些情况直接由<quote>cross-type</quote> 比较操作符实现，但是，如果没有这种操作符，解析器将把不太通用的类型强制为更通用的类型，并应用后者的比较操作符。
   </para>

<!--==========================orignal english content==========================
   <para>
    As shown above, all comparison operators are binary operators that
    return values of type <type>boolean</type>.  Thus, expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).  Use the <literal>BETWEEN</literal> predicates
    shown below to perform range tests.
   </para>
____________________________________________________________________________-->
   <para>
    如上所示，所有比较操作符都是二元操作符，返回<type>boolean</type>类型的值。
    因此，类似<literal>1 &lt; 2 &lt; 3</literal>的表达式是无效的。因为没有<literal>&lt;</literal>操作符与 <literal>3</literal> 进行Boolean值比较）。
    使用下面显示的<literal>BETWEEN</literal>谓词执行范围测试。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-pred-table"/>所示，也有一些比较谓词。它们的行为和操作符很像，但是具有 SQL 标准所要求的特殊语法。
   </para>

   <table id="functions-comparison-pred-table">
<!--==========================orignal english content==========================
    <title>Comparison Predicates</title>
____________________________________________________________________________-->
    <title>比较谓词</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词
       </para>
       <para>
        描述
       </para>
       <para>
        示例(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between (inclusive of the range endpoints).
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间(包括范围端点)。
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between (the negation of <literal>BETWEEN</literal>).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间 (<literal>BETWEEN</literal>的否定).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null.
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空。
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null.
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空。
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null (nonstandard syntax).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空（非标准语法）。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null (nonstandard syntax).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空（非标准语法）。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true.
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真。
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false or unknown.
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假或未知。
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false.
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假。
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or unknown.
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或未知。
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields unknown.
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为未知。
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or false.
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或假。
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    The <token>BETWEEN</token> predicate simplifies range tests:
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    is equivalent to
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <token>BETWEEN</token>谓词可以简化范围测试：
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    等效于
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    注意<token>BETWEEN</token>认为终点值是包含在范围内的。
    <literal>BETWEEN SYMMETRIC</literal> 就像<literal>BETWEEN</literal>，除了没有要求<literal>AND</literal>的左边的参数小于或等于右边的参数。
    如果不是的话，这两个参数将自动交换，因此总是隐含一个非空范围。。
   </para>

<!--==========================orignal english content==========================
   <para>
    The various variants of <literal>BETWEEN</literal> are implemented in
    terms of the ordinary comparison operators, and therefore will work for
    any data type(s) that can be compared.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>BETWEEN</literal>的各种变量都是以普通比较操作符的方式实现的，因此适用于任何可以比较的数据类型。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The use of <literal>AND</literal> in the <literal>BETWEEN</literal>
     syntax creates an ambiguity with the use of <literal>AND</literal> as a
     logical operator.  To resolve this, only a limited set of expression
     types are allowed as the second argument of a <literal>BETWEEN</literal>
     clause.  If you need to write a more complex sub-expression
     in <literal>BETWEEN</literal>, write parentheses around the
     sub-expression.
    </para>
____________________________________________________________________________-->
    <para>
     在<literal>BETWEEN</literal>语法中使用<literal>AND</literal>会与使用<literal>AND</literal>作为逻辑操作符产生歧义。 
     为了解决这个问题，只允许有限的一组表达类型作为<literal>BETWEEN</literal>子句的第二个参数。 
     如果您需要在<literal>BETWEEN</literal>中写一个更复杂的子表达式，在子表达式两边写上圆括号。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    当有一个输入为空时，普通的比较操作符会得到空（表示<quote>未知</quote>），而不是真或假。例如，<literal>7 = NULL</literal>得到空，<literal>7 &lt;&gt; NULL</literal>也一样。如果这种行为不合适，可以使用<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>谓词：
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    对于非空输入，<literal>IS DISTINCT FROM</literal>和<literal>&lt;&gt;</literal>操作符一样。不过，如果两个输入都为空，它会返回假。而如果只有一个输入为空，它会返回真。类似地，<literal>IS NOT DISTINCT FROM</literal>对于非空输入的行为与<literal>=</literal>相同，但是当两个输入都为空时它返回真，并且当只有一个输入为空时返回假。因此，这些谓词实际上把空值当作一种普通数据值而不是<quote>unknown</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    To check whether a value is or is not null, use the predicates:
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    or the equivalent, but nonstandard, predicates:
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    要检查一个值是否为空，使用下面的谓词：
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    或者等效，但并不标准的谓词：
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>

<!--==========================orignal english content==========================
   <para>
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
   </para>
____________________________________________________________________________-->
   <para>
    <emphasis>不要</emphasis>写<literal><replaceable>expression</replaceable> = NULL</literal>，因为<literal>NULL</literal>是不<quote>等于</quote><literal>NULL</literal>的（控制代表一个未知的值，因此我们无法知道两个未知的数值是否相等）。
   </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    有些应用可能要求表达式<literal><replaceable>expression</replaceable> = NULL</literal>在<replaceable>expression</replaceable>得出空值时返回真。我们强烈建议这样的应用修改成遵循 SQL 标准。但是，如果这样修改不可能完成，那么我们可以使用配置变量<xref linkend="guc-transform-null-equals"/>。如果打开它，<productname>PostgreSQL</productname>将把<literal>x = NULL</literal>子句转换成<literal>x IS NULL</literal>。
   </para>
  </tip>

<!--==========================orignal english content==========================
   <para>
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
   </para>
____________________________________________________________________________-->
   <para>
    如果<replaceable>expression</replaceable>是行值，那么当行表达式本身为非空值或者行的所有域为非空时<literal>IS NULL</literal>为真。由于这种行为，<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>并不总是为行值表达式返回反转的结果，特别是，一个同时包含 NULL 和非空值的域将会对两种测试都返回假。在某些情况下，写成<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>或者<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>会更好，它们只会检查整个行值是否为空而不需要在行的域上做额外的测试。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    Boolean values can also be tested using the predicates
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    布尔值也可以使用下列谓词进行测试：
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    这些谓词将总是返回真或假，从来不返回空值，即使操作数是空也如此。空值输入被当做逻辑值<quote>未知</quote>。 请注意实际上<literal>IS UNKNOWN</literal>和<literal>IS NOT UNKNOWN</literal>分别与<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>相同， 只是输入表达式必须是布尔类型。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

<!--==========================orignal english content==========================
   <para>
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-func-table"/>中所示，也有一些比较相关的函数可用。
   </para>

  <table id="functions-comparison-func-table">
<!--==========================orignal english content==========================
    <title>Comparison Functions</title>
____________________________________________________________________________-->
    <title>比较函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of non-null arguments.
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回非空参数的数量。
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of null arguments.
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回空参数的数量。
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!--==========================orignal english content==========================
   <title>Mathematical Functions and Operators</title>
____________________________________________________________________________-->
   <title>数学函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>为很多类型提供了数学操作符。对于那些没有标准数学表达的类型（如日期/时间类型），我们将在后续小节中描述实际的行为。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-math-op-table"/> shows the mathematical
    operators that are available for the standard numeric types.
    Unless otherwise noted, operators shown as
    accepting <replaceable>numeric_type</replaceable> are available for all
    the types <type>smallint</type>, <type>integer</type>,
    <type>bigint</type>, <type>numeric</type>, <type>real</type>,
    and <type>double precision</type>.
    Operators shown as accepting <replaceable>integral_type</replaceable>
    are available for the types <type>smallint</type>, <type>integer</type>,
    and <type>bigint</type>.
    Except where noted, each form of an operator returns the same data type
    as its argument(s).  Calls involving multiple argument data types, such
    as <type>integer</type> <literal>+</literal> <type>numeric</type>,
    are resolved by using the type appearing later in these lists.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-math-op-table"/> 显示了可用于标准数字类型的数学操作符。.
    除非另有说明, 显示为可接受 <replaceable>numeric_type</replaceable> 的操作符对所有的 <type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type> 和 <type>double precision</type>类型都可用。
    显示为可接受 <replaceable>integral_type</replaceable> 的操作符对 <type>smallint</type>、<type>integer</type> 和 <type>bigint</type>类型是可用的。
    除了特别说明之处，操作符的每种形式都返回与其参数相同的数据类型。
    涉及多个参数数据类型的调用， 例如 <type>integer</type> <literal>+</literal> <type>numeric</type>，可通过使用这些列表中稍后出现的类型来解析。
   </para>

   <table id="functions-math-op-table">
<!--==========================orignal english content==========================
    <title>Mathematical Operators</title>
____________________________________________________________________________-->
    <title>数学操作符</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        加
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        一元加(无操作)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        减
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Negation
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        否定
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        乘
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Division (for integral types, division truncates the result towards
        zero)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        除(对于整型，除法将结果截断为零)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder); available for <type>smallint</type>,
        <type>integer</type>, <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        模（取余）; 适用于 <type>smallint</type>，<type>integer</type>，<type>bigint</type> 和 <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponentiation (unlike typical mathematical practice, multiple uses of
        <literal>^</literal> will associate left to right)
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数 (不像典型的数学实践, 多次使用 <literal>^</literal> 将会从左到有关联)
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>!</literal>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial
        (deprecated, use <link linkend="function-factorial"><function>factorial()</function></link> instead)
       </para>
       <para>
        <literal>5 !</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>!</literal>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘(已弃用, 使用 <link linkend="function-factorial"><function>factorial()</function></link> 代替)
       </para>
       <para>
        <literal>5 !</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>bigint</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial as a prefix operator
        (deprecated, use <link linkend="function-factorial"><function>factorial()</function></link> instead)
       </para>
       <para>
        <literal>!! 5</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>bigint</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘作为前缀操作符(已弃用, 使用 <link linkend="function-factorial"><function>factorial()</function></link> 代替)
       </para>
       <para>
        <literal>!! 5</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise AND
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位与(AND)
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise OR
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位或(OR)
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise exclusive OR
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位异或(exclusive OR)
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位求反(NOT)
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift left
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位左移
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift right
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位右移
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.
   Many of these functions are provided in multiple forms with different
   argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument(s); cross-type cases are resolved in the
   same way as explained above for operators.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-func-table"/> 显示了可用的数学函数。
   许多这样的函数以多种具有不同的参数类型的形式提供。
   除非注明，任何给定形式的函数都返回与其参数相同的数据类型;跨类型情况的解决方法与上述对操作符的解释相同。
   使用<type>double precision</type>数据的函数大多是在主机系统的C库上实现的;
   因此，边界情况下的准确性和行为会因主机系统的区别而不同。
  </para>

   <table id="functions-math-func-table">
<!--==========================orignal english content==========================
    <title>Mathematical Functions</title>
____________________________________________________________________________-->
    <title>数学函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument (same
        as <function>ceil</function>)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数 (与 <function>ceil</function> 相同)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts radians to degrees
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将弧度转换为角度
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Integer quotient of <parameter>y</parameter>/<parameter>x</parameter>
        (truncates towards zero)
       </para>
       <para>
        <literal>div(9,4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter> 的整数商（截断为零位）
       </para>
       <para>
        <literal>div(9,4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponential (<literal>e</literal> raised to the given power)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数 (<literal>e</literal> 的给定次方)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to argument
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        小于或等于参数的最接近整数
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Greatest common divisor (the largest positive number that divides both
        inputs with no remainder); returns <literal>0</literal> if both inputs
        are zero; available for <type>integer</type>, <type>bigint</type>,
        and <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最大公约数 (能将两个输入数整除而无余数的最大正数); 如果两个输入为零则返回 <literal>0</literal> ; 适用于 <type>integer</type>, <type>bigint</type>,和 <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Least common multiple (the smallest strictly positive number that is
        an integral multiple of both inputs); returns <literal>0</literal> if
        either input is zero; available for <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最小公倍数(两个输入的整数倍的最小的严格正数)；如果任意一个输入值为零则返回<literal>0</literal>；适用于<type>integer</type>，<type>bigint</type>，和 <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Natural logarithm
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        自然对数
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm (same as <function>log</function>)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数 (与 <function>log</function> 相同)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Logarithm of <parameter>x</parameter> to base <parameter>b</parameter>
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        以 <parameter>b</parameter> 为底的 parameter>x</parameter>的对数
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Minimum scale (number of fractional decimal digits) needed
        to represent the supplied value precisely
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        精确表示所提供值所需的最小刻度（小数位数）
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Remainder of <parameter>y</parameter>/<parameter>x</parameter>;
        available for <type>smallint</type>, <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>mod(9,4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的余数；
        适用于<type>smallint</type>、<type>integer</type>、<type>bigint</type>、和 <type>numeric</type>
       </para>
       <para>
        <literal>mod(9,4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Approximate value of <phrase role="symbol_font">&pi;</phrase>
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
         <phrase role="symbol_font">&pi;</phrase>的近似值
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter> raised to the power of <parameter>b</parameter>
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter>的<parameter>b</parameter>次幂
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts degrees to radians
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将角度转换为弧度
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Rounds to nearest integer
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        四舍五入到最近的整数
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Rounds <parameter>v</parameter> to <parameter>s</parameter> decimal
        places
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        把 <parameter>v</parameter> 四舍五入到 <parameter>s</parameter> 位小数
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Scale of the argument (the number of decimal digits in the fractional part)
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        参数的刻度（小数点后的位数）
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sign of the argument (-1, 0, or +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        参数的符号 (-1, 0, 或 +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Reduces the value's scale (number of fractional decimal digits) by
        removing trailing zeroes
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        通过删除尾数部分的零来降低值的刻度(小数位数)
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Truncates to integer (towards zero)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        截断整数 (向零靠近)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Truncates <parameter>v</parameter> to <parameter>s</parameter>
        decimal places
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        截断 <parameter>v</parameter> 到 <parameter>s</parameter> 位小数位置的数字
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls in a histogram
        having <parameter>count</parameter> equal-width buckets spanning the
        range <parameter>low</parameter> to <parameter>high</parameter>.
        Returns <literal>0</literal>
        or <literal><parameter>count</parameter>+1</literal> for an input
        outside that range.
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回包含<parameter>count</parameter>等宽柱的柱状图中<parameter>operand</parameter>所在的柱的编号，范围从<parameter>low</parameter>到<parameter>high</parameter>。
        超出该范围的输入则返回<literal>0</literal>或<literal><parameter>计数</parameter>+1</literal>。
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls given an array listing the
        lower bounds of the buckets.  Returns <literal>0</literal> for an
        input less than the first lower
        bound.  <parameter>operand</parameter> and the array elements can be
        of any type having standard comparison operators.
        The <parameter>thresholds</parameter> array <emphasis>must be
        sorted</emphasis>, smallest first, or unexpected results will be
        obtained.
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个柱号，这个柱是在给定数组中<parameter>operand</parameter>将被分配的柱。
        对于一个低于第一个下界的输入返回<literal>0</literal>。
        <parameter>operand</parameter>和数组元素可以是具有标准比较操作符的任何类型。
        <parameter>thresholds</parameter>数组<emphasis>必须被排好序</emphasis>，最小的排在最前面，否则将会得到意想不到的结果。
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
  </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-math-random-table"/>展示了用于产生随机数的函数。
  </para>

   <table id="functions-math-random-table">
<!--==========================orignal english content==========================
    <title>Random Functions</title>
____________________________________________________________________________-->
    <title>随机函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns a random value in the range 0.0 &lt;= x &lt; 1.0
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回一个范围 0.0 &lt;= x &lt; 1.0 中的随机值
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Sets the seed for subsequent <literal>random()</literal> calls;
        argument must be between -1.0 and 1.0, inclusive
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        为后续的<literal>random()</literal>调用设置种子；参数必须在-1.0和1.0之间，包括边界值
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   The <function>random()</function> function uses a simple linear
   congruential algorithm.  It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the series of results of
   subsequent <function>random()</function> calls in the current session
   can be repeated by re-issuing <function>setseed()</function> with the same
   argument.
  </para>
____________________________________________________________________________-->
  <para>
   <function>random()</function>函数使用了一个简单的线性共轭算法。 
   它的速度很快，但不适合于密码学应用；关于更安全的替代方案，请参阅 <xref linkend="pgcrypto"/>模块。 
   如果<function>setseed()</function>被调用，那么当前会话中的一系列后续<function>random()</function>调用的结果能够通过使用相同的参数重新发布<function>setseed()</function>来重复。
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  Each of these functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-trig-table"/>显示了可用的三角函数。
   每一种这样的函数都有两个变体，一个以弧度度量角，另一个以角度度量角。
  </para>

   <table id="functions-math-trig-table">
<!--==========================orignal english content==========================
    <title>Trigonometric Functions</title>
____________________________________________________________________________-->
    <title>三角函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in radians
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为弧度
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in degrees
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为度数
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in radians
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为弧度
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in degrees
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为度数
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in radians
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为弧度
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in degrees
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为度数
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in radians
       </para>
       <para>
        <literal>atan2(1,0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为弧度
       </para>
       <para>
        <literal>atan2(1,0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in degrees
       </para>
       <para>
        <literal>atan2d(1,0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为度数
       </para>
       <para>
        <literal>atan2d(1,0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in radians
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为弧度
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in degrees
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为度数
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in radians
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为弧度
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in degrees
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为度数
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in radians
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为弧度
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in degrees
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为度数
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in radians
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为弧度
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in degrees
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为度数
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    另一种使用以角度度量的角的方法是使用早前展示的单位转换函数<literal><function>radians()</function></literal>和<literal><function>degrees()</function></literal>。不过，使用基于角度的三角函数更好，因为这类方法能避免<literal>sind(30)</literal>等特殊情况下的舍入偏差。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-hyp-table"/>显示的是可用的双曲函数。
  </para>

  <table id="functions-math-hyp-table">
<!--==========================orignal english content==========================
    <title>Hyperbolic Functions</title>
____________________________________________________________________________-->
    <title>双曲函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic sine
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲正弦
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic cosine
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲余弦
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic tangent
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲切线
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic sine
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲正弦
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic cosine
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲余弦
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic tangent
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲切线
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--==========================orignal english content==========================
   <title>String Functions and Operators</title>
____________________________________________________________________________-->
   <title>字符串函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Except where noted, these functions and operators
    are declared to accept and return type <type>text</type>.  They will
    interchangeably accept <type>character varying</type> arguments.
    Values of type <type>character</type> will be converted
    to <type>text</type> before the function or operator is applied, resulting
    in stripping any trailing spaces in the <type>character</type> value.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述了用于检查和操作字符串值的函数和操作符。
    在这个环境中的串包括所有类型<type>character</type>、<type>character varying</type>和<type>text</type>的值。
    除非特别说明，这些函数和操作符声明为接受并返回<type>text</type>类型。
    他们将互换接受<type>character varying</type>参数。
    在应用函数或操作符之前<type>character</type>类型的值将被转换为<type>text</type>，结果删除<type>character</type>值中的任何末尾空格。
   </para>

<!--==========================orignal english content==========================
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些字符串函数，它们使用关键字，而不是逗号来分隔参数。详情请见<xref linkend="functions-string-sql"/>，<productname>PostgreSQL</productname>也提供了这些函数使用正常函数调用语法的版本（见<xref linkend="functions-string-other"/>）。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</type>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</literal>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql"/>.  For other cases, insert an explicit
     coercion to <type>text</type> if you need to duplicate the previous behavior.
    </para>
____________________________________________________________________________-->
    <para>
     由于存在从那些数据类型到<type>text</type>的隐式强制措施，在<productname>PostgreSQL</productname> 8.3之前，这些函数也可以接受多种非字符串数据类型。这些强制措施在目前的版本中已经被删除，因为它们常常导致令人惊讶的行为。不过，字符串串接操作符（<literal>||</literal>）仍然接受非字符串输入，只要至少一个输入是一种字符串类型，如<xref linkend="functions-string-sql"/>所示。对于其他情况，如果你需要复制之前的行为，可以为<type>text</type>插入一个显式强制措施。
    </para>
   </note>

   <table id="functions-string-sql">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> String Functions and Operators</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym>字符串函数和操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the two strings.
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接两个字符串。
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the non-string input to text, then concatenates the two
        strings.  (The non-string input cannot be of an array type, because
        that would create ambiguity with the array <literal>||</literal>
        operators.  If you want to concatenate an array's text equivalent,
        cast it to <type>text</type> explicitly.)
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将非字符串输入转换为文本，然后将两个字符串串联在一起。
        （非字符串输入不能为数组类型，因为这将在<literal>||</literal>操作符的数组中造成歧义。如果你想连接一个数组的文本相等的，请显式地将其转换为<type>text</type> 。）
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
		Checks whether the string is in the specified Unicode normalization
        form.  The optional <parameter>form</parameter> key word specifies the
        form: <literal>NFC</literal> (the default), <literal>NFD</literal>,
        <literal>NFKC</literal>, or <literal>NFKD</literal>.  This expression can
        only be used when the server encoding is <literal>UTF8</literal>.  Note
        that checking for normalization using this expression is often faster
        than normalizing possibly already normalized strings.
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
		检查字符串是否在指定的 Unicode 规范化表单中。
		可选的<parameter>form</parameter>关键词指定表单：<literal>NFC</literal> (默认的), <literal>NFD</literal>, <literal>NFKC</literal>, 或 <literal>NFKD</literal>。 
		只有在服务器编码为<literal>UTF8</literal>时，才能使用此表达式。
		请注意，使用这个表达式检查规范化通常比规范化可能已经规范化的字符串要快。
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的位数(8倍于<function>octet_length</function>)。
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of characters in the string.
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all lower case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的语言环境规则，将字符串转换为全部小写。
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to the specified Unicode
        normalization form.  The optional <parameter>form</parameter> key word
        specifies the form: <literal>NFC</literal> (the default),
        <literal>NFD</literal>, <literal>NFKC</literal>, or
        <literal>NFKD</literal>.  This function can only be used when the
        server encoding is <literal>UTF8</literal>.
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将字符串转换为指定的Unicode规范化形式。
        可选的<parameter>form</parameter>关键字指定了如下形式:<literal>NFC</literal> (the default)，<literal>NFD</literal>， <literal>NFKC</literal>，或<literal>NFKD</literal>。
        该函数只能在服务器编码为<literal>UTF8</literal>时使用。
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串的字节数。
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.  Since this version of the
        function accepts type <type>character</type> directly, it will not
        strip trailing spaces.
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字节数。 由于此版本的函数直接接受<type>character</type>类型，它不会剥离尾随空格。
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>string</parameter> that starts at
        the <parameter>start</parameter>'th character and extends
        for <parameter>count</parameter> characters
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，并用<parameter>newsubstring</parameter>扩展到<parameter>count</parameter>字符。
        如果省略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回指定的<parameter>substring</parameter>在<parameter>string</parameter>起始索引，如果不存在则返回零，。
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character if that is specified,
        and stopping after <parameter>count</parameter> characters if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		如果已指定，提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，
		并且在<parameter>count</parameter>字符后停止。如果已指定的话。 
		提供至少一个<parameter>start</parameter>和<parameter>count</parameter>中的至少一个。
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts substring matching POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配POSIX正则表达式的子字符串; 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts substring matching <acronym>SQL</acronym> regular expression;
        see <xref linkend="functions-similarto-regexp"/>.
       </para>
       <para>
        <literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配 <acronym>SQL</acronym> 正则表达式的字串；参见 <xref linkend="functions-similarto-regexp"/>。
       </para>
       <para>
        <literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>string</parameter>.
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开始、末端或两端(默认为<literal>BOTH</literal> )移除仅包含<parameter>characters</parameter>(默认为空格)字符的最长字符串。
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        这是一个非标准的<function>trim()</function>语法。
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all upper case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的定位规则，将字符串转换为所有大写。
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other"/>.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql"/>.
   </para>
____________________________________________________________________________-->
   <para>
    还有额外的串操作函数可以用，它们在<xref linkend="functions-string-other"/>中列出。它们有些在内部用于实现<xref linkend="functions-string-sql"/>列出的<acronym>SQL</acronym>标准字符串函数。
   </para>

   <table id="functions-string-other">
<!--==========================orignal english content==========================
    <title>Other String Functions</title>
____________________________________________________________________________-->
    <title>其他字符串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the numeric code of the first character of the argument.
        In <acronym>UTF8</acronym> encoding, returns the Unicode code point
        of the character.  In other multibyte encodings, the argument must
        be an <acronym>ASCII</acronym> character.
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回参数的第一个字符的数字代码。在<acronym>UTF8</acronym>编码中，返回该字符的Unicode代码点。
		在其他多字节编码中，该参数必须是一个<acronym>ASCII</acronym>字符。
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>.
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开头或结尾删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的字符串
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the character with the given code. In <acronym>UTF8</acronym>
        encoding the argument is treated as a Unicode code point. In other
        multibyte encodings the argument must designate
        an <acronym>ASCII</acronym> character.  <literal>chr(0)</literal> is
        disallowed because text data types cannot store that character.
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回给定代码的字符。在<acronym>UTF8</acronym>编码中该参数被视作一个Unicode代码点。
        在其他多字节编码中该参数必须指定一个<acronym>ASCII</acronym>字符。
        <literal>chr(0)</literal> 字符不被允许，因为文本数据类型不能存储这种字符。
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the text representations of all the arguments.
        NULL arguments are ignored.
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接所有参数的文本表示。空参数被忽略。
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates all but the first argument, with separators. The first
        argument is used as the separator string, and should not be NULL.
        Other NULL arguments are ignored.
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用分隔符连接除第一个参数外的所有参数。第一个参数用作分隔符字符串，不应为NULL。其他NULL参数将被忽略。
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         Formats arguments according to a format string;
         see <xref linkend="functions-string-format"/>.
         This function is similar to the C function <function>sprintf</function>.
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         根据格式字符串对参数进行格式化；参见 <xref linkend="functions-string-format"/>。
         这个函数类似于C函数 <function>sprintf</function>。
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		将每个单词的第一个字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns first <parameter>n</parameter> characters in the
        string, or when <parameter>n</parameter> is negative, returns
        all but last |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以字符串返回第一个 <parameter>n</parameter> 字符，或在 <parameter>n</parameter> 为负时, 返回最后 |<parameter>n</parameter>| 个字符之外的全部字符。
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the string.
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the right).
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		将<parameter>string</parameter>扩展为长度<parameter>length</parameter>，通过前置字符<parameter>fill</parameter>（默认空格）。 
		如果<parameter>string</parameter>已经超过<parameter>length</parameter>那么它将被截断（在右侧）。
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>开始删除包含<parameter>characters</parameter>（默认空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the argument, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算参数的 MD5 <link linkend="functions-hash-note">hash</link> ，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
		将<parameter>qualified_identifier</parameter>拆分为一个标识符数组，删除单个标识符的任何引用。 
		默认情况下，最后一个标识符之后的额外字符被视为错误；但是，如果第二个参数为<literal>false</literal>，则忽略这些额外的字符。
		（这种行为对于解析类似函数的对象的名称有作用。）
		请注意，此函数不会截断超长标识符。如果你想截断，你可以把结果给到<type>name[]</type>。
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns current client encoding name.
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前客户端编码名称。
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回适合引用的给定字符串，作为<acronym>SQL</acronym>语句字符串中的标识符。
		只有在必要的情况下才添加引号(例如，如果字符串包含非标识符字符或将被大小写折叠)。
		嵌入的引号被适当地加双引号。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串，用作字符串文字使用。
		嵌入式单引号和反斜线适当的翻倍(转双引号或双斜线)。
		请注意，<function>quote_literal</function>返回无效输入；如果这个参数可能为空，<function>quote_nullable</function>通常更合适。另请参阅<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的值转换为文本，然后将其作为字面量引用。
        内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串文字;或者，如果参数为null，则返回<literal>NULL</literal>。
        内嵌的单引号和反斜杠被适当地翻倍。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal;
        or, if the argument is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定值转换为文本，然后将其作为字面量引用；或者，如果参数为null，则返回<literal>NULL</literal>。
		内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns captured substring(s) resulting from the first match of a POSIX
        regular expression to the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        返回从POSIX正则表达式到<parameter>string</parameter>的第一个匹配中捕获的子字符串;参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        Returns captured substring(s) resulting from matching a POSIX regular
        expression to the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        返回通过将POSIX正则表达式与<parameter>string</parameter>匹配而捕获的子字符串；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces substring(s) matching a POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换匹配POSIX正则表达式的子字符串；参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>； 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>；参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Repeats <parameter>string</parameter> the specified
        <parameter>number</parameter> of times.
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重复<parameter>string</parameter>指定<parameter>number</parameter>的次数。
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces all occurrences in <parameter>string</parameter> of
        substring <parameter>from</parameter> with
        substring <parameter>to</parameter>.
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter> 中当前的子串<parameter>from</parameter>替换为子串<parameter>to</parameter>。
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reverses the order of the characters in the string.
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        颠倒字符串中字符的顺序。
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns last <parameter>n</parameter> characters in the string,
        or when <parameter>n</parameter> is negative, returns all but
        first |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		返回字符串中的最后<parameter>n</parameter>个字符，或者在<parameter>n</parameter>>为负时，返回除了前面的|<parameter>n</parameter>|字符之外的所有字符。
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        扩展 <parameter>string</parameter> 到长度 <parameter>length</parameter>，通过追加<parameter>fill</parameter> 字符(默认为空格).  
        如果<parameter>string</parameter> 已经比 <parameter>length</parameter> 长，则截断它。
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		从<parameter>string</parameter>末尾删除包含<parameter>characters</parameter>（默认为空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns
        the <parameter>n</parameter>'th field (counting from one).
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        在<parameter>delimiter</parameter>出现时拆分<parameter>string</parameter>，并且返回第<parameter>n</parameter>个字段(从一计数)。
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
        (Same as <literal>position(<parameter>substring</parameter> in
        <parameter>string</parameter>)</literal>, but note the reversed
        argument order.)
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
		返回在<parameter>string</parameter>中指定的<parameter>substring</parameter>的起始索引,如果不存在则为零。
		（与<literal>(<parameter>substring</parameter> 在 <parameter>string</parameter>中的)位置</literal>相同，但是请注意反转的参数顺序）
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character,
        and extending for <parameter>count</parameter> characters if that is
        specified.  (Same
        as <literal>substring(<parameter>string</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子字符串，并扩展<parameter>count</parameter>字符，如果指定了的话。
		(与 <literal>子字符串(<parameter>string</parameter> 从 <parameter>start</parameter> 开始计数 <parameter>count</parameter>)</literal>相同。)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if <parameter>string</parameter> starts
        with <parameter>prefix</parameter>.
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果 <parameter>string</parameter> 以 <parameter>prefix</parameter>开始就返回真。
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts <parameter>string</parameter> to <acronym>ASCII</acronym>
        from another encoding, which may be identified by name or number.
        If <parameter>encoding</parameter> is omitted the database encoding
        is assumed (which in practice is the only useful case).
        The conversion consists primarily of dropping accents.
        Conversion is only supported
        from <literal>LATIN1</literal>, <literal>LATIN2</literal>,
        <literal>LATIN9</literal>, and <literal>WIN1250</literal> encodings.
        (See the <xref linkend="unaccent"/> module for another, more flexible
        solution.)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		将<parameter>string</parameter>从另一个编码中转换为<acronym>ASCII</acronym>，该编码可按名称或编号标识。
		如果<parameter>encoding</parameter>被省略，则假定数据库编码（这在实践中是唯一有用的案例）。转换主要包括降音。
		转换仅支持来自 <literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、 和 <literal>WIN1250</literal> 的编码.
		(其他请参见 <xref linkend="unaccent"/> 模块, 更灵活的解决方案。)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the number to its equivalent hexadecimal representation.
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将数字转换为其相应的十六进制表示形式。
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces each character in <parameter>string</parameter> that
        matches a character in the <parameter>from</parameter> set with the
        corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are deleted.
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>中与<parameter>from</parameter>集合中匹配的每个字符替换为<parameter>to</parameter>集合中相应的字符。
        如果<parameter>from</parameter>长于<parameter>to</parameter>，<parameter>from</parameter>中出现的额外字符被删除。
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
   </para>
____________________________________________________________________________-->
   <para>
    <function>concat</function>、<function>concat_ws</function>和<function>format</function>函数是可变的，因此可以把要串接或格式化的值作为一个标记了<literal>VARIADIC</literal>关键字的数组进行传递（见<xref linkend="xfunc-sql-variadic-functions"/>）。
    数组的元素被当作函数的独立普通参数一样处理。如果可变数组参数为 NULL，<function>concat</function>和<function>concat_ws</function>返回 NULL，但<function>format</function>把 NULL 当作一个零元素数组。
   </para>

<!--==========================orignal english content==========================
   <para>
    See also the aggregate function <function>string_agg</function> in
    <xref linkend="functions-aggregate"/>, and the functions for
    converting between strings and the <type>bytea</type> type in
    <xref linkend="functions-binarystring-conversions"/>.
   </para>
____________________________________________________________________________-->
   <para>
	还可以参阅<xref linkend="functions-aggregate"/>中的<function>string_agg</function>，以及<xref linkend="functions-binarystring-conversions"/>中的字符串和<type>bytea</type>类型之间转换的功能。
   </para>

   <sect2 id="functions-string-format">
<!--==========================orignal english content==========================
    <title><function>format</function></title>
____________________________________________________________________________-->
    <title><function>format</function></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>format</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>format</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>format</function>根据一个格式字符串产生格式化的输出，其形式类似于 C 函数<function>sprintf</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <parameter>formatarg</parameter> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
    </para>
____________________________________________________________________________-->
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter>是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用<firstterm>格式说明符</firstterm>的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个<parameter>formatarg</parameter>参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。
    </para>

<!--==========================orignal english content==========================
    <para>
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     where the component fields are:

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter> (optional)</term>
       <listitem>
        <para>
         A string of the form <literal><parameter>n</parameter>$</literal> where
         <parameter>n</parameter> is the index of the argument to print.
         Index 1 means the first argument after
         <parameter>formatstr</parameter>.  If the <parameter>position</parameter> is
         omitted, the default is to use the next argument in sequence.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter> (optional)</term>
       <listitem>
        <para>
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <parameter>width</parameter>
         field is also specified.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter> (optional)</term>
       <listitem>
        <para>
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<parameter>n</parameter>$</literal> to
         use the <parameter>n</parameter>th function argument as the width.
        </para>

        <para>
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<parameter>width</parameter>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter> (required)</term>
       <listitem>
        <para>
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     格式说明符由一个<literal>%</literal>字符开始并且有这样的形式
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     其中的各组件域是：

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter>（可选）</term>
       <listitem>
        <para>
         一个形式为<literal><parameter>n</parameter>$</literal>的字符串，其中<parameter>n</parameter>是要打印的参数的索引。索引 1 表示<parameter>formatstr</parameter>之后的第一个参数。如果<parameter>position</parameter>被忽略，默认会使用序列中的下一个参数。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter>（可选）</term>
       <listitem>
        <para>
         控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（<literal>-</literal>），它将导致格式说明符的输出会被左对齐（left-justified）。除非<parameter>width</parameter>域也被指定，否者这个域不会产生任何效果。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter>（可选）</term>
       <listitem>
        <para>
         指定用于显示格式说明符输出的<emphasis>最小</emphasis>字符数。输出将被在左部或右部（取决于<literal>-</literal>标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（<literal>*</literal>）表示使用下一个函数参数作为宽度；或者一个形式为<literal>*<parameter>n</parameter>$</literal>的字符串表示使用第<parameter>n</parameter>个函数参数作为宽度。
        </para>

        <para>
         如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为<function>abs</function>(<parameter>width</parameter>)的域中被左对齐（如果<literal>-</literal>标志被指定）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter>（必需）</term>
       <listitem>
        <para>
         格式转换的类型，用于产生格式说明符的输出。支持下面的类型：
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal>将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal>将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等效于<function>quote_ident</function>）。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal>将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串<literal>NULL</literal>（等效于<function>quote_nullable</function>）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

<!--==========================orignal english content==========================
    <para>
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
    </para>
____________________________________________________________________________-->
    <para>
     除了以上所述的格式说明符之外，要输出一个文字形式的<literal>%</literal>字符，可以使用特殊序列<literal>%%</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are some examples of the basic format conversions:

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面有一些基本的格式转换的例子：

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>结果：</lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are examples using <parameter>width</parameter> fields
     and the <literal>-</literal> flag:

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面是使用<parameter>width</parameter>域和<literal>-</literal>标志的例子：

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     These examples show use of <parameter>position</parameter> fields:

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     这些例子展示了<parameter>position</parameter>域的例子：

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <parameter>position</parameter> fields to be mixed
     in the same format string.  A format specifier without a
     <parameter>position</parameter> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     不同于标准的 C 函数<function>sprintf</function>，<productname>PostgreSQL</productname>的<function>format</function>函数允许将带有或者不带有<parameter>position</parameter>域的格式说明符被混在同一个格式字符串中。一个不带有<parameter>position</parameter>域的格式说明符总是使用最后一个被消耗的参数的下一个参数。另外，<function>format</function>函数不要求所有函数参数都被用在格式字符串中。例如：

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
    </para>
____________________________________________________________________________-->
    <para>
     对于安全地构造动态 SQL 语句，<literal>%I</literal>和<literal>%L</literal>格式说明符特别有用。参见<xref linkend="plpgsql-quote-literal-example"/>。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--==========================orignal english content==========================
   <title>Binary String Functions and Operators</title>
____________________________________________________________________________-->
   <title>二进制串函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating binary strings, that is values of type <type>bytea</type>.
    Many of these are equivalent, in purpose and syntax, to the
    text-string functions described in the previous section.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述那些检查和操作二进制字符串的函数和操作符，这是类型<type>bytea</type>的值。
    其中许多函数在用途和语法上都与上一节中描述的文本字符串函数等效。
   </para>

<!--==========================orignal english content==========================
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些使用关键字而不是逗号来分割参数的串函数。详情请见<xref linkend="functions-binarystring-sql"/>。<productname>PostgreSQL</productname>也提供了这些函数使用常规函数调用语法的版本（参阅<xref linkend="functions-binarystring-other"/>）。
   </para>

   <table id="functions-binarystring-sql">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym>二进制串函数和操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the two binary strings.
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        连接两个二进制字符串。
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the binary string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的位数 (8 倍于 <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the binary string.
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bytes</parameter> that starts at
        the <parameter>start</parameter>'th byte and extends
        for <parameter>count</parameter> bytes
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        将<parameter>bytes</parameter>的子字符串替换为<parameter>newsubstring</parameter>，该子字符串从<parameter>start</parameter>字节开始，并以<parameter>count</parameter>字节扩展。
        如果忽略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>bytes</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回指定的<parameter>substring</parameter>在<parameter>bytes</parameter>内的起始索引，如果不存在，则为零。
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte if that is specified,
        and stopping after <parameter>count</parameter> bytes if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
		提取<parameter>bytes</parameter>从<parameter>start</parameter>字节开始的子字符串，如果指定了，并且在<parameter>count</parameter>字节之后停止，如果指定了的话。
		至少提供<parameter>start</parameter>和<parameter>count</parameter>中的一个。
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start
        and end of <parameter>bytes</parameter>.
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>bytes</parameter>的开始和结束处删除<parameter>bytesremoved</parameter>中只包含字节的最长字符串。
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        这是<function>trim()</function>的非标准语法。
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
   </para>
____________________________________________________________________________-->
   <para>
    还有一些二进制串处理函数可以使用，在<xref linkend="functions-binarystring-other"/>列出。 其中有一些是在内部使用，用于实现<xref linkend="functions-binarystring-sql"/>列出的 SQL 标准串函数。
   </para>

   <table id="functions-binarystring-other">
<!--==========================orignal english content==========================
    <title>Other Binary String Functions</title>
____________________________________________________________________________-->
    <title>其他二进制串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start and end of
        <parameter>bytes</parameter>.
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>bytes</parameter>的开始和结束处删除只包含<parameter>bytesremoved</parameter>中出现的字节的最长字符串
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> bit
        from binary string.
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 位。
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> byte
        from binary string.
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 字节。
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of bytes in the binary string.
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the binary string, assuming
        that it is text in the given <parameter>encoding</parameter>.
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字符数，假设它是给定<parameter>encoding</parameter>中的文本。
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the binary string, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算二进制字符串的MD5 <link linkend="functions-hash-note">hash</link>，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> bit in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的<link linkend="functions-zerobased-note">n'th</link>位为<parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> byte in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的 <link linkend="functions-zerobased-note">n'th</link> 字节到 <parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-224 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-224 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-256 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-256 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-384 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-384 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-512 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-512 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte,
        and extending for <parameter>count</parameter> bytes if that is
        specified.  (Same
        as <literal>substring(<parameter>bytes</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>字节开始提取<parameter>bytes</parameter>的子字符串，并扩展为<parameter>count</parameter>字节，如果这是指定的。
        (与 <literal>substring(<parameter>bytes</parameter> 从 <parameter>start</parameter> 到 <parameter>count</parameter>)</literal> 相同.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para id="functions-zerobased-note">
   Functions <function>get_byte</function> and <function>set_byte</function>
   number the first byte of a binary string as byte 0.
   Functions <function>get_bit</function> and <function>set_bit</function>
   number bits from the right within each byte; for example bit 0 is the least
   significant bit of the first byte, and bit 15 is the most significant bit
   of the second byte.
  </para>
____________________________________________________________________________-->
  <para id="functions-zerobased-note">
   函数<function>get_byte</function>和<function>set_byte</function>把一个二进制串中的一个字节计数为字节 0。
   函数<function>get_bit</function>和<function>set_bit</function>在每一个字节中从右边起计数位；
   例如位 0 是第一个字节的最低有效位，而位 15 是第二个字节的最高有效位。
  </para>

<!--==========================orignal english content==========================
  <para id="functions-hash-note">
   For historical reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <link linkend="function-encode"><function>encode</function></link>
   and <link linkend="function-decode"><function>decode</function></link> to
   convert between the two.  For example write <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation,
   or <literal>decode(md5('abc'), 'hex')</literal> to get
   a <type>bytea</type> value.
  </para>
____________________________________________________________________________-->
  <para id="functions-hash-note">
   由于历史原因，函数<function>md5</function>返回的是一个十六进制编码的<type>text</type>值，而SHA-2函数返回类型<type>bytea</type>。
   可以使用函数<link linkend="function-encode"><function>encode</function></link>和<link linkend="function-decode"><function>decode</function></link>在两者之间转换。
   例如<literal>encode(sha256('abc'),'hex')</literal>可以得到一个十六进制编码的文本表示，或者<literal>decode(md5('abc'), 'hex')</literal>得到一个<type>bytea</type> 值。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   Functions for converting strings between different character sets
   (encodings), and for representing arbitrary binary data in textual
   form, are shown in
   <xref linkend="functions-binarystring-conversions"/>.  For these
   functions, an argument or result of type <type>text</type> is expressed
   in the database's default encoding, while arguments or results of
   type <type>bytea</type> are in an encoding named by another argument.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   用于在不同字符集(编码)之间转换字符串的函数，以及用于以文本形式表示任意二进制数据的函数，在<xref linkend="functions-binarystring-conversions"/>中显示。
   对于这些函数，类型为<type>text</type>的参数或结果表示为数据库的默认编码，而类型为<type>bytea</type>的参数或结果表示为由另一个参数命名的编码。
  </para>

  <table id="functions-binarystring-conversions">
<!--==========================orignal english content==========================
   <title>Text/Binary String Conversion Functions</title>
____________________________________________________________________________-->
   <title>Text/Binary String Conversion Functions</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       Function
      </para>
      <para>
       Description
      </para>
      <para>
       Example(s)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       函数
      </para>
      <para>
       描述
      </para>
      <para>
       例子
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to a binary string in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为编码<parameter>dest_encoding</parameter>的二进制字符串
       (适用的转换请参阅<xref linkend="multibyte-conversions-supported"/>)。
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to <type>text</type> in the database encoding
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为数据库编码中的<type>text</type>。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。	   
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a <type>text</type> string (in the database encoding) to a
       binary string encoded in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将<type>text</type>字符串(数据库编码)转换为编码<parameter>dest_encoding</parameter>中编码的二进制字符串。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Encodes binary data into a textual representation; supported
       <parameter>format</parameter> values are:
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将二进制数据编码成文本表示；支持的<parameter>format</parameter>值为：
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Decodes binary data from a textual representation; supported
       <parameter>format</parameter> values are the same as
       for <function>encode</function>.
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       从文本表示中解码二进制数据;支持的<parameter>format</parameter>值与<function>encode</function>相同。
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <function>encode</function> and <function>decode</function>
   functions support the following textual formats:

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>base64</literal> format is that
       of <ulink url="https://tools.ietf.org/html/rfc2045#section-6.8">RFC
       2045 Section 6.8</ulink>.  As per the RFC, encoded lines are
       broken at 76 characters.  However instead of the MIME CRLF
       end-of-line marker, only a newline is used for end-of-line.
       The <function>decode</function> function ignores carriage-return,
       newline, space, and tab characters.  Otherwise, an error is
       raised when <function>decode</function> is supplied invalid
       base64 data &mdash; including when trailing padding is incorrect.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>escape</literal> format converts zero bytes and
       bytes with the high bit set into octal escape sequences
       (<literal>\</literal><replaceable>nnn</replaceable>), and it doubles
       backslashes.  Other byte values are represented literally.
       The <function>decode</function> function will raise an error if a
       backslash is not followed by either a second backslash or three
       octal digits; it accepts other byte values unchanged.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>hex</literal> format represents each 4 bits of
       data as one hexadecimal digit, <literal>0</literal>
       through <literal>f</literal>, writing the higher-order digit of
       each byte first.  The <function>encode</function> function outputs
       the <literal>a</literal>-<literal>f</literal> hex digits in lower
       case.  Because the smallest unit of data is 8 bits, there are
       always an even number of characters returned
       by <function>encode</function>.
       The <function>decode</function> function
       accepts the <literal>a</literal>-<literal>f</literal> characters in
       either upper or lower case.  An error is raised
       when <function>decode</function> is given invalid hex data
       &mdash; including when given an odd number of characters.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <function>encode</function> 和 <function>decode</function> 函数支持以下文本格式:

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>base64</literal>格式是<ulink url="https://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 Section 6.8</ulink>。
       根据RFC，编码的行被分割为76个字符。但是，作为MIME CRLF行结束标记的替代，只有换行符用于行结束。
       <function>decode</function>函数忽略回车、换行、空格和制表符。
       否则，当<function>decode</function>被提供了无效的base64数据&mdash；包括结尾填充不正确时。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>escape</literal>格式将零字节和设置了高位的字节转换为八进制转义序列(<literal>\</literal><replaceable>nnn</replaceable>)，并将反斜杠加倍。
       其他字节值按字面意思表示。
       <function>decode</function>函数如果反斜杠后面没有第二个反斜杠或三个八进制数字将引发错误;它接受其他未变化的字节值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>hex</literal>格式将每4位数据表示为一个十六进制数字，从<literal>0</literal>到<literal>f</literal>，首先写入每个字节的高阶数字。
       <function>encode</function>函数输出<literal>a</literal>-<literal>f</literal>的十六进制小写数字。
       因为数据的最小单位是8位，所以<function>encode</function>总是返回偶数个字符。
       <function>decode</function>函数接受大写或小写的<literal>a</literal>-<literal>f</literal>字符。
       当<function>decode</function>给出无效的十六进制数据&mdash时将引发一个错误，包括给定奇数个字符时。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
  </para>
____________________________________________________________________________-->
  <para>
  参见<xref linkend="functions-aggregate"/>中的聚集函数<function>string_agg</function>以及<xref linkend="lo-funcs"/>中的大对象函数。
  </para>
 </sect1>

  <sect1 id="functions-bitstring">
<!--==========================orignal english content==========================
   <title>Bit String Functions and Operators</title>
____________________________________________________________________________-->
   <title>位串函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  (While only
    type <type>bit</type> is mentioned in these tables, values of
    type <type>bit varying</type> can be used interchangeably.)
    Bit strings support the usual comparison operators shown in
    <xref linkend="functions-comparison-op-table"/>, as well as the
    operators shown in <xref linkend="functions-bit-string-op-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述用于检查和操作位串的函数和操作符，也就是操作类型为<type>bit</type>和<type>bit varying</type>的值的函数和操作符。
    (虽然这些表中只提到了<type>bit</type>类型，但<type>bit varying</type>类型的值可以互换使用。)
    位字符串支持<xref linkend="functions-comparison-op-table"/>中显示的常用比较操作符，就像<xref linkend="functions-bit-string-op-table"/>中显示的操作符。
   </para>

   <table id="functions-bit-string-op-table">
<!--==========================orignal english content==========================
    <title>Bit String Operators</title>
____________________________________________________________________________-->
    <title>位串操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Concatenation
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        连接
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise AND (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位与（输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise exclusive OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位异或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位求反
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift left
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位左移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift right
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位右移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Some of the functions available for binary strings are also available
    for bit strings, as shown in <xref linkend="functions-bit-string-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    一些可用于二进制字符串的函数也可用于位字符串，如<xref linkend="functions-bit-string-table"/>中所示。
   </para>

   <table id="functions-bit-string-table">
<!--==========================orignal english content==========================
    <title>Bit String Functions</title>
____________________________________________________________________________-->
    <title>位字符串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the bit string.
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的字节数。
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bits</parameter> that starts at
        the <parameter>start</parameter>'th bit and extends
        for <parameter>count</parameter> bits
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        替换从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，并将<parameter>newsubstring</parameter>扩展<parameter>count</parameter>位。
        如果<parameter>count</parameter>被省略，默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>bits</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        按返回指定<parameter>substring</parameter>的起始索引，以<parameter>bits</parameter>为单位，如果不存在则返回0。
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bits</parameter> starting at
        the <parameter>start</parameter>'th bit if that is specified,
        and stopping after <parameter>count</parameter> bits if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        如果指定了起始位，则提取从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，如果指定了计数位，则在<parameter>count</parameter>位之后停止。
        <parameter>start</parameter>和<parameter>count</parameter>至少提供一个。
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th bit
        from bit string; the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从位字符串中提取第<parameter>n</parameter>位；第一个(最左)位为第0位。
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Sets <parameter>n</parameter>'th bit in
        bit string to <parameter>newvalue</parameter>;
        the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        将位字符串中的第<parameter>n</parameter>位设置为<parameter>newvalue</parameter>；第一个(最左)位是第0位。
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Casting an integer to <type>bit(n)</type> copies the rightmost
    <literal>n</literal> bits.  Casting an integer to a bit string width wider
    than the integer itself will sign-extend on the left.
    Some examples:
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
   </para>
____________________________________________________________________________-->
   <para>
    另外，我们可以在整数和<type>bit</type>之间来回转换。
    将一个整数转换为<type>bit(n)</type>会复制最右边的<literal>n</literal>位。
    将一个整数转换为比整数本身更宽的位字符串宽度将在左边进行符号扩展。一些例子：
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    请注意，如果只是转换为<quote>bit</quote>，意思是转换成<literal>bit(1)</literal>，因此只会转换整数的最低有效位。
   </para>
  </sect1>


 <sect1 id="functions-matching">
<!--==========================orignal english content==========================
  <title>Pattern Matching</title>
____________________________________________________________________________-->
  <title>模式匹配</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了三种独立的实现模式匹配的方法：<acronym>SQL</acronym> <function>LIKE</function>操作符、更近一些的<function>SIMILAR TO</function>操作符（SQL:1999 里添加进来的）和<acronym>POSIX</acronym>-风格的正则表达式。除了这些基本的<quote>这个串匹配这个模式吗？</quote>操作符外，还有一些函数可用于提取或替换匹配子串并在匹配位置分离一个串。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
    </para>
____________________________________________________________________________-->
    <para>
     如果你的模式匹配的要求超出了这些，请考虑用 Perl 或 Tcl 写一个用户定义的函数。
    </para>
   </tip>
   
   <caution>
<!--==========================orignal english content==========================
    <para>
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
    </para>
____________________________________________________________________________-->
    <para>
     虽然大部分的正则表达式搜索都能被很快地执行，但是正则表达式仍可能被
     人为地弄成需要任意长的时间和任意量的内存进行处理。要当心从不怀好意
     的来源接受正则表达式搜索模式。如果必须这样做，建议加上语句超时限制。
    </para>

<!--==========================orignal english content==========================
    <para>
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
    </para>
____________________________________________________________________________-->
    <para>
     使用<function>SIMILAR TO</function>模式的搜索具有同样的安全性危险，
     因为<function>SIMILAR TO</function>提供了很多和
     <acronym>POSIX</acronym>-风格正则表达式相同的能力。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
    </para>
____________________________________________________________________________-->
    <para>
     <function>LIKE</function>搜索比其他两种选项简单得多，因此在使用
     不怀好意的模式来源时要更安全些。
    </para>
   </caution>
<!--==========================orignal english content==========================
   <para>
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
   </para>
____________________________________________________________________________-->
   <para>
    这三种类型的模式匹配算子都不支持非确定性拼贴。 如果需要的话，可以在表达式中应用不同的拼贴来绕过这个限制。
   </para>
  <sect2 id="functions-like">
<!--==========================orignal english content==========================
   <title><function>LIKE</function></title>
____________________________________________________________________________-->
   <title><function>LIKE</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     如果该<replaceable>string</replaceable>匹配了提供的<replaceable>pattern</replaceable>，那么<function>LIKE</function>表达式返回真（和预期的一样，如果<function>LIKE</function>返回真，那么<function>NOT LIKE</function>表达式返回假， 反之亦然。一个等效的表达式是<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
    </para>
____________________________________________________________________________-->
    <para>
     如果<replaceable>pattern</replaceable>不包含百分号或者下划线，那么该模式只代表它本身的串；这时候<function>LIKE</function>的行为就象等号操作符。在<replaceable>pattern</replaceable>里的下划线 （<literal>_</literal>）代表（匹配）任何单个字符； 而一个百分号（<literal>%</literal>）匹配任何零或更多个字符的序列。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
   </para>
____________________________________________________________________________-->
   <para>
    <function>LIKE</function>模式匹配总是覆盖整个串。因此，要匹配在串内任何位置的序列，该模式必须以百分号开头和结尾。
   </para>

<!--==========================orignal english content==========================
   <para>
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
   </para>
____________________________________________________________________________-->
   <para>
    要匹配文本的下划线或者百分号，而不是匹配其它字符， 在<replaceable>pattern</replaceable>里相应的字符必须 前导逃逸字符。缺省的逃逸字符是反斜线，但是你可以用<literal>ESCAPE</literal>子句指定一个不同的逃逸字符。 要匹配逃逸字符本身，写两个逃逸字符。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，你在文串常量中写的任何反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
   </para>
____________________________________________________________________________-->
   <para>
    请注意反斜线在串文本里已经有特殊含义了，所以如果你写一个 包含反斜线的模式常量，那你就要在 SQL 语句里写两个反斜线。 因此，写一个匹配单个反斜线的模式实际上要在语句里写四个反斜线。 你可以通过用 ESCAPE 选择一个不同的逃逸字符 来避免这样；这样反斜线就不再是 LIKE 的特殊字符了。 但仍然是字符文本分析器的特殊字符，所以你还是需要两个反斜线。)
    我们也可以通过写<literal>ESCAPE ''</literal>的方式不选择逃逸字符，这样可以有效地禁用逃逸机制，但是没有办法关闭下划线和百分号在模式中的特殊含义。
   </para>

<!--==========================orignal english content==========================
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
____________________________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
	因此，<productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>

<!--==========================orignal english content==========================
   <para>
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    关键字<token>ILIKE</token>可以用于替换<token>LIKE</token>， 它令该匹配根据活动区域成为大小写无关。这个不属于<acronym>SQL</acronym>标准而是一个<productname>PostgreSQL</productname>扩展。
   </para>

<!--==========================orignal english content==========================
   <para>
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.  You may see these
    operator names in <command>EXPLAIN</command> output and similar
    places, since the parser actually translates <function>LIKE</function>
    et al. to these operators.
   </para>
____________________________________________________________________________-->
   <para>
    操作符<literal>~~</literal>等效于<function>LIKE</function>， 而<literal>~~*</literal>对应<function>ILIKE</function>。 
    还有 <literal>!~~</literal>和<literal>!~~*</literal>操作符分别代表<function>NOT LIKE</function>和<function>NOT ILIKE</function>。
    所有这些操作符都是<productname>PostgreSQL</productname>特有的。
    你可能会在<command>EXPLAIN</command>输出和类似的地方看到这些操作符名称，因为解析器实际上将<function>LIKE</function>等翻译成这些运算符。
   </para>

<!--==========================orignal english content==========================
   <para>
    The phrases <function>LIKE</function>, <function>ILIKE</function>,
    <function>NOT LIKE</function>, and <function>NOT ILIKE</function> are
    generally treated as operators
    in <productname>PostgreSQL</productname> syntax; for example they can
    be used in <replaceable>expression</replaceable>
    <replaceable>operator</replaceable> ANY
    (<replaceable>subquery</replaceable>) constructs, although
    an <literal>ESCAPE</literal> clause cannot be included there.  In some
    obscure cases it may be necessary to use the underlying operator names
    instead.
   </para>
____________________________________________________________________________-->
   <para>
    短语<function>LIKE</function>，<function>ILIKE</function>，<function>NOT LIKE</function>，和 <function>NOT ILIKE</function> 在<productname>PostgreSQL</productname>语法中通常被视为操作符；
    例如，它们可以用于<replaceable>expression</replaceable> <replaceable>operator</replaceable>的任何（<replaceable>subquery</replaceable>）构造，尽管这里不能包含<literal>ESCAPE</literal>子句。
    在某些晦涩难懂的情况下，可能需要用底层操作符名称替代。
   </para>

<!--==========================orignal english content==========================
   <para>
    Also see the prefix operator <literal>^@</literal> and corresponding
    <function>starts_with</function> function, which are useful in cases
    where simply matching the beginning of a string is needed.
   </para>
____________________________________________________________________________-->
   <para>
    还可参见前缀操作符<literal>^@</literal>和相应的<function>starts_with</function>函数，在需要简单匹配字符串开头的情况下比较有用。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--==========================orignal english content==========================
   <title><function>SIMILAR TO</function> Regular Expressions</title>
____________________________________________________________________________-->
   <title><function>SIMILAR TO</function>正则表达式</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>regular expression</primary>
    <!-&minus; <seealso>pattern matching</seealso> breaks index build -&minus;>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regular expression</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>substring</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common (POSIX) regular
    expression notation.
   </para>
____________________________________________________________________________-->
   <para>
    <function>SIMILAR TO</function>操作符根据自己的模式是否匹配给定串而返回真或者假。 
    它和<function>LIKE</function>非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。 
    SQL 正则表达式是在<function>LIKE</function>标记和普通的(POSIX)正则表达式标记的奇怪的杂交。
   </para>

<!--==========================orignal english content==========================
   <para>
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
   </para>
____________________________________________________________________________-->
   <para>
    类似<function>LIKE</function>，<function>SIMILAR TO</function>操作符只有在它的模式匹配整个串的时候才能成功；这一点和普通的 正则表达式的行为不同，在普通的正则表达式里，模式匹配串的任意部分。 和<function>LIKE</function>类似的地方还有，<function>SIMILAR TO</function>使用<literal>_</literal>和<literal>%</literal>作为分别代表任意单个字符和任意串的通配符（这些可以比得上 POSIX 正则表达式里的<literal>.</literal>和<literal>.*</literal>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal> denotes alternation (either of two alternatives).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
     </para>
    </listitem>
    <listitem>
     <para>
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
     </para>
    </listitem>
   </itemizedlist>

    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
   </para>
____________________________________________________________________________-->
   <para>
    除了这些从<function>LIKE</function>借用的功能之外，<function>SIMILAR TO</function>支持下面这些从 POSIX 正则表达式借用的 模式匹配元字符：

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal>表示选择（两个候选之一）。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal>表示重复前面的项零次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal>表示重复前面的项一次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal>表示重复前面的项零次或一次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal>表示重复前面的项刚好<replaceable>m</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>表示重复前面的项<replaceable>m</replaceable>次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>表示重复前面的项至少<replaceable>m</replaceable>次并且不超过<replaceable>n</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      可以使用圆括号<literal>()</literal>把多个项组合成一个逻辑项。
     </para>
    </listitem>
    <listitem>
     <para>
      一个方括号表达式<literal>[...]</literal>声明一个字符类，就像 POSIX 正则表达式一样。
     </para>
    </listitem>
   </itemizedlist>

    注意点号（<literal>.</literal>）不是<function>SIMILAR TO</function>的一个元字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    As with <function>LIKE</function>, a backslash disables the special
    meaning of any of these metacharacters.  A different escape character
    can be specified with <literal>ESCAPE</literal>, or the escape
    capability can be disabled by writing <literal>ESCAPE ''</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    与<function>LIKE</function>一样，反斜杠将禁用这些元字符的特殊含义。
    可以用 <literal>ESCAPE</literal> 来指定不同的转义字符，或者可以通过写 <literal>ESCAPE ''</literal> 来禁用转义功能。
   </para>

<!--==========================orignal english content==========================
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
____________________________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
    <productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another nonstandard extension is that following the escape character
    with a letter or digit provides access to the escape sequences
    defined for POSIX regular expressions; see
    <xref linkend="posix-character-entry-escapes-table"/>,
    <xref linkend="posix-class-shorthand-escapes-table"/>, and
    <xref linkend="posix-constraint-escapes-table"/> below.
   </para>
____________________________________________________________________________-->
   <para>
    另一个非标准扩展是，在转义字符后面跟着一个字母或数字提供了对为POSIX正则表达式定义的转义序列的访问；参见下面的
    <xref linkend="posix-character-entry-escapes-table"/>，<xref linkend="posix-class-shorthand-escapes-table"/>，和 <xref linkend="posix-constraint-escapes-table"/> 。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to SQL99 syntax:
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    or as a plain three-argument function:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!-&minus; " font-lock sanity -&minus;>
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
   </para>
____________________________________________________________________________-->
   <para>
    带有三个参数的<function>substring</function>函数可以提取匹配SQL正则表达式模式的子字符串。 该函数可以按照SQL99语法编写。
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    或作为一个普通的三参数函数:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    与<literal>SIMILAR TO</literal>一样，指定的模式必须与整个数据字符串匹配，否则函数失败并返回空值。 为了表示匹配的数据子字符串的模式中，模式中应该包含两个转义字符的出现，并在后面加上一个双引号(<literal>"</literal>)。<!-- " font-lock sanity --> 匹配成功后，将返回与这些分隔符之间的模式部分匹配的文本。
   </para>

<!--==========================orignal english content==========================
   <para>
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
   </para>
____________________________________________________________________________-->
   <para>
    转义-双引号分隔符实际上是  将<function>子字符串</function>的模式分成三个独立的 正则表达式；例如，竖条(<literal>|</literal>)  三节中的任何一节只影响到该节。 此外，第一节和第三种正则表达式的定义是为了匹配最小的  尽可能多的文字，而不是最大的文字，当有歧义的时候，就不应该是最大的文字。关于有多少数据字符串符合哪种模式。 (在POSIX术语中，第一和第三种正则表达式被强行规定为非贪婪)。
   </para>

<!--==========================orignal english content==========================
   <para>
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
   </para>
____________________________________________________________________________-->
   <para>
    作为对SQL标准的扩展，<productname>PostgreSQL</productname>只允许有一个转义双引号分隔符，在这种情况下，第三个正则表达式被视为空；或者没有分隔符，在这种情况下，第一个和第三个正则表达式被视为空。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子，使用<literal>#&quot;</literal>定界返回串：
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--==========================orignal english content==========================
   <title><acronym>POSIX</acronym> Regular Expressions</title>
____________________________________________________________________________-->
   <title><acronym>POSIX</acronym>正则表达式</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>substring</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-posix-table"/>列出了所有可用于 POSIX 正则表达式模式匹配的操作符。
   </para>

   <table id="functions-posix-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Match Operators</title>
____________________________________________________________________________-->
    <title>正则表达式匹配操作符</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' ~ '.*thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' ~ '.*thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' ~* '.*Thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' ~* '.*Thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' !~ '.*thomas.*'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' !~ '.*thomas.*'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' !~* '.*vadim.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' !~* '.*vadim.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
    <para>
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>正则表达式提供了比<function>LIKE</function>和<function>SIMILAR TO</function>操作符更强大的含义。许多 Unix 工具，例如<command>egrep</command>、<command>sed</command>或<command>awk</command>使用一种与我们这里描述的类似的模式匹配语言。
    </para>

<!--==========================orignal english content==========================
    <para>
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
    </para>
____________________________________________________________________________-->
    <para>
     正则表达式是一个字符序列，它是定义一个串集合 （一个<firstterm>正则集</firstterm>）的缩写。 如果一个串是正则表达式描述的正则集中的一员时， 我们就说这个串匹配该正则表达式。 和<function>LIKE</function>一样，模式字符准确地匹配串字符， 除非在正则表达式语言里有特殊字符 &mdash; 不过正则表达式用的 特殊字符和<function>LIKE</function>用的不同。 和<function>LIKE</function>模式不一样的是，正则表达式允许匹配串里的任何位置，除非该正则表达式显式地挂接在串的开头或者结尾。
    </para>

<!--==========================orignal english content==========================
    <para>
     Some examples:
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一些例子：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>模式语言的详细描述见下文。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
    </para>
____________________________________________________________________________-->
    <para>
     带两个参数的<function>substring</function>函数，即<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable>)</function>，提供了抽取一个匹配 POSIX 正则表达式模式的子串的方法。如果没有匹配它返回空值，否则就是文本中匹配模式的那部分。 但是如果该模式包含任何圆括号，那么将返回匹配第一对子表达式（对应第一个左圆括号的） 的文本。如果你想在表达式里使用圆括号而又不想导致这个例外，那么你可以在整个表达式外边放上一对圆括号。 如果你需要在想抽取的子表达式前有圆括号，参阅后文描述的非捕获性圆括号。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</literal> specifies case-insensitive
     matching, while flag <literal>g</literal> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_replace</function>函数提供了将匹配 POSIX 正则表达式模式的子串替换为新文本的功能。 它的语法是 <function>regexp_replace</function>(<replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。 如果没有匹配<replaceable>pattern</replaceable>，那么返回不加修改的<replaceable>source</replaceable>串。 如果有匹配，则返回的<replaceable>source</replaceable>串里面的匹配子串将被<replaceable>replacement</replaceable>串替换掉。<replaceable>replacement</replaceable>串可以包含<literal>\</literal><replaceable>n</replaceable>， 其中<literal>\</literal><replaceable>n</replaceable>是 1 到 9， 表明源串里匹配模式里第<replaceable>n</replaceable>个圆括号子表达式的子串应该被插入， 并且它可以包含<literal>\&amp;</literal>表示应该插入匹配整个模式的子串。如果你需要放一个文字形式的反斜线在替换文本里，那么写<literal>\\</literal>。<replaceable>flags</replaceable>参数是一个可选的文本串，它包含另个或更多单字母标志，这些标志可以改变函数的行为。标志<literal>i</literal>指定大小写无关的匹配，而标志<literal>g</literal>指定替换每一个匹配的子串而不仅仅是第一个。支持的标志（但不是<literal>g</literal>）在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_match</function> function returns a text array of
     captured substring(s) resulting from the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_match</function>返回一个文本数组，它包含一个POSIX正则表达式模式与一个字符串第一个匹配所得到的子串。其语法是<function>regexp_match</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。如果没有匹配，则结果为<literal>NULL</literal>。如果找到一个匹配并且<replaceable>pattern</replaceable>不包含带括号的子表达式，那么结果是一个单一元素的文本数组，其中包含匹配整个模式的子串。如果找到一个匹配并且<replaceable>pattern</replaceable>含有带括号的子表达式，那么结果是一个文本数组，其中第<replaceable>n</replaceable>个元素是与<replaceable>pattern</replaceable>的第<replaceable>n</replaceable>个圆括号子表达式匹配的子串（<quote>非捕获</quote>圆括号不计入在内，详见下文）。<replaceable>flags</replaceable>参数是一个可选的文本字符串，它包含零个或者更多个可以改变该函数行为的单字母标志。所支持的标志在<xref linkend="posix-embedded-options-table"/>中介绍。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
(1 row)
</programlisting>
    In the common case where you just want the whole matching substring
    or <literal>NULL</literal> for no match, write something like
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 barbeque
(1 row)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
    在通常情况下，人们只是想要的大整个匹配的子串或者<literal>NULL</literal>（没有匹配），可以写成这样
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_matches</function> function returns a set of text arrays
     of captured substring(s) resulting from matching a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_matches</function>函数返回一个文本数组的集合，其中包含着一个POSIX正则表达式模式与一个字符串匹配得到的子串。它和<function>regexp_match</function>具有相同的语法。如果没有匹配，这个函数不会返回行。如果有一个匹配并且给定了<literal>g</literal>标志，则返回一行。如果有<replaceable>N</replaceable>个匹配并且给定了<literal>g</literal>标志，则返回<replaceable>N</replaceable>行。每一个返回的行都是一个文本数组，其中含有整个匹配的子串或者匹配<replaceable>pattern</replaceable>的圆括号子表达式的子串，这和上面对<function>regexp_match</function>的介绍一样。<function>regexp_matches</function>接受<xref linkend="posix-embedded-options-table"/>中展示的所有标志，外加令它返回所有匹配而不仅仅是第一个匹配的<literal>g</literal>标志。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
    </para>
____________________________________________________________________________-->
    <para>
     在大部分情况下，<function>regexp_matches()</function>应该与<literal>g</literal>标志一起使用，因为如果只是想要第一个匹配，使用<function>regexp_match()</function>会更加简单高效。不过，<function>regexp_match()</function>仅存在于<productname>PostgreSQL</productname>版本10以及更高的版本中。当在较老的版本中使用时，一种常用的技巧是把<function>regexp_matches()</function>调用放在子选择中，例如：
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     如果有一个匹配，则这个语句会产生一个文本数组，否则返回<literal>NULL</literal>，这和<function>regexp_match()</function>的做法一样。如果没有子选择，这个查询对于没有匹配的表行根本不会产生输出，显然那不是想要的行为。
    </para>
   </tip>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_split_to_table</function>把一个 POSIX 正则表达式模式当作一个定界符来分离一个串。它的语法形式是<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。如果没有与<replaceable>pattern</replaceable>的匹配，该函数返回<replaceable>string</replaceable>。如果有至少有一个匹配，对每一个匹配它都返回从上一个匹配的末尾（或者串的开头）到这次匹配开头之间的文本。当没有更多匹配时，它返回从上一次匹配的末尾到串末尾之间的文本。<replaceable>flags</replaceable>参数是一个可选的文本串，它包含零个或更多单字母标志，这些标识可以改变该函数的行为。<function>regexp_split_to_table</function>能支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_split_to_array</function>函数的行为和<function>regexp_split_to_table</function>相同，不过<function>regexp_split_to_array</function>会把它的结果以一个<type>text</type>数组的形式返回。它的语法是<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。这些参数和<function>regexp_split_to_table</function>的相同。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-&minus;-&minus;-&minus;-
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-&minus;-&minus;-
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_match</function> and
    <function>regexp_matches</function>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
   </para>
____________________________________________________________________________-->
   <para>
    正如上一个例子所示，正则表达式分离函数会忽略零长度的匹配，这种匹配发生在串的开头或结尾或者正好发生在前一个匹配之后。这和正则表达式匹配的严格定义是相悖的，后者由<function>regexp_match</function>和<function>regexp_matches</function>实现，但是通常前者是实际中最常用的行为。其他软件系统如Perl也使用相似的定义。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--==========================orignal english content==========================
    <title>Regular Expression Details</title>
____________________________________________________________________________-->
    <title>正则表达式细节</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的正则表达式是使用 Henry Spencer 写的一个包来实现的。下面的正则表达式的大部分描述都是从他的手册页中逐字拷贝过来的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
   </para>
____________________________________________________________________________-->
   <para>
    正则表达式（<acronym>RE</acronym>），在<acronym>POSIX</acronym> 1003.2 中定义， 它有两种形式：<firstterm>扩展</firstterm>的<acronym>RE</acronym>或者是<acronym>ERE</acronym>（大概地说就是那些在<command>egrep</command>里的）， <firstterm>基本</firstterm>的<acronym>RE</acronym>或者是<acronym>BRE</acronym>（大概地说就是那些在<command>ed</command>里的）。<productname>PostgreSQL</productname>支持两种形式，并且还实现了一些POSIX标准中没有但是在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。使用了那些非POSIX扩展的<acronym>RE</acronym>叫<firstterm>高级</firstterm><acronym>RE</acronym>， 或者本文档里说的<acronym>ARE</acronym>。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容（以及更多的限制）。我们首先描述 ARE 和 ERE 形式， 描述那些只适用于 ARE 的特性，然后描述 BRE 的区别是什么。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>初始时总是推测一个正则表达式遵循 ARE 规则。但是，可以通过为 RE 模式预置一个<firstterm>embedded option</firstterm>来选择限制更多的 ERE 或 BRE 规则，如<xref linkend="posix-metasyntax"/>中所述。这对为期望准确的<acronym>POSIX</acronym> 1003.2 规则的应用提供兼容性很有用。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
   </para>
____________________________________________________________________________-->
   <para>
    一个正则表达式被定义为一个或更多<firstterm>分支</firstterm>，它们之间被<literal>|</literal>分隔。只要能匹配其中一个分支的东西都能匹配正则表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
   </para>
____________________________________________________________________________-->
   <para>
    一个分支是一个或多个<firstterm>量化原子</firstterm>或者<firstterm>约束</firstterm>连接而成。一个原子匹配第一个，然后后面的原子匹配第二个， 以此类推；一个空分支匹配空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    一个量化原子是一个<firstterm>原子</firstterm>， 后面可能跟着一个<firstterm>量词</firstterm>。没有量词的时候，它匹配一个原子， 有量词的时候，它可以匹配若干个原子。一个<firstterm>原子</firstterm>可以是在<xref linkend="posix-atoms-table"/>里面显示的任何可能。 可能的量词和它们的含义在<xref linkend="posix-quantifiers-table"/>里显示。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
   </para>
____________________________________________________________________________-->
   <para>
    一个<firstterm>约束</firstterm>匹配一个空串，但只是在满足特定条件下才匹配。 约束可以在能够使用原子的地方使用，只是它不能跟着量词。简单的约束在<xref linkend="posix-constraints-table"/>里显示； 更多的约束稍后描述。
   </para>


   <table id="posix-atoms-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Atoms</title>
____________________________________________________________________________-->
    <title>正则表达式原子</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Atom</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>原子</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>（其中<replaceable>re</replaceable>是任何正则表达式） 匹配一个对<replaceable>re</replaceable>的匹配，匹配将为可能的报告被记下</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>同上，但是匹配不会为了报告而被记下 （一个<quote>非捕获</quote>圆括号集） （只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>.</literal> </entry>
       <entry> matches any single character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>.</literal> </entry>
       <entry>匹配任意单个字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> 一个<firstterm>方括号表达式</firstterm>， 匹配<replaceable>chars</replaceable>中的任意一个（详见<xref linkend="posix-bracket-expressions"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry>（其中<replaceable>k</replaceable>是一个非字母数字字符） 匹配一个被当作普通字符看待的特定字符， 例如，<literal>\\</literal>匹配一个反斜线字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry>其中<replaceable>c</replaceable>是一个字母数字 （可能跟着其它字符），它是一个<firstterm>逃逸</firstterm>， 参阅<xref linkend="posix-escape-sequences"/>（仅对 ARE； 在 ERE 和 BRE 中，它匹配<replaceable>c</replaceable>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal> </entry>
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal> </entry>
       <entry>如果后面跟着一个字符，而不是数字， 那么就匹配左花括弧<literal>{</literal>；如果跟着一个数字， 那么它是<replaceable>range</replaceable>的开始（见下文）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry>其中<replaceable>x</replaceable>是一个没有其它意义的单个字符，则匹配该字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    An RE cannot end with a backslash (<literal>\</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    RE 不能以反斜线（<literal>\</literal>）结尾。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，任何你写在文字串常量中的反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Quantifiers</title>
____________________________________________________________________________-->
    <title>正则表达式量词</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Quantifier</entry>
       <entry>Matches</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>量词</entry>
       <entry>匹配</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>*</literal> </entry>
       <entry> a sequence of 0 or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>*</literal> </entry>
       <entry>一个由原子的 0 次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>+</literal> </entry>
       <entry> a sequence of 1 or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>+</literal> </entry>
       <entry>一个由原子的 1 次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>?</literal> </entry>
       <entry> a sequence of 0 or 1 matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>?</literal> </entry>
       <entry>一个由原子的 0 次或 1 次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的正好<replaceable>m</replaceable>次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry>一个由原子的<replaceable>m</replaceable>次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的从<replaceable>m</replaceable>次到<replaceable>n</replaceable>次（包括）匹配组成的序列；<replaceable>m</replaceable>不能超过<replaceable>n</replaceable> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry> non-greedy version of <literal>*</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry><literal>*</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry> non-greedy version of <literal>+</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry><literal>+</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>??</literal> </entry>
       <entry> non-greedy version of <literal>?</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>??</literal> </entry>
       <entry><literal>?</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>的非贪婪版本 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
   </para>
____________________________________________________________________________-->
   <para>
    使用<literal>{</literal><replaceable>...</replaceable><literal>}</literal>的形式被称作<firstterm>范围</firstterm>。 一个范围内的数字<replaceable>m</replaceable>和<replaceable>n</replaceable>都是无符号十进制整数， 允许的数值从 0 到 255（包含）。
   </para>

<!--==========================orignal english content==========================
    <para>
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
   </para>
____________________________________________________________________________-->
    <para>
     <firstterm>非贪婪</firstterm>的量词（只在 ARE 中可用）匹配对应的正常 （<firstterm>贪婪</firstterm>）模式，区别是它寻找最少的匹配，而不是最多的匹配。详见<xref linkend="posix-matching-rules"/>。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     一个量词不能紧跟在另外一个量词后面，例如<literal>**</literal>是非法的。量词不能作为表达式或者子表达式的开头，也不能跟在<literal>^</literal>或者<literal>|</literal>后面。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Constraints</title>
____________________________________________________________________________-->
    <title>正则表达式约束</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Constraint</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>约束</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>^</literal> </entry>
       <entry> matches at the beginning of the string </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>^</literal> </entry>
       <entry>串开头的匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>$</literal> </entry>
       <entry> matches at the end of the string </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>$</literal> </entry>
       <entry>串末尾的匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>positive lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>negative lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>
       
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上有一个子串匹配<replaceable>re</replaceable>端， <firstterm>positive lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上没有子串匹配<replaceable>re</replaceable>端， <firstterm>negative lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
   </para>
____________________________________________________________________________-->
   <para>
    lookahead 和 lookbehind 约束不能包含<firstterm>后引用</firstterm> （参阅<xref linkend="posix-escape-sequences"/>），并且其中的所有圆括号 都被认为是非捕获的。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--==========================orignal english content==========================
    <title>Bracket Expressions</title>
____________________________________________________________________________-->
    <title>方括号表达式</title>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>方括号表达式</firstterm>是一个包围在<literal>[]</literal>中的字符列表。它通常匹配列表中的任意单个字符（但见下文）。 如果列表以<literal>^</literal>开头，它匹配任意单个<emphasis>不</emphasis>在该列表参与部分中的字符。如果该列表中两个字符用<literal>-</literal>隔开， 那它就是那两个字符（包括在内）之间的所有字符范围的缩写，例如，在<acronym>ASCII</acronym>中<literal>[0-9]</literal>匹配任何十进制数字。两个范围共享一个端点是非法的，例如，<literal>a-c-e</literal>。范围与字符集关系密切， 可移植的程序应该避免依靠它们。
   </para>

<!--==========================orignal english content==========================
   <para>
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
   </para>
____________________________________________________________________________-->
   <para>
    想在列表中包含文本<literal>]</literal>，可以让它做列表的首字符（如果使用了<literal>^</literal>，需要放在其后）。 想在列表中包含文本<literal>-</literal>，可以让它做列表的首字符或者尾字符，或者一个范围的第二个端点。 想在列表中把文本<literal>-</literal>当做范围的起点， 把它用<literal>[.</literal>和<literal>.]</literal>包围起来，这样它就成为一个排序元素（见下文）。 除了这些字符本身、一些用<literal>[</literal>的组合（见下段）以及逃逸（只在 ARE 中有效）以外，所有其它特殊字符 在方括号表达式里都失去它们的特殊含义。特别是，在 ERE 和 BRE 规则下<literal>\</literal>不是特殊的， 但在 ARE 里，它是特殊的（引入一个逃逸）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在一个方括号表达式里，一个排序元素（一个字符、一个被当做一个单一字符排序的多字符序列或者一个表示上面两种情况的排序序列名称） 包含在<literal>[.</literal>和<literal>.]</literal>里面的时候表示该排序元素的字符序列。该序列被当做该方括号列表 的一个单一元素。这允许一个包含多字符排序元素的方括号表达式去匹配多于一个字符，例如，如果排序序列包含一个<literal>ch</literal>排序元素， 那么 RE <literal>[[.ch.]]*c</literal>匹配<literal>chchcc</literal>的头五个字符。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>当前不支持多字符排序元素。这些信息描述了将来可能有的行为。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，包围在<literal>[=</literal>和<literal>=]</literal>里的排序元素是一个<firstterm>等价类</firstterm>， 代表等效于那一个的所有排序元素的字符序列，包括它本身（如果没有其它等效排序元素，那么就好象封装定界符是<literal>[.</literal>和 <literal>.]</literal>）。例如，如果<literal>o</literal>和<literal>^</literal>是一个等价类的成员，那么<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>和<literal>[o^]</literal>都是同义的。一个等价类不能是一个范围的端点。
   </para>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，在<literal>[:</literal>和<literal>:]</literal>里面封装的字符类的名字代表属于该类的所有字符的列表。 字符类不能作为范围的端点使用。<acronym>POSIX</acronym>标准定义了这些字符类的名称：
    <literal>alnum</literal> (字符和数字),
    <literal>alpha</literal> (字符),
    <literal>blank</literal> (空格和制表符tab),
    <literal>cntrl</literal> (控制符),
    <literal>digit</literal> (数位数),
    <literal>graph</literal> (空格除外可打印字符),
    <literal>lower</literal> (小写字母),
    <literal>print</literal> (包含空格可打印字符),
    <literal>punct</literal> (标点符号),
    <literal>space</literal> (空白),
    <literal>upper</literal> (大写字母),
    和 <literal>xdigit</literal> (十六进制数).
    对于7位ASCII字符集中的字符来说，这些标准字符类的行为在不同平台上一般是一致的。一个给定的非ASCII字符是否被认为属于这些类别中的一个，取决于正则表达式函数或运算符使用的<firstterm>collation</firstterm>（见<xref linkend="collation"/>），或者默认情况下取决于数据库的<envar>LC_CTYPE</envar> locale设置（见<xref linkend="locale"/>）。非ASCII字符的分类在不同的平台上会有不同的分类，即使是在类似命名的locale中也是如此。 (但<literal>C</literal> locale从不认为任何非ASCII字符属于上述任何一类)。除了这些标准字符类之外，<productname>PostgreSQL</productname>定义了<literal>ascii</literal>字符类，它完全包含7位ASCII字符集。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</literal> character (as
    defined by the <acronym>POSIX</acronym> character class described above)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
   </para>
____________________________________________________________________________-->
   <para>
    方括号表达式里有两个特例：方括号表达式<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>是约束，分别匹配一个单词开头和结束的空串。 单词定义为一个单词字符序列，前面和后面都没有其它单词字符。单词字符是一个<literal>alnum</literal>字符（和如上所述<acronym>POSIX</acronym>字符类中定义的一样） 或者一个下划线。这是一个扩展，兼容<acronym>POSIX</acronym> 1003.2， 但那里面并没有说明， 而且在准备移植到其他系统里去的软件里一定要小心使用。通常下文描述的约束逃逸更好些（它们并非更标准，但是更容易键入）。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--==========================orignal english content==========================
    <title>Regular Expression Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式逃逸</title>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>逃逸</firstterm>是以<literal>\</literal>开头，后面跟着一个字母数字字符得特殊序列。 逃逸有好几种变体：字符项、类缩写、约束逃逸以及后引用。在 ARE 里， 如果一个<literal>\</literal>后面跟着一个字母数字，但是并未组成一个合法的逃逸， 那么它是非法的。在 ERE 中没有逃逸：在方括号表达式之外，一个后面跟着字母数字字符的<literal>\</literal>只是表示该字符是一个普通的字符，而且在一个方括号表达式里，<literal>\</literal>是一个普通的字符（后者实际上在 ERE 和 ARE 不兼容）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>字符项逃逸</firstterm>用于便于我们在 RE 中声明那些不可打印的或其他习惯的字符。它们显示在<xref linkend="posix-character-entry-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>类缩写逃逸</firstterm>用来提供一些常用的字符类缩写。它们显示在<xref linkend="posix-class-shorthand-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>约束逃逸</firstterm>是一个约束，如果满足特定的条件，它匹配该空串。它们显示在<xref linkend="posix-constraint-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>后引用</firstterm>（<literal>\</literal><replaceable>n</replaceable>）匹配数字<literal>\</literal><replaceable>n</replaceable>指定的被前面的圆括号子表达式匹配的同一个串 （参阅<xref linkend="posix-constraint-backref-table"/>）。例如， <literal>([bc])\1</literal>匹配<literal>bb</literal>或者<literal>cc</literal>， 但是不匹配<literal>bc</literal>或者<literal>cb</literal>。RE 中子表达式必须完全在后引用前面。子表达式以它们的先导圆括号的顺序编号。非捕获圆括号并不定义子表达式。
   </para>

   <table id="posix-character-entry-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Character-Entry Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式字符项逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry> alert (bell) character, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry>警告（响铃）字符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry> backspace, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry>退格，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry>反斜线（<literal>\</literal>）的同义词，用来减少双写反斜线</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry>（其中<replaceable>X</replaceable>是任意字符）低序5位和<replaceable>X</replaceable>相同的字符，它的其他位都是零</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry>排序序列名为<literal>ESC</literal>的字符，如果无法做到该字符为八进制值 <literal>033</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry> form feed, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry>换页，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry> newline, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry>新行，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry> carriage return, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry>回车，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry> horizontal tab, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry>水平制表符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry>（其中<replaceable>wxyz</replaceable>正好是四个十六进制位）十六进制值为<literal>0x</literal><replaceable>wxyz</replaceable>的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry>（其中<replaceable>stuvwxyz</replaceable>正好是八个十六进制位）十六进制值为<literal>0x</literal><replaceable>stuvwxyz</replaceable>的字符
       </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry> vertical tab, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry>垂直制表符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry>（其中<replaceable>hhh</replaceable>是十六进制位的任意序列）十六进制值为<literal>0x</literal><replaceable>hhh</replaceable>的字符（一个单一字符，不管用了多少个十六进制位）
       </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry>值为<literal>0</literal>（空字节）的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry>（其中<replaceable>xy</replaceable>正好是两个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xy</replaceable>的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry>（其中<replaceable>xyz</replaceable>正好是三个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xyz</replaceable>的字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    十六进制位是<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>和<literal>A</literal>-<literal>F</literal>。八进制位是<literal>0</literal>-<literal>7</literal>。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    Numeric character-entry escapes specifying values outside the ASCII range
    (0&ndash;127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
   </para>
____________________________________________________________________________-->
   <para>
    指定 ASCII 范围（0&ndash;127）之外的值的数字字符项转义的含义取决于数据库编码。
    当编码是 UTF-8 时，转义值等价于 Unicode 代码点，例如
    <literal>\u1234</literal>表示字符<literal>U+1234</literal>。对于其他多字节编码，
    字符项转义通常只是指定该字符的字节值的串接。如果该转义值不对应数据库编码
    中的任何合法字符，将不会发生错误，但是它不会匹配任何数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
   </para>
____________________________________________________________________________-->
   <para>
    字符项逃逸总是被当作普通字符。例如，<literal>\135</literal>是 ASCII 中的<literal>]</literal>， 但<literal>\135</literal>并不终止一个方括号表达式。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Class-Shorthand Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式类缩写逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>
       (note underscore is included) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>（注意下划线是被包括的）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
       (note underscore is included) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
      （注意下划线是被包括的）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Within bracket expressions, <literal>\d</literal>, <literal>\s</literal>,
    and <literal>\w</literal> lose their outer brackets,
    and <literal>\D</literal>, <literal>\S</literal>, and <literal>\W</literal> are illegal.
    (So, for example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
    Also, <literal>[a-c\D]</literal>, which is equivalent to
    <literal>[a-c^[:digit:]]</literal>, is illegal.)
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，<literal>\d</literal>、<literal>\s</literal>和<literal>\w</literal>会失去它们的外层方括号，而<literal>\D</literal>、<literal>\S</literal>和 <literal>\W</literal>是非法的（也就是说，例如<literal>[a-c\d]</literal>等效于<literal>[a-c[:digit:]]</literal>。同样<literal>[a-c\D]</literal>等效于 <literal>[a-c^[:digit:]]</literal>的，也是非法的）。
   </para>

   <table id="posix-constraint-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Constraint Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式约束逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry>只在串开头匹配（与<literal>^</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry> matches only at the beginning of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry>只在一个词的开头匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry> matches only at the end of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry>只在一个词的末尾匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry> matches only at the beginning or end of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry>只在一个词的开头或末尾匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry>只在一个词的不是开头或末尾的点上匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry>只在串的末尾匹配（与<literal>$</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
   </para>
____________________________________________________________________________-->
   <para>
    一个词被定义成在上面<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>中的声明。在方括号表达式里，约束逃逸是非法的。
   </para>

   <table id="posix-constraint-backref-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Back References</title>
____________________________________________________________________________-->
    <title>正则表达式后引用</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位）一个到第<replaceable>m</replaceable>个子表达式的后引用</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位，并且<replaceable>nn</replaceable>是一些更多的位，并且十六进制值<replaceable>mnn</replaceable>不超过目前能看到的封闭捕获圆括号的数目）一个到第<replaceable>mnn</replaceable>个子表达式的后引用</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
    </para>
____________________________________________________________________________-->
    <para>
     在八进制字符项逃逸和后引用之间有一个历史继承的歧义存在，这个歧义是 通过下面的启发式规则解决的，像上面描述地那样。前导零总是表示这是一个八进制逃逸。 而单个非零数字，如果没有跟着任何其它位，那么总是被认为后引用。 一个多位的非零开头的序列也被认为是后引用，只要它出现在合适的子表达式后面 （也就是说，在后引用的合法范围中的数），否则就被认为是一个八进制。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--==========================orignal english content==========================
    <title>Regular Expression Metasyntax</title>
____________________________________________________________________________-->
    <title>正则表达式元语法</title>

<!--==========================orignal english content==========================
   <para>
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
   </para>
____________________________________________________________________________-->
   <para>
    除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。
   </para>

<!--==========================orignal english content==========================
   <para>
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个 RE 以<literal>***:</literal>开头，那么剩下的 RE 都被当作 ARE（这在<productname>PostgreSQL</productname>中通常是无效的，因为 RE 被假定为 ARE，但是如果 ERE 或 BRE 模式通过<replaceable>flags</replaceable>参数被指定为一个正则表达式函数时，它确实能产生效果）。如果一个 RE 以<literal>***=</literal>开头， 那么剩下的 RE 被当作一个文本串，所有的字符都被认为是一个普通字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
   </para>
____________________________________________________________________________-->
   <para>
    一个 ARE 可以以<firstterm>嵌入选项</firstterm>开头：一个序列<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>（这里的<replaceable>xyz</replaceable>是一个或多个字母字符）声明影响剩余 RE 的选项。 这些选项覆盖任何前面判断的选项 &mdash; 特别地，它们可以覆盖一个正则表达式操作符隐含的大小写敏感的行为，或者覆盖<replaceable>flags</replaceable>参数中的正则表达式函数。可用的选项字母在<xref linkend="posix-embedded-options-table"/>中显示。注意这些同样的选项字母也被用在正则表达式函数的<replaceable>flags</replaceable>参数中。
   </para>

   <table id="posix-embedded-options-table">
<!--==========================orignal english content==========================
    <title>ARE Embedded-Option Letters</title>
____________________________________________________________________________-->
    <title>ARE 嵌入选项字母</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>选项</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>b</literal> </entry>
       <entry> rest of RE is a BRE </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>b</literal> </entry>
       <entry>RE的剩余部分是一个BRE </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>c</literal> </entry>
       <entry> case-sensitive matching (overrides operator type) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>c</literal> </entry>
       <entry>大小写敏感的匹配（覆盖操作符类型）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>e</literal> </entry>
       <entry> rest of RE is an ERE </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>e</literal> </entry>
       <entry>RE的剩余部分是一个ERE </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>i</literal> </entry>
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>i</literal> </entry>
       <entry>大小写不敏感的匹配（见<xref linkend="posix-matching-rules"/>）（覆盖操作符类型）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>m</literal> </entry>
       <entry> historical synonym for <literal>n</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>m</literal> </entry>
       <entry><literal>n</literal>的历史原因的同义词 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>n</literal> </entry>
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>n</literal> </entry>
       <entry>新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>p</literal> </entry>
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>p</literal> </entry>
       <entry>部分新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>q</literal> </entry>
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>q</literal> </entry>
       <entry>RE的剩余部分是一个文字（<quote>quoted</quote>）串，全部是普通字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>s</literal> </entry>
       <entry> non-newline-sensitive matching (default) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>s</literal> </entry>
       <entry>非新行敏感的匹配（默认）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>t</literal> </entry>
       <entry> tight syntax (default; see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>t</literal> </entry>
       <entry>紧语法（默认，见下文）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>w</literal> </entry>
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>w</literal> </entry>
       <entry>逆部分新行敏感（<quote>怪异</quote>）的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>x</literal> </entry>
       <entry> expanded syntax (see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>x</literal> </entry>
       <entry>扩展语法（见下文）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
   </para>
____________________________________________________________________________-->
   <para>
    嵌入选项在<literal>)</literal>终止序列时发生作用。它们只在 ARE 的开始处起作用 （在任何可能存在的<literal>***:</literal>控制器后面）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:

    <itemizedlist>
     <listitem>
      <para>
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space or <literal>#</literal> within a bracket expression is retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
   </para>
____________________________________________________________________________-->
   <para>
    除了通常的（<firstterm>紧</firstterm>）RE 语法（这种情况下所有字符都有效）， 还有一种<firstterm>扩展</firstterm>语法，可以通过声明嵌入的<literal>x</literal>选项获得。在扩展语法里，RE 中的空白字符被忽略，就像那些在<literal>#</literal>和其后的新行（或 RE 的末尾）之间的字符一样。这样就允许我们给一个复杂的 RE 分段和注释。不过这个基本规则有三种例外：

    <itemizedlist>
     <listitem>
      <para>
       空白字符或前置了<literal>\</literal>的<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       方括号表达式里的空白或者<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       在多字符符号里面不能出现空白和注释，例如<literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    为了这个目的，空白是空格、制表符、新行和任何属于<replaceable>空白</replaceable>字符类的字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
   </para>
____________________________________________________________________________-->
   <para>
    最后，在 ARE 里，方括号表达式外面，序列<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>（其中<replaceable>ttt</replaceable>是任意不包含一个<literal>)</literal>)的文本）是一个注释， 它被完全忽略。同样，这样的东西是不允许出现在多字符符号的字符中间的，例如 <literal>(?:</literal>。这种注释更像是一种历史产物而不是一种有用的设施，并且它们的使用已经被废弃；请使用扩展语法来替代。   </para>

<!--==========================orignal english content==========================
   <para>
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
   </para>
____________________________________________________________________________-->
   <para>
    如果声明了一个初始的<literal>***=</literal>控制器，那么所有这些元语法扩展<emphasis>都不能</emphasis>使用，因为这样表示把用户输入当作一个文字串而不是 RE 对待。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--==========================orignal english content==========================
    <title>Regular Expression Matching Rules</title>
____________________________________________________________________________-->
    <title>正则表达式匹配规则</title>

<!--==========================orignal english content==========================
   <para>
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
   </para>
____________________________________________________________________________-->
   <para>
    在 RE 可以在给定串中匹配多于一个子串的情况下， RE 匹配串中最靠前的那个子串。如果 RE 可以匹配在那个位置开始 的多个子串，要么是取最长的子串，要么是最短的，具体哪种， 取决于 RE 是<firstterm>贪婪</firstterm>的还是<firstterm>非贪婪</firstterm>的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Whether an RE is greedy or not is determined by the following rules:
    <itemizedlist>
     <listitem>
      <para>
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
      </para>
     </listitem>
     <listitem>
      <para>
       Adding parentheses around an RE does not change its greediness.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
      </para>
     </listitem>
     <listitem>
      <para>
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个 RE 是否贪婪取决于下面规则：
    <itemizedlist>
     <listitem>
      <para>
       大多数原子以及所有约束，都没有贪婪属性（因为它们毕竟无法匹配个数变化的文本）。
      </para>
     </listitem>
     <listitem>
      <para>
       在一个 RE 周围加上圆括号并不会改变其贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       带一个固定重复次数量词 （<literal>{</literal><replaceable>m</replaceable><literal>}</literal>或者<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>） 的量化原子和原子自身具有同样的贪婪性（可能是没有）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带其他普通的量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>中<replaceable>m</replaceable>等于<replaceable>n</replaceable>的情况）的量化原子是贪婪的（首选最长匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带非贪婪量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>中<replaceable>m</replaceable>等于 <replaceable>n</replaceable>的情况）的量化原子是非贪婪的（首选最短匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个分支 &mdash; 也就是说，一个没有顶级<literal>|</literal>操作符的 RE &mdash; 和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       一个由<literal>|</literal>操作符连接起来的两个或者更多分支组成的 RE 总是贪婪的。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
   </para>
____________________________________________________________________________-->
   <para>
    上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子， 而且也适用于包含量化原子的分支和整个 RE。这里的意思是， 匹配是按照分支或者整个 RE <emphasis>作为一个整体</emphasis>匹配最长或者最短的可能子串。 一旦整个匹配的长度确定，那么匹配任意特定子表达式的部分就基于该子表达式的贪婪属性进行判断，在 RE 里面靠前的子表达式的优先级高于靠后的子表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    An example of what this means:
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    一个相应的例子：
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
    在第一个例子里，RE 作为整体是贪婪的，因为<literal>Y*</literal>是贪婪的。它可以匹配从<literal>Y</literal>开始的东西，并且它匹配从这个位置开始的最长的串， 也就是，<literal>Y123</literal>。输出是这里的圆括号包围的部分，或者说是<literal>123</literal>。在第二个例子里， RE 总体上是一个非贪婪的 RE，因为<literal>Y*?</literal>是非贪婪的。它可以匹配从<literal>Y</literal>开始的最短的子串，也就是说<literal>Y1</literal>。子表达式<literal>[0-9]{1,3}</literal>是贪婪的，但是它不能修改总体匹配长度的决定； 因此它被迫只匹配<literal>1</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
   </para>
____________________________________________________________________________-->
   <para>
    简而言之，如果一个 RE 同时包含贪婪和非贪婪的子表达式，那么总的匹配长度要么是尽可能长，要么是尽可能短，这取决于给整个 RE 赋予的属性。给子表达式赋予的属性只影响在这个匹配里，各个子表达式之间相互允许<quote>吃掉</quote>的多少。
   </para>

<!--==========================orignal english content==========================
   <para>
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
   </para>
____________________________________________________________________________-->
   <para>
    量词<literal>{1,1}</literal>和<literal>{1,1}?</literal>可以分别用于在一个子表达式
    或者整个 RE 上强制贪婪或者非贪婪。当需要整个 RE 具有不同于从其元素中
    推导出的贪婪属性时，这很有用。例如，假设我们尝试将一个包含一些数字的
    字符串分隔成数字以及在它们之前和之后的部分，我们可能会尝试这样做：
<screen>
SELECT regexp_matches('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    这不会有用：第一个<literal>.*</literal>是贪婪的，因此它会<quote>吃掉</quote>
    尽可能多的字符而留下<literal>\d+</literal>去匹配在最后一个可能位置上的最
    后一个数字。我们可能会通过让它变成非贪婪来修复：
<screen>
SELECT regexp_matches('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    这也不会有用：因为现在 RE 作为整体来说是非贪婪的，因此它会尽快结束
    全部的匹配。我们可以通过强制 RE 整体是贪婪的来得到我们想要的：
<screen>
SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    独立于 RE 的组件的贪婪性之外控制 RE 的整体贪婪性为处理变长模式提供了
    很大的灵活性。
   </para>

<!--==========================orignal english content==========================
   <para>
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
   </para>
____________________________________________________________________________-->
   <para>
    在决定更长或者更短的匹配时，匹配长度是以字符衡量的，而不是排序元素。一个空串会被认为比什么都不匹配长。例如：<literal>bb*</literal>匹配<literal>abbbc</literal>的中间三个字符；<literal>(week|wee)(night|knights)</literal>匹配<literal>weeknights</literal>的所有十个字符； 而<literal>(.*).*</literal>匹配 <literal>abc</literal>的时候，圆括号包围的子表达式匹配所有三个字符；当<literal>(a*)*</literal>被拿来匹配<literal>bc</literal>时，整个 RE 和圆括号 子表达式都匹配一个空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果声明了大小写无关的匹配，那么效果就好像所有大小写区别在字母表中消失了。如果在多个情况中一个字母以一个普通字符的形式出现在方括号表达式外面，那么它实际上被转换成 一个包含大小写的方括号表达式，也就是说，x 变成 [xX]。 如果它出现在一个方括号表达式里面，那么它的所有大小写的同族都被加入 方括号表达式中，也就是说，<literal>x</literal>变成<literal>[xX]</literal>。当它出现在一个方括号表达式内时，它的所有大小写副本都被加入到方括号表达式中，例如， <literal>[x]</literal>会变成<literal>[xX]</literal>，而<literal>[^x]</literal>会变成<literal>[^xX]</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了新行敏感的匹配，<literal>.</literal>和使用<literal>^</literal>的方括号表达式 将永远不会匹配新行字符（这样，匹配就绝对不会跨越新行，除非 RE 显式地安排了这样的情况）并且<literal>^</literal>和<literal>$</literal>除了分别匹配串开头和结尾之外，还将分别匹配新行后面和前面的空串。但是 ARE 逃逸<literal>\A</literal>和<literal>\Z</literal>仍然<emphasis>只</emphasis>匹配串的开头和结尾。
   </para>

<!--==========================orignal english content==========================
   <para>
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了部分新行敏感的匹配，那么它影响<literal>.</literal>和方括号表达式， 这个时候和新行敏感的匹配一样，但是不影响<literal>^</literal>和<literal>$</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了逆新行敏感匹配，那么它影响<literal>^</literal>和<literal>$</literal>，其作用和在新行敏感的匹配里一样，但是不影响<literal>.</literal>和方括号表达式。这个并不是很有用，只是为了满足对称性而提供的。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--==========================orignal english content==========================
    <title>Limits and Compatibility</title>
____________________________________________________________________________-->
    <title>限制和兼容性</title>

<!--==========================orignal english content==========================
   <para>
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
   </para>
____________________________________________________________________________-->
   <para>
    在这个实现里，对 RE 的长度没有特别的限制。但是，那些希望高移植性的程序应该避免使用长度超过 256 字节的 RE，因为 POSIX 兼容 的实现可以拒绝接受这样的 RE。
   </para>

<!--==========================orignal english content==========================
   <para>
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
   </para>
____________________________________________________________________________-->
   <para>
    ARE 实际上和 POSIX ERE 不兼容的唯一的特性是在方括号表达式里<literal>\</literal>并不失去它特殊的含义。所有其它 ARE 特性都使用在 POSIX ERE 里面是非法或者是未定义、未声明效果的语法；指示器的<literal>***</literal>就是在 POSIX 的 BRE 和 ERE 之外的语法。
   </para>

<!--==========================orignal english content==========================
   <para>
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
   </para>
____________________________________________________________________________-->
   <para>
    许多 ARE 扩展都是从 Perl 那里借来的（但是有些被做了修改来清理它们），以及一些 Perl 里没有出现的扩展。要注意的不兼容性包括<literal>\b</literal>、<literal>\B</literal>、对结尾的新行缺乏特别的处理、对那些被新行敏感匹配的东西附加的补齐方括号表达式、在 lookahead/lookbehind 约束里对圆括号和后引用的限制以及最长/最短 匹配（而不是第一匹配）的语义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</productname>:

    <itemizedlist>
     <listitem>
      <para>
       In AREs, <literal>\</literal> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
      </para>
     </listitem>
     <listitem>
      <para>
       In AREs, <literal>\</literal> remains a special character within
       <literal>[]</literal>, so a literal <literal>\</literal> within a bracket
       expression must be written <literal>\\</literal>.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname> 7.4 之前的版本中识别的 ARE 和 ERE 语法存在两个非常明显的不兼容：

    <itemizedlist>
     <listitem>
      <para>
       在 ARE 中，后面跟着一个字母数字字符的<literal>\</literal>要么是一个逃逸要么是一个错误， 但是在以前的版本里，它只是写该字母数字字符的另外一种方法。这个应该不是什么问题， 因为在以前的版本里没有什么理由会让我们写这样的序列。
      </para>
     </listitem>
     <listitem>
      <para>
       在 ARE 里，<literal>\</literal>在<literal>[]</literal>里还是一个特殊字符， 因此在方括号表达式里的一个文本<literal>\</literal>必须被写成<literal>\\</literal>。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--==========================orignal english content==========================
    <title>Basic Regular Expressions</title>
____________________________________________________________________________-->
    <title>基本正则表达式</title>

<!--==========================orignal english content==========================
   <para>
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
   </para>
____________________________________________________________________________-->
   <para>
    BRE 在几个方面和 ERE 不太一样。在 BRE 中，<literal>|</literal>、<literal>+</literal>和<literal>?</literal>都是普通字符并且没有与它们功能等价的东西。范围的定界符是<literal>\{</literal>和<literal>\}</literal>， 因为 <literal>{</literal>和<literal>}</literal>本身是普通字符。嵌套的子表达式的圆括号是<literal>\(</literal>和<literal>\)</literal>，因为<literal>(</literal>和<literal>)</literal>自身是普通字符。除非在 RE 开头或者是圆括号子表达式开头，<literal>^</literal>都是一个普通字符。 除非在 RE 结尾或者是圆括号子表达式的结尾，<literal>$</literal>是一个普通字符。如果<literal>*</literal>出现在 RE 开头或者是圆括号封装的子表达式开头 （前面可能有<literal>^</literal>），那么它是个普通字符。最后，可以用单数字的后引用，<literal>\&lt;</literal>和<literal>\&gt;</literal>分别是<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>的同义词；在 BRE 中没有其它可用的逃逸。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->
   <sect3 id="posix-vs-xquery">
<!--==========================orignal english content==========================
   <title>Differences from XQuery (<literal>LIKE_REGEX</literal>)</title>
____________________________________________________________________________-->
   <title>与XQuery的区别 (<literal>LIKE_REGEX</literal>)</title>

<!--==========================orignal english content==========================
   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery regular expressions</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery正则表达式</primary>
   </indexterm>

<!--==========================orignal english content==========================
    <para>
     Since SQL:2008, the SQL standard includes
     a <literal>LIKE_REGEX</literal> operator that performs pattern
     matching according to the XQuery regular expression
     standard.  <productname>PostgreSQL</productname> does not yet
     implement this operator, but you can get very similar behavior using
     the <function>regexp_match()</function> function, since XQuery
     regular expressions are quite close to the ARE syntax described above.
    </para>
____________________________________________________________________________-->
    <para>
     从SQL:2008开始，SQL标准中包含了一个<literal>LIKE_REGEX</literal>操作符，它根据XQuery正则表达式标准执行模式匹配。 <productname>PostgreSQL</productname>还没有实现这个操作符，但是你可以使用<function>regexp_match()</function>函数获得非常类似的行为，因为XQuery正则表达式非常接近于上面描述的ARE语法。
    </para>

<!--==========================orignal english content==========================
    <para>
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:

     <itemizedlist>
      <listitem>
       <para>
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
       </para>
      </listitem>
      <listitem>
       <para>
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
       </para>
      </listitem>
      <listitem>
       <para>
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
       </para>
      </listitem>
      <listitem>
       <para>
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
        <itemizedlist>
         <listitem>
          <para>
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     与现有的基于POSIX的
正则表达式功能和XQuery正则表达式包括。

     <itemizedlist>
      <listitem>
       <para>
        不支持XQuery字符类减法。 这个功能的一个例子是使用下面的例子，只匹配英文辅音。<literal>[a-z-[aeiou]]</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery字符类速记<literal>c</literal>。
不支持<literal>C</literal>、<literal>i</literal>和<literal>I</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        不支持使用<literal>p{UnicodeProperty}</literal>或反过来的<literal>P{UnicodeProperty}</literal>的XQuery字符类元素。
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX根据当前的locale来解释字符类，如<literal>/w</literal> (见<xref linkend="posix-class-shorthand-escapes-table"/>)(你可以通过在操作符或函数中附加一个<literal>COLLATE</literal>子句来控制)。 XQuery通过引用Unicode字符属性来指定这些类，因此只有遵循Unicode规则的locale才能获得等效的行为。
       </para>
      </listitem>
      <listitem>
       <para>
        SQL标准（而不是XQuery本身）试图满足更多的需求。<quote>newline的变体</quote>比POSIX的变体。 上面描述的对新行敏感的匹配选项只考虑ASCII NL (<literal>n</literal>)是新行，但SQL会让我们把CR (<literal>r</literal>)、CRLF (<literal>r/n</literal>)(Windows风格的新行)，以及一些Unicode唯一的字符，如LINE SEPARATOR (U+2028)也视为新行。值得注意的是，<literal>.</literal>和<literal>s</literal>应该算作一个字符，而不是按照SQL的规定算作两个字符。
       </para>
      </listitem>
      <listitem>
       <para>
        在<xref linkend="posix-character-entry-escapes-table"/>中描述的字符输入转义中，XQuery只支持<literal>n</literal>、<literal>r</literal>和<literal>t</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery不支持<literal>[::<replaceable>name</replaceable>:]]</literal>语法，不支持括号表达式中的字符类。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery没有 lookahead 或 lookbehind 约束，也没有任何在
        <xref linkend="posix-constraint-escapes-table"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        <xref linkend="posix-metasyntax"/>中描述的metasyntax形式在XQuery中不存在。
       </para>
      </listitem>
      <listitem>
       <para>
        由XQuery定义的正则表达式标志字母与POSIX的选项字母相关，但不一样。
 <xref linkend="posix-embedded-options-table"/>）。 虽然<literal>i</literal>和<literal>q</literal>选项的行为是一样的，但其他的选项却不一样。
        <itemizedlist>
         <listitem>
          <para>
           XQuery的<literal>s</literal>（允许点匹配换行）和<literal>m</literal>（允许<literal>^</literal>和<literal>$</literal>在换行处匹配）标志提供了与POSIX的<literal>n</literal>相同的行为。<literal>p</literal>和<literal>w</literal>标志，但它们与POSIX的<literal>s</literal>和<literal>m</literal>标志的行为不匹配。特别要注意的是，点匹配-newline是POSIX中的默认行为，但不是XQuery。
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery的<literal>x</literal>（忽略模式中的空格）标志与POSIX的扩展模式标志明显不同。 POSIX的<literal>x</literal>标志也允许<literal>#</literal>在模式中开始注释，并且POSIX不会忽略反斜线后的空格字符。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect3>

  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
<!--==========================orignal english content==========================
   <title>Data Type Formatting Functions</title>
____________________________________________________________________________-->
   <title>数据类型格式化函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>formatting</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>formatting</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>格式化函数提供一套强大的工具用于把各种数据类型 （日期/时间、整数、浮点、数字） 转换成格式化的字符串以及反过来从格式化的字符串转换成 指定的数据类型。<xref linkend="functions-formatting-table"/>列出了这些函数。这些函数都遵循一个公共的调用规范： 第一个参数是待格式化的值，而第二个是一个定义输出或输入格式的模板。
   </para>

   <table id="functions-formatting-table">
<!--==========================orignal english content==========================
    <title>Formatting Functions</title>
____________________________________________________________________________-->
    <title>格式化函数</title>
    <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>convert time stamp to string</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>把时间戳转成字符串</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>convert interval to string</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把间隔转成字符串</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>convert integer to string</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把整数转成字符串</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>convert real/double precision to string</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>把实数或双精度转成字符串</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>convert numeric to string</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>把数字转成字符串</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>convert string to date</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>把字符串转成日期</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
        <entry>convert string to numeric</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
        <entry>把字符串转成数字</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>convert string to time stamp</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>把字符串转成时间戳</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts time stamp to string according to the given format.
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将时间戳转换为字符串。
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts interval to string according to the given format.
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将间隔转换为字符串。
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts number to string according to the given format; available
        for <type>integer</type>, <type>bigint</type>, <type>numeric</type>,
        <type>real</type>, <type>double precision</type>.
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将数字转换为字符串；适用于 <type>integer</type>， <type>bigint</type>， <type>numeric</type>，<type>real</type>， <type>double precision</type>。
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        Converts string to date according to the given format.
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为日期。
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Converts string to numeric according to the given format.
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为数字。
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Converts string to time stamp according to the given format.
        (See also <function>to_timestamp(double precision)</function> in
        <xref linkend="functions-datetime-table"/>.)
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为时间戳。
        （也请参见<xref linkend="functions-datetime-table"/>中的<function>to_timestamp(double precision)</function> 。）
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <tip>
<!--==========================orignal english content==========================
    <para>
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
    </para>
____________________________________________________________________________-->
    <para>
     <function>to_timestamp</function>和<function>to_date</function>存在的目的是为了处理无法用简单造型转换的输入格式。对于大部分标准的日期/时间格式，简单地把源字符串造型成所需的数据类型是可以的，并且简单很多。类似地，对于标准的数字表示形式，<function>to_number</function>也是没有必要的。
    </para>
   </tip>
   
<!--==========================orignal english content==========================
   <para>
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
   </para>
____________________________________________________________________________-->
   <para>
    在一个<function>to_char</function>输出模板串中，一些特定的模式可以被识别并且被替换成基于给定值的被恰当地格式化的数据。任何不属于模板模式的文本都简单地照字面拷贝。同样，在一个输入 模板串里（对其他函数），模板模式标识由输入数据串提供的值。如果在模板字符串中有不是模板模式的字符，输入数据字符串中的对应字符会被简单地跳过（不管它们是否等于模板字符串字符）。
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-datetime-table"/>展示了可以用于格式化日期和时间值的模版。
  </para>

    <table id="functions-formatting-datetime-table">
<!--==========================orignal english content==========================
     <title>Template Patterns for Date/Time Formatting</title>
____________________________________________________________________________-->
     <title>用于日期/时间格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>hour of day (00&ndash;23)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>一天中的小时 (00&ndash;23)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minute (00&ndash;59)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>分钟 (00&ndash;59)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SS</literal></entry>
        <entry>second (00&ndash;59)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SS</literal></entry>
        <entry>秒 (00&ndash;59)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MS</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MS</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>US</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>US</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>tenth of second (0&ndash;9)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>十分之一秒 (0&ndash;9)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>hundredth of second (00&ndash;99)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>百分之一秒 (00&ndash;99)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>tenth of a millisecond (0000&ndash;9999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>十分之一毫秒 (0000&ndash;9999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>hundredth of a millisecond (00000&ndash;99999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>百分之一毫秒 (00000&ndash;99999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>seconds past midnight (0&ndash;86399)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>午夜后的秒 (0&ndash;86399)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>meridiem indicator (without periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>正午指示器（不带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>meridiem indicator (with periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>正午指示器（带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>year (4 or more digits) with comma</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>带逗号的年（4 位或者更多位） with comma</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>year (4 or more digits)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>年（4 位或者更多位）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>last 3 digits of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>年的最后 3 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YY</literal></entry>
        <entry>last 2 digits of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YY</literal></entry>
        <entry>年的最后 2 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Y</literal></entry>
        <entry>last digit of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Y</literal></entry>
        <entry>年的最后 1 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 周编号方式的年（4 位或更多位）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 3 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IY</literal></entry>
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 2 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>I</literal></entry>
        <entry>last digit of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>I</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 1 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
        <entry>era indicator (without periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> 或 <literal>ad</literal></entry>
        <entry>纪元指示器（不带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
        <entry>era indicator (with periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> 或 <literal>a.d.</literal></entry>
        <entry>纪元指示器（带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>全大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Month</literal></entry>
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Month</literal></entry>
        <entry>全首字母大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>month</literal></entry>
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>month</literal></entry>
        <entry>全小写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MON</literal></entry>
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MON</literal></entry>
        <entry>简写的大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>简写的首字母大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>mon</literal></entry>
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>mon</literal></entry>
        <entry>简写的小写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MM</literal></entry>
        <entry>month number (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MM</literal></entry>
        <entry>月编号 (01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>全大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Day</literal></entry>
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Day</literal></entry>
        <entry>全首字母大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>day</literal></entry>
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>day</literal></entry>
        <entry>全小写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DY</literal></entry>
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DY</literal></entry>
        <entry>简写的大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>简写的首字母大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>dy</literal></entry>
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>dy</literal></entry>
        <entry>简写的小写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>day of year (001&ndash;366)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>一年中的日(001&ndash;366)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>day of ISO 8601 week-numbering year (001&ndash;371; day 1 of the year is Monday of the first ISO week)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>ISO 8601 周编号方式的年中的日 （001&ndash;371; 年的第 1 日时第一个 ISO 周的周一）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DD</literal></entry>
        <entry>day of month (01&ndash;31)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DD</literal></entry>
        <entry>月中的日 (01&ndash;31)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>D</literal></entry>
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>周中的日，周日 (<literal>1</literal>) 到周六 (<literal>7</literal>)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>ID</literal></entry>
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>ID</literal></entry>
        <entry>周中的 ISO 8601 日，周一 (<literal>1</literal>) 到周日 (<literal>7</literal>)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>W</literal></entry>
        <entry>week of month (1&ndash;5) (the first week starts on the first day of the month)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>W</literal></entry>
        <entry>月中的周 (1&ndash;5) （第一周从该月的第一天开始）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>WW</literal></entry>
        <entry>week number of year (1&ndash;53) (the first week starts on the first day of the year)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>WW</literal></entry>
        <entry>年中的周数 (1&ndash;53) （第一周从该年的第一天开始）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IW</literal></entry>
        <entry>week number of ISO 8601 week-numbering year (01&ndash;53; the first Thursday of the year is in week 1)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IW</literal></entry>
        <entry>ISO 8601 周编号方式的年中的周数 (01&ndash;53; 新的一年的第一个周四在第一周)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>CC</literal></entry>
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>CC</literal></entry>
        <entry>世纪（2 位数）（21 世纪开始于 2001-01-01）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>J</literal></entry>
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>J</literal></entry>
        <entry>儒略日（从午夜 UTC 的公元前 4714 年 11 月 24 日开始的整数日数）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Q</literal></entry>
        <entry>quarter</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Q</literal></entry>
        <entry>季度</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>RM</literal></entry>
        <entry>month in upper case Roman numerals (I&ndash;XII; I=January)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>RM</literal></entry>
        <entry>大写形式的罗马计数法的月 (I&ndash;XII; I=一月)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>rm</literal></entry>
        <entry>month in lower case Roman numerals (i&ndash;xii; i=January)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>rm</literal></entry>
        <entry>小写形式的罗马计数法的月 (i&ndash;xii; i=一月)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>大写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>tz</literal></entry>
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>tz</literal></entry>
        <entry>小写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>time-zone hours</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>时区的小时</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>time-zone minutes</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>时区的分钟</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>OF</literal></entry>
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>OF</literal></entry>
        <entry>从UTC开始的时区偏移（仅在<function>to_char</function>中支持）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
   </para>
____________________________________________________________________________-->
   <para>
    修饰语可以被应用于模板模式来修改它们的行为。例如，<literal>FMMonth</literal>就是带着<literal>FM</literal>修饰语的<literal>Month</literal>模式。<xref linkend="functions-formatting-datetimemod-table"/>展示了可用于日期/时间格式化的修饰语模式。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--==========================orignal english content==========================
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
____________________________________________________________________________-->
     <title>用于日期/时间格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制前导零和填充的空格）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写形式的序数后缀</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写形式的序数后缀</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>fixed format global option (see usage notes)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>固定的格式化全局选项（见使用须知）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>translation mode (use localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>翻译模式（基于<xref linkend="guc-lc-time"/>使用本地化的日和月名）</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>spell mode (not implemented)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>拼写模式（未实现）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Usage notes for date/time formatting:

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TM</literal> suppresses trailing blanks whether or
       not <literal>FM</literal> is specified.
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       ignore letter case in the input; so for
       example <literal>MON</literal>, <literal>Mon</literal>,
       and <literal>mon</literal> all accept the same strings.  When using
       the <literal>TM</literal> modifier, case-folding is done according to
       the rules of the function's input collation (see
       <xref linkend="collation"/>).
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
      </para>
     </listitem>

     <listitem>
      <para>
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
      </para>
      <para>
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
      </para>
     </listitem>

     <listitem>
      <para>
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
      </para>
      <tip>
        <para>
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!-&minus; "" font-lock sanity :-) -&minus;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.,
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.,
       <literal>95</literal> becomes 1995.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       negative years are treated as signifying BC.  If you write both a
       negative year and an explicit <literal>BC</literal> field, you get AD
       again.  An input of year zero is treated as 1 BC.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
       <itemizedlist>
        <listitem>
         <para>
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
         </para>
        </listitem>
        <listitem>
         <para>
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
      </para>
      <caution>
       <para>
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
      </para>

      <para>
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
      </para>
     </listitem>

    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    日期/时间格式化的使用须知：

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal>抑制前导的零或尾随的空白， 否则会把它们增加到输入从而把一个模式的输出变成固定宽度。在<productname>PostgreSQL</productname>中，<literal>FM</literal>只修改下一个声明，而在 Oracle 中，<literal>FM</literal>影响所有随后的声明，并且重复的<literal>FM</literal>修饰语将触发填充模式开和关。
      </para>
     </listitem>

     <listitem>
      <para>
       无论是否指定<literal>FM</literal>，<literal>TM</literal>抑制尾随的空格。
      </para>
     </listitem>

     <listitem>
      <para>
	   <function>to_timestamp</function>和<function>to_date</function>忽略输入中的字母大小写；
	   例如<literal>MON</literal>，<literal>Mon</literal>和<literal>mon</literal>都接受相同的字符串。
	   当使用<literal>TM</literal>修饰符时，大小写折叠是根据函数的输入排序规则进行的(参见 <xref linkend="collation"/>)。
      </para>
     </listitem>

      <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>跳过了输入字符串开头和日期和时间值周围的多个空格，除非使用了<literal>FX</literal>选项。 例如，<literal>to_to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYY-MON')</literal>和<literal>to_timestamp('2000 - JUN', 'YYY-MON')</literal>都能工作，但<literal>to_timestamp('2000&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY-MON')</literal>返回一个错误，因为<function>to_timestamp</function>只期望一个空格。<literal>FX</literal>必须指定为模板中的第一个项目。
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>的模板字符串中的分隔符（一个空格或非字母/非数字字符）与输入字符串中的任何一个分隔符相匹配，或者被跳过，除非使用了<literal>FX</literal>选项。例如，<literal>to_to_timestamp('2000JUN', 'YYY///MON')</literal>和<literal>to_timestamp('2000/JUN', 'YYY/MON')</literal>可以工作，但<literal>to_timestamp('2000/JUN', 'YYYY/MON')</literal>返回一个错误，因为输入字符串中的分隔符数量超过了模板中的分隔符数量。
      </para>
      <para>
       如果指定了<literal>FX</literal>，模板字符串中的分隔符正好与输入字符串中的一个字符匹配。 但要注意的是，输入字符串中的字符不需要与模板字符串中的分隔符相同。例如，<literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>可以工作，但是<literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>返回错误，因为模板字符串中的第二个空格会消耗掉输入字符串中的字母<literal>J</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TZH</literal>模板模式可以匹配一个有符号的数字。如果没有<literal>FX</literal>选项，减号可能是模糊的，可能被解释为分隔符。这种模棱两可的问题可以通过以下方式解决。 如果模板字符串中<literal>TZH</literal>前的分隔符的数量小于输入字符串中减号前的分隔符数量，则减号被解释为<literal>TZH</literal>的一部分。否则，减号被认为是值之间的分隔符。例如，<literal>to_timestamp(''2000 -10', 'YYY&nbsp;TZH')</literal>与<literal>-10</literal>匹配，但<literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>匹配<literal>10</literal>到<literal>TZH</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_char</function>模板里可以有普通文本，并且它们会被照字面输出。你可以把一个子串放到双引号里强迫它被解释成一个文本，即使它里面包含模板模式也如此。例如，在 <literal>'"Hello Year "YYYY'</literal>中，<literal>YYYY</literal>将被年份数据代替，但是<literal>Year</literal>中单独的<literal>Y</literal>不会。在<function>to_date</function>、<function>to_number</function>以及<function>to_timestamp</function>中，文本和双引号字符串会导致跳过该字符串中所包含的字符数量，例如<literal>"XX"</literal>会跳过两个输入字符（不管它们是不是<literal>XX</literal>）。
      </para>
      <tip>
        <para>
        在<productname>PostgreSQL</productname> 12之前，可以使用非字母或非数字字符跳过输入字符串中的任意文本。例如，<literal>to_timestamp('2000y6m1d', 'yyyyy-MM-DD')</literal>以前是有效的。 现在，你只能使用字母字符来实现这个目的。 例如，<literal>to_timestamp(''2000y6m1d', 'yyyytMMtDDt')</literal>和<literal>to_timestamp('2000y6m1d', 'yyyyy"y"MM"m"DD"d"')</literal>跳过<literal>y</literal>、<literal>m</literal>和<literal>d</literal>。
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
       如果你想在输出里有双引号，那么你必须在它们前面放反斜线，例如 <literal>'\"YYYY Month\"'</literal>。<!-- "" font-lock sanity :-) -->不然，在双引号字符串外面的反斜线就不是特殊的。在双引号字符串内，反斜线会导致下一个字符被取其字面形式，不管它是什么字符（但是这没有特殊效果，除非下一个字符是一个双引号或者另一个反斜线）。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，如果年份格式声明少于四位（如<literal>YYY</literal>）并且提供的年份少于四位，年份将被调整为最接近于 2020 年，例如<literal>95</literal>会变成 1995。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，负的年份被视为表示BC。
       如果你同时写一个负的年份和一个显式的<literal>BC</literal>字段，你又会得到AD。第0年的输入被视为公元前1年。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，在处理超过4位数的年份时，<literal>YYYY</literal>转换具有限制。你必须在<literal>YYYY</literal>后面使用一些非数字字符或者模板， 否则年份总是被解释为 4 位数字。例如（对于 20000 年）：<literal>to_date('200001131', 'YYYYMMDD')</literal>将会被解释成一个 4 位数字的年份，而不是在年份后使用一个非数字分隔符，像<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>或<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，<literal>CC</literal>（世纪）字段会被接受，但是如果有<literal>YYY</literal>、<literal>YYYY</literal>或者<literal>Y,YYY</literal>字段则会忽略它。如果<literal>CC</literal>与<literal>YY</literal>或<literal>Y</literal>一起使用，则结果被计算为指定世纪中的那一年。如果指定了世纪但是没有指定年，则会假定为该世纪的第一年。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，工作日名称或编号（<literal>DAY</literal>、<literal>D</literal>以及相关的字段类型）会被接受，但会为了计算结果的目的而忽略。季度（<literal>Q</literal>）字段也是一样。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，一个 ISO 8601 周编号的日期（与一个格里高利日期相区别）可以用两种方法之一被指定为<function>to_timestamp</function>和<function>to_date</function>：
       <itemizedlist>
        <listitem>
         <para>
          年、周编号和工作日：例如<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>返回日期<literal>2006-10-19</literal>。如果你忽略工作日，它被假定为 1（周一）。
         </para>
        </listitem>
        <listitem>
         <para>
          年和一年中的日：例如<literal>to_date('2006-291', 'IYYY-IDDD')</literal>也返回<literal>2006-10-19</literal>。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       尝试使用一个混合了 ISO 8601 周编号和格里高利日期的域来输入一个日期是无意义的，并且将导致一个错误。在一个 ISO 周编号的年的环境下，一个<quote>月</quote>或<quote>月中的日</quote>的概念没有意义。在一个格里高利年的环境下，ISO 周没有意义。用户应当避免混合格里高利和 ISO 日期声明。
      </para>
      <caution>
       <para>
        虽然<function>to_date</function>将会拒绝混合使用格里高利和 ISO 周编号日期的域，
        <function>to_char</function>却不会，因为<literal>YYYY-MM-DD (IYYY-IDDD)</literal>
        这种输出格式也会有用。但是避免写类似<literal>IYYY-MM-DD</literal>的东西，那会得到在
        起始年附近令人惊讶的结果（详见<xref linkend="functions-datetime-extract"/>）。
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>中，毫秒（<literal>MS</literal>）和微秒（<literal>US</literal>）域都被用作小数点后的秒位。例如<literal>to_timestamp('12.3', 'SS.MS')</literal>不是 3 毫秒, 而是 300，因为该转换把它看做 12 + 0.3 秒。这意味着对于格式<literal>SS.MS</literal>而言，输入值<literal>12.3</literal>、<literal>12.30</literal>和<literal>12.300</literal>指定了相同数目的毫秒。要得到三毫秒，你必须使用 <literal>12.003</literal>，转换会把它看做 12 + 0.003 = 12.003 秒。
      </para>

      <para>
       下面是一个更复杂的例子∶<literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>是 15 小时、12 分钟和 2 秒 + 20 毫秒 + 1230微秒 = 2.021230 秒。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(..., 'ID')</function>的一周中日的编号匹配<function>extract(isodow from ...)</function>函数，但是<function>to_char(..., 'D')</function>不匹配<function>extract(dow from ...)</function>的日编号。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(interval)</function>格式化<literal>HH</literal>和<literal>HH12</literal>为显示在一个 12 小时的时钟上，即零小时和 36 小时输出为<literal>12</literal>，而<literal>HH24</literal>会输出完整的小时值，对于间隔它可以超过 23.
      </para>
     </listitem>

    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-numeric-table"/>展示了可以用于格式化数字值的模版模式。
  </para>

    <table id="functions-formatting-numeric-table">
<!--==========================orignal english content==========================
     <title>Template Patterns for Numeric Formatting</title>
____________________________________________________________________________-->
     <title>用于数字格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>9</literal></entry>
        <entry>digit position (can be dropped if insignificant)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>9</literal></entry>
        <entry>数位（如果无意义可以被删除）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>0</literal></entry>
        <entry>digit position (will not be dropped, even if insignificant)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>0</literal></entry>
        <entry>数位（即便没有意义也不会被删除）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>小数点</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>分组（千）分隔符</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PR</literal></entry>
        <entry>negative value in angle brackets</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PR</literal></entry>
        <entry>尖括号内的负值</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>S</literal></entry>
        <entry>sign anchored to number (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>S</literal></entry>
        <entry>带符号的数字（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>L</literal></entry>
        <entry>currency symbol (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>L</literal></entry>
        <entry>货币符号（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>D</literal></entry>
        <entry>decimal point (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>小数点（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>G</literal></entry>
        <entry>group separator (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>G</literal></entry>
        <entry>分组分隔符（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minus sign in specified position (if number &lt; 0)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>在指定位置的负号（如果数字 &lt; 0）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PL</literal></entry>
        <entry>plus sign in specified position (if number &gt; 0)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PL</literal></entry>
        <entry>在指定位置的正号（如果数字 &gt; 0）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SG</literal></entry>
        <entry>plus/minus sign in specified position</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SG</literal></entry>
        <entry>在指定位置的正/负号</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>RN</literal></entry>
        <entry>Roman numeral (input between 1 and 3999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>RN</literal></entry>
        <entry>罗马数字（输入在 1 和 3999 之间）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>序数后缀</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>V</literal></entry>
        <entry>shift specified number of digits (see notes)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>V</literal></entry>
        <entry>移动指定位数（参阅注解）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>exponent for scientific notation</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>科学记数的指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Usage notes for numeric formatting:

    <itemizedlist>
     <listitem>
      <para>
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
      </para>
     </listitem>

     <listitem>
      <para>
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
      </para>
     </listitem>

     <listitem>
      <para>
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
      </para>
     </listitem>

     <listitem>
      <para>
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    数字格式化的用法须知：

    <itemizedlist>
     <listitem>
      <para>
       <literal>0</literal>指定一个总是被打印的数位，即便它包含前导/拖尾的零。<literal>9</literal>也指定一个数位，但是如果它是前导零则会被空格替换，而如果是拖尾零并且指定了填充模式则它会被删除（对于<function>to_number()</function>来说，这两种模式字符等效）。
      </para>
     </listitem>

     <listitem>
      <para>
       模式字符<literal>S</literal>、<literal>L</literal>、<literal>D</literal>以及<literal>G</literal>表示当前locale定义的负号、货币符号、小数点以及数字分隔符字符（见<xref linkend="guc-lc-monetary"/>和<xref linkend="guc-lc-numeric"/>）。不管locale是什么，模式字符句号和逗号就表示小数点和数字分隔符。
      </para>
     </listitem>

     <listitem>
      <para>
       对于<function>to_char()</function>的模式中的一个负号，如果没有明确的规定，将为该负号保留一列，并且它将被锚接到（出现在左边）那个数字。如果<literal>S</literal>正好出现在某个<literal>9</literal>的左边，它也将被锚接到那个数字。
      </para>
     </listitem>

     <listitem>
      <para>
       使用<literal>SG</literal>、<literal>PL</literal>或<literal>MI</literal>格式化的符号并不挂在数字上面； 例如，<literal>to_char(-12, 'MI9999')</literal>生成<literal>'-&nbsp;&nbsp;12'</literal>，而<literal>to_char(-12, 'S9999')</literal>生成 <literal>'&nbsp;&nbsp;-12'</literal>。（Oracle 里的实现不允许在<literal>9</literal>前面使用<literal>MI</literal>，而是要求<literal>9</literal>在<literal>MI</literal>前面。）
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal>不会转换小于零的数值，也不会转换小数。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>、<literal>SG</literal>和<literal>TH</literal>是<productname>PostgreSQL</productname>扩展。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_number</function>中，如果没有使用<literal>L</literal>或<literal>TH</literal>之类的非数据模板模式，相应数量的输入字符会被跳过，不管它们是否匹配模板模式，除非它们是数据字符（也就是数位、负号、小数点或者逗号）。例如，<literal>TH</literal>会跳过两个非数据字符。
      </para>
     </listitem>

     <listitem>
      <para>
       带有<function>to_char</function>的<literal>V</literal>会把输入值乘上<literal>10^<replaceable>n</replaceable></literal>，其中<replaceable>n</replaceable>是跟在<literal>V</literal>后面的位数。带有<function>to_number</function>的<literal>V</literal>以类似的方式做除法。<function>to_char</function>和<function>to_number</function>不支持使用结合小数点的<literal>V</literal>（例如，不允许<literal>99.9V99</literal>）。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>EEEE</literal>（科学记数法）不能和任何其他格式化模式或修饰语（数字和小数点模式除外）组合在一起使用，并且必须位于格式化字符串的最后（例如<literal>9.99EEEE</literal>是一个合法的模式）。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
   </para>
____________________________________________________________________________-->
   <para>
    某些修饰语可以被应用到任何模板来改变其行为。例如，<literal>FM99.99</literal>是带有<literal>FM</literal>修饰语的<literal>99.99</literal>模式。<xref linkend="functions-formatting-numericmod-table"/>中展示了用于数字格式化模式修饰语。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--==========================orignal english content==========================
     <title>Template Pattern Modifiers for Numeric Formatting</title>
____________________________________________________________________________-->
     <title>用于数字格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制拖尾零和填充的空白）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>999TH</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写序数后缀</entry>
        <entry><literal>999TH</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>999th</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写序数后缀</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-examples-table"/>展示了一些使用<function>to_char</function>函数的例子。
  </para>

    <table id="functions-formatting-examples-table">
<!--==========================orignal english content==========================
     <title><function>to_char</function> Examples</title>
____________________________________________________________________________-->
     <title><function>to_char</function>例子</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Expression</entry>
        <entry>Result</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>表达式</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--==========================orignal english content==========================
   <title>Date/Time Functions and Operators</title>
____________________________________________________________________________-->
   <title>时间/日期函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-datetime-table"/>展示了可用于处理日期/时间值的函数，其细节在随后的小节中描述。<xref linkend="operators-datetime-table"/>演示了基本算术操作符 （<literal>+</literal>、<literal>*</literal>等）的行为。 而与格式化相关的函数，可以参考<xref linkend="functions-formatting"/>。你应该很熟悉<xref linkend="datatype-datetime"/>中的日期/时间数据类型的背景知识。
  </para>

<!--==========================orignal english content==========================
  <para>
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
  </para>
____________________________________________________________________________-->
  <para>
   所有下文描述的接受<type>time</type>或<type>timestamp</type>输入的函数和操作符实际上都有两种变体： 一种接收<type>time with time zone</type>或<type>timestamp with time zone</type>， 另外一种接受<type>time without time zone</type>或者 <type>timestamp without time zone</type>。为了简化，这些变种没有被独立地展示。此外，<literal>+</literal>和<literal>*</literal>操作符都是可交换的操作符对（例如，date + integer 和 integer + date）；我们只显示其中一个。
  </para>

    <table id="operators-datetime-table">
<!--==========================orignal english content==========================
     <title>Date/Time Operators</title>
____________________________________________________________________________-->
     <title>日期/时间操作符</title>

     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Add a number of days to a date
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         给日期加上天数
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a date
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         为日期添加时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add a time-of-day to a date
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在日期中添加一天中的时间
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Add intervals
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         添加时间间隔
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在时间戳中添加一个时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Add an interval to a time
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         为时间添加时间间隔
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Negate an interval
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         取否一个时间间隔
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Subtract dates, producing the number of days elapsed
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         减去日期，生成经过的天数
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Subtract a number of days from a date
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从日期中减去天数
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a date
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从日期中减去时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract times
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Subtract an interval from a time
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从时间中减去时间间隔
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从时间戳中减去时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract intervals
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间间隔
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract timestamps (converting 24-hour intervals into days,
         similarly to <function>justify_hours()</function>)
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间戳（将24小时间隔转换为天，类似于<function>justify_hours()</function>）
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Multiply an interval by a scalar
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         将时间间隔乘以数量
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Divide an interval by a scalar
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         用时间间隔除以数量
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--==========================orignal english content==========================
     <title>Date/Time Functions</title>
____________________________________________________________________________-->
     <title>日期/时间函数</title>
     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Function
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         函数
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract arguments, producing a <quote>symbolic</quote> result that
         uses years and months, rather than just days
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去参数，生成一个使用年和月，而不是只用日的<quote>符号化</quote>的结果
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract argument from <function>current_date</function> (at midnight)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从 <function>current_date</function> 减去参数(在午夜)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间（在语句执行期间变化）；参见<xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Current date; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         当前日期；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get timestamp subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间戳字段 （等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get interval subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间间隔子字段（等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Truncate to specified precision in the specified time zone; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         在规定的时区中截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get timestamp subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间戳子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get interval subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间间隔子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite date (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限日期（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite timestamp (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间戳（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite interval (currently always true)
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间间隔 （当前总是为真）
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval so 30-day time periods are represented as months
        </para>
        <para>
         <literal>justify_days(interval '35 days')</literal>
         <returnvalue>1 mon 5 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         调整间隔，使得30天时间周期表示为月
        </para>
        <para>
         <literal>justify_days(interval '35 days')</literal>
         <returnvalue>1 mon 5 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval so 24-hour time periods are represented as days
        </para>
        <para>
         <literal>justify_hours(interval '27 hours')</literal>
         <returnvalue>1 day 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
        调整时间间隔，使得24小时时间周期表示为日
        </para>
        <para>
         <literal>justify_hours(interval '27 hours')</literal>
         <returnvalue>1 day 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval using <function>justify_days</function>
         and <function>justify_hours</function>, with additional sign
         adjustments
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         使用 <function>justify_days</function> 和 <function>justify_hours</function>调整时间间隔； 通过额外的符号调整
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中的当前时间，有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current
         transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Create date from year, month and day fields
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从年、月和日字段创建日期
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields, each of which can default to zero
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从年、月、周、日、小时、分钟和秒字段创建时间间隔，每个字段默认为0
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Create time from hour, minute and seconds fields
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从小时、分钟和秒字段创建时间
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Create timestamp from year, month, day, hour, minute and seconds fields
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从年、月、日、小时、分钟和秒字段创建时间戳
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields; if <parameter>timezone</parameter> is not
         specified, the current time zone is used
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         从年，月，日，小时，分钟和秒字段结合时区创建时间戳；如果没有指定<parameter>timezone</parameter>，则使用当前时区
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前语句的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         当前的日期和时间
         （类似 <function>clock_timestamp</function>, 但是采用 <type>text</type> 字符串）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp with time zone
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将Unix纪元转换为带时区的时间戳(从1970-01-01 00:00:00+00开的的秒)
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    除了这些函数以外，还支持 SQL 操作符<literal>OVERLAPS</literal>：
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。端点可以用一对日期、时间或者时间戳来指定；或者是用一个后面跟着一个间隔的日期、时间或时间戳来指定。当一对值被提供时，起点或终点都可以被写在前面，<literal>OVERLAPS</literal>会自动地把较早的值作为起点。每一个时间段被认为是表示半开的间隔<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>，除非<replaceable>start</replaceable>和<replaceable>end</replaceable>相等，这种情况下它表示单个时间实例。例如这表示两个只有一个共同端点的时间段不重叠。
   </para>

<!--==========================orignal english content==========================
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
</screen>

<!--==========================orignal english content==========================
  <para>
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days,
   keeping the time of day the same.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set
   to <literal>America/Denver</literal>:
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>
   This happens because an hour was skipped due to a change in daylight saving
   time at <literal>2005-04-03 02:00:00</literal> in time zone
   <literal>America/Denver</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   当把一个<type>interval</type>值添加到<type>timestamp with time zone</type>上（或从中减去）时， 天的部分会按照指定的天数增加或减少<type>timestamp with time zone</type>的日期，保持一天中相同的时间。
   对于横跨夏令时的变化（当会话的时区被设置为可识别DST的时区时），这意味着<literal>interval '1 day'</literal>并 不一定等于<literal>interval '24 hours'</literal>。
   例如，当会话的时区设置为<literal>America/Denver</literal>时：
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>  
   发生此情况是因为夏令时在<literal>America/Denver</literal>时区的<literal>2005-04-03 02:00:00</literal>的时间发生更改而跳过了一个小时。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
  </para>
____________________________________________________________________________-->
  <para>
   注意<function>age</function>返回的<literal>月数</literal>域可能有歧义，因为不同的月份有不同的天数。 <productname>PostgreSQL</productname>的方法是当计算部分月数时，采用两个日期中较早的月。例如：<literal>age('2004-06-01', '2004-04-30')</literal>使用4月份得到<literal>1 mon 1 day</literal>，而用5月分时会得到<literal>1 mon 2 days</literal>，因为5月有31天，而4月只有30天。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
  </para>
____________________________________________________________________________-->
  <para>
   日期和时间戳的减法也可能会很复杂。执行减法的一种概念上很简单的方法是，使用
   <literal>EXTRACT(EPOCH FROM ...)</literal>把每个值都转换成秒数，然后执行减法，
   这样会得到两个值之间的<emphasis>秒</emphasis>数。这种方法将会适应每个月中天数、
   时区改变和夏令时调整。使用<quote><literal>-</literal></quote>操作符的日期或时间
   戳减法会返回值之间的天数（24小时）以及时/分/秒，也会做同样的调整。
   <function>age</function>函数会返回年、月、日以及时/分/秒，执行按域的减法，然后对
   负值域进行调整。下面的查询展示了这些方法的不同。例子中的结果由
   <literal>timezone = 'US/Eastern'</literal>产生，这使得两个使用的日期之间存在着夏令
   时的变化：
  </para>

<!--==========================orignal english content==========================
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
<!--==========================orignal english content==========================
   <title><function>EXTRACT</function>, <function>date_part</function></title>
____________________________________________________________________________-->
   <title><function>EXTRACT</function>, <function>date_part</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>extract</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:

    <!-&minus; alphabetical -&minus;>
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        The century
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        For <type>timestamp</type> values, the day (of the month) field
        (1&ndash;31) ; for <type>interval</type> values, the number of days
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        The year field divided by 10
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        The day of the year (1&ndash;365/366)
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        You can convert an epoch value back to a time stamp
        with <function>to_timestamp</function>:
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        The hour field (0&ndash;23)
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
       </para>
       <para>
        This field is not available in PostgreSQL releases prior to 8.3.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        The millennium
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        The minutes field (0&ndash;59)
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        For <type>timestamp</type> values, the number of the month
        within the year (1&ndash;12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0&ndash;11)
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        The quarter of the year (1&ndash;4) that the date is in
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        The seconds field, including any fractional seconds
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        The hour component of the time zone offset
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        The minute component of the time zone offset
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
       </para>
       <para>
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <function>extract</function>函数从日期/时间值中抽取子域，例如年或者小时等。<replaceable>source</replaceable>必须是一个类型 <type>timestamp</type>、<type>time</type>或<type>interval</type>的值表达式（类型为<type>date</type>的表达式将被造型为 <type>timestamp</type>，并且因此也可以被同样使用）。<replaceable>field</replaceable>是一个标识符或者字符串，它指定从源值中抽取的域。<function>extract</function>函数返回类型为<type>double precision</type>的值。 下列值是有效的域名字∶

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        世纪
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        第一个世纪从 0001-01-01 00:00:00 AD 开始， 尽管那时候人们还不知道这是第一个世纪。这个定义适用于所有使用格里高利历法的国家。其中没有 0 世纪，我们直接从公元前 1 世纪到公元 1 世纪。
        
        如果你认为这个不合理，那么请把抱怨发给：罗马圣彼得教堂，梵蒂冈，教皇收。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，是（月份）里的日域（1&ndash;31）；对于<type>interval</type>值，是日数
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>
</screen>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        年份域除以10
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        一周中的日，从周日（<literal>0</literal>）到周六（<literal>6</literal>）
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        请注意，<function>extract</function>的一周中的日和<function>to_char(..., 'D')</function>函数不同。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        一年的第几天（1&ndash;365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        对于<type>timestamp with time zone</type>值， 是自 1970-01-01 00:00:00 UTC 以来的秒数（结果可能是负数）； 对于<type>date</type> and <type>timestamp</type>值，是自本地时间 1970-01-01 00:00:00 以来的描述；对于<type>interval</type>值，它是时间间隔的总秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>结果：</lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>结果：</lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        不能用<function>to_timestamp</function>把一个 epoch 值转换回成时间戳：
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        小时域（0&ndash;23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
        一周中的日，从周一（<literal>1</literal>）到周日（<literal>7</literal>）
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
        除了周日，这和<literal>dow</literal>相同。这符合<acronym>ISO</acronym> 8601 中一周中的日的编号。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
        日期所落在的<acronym>ISO</acronym> 8601 周编号的年（不适用于间隔）
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>结果：</lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>结果：</lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
        每一个<acronym>ISO</acronym> 8601 周编号的年都开始于包含1月4日的那一周的周一，在早的1月或迟的12月中<acronym>ISO</acronym>年可能和格里高利年不同。更多信息见<literal>week</literal>域。
       </para>
       <para>
        这个域不能用于 PostgreSQL 8.3之前的版本。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1,000,000。请注意它包括全部的秒
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        千年
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        19xx的年份在第二个千年里。第三个千年从 2001 年 1 月 1 日开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1000。请注意它包括完整的秒。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        分钟域（0&ndash;59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，它是一年里的月份数（1&ndash;12）； 对于<type>interval</type>值，它是月的数目，然后对 12 取模（0&ndash;11）
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        该天所在的该年的季度（1&ndash;4）
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        秒字段，包括任何小数秒。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        与 UTC 的时区偏移，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区（从技术上来看，<productname>PostgreSQL</productname>不使用 UTC，因为其中不处理闰秒）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        时区偏移的小时部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        时区偏移的分钟部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        该天在所在的<acronym>ISO</acronym> 8601 周编号的年份里是第几周。根据定义， 一年的第一周包含该年的 1月 4 日并且 ISO 周从星期一开始。换句话说，一年的第一个星期四在第一周。
       </para>
       <para>
        在 ISO 周编号系统中，早的 1 月的日期可能位于前一年的第五十二或者第五十三周，而迟的 12 月的日期可能位于下一年的第一周。例如， <literal>2005-01-01</literal>位于 2004 年的第五十三周，并且<literal>2006-01-01</literal>位于 2005 年的第五十二周，而<literal>2012-12-31</literal>位于 2013 年的第一周。我们推荐把<literal>isoyear</literal>域和<literal>week</literal>一起使用来得到一致的结果。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        年份域。要记住这里没有<literal>0 AD</literal>，所以从<literal>AD</literal>年里抽取<literal>BC</literal>年应该小心处理。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
   
   <note>
<!--==========================orignal english content==========================
    <para>
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
    </para>
____________________________________________________________________________-->
    <para>
     当输入值为 +/-Infinity 时，<function>extract</function>对于单调增的域（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>以及<literal>millennium</literal>）返回 +/-Infinity。对于其他域返回 NULL。<productname>PostgreSQL</productname> 9.6 之前的版本对所有输入无穷的情况都返回零。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>extract</function>函数主要的用途是做计算性处理。对于用于显示的日期/时间值格式化，参阅<xref linkend="functions-formatting"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
   </para>
____________________________________________________________________________-->
   <para>
    在传统的<productname>Ingres</productname>上建模的<function>date_part</function>函数等价于<acronym>SQL</acronym>标准函数<function>extract</function>：
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    请注意这里的<replaceable>field</replaceable>参数必须是一个串值，而不是一个名字。有效的<function>date_part</function>域名 和<function>extract</function>相同。
   </para>

<!--==========================orignal english content==========================
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>结果：</lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
<!--==========================orignal english content==========================
   <title><function>date_trunc</function></title>
____________________________________________________________________________-->
   <title><function>date_trunc</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
   </para>
____________________________________________________________________________-->
   <para>
    <function>date_trunc</function>函数在概念上和用于数字的<function>trunc</function>函数类似。
   </para>

<!--==========================orignal english content==========================
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
   </para>
____________________________________________________________________________-->
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable>是类型<type>timestamp</type>或<type>interval</type>的值表达式（类型<type>date</type>和 <type>time</type>的值都分别被自动转换成<type>timestamp</type>, <type>timestamp with time zone</type>,或者<type>interval</type>）。<replaceable>field</replaceable>选择对输入值选用什么样的精度进行截断。返回的值是<type>timestamp</type>, <type>timestamp with time zone</type>,类型或者所有小于选定的 精度的域都设置为零（或者一，对于日期和月份）的<type>interval</type>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Valid values for <replaceable>field</replaceable> are:
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>field</replaceable>的有效值是∶
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
   </para>
____________________________________________________________________________-->
   <para>
    当输入值的类型为<type>timestamp with time zone</type>时。截断是针对特定时区进行的。 例如，截断为<literal>day</literal>，产生的值是 是该区域的午夜。 默认情况下，截断是在以下方面进行的  到当前的<xref linkend="guc-timezone"/>设置，但在当前的 可以提供可选的<replaceable>time_zone</replaceable>参数。以指定不同的时区。 可以指定时区名称 <xref linkend="datatype-timezones"/>中描述的任何一种方式。
   </para>

<!--==========================orignal english content==========================
   <para>
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
   </para>
____________________________________________________________________________-->
   <para>
    当处理<type>timestamp without time zone</type> 或<type>interval</type>输入时，不能指定时区。 这些总是按表面值来处理。
   </para>

<!--==========================orignal english content==========================
   <para>
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    示例  (假设当地时区为 <literal>America/New_York</literal>):
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>

</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
<!--==========================orignal english content==========================
   <title><literal>AT TIME ZONE</literal></title>
____________________________________________________________________________-->
   <title><literal>AT TIME ZONE</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <literal>AT TIME ZONE</literal> operator converts time
    stamp <emphasis>without</emphasis> time zone to/from
    time stamp <emphasis>with</emphasis> time zone, and
    <type>time with time zone</type> values to different time
    zones. <xref linkend="functions-datetime-zoneconvert-table"/> shows its
    variants.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>AT TIME ZONE</literal>把时间戳<emphasis>without</emphasis>时区转换成时间戳<emphasis>with</emphasis>时区或者反过来，并且把<type>time with time zone</type>值转换成不同的时区。<xref linkend="functions-datetime-zoneconvert-table"/>展示了它的变体。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--==========================orignal english content==========================
     <title><literal>AT TIME ZONE</literal> Variants</title>
____________________________________________________________________________-->
     <title><literal>AT TIME ZONE</literal>变体</title>
     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>without</emphasis> time zone to
         time stamp <emphasis>with</emphasis> time zone, assuming the given
         value is in the named time zone.
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>without</emphasis>时区转换为时间戳<emphasis>with</emphasis>时区，假设给定的值在指定的时区内。
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>with</emphasis> time zone to
         time stamp <emphasis>without</emphasis> time zone, as the time would
         appear in that zone.
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>with</emphasis>时区转换为时间戳<emphasis>without</emphasis>时区，因为时间将出现在该时区中
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Converts given time <emphasis>with</emphasis> time zone to a new time
         zone.  Since no date is supplied, this uses the currently active UTC
         offset for the named destination zone.
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         将给定的时间<emphasis>with</emphasis>时区转换为新的时区。由于没有提供日期，这将使用指定目的区域的当前活动UTC偏移量。
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text value (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
    The interval case is only useful for zones that have fixed offsets from
    UTC, so it is not very common in practice.
   </para>
____________________________________________________________________________-->
   <para>
    在这些表达式里，我们需要的时区<replaceable>zone</replaceable>可以指定为文本值（例如，<literal>'America/Los_Angeles'</literal>）或者一个间隔 （例如，<literal>INTERVAL '-08:00'</literal>）。
    在文本情况下，可用的时区名字可以用<xref linkend="datatype-timezones"/>中描述的任何方式指定。
    时间区间只适用于与UTC有固定偏移量的区域，因此在实践中并不常见。
   </para>

<!--==========================orignal english content==========================
   <para>
    Examples (assuming the current <xref linkend="guc-timezone"/> setting
    is <literal>America/Los_Angeles</literal>):
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.
   </para>
____________________________________________________________________________-->
   <para>
    例子 （假设当前 <xref linkend="guc-timezone"/> 设置为 <literal>America/Los_Angeles</literal>）:
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    第一个例子给缺少时区的值加上了时区，并且显示了使用当前<varname>TimeZone</varname>设置的值。
    第二个例子把带有时区值的时间戳移动到指定的时区，并且返回不带时区的值。
    这允许存储和显示不同于当前<varname>TimeZone</varname>设置的值。第三个例子把东京时间转换成芝加哥时间。
   </para>

<!--==========================orignal english content==========================
   <para>
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
   </para>
____________________________________________________________________________-->
   <para>
    函数<literal><function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)</literal>等效于 SQL 兼容的结构<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
<!--==========================orignal english content==========================
   <title>Current Date/Time</title>
____________________________________________________________________________-->
   <title>当前日期/时间</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了许多返回当前日期和时间的函数。这些 SQL 标准的函数全部都按照当前事务的开始时刻返回值：
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
    </para>
____________________________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>和<function>CURRENT_TIMESTAMP</function>传递带有时区的值；<function>LOCALTIME</function>和<function>LOCALTIMESTAMP</function>传递的值不带时区。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
    </para>
____________________________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>和 <function>LOCALTIMESTAMP</function>可以有选择地接受一个精度参数， 该精度导致结果的秒域被园整为指定小数位。如果没有精度参数，结果将被给予所能得到的全部精度。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<screen>
SELECT CURRENT_TIME;
<lineannotation>结果: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
   </para>
____________________________________________________________________________-->
   <para>
    因为这些函数全部都按照当前事务的开始时刻返回结果，所以它们的值在事务运行的整个期间内都不改变。 我们认为这是一个特性：目的是为了允许一个事务在<quote>当前</quote>时间上有一致的概念， 这样在同一个事务里的多个修改可以保持同样的时间戳。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Other database systems might advance these values more
     frequently.
    </para>
____________________________________________________________________________-->
    <para>
     许多其它数据库系统可能会更频繁地推进这些值。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>同样也提供了返回当前语句开始时间的函数， 它们会返回函数被调用时的真实当前时间。这些非 SQL 标准的函数列表如下：
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>transaction_timestamp()</function>等价于<function>CURRENT_TIMESTAMP</function>，但是其命名清楚地反映了它的返回值。<function>statement_timestamp()</function>返回当前语句的开始时刻（更准确的说是收到 客户端最后一条命令的时间）。<function>statement_timestamp()</function>和<function>transaction_timestamp()</function>在一个事务的第一条命令期间返回值相同，但是在随后的命令中却不一定相同。 <function>clock_timestamp()</function>返回真正的当前时间，因此它的值甚至在同一条 SQL 命令中都会变化。<function>timeofday()</function>是一个有历史原因的<productname>PostgreSQL</productname>函数。和<function>clock_timestamp()</function>相似，<function>timeofday()</function>也返回真实的当前时间，但是它的结果是一个格式化的<type>text</type>串，而不是<type>timestamp with time zone</type>值。<function>now()</function>是<productname>PostgreSQL</productname>的一个传统，等效于<function>transaction_timestamp()</function>。
   </para>

<!--==========================orignal english content==========================
   <para>
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -&minus; but see tip below
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    所有日期/时间类型还接受特殊的文字值<literal>now</literal>，用于指定当前的日期和时间（重申，被解释为当前事务的开始时刻）。 因此，下面三个都返回相同的结果：
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- 但请参阅下面的提示
</programlisting>
   </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      Do not use the third form when specifying a value to be evaluated later,
      for example in a <literal>DEFAULT</literal> clause for a table column.
      The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
      (See also <xref linkend="datatype-datetime-special-values"/>.)
     </para>
____________________________________________________________________________-->
     <para>
      当指定以后要计算的值时，不要使用第三种形式，例如在表列的<literal>DEFAULT</literal>子句中。
      系统将在分析这个常量的时候把<literal>now</literal>转换为一个<type>timestamp</type>， 这样需要默认值时就会得到创建表的时间！而前两种形式要到实际使用缺省值的时候才被计算， 因为它们是函数调用。因此它们可以给出每次插入行的时刻。
      （参见 <xref linkend="datatype-datetime-special-values"/>。）
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--==========================orignal english content==========================
   <title>Delaying Execution</title>
____________________________________________________________________________-->
   <title>延时执行</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>delay</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>delay</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The following functions are available to delay execution of the server
    process:
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function> makes the current session's process
    sleep until the given number of seconds have
    elapsed.  Fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function to
    allow the sleep time to be specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    下面的这些函数可以用于让服务器进程延时执行：
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function>使当前会话的进程休眠，直到过去给定的秒数。可以指定几分之一秒的延迟。
	<function>pg_sleep_for</function>是一个方便的函数，允许将睡眠时间指定为时间间隔。
	<function>pg_sleep_until</function>是一个方便的函数，用于需要特定的唤醒时间。例如：

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
     <para>
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
     </para>
____________________________________________________________________________-->
     <para>
      有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用值。休眠延迟将至少持续指
      定的时长， 也有可能由于服务器负荷而比指定的时间长。特别地，
      <function>pg_sleep_until</function>并不保证能刚好在指定的时刻被唤醒，但它不会
      在比指定时刻早的时候醒来。
     </para>
   </note>

   <warning>
<!--==========================orignal english content==========================
     <para>
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
     </para>
____________________________________________________________________________-->
     <para>
      请确保在调用<function>pg_sleep</function>或者其变体时，你的会话没有持有不必要
      的锁。否则其它会话可能必须等待你的休眠会话，因而减慢整个系统速度。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--==========================orignal english content==========================
  <title>Enum Support Functions</title>
____________________________________________________________________________-->
  <title>枚举支持函数</title>

<!--==========================orignal english content==========================
  <para>
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>
____________________________________________________________________________-->
  <para>
   对于枚举类型(在<xref linkend="datatype-enum"/>中描述）， 有一些函数允许更清洁的编码，而不需要为一个枚举类型硬写特定的值。它们被列在<xref linkend="functions-enum-table"/>中。本例假定一个枚举类型被创建为：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--==========================orignal english content==========================
    <title>Enum Support Functions</title>
____________________________________________________________________________-->
    <title>枚举支持函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the first value of the input enum type.
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的第一个值。
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the last value of the input enum type.
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的最后一个值。
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns all values of the input enum type in an ordered array.
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将输入枚举类型的所有值作为一个有序的数组返回。
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 
        如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as used in the examples.
   </para>
____________________________________________________________________________-->
   <para>
    请注意，除了双参数形式的<function>enum_range</function>外， 这些函数忽略传递给它们的具体值，它们只关心声明的数据类型。 
    空值或类型的一个特定值可以通过，并得到相同的结果。这些函数更多地被用于一个表列或函数参数，而不是一个硬写的类型名，如例子中所使用。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--==========================orignal english content==========================
  <title>Geometric Functions and Operators</title>
____________________________________________________________________________-->
  <title>几何函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    几何类型<type>point</type>、<type>box</type>、
    <type>lseg</type>、<type>line</type>、<type>path</type>、
    <type>polygon</type>和<type>circle</type>有一大堆本地支持函数和操作符，如<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>和<xref linkend="functions-geometry-conv-table"/>中所示。
   </para>

   <table id="functions-geometry-op-table">
<!--==========================orignal english content==========================
    <title>Geometric Operators</title>
____________________________________________________________________________-->
    <title>几何操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Adds the coordinates of the second <type>point</type> to those of each
        point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第二个<type>point</type>的坐标添加到第一个参数的每个点的坐标中，从而执行翻译。
        适用于 <type>point</type>、<type>box</type>、<type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Concatenates two open paths (returns NULL if either path is closed).
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        连接两个打开的路径(如果其中一个路径是关闭的，则返回NULL)。
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtracts the coordinates of the second <type>point</type> from those
        of each point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        从第一个参数的每个点的坐标中减去第二个<type>point</type>的坐标，从而执行翻译。
        适用于 <type>point</type>、 <type>box</type>、 <type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplies each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex multiplication).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin by the length
        of the vector, and rotating it counterclockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> a
        box with these operators only moves its corner points: the box is
        still considered to have sides parallel to the axes.  Hence the box's
        size is not preserved, as a true rotation would do.</para></footnote>
        <type>path</type>, <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
		将第一个参数的每个点乘上第二个point(将点视为由实部和虚部表示的复数，并执行标准的复数乘法)。
		如果将第二个<type>point</type>解释为向量，这等价于将对象的大小和到原点的距离按向量的长度缩放，并以向量与<replaceable>x</replaceable>轴的夹角绕原点逆时针旋转。
		适用于<type>point</type>, <type>box</type>,<footnote
		id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> 用这些操作符“旋转”一个盒子，只会移动它的角点:这个盒子仍然被认为有平行于轴的边。
		因此，盒子的大小并没有像真正的旋转那样得到保留。</para></footnote>
		<type>path</type>, <type>circle</type>.。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Divides each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex division).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin down by the
        length of the vector, and rotating it clockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnoteref
        linkend="functions-geometry-rotation-fn"/> <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
		将第一个参数的每个点除以第二个<type>point</type>(将点视为由实部和虚部表示的复数，并执行标准的复数除法)。
		如果将第二个<type>point</type>解释为向量，这等价于将物体的大小和到原点的距离按向量的长度向下缩放，并以向量与<replaceable>x</replaceable>轴的夹角围绕原点顺时针旋转。
		适用于 <type>point</type>, <type>box</type>,<footnoteref linkend="functions-geometry-rotation-fn"/> <type>path</type>,<type>circle</type>。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the center point.
        Available for <type>box</type>, <type>lseg</type>, <type>path</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。适用于 <type>box</type>, <type>lseg</type>, <type>path</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the point of intersection, or NULL if there is none.
        Available for <type>lseg</type>, <type>line</type>.
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算交点，如果没有则为NULL。适用于 <type>lseg</type>, <type>line</type>。
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes the intersection of two boxes, or NULL if there is none.
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的交集，如果没有则为NULL。
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the closest point to the first object on the second object.
        Available for these pairs of types:
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算第二个对象上离第一个对象最近的点。适用于这些类型对：
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the distance between the objects.
        Available for all seven geometric types, for all combinations
        of <type>point</type> with another geometric type, and for
        these additional pairs of types:
        (<type>box</type>, <type>lseg</type>),
        (<type>box</type>, <type>line</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (and the commutator cases).
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算对象之间的距离。适用于所有七种几何类型，适用于<type>point</type>与另一种几何类型的所有组合，以及这些额外的类型对:
        (<type>box</type>, <type>lseg</type>),
        (<type>box</type>, <type>line</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (以及易子情况下).
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object contain second?
        Available for these pairs of types:
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含第二个对象吗? 适用于这些类型对：
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object contained in or on second?
        Available for these pairs of types:
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含在第二个对象之中还是在第二个对象之上? 适用于这些类型对：
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects overlap?  (One point in common makes this true.)
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象有重叠吗?(一个共同点使之为真。)
        适用于 <type>box</type>、<type>polygon</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly left of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的左边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly right of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的右边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the right of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的右侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the left of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的左侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象下面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象上面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象上面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象下面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object below second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象下面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&lt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly below second?
        (This operator is misnamed; it should be <literal>&lt;&lt;|</literal>.)
       </para>
       <para>
        <literal>point '(1,0)' &lt;^ point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&lt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象下面？
        (这个操作符命名错误; 它应该是 <literal>&lt;&lt;|</literal>.)
       </para>
       <para>
        <literal>point '(1,0)' &lt;^ point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object above second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象上面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&gt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly above second?
        (This operator is misnamed; it should be <literal>|&gt;&gt;</literal>.)
       </para>
       <para>
        <literal>point '(1,1)' &gt;^ point '(1,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&gt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象上面？
        (这个操作符命名错误; 它应该是 <literal>|&gt;&gt;</literal>.)
       </para>
       <para>
        <literal>point '(1,1)' &gt;^ point '(1,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects intersect?
        Available for these pairs of types:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是否相交? 适用于这些类型对:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line horizontal?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是水平的?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points horizontally aligned (that is, have same y coordinate)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否水平对齐(即具有相同的y坐标)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line vertical?
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是纵向的的？
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points vertically aligned (that is, have same x coordinate)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否垂直对齐(即具有相同的x坐标)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines perpendicular?
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是垂直的？
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines parallel?
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是平行的？
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are these objects the same?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是相同的吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <caution>
<!--==========================orignal english content==========================
    <para>
     Note that the <quote>same as</quote> operator, <literal>~=</literal>,
     represents the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of the geometric types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares for equal <emphasis>areas</emphasis> only.
     The other scalar comparison operators (<literal>&lt;=</literal> and so
     on), where available for these types, likewise compare areas.
    </para>
____________________________________________________________________________-->
    <para>
     请注意<quote>same as</quote>操作符（<literal>~=</literal>），表示<type>point</type>、<type>box</type>、<type>polygon</type>和<type>circle</type>类型的一般相等概念。
     这些类型中的某些还有一个<literal>=</literal>操作符，但是<literal>=</literal>只比较相同的<emphasis>面积</emphasis>。
     其它的标量比较操作符 （<literal>&lt;=</literal>等等），在这些类型可用的地方，同样比较区域。
    </para>
   </caution>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively
     called <literal>~</literal> and <literal>@</literal>.  These names are still
     available, but are deprecated and will eventually be removed.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>之前，包含操作符<literal>@&gt;</literal>和<literal>&lt;@</literal>被分别称为<literal>~</literal>和<literal>@</literal>。 这些名字仍然可以使用，但是已被废除并且最终将被移除。
    </para>
   </note>

   <table id="functions-geometry-func-table">
<!--==========================orignal english content==========================
    <title>Geometric Functions</title>
____________________________________________________________________________-->
    <title>几何函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes area.
        Available for <type>box</type>, <type>path</type>, <type>circle</type>.
        A <type>path</type> input must be closed, else NULL is returned.
        Also, if the <type>path</type> is self-intersecting, the result may be
        meaningless.
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算面积。适用于 <type>box</type>, <type>path</type>, <type>circle</type>。
        <type>path</type> 输入必须封闭，否则返回NULL。同样，如果 <type>path</type> 是自交叉的，结果可能是没有意义的。
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center point.
        Available for <type>box</type>, <type>circle</type>.
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。适用于 <type>box</type>, <type>circle</type>。
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment
        (same as <function>lseg(box)</function>).
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        提取框的对角线作为线段（与 <function>lseg(box)</function>相同）。
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes diameter of circle.
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的直径。
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes vertical size of box.
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的垂直尺寸。
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path closed?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否封闭?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path open?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否开放?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>。
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to closed form.
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为封闭形式。
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to open form.
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为开放形式。
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes radius of circle.
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的半径。
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes slope of a line drawn through the two points.
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算通过两点所画直线的斜率。
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes horizontal size of box.
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的水平大小。
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--==========================orignal english content==========================
    <title>Geometric Type Conversion Functions</title>
____________________________________________________________________________-->
    <title>几何类型转换函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>
     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes box inscribed within the circle.
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算框中内刻的圆形。
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts point to empty box.
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将点转换为空框。
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts any two corner points to box.
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将任意两个角点转换为框。
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of polygon.
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算多边形的边界框。
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of two boxes.
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的边界框。
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Computes smallest circle enclosing box.
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        计算最小的圆形包围框。
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Constructs circle from center and radius.
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        从圆心和半径构造圆。
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Converts polygon to circle.  The circle's center is the mean of the
        positions of the polygon's points, and the radius is the average
        distance of the polygon's points from that center.
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        将多边形转换为圆。圆心是多边形各点位置的平均值，半径是多边形各点到圆心的平均距离。
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        Converts two points to the line through them.
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        将两个点转换成通过它们的直线。
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment.
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
       提取框的对角线作为线段。
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Constructs line segment from two endpoints.
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        从两个端点构造线段。
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts polygon to a closed path with the same list of points.
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将多边形转换为具有点的相同列表的封闭路径。
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Constructs point from its coordinates.
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        从它的坐标构造点。
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of box.
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算框的中心。
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of circle.
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算圆心。
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of line segment.
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算线段的中心。
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of polygon (the mean of the
        positions of the polygon's points).
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算多边形的中心（多边形的点位置的平均值）。
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts box to a 4-point polygon.
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将框转换为4点多边形。
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to a 12-point polygon.
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为12点多边形。
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to an <replaceable>n</replaceable>-point polygon.
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为<replaceable>n</replaceable>点多边形。
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts closed path to a polygon with the same list of points.
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将封闭路径转换为具有点的相同列表的多边形。
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
    <para>
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
    </para>
____________________________________________________________________________-->
    <para>
     我们可以把一个<type>point</type>的两个组成数字当作具有索引 0 和 1 的数组访问。例如，如果<literal>t.p</literal>是一个<type>point</type>列，那么<literal>SELECT p[0] FROM t</literal>检索 X 座标而 <literal>UPDATE t SET p[1] = ...</literal>改变 Y 座标。同样，<type>box</type>或者<type>lseg</type>类型的值可以当作两个<type>point</type>值的数组值看待。
    </para>

  </sect1>

 <sect1 id="functions-net">
<!--==========================orignal english content==========================
  <title>Network Address Functions and Operators</title>
____________________________________________________________________________-->
  <title>网络地址函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   The IP network address types, <type>cidr</type> and <type>inet</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized operators and functions shown in
   <xref linkend="cidr-inet-operators-table"/> and
   <xref linkend="cidr-inet-functions-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   IP网络地址类型，<type>cidr</type>和<type>inet</type>，支持<xref linkend="functions-comparison-op-table"/>所示的常用比较操作符，
   以及<xref linkend="cidr-inet-operators-table"/> 和 <xref linkend="cidr-inet-functions-table"/>所示的专用操作符和函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly;
   therefore, the operators and functions shown below as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is
   because the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value
   to <type>cidr</type>.  When this is done, any bits to the right of the
   netmask are silently zeroed to create a valid <type>cidr</type> value.
  </para>
____________________________________________________________________________-->
  <para>
   任何<type>cidr</type> 值都可以隐式地转换到<type>inet</type>；因此，下面在<type>inet</type>上操作的操作符和函数也可以在<type>cidr</type>值上工作。
   (对于<type>inet</type>和<type>cidr</type>有单独的函数，这是因为这两种情况的行为应该是不同的。)
   此外，它允许将<type>inet</type>值转换为<type>cidr</type>。
   当这样做的时候，子网掩码右边的任何位都被静默地置零，以创建一个有效的<type>cidr</type>值。
  </para>

   <table id="cidr-inet-operators-table">
<!--==========================orignal english content==========================
    <title>IP Address Operators</title>
____________________________________________________________________________-->
    <title>IP地址操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet strictly contained by subnet?
        This operator, and the next four, test for subnet inclusion.  They
        consider only the network parts of the two addresses (ignoring any
        bits to the right of the netmasks) and determine whether one network
        is identical to or a subnet of the other.
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含在子网中?这个操作符和后续的四个操作符测试子网包含情况。
        它们只考虑两个地址的网络部分(忽略网络掩码右侧的任何位)，并确定一个网络与另一个网络相同或者是相同的子网。
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet contained by or equal to subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet strictly contain subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet contain or equal subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does either subnet contain or equal the other?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        其中一个子网包含或等于另一个子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Subtracts an offset from an address.
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        从地址中减去偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the difference of two addresses.
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算两个地址的差值。
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="cidr-inet-functions-table">
<!--==========================orignal english content==========================
    <title>IP Address Functions</title>
____________________________________________________________________________-->
    <title>IP地址的函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The result is the same as the <type>inet</type> output function
        produces; it is <quote>abbreviated</quote> only in comparison to the
        result of an explicit cast to <type>text</type>, which for historical
        reasons will never suppress the netmask part.)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩略的文本显示格式。
        (结果与<type>inet</type>输出函数产生的结果相同;它只是在与显式转换为<type>text</type>的结果比较时才被<quote>abbreviated</quote>，
        由于历史原因，它永远不会抑制子网掩码部分。)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The abbreviation consists of dropping all-zero octets to the right
        of the netmask; more examples are in
        <xref linkend="datatype-net-cidr-table"/>.)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩写的文本显示格式。(缩写包括在子网掩码的右侧删除所有零字节;更多的例子请见 <xref linkend="datatype-net-cidr-table"/>。)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the broadcast address for the address's network.
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算广播地址。
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the address's family: <literal>4</literal> for IPv4,
        <literal>6</literal> for IPv6.
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回地址的系列: <literal>4</literal> 对应 IPv4, <literal>6</literal> 对应 IPv6。
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the IP address as text, ignoring the netmask.
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回IP地址文本，忽略子网掩码。
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the host mask for the address's network.
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算主机掩码。
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Computes the smallest network that includes both of the given networks.
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        计算包含两个给定网络的最小网络。
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the addresses belong to the same IP family.
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试地址是否属于同一IP族。
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the netmask length in bits.
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        以比特位返回子网掩码长度。
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the network mask for the address's network.
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算网络掩码。
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Returns the network part of the address, zeroing out
        whatever is to the right of the netmask.
        (This is equivalent to casting the value to <type>cidr</type>.)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        返回地址的网络部分，将子网掩码右边的部分归零。(这相当于将值转换为<type>cidr</type>。)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Sets the netmask length for an <type>inet</type> value.
        The address part does not change.
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        设置<type>inet</type>值的子网掩码长度。地址部分不改变。
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Sets the netmask length for a <type>cidr</type> value.
        Address bits to the right of the new netmask are set to zero.
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        设置<type>cidr</type>值的子网掩码长度。新子网掩码右侧的地址位设置为零。
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the unabbreviated IP address and netmask length as text.
        (This has the same result as an explicit cast to <type>text</type>.)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本形式返回未缩写的IP地址和子网掩码长度。(这与显式转换为<type>text</type>的结果相同。)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <tip>
<!--==========================orignal english content==========================
   <para>
    The <function>abbrev</function>, <function>host</function>,
    and <function>text</function> functions are primarily intended to offer
    alternative display formats for IP addresses.
   </para>
____________________________________________________________________________-->
   <para>
    <function>abbrev</function>、<function>host</function>和<function>text</function>函数主要用于为IP地址提供另一种显示格式。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   The MAC address types, <type>macaddr</type> and <type>macaddr8</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized functions shown in
   <xref linkend="macaddr-functions-table"/>.
   In addition, they support the bitwise logical operators
   <literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>
   (NOT, AND and OR), just as shown above for IP addresses.
  </para>
____________________________________________________________________________-->
  <para>
   MAC地址类型， <type>macaddr</type> 和<type>macaddr8</type>，支持<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符以及<xref linkend="macaddr-functions-table"/>中所示的特殊函数。
   此外，它们支持位元逻辑操作符<literal>~</literal>, <literal>&amp;</literal> 和 <literal>|</literal> (NOT, AND 和 OR)，就像上面对IP地址所示的那样。
  </para>

   <table id="macaddr-functions-table">
<!--==========================orignal english content==========================
    <title>MAC Address Functions</title>
____________________________________________________________________________-->
    <title>MAC 地址函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        Sets the last 3 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        将地址的最后3个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the last 5 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的最后5个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the 7th bit of the address to one, creating what is known as
        modified EUI-64, for inclusion in an IPv6 address.
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的第7位设置为1，创建所谓的modified EUI-64，用于包含在IPv6地址中。
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


 <sect1 id="functions-textsearch">
<!--==========================orignal english content==========================
  <title>Text Search Functions and Operators</title>
____________________________________________________________________________-->
  <title>文本搜索函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   总结了为全文搜索提供的函数和操作符。<productname>PostgreSQL</productname>的文本搜索功能的详细解释可参考<xref linkend="textsearch"/>。
  </para>

   <table id="textsearch-operators-table">
<!--==========================orignal english content==========================
    <title>Text Search Operators</title>
____________________________________________________________________________-->
    <title>文本搜索操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>tsvector</type> match <type>tsquery</type>?
        (The arguments can be given in either order.)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>tsvector</type>匹配<type>tsquery</type>吗?(参数可以按任意顺序给出。)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does text string, after implicit invocation
        of <function>to_tsvector()</function>, match <type>tsquery</type>?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        隐式调用<function>to_tsvector()</function>后的文本字符串匹配<type>tsquery</type>么 ?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is a deprecated synonym for <literal>@@</literal>.
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这是<literal>@@</literal>已弃用的同义词。
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Concatenates two <type>tsvector</type>s.  If both inputs contain
        lexeme positions, the second input's positions are adjusted
        accordingly.
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        连接两个<type>tsvector</type>。如果两个输入都包含词素位置，则相应地调整第二个输入的位置。
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs two <type>tsquery</type>s together, producing a query that
        matches documents that match both input queries.
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs two <type>tsquery</type>s together, producing a query that
        matches documents that match either input query.
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Negates a <type>tsquery</type>, producing a query that matches
        documents that do not match the input query.
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        否定<type>tsquery</type>，生成一个与输入查询不匹配的匹配文档的查询。
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query, which matches if the two input queries
        match at successive lexemes.
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，如果两个输入查询在连续的词素上匹配，该查询将进行匹配。
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first <type>tsquery</type> contain the second?  (This considers
        only whether all the lexemes appearing in one query appear in the
        other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含了第二个吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first <type>tsquery</type> contained in the second?  (This
        considers only whether all the lexemes appearing in one query appear
        in the other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含在第二个中吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，而忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
    <para>
     In addition to these specialized operators, the usual comparison
     operators shown in <xref linkend="functions-comparison-op-table"/> are
     available for types <type>tsvector</type> and <type>tsquery</type>.
     These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
    </para>
____________________________________________________________________________-->
    <para>
	 除了这些专用操作符之外， <xref linkend="functions-comparison-op-table"/> 中所示的常用比较操作符也适用于<type>tsvector</type>和<type>tsquery</type>类型。
	 它们对于文本搜索不是很有用，但是允许使用。例如，建在这些类型列上的唯一索引。
    </para>

   <table id="textsearch-functions-table">
<!--==========================orignal english content==========================
    <title>Text Search Functions</title>
____________________________________________________________________________-->
    <title>文本搜索函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts an array of lexemes to a <type>tsvector</type>.
        The given strings are used as-is without further processing.
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将词素数组转换为<type>tsvector</type>。给定的字符串按原样使用，不做进一步处理。
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        Returns the OID of the current default text search configuration
        (as set by <xref linkend="guc-default-text-search-config"/>).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        返回当前默认文本搜索配置的OID(由 <xref linkend="guc-default-text-search-config"/> 所设定的).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes in the <type>tsvector</type>.
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsvector</type>中的词位数。
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes plus operators in
        the <type>tsquery</type>.
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsquery</type>中词位和操作符的数目。
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches documents containing all non-stopwords in the text.
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
		将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
		字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配文本中包含所有非停止词的文档。
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches phrases containing all non-stopwords in the text.
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
		字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配包含文本中所有非停止词的短语。
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according
        to the specified or default configuration.  Quoted word sequences are
        converted to phrase tests.  The word <quote>or</quote> is understood
        as producing an OR operator, and a dash produces a NOT operator;
        other punctuation is ignored.
        This approximates the behavior of some common web search tools.
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
		将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。引用的单词序列被转换为短语测试。
		<quote>or</quote>一词被理解为产生OR操作符，而破折号产生NOT操作符;其他标点符号被忽略。这类似于一些常见的网络搜索工具的行为。
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Produces a representation of the indexable portion of
        a <type>tsquery</type>.  A result that is empty or
        just <literal>T</literal> indicates a non-indexable query.
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
		生成<type>tsquery</type>的可转位部分的表示。结果为空或仅为<literal>T</literal>表示不可索引查询。
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to each element
        of the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将指定的<parameter>weight</parameter>赋给<parameter>vector</parameter>的每个元素。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to elements
        of the <parameter>vector</parameter> that are listed
        in <parameter>lexemes</parameter>.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将指定的<parameter>weight</parameter>赋给列在<parameter>lexemes</parameter>中的<parameter>vector</parameter>元素。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes positions and weights from the <type>tsvector</type>.
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<type>tsvector</type>中移除位置和权重。
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  The words must be combined
        by valid <type>tsquery</type> operators.
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。单词必须由有效的<type>tsquery</type>操作符组合。
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsvector</type>, normalizing words according
        to the specified or default configuration.  Position information is
        included in the result.
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。结果中包含位置信息。
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts each string value in the JSON document to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of string
        values.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>; observe the difference in the examples.)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
		将JSON文档中的每个字符串值转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
		然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对字符串值之间存在一个停止词一样生成。
		(注意，当输入为<type>jsonb</type>时，JSON对象的字段的<quote>document order</quote>取决于实现;请观察这些例子中的差异。)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects each item in the JSON document that is requested by
        the <parameter>filter</parameter> and converts each one to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of selected
        items.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>.)
        The <parameter>filter</parameter> must be a <type>jsonb</type>
        array containing zero or more of these keywords:
        <literal>"string"</literal> (to include all string values),
        <literal>"numeric"</literal> (to include all numeric values),
        <literal>"boolean"</literal> (to include all boolean values),
        <literal>"key"</literal> (to include all keys), or
        <literal>"all"</literal> (to include all the above).
        As a special case, the <parameter>filter</parameter> can also be a
        simple JSON value that is one of these keywords.
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        选择<parameter>filter</parameter>请求的JSON文档中的每个项，并将每个项转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
        然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对选定的项目之间存在一个停止词一样生成。
        (注意，当输入为<type>jsonb</type>时，JSON对象字段的<quote>document order</quote>取决于实现。)
        <parameter>filter</parameter>必须是一个<type>jsonb</type>数组，其中包含0个或多个关键字:
        <literal>"string"</literal>(包括所有字符串值)，
        <literal>"numeric"</literal>(包括所有数值)，
        <literal>"boolean"</literal>(包括所有布尔值)，
        <literal>"key"</literal>(包括所有键)，或
        <literal>"all"</literal>(包括以上所有关键字)。
        作为一种特殊情况，该<parameter>filter</parameter>也可以是这些关键字之一的简单JSON值。
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrence of the given <parameter>lexeme</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<parameter>vector</parameter>中删除任何出现的给定<parameter>lexeme</parameter>。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrences of the lexemes
        in <parameter>lexemes</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
		从<parameter>vector</parameter>中删除<parameter>lexemes</parameter>中出现的任何词位。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects only elements with the given <parameter>weights</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        只从<parameter>vector</parameter>中选择具有给定<parameter>weights</parameter>的元素。
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, the match(es) for
        the <parameter>query</parameter> in
        the <parameter>document</parameter>, which must be raw text not
        a <type>tsvector</type>.  Words in the document are normalized
        according to the specified or default configuration before matching to
        the query.  Use of this function is discussed in
        <xref linkend="textsearch-headline"/>, which also describes the
        available <parameter>options</parameter>.
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示<parameter>document</parameter>中<parameter>query</parameter>的匹配项，该匹配项必须是原始文本，而不是<type>tsvector</type>。
        在匹配查询之前，文档中的单词将根据指定的或默认的配置进行规范化。
        <xref linkend="textsearch-headline"/>中讨论了该函数的使用，还描述了可用的<parameter>options</parameter>。
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, match(es) for
        the <parameter>query</parameter> that occur in string values
        within the JSON <parameter>document</parameter>.
        See <xref linkend="textsearch-headline"/> for more details.
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示匹配JSON<parameter>document</parameter>中字符串值中的<parameter>query</parameter>。
        更多细节请参阅 <xref linkend="textsearch-headline"/>。
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>.  See
        <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。详情请参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>, using a cover density
        algorithm.  See <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
		使用覆盖密度算法计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。
		详情参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces occurrences of <parameter>target</parameter>
        with <parameter>substitute</parameter>
        within the <parameter>query</parameter>.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        在<parameter>query</parameter>中使用 <parameter>substitute</parameter>替换出现的<parameter>target</parameter>。
        详情参见 <xref linkend="textsearch-query-rewriting"/> 。
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces portions of the <parameter>query</parameter> according to
        target(s) and substitute(s) obtained by executing
        a <command>SELECT</command> command.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        根据目标替换部分<parameter>query</parameter>，并替换通过执行<command>SELECT</command>命令获得的查询。
        详情参见<xref linkend="textsearch-query-rewriting"/>。
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter>
        and <parameter>query2</parameter> at successive lexemes (same
        as <literal>&lt;-&gt;</literal> operator).
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，在连续的词位上搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项(与<literal>&lt;-&gt;</literal>操作符相同)。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter> and
        <parameter>query2</parameter> that occur exactly
        <parameter>distance</parameter> lexemes apart.
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，用于搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项，这些匹配项恰好出现在<parameter>distance</parameter>词位之间。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Converts a <type>tsvector</type> to an array of lexemes.
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<type>tsvector</type>转换为词位的数组。
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        Expands a <type>tsvector</type> into a set of rows, one per lexeme.
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        将<type>tsvector</type>展开为一组行，每个行对应一个词位。
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
   </para>
____________________________________________________________________________-->
   <para>
	所有接受一个可选的<type>regconfig</type>参数的文本搜索函数在该参数被忽略时，使用由<xref linkend="guc-default-text-search-config"/>指定的配置。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are primarily helpful for development and
   debugging of new text search configurations.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="textsearch-functions-debug-table"/>中的函数被单独列出，因为它们通常不被用于日常的文本搜索操作。 
   它们主要有助于开发和调试新的文本搜索配置。
  </para>

   <table id="textsearch-functions-debug-table">
<!--==========================orignal english content==========================
    <title>Text Search Debugging Functions</title>
____________________________________________________________________________-->
    <title>文本搜索调试函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
        Extracts and normalizes tokens from
        the <parameter>document</parameter> according to the specified or
        default text search configuration, and returns information about how
        each token was processed.
        See <xref linkend="textsearch-configuration-testing"/> for details.
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
		根据指定的或默认的文本搜索配置从<parameter>document</parameter中提取和标准化标记，并返回关于每个标记是如何处理的信息。
		详请参见<xref linkend="textsearch-configuration-testing"/>。
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns an array of replacement lexemes if the input token is known to
        the dictionary, or an empty array if the token is known to the
        dictionary but it is a stop word, or NULL if it is not a known word.
        See <xref linkend="textsearch-dictionary-testing"/> for details.
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
		如果字典知道输入标记，则返回替换词位数组;如果字典知道标记，但它是停止词，则返回空数组;如果它不是已知词，则返回NULL。
		详情参见<xref linkend="textsearch-dictionary-testing"/>。
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using the
        named parser.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用命名的解析器从<parameter>document</parameter>中提取标记。详情参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using a
        parser specified by OID.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用OID指定的解析器从<parameter>document</parameter>中提取标记。
        详请参见 <xref linkend="textsearch-parser-testing"/> 。
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token the named parser can
        recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述命名解析器可以识别的每种类型的标记。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token a parser specified
        by OID can recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述OID指定的解析器可以识别的每种标记类型。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
        Executes the <parameter>sqlquery</parameter>, which must return a
        single <type>tsvector</type> column, and returns statistics about each
        distinct lexeme contained in the data.
        See <xref linkend="textsearch-statistics"/> for details.
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
		执行<parameter>sqlquery</parameter>，该查询必须返回单个<type>tsvector</type>列，并返回关于数据中包含的每个不同词位的统计信息。
		详请参见<xref linkend="textsearch-statistics"/>。
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

 </sect1>

 <sect1 id="functions-uuid">
<!--==========================orignal english content==========================
  <title>UUID Functions</title>
____________________________________________________________________________-->
  <title>UUID 函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>generating</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>生成</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> includes one function to generate a UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   This function returns a version 4 (random) UUID.  This is the most commonly
   used type of UUID and is appropriate for most applications.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> 包含一个函数来生成UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   此函数返回一个版本4(随机)的UUID。这是最常用的UUID类型，适用于大多数应用程序。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <xref linkend="uuid-ossp"/> module provides additional functions that
   implement other standard algorithms for generating UUIDs.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="uuid-ossp"/>模块提供了额外的功能，用于实现生成UUIDs的其他标准算法。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> also provides the usual comparison
   operators shown in <xref linkend="functions-comparison-op-table"/> for
   UUIDs.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>还为UUIDs提供了<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符。
  </para>
 </sect1>

 <sect1 id="functions-xml">
<!--==========================orignal english content==========================
  <title>XML Functions</title>
____________________________________________________________________________-->
  <title>XML 函数</title>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>XML 函数</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <para>
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
  </para>
____________________________________________________________________________-->
  <para>
   本节中描述的函数以及类函数的表达式都在类型<type>xml</type>的值上操作。类型<type>xml</type>的详细信息请参见<xref linkend="datatype-xml"/>。用于在值和类型<type>xml</type>之间转换的类函数的表达式<function>xmlparse</function>和<function>xmlserialize</function>记录在这里，而不是在本节中。
</para>

<!--==========================orignal english content==========================
  <para>
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure -&minus;with-libxml</command>.
  </para>
____________________________________________________________________________-->
  <para>
         使用大部分这些函数要求<productname>PostgreSQL</productname>使用了<command>configure --with-libxml</command>进行编译。
  </para>

  <sect2 id="functions-producing-xml">
<!--==========================orignal english content==========================
   <title>Producing XML Content</title>
____________________________________________________________________________-->
   <title>产生 XML 内容</title>

<!--==========================orignal english content==========================
   <para>
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
   </para>
____________________________________________________________________________-->
   <para>
    有一组函数和类函数的表达式可以用来从 SQL 数据产生 XML 内容。它们特别适合于将查询结果格式化成 XML 文档以便于在客户端应用中处理。
   </para>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlcomment</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlcomment</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>-&minus;</literal></quote> or end with a
     <quote><literal>-</literal></quote>, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlcomment</function>创建了一个 XML 值，它包含一个使用指定文本作为内容的 XML 注释。
     该文本不包含<quote><literal>--</literal></quote>或者也不会以一个<quote><literal>-</literal></quote>结尾，否则该结果的结构不是一个合法的 XML 注释。如果参数为空，结果也为空。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <!-&minus;hello-&minus;>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlconcat</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlconcat</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlconcat</function>将由单个 XML 值组成的列表串接成一个单独的值，这个值包含一个 XML 内容片断。空值会被忽略，只有当没有参数为非空时结果才为空。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <abc/><bar>foo</bar>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
    </para>
____________________________________________________________________________-->
    <para>
     如果 XML 声明存在，它们会按照下面的方式被组合。如果所有的参数值都有相同的 XML 版本声明，该版本将被用在结果中，否则将不使用版本。如果所有参数值有独立声明值<quote>yes</quote>，那么该值将被用在结果中。如果所有参数值都有一个独立声明值并且至少有一个为<quote>no</quote>，则<quote>no</quote>被用在结果中。否则结果中将没有独立声明。如果结果被决定要要求一个独立声明但是没有版本声明，将会使用一个版本 1.0 的版本声明，因为 XML 要求一个 XML 声明要包含一个版本声明。编码声明会被忽略并且在所有情况中都会被移除。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlelement</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlelement</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
     The <replaceable>name</replaceable>
     and <replaceable>attname</replaceable> items shown in the syntax are
     simple identifiers, not values.  The <replaceable>attvalue</replaceable>
     and <replaceable>content</replaceable> items are expressions, which can
     yield any <productname>PostgreSQL</productname> data type.  The
     argument(s) within <literal>XMLATTRIBUTES</literal> generate attributes
     of the XML element; the <replaceable>content</replaceable> value(s) are
     concatenated to form its content.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlelement</function>使用给定名称、属性和内容产生一个 XML 元素。
     语法中显示的<replaceable>name</replaceable>和<replaceable>attname</replaceable>项是简单的标识符，而不是值。
     <replaceable>attvalue</replaceable>和<replaceable>content</replaceable>项是表达式，它们可以生成任何<productname>PostgreSQL</productname>数据类型。
     <literal>XMLATTRIBUTES</literal>的参数生成XML元素的属性；将<replaceable>content</replaceable>值连接起来形成其内容。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     不是合法 XML 名字的元素名和属性名将被逃逸，逃逸的方法是将违反的字符用序列<literal>_x<replaceable>HHHH</replaceable>_</literal>替换，其中<replaceable>HHHH</replaceable>是被替换字符的 Unicode 代码点的十六进制表示。例如：
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     But these are not:
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     如果属性值是一个列引用，则不需要指定一个显式的属性名，在这种情况下列的名字将被默认用于属性的名字。在其他情况下，属性必须被给定一个显式名称。因此这个例子是合法的：
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     但是下面这些不合法：
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"><abc/><!-&minus;test-&minus;><xyz/></foo>
]]></screen>

     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
____________________________________________________________________________-->
    <para>
     如果指定了元素内容，它们将被根据其数据类型格式化。如果内容本身也是类型<type>xml</type>，就可以构建复杂的 XML 文档。例如：
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

     其他类型的内容将被格式化为合法的 XML 字符数据。这意味着字符 &lt;, &gt;, 和 &amp; 将被转换为实体。二进制数据（数据类型<type>bytea</type>）将被表示成 base64 或十六进制编码，具体取决于配置参数<xref linkend="guc-xmlbinary"/>的设置。为了使PostgreSQL的映射与SQL:2006及以后的SQL:2006中指定的映射保持一致，个别数据类型的特殊行为将不断发展，正如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlforest</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlforest</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for <function>xmlelement</function>,
     each <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expressions can have any data
     type.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlforest</function>使用给定名称和内容产生一个元素的 XML 森林（序列）。
     对于<function>xmlelement</function>，每个<replaceable>name</replaceable>都必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------&zwsp;-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     如我们在第二个例子中所见，如果内容值是一个列引用，元素名称可以被忽略，这种情况下默认使用列名。否则，必须指定一个名字。
    </para>

<!--==========================orignal english content==========================
    <para>
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
    </para>
____________________________________________________________________________-->
    <para>
     如上文<function>xmlelement</function>所示，非法 XML 名字的元素名会被逃逸。相似地，内容数据也会被逃逸来产生合法的 XML 内容，除非它已经是一个<type>xml</type>类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意如果 XML 森林由多于一个元素组成，那么它不是合法的 XML 文档，因此在<function>xmlelement</function>中包装<function>xmlforest</function>表达式会有用处。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlpi</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlpi</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlpi</function> expression creates an XML
     processing instruction.
     As for <function>xmlelement</function>,
     the <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expression can have any data type.
     The <replaceable>content</replaceable>, if present, must not contain the
     character sequence <literal>?&gt;</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlpi</function>创建一个 XML 处理指令。
     对于<function>xmlelement</function>，<replaceable>name</replaceable>必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。如果存在，<replaceable>content</replaceable>不能包含字符序列<literal>?&gt;</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?php echo "hello world";?>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlroot</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlroot</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlroot</function>修改一个 XML 值的根结点的属性。如果指定了一个版本，它会替换根节点的版本声明中的值；如果指定了一个独立设置，它会替换根节点的独立声明中的值。
    </para>

<!--==========================orignal english content==========================
    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
<!--==========================orignal english content==========================
    <title><literal>xmlagg</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlagg</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
    </para>
____________________________________________________________________________-->
    <para>
     和这里描述的其他函数不同，函数<function>xmlagg</function>是一个聚集函数。它将聚集函数调用的输入值串接起来，非常像<function>xmlconcat</function>所做的事情，除了串接是跨行发生的而不是在单一行的多个表达式上发生。聚集表达式的更多信息请见<xref linkend="functions-aggregate"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo>abc</foo><bar/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     为了决定串接的顺序，可以为聚集调用增加一个<literal>ORDER BY</literal>子句，如<xref linkend="syntax-aggregates"/>中所述。例如：

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     我们推荐在以前的版本中使用下列非标准方法，并且它们在特定情况下仍然有用：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--==========================orignal english content==========================
    <title>XML Predicates</title>
____________________________________________________________________________-->
    <title>XML 谓词</title>

<!--==========================orignal english content==========================
    <para>
     The expressions described in this section check properties
     of <type>xml</type> values.
    </para>
____________________________________________________________________________-->
    <para>
     这一节描述的表达式检查<type>xml</type>值的属性。
    </para>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>IS DOCUMENT</literal></title>
____________________________________________________________________________-->
    <title><literal>IS DOCUMENT</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
    </para>
____________________________________________________________________________-->
    <para>
     如果参数 XML 值是一个正确的 XML 文档，则<literal>IS DOCUMENT</literal>返回真，如果不是则返回假（即它是一个内容片断），或者是参数为空时返回空。文档和内容片断之间的区别请见<xref linkend="datatype-xml"/>。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>IS NOT DOCUMENT</literal></title>
____________________________________________________________________________-->
    <title><literal>IS NOT DOCUMENT</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
    </para>
____________________________________________________________________________-->
    <para>
     如果参数中的XML值是一个正确的XML文档，那么表达式<literal>IS NOT DOCUMENT</literal>返回假，否则返回真（也就是说它是一个内容片段），如果参数为空则返回空。
    </para>
   </sect3>

   <sect3 id="xml-exists">
<!--==========================orignal english content==========================
    <title><literal>XMLEXISTS</literal></title>
____________________________________________________________________________-->
    <title><literal>XMLEXISTS</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlexists</function>评价一个XPath 1.0表达式(第一个参数)，以传递的XML值作为其上下文项。 如果评价的结果产生一个空节点集，该函数返回false，如果产生任何其他值，则返回true。 如果任何参数为空，则函数返回null。 作为上下文项传递的非空值必须是一个XML文档，而不是内容片段或任何非XML值。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>BY REF</literal>和<literal>BY VALUE</literal>子句在<productname>PostgreSQL</productname>中被接受，但在<xref linkend="functions-xml-limits-postgresql"/>中被忽略。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在SQL标准中，<function>xmlexists</function>函数评估XML查询语言中的表达式，但<productname>PostgreSQL</productname>只允许使用XPath 1.0表达式，在<xref linkend="functions-xml-limits-xpath1"/>中讨论过。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
<!--==========================orignal english content==========================
    <title><literal>xml_is_well_formed</literal></title>
____________________________________________________________________________-->
    <title><literal>xml_is_well_formed</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     These functions check whether a <type>text</type> string represents
     well-formed XML, returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
    </para>
____________________________________________________________________________-->
    <para>
     这些函数检查一个<type>text</type>串是不是一个良构的 XML，返回一个布尔结果。<function>xml_is_well_formed_document</function>检查一个良构的文档，而<function>xml_is_well_formed_content</function>检查良构的内容。如果<xref linkend="guc-xmloption"/>配置参数被设置为<literal>DOCUMENT</literal>，<function>xml_is_well_formed</function>会做第一个函数的工作；如果配置参数被设置为<literal>CONTENT</literal>，<function>xml_is_well_formed</function>会做第二个函数的工作。这意味着<function>xml_is_well_formed</function>对于检查一个到类型<type>xml</type>的简单造型是否会成功非常有用，而其他两个函数对于检查<function>XMLPARSE</function>的对应变体是否会成功有用。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 f
(1 row)
]]></screen>

     The last example shows that the checks include whether
     namespaces are correctly matched.
    </para>
____________________________________________________________________________-->
    <para>
     例子：

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

     最后一个例子显示了这些检查也包括名字空间是否正确地匹配。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--==========================orignal english content==========================
   <title>Processing XML</title>
____________________________________________________________________________-->
   <title>处理 XML</title>

<!--==========================orignal english content==========================
   <para>
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
   </para>
____________________________________________________________________________-->
   <para>
    要处理数据类型<type>xml</type>的值， PostgreSQL 提供了函数<function>xpath</function>和<function>xpath_exists</function>，它们计算 XPath 1.0 表达式以及<function>XMLTABLE</function>表函数。
   </para>

   <sect3 id="functions-xml-processing-xpath">
<!--==========================orignal english content==========================
    <title><literal>xpath</literal></title>
____________________________________________________________________________-->
    <title><literal>xpath</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>XPath</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <parameter>xpath</parameter> (given as text)
     against the XML value
     <parameter>xml</parameter>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xpath</function>根据 XML 值<parameter>xml</parameter>计算 XPath 1.0 表达式<parameter>xpath</parameter> (以文本形式给出)。
     它返回一个 XML 值的数组，该数组对应于该 XPath 表达式产生的结点集合。
     如果该 XPath 表达式返回一个标量值而不是一个结点集合，将会返回一个单一元素的数组。
    </para>

<!--==========================orignal english content==========================
   <para>
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
    </para>
____________________________________________________________________________-->
   <para>
     第二个参数必须是一个良构的 XML 文档。特殊地，它必须有一个单一根结点元素。
   </para>

<!--==========================orignal english content==========================
    <para>
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
    </para>
____________________________________________________________________________-->
    <para>
     该函数可选的第三个参数是一个名字空间映射的数组。这个数组应该是一个二维<type>text</type>数组，其第二轴长度等于2（即它应该是一个数组的数组，其中每一个都由刚好 2 个元素组成）。每个数组项的第一个元素是名字空间的名称（别名），第二个元素是名字空间的 URI。并不要求在这个数组中提供的别名和在 XML 文档本身中使用的那些名字空间相同（换句话说，在 XML 文档中和在<function>xpath</function>函数环境中，别名都是<emphasis>本地的</emphasis>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     To deal with default (anonymous) namespaces, do something like this:
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     要处理默认（匿名）命名空间，做这样的事情：
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
<!--==========================orignal english content==========================
    <title><literal>xpath_exists</literal></title>
____________________________________________________________________________-->
    <title><literal>xpath_exists</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>
 
<!--==========================orignal english content==========================
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xpath_exists</function>是<function>xpath</function>函数的一种特殊形式。这个函数不是返回满足 XPath 1.0 表达式的单一 XML 值，它返回一个布尔值表示查询是否被满足(具体来说，它是否产生了空节点集以外的任何值)。这个函数等价于标准的<literal>XMLEXISTS</literal>谓词，不过它还提供了对一个名字空间映射参数的支持。
    </para>

<!--==========================orignal english content==========================
   <para>
     Example:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
   <para>
     例子：
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
   </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
<!--==========================orignal english content==========================
    <title><literal>xmltable</literal></title>
____________________________________________________________________________-->
    <title><literal>xmltable</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmltable</function> expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's <literal>FROM</literal> clause.

    </para>
____________________________________________________________________________-->
    <para>
     <function>xmltable</function>表达式基于给定的XML值产生一个表、一个抽取行的XPath过滤器以及一个列定义集合。
     虽然它在语法上类似于函数，但它只能作为一个表出现在查询的<literal>FROM</literal>子句中。
    </para>

<!--==========================orignal english content==========================
    <para>
     The optional <literal>XMLNAMESPACES</literal> clause gives a
     comma-separated list of namespace definitions, where
     each <replaceable>namespace_uri</replaceable> is a <type>text</type>
     expression and each <replaceable>namespace_name</replaceable> is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
    </para>
____________________________________________________________________________-->
    <para>
     可选的<literal>XMLNAMESPACES</literal>子句是一个逗号分隔的名字空间定义列表。
     其中每个<replaceable>namespace_uri</replaceable>是一个<type>text</type>表达式，每个<replaceable>namespace_name</replaceable>是一个简单的标识符。
     它指定文档中使用的XML名字空间极其别名。当前不支持默认的名字空间说明。
    </para>

<!--==========================orignal english content==========================
    <para>
     The required <replaceable>row_expression</replaceable> argument is an
     XPath 1.0 expression (given as <type>text</type>) that is evaluated,
     passing the XML value <replaceable>document_expression</replaceable> as
     its context item, to obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
    </para>
____________________________________________________________________________-->
    <para>
     所需的<replaceable>row_expression</replaceable>参数是一个求值的XPath 1.0表达式(以<type>text</type>形式给出)，通过传递XML值<replaceable>document_expression</replaceable>作为其上下文项，得到一组XML节点。
     这些节点就是<function>xmltable</function>转换为输出行的内容。如果<replaceable>document_expression</replaceable>为空，或者<replaceable>row_expression</replaceable>产生空节点集或节点集以外的任何值，则不会产生行。
    </para>

<!--==========================orignal english content==========================
    <para>
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>document_expression</replaceable>提供了上下文。<replaceable>row_expression</replaceable>的项。
     它必须是一个格式良好的XML文档；不接受片段/森林。<literal>BY REF</literal>和<literal>BY VALUE</literal>子句 如上文所讨论的那样，被接受但被忽略了，正如在<xref linkend="functions-xml-limits-postgresql"/>中所讨论的。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在SQL标准中，<function>xmltable</function>函数 评估XML查询语言中的表达式。
     但<productname>PostgreSQL</productname>只允许使用XPath 1.0的 表达式，正如在 <xref linkend="functions-xml-limits-xpath1"/>所讨论的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The required <literal>COLUMNS</literal> clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless <literal>FOR ORDINALITY</literal> is specified, in which case
     type <type>integer</type> is implicit).  The path, default and
     nullability clauses are optional.
    </para>
____________________________________________________________________________-->
    <para>
     需要的<literal>COLUMNS</literal>子句指定将在输出表中生成的列。有关格式，请参阅上面的语法摘要。
     每个列都需要一个名称，作为一个数据类型(除非指定了 <literal>FOR ORDINALITY</literal>，在这种情况下类型 <type>integer</type>是隐式的)。
     路径、默认值以及为空性子句是可选的。	 
    </para>

<!--==========================orignal english content==========================
    <para>
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     被标记为<literal>FOR ORDINALITY</literal>的列将按照从<replaceable>row_expression</replaceable>的结果节点集中检索到的节点的顺序，从1开始，填充行号。最多只能有一个列被标记为<literal>FOR ORDINALITY</literal>。
    </para>
    <note>
<!--==========================orignal english content==========================
     <para>
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
     </para>
____________________________________________________________________________-->
     <para>
      XPath 1.0 并没有为节点集中的节点指定顺序，因此依赖特定结果顺序的代码将取决于实现。 详情请参见 <xref linkend="xml-xpath-1-specifics"/>。
     </para>
    </note>
<!--==========================orignal english content==========================
<para>
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
    </para>
____________________________________________________________________________-->
<para>
     列的<replaceable>column_expression</replaceable>是一个XPath 1.0表达式，它对每一行都要进行求值，并以<replaceable>row_expression</replaceable>结果中的当前节点作为其上下文项，以找到列的值。 如果没有给出<replaceable>column_expression</replaceable>，那么列名被用作隐式路径。
    </para>

<!--==========================orignal english content==========================
    <para>
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非XML值（在XPath 1.0中仅限于string、boolean或double），而该列的PostgreSQL类型不是<type>xml</type>，那么该列将被设置为将值的字符串表示法分配给PostgreSQL类型。 (如果值是布尔值，如果输出列的类型类别是数字，那么它的字符串表示方式将被认为是<literal>1</literal>或<literal>0</literal>，否则<literal>true</literal>或 <literal>false</literal>。)
    </para>

<!--==========================orignal english content==========================
    <para>
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
     <footnote>
      <para>
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
      </para>
     </footnote>
    </para>
____________________________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非空的XML节点集，并且该列的PostgreSQL类型是<type>xml</type>，那么如果该列是文档或内容形式的，那么该列将被精确地分配表达式结果。
     <footnote>
      <para>
       在顶层包含一个以上的元素节点的结果，或者在元素之外的非空格文本，就是内容形式的一个例子。一个XPath结果可以是这两种形式的，例如，如果它返回的是一个从包含它的元素中选择的属性节点。这样的结果将被放到内容形式中，每个不允许的节点都会被替换为它的字符串值，就像XPath 1.0<function>string</function> 函数定义的那样。
       
      </para>
     </footnote>
    </para>

<!--==========================orignal english content==========================
    <para>
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
    </para>
____________________________________________________________________________-->
    <para>
     分配给<type>xml</type>输出列的非XML结果会产生内容，一个带有结果字符串值的单个文本节点。分配给任何其他类型的列的XML结果不能有一个以上的节点，否则会产生错误。如果正好有一个节点，则该列将被设置为将该节点的字符串值（如XPath 1.0 <function>string</function>函数定义的那样）分配给PostgreSQL类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
    </para>
____________________________________________________________________________-->
    <para>
     一个XML元素的字符串值是字符串值的协整，按文档的顺序。该元素中包含的所有文本节点及其子节点。字符串 元素的值是一个没有下级文本节点的元素的值是一个 空字符串（不是<literal>NULL</literal>）。任何<literal>xsi:nil</literal>属性都会被忽略。请注意，两个非文本之间的<literal>text()</literal>节点只用空格，而两个非文本 元素，并且保留了<literal>text()</literal>上的前导白格。节点不被扁平化。XPath 1.0中的<function>string</function>函数可以参考XPath 1.0中的 定义其他XML节点类型和非XML值的字符串值的规则。
    </para>

<!--==========================orignal english content==========================
    <para>
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
____________________________________________________________________________-->
    <para>
     这里介绍的转换规则并不完全是SQL标准中的转换规则，如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
    </para>
____________________________________________________________________________-->
    <para>
     如果路径表达式为给定行返回一个空节点集（通常情况下，当它不匹配时），该列将被设置为<literal>NULL</literal>，除非指定了<replaceable>default_expression</replaceable>；然后使用评价该表达式产生的值。
    </para>

<!--==========================orignal english content==========================
    <para>
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>default_expression</replaceable>，而不是在调用<function>xmltable</function>时立即被评价，而是在每次需要列的默认值时，都会被评价。 如果表达式符合稳定或不可更改的条件，则可以跳过重复评价。 这意味着，你可以在<replaceable>default_expression</replaceable>中使用像<function>nextval</function>这样的不稳定函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT
     NULL</literal> column does not match anything and there is
     no <literal>DEFAULT</literal> or
     the <replaceable>default_expression</replaceable> also evaluates to null,
     an error is reported.
    </para>
____________________________________________________________________________-->
    <para>
     列可能会被标记为<literal>NOT NULL</literal>。如果一个<literal>NOT NULL</literal>列的<replaceable>column_expression</replaceable>不匹配任何东西并且没有<literal>DEFAULT</literal>或者<replaceable>default_expression</replaceable>也计算为空，则会报告一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-&minus; xyxxz -&minus;>2a2<?aaaaa?> <!-&minus;x-&minus;>  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     接下来的例子展示了多个text()节点的串接、列名用作XPath过滤器的用法以及对空格、XML注释和处理指令的处理：

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
       element        
----------------------
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-&minus;-&minus;-+-&minus;-&minus;-
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面的例子展示了如何使用<literal>XMLNAMESPACES</literal>子句指定用在XML文档以及XPath表达式中的名字空间列表：

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--==========================orignal english content==========================
   <title>Mapping Tables to XML</title>
____________________________________________________________________________-->
   <title>将表映射到 XML</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数将会把关系表的内容映射成 XML 值。它们可以被看成是 XML 导出功能：
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>table</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
   </para>
____________________________________________________________________________-->
   <para>
    <function>table_to_xml</function>映射由参数<parameter>table</parameter>传递的命名表的内容。<type>regclass</type>类型接受使用常见标记标识表的字符串，包括可选的模式限定和双引号。<function>query_to_xml</function>执行由参数<parameter>query</parameter>传递的查询并且映射结果集。<function>cursor_to_xml</function>从<parameter>cursor</parameter>指定的游标中取出指定数量的行。如果需要映射一个大型的表，我们推荐这种变体，因为每一个函数都是在内存中构建结果值的。
   </para>

<!--==========================orignal english content==========================
   <para>
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
   </para>
____________________________________________________________________________-->
   <para>
    如果<parameter>tableforest</parameter>为假，则结果的 XML 文档看起来像这样：
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    如果<parameter>tableforest</parameter>为真，结果是一个看起来像这样的 XML 内容片断：
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    如果没有表名可用，在映射一个查询或一个游标时，在第一种格式中使用串<literal>table</literal>，在第二种格式中使用<literal>row</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
   </para>
____________________________________________________________________________-->
   <para>
    这几种格式的选择由用户决定。第一种格式是一个正确的 XML 文档，它在很多应用中都很重要。如果结果值要被重组为一个文档，第二种格式在<function>cursor_to_xml</function>函数中更有用。前文讨论的产生 XML 内容的函数（特别是<function>xmlelement</function>）可以被用来把结果修改成符合用户的要求。
   </para>

<!--==========================orignal english content==========================
   <para>
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
   </para>
____________________________________________________________________________-->
   <para>
    数据值会被以前文的函数<function>xmlelement</function>中描述的相同方法映射。
   </para>

<!--==========================orignal english content==========================
   <para>
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
   </para>
____________________________________________________________________________-->
   <para>
    参数<parameter>nulls</parameter>决定空值是否会被包含在输出中。如果为真，列中的空值被表示为：
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    其中<literal>xsi</literal>是 XML 模式实例的 XML 名字空间前缀。一个合适的名字空间声明将被加入到结果值中。如果为假，包含空值的列将被从输出中忽略掉。
   </para>

<!--==========================orignal english content==========================
   <para>
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
   </para>
____________________________________________________________________________-->
   <para>
    参数<parameter>targetns</parameter>指定想要的结果的 XML 名字空间。如果没有想要的特定名字空间，将会传递一个空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数返回 XML 模式文档，这些文档描述上述对应函数所执行的映射：
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    最重要的是相同的参数被传递来获得匹配的 XML 数据映射和 XML 模式文档。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数产生 XML 数据映射和对应的 XML 模式，并把产生的结果链接在一起放在一个文档（或森林）中。在要求自包含和自描述的结果是它们非常有用：
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have <literal>USAGE</literal> (lookup) privilege for.
   </para>
____________________________________________________________________________-->
   <para>
    另外，下面的函数可用于产生相似的整个模式或整个当前数据库的映射：
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    这些函数会忽略当前用户不可读的表。数据库范围的函数还会忽略当前用户没有<literal>USAGE</literal> (查找)权限的模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
   </para>
____________________________________________________________________________-->
   <para>
    请注意，这可能会产生大量数据，这些数据需要在内存中构建。
    当请求大型模式或数据库的内容映射时，可能值得考虑单独映射表，甚至可能通过游标。
   </para>

<!--==========================orignal english content==========================
   <para>
    The result of a schema content mapping looks like this:

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
   </para>
____________________________________________________________________________-->
   <para>
    一个模式内容映射的结果看起来像这样：

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    其中一个表映射的格式取决于上文解释的<parameter>tableforest</parameter>参数。
   </para>

<!--==========================orignal english content==========================
   <para>
    The result of a database content mapping looks like this:

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    where the schema mapping is as above.
   </para>
____________________________________________________________________________-->
   <para>
    一个数据库内容映射的结果看起来像这样：

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    其中的模式映射如上所述。
   </para>

<!--==========================orignal english content==========================
   <para>
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
   </para>
____________________________________________________________________________-->
   <para>
    作为一个使用这些函数产生的输出的例子，<xref linkend="xslt-xml-html"/>展示了一个 XSLT 样式表，它将<function>table_to_xml_and_xmlschema</function>的输出转换为一个包含表数据的扁平转印的 HTML 文档。以一种相似的方式，这些函数的结果可以被转换成其他基于 XML 的格式。
   </para>

   <example id="xslt-xml-html">
<!--==========================orignal english content==========================
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
____________________________________________________________________________-->
    <title>转换 SQL/XML 输出到 HTML 的 XSLT 样式表</title>
<!--==========================orignal english content==========================
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
____________________________________________________________________________-->
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
<!--==========================orignal english content==========================
  <title>JSON Functions and Operators</title>
____________________________________________________________________________-->
  <title>JSON 函数和操作符</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>functions and operators</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-json">
    <primary>JSON</primary>
    <secondary>函数和操作符</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <para>
   This section describes:

   <itemizedlist>
    <listitem>
     <para>
      functions and operators for processing and creating JSON data
     </para>
    </listitem>
    <listitem>
     <para>
      the SQL/JSON path language
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   本节描述:

   <itemizedlist>
    <listitem>
     <para>
      用于处理和创建JSON数据的函数和运算器
     </para>
    </listitem>
    <listitem>
     <para>
      SQL/JSON路径语言
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
  </para>
____________________________________________________________________________-->
  <para>
   要了解有关SQL/JSON标准的更多信息，请参阅<xref linkend="sqltr-19075-6"/>。有关<productname>PostgreSQL</productname>中支持的JSON类型的详细信息，见 <xref linkend="datatype-json"/>。
   .
  </para>

  <sect2 id="functions-json-processing">
<!--==========================orignal english content==========================
   <title>Processing and Creating JSON Data</title>
____________________________________________________________________________-->
   <title>处理和创建JSON数据</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
   In addition, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, though not for <type>json</type>.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   <xref linkend="json-indexing"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-op-table"/>展示了可以用于 JSON 数据类型（见<xref linkend="datatype-json"/>）的操作符。
   此外，<xref linkend="functions-comparison-op-table"/>所示的常用比较操作符也适用于<type>jsonb</type>，但不适用于<type>json</type>。
   比较操作符遵循 <xref linkend="json-indexing"/>中的B树操作概要的排序规则。
  </para>

  <table id="functions-json-op-table">
<!--==========================orignal english content==========================
    <title><type>json</type> and <type>jsonb</type> Operators</title>
____________________________________________________________________________-->
    <title><type>json</type> 和 <type>jsonb</type> 操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素(数组元素从0开始索引，但负整数从末尾开始计数)。
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key.
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段。
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array,
        as <type>text</type>.
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素，作为<type>text</type>。
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key, as <type>text</type>.
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段，作为<type>text</type>。
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取指定路径下的JSON子对象，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>text</type>。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
   </para>
____________________________________________________________________________-->
   <para>
    如果JSON输入没有匹配请求的正确结构，字段/元素/路径提取操作符返回NULL，而不是失败;例如，如果不存在这样的键或数组元素。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Some further operators exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively search indexed
   <type>jsonb</type> data.
  </para>
____________________________________________________________________________-->
  <para>
   还有一些操作符仅适用于<type>jsonb</type>，如表<xref linkend="functions-jsonb-op-table"/>所示。
   第<xref linkend="json-indexing"/>描述了如何使用这些操作符来有效地搜索索引的<type>jsonb</type>数据。
  </para>

  <table id="functions-jsonb-op-table">
<!--==========================orignal english content==========================
    <title>Additional <type>jsonb</type> Operators</title>
____________________________________________________________________________-->
    <title>附加的 <type>jsonb</type> 操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first JSON value contain the second?
        (See <xref linkend="json-containment"/> for details about containment.)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个JSON值是否包含第二个?(请参见<xref linkend="json-containment"/>以了解包含的详细信息。)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first JSON value contained in the second?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第二个JSON中是否包含第一个JSON值?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the text string exist as a top-level key or array element within
        the JSON value?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本字符串是否作为JSON值中的顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do any of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的字符串是否作为顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do all of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的所有字符串都作为顶级键或数组元素存在吗?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Concatenates two <type>jsonb</type> values.
        Concatenating two objects generates an object with the union of their
        keys, taking the second object's value when there are duplicate keys.
        Does not operate recursively: only the top-level array or object
        structure is merged.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        连接两个<type>jsonb</type>值。连接两个数组将生成一个包含每个输入的所有元素的数组。连接两个对象将生成一个包含它们键的并集的对象，当存在重复的键时取第二个对象的值。
        所有其他情况都是通过将非数组输入转换为单个元素数组，然后按照两个数组的方式进行处理。
        不递归操作:只有顶级数组或对象结构被合并。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从JSON对象中删除键(以及它的值)，或从JSON数组中删除匹配的字符串值。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all matching keys or array elements from the left operand.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从左操作数中删除所有匹配的键或数组元素。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除具有指定索引的数组元素(负整数从末尾计数)。如果JSON值不是数组，则抛出错误。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除指定路径上的字段或数组元素，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does JSON path return any item for the specified JSON value?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON路径是否为指定的JSON值返回任何项?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the
        specified JSON value.  Only the first item of the result is taken into
        account.  If the result is not Boolean, then <literal>NULL</literal>
        is returned.
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只考虑结果的第一项。如果结果不是布尔值，则返回<literal>NULL</literal>。
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
____________________________________________________________________________-->
   <para>
    <type>jsonpath</type>操作符<literal>@?</literal> 和 <literal>@@</literal>抑制以下错误:缺少对象字段或数组元素，意外的JSON项目类型，日期时间和数字错误。
	还可以告诉以下描述的与<type>jsonpath</type>相关的函数来抑制这些类型的错误。在搜索不同结构的JSON文档集合时，此行为可能会有所帮助。
	
	The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for constructing <type>json</type> and <type>jsonb</type> values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-creation-table"/> 显示可用于构造<type>json</type>和<type>jsonb</type>值的函数。
  </para>

  <table id="functions-json-creation-table">
<!--==========================orignal english content==========================
    <title>JSON Creation Functions</title>
____________________________________________________________________________-->
    <title>JSON 创建函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Converts any SQL value to <type>json</type> or <type>jsonb</type>.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to <type>json</type>, the cast function will be used to perform the
        conversion;<footnote>
         <para>
          For example, the <xref linkend="hstore"/> extension has a cast
          from <type>hstore</type> to <type>json</type>, so that
          <type>hstore</type> values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
         </para>
        </footnote>
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        将任何SQL值转换为<type>json</type>或<type>jsonb</type>。数组和组合递归地转换为数组和对象(多维数组在JSON中变成数组的数组)。
        否则，如果存在从SQL数据类型到<type>json</type的类型转换，则造型函数将用于执行转换;
        <footnote>
         <para>
          例如，<xref linkend="hstore"/>扩展有一个从<type>hstore</type>到<type>json</type>的转换，这样通过json创建函数转换的<type>hstore</type>值将被表示为json对象，而不是原始字符串值
         </para>
        </footnote>
        否则，将生成一个标量json值。对于除数字、布尔值或空值之外的任何标量，将使用文本表示，并根据需要进行转义，使其成为有效的JSON字符串值。
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL array to a JSON array.  The behavior is the same
        as <function>to_json</function> except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL数组转换为JSON数组。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级数组元素之间添加。
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL composite value to a JSON object.  The behavior is the
        same as <function>to_json</function> except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL组合值转换为JSON对象。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级元素之间添加。
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建可能异构类型的JSON数组。每个参数都按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建一个JSON对象。按照惯例，参数列表由交替的键和值组成。
        关键参数强制转换为文本;值参数按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从文本数组构建JSON对象。该数组必须有两个维度，一个维度的成员数为偶数，在这种情况下，它们被视为交替的键/值对;
        另一个维度的成员数为二维，每个内部数组恰好有两个元素，它们被视为键/值对。所有值都转换为JSON字符串。
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        This form of <function>json_object</function> takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这种形式的<function>json_object</function>从单独的文本数组中成对地获取键和值。否则，它与单参数形式相同。
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-processing-table"/> 显示可用于处理<type>json</type>和<type>jsonb</type>值的函数。
  </para>

  <table id="functions-json-processing-table">
<!--==========================orignal english content==========================
    <title>JSON Processing Functions</title>
____________________________________________________________________________-->
    <title>JSON 处理函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of JSON values.
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组JSON值。
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of <type>text</type> values.
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 foo
 bar
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组<type>文本</type>值。
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of elements in the top-level JSON array.
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回顶级JSON数组中的元素数量。
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        将顶级JSON对象展开为一组键/值对。
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
        The returned <parameter>value</parameter>s will be of
        type <type>text</type>.
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        将顶级JSON对象扩展为一组键/值对。返回的<parameter>值</parameter>的类型为<type>文本</type>。
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the <literal>#&gt;</literal>
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        在指定路径下提取JSON子对象。(这在功能上相当于<literal>#&gt;</literal>操作符，但在某些情况下，将路径写成可变参数列表会更方便。)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
        (This is functionally equivalent to the <literal>#&gt;&gt;</literal>
        operator.)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>文本</type>。(这在功能上等同于<literal>#&gt;&gt;</literal>操作符。)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of keys in the top-level JSON object.
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f1
 f2
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回顶级JSON对象中的键集合。
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        of the <parameter>base</parameter> argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of <parameter>base</parameter> is just
        <literal>NULL</literal>, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if <parameter>base</parameter> isn't <literal>NULL</literal> then
        the values it contains will be used for unmatched columns.
       </para>
       <para>
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           A JSON null value is converted to a SQL null in all cases.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is of type <type>json</type>
           or <type>jsonb</type>, the JSON value is just reproduced exactly.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        While the example below uses a constant JSON value, typical use would
        be to reference a <type>json</type> or <type>jsonb</type> column
        laterally from another table in the query's <literal>FROM</literal>
        clause.  Writing <function>json_populate_record</function> in
        the <literal>FROM</literal> clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        将顶级JSON对象扩展为具有<parameter>基本</parameter>参数的复合类型的行。JSON对象将被扫描，查找名称与输出行类型的列名匹配的字段，并将它们的值插入到输出的这些列中。
        (不对应任何输出列名的字段将被忽略。)在典型的使用中，<parameter>基本</parameter>的值仅为<literal>NULL</literal>，这意味着任何不匹配任何对象字段的输出列都将被填充为空。
        但是，如果<parameter>base</parameter>不为<literal>NULL</literal>，那么它包含的值将用于不匹配的列。
       </para>
       <para>
        要将JSON值转换为输出列的SQL类型，需要按次序应用以下规则:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           在所有情况下，JSON空值都会转换为SQL空值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列的类型是<type>json</type>或<type>jsonb</type>，则会精确地重制JSON值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列是复合(行)类型，且JSON值是JSON对象，则该对象的字段将转换为输出行类型的列，通过这些规则的递归应用程序。
          </para>
         </listitem>
         <listitem>
          <para>
           同样，如果输出列是数组类型，而JSON值是JSON数组，则通过这些规则的递归应用程序将JSON数组的元素转换为输出数组的元素。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，如果JSON值是字符串，则将字符串的内容提供给输入转换函数，用以确定列的数据类型。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，JSON值的普通文本表示将被提供给输入转换函数，以确定列的数据类型。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        虽然下面的示例使用一个常量JSON值，典型的用法是在查询的<literal>FROM</literal>子句中从另一个表侧面地引用<type>json</type>或<type>jsonb</type>列。
        在<literal>FROM</literal>子句中编写<function>json_populate_record</function>是一种很好的实践，因为提取的所有列都可以使用，而不需要重复的函数调用。
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the <parameter>base</parameter> argument.
        Each element of the JSON array is processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
-&minus;-+-&minus;-
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将对象的顶级JSON数组展开为一组具有<parameter>基本</parameter>参数的复合类型的行。
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        defined by an <literal>AS</literal> clause.  (As with all functions
        returning <type>record</type>, the calling query must explicitly
        define the structure of the record with an <literal>AS</literal>
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for <function>json[b]_populate_record</function>.  Since there is no
        input record value, unmatched columns are always filled with nulls.
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        将顶级JSON对象展开为具有由 <literal>AS</literal>子句定义的复合类型的行。
        (与所有返回<type>record</type>的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        输出记录由JSON对象的字段填充，与上面描述的<function>json[b]_populate_record</function>的方式相同。
        由于没有输入记录值，不匹配的列总是用空值填充。
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an <literal>AS</literal> clause.  (As
        with all functions returning <type>record</type>, the calling query
        must explicitly define the structure of the record with
        an <literal>AS</literal> clause.)  Each element of the JSON array is
        processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        将顶级JSON对象数组展开为一组由<literal>AS</literal>子句定义的复合类型的行。
        (与所有返回record的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with the item designated by <parameter>path</parameter>
        replaced by <parameter>new_value</parameter>, or with
        <parameter>new_value</parameter> added if
        <parameter>create_if_missing</parameter> is true (which is the
        default) and the item designated by <parameter>path</parameter>
        does not exist.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and <parameter>create_if_missing</parameter> is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回<parameter>target</parameter>，将<parameter>path</parameter>指定的项替换为<parameter>new_value</parameter>，
        如果<parameter>create_if_missing</parameter>为真(此为默认值)并且<parameter>path</parameter>指定的项不存在，则添加<parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的<parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组索引，并且<parameter>create_if_missing</parameter>为真，那么如果索引为负，新值将添加到数组的开头，如果索引为正，则添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        If <parameter>new_value</parameter> is not <literal>NULL</literal>,
        behaves identically to <literal>jsonb_set</literal>. Otherwise behaves
        according to the value
        of <parameter>null_value_treatment</parameter> which must be one
        of <literal>'raise_exception'</literal>,
        <literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, or
        <literal>'return_target'</literal>. The default is
        <literal>'use_json_null'</literal>.
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        如果<parameter>new_value</parameter>不为<literal>NULL</literal>，则行为与<literal>jsonb_set</literal>完全一样。
        否则，根据<parameter>null_value_treatment</parameter>的值，它必须是<literal>'raise_exception'</literal>，<literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, 或<literal>'return_target'</literal>。
        默认值为<literal>'use_json_null'</literal>。
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with <parameter>new_value</parameter> inserted.  If the item
        designated by the <parameter>path</parameter> is an array
        element, <parameter>new_value</parameter> will be inserted before
        that item if <parameter>insert_after</parameter> is false (which
        is the default), or after it
        if <parameter>insert_after</parameter> is true.  If the item
        designated by the <parameter>path</parameter> is an object
        field, <parameter>new_value</parameter> will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回插入<parameter>new_value</parameter>的<parameter>target</parameter>。
        如果<parameter>path</parameter>指派的项是一个数组元素，如果 <parameter>insert_after</parameter>为假(此为默认值)，则<parameter>new_value</parameter>将被插入到该项之前，如果 <parameter>insert_after</parameter>为真则在该项之后。
        如果由<parameter>path</parameter>指派的项是一个对象字段，则只在对象不包含该键时才插入 <parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的 <parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组下标，则如果下标为负，则将新值添加到数组的开头;如果下标为正，则将新值添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从给定的JSON值中删除所有具有空值的对象字段，递归地。非对象字段的空值是未受影响的。
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the JSON path returns any item for the specified JSON
        value.
        If the <parameter>vars</parameter> argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the <type>jsonpath</type> expression.
        If the <parameter>silent</parameter> argument is specified and
        is <literal>true</literal>, the function suppresses the same errors
        as the <literal>@?</literal> and <literal>@@</literal> operators do.
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查JSON路径是否返回指定JSON值的任何项。如果指定了<parameter>vars</parameter>参数，则它必须是一个JSON对象，并且它的字段提供要替换到<type>jsonpath</type>表达式中的名称值。
        如果指定了<parameter>silent</parameter>参数并为<literal>true</literal>，函数会抑制与<literal>@?</literal> 和 <literal>@@</literal>运算符相同的错误。
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the specified
        JSON value.  Only the first item of the result is taken into account.
        If the result is not Boolean, then <literal>NULL</literal> is returned.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只有结果的第一项被考虑在内。
        如果结果不是布尔值，则返回<literal>NULL</literal>。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2
 3
 4
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        以JSON数组的形式返回由JSON路径为指定的JSON值返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns the first JSON item returned by the JSON path for the
        specified JSON value.  Returns <literal>NULL</literal> if there are no
        results.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的第一个JSON项。如果没有结果则返回<literal>NULL</literal>。
        可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与 <function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        These functions act like their counterparts described above without
        the <literal>_tz</literal> suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value <literal>2015-08-02</literal> as a timestamp with time
        zone, so the result depends on the current
        <xref linkend="guc-timezone"/> setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这些函数与上面描述的没有<literal>_tz</literal>后缀的对应函数类似，除了这些函数支持需要时区感知转换的日期/时间值比较之外。
        下面的示例需要将只包含日期的值<literal>2015-08-02</literal>解释为带有时区的时间戳，因此结果依赖于当前<xref linkend="guc-timezone"/>设置。
        由于这种依赖性，这些函数被标记为稳定的，这意味着不能在索引中使用这些函数。
        它们的对应项是不可改变的，因此可以用于索引;但是，如果要求他们进行这样的比较，他们就会抛出错误。
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given JSON value to pretty-printed, indented text.
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的JSON值转换为精美打印的，缩进的文本。
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        <literal>object</literal>, <literal>array</literal>,
        <literal>string</literal>, <literal>number</literal>,
        <literal>boolean</literal>, and <literal>null</literal>.
        (The <literal>null</literal> result should not be confused
        with a SQL NULL; see the examples.)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本字符串形式返回顶级JSON值的类型。可能的类型有<literal>object</literal>, <literal>array</literal>,<literal>string</literal>, <literal>number</literal>,<literal>boolean</literal>, 和 <literal>null</literal>。
        (<literal>null</literal>的结果不应该与SQL NULL 混淆;参见示例。)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
    See also <xref linkend="functions-aggregate"/> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object, and their <type>jsonb</type> equivalents,
    <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
  </para>
____________________________________________________________________________-->
  <para>
    参见 <xref linkend="functions-aggregate"/>，聚合函数<function>json_agg</function>将聚合记录值为JSON，聚合函数<function>json_object_agg</function>将聚合成对的值为JSON对象，
    以及它们在<type>jsonb</type>中的相当的(函数)，<function>jsonb_agg</function>和<function>jsonb_object_agg</function>。
  </para>
 </sect2>

 <sect2 id="functions-sqljson-path">
<!--==========================orignal english content==========================
  <title>The SQL/JSON Path Language</title>
____________________________________________________________________________-->
  <title>SQL/JSON 路径语言</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON path language</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON 路径语言</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
  </para>
____________________________________________________________________________-->
  <para>
   SQL/JSON路径表达式指定了要从JSON数据中检索的项目，类似于SQL访问XML时使用的XPath表达式。
   在<productname>PostgreSQL</productname>中，路径表达式作为<type>jsonpath</type>数据类型实现，可以使用<xref linkend="datatype-jsonpath"/>中描述的任何元素。
  </para>

<!--==========================orignal english content==========================
  <para>
   JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
  </para>
____________________________________________________________________________-->
  <para>
   JSON查询函数和操作符将提供的路径表达式传递给<firstterm>path engine</firstterm>进行评估。
   如果表达式与被查询的JSON数据匹配，则返回相应的JSON项或项集。
   路径表达式是用SQL/JSON路径语言编写的，也可以包括算术表达式和函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
  </para>
____________________________________________________________________________-->
  <para>
   路径表达式由<type>jsonpath</type>数据类型允许的元素序列组成。路径表达式通常从左向右求值，但你可以使用圆括号来更改操作的顺序。
   如果计算成功，将生成一系列JSON项，并将计算结果返回到JSON查询函数，该函数将完成指定的计算。
  </para>

<!--==========================orignal english content==========================
  <para>
   To refer to the JSON value being queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> variable
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each operator that follows deals with the
   result of the previous evaluation step.
  </para>
____________________________________________________________________________-->
  <para>
   要引用正在查询的JSON值(<firstterm>context item</firstterm>项)，在路径表达式中使用<literal>$</literal>变量。
   它后面可以跟着一个或多个<link linkend="type-jsonpath-accessors">accessor operators</link>，这些操作符在JSON结构中逐级向下检索上下文项的子项。
   后面的每个操作符处理前一个求值步骤的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，假设你有一些你想要解析的来自GPS跟踪器的JSON数据，例如:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator to descend through surrounding JSON objects:
<programlisting>
$.track.segments
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为了检索可用的轨迹段，你需要使用<literal>.<replaceable>key</replaceable></literal>访问操作符来向下浏览周边的JSON对象:
<programlisting>
$.track.segments
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To retrieve the contents of an array, you typically use the
   <literal>[*]</literal> operator. For example,
   the following path will return the location coordinates for all
   the available track segments:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要检索数组的内容，通常使用<literal>[*]</literal>操作符。例如，下面的路径将返回所有可用轨道段的位置坐标:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Recall that JSON array indexes are 0-relative:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要只返回第一个段的坐标，可以在<literal>[]</literal>访问操作符中指定相应的下标。重新调用相对于0的JSON数组索引:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
<programlisting>
$.track.segments.size()
</programlisting>
   More examples of using <type>jsonpath</type> operators
   and methods within path expressions appear below in
   <xref linkend="functions-sqljson-path-operators"/>.
  </para>
____________________________________________________________________________-->
  <para>
   每个路径求值步骤的结果可以由<xref linkend="functions-sqljson-path-operators"/>中列出的一个或多个<type>jsonpath</type>操作符和方法来处理。
   每个方法名之前必须有一个点。例如，你可以得到一个数组的大小:
<programlisting>
$.track.segments.size()
</programlisting>
   在路径表达式中使用<type>jsonpath</type>操作符和方法的更多示例见下面<xref linkend="functions-sqljson-path-operators"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   When defining a path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similarly to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在定义路径时，还可以使用一个或多个与SQL中的<literal>WHERE</literal>子句类似的<firstterm>filter expressions</firstterm>。
   过滤器表达式以问号开头，并在圆括号中提供条件:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned <literal>true</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   过滤表达式必须在它们应该应用的路径求值步骤之后写入。该步骤的结果将被筛选，以只包括满足所提供条件的那些项。
   SQL/JSON定义了三值逻辑，因此条件可以是 <literal>true</literal>, <literal>false</literal>,或 <literal>unknown</literal>。
   <literal>unknown</literal>值发挥与SQL <literal>NULL</literal>相同的角色，可以使用<literal>is unknown</literal>谓词进行测试。
   进一步的路径求值步骤只使用筛选器表达式返回<literal>true</literal>的那些项。
  </para>

<!--==========================orignal english content==========================
  <para>
   The functions and operators that can be used in filter expressions are
   listed in <xref linkend="functions-sqljson-filter-ex-table"/>.  Within a
   filter expression, the <literal>@</literal> variable denotes the value
   being filtered (i.e., one result of the preceding path step).  You can
   write accessor operators after <literal>@</literal> to retrieve component
   items.
  </para>
____________________________________________________________________________-->
  <para>
   可以在过滤表达式中使用的函数和操作符罗列在<xref linkend="functions-sqljson-filter-ex-table"/>中。
   在一个过滤表达式中，<literal>@</literal>变量表示被过滤的值(也就是说，前面路径步骤的一个结果)。你可以在 <literal>@</literal>后面写访问操作符来检索组件项。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，假设你想要检索所有高于130的心率值。你可以使用下面的表达式来实现这一点:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before returning the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为了获得具有这些值的片段的开始时间，必须在返回开始时间之前过滤掉不相关的片段，所以过滤表达式应用于上一步，条件中使用的路径不同:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can use several filter expressions in sequence, if required. For
   example, the following expression selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   如果需要，可以按顺序使用几个过滤器表达式。例如，下面的表达式选择所有包含有相关坐标和高心率值的位置的段的开始时间:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   也允许在不同嵌套层级中使用过滤器表达式。下面的例子首先根据位置筛选所有的片段，然后返回这些片段的高心率值，如果适用的话:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can also nest filter expressions within each other:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   你也可以在彼此之间嵌套过滤器表达式:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   如果包含任何具有高心率值的片段，则该表达式返回曲目的大小，否则返回空序列。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s implementation of the SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的SQL/JSON路径语言的实现与SQL/JSON标准有以下偏差:
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     路径表达式可以是布尔谓词，尽管SQL/JSON标准只允许在过滤器中使用谓词。
     这是实现<literal>@@</literal>操作符所必需的。例如，下面的<type>jsonpath</type>表达式在<productname>PostgreSQL</productname>中是有效的:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在解释<literal>like_regex</literal>过滤器中使用的正则表达式模式方面有一些小的差异，如<xref linkend="jsonpath-regular-expressions"/>中所述。
    </para>
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
<!--==========================orignal english content==========================
   <title>Strict and Lax Modes</title>
____________________________________________________________________________-->
   <title>严格的(Strict) 和 不严格的(Lax) 模式</title>
<!--==========================orignal english content==========================
    <para>
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
    </para>
____________________________________________________________________________-->
    <para>
     当查询JSON数据时，路径表达式可能与实际的JSON数据结构不匹配。
     试图访问不存在的对象成员或数组元素会导致结构错误。SQL/JSON路径表达式有两种处理结构错误的模式:
    </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
     </para>
____________________________________________________________________________-->
     <para>
      不严格的(lax)(默认)&mdash;路径引擎隐式地将查询的数据适配到指定的路径。任何剩余的结构错误都将被抑制并转换为空SQL/JSON序列。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      strict &mdash; if a structural error occurs, an error is raised.
     </para>
____________________________________________________________________________-->
     <para>
      严格的(strict) &mdash;如果发生了结构错误，则会引发错误。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
   <para>
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
    <itemizedlist>
     <listitem>
      <para>
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
      </para>
     </listitem>
     <listitem>
      <para>
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    如果JSON数据不符合期望的模式，不严格的(lax)模式有助于匹配JSON文档结构和路径表达式。
    如果操作不匹配特定操作的要求，可以自动将其包装为SQL/JSON数组，也可以在执行该操作之前将其元素转换为SQL/JSON序列来解包装。
    此外，比较操作符会自动以lax模式打开它们的操作数，因此你可以开包即用的就能比较SQL/JSON数组。
    大小为1的数组被认为等于它的唯一元素。只有在以下情况下才不会自动展开:
    <itemizedlist>
     <listitem>
      <para>
       路径表达式包含<literal>type()</literal>或<literal>size()</literal>方法，它们分别返回数组中的元素类型和数量。
      </para>
     </listitem>
     <listitem>
      <para>
       查询的JSON数据包含嵌套的数组。在本例中，只有最外层的数组被打开，而所有内部数组保持不变。
       因此，隐式展开在每个路径求值步骤中只能向下进行一级。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，当查询上面列出的GPS数据时，当使用不严格的(lax)模式时，你可以从它存储了一组片段的事实中抽象出来:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在严格的(strict)模式中，指定的路径必须与查询的JSON文档的结构完全匹配才能返回SQL/JSON项，因此使用该路径表达式会导致错误。
	要得到与不严格的(lax)模式相同的结果，你必须显式地打开<literal>segments</literal>数组:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
<!--==========================orignal english content==========================
   <title>SQL/JSON Path Operators and Methods</title>
____________________________________________________________________________-->
   <title>SQL/JSON 路径操作符和方法</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-op-table"/>显示了jsonpath中可用的操作符和方法。
	请注意，虽然一元操作符和方法可以应用于由前一个路径步骤产生的多个值，二元操作符(加法等)只能应用于单个值。
   </para>

   <table id="functions-sqljson-op-table">
<!--==========================orignal english content==========================
    <title><type>jsonpath</type> Operators and Methods</title>
____________________________________________________________________________-->
    <title><type>jsonpath</type> 操作符和方法</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator/Method
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符/方法
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        加法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        一元加号(无操作);与加法不同，这个可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        减法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Negation; unlike subtraction, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        否定;与减法不同，它可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        乘法
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Division
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        除法
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        模数 (余数)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        Type of the JSON item (see <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        JSON项的类型 (参见 <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Size of the JSON item (number of array elements, or 1 if not an
        array)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        JSON项的大小(数组元素的数量，如果不是数组则为1)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Approximate floating-point number converted from a JSON number or
        string
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        从JSON数字或字符串转换过来的近似浮点数
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        大于或等于给定数字的最接近的整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        小于或等于给定数字的最近整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Absolute value of the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        给定数字的绝对值
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string using the
        specified <function>to_timestamp</function> template
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        使用指定的<function>to_timestamp</function>模板从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        The object's key-value pairs, represented as an array of objects
        containing three fields: <literal>"key"</literal>,
        <literal>"value"</literal>, and <literal>"id"</literal>;
        <literal>"id"</literal> is a unique identifier of the object the
        key-value pair belongs to
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        对象的键值对，表示为包含三个字段的对象数组:<literal>"key"</literal>， <literal>"value"</literal>，和<literal>"id"</literal>;<literal>"id"</literal>是键值对所归属对象的唯一标识符
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <note>
<!--==========================orignal english content==========================
     <para>
      The result type of the <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal>
      methods can be <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, or <type>timestamp</type>.
      Both methods determine their result type dynamically.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal> 和<literal>datetime(<replaceable>template</replaceable>)</literal>方法的结果类型可以是<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 或 <type>timestamp</type>。
      这两个方法都动态地确定它们的结果类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime()</literal> method sequentially tries to
      match its input string to the ISO formats
      for <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, and <type>timestamp</type>. It stops on
      the first matching format and emits the corresponding data type.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal>方法依次尝试将其输入字符串与<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 和 <type>timestamp</type>的ISO格式进行匹配。
      它在第一个匹配格式时停止，并发出相应的数据类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime(<replaceable>template</replaceable>)</literal>
      method determines the result type according to the fields used in the
      provided template string.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime(<replaceable>template</replaceable>)</literal>方法根据所提供的模板字符串中使用的字段确定结果类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal> methods
      use the same parsing rules as the <literal>to_timestamp</literal> SQL
      function does (see <xref linkend="functions-formatting"/>), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal>和<literal>datetime(<replaceable>template</replaceable>)</literal>方法使用与<literal>to_timestamp</literal> SQL函数相同的解析规则(see <xref linkend="functions-formatting"/>)，但有三个例外。
      首先，这些方法不允许不匹配的模板模式。
      其次，模板字符串中只允许以下分隔符:减号、句点、solidus(斜杠)、逗号、撇号、分号、冒号和空格。
      第三，模板字符串中的分隔符必须与输入字符串完全匹配。
     </para>
<!--==========================orignal english content==========================
     <para>
      If different date/time types need to be compared, an implicit cast is
      applied. A <type>date</type> value can be cast to <type>timestamp</type>
      or <type>timestamptz</type>, <type>timestamp</type> can be cast to
      <type>timestamptz</type>, and <type>time</type> to <type>timetz</type>.
      However, all but the first of these conversions depend on the current
      <xref linkend="guc-timezone"/> setting, and thus can only be performed
      within timezone-aware <type>jsonpath</type> functions.
     </para>
____________________________________________________________________________-->
     <para>
      如果需要比较不同的日期/时间类型，则应用隐式转换。
      <type>date</type>值可以转换为<type>timestamp</type>或 <type>timestamptz</type>, <type>timestamp</type>可以转换为<type>timestamptz</type>, <type>time</type>可以转换为<type>timetz</type>。
      但是，除了第一个转换外，其他所有转换都依赖于当前<xref linkend="guc-timezone"/>设置，因此只能在时区感知的<type>jsonpath</type>函数中执行。
     </para>
    </note>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/> shows the available
    filter expression elements.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/>显示了适用的过滤器表达式元素。
   </para>

   <table id="functions-sqljson-filter-ex-table">
<!--==========================orignal english content==========================
    <title><type>jsonpath</type> Filter Expression Elements</title>
____________________________________________________________________________-->
    <title><type>jsonpath</type> 过滤器表达式元素</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate/Value
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词/值
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等比较(这个，和其他比较操作符，适用于所有JSON标量值)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Non-equality comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>true</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>真</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>false</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>假</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON constant <literal>null</literal> (note that, unlike in SQL,
        comparison to <literal>null</literal> works normally)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON常数<literal>null</literal>(注意，与SQL不同，与<literal>null</literal>比较可以正常工作)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a Boolean condition is <literal>unknown</literal>.
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔条件是否为 <literal>unknown</literal>。
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of <literal>flag</literal> characters (see
        <xref linkend="jsonpath-regular-expressions"/>).
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第一个操作数是否与第二个操作数给出的正则表达式匹配，可选使用由一串<literal>flag</literal>字符描述的修改(参见<xref linkend="jsonpath-regular-expressions"/>)。
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the second operand is an initial substring of the first
        operand.
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第二个操作数是否为第一个操作数的初始子串。
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns <literal>unknown</literal> if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试路径表达式是否至少匹配一个SQL/JSON项。
        如果路径表达式会导致错误，则返回<literal>unknown</literal>;第二个例子使用这个方法来避免在严格模式下出现无此键(no-such-key)错误。
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
<!--==========================orignal english content==========================
    <title>SQL/JSON Regular Expressions</title>
____________________________________________________________________________-->
    <title>SQL/JSON 正则表达式</title>

<!--==========================orignal english content==========================
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     SQL/JSON路径表达式允许通过<literal>like_regex</literal>过滤器将文本匹配为正则表达式。
     例如，下面的SQL/JSON路径查询将不区分大小写地匹配以英语元音开头的数组中的所有字符串:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
    </para>
____________________________________________________________________________-->
    <para>
     可选的<literal>flag</literal>字符串可以包括一个或多个字符<literal>i</literal>用于不区分大小写的匹配，<literal>m</literal>允许<literal>^</literal>和<literal>$</literal>在换行时匹配，<literal>s</literal>允许<literal>.</literal>匹配换行符，<literal>q</literal>引用整个模式(将行为简化为一个简单的子字符串匹配)。
    </para>

<!--==========================orignal english content==========================
    <para>
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
    </para>
____________________________________________________________________________-->
    <para>
     SQL/JSON标准借用了来自<literal>LIKE_REGEX</literal>操作符的正则表达式定义，其使用了XQuery标准。
     PostgreSQL目前不支持<literal>LIKE_REGEX</literal>操作符。因此，<literal>like_regex</literal>过滤器是使用<xref linkend="functions-posix-regexp"/>中描述的POSIX正则表达式引擎来实现的。
     这导致了与标准SQL/JSON行为的各种细微差异，这在<xref linkend="posix-vs-xquery"/>中进行了分类。
     但是请注意，这里描述的标志字母不兼容并不适用于SQL/JSON，因为它将XQuery标志字母翻译为符合POSIX引擎的预期。
    </para>

<!--==========================orignal english content==========================
    <para>
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match strings that contain only digits:
<programlisting>
$ ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     请记住，<literal>like_regex</literal>的模式参数是一个JSON路径字符串文字，根据<xref linkend="datatype-jsonpath"/>给出的规则编写。
     这特别意味着在正则表达式中要使用的任何反斜杠都必须加倍。例如，匹配只包含数字的字符串:
<programlisting>
$ ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
<!--==========================orignal english content==========================
  <title>Sequence Manipulation Functions</title>
____________________________________________________________________________-->
  <title>序列操作函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>sequence</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>sequence</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述对<firstterm>sequence objects</firstterm>进行操作的函数，也称为序列生成器或序列。
   序列对象是使用<xref linkend="sql-createsequence"/>创建的特殊单行表。
   序列对象通常用于为表中的行生成惟一标识符。在<xref linkend="functions-sequence-table"/>中列出的序列函数，提供了简单的、多用户安全方法，用于从序列对象中获取连续的序列值。
  </para>

   <table id="functions-sequence-table">
<!--==========================orignal english content==========================
    <title>Sequence Functions</title>
____________________________________________________________________________-->
    <title>序列函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Advances the sequence object to its next value and returns that value.
        This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely
        receive a distinct sequence value.
        If the sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        appropriate parameters in the <xref linkend="sql-createsequence"/>
        command.
      </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        将序列对象推进到下一个值并返回该值。这是自动完成的:即使多个会话并发地执行<function>nextval</function>，每个会话也会安全地接收到不同的序列值。
        如果序列对象是用默认形参创建的，则连续的<function>nextval</function>调用将返回以1开始的连续值。
        其他行为可以通过在<xref linkend="sql-createsequence"/>命令中使用适当的参数获得。
      </para>
       <para>
		这个函数需要<literal>USAGE</literal>或<literal>UPDATE</literal>特权在序列上。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Sets the sequence object's current value, and optionally
        its <literal>is_called</literal> flag.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value that will be reported
        by <function>currval</function> is also set to the specified value.
        In the three-parameter form, <literal>is_called</literal> can be set
        to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same
        effect as the two-parameter form. If it is set
        to <literal>false</literal>, the next <function>nextval</function>
        will return exactly the specified value, and sequence advancement
        commences with the following <function>nextval</function>.
        Furthermore, the value reported by <function>currval</function> is not
        changed in this case.  For example,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        The result returned by <function>setval</function> is just the value of its
        second argument.
       </para>
       <para>
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        设置序列对象的当前值，以及可选的它的<literal>is_called</literal>标志。
        双参数形式将序列的<literal>last_value</literal>字段设置为指定的值，并将其<literal>is_called</literal>字段设置为<literal>true</literal>，意味着下一个<function>nextval</function>将在返回值之前推进序列。
        <function>currval</function>将报告的值也设置为指定的值。在三参数形式中，<literal>is_called</literal>可以设置为<literal>true</literal> 或 <literal>false</literal>。
        <literal>true</literal>与双参数形式具有相同的效果。
        如果设置为<literal>false</literal>，下一个<function>nextval</function>将返回指定的值，序列推进从下面的<function>nextval</function>开始。
        而且，<function>currval</function>报告的值在这种情况下不会改变。例如,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        <function>setval</function>返回的结果就是它的第二个参数的值。
       </para>
       <para>
        这个函数在序列上需要<literal>UPDATE</literal>特权。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently obtained
        by <function>nextval</function> for this sequence in the current
        session.  (An error is reported if <function>nextval</function> has
        never been called for this sequence in this session.)  Because this is
        returning a session-local value, it gives a predictable answer whether
        or not other sessions have executed <function>nextval</function> since
        the current session did.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中为该序列最近获取的值。(如果在这个会话中没有为这个序列调用<function>nextval</function>会报告错误。)
        因为它返回的是一个会话本地值，所以它给出了一个可预测的答案，即自当前会话以来，其他会话是否执行了<function>nextval</function>。
       </para>
       <para>
        这个函数需要序列上的<literal>USAGE</literal> 或 <literal>SELECT</literal>特权。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中最近返回的值。这个函数与<function>currval</function>相同，不同之处在于它没有使用序列名作为参数，而是引用当前会话中<function>nextval</function>最近应用到的序列。
        如果在当前会话中还没有调用<function>nextval</function>，那么调用<function>lastval</function>是一个错误。
       </para>
       <para>
        该函数在最后使用的序列上需要<literal>USAGE</literal>或<literal>SELECT</literal>特权。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <caution>
<!--==========================orignal english content==========================
   <para>
    To avoid blocking concurrent transactions that obtain numbers from
    the same sequence, a <function>nextval</function> operation is never
    rolled back; that is, once a value has been fetched it is considered
    used and will not be returned again.  This is true even if the
    surrounding transaction later aborts, or if the calling query ends
    up not using the value.  For example an <command>INSERT</command> with
    an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
    tuple, including doing any required <function>nextval</function>
    calls, before detecting any conflict that would cause it to follow
    the <literal>ON CONFLICT</literal> rule instead.  Such cases will leave
    unused <quote>holes</quote> in the sequence of assigned values.
    Thus, <productname>PostgreSQL</productname> sequence
    objects <emphasis>cannot be used to obtain <quote>gapless</quote>
    sequences</emphasis>.
   </para>
____________________________________________________________________________-->
   <para>
    为了避免阻塞从相同序列中获取数字的并发事务，<function>nextval</function>操作永远不会回滚;也就是说，一旦获取了一个值，它就会被认为是已使用的，并且不会再次返回。
    即使周围的事务随后中止，或者调用查询最终没有使用该值，也会出现这种情况。
    例如，带有<literal>ON CONFLICT</literal>子句的<command>INSERT</command>将计算要插入的元组，包括执行任何必需的<function>nextval</function>调用，在检测到任何可能导致它遵循<literal>ON CONFLICT</literal>规则的冲突之前。
    这种情况会在赋值序列中留下未使用的<quote>holes</quote>。因此，<productname>PostgreSQL</productname>序列对象<emphasis>不能被用于获取 <quote>gapless</quote> 序列</emphasis>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Likewise, any sequence state changes made by <function>setval</function>
    are not undone if the transaction rolls back.
   </para>
____________________________________________________________________________-->
   <para>
    同样的，如果事务回滚，<function>setval</function>所做的任何序列状态更改都不会撤消。
   </para>
  </caution>

<!--==========================orignal english content==========================
  <para>
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
<programlisting>
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
</programlisting>
   The sequence name can be schema-qualified if necessary:
<programlisting>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
</programlisting>
   See <xref linkend="datatype-oid"/> for more information about
   <type>regclass</type>.
  </para>
____________________________________________________________________________-->
  <para>
   序列函数所要操作的序列由<type>regclass</type>参数指定，该参数只是<structname>pg_class</structname>系统目录中序列的OID。
   你不必手工查找OID，不过，因为<type>regclass</type>数据类型的输入转换器将为您完成这项工作。
   只需将序列名用单引号括起来，这样它看起来就像一个文字常量。
   为了与处理普通<acronym>SQL</acronym>名称兼容，字符串将被转换为小写，除非它在序列名称周围包含双引号。因此:
<programlisting>
nextval('foo')      <lineannotation>序列上操作 <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>序列上操作 <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>序列上操作 <literal>Foo</literal></lineannotation>
</programlisting>
   如需要，序列名称可以是模式限定的:
<programlisting>
nextval('myschema.foo')     <lineannotation>操作 <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>同上</lineannotation>
nextval('foo')              <lineannotation>在搜索路径中查找 <literal>foo</literal></lineannotation>
</programlisting>
   关于<type>regclass</type>的更多信息请参见<xref linkend="datatype-oid"/>。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</type>, not <type>regclass</type>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</type> to <type>regclass</type> before the function is
    invoked.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.1 之前，序列函数的参数类型是<type>text</type>， 而不是 <type>regclass</type>，并且前文所述的从文本串到 OID 值的转换将在每次调用的时候发生。 
    为了向后兼容，这个处理仍然存在，但是在内部实际上是通过在函数调用前隐式地将<type>text</type>转换成<type>regclass</type>实现的。
   </para>

<!--==========================orignal english content==========================
   <para>
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</type>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</quote> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</quote> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</type> constant instead of <type>regclass</type>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
   </para>
____________________________________________________________________________-->
   <para>
    当你把一个序列函数的参数写成一个无修饰的文字串，那么它将变成类型为<type>regclass</type>的常量。
    因为这只是一个 OID，它将跟踪最初标识的序列，而不管后面是否改名、模式变化等等。 
    这种<quote>早期绑定</quote>的行为通常是列默认值和视图中引用的序列所需要的。 
    但是有时候你可能想要<quote>延迟绑定</quote>，其中序列的引用是在运行时解析的。
    要得到延迟绑定的行为，我们可以强制常量被存储为<type>text</type>常量，而不是<type>regclass</type>：
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
    请注意，延迟绑定是<productname>PostgreSQL</productname>版本 8.1 之前唯一被支持的行为， 因此你可能需要做这些来保留旧应用的语义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
   </para>
____________________________________________________________________________-->
   <para>
    当然，序列函数的参数也可以是表达式。如果它是一个文本表达式，那么隐式的转换将导致运行时的查找。
   </para>
  </note>

 </sect1>

 <sect1 id="functions-conditional">
<!--==========================orignal english content==========================
  <title>Conditional Expressions</title>
____________________________________________________________________________-->
  <title>条件表达式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>CASE</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>CASE</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>conditional expression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>条件表达式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述在<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的条件表达式。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
   </para>
____________________________________________________________________________-->
   <para>
    如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个服务器端函数。
   </para>
  </tip>
   <note>
<!--==========================orignal english content==========================
    <para>
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
    </para>
____________________________________________________________________________-->
    <para>
     尽管<token>COALESCE</token>、<token>GREATEST</token>和<token>LEAST</token>在语法上类似于函数，但它们不是普通的函数，因此不能使用显式<token>VARIADIC</token>数组参数。
    </para>
   </note>
  <sect2 id="functions-case">
<!--==========================orignal english content==========================
   <title><literal>CASE</literal></title>
____________________________________________________________________________-->
   <title><literal>CASE</literal></title>

<!--==========================orignal english content==========================
  <para>
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>SQL</acronym> <token>CASE</token>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句：

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token>子句可以用于任何表达式可以出现的地方。每一个<replaceable>condition</replaceable>是一个返回<type>boolean</type>结果的表达式。如果结果为真，那么<token>CASE</token>表达式的结果就是符合条件的<replaceable>result</replaceable>，并且剩下的<token>CASE</token>表达式不会被处理。如果条件的结果不为真，那么以相同方式搜寻任何随后的<token>WHEN</token>子句。如果没有<token>WHEN</token> <replaceable>condition</replaceable>为真，那么<token>CASE</token>表达式的值就是在<token>ELSE</token>子句里的<replaceable>result</replaceable>。如果省略了<token>ELSE</token>子句而且没有条件为真，结果为空。
  </para>

<!--==========================orignal english content==========================
   <para>
    An example:
<screen>
SELECT * FROM test;

 a
-&minus;-
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

<!--==========================orignal english content==========================
  <para>
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
  </para>
____________________________________________________________________________-->
  <para>
   所有<replaceable>result</replaceable>表达式的数据类型都必须可以转换成单一的输出类型。 参阅<xref linkend="typeconv-union-case"/>获取细节。
  </para>

<!--==========================orignal english content==========================
  <para>
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
  </para>
____________________________________________________________________________-->
  <para>
   下面这个<quote>简单</quote>形式的<token>CASE</token>表达式是上述通用形式的一个变种：

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   第一个<replaceable>expression</replaceable>会被计算，然后与所有在<token>WHEN</token>子句中的每一个<replaceable>value</replaceable>对比，直到找到一个相等的。如果没有找到匹配的，则返回在<token>ELSE</token>子句中的<replaceable>result</replaceable>（或者控制）。 这类似于 C 里的<function>switch</function>语句。
  </para>

<!--==========================orignal english content==========================
   <para>
    The example above can be written using the simple
    <token>CASE</token> syntax:
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    上面的例子可以用简单<token>CASE</token>语法来写：
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <token>CASE</token>表达式并不计算任何无助于判断结果的子表达式。例如，下面是一个可以避免被零除错误的方法：
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
    </para>
____________________________________________________________________________-->
    <para>
     如<xref linkend="syntax-express-eval"/>中所述，在有几种情况中一个表达式的子表达式
     会被计算多次，因此<quote><token>CASE</token>只计算必要的表达式</quote>这
     一原则并非不可打破。例如一个常量子表达式<literal>1/0</literal>通常将会在规划时导致一次
     除零错误，即便它位于一个执行时永远也不会进入的<token>CASE</token>分支时也是
     如此。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
<!--==========================orignal english content==========================
   <title><literal>COALESCE</literal></title>
____________________________________________________________________________-->
   <title><literal>COALESCE</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NVL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NVL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>COALESCE</function>函数返回它的第一个非空参数的值。当且仅当所有参数都为空时才会返回空。它常用于在为显示目的检索数据时用缺省值替换空值。例如：
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   如果<varname>description</varname>不为空，这将会返回它的值，否则如果<varname>short_description</varname>非空则返回<varname>short_description</varname>的值，如果前两个都为空则返回<literal>(none)</literal>。
  </para>

<!--==========================orignal english content==========================
   <para>
    The arguments must all be convertible to a common data type, which
    will be the type of the result (see
    <xref linkend="typeconv-union-case"/> for details).
   </para>
____________________________________________________________________________-->
   <para>
    所有参数都必须转换为一个公共数据类型，它将是结果的类型 (详请参见 <xref linkend="typeconv-union-case"/> )。
   </para>

<!--==========================orignal english content==========================
   <para>
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
   </para>
____________________________________________________________________________-->
   <para>
    和<token>CASE</token>表达式一样，<function>COALESCE</function>将不会 计算无助于判断结果的参数；也就是说，在第一个非空参数右边的参数不会被计算。这个 SQL 标准函数提供了类似于<function>NVL</function>和<function>IFNULL</function>的能力，它们被用在某些其他数据库系统中。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
<!--==========================orignal english content==========================
   <title><literal>NULLIF</literal></title>
____________________________________________________________________________-->
   <title><literal>NULLIF</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
  </para>
____________________________________________________________________________-->
  <para>
   当<replaceable>value1</replaceable>和<replaceable>value2</replaceable>相等时，<function>NULLIF</function>返回一个空值。 
   否则它返回<replaceable>value1</replaceable>。 这些可以用于执行前文给出的<function>COALESCE</function>例子的逆操作：
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   在这个例子中，如果<literal>value</literal>是<literal>(none)</literal>，将返回空值，否则返回<literal>value</literal>的值。
  </para>

<!--==========================orignal english content==========================
  <para>
   The two arguments must be of comparable types.
   To be specific, they are compared exactly as if you had
   written <literal><replaceable>value1</replaceable>
   = <replaceable>value2</replaceable></literal>, so there must be a
   suitable <literal>=</literal> operator available.
  </para>
____________________________________________________________________________-->
  <para>
   这两个参数必须具有可比较的类型。具体来说，它们的比较与你写的 <literal><replaceable>value1</replaceable> = <replaceable>value2</replaceable></literal>完全一样，因此必须有一个合适的<literal>=</literal>操作符可用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The result has the same type as the first argument &mdash; but there is
   a subtlety.  What is actually returned is the first argument of the
   implied <literal>=</literal> operator, and in some cases that will have
   been promoted to match the second argument's type.  For
   example, <literal>NULLIF(1, 2.2)</literal> yields <type>numeric</type>,
   because there is no <type>integer</type> <literal>=</literal>
   <type>numeric</type> operator,
   only <type>numeric</type> <literal>=</literal> <type>numeric</type>.
  </para>
____________________________________________________________________________-->
  <para>
   结果的类型与第一个参数相同，但有一点细微的区别。实际上返回的是隐含 <literal>=</literal>操作符的第一个参数，在某些情况下，它将被提升以匹配第二个参数的类型。
   例如，<literal>NULLIF(1, 2.2)</literal> 生成 <type>numeric</type>，因为没有<type>integer</type> <literal>=</literal> <type>numeric</type>操作符，只有<type>numeric</type> <literal>=</literal> <type>numeric</type>。
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
<!--==========================orignal english content==========================
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
____________________________________________________________________________-->
   <title><literal>GREATEST</literal>和<literal>LEAST</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!--==========================orignal english content==========================
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
   </para>
____________________________________________________________________________-->
   <para>
    <function>GREATEST</function>和<function>LEAST</function>函数从一个任意的数字表达式列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型 （参阅<xref linkend="typeconv-union-case"/>获取细节）。列表中的 NULL 数值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that <function>GREATEST</function> and <function>LEAST</function> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
   </para>
____________________________________________________________________________-->
   <para>
    请注意<function>GREATEST</function>和<function>LEAST</function>都不是 SQL 标准，但却是很常见的扩展。某些其他数据库让它们在任何参数为 NULL 时返回 NULL，而不是在所有参数都为 NULL 时才返回 NULL。
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!--==========================orignal english content==========================
  <title>Array Functions and Operators</title>
____________________________________________________________________________-->
  <title>数组函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="array-operators-table"/> shows the specialized operators
   available for array types.
   In addition to those, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   arrays.  The comparison operators compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</productname> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="array-operators-table"/>显示了可以用于数组类型的专用的操作符。
   除此之外，<xref linkend="functions-comparison-op-table"/>中所示的常用比较运算符也适用于数组。
   比较操作符逐个元素的比较数组内容，使用默认的元素数据类型的B-tree比较函数，并根据第一个差值进行排序。
   多维数组的元素按照行序进行访问（最后的下标变化最快）。
   如果两个数组的内容相同但维数不等，那么维度信息中的第一个不同将决定排序顺序（这是对<productname>PostgreSQL</productname> 8.2 之前版本的修改： 老版本认为内容相同的两个数组相等，即使它们的维数或下标范围并不相同）。
  </para>

   <table id="array-operators-table">
<!--==========================orignal english content==========================
    <title>Array Operators</title>
____________________________________________________________________________-->
    <title>数组操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first array contain the second, that is, does each element
        appearing in the second array equal some element of the first array?
        (Duplicates are not treated specially,
        thus <literal>ARRAY[1]</literal> and <literal>ARRAY[1,1]</literal> are
        each considered to contain the other.)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组是否包含第二个数组，也就是说，出现在第二个数组中的每个元素是否等于第一个数组中的某个元素?
        (重复值不需要特殊处理，因此<literal>ARRAY[1]</literal> 和 <literal>ARRAY[1,1]</literal>被认为包含对方。)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first array contained by the second?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组包含在第二个数组中么?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the arrays overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些数组有重叠么，也就是说，它们有共同的元素么?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates the two arrays.  Concatenating a null or empty array is a
        no-op; otherwise the arrays must have the same number of dimensions
        (as illustrated by the first example) or differ in number of
        dimensions by one (as illustrated by the second).
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        连接两个数组。连接空(null)或空数组是一个无操作(no-op);否则，数组必须具有相同的维度数(如第一个示例所示)，或者维度数相差一个(如第二个示例所示)。
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the front of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将元素连接到数组的前面(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the end of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将元素连接到数组的末尾(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
  </para>
____________________________________________________________________________-->
  <para>
   参阅<xref linkend="arrays"/>获取有关数组操作符行为的更多细节。有关哪些操作符支持被索引的操作，请参阅<xref linkend="indexes-types"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="array-functions-table"/>展示了可以用于数组类型的函数。 参阅<xref linkend="arrays"/>获取更多信息以及使用这些函数的例子。
  </para>

   <table id="array-functions-table">
<!--==========================orignal english content==========================
    <title>Array Functions</title>
____________________________________________________________________________-->
    <title>数组函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Appends an element to the end of an array (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        operator).
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        向一个数组的末端追加一个元素 (等同于 <type>anyarray</type> <literal>||</literal> <type>anyelement</type> 操作符)。
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates two arrays (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        连接两个数组(等同于 <type>anyarray</type> <literal>||</literal> <type>anyarray</type> 操作符)。
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a text representation of the array's dimensions.
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回数组维度的文本表示形式。
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns an array filled with copies of the given value, having
        dimensions of the lengths specified by the second argument.
        The optional third argument supplies lower-bound values for each
        dimension (which default to all <literal>1</literal>).
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        返回一个包含给定值的拷贝的数组，其维数与第二个参数指定的长度相同。
        可选的第三个参数提供每个维度的下界值(默认为全部为 <literal>1</literal>)。
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the length of the requested array dimension.
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的长度。
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the lower bound of the requested array dimension.
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的下界。
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of dimensions of the array.
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组的维度数。
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the subscript of the first occurrence of the second argument
        in the array, or <literal>NULL</literal> if it's not present.
        If the third argument is given, the search begins at that subscript.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回阵列中第二个参数中第一次发生的下标，如果它不存在，则返回<literal>NULL</literal>。
        如果给出了第三个参数，则搜索从该下标开始。数组必须是一维的。比较是使用<literal>IS NOT DISTINCT FROM</literal>语义进行的，所以可以搜索<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the subscripts of all occurrences of the second
        argument in the array given as first argument.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
        <literal>NULL</literal> is returned only if the array
        is <literal>NULL</literal>; if the value is not found in the array, an
        empty array is returned.
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回作为第一个参数的数组中第二个参数所有出现的下标的数组。
        数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以搜索<literal>NULL</literal>。
        只有当数组为<literal>NULL</literal>时才返回<literal>NULL</literal>;如果在数组中没有找到该值，则返回空数组。
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Prepends an element to the beginning of an array (same as
        the <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        在数组的开头添加一个元素(等同于<type>anyelement</type> <literal>||</literal> <type>anyarray</type>操作符)。
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Removes all elements equal to the given value from the array.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to remove <literal>NULL</literal>s.
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        从数组中移除与给定值相等的所有元素。数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以删除<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Replaces each array element equal to the second argument with the
        third argument.
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将等于第二个参数的每个数组元素替换为第三个参数。
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts each array element to its text representation, and
        concatenates those separated by
        the <parameter>delimiter</parameter> string.
        If <parameter>null_string</parameter> is given and is
        not <literal>NULL</literal>, then <literal>NULL</literal> array
        entries are represented by that string; otherwise, they are omitted.
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将每个数组元素转换为它的文本表现形式，并连接由<parameter>delimiter</parameter>符字符串分隔的元素。
        如果给出了<parameter>null_string</parameter>且不为<literal>NULL</literal>，则<literal>NULL</literal>数组项由该字符串表示;否则，它们将被省略。
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the upper bound of the requested array dimension.
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的上界。
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the total number of elements in the array, or 0 if the array
        is empty.
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组中元素的总数，如果数组为空则返回0。
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and forms the remaining data
        into a <type>text</type> array.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate element in the array.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are converted
        to <literal>NULL</literal> entries.
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        在出现<parameter>分隔符</parameter>时拆分<parameter>字符串</parameter>，并将剩余数据形成<type>文本</type>数组。
        如果<parameter>分隔符</parameter>为<literal>NULL</literal>，则<parameter>字符串</parameter>中的每个字符将成为数组中的单独元素。
        如果<parameter>分隔符</parameter>为空字符串，则该<parameter>字符串</parameter>视为单个字段。
        如果提供了<parameter>null_string</parameter>且不为<literal>NULL</literal>，那么匹配该字符串的字段将被转换为<literal>NULL</literal>项。
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands an array to a set of rows.
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将数组展开为一组行。
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        Expands multiple arrays (possibly of different data types) to a set of
        rows.  If the arrays are not all the same length then the shorter ones
        are padded with <literal>NULL</literal>s.  This is only allowed in a
        query's FROM clause; see <xref linkend="queries-tablefunctions"/>.
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        将多个数组(可能是不同的数据类型)展开为一组行。
        如果数组的长度不完全相同，那么较短的数组将用<literal>NULL</literal>填充。
        这只在查询的FROM子句中允许;参见<xref linkend="queries-tablefunctions"/>。
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     There are two differences in the behavior of <function>string_to_array</function>
     from pre-9.1 versions of <productname>PostgreSQL</productname>.
     First, it will return an empty (zero-element) array rather
     than <literal>NULL</literal> when the input string is of zero length.
     Second, if the delimiter string is <literal>NULL</literal>, the function
     splits the input into individual characters, rather than
     returning <literal>NULL</literal> as before.
    </para>
____________________________________________________________________________-->
    <para>
     <function>string_to_array</function>的行为中有两点与<productname>PostgreSQL</productname> 9.1之前的版本不同。
     首先，当输入串的长度为零时，它将返回一个空（无元素）数组而不是 <literal>NULL</literal>。
     其次，如果定界符串为 <literal>NULL</literal>，该函数会将输入划分成独立字符，而不是像以前那样返回 <literal>NULL</literal>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
   </para>
____________________________________________________________________________-->
   <para>
    也可参见<xref linkend="functions-aggregate"/>了解用于数组的聚集函数<function>array_agg</function>。
   </para>
  </sect1>

 <sect1 id="functions-range">
<!--==========================orignal english content==========================
  <title>Range Functions and Operators</title>
____________________________________________________________________________-->
  <title>范围函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="rangetypes"/> for an overview of range types.
  </para>
____________________________________________________________________________-->
  <para>
   范围类型的概述请见<xref linkend="rangetypes"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="range-operators-table"/> shows the operators
   available for range types.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="range-operators-table"/>展示了范围类型可用的操作符。
  </para>

    <table id="range-operators-table">
<!--==========================orignal english content==========================
     <title>Range Operators</title>
____________________________________________________________________________-->
     <title>范围操作符</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>equal</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>等于</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>not equal</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>不等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>less than</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>小于</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>greater than</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>大于</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>less than or equal</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>小于等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>greater than or equal</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>大于等于</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>contains range</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含范围</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>contains element</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含元素</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>range is contained by</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>范围被包含</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>element is contained by</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>元素被包含</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>overlap (have points in common)</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>重叠（有公共点）</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>strictly left of</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>严格左部</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>strictly right of</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>严格右部</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>does not extend to the right of</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>不超过右部</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>does not extend to the left of</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>不超过左部</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>-|-</literal> </entry>
        <entry>is adjacent to</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>-|-</literal> </entry>
        <entry>相邻</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>union</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>并</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>*</literal> </entry>
        <entry>intersection</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>*</literal> </entry>
        <entry>交</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>difference</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>差</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
  <para>
   The simple comparison operators <literal>&lt;</literal>,
   <literal>&gt;</literal>, <literal>&lt;=</literal>, and
   <literal>&gt;=</literal> compare the lower bounds first, and only if those
   are equal, compare the upper bounds.  These comparisons are not usually
   very useful for ranges, but are provided to allow B-tree indexes to be
   constructed on ranges.
  </para>
____________________________________________________________________________-->
  <para>
   简单比较操作符<literal>&lt;</literal>、
   <literal>&gt;</literal>、<literal>&lt;=</literal>和
   <literal>&gt;=</literal>首先比较下界，并且只有在下界相等时才比较上界。这些比较通常对范围不怎么有用，但是还是提供它们以便能够在范围上构建 B树索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
  </para>
____________________________________________________________________________-->
  <para>
   当涉及一个空范围时，左部/右部/相邻操作符总是返回假；即一个空范围被认为不在任何其他范围前面或者后面。
  </para>

<!--==========================orignal english content==========================
  <para>
   The union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented.
  </para>
____________________________________________________________________________-->
  <para>
   如果结果范围可能需要包含两个分离的子范围，并和差操作符将会失败，因为这样的范围无法被表示。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="range-functions-table"/>显示可用于范围类型的函数。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
    <primary>lower</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>lower</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>upper</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>upper</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>

    <table id="range-functions-table">
<!--==========================orignal english content==========================
     <title>Range Functions</title>
____________________________________________________________________________-->
     <title>范围函数</title>
     <tgroup cols="5">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>range's element type</entry>
        <entry>lower bound of range</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>范围的元素类型</entry>
        <entry>范围的下界</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>range's element type</entry>
        <entry>upper bound of range</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry>范围的元素类型</entry>
        <entry>范围的上界</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>is the range empty?</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>范围为空？</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>is the lower bound inclusive?</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>下界包含在内？</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>is the upper bound inclusive?</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>上界包含在内？</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>is the lower bound infinite?</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>下界无限？</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>is the upper bound infinite?</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>上界无限？</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>
          <function>range_merge</function>(<type>anyrange</type>, <type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>anyrange</type></entry>
        <entry>the smallest range which includes both of the given ranges</entry>
        <entry><literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal></entry>
        <entry><literal>[1,4)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>
          <function>range_merge</function>(<type>anyrange</type>, <type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>anyrange</type></entry>
        <entry>包含两个给定范围的最小范围</entry>
        <entry><literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal></entry>
        <entry><literal>[1,4)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
  <para>
   The <function>lower</function> and  <function>upper</function> functions return null
   if the range is empty or the requested bound is infinite.
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
  </para>
____________________________________________________________________________-->
  <para>
   如果范围为空或者被请求的界是无限的，<function>lower</function>和<function>upper</function>函数返回空值。函数<function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>和<function>upper_inf</function>对一个空范围全部返回假。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
<!--==========================orignal english content==========================
  <title>Aggregate Functions</title>
____________________________________________________________________________-->
  <title>聚集函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-aggregate">
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-aggregate">
   <primary>聚集函数</primary>
   <secondary>内建</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   and statistical aggregates in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>聚集函数</firstterm>从一个输入值的集合计算出一个单一值。内建的通用聚集函数在<xref linkend="functions-aggregate-table"/>中列出，而统计性聚集在<xref linkend="functions-aggregate-statistics-table"/>中列出。内建的组内有序集聚集函数在<xref linkend="functions-orderedset-table"/>中列出，而内建的组内假想集聚集在<xref linkend="functions-hypothetical-table"/>中列出。与聚集函数紧密相关的分组操作在<xref linkend="functions-grouping-table"/>中列出。<xref linkend="syntax-aggregates"/>中会解释针对聚集函数的特殊语法考虑。额外的介绍信息请参考<xref linkend="tutorial-agg"/>。
  </para>

  <table id="functions-aggregate-table">
<!--==========================orignal english content==========================
   <title>General-Purpose Aggregate Functions</title>
____________________________________________________________________________-->
   <title>通用聚集函数</title>

   <tgroup cols="5">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>部分模式</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       any non-array type
      </entry>
      <entry>
       array of the argument type
      </entry>
      <entry>No</entry>
      <entry>input values, including nulls, concatenated into an array</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       任何非数组类型
      </entry>
      <entry>
       参数类型的数组
      </entry>
      <entry>No</entry>
      <entry>输入值（包括空）被连接到一个数组</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       any array type
      </entry>
      <entry>
       same as argument data type
      </entry>
      <entry>No</entry>
      <entry>input arrays concatenated into array of one higher dimension
       (inputs must all have same dimensionality,
        and cannot be empty or null)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       任意数组类型
      </entry>
      <entry>
       和参数数据类型相同
      </entry>
      <entry>No</entry>
      <entry>输入数组被串接到一个更高维度的数组中
       （输入必须都具有相同的维度并且不能为空或者 NULL）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, or <type>interval</type>
      </entry>
      <entry>
       <type>numeric</type> for any integer-type argument,
       <type>double precision</type> for a floating-point argument,
       otherwise the same as the argument data type
      </entry>
      <entry>Yes</entry>
      <entry>the average (arithmetic mean) of all non-null input values</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、<type>numeric</type>或<type>interval</type>
      </entry>
      <entry>
       对于任何整数类型参数是<type>numeric</type>，对于一个浮点参数是<type>double precision</type>，否则和参数数据类型相同
      </entry>
      <entry>Yes</entry>
      <entry>所有非空输入值的平均值（算术平均）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <entry>
        same as argument data type
      </entry>
      <entry>Yes</entry>
      <entry>the bitwise AND of all non-null input values, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、<type>bigint</type>或<type>bit</type>
      </entry>
      <entry>
        与参数数据类型相同
      </entry>
      <entry>Yes</entry>
      <entry>所有非空输入值的按位与，如果没有非空值则结果是空值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <entry>
        same as argument data type
      </entry>
      <entry>Yes</entry>
      <entry>the bitwise OR of all non-null input values, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <entry>
        与参数数据类型相同
      </entry>
      <entry>Yes</entry>
      <entry>所有非空输入值的按位或，如果没有非空值则结果是空值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>true if all input values are true, otherwise false</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>如果所有输入值为真则结果为真，否则为假</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>true if at least one input value is true, otherwise false</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>至少一个输入值为真时结果为真，否则为假</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
      <entry>Yes</entry>
      <entry>number of input rows</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
      <entry>Yes</entry>
      <entry>输入的行数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>Yes</entry>
      <entry>
       number of input rows for which the value of <replaceable
       class="parameter">expression</replaceable> is not null
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>Yes</entry>
      <entry>
       <replaceable class="parameter">expression</replaceable>值非空的输入行的数目
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>equivalent to <function>bool_and</function></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Yes</entry>
      <entry>等价于<function>bool_and</function></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>No</entry>
      <entry>aggregates values, including nulls, as a JSON array</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>No</entry>
      <entry>将值，包含空值，聚集成一个 JSON 数组</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>jsonb_agg</primary>
       </indexterm>
       <function>jsonb_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>No</entry>
      <entry>aggregates values, including nulls, as a JSON array</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>jsonb_agg</primary>
       </indexterm>
       <function>jsonb_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>No</entry>
      <entry>把值，包含空值，聚合成一个 JSON 数组</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>No</entry>
      <entry>aggregates name/value pairs as a JSON object; values can be
       null, but not names</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>No</entry>
      <entry>将名字/值对聚集成一个 JSON 对象，值可以为空，但不能是名字。</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>jsonb_object_agg</primary>
       </indexterm>
       <function>jsonb_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>No</entry>
      <entry>aggregates name/value pairs as a JSON object; values can be
       null, but not names</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>jsonb_object_agg</primary>
       </indexterm>
       <function>jsonb_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>No</entry>
      <entry>把名字/值对聚合成一个 JSON 对象，值可以为空，但不能是名字。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>any numeric, string, date/time, network, or enum type,
             or arrays of these types</entry>
      <entry>same as argument type</entry>
      <entry>Yes</entry>
      <entry>
       maximum value of <replaceable
       class="parameter">expression</replaceable> across all non-null input
       values
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>任意数组、数字、串、日期/时间、网络或者枚举类型，或者这些类型的数组</entry>
      <entry>与参数数据类型相同</entry>
      <entry>Yes</entry>
      <entry>
       所有非空输入值中<replaceable class="parameter">expression</replaceable>的最大值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>any numeric, string, date/time, network, or enum type,
             or arrays of these types</entry>
      <entry>same as argument type</entry>
      <entry>Yes</entry>
      <entry>
       minimum value of <replaceable
       class="parameter">expression</replaceable> across all non-null input
       values
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>任意数组、数字、串、日期/时间、网络或者枚举类型，或者这些类型的数组</entry>
      <entry>与参数数据类型相同</entry>
      <entry>Yes</entry>
      <entry>
       所有非空输入值中<replaceable class="parameter">expression</replaceable>的最小值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
       (<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</type>)
      </entry>
      <entry>
       same as argument types
      </entry>
      <entry>No</entry>
      <entry>non-null input values concatenated into a string, separated by delimiter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
       (<type>text</type>, <type>text</type>) 或 (<type>bytea</type>, <type>bytea</type>)
      </entry>
      <entry>
       与参数数据类型相同
      </entry>
      <entry>No</entry>
      <entry>非空输入值连接成一个串，用定界符分隔</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>,
       <type>interval</type>, or <type>money</type>
      </entry>
      <entry>
       <type>bigint</type> for <type>smallint</type> or
       <type>int</type> arguments, <type>numeric</type> for
       <type>bigint</type> arguments, otherwise the same as the
       argument data type
      </entry>
      <entry>Yes</entry>
      <entry>sum of <replaceable class="parameter">expression</replaceable>
       across all non-null input values</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、<type>numeric</type>、
       <type>interval</type>或<type>money</type>
      </entry>
      <entry>
       对<type>smallint</type>或<type>int</type>参数是<type>bigint</type>，对<type>bigint</type>参数是<type>numeric</type>，否则和参数数据类型相同
      </entry>
      <entry>Yes</entry>
      <entry>所有非空输入值的<replaceable class="parameter">expression</replaceable>的和</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>No</entry>
      <entry>concatenation of non-null XML values
       (see also <xref linkend="functions-xml-xmlagg"/>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>No</entry>
      <entry>连接 非空XML 值（参见<xref linkend="functions-xml-xmlagg"/>）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
  </para>
____________________________________________________________________________-->
  <para>
   请注意，除了<function>count</function>以外，这些函数在没有行被选中时返回控制。尤其是<function>sum</function>函数在没有输入行时返回空值，而不是零，并且<function>array_agg</function>在这种情况返回空值而不是一个空数组。必要时可以用<function>coalesce</function>把空值替换成零或一个空数组。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Aggregate functions which support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
  </para>
____________________________________________________________________________-->
  <para>
   支持<firstterm>部分模式</firstterm>的聚集函数有资格参与到各种优化中，例如并行聚集。
  </para>

  <note>
<!--==========================orignal english content==========================
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
<!--==========================orignal english content==========================
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
<!--==========================orignal english content==========================
    <para>
      Boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      As for <function>any</function> and <function>some</function>,
      it seems that there is an ambiguity built into the standard syntax:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
    </para>
____________________________________________________________________________-->
    <para>
      布尔聚集<function>bool_and</function>和<function>bool_or</function>对应于标准的 SQL 聚集<function>every</function>和<function>any</function>或<function>some</function>。而对于<function>any</function> 和<function>some</function>，似乎在标准语法中有一个歧义：
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      如果子查询返回一行有一个布尔值的结果，这里的<function>ANY</function>可以被认为是引入一个子查询，或者是作为一个聚集函数。因而标准的名称不能指定给这些聚集。
    </para>
  </note>

  <note>
<!--==========================orignal english content==========================
   <para>
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index which includes all rows in
    the table.
   </para>
____________________________________________________________________________-->
   <para>
    在把<function>count</function>聚集应用到整个表上时，习惯于使用其他 SQL 数据管理系统的用户可能会对它的性能感到失望。一个如下的查询：
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    将会要求与整个表大小成比例的工作：<productname>PostgreSQL</productname>将需要扫描整个表或者整个包含表中所有行的索引。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
  </para>
____________________________________________________________________________-->
  <para>
   与相似的用户定义的聚集函数一样，聚集函数<function>array_agg</function>、
   <function>json_agg</function>、<function>jsonb_agg</function>、<function>json_object_agg</function>、<function>jsonb_object_agg</function>、<function>string_agg</function>和<function>xmlagg</function>会依赖输入值的顺序产生有意义的不同结果值。这个顺序默认是不用指定的，但是可以在聚集调用时使用<literal>ORDER BY</literal>子句进行控制，如<xref linkend="syntax-aggregates"/>中所示。作为一种选择，从一个排序号的子查询来提供输入值通常会有帮助。例如：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   注意如果外面的查询层次包含额外的处理（例如连接），这种方法可能会失败，因为这可能导致子查询的输出在计算聚集之前被重新排序。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Where the description mentions
   <replaceable class="parameter">N</replaceable>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <replaceable class="parameter">N</replaceable> is zero.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-aggregate-statistics-table"/>展示了通常被用在统计分析中的聚集函数（这些被隔离出来是为了不和常用聚集混淆）。其中描述提到了<replaceable class="parameter">N</replaceable>，它表示对应于所有非空输入表达式的输入行的数目。在所有情况中，如果计算是无意义的，将会返回空值，例如当<replaceable class="parameter">N</replaceable>为零。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>statistics</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>统计</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>linear regression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>线性回归</primary>
  </indexterm>

  <table id="functions-aggregate-statistics-table">
<!--==========================orignal english content==========================
   <title>Aggregate Functions for Statistics</title>
____________________________________________________________________________-->
   <title>用于统计的聚集函数</title>

   <tgroup cols="5">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>部分模式</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>correlation</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>correlation coefficient</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>correlation</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>相关系数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>population covariance</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>总体协方差</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>sample covariance</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>样本协方差</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>average of the independent variable
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>自变量的平均值
      （<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>average of the dependent variable
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>因变量的平均值
      （<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>Yes</entry>
      <entry>number of input rows in which both expressions are nonnull</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>Yes</entry>
      <entry>两个表达式都不为空的输入行的数目</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regression intercept</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>y-intercept of the least-squares-fit linear equation
      determined by the (<replaceable
      class="parameter">X</replaceable>, <replaceable
      class="parameter">Y</replaceable>) pairs</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>回归截矩</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>由（<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>）对决定的最小二乘拟合的线性方程的 y截距</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>square of the correlation coefficient</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>相关系数的平方</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regression slope</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>slope of the least-squares-fit linear equation determined
      by the (<replaceable class="parameter">X</replaceable>,
      <replaceable class="parameter">Y</replaceable>) pairs</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>回归斜率</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry>由（<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>）对决定的最小二乘拟合的线性方程的斜率</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the independent variable)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>（自变量的<quote>平方和</quote>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      products</quote> of independent times dependent
      variable)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal>（自变量乘以因变量的<quote>积之合</quote>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the dependent variable)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>（因变量的<quote>平方和</quote>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>historical alias for <function>stddev_samp</function></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry><function>stddev_samp</function>的历史别名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>population standard deviation of the input values</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>输入值的总体标准偏差</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>sample standard deviation of the input values</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>标准偏差</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>输入值的样本标准偏差</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>historical alias for <function>var_samp</function></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry><function>var_samp</function>的历史别名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>population variance of the input values (square of the population standard deviation)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
        <secondary>总体</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>输入值的总体方差（总体标准偏差的平方）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>sample variance of the input values (square of the sample standard deviation)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>方差</primary>
        <secondary>样本</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>或<type>numeric</type>
      </entry>
      <entry>
       浮点参数为<type>double precision</type>，否则为<type>numeric</type>
      </entry>
      <entry>Yes</entry>
      <entry>输入值的样本方差（样本标准偏差的平方）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-orderedset-table"/>展示了一些使用
   <firstterm>有序集聚集</firstterm>语法的聚集函数。这些函数有时也被称为
   <quote>逆分布</quote>函数。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>

  <table id="functions-orderedset-table">
<!--==========================orignal english content==========================
   <title>Ordered-Set Aggregate Functions</title>
____________________________________________________________________________-->
   <title>有序集聚集函数</title>

   <tgroup cols="6">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚集参数类型</entry>
      <entry>返回类型</entry>
      <entry>部分模式</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>mode</primary>
        <secondary>statistical</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
       any sortable type
      </entry>
      <entry>
       same as sort expression
      </entry>
      <entry>No</entry>
      <entry>
       returns the most frequent input value (arbitrarily choosing the first
       one if there are multiple equally-frequent results)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>mode</primary>
        <secondary>statistical</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
       任何可排序类型
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>No</entry>
      <entry>
       返回最频繁的输入值（如果有多个频度相同的值就选第一个）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>continuous</secondary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type> or <type>interval</type>
      </entry>
      <entry>
       same as sort expression
      </entry>
      <entry>No</entry>
      <entry>
       continuous percentile: returns a value corresponding to the specified
       fraction in the ordering, interpolating between adjacent input items if
       needed
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>continuous</secondary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>或者<type>interval</type>
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>No</entry>
      <entry>
       连续百分率：返回一个对应于排序中指定分数的值，如有必要就在相邻的输入项之间插值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       <type>double precision</type> or <type>interval</type>
      </entry>
      <entry>
       array of sort expression's type
      </entry>
      <entry>No</entry>
      <entry>
       multiple continuous percentile: returns an array of results matching
       the shape of the <replaceable>fractions</replaceable> parameter, with each
       non-null element replaced by the value corresponding to that percentile
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       <type>double precision</type>或者<type>interval</type>
      </entry>
      <entry>
       排序表达式的类型的数组
      </entry>
      <entry>No</entry>
      <entry>
       多重连续百分率：返回一个匹配<replaceable>fractions</replaceable>参数形状的结果数组，
       其中每一个非空元素都用对应于那个百分率的值替换
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>discrete</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       any sortable type
      </entry>
      <entry>
       same as sort expression
      </entry>
      <entry>No</entry>
      <entry>
       discrete percentile: returns the first input value whose position in
       the ordering equals or exceeds the specified fraction
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>discrete</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       一种可排序类型
      </entry>
      <entry>
       与排序表达式相同
      </entry>
      <entry>No</entry>
      <entry>
       离散百分率：返回第一个在排序中位置等于或者超过指定分数的输入值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       any sortable type
      </entry>
      <entry>
       array of sort expression's type
      </entry>
      <entry>No</entry>
      <entry>
       multiple discrete percentile: returns an array of results matching the
       shape of the <replaceable>fractions</replaceable> parameter, with each non-null
       element replaced by the input value corresponding to that percentile
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       任何可排序类型
      </entry>
      <entry>
       排序表达式的类型的数组
      </entry>
      <entry>No</entry>
      <entry>
       多重离散百分率：返回一个匹配<replaceable>fractions</replaceable>参数形状的结果数组，
       其中每一个非空元素都用对应于那个百分率的输入值替换
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   All the aggregates listed in <xref linkend="functions-orderedset-table"/>
   ignore null values in their sorted input.  For those that take
   a <replaceable>fraction</replaceable> parameter, the fraction value must be
   between 0 and 1; an error is thrown if not.  However, a null fraction value
   simply produces a null result.
  </para>
____________________________________________________________________________-->
  <para>
   所有列在<xref linkend="functions-orderedset-table"/>中的聚集会忽略它们的已
   排序输入中的空值。对那些有一个<replaceable>fraction</replaceable>参数的聚
   集来说，该分数值必须位于 0 和 1 之间，否则会抛出错误。不过，一个空分数值会
   产生一个空结果。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Each of the aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows computed from the <replaceable>sorted_args</replaceable>.
  </para>
____________________________________________________________________________-->
  <para>
   每个列在<xref linkend="functions-hypothetical-table"/>中的聚集都与一个定义在
   <xref linkend="functions-window"/>中的同名窗口函数相关联。在每种情况中，聚集
   结果的计算方法是：假设根据<replaceable>args</replaceable>构建的<quote>假想</quote>行已
   经被增加到从<replaceable>sorted_args</replaceable>计算得到的已排序行分组中，
   然后用相关联的窗口函数针对该行返回的值就是聚集的结果。
  </para>

  <table id="functions-hypothetical-table">
<!--==========================orignal english content==========================
   <title>Hypothetical-Set Aggregate Functions</title>
____________________________________________________________________________-->
   <title>假想集聚集函数</title>

   <tgroup cols="6">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚集参数类型</entry>
      <entry>返回类型</entry>
      <entry>部分模式</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>No</entry>
      <entry>
       rank of the hypothetical row, with gaps for duplicate rows
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>No</entry>
      <entry>
       假想行的排名，为重复的行留下间隔
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>No</entry>
      <entry>
       rank of the hypothetical row, without gaps
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>No</entry>
      <entry>
       假想行的排名，不留间隔
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>No</entry>
      <entry>
       relative rank of the hypothetical row, ranging from 0 to 1
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>No</entry>
      <entry>
       假想行的相对排名，范围从 0 到 1
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>No</entry>
      <entry>
       relative rank of the hypothetical row, ranging from
       1/<replaceable>N</replaceable> to 1
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>No</entry>
      <entry>
       假想行的相对排名，范围从 1/<replaceable>N</replaceable> 到 1
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   For each of these hypothetical-set aggregates, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
  </para>
____________________________________________________________________________-->
  <para>
   对于这些假想集聚集的每一个，<replaceable>args</replaceable>中给定的直接参数
   列表必须匹配<replaceable>sorted_args</replaceable>中给定的聚集参数的
   数量和类型。与大部分的内建聚集不同，这些聚集并不严格，即它们不会丢弃包含空值
   的输入行。空值的排序根据<literal>ORDER BY</literal>子句中指定的规则进行。
  </para>
  
  <table id="functions-grouping-table">
<!--==========================orignal english content==========================
   <title>Grouping Operations</title>
____________________________________________________________________________-->
   <title>分组操作</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>GROUPING</primary>
       </indexterm>
       <function>GROUPING(<replaceable class="parameter">args...</replaceable>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>
       Integer bit mask indicating which arguments are not being included in the current
       grouping set
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>GROUPING</primary>
       </indexterm>
       <function>GROUPING(<replaceable class="parameter">args...</replaceable>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>
       整数位掩码指示哪些参数不被包括在当前分组集合中
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
   <para>
    Grouping operations are used in conjunction with grouping sets (see
    <xref linkend="queries-grouping-sets"/>) to distinguish result rows.  The
    arguments to the <literal>GROUPING</literal> operation are not actually evaluated,
    but they must match exactly expressions given in the <literal>GROUP BY</literal>
    clause of the associated query level.  Bits are assigned with the rightmost
    argument being the least-significant bit; each bit is 0 if the corresponding
    expression is included in the grouping criteria of the grouping set generating
    the result row, and 1 if it is not.  For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    分组操作用来与分组集合（见<xref linkend="queries-grouping-sets"/>）共同来
    区分结果行。<literal>GROUPING</literal>操作的参数并不会被实际计算，但是它们必
    须准确地匹配在相关查询层次的<literal>GROUP BY</literal>子句中给定的表达式。
    最右边参数指派的位是最低有效位，如果对应的表达式被包括在产生结果行的分组
    集合的分组条件中则每一位是 0，否则是 1。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
   </para>

 </sect1>

 <sect1 id="functions-window">
<!--==========================orignal english content==========================
  <title>Window Functions</title>
____________________________________________________________________________-->
  <title>窗口函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-window">
   <primary>window function</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-window">
   <primary>窗口函数</primary>
   <secondary>内建</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>窗口函数</firstterm>提供在与当前查询行相关的行集合上执行计算的能力。有关这个特性的介绍请见<xref linkend="tutorial-window"/>。
   语法细节则请见<xref linkend="syntax-window-functions"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-window-table"/>列出了内建的窗口函数。注意<emphasis>必须</emphasis>使用窗口函数的语法调用这些函数； 一个<literal>OVER</literal>子句是必需的。
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to these functions, any built-in or user-defined
   general-purpose or statistical
   aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as non-window aggregates
   and return a single row for the entire set.
  </para>
____________________________________________________________________________-->
  <para>
   在这些函数之外，任何内建的或者用户定义的通用或者统计性聚集（即非有序集和假想集聚集）都可以被用作一个窗口函数，内建聚集的列表请见<xref linkend="functions-aggregate"/>。仅当聚集函数调用后面跟着一个<literal>OVER</literal>子句时，聚集函数才会像窗口函数那样工作，否则它们会按非窗口聚集的方式运行并且为整个集合返回一个单一行。
  </para>

  <table id="functions-window-table">
<!--==========================orignal english content==========================
   <title>General-Purpose Window Functions</title>
____________________________________________________________________________-->
   <title>通用窗口函数</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>number of the current row within its partition, counting from 1</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>当前行在其分区中的行号，从1计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>rank of the current row with gaps; same as <function>row_number</function> of its first peer</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>带间隙的当前行排名； 与该行的第一个同等行的<function>row_number</function>相同</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>rank of the current row without gaps; this function counts peer groups</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>不带间隙的当前行排名； 这个函数计数同等组</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>relative rank of the current row: (<function>rank</function> - 1) / (total partition rows - 1)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>当前行的相对排名： (<function>rank</function>- 1) / (总行数 - 1)</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>累积分布：(在当前行之前或者平级的分区行数) / 分区行总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</type>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>integer ranging from 1 to the argument value, dividing the
       partition as equally as possible</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</type>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>从1到参数值的整数范围，尽可能等分分区</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
         lag(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
             [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows before the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>
       (which must be of the same type as
       <replaceable class="parameter">value</replaceable>).
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
         lag(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
             [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>的类型相同</type>
      </entry>
      <entry>
       返回<replaceable class="parameter">value</replaceable>，它在分区内当前行的之前<replaceable class="parameter">offset</replaceable>个位置的行上计算；如果没有这样的行，返回<replaceable class="parameter">default</replaceable>替代（必须和<replaceable class="parameter">value</replaceable>类型相同）。<replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>都是根据当前行计算的结果。如果忽略它们，则<replaceable class="parameter">offset</replaceable>默认是1，<replaceable class="parameter">default</replaceable>默认是空值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
         lead(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
              [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows after the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>
       (which must be of the same type as
       <replaceable class="parameter">value</replaceable>).
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
         lead(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
              [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回<replaceable class="parameter">value</replaceable>，它在分区内当前行的之后<replaceable class="parameter">offset</replaceable>个位置的行上计算；如果没有这样的行，返回<replaceable class="parameter">default</replaceable>替代（必须和<replaceable class="parameter">value</replaceable>类型相同）。<replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>都是根据当前行计算的结果。如果忽略它们，则<replaceable class="parameter">offset</replaceable>默认是1，<replaceable class="parameter">default</replaceable>默认是空值
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the first row of the window frame
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       返回在窗口帧中第一行上计算的<replaceable class="parameter">value</replaceable>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the last row of the window frame
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回在窗口帧中最后一行上计算的<replaceable class="parameter">value</replaceable>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</type>, <replaceable class="parameter">nth</replaceable> <type>integer</type>)
       </function>
      </entry>
      <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the <replaceable class="parameter">nth</replaceable>
       row of the window frame (counting from 1); null if no such row
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</type>, <replaceable class="parameter">nth</replaceable> <type>integer</type>)
       </function>
      </entry>
      <entry>
       <type>和<replaceable class="parameter">value</replaceable>类型相同</type>
      </entry>
      <entry>
       返回在窗口帧中第<replaceable class="parameter">nth</replaceable>行（行从1计数）上计算的<replaceable class="parameter">value</replaceable>；没有这样的行则返回空值
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all peer rows.
  </para>
____________________________________________________________________________-->
  <para>
   在<xref linkend="functions-window-table"/>中列出的所有函数都依赖于相关窗口定义的<literal>ORDER BY</literal>子句指定的排序顺序。仅考虑<literal>ORDER BY</literal>列时不能区分的行被称为是<firstterm>同等行</firstterm>。定义的这四个排名函数（包括 <function>cume_dist</function>），对于任何两个同等行的答案相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
  </para>
____________________________________________________________________________-->
  <para>
   注意<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>只考虑<quote>窗口帧</quote>内的行，它默认情况下包含从分区的开始行直到当前行的最后一个同等行。这对<function>last_value</function>可能不会给出有用的结果，有时对<function>nth_value</function>也一样。你可以通过向<literal>OVER</literal>子句增加一个合适的帧声明（<literal>RANGE</literal>或<literal>GROUPS</literal>）来重定义帧。关于帧声明的更多信息请参考<xref linkend="syntax-window-functions"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
  </para>
____________________________________________________________________________-->
  <para>
   当一个聚集函数被用作窗口函数时，它将在当前行的窗口帧内的行上聚集。 一个使用<literal>ORDER BY</literal>和默认窗口帧定义的聚集产生一种<quote>运行时求和</quote>类型的行为，这可能是或者不是想要的结果。为了获取在整个分区上的聚集，忽略<literal>ORDER BY</literal>或者使用<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>。 其它窗口帧声明可以用来获得其它的效果。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
   </para>
____________________________________________________________________________-->
   <para>
    SQL 标准为<function>lead</function>、<function>lag</function>、<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>定义了一个<literal>RESPECT NULLS</literal>或<literal>IGNORE NULLS</literal>选项。 这在<productname>PostgreSQL</productname>中没有实现：行为总是与标准的默认相同，即<literal>RESPECT NULLS</literal>。 同样，标准中用于<function>nth_value</function>的<literal>FROM FIRST</literal>或<literal>FROM LAST</literal>选项没有实现： 只有支持默认的<literal>FROM FIRST</literal>行为（你可以通过反转<literal>ORDER BY</literal>的排序达到<literal>FROM LAST</literal>的结果）。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <function>cume_dist</function> computes the fraction of partition rows that
   are less than or equal to the current row and its peers, while
   <function>percent_rank</function> computes the fraction of partition rows that
   are less than the current row, assuming the current row does not exist
   in the partition.
  </para>
____________________________________________________________________________-->
  <para>
   <function>cume_dist</function>计算小于等于当前行及其平级行的分区行所占的分数，而<function>percent_rank</function>计算小于当前行的分区行所占的分数，假定当前行不存在于该分区中。
  </para>

 </sect1>

 <sect1 id="functions-subquery">
<!--==========================orignal english content==========================
  <title>Subquery Expressions</title>
____________________________________________________________________________-->
  <title>子查询表达式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>subquery</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>subquery</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的子查询表达式。所有本节中成文的表达式都返回布尔值（真/假）结果。
  </para>

  <sect2 id="functions-subquery-exists">
<!--==========================orignal english content==========================
   <title><literal>EXISTS</literal></title>
____________________________________________________________________________-->
   <title><literal>EXISTS</literal></title>

<!--==========================orignal english content==========================
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</command> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</quote>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</quote>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>EXISTS</token>的参数是一个任意的<command>SELECT</command>语句， 或者说<firstterm>子查询</firstterm>。系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么<token>EXISTS</token>的结果就为<quote>真</quote>； 如果子查询没有返回行，那么<token>EXISTS</token>的结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
  </para>
____________________________________________________________________________-->
  <para>
   子查询可以引用来自周围的查询的变量，这些变量在该子查询的任何一次计算中都起常量的作用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
  </para>
____________________________________________________________________________-->
  <para>
   这个子查询通常只是运行到能判断它是否可以返回至少一行为止， 而不是等到全部结束。在这里写任何有副作用的子查询都是不明智的（例如调用序列函数）；这些副作用是否发生是很难判断的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</literal> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
  </para>
____________________________________________________________________________-->
  <para>
   因为结果只取决于是否会返回行，而不取决于这些行的内容， 所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用<literal>EXISTS(SELECT 1 WHERE ...)</literal>的形式写所有的<literal>EXISTS</literal>测试。不过这条规则有例外，例如那些使用<token>INTERSECT</token>的子查询。
  </para>

<!--==========================orignal english content==========================
  <para>
   This simple example is like an inner join on <literal>col2</literal>, but
   it produces at most one output row for each <literal>tab1</literal> row,
   even if there are several matching <literal>tab2</literal> rows:
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   下面这个简单的例子类似在<literal>col2</literal>上的一次内联接，但是它为每个 <literal>tab1</literal>的行生成最多一个输出，即使存在多个匹配<literal>tab2</literal>的行也如此∶
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
<!--==========================orignal english content==========================
   <title><literal>IN</literal></title>
____________________________________________________________________________-->
   <title><literal>IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧括起来的子查询， 它必须正好只返回一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果找到任何等于子查询行的情况，那么<token>IN</token>的结果就是<quote>真</quote>。 如果没有找到相等行，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>IN</token>结构的结果将是空值，而不是假。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的<token>IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到任意相等的子查询行，则<token>IN</token>的结果为<quote>真</quote>。如果没有找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
  </para>
____________________________________________________________________________-->
  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-notin">
<!--==========================orignal english content==========================
   <title><literal>NOT IN</literal></title>
____________________________________________________________________________-->
   <title><literal>NOT IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个用圆括弧包围的子查询，它必须返回正好一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果只找到不相等的子查询行（包括子查询不返回行的情况），那么<token>NOT IN</token>的结果是<quote>真</quote>。 如果找到任何相等行，则结果为<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>NOT IN</token>结构的结果将是空值，而不是真。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询会完全结束是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的<token>NOT IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到不等于子查询行的行，则<token>NOT IN</token>的结果为<quote>真</quote>。如果找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
  </para>
____________________________________________________________________________-->
  <para>
  通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>NOT IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
<!--==========================orignal english content==========================
   <title><literal>ANY</literal>/<literal>SOME</literal></title>
____________________________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的右手边是一个圆括弧括起来的子查询， 它必须返回正好一个列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果获得任何真值结果，那么<token>ANY</token>的结果就是<quote>真</quote>。 如果没有找到真值结果，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。<token>IN</token>等价于<literal>= ANY</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果没有任何成功并且至少有一个右手边行为该操作符结果生成空值， 那么<token>ANY</token>结构的结果将是空值，而不是假。 这个行为是遵照 SQL 处理空值布尔组合的一般规则制定的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</quote> if the comparison
   returns true for any subquery row.
   The result is <quote>false</quote> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if no comparison with a subquery row returns true,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。右手边是一个圆括弧括起来的子查询， 它必须返回和左手边列表给出的表达式一样多的列。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果比较为任何子查询行返回真，则<token>ANY</token>的结果为<quote>真</quote>。如果比较对每一个子查询行都返回假，则结果为<quote>假</quote>（包括子查询不返回行的情况）。如果比较不对任何行返回真并且至少对一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>

  <sect2 id="functions-subquery-all">
<!--==========================orignal english content==========================
   <title><literal>ALL</literal></title>
____________________________________________________________________________-->
   <title><literal>ALL</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any false result is found.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   ALL 的这种形式的右手边是一个圆括弧括起来的子查询， 它必须只返回一列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。该操作符必须生成布尔结果。 如果所有行得到真（包括子查询没有返回任何行的情况），<token>ALL</token>的结果就是<quote>真</quote>。如果没有存在任何假值结果，那么结果是<quote>假</quote>。如果比较为任何行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>NOT IN</token>等价于<literal>&lt;&gt; ALL</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</quote> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</quote> if the comparison returns false for any
   subquery row.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <token>ALL</token>的这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，它必须返回和左手边行中表达式一样多的列。 左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果对所有子查询行该比较都返回真，那么<token>ALL</token>的结果就是<quote>真</quote>（包括子查询没有返回任何行的情况）。如果对任何子查询行比较返回假，则结果为<quote>假</quote>。如果比较对任何子查询行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Single-Row Comparison</title>
____________________________________________________________________________-->
   <title>单一行比较</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-subquery">
    <primary>comparison</primary>
    <secondary>subquery result row</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-subquery">
    <primary>比较</primary>
    <secondary>子查询结果行</secondary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
  </para>
____________________________________________________________________________-->
  <para>
   左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，该查询必须返回和左手边行中表达式数目完全一样的列。 另外，该子查询不能返回超过一行的数量（如果它返回零行，那么结果就是空值）。 左手边被计算并逐行与右手边的子查询结果行比较。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
<!--==========================orignal english content==========================
  <title>Row and Array Comparisons</title>
____________________________________________________________________________-->
  <title>行和数组比较</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
  
<!--==========================orignal english content==========================
  <indexterm>
   <primary>composite type</primary>
   <secondary>comparison</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>组合类型</primary>
   <secondary>比较</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>row-wise comparison</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>逐行比较</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>comparison</primary>
   <secondary>composite type</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>逐行</secondary>
  </indexterm>
  
<!--==========================orignal english content==========================
  <indexterm>
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>行构造器</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述几个特殊的结构，用于在值的组之间进行多重比较。这些形式语法上和前面一节的子查询形式相关，但是不涉及子查询。 这种形式涉及的数组子表达式是<productname>PostgreSQL</productname>的扩展； 其它的是<acronym>SQL</acronym>兼容的。所有本节记录的表达式形式都返回布尔（Boolean）结果（真/假）。
  </para>

  <sect2 id="functions-comparisons-in-scalar">
<!--==========================orignal english content==========================
   <title><literal>IN</literal></title>
____________________________________________________________________________-->
   <title><literal>IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果等于任何右手边表达式中的一个，结果为<quote>真</quote>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>IN</token>结构的结果将为空值，而不是假。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>NOT IN</literal></title>
____________________________________________________________________________-->
   <title><literal>NOT IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果不等于所有右手边表达式，结果为<quote>真</quote>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>NOT IN</token>结构的结果将为空值， 而不是我们可能天真地认为的真值。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>

  <tip>
<!--==========================orignal english content==========================
  <para>
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>x NOT IN y</literal>在所有情况下都等效于<literal>NOT (x IN y)</literal>。但是，在处理空值的时候，用<token>NOT IN</token>比用<token>IN</token>更可能迷惑新手。最好尽可能用正逻辑来表达你的条件。
  </para>
  </tip>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
____________________________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the array has zero elements).
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式被计算并且使用给出的<replaceable>操作符</replaceable>对数组的每个元素进行比较，这个操作符必须得到布尔结果。如果得到了任何真值结果，那么<token>ANY</token>的结果是<quote>真</quote>。 如果没有找到真值结果（包括数组只有零个元素的情况），那么结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   如果数组表达式得到一个空数组，<token>ANY</token>的结果将为空值。如果左手边的表达式得到空值，<token>ANY</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到真值比较结果，<token>ANY</token>的结果将是空值而不是假（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>ALL</literal> (array)</title>
____________________________________________________________________________-->
   <title><literal>ALL</literal> (array)</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</quote> if any false result is found.
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>与数组的每个元素进行比较，这个操作符必须得到一个布尔结果。如果所有比较都得到真值结果，那么<token>ALL</token>的结果是 <quote>真</quote>（包括数组只有零个元素的情况）。如果有任何假值结果，那么结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
  如果数组表达式得到一个空数组，<token>ALL</token>的结果将为空值。如果左手边的表达式得到空值，<token>ALL</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到假值比较结果，<token>ALL</token>的结果将是空值而不是真（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2 id="row-wise-comparison">
<!--==========================orignal english content==========================
   <title>Row Constructor Comparison</title>
____________________________________________________________________________-->
   <title>行构造器比较</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The two row values must have the same number of fields.
   Each side is evaluated and they are compared row-wise.  Row constructor
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>.
   Every row element must be of a type which has a default B-tree operator
   class or the attempted comparison may generate an error.
  </para>
____________________________________________________________________________-->
  <para>
   每一边都是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。两个行值必须具有相同数量的域。每一边被计算并且被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>、
   <literal>&gt;=</literal>时，允许进行行构造器比较。每一个行元素必须是具有一个默认 B 树操作符类的类型，否则尝试比较会产生一个错误。
  </para>
  
  <note>
<!--==========================orignal english content==========================
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para>
____________________________________________________________________________-->
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
  </para>
____________________________________________________________________________-->
  <para>
   <literal>=</literal>和<literal>&lt;&gt;</literal>情况略有不同。如果两行的所有对应成员都是非空且相等则这两行被认为相等；如果任何对应成员是非空但是不相等则这两行不相等；否则行比较的结果为未知（空值）。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and
   <literal>&gt;=</literal> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>
   yields true, not null, because the third pair of elements are not
   considered.
  </para>
____________________________________________________________________________-->
  <para>
   对于<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况，行元素被从左至右比较，在找到一处不等的或为空的元素对就立刻停下来。如果这一对元素都为空值，则行比较的结果为未知（空值）；否则这一对元素的比较结果决定行比较的结果。例如，<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>得到真，而不是空值，因为第三对元素并没有被考虑。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;=</literal>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</literal>
    was implemented as
    <literal>a &lt; c AND b &lt; d</literal>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.2之前，<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况不是按照每个 SQL 声明来处理的。一个像<literal>ROW(a,b) &lt; ROW(c,d)</literal>的比较会被实现为<literal>a &lt; c AND b &lt; d</literal>，而结果行为等价于<literal>a &lt; c OR (a = c AND b &lt; d)</literal>。
   </para>
  </note>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
  </para>
____________________________________________________________________________-->
  <para>
   这个结构与<literal>&lt;&gt;</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
  </para>
____________________________________________________________________________-->
  <para>
   这个结构与<literal>=</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>
  
  </sect2>

  <sect2 id="composite-type-comparison">
<!--==========================orignal english content==========================
   <title>Composite Type Comparison</title>
____________________________________________________________________________-->
   <title>组合类型比较</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

<!--==========================orignal english content==========================
   <para>
   The SQL specification requires row-wise comparison to return NULL if the
   result depends on comparing two NULL values or a NULL and a non-NULL.
   <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison"/>) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery"/>).
   In other contexts where two composite-type values are compared, two
   NULL field values are considered equal, and a NULL is considered larger
   than a non-NULL.  This is necessary in order to have consistent sorting
   and indexing behavior for composite types.
  </para>
____________________________________________________________________________-->
   <para>
    SQL 规范要求在结果依赖于比较两个 NULL 值或者一个 NULL 与一个非 NULL 时逐行比较返回 NULL。<productname>PostgreSQL</productname>只有在比较两个行构造器（如<xref linkend="row-wise-comparison"/>）的结果或者比较一个行构造器与一个子查询的输出时才这样做（如<xref linkend="functions-subquery"/>中所述）。在其他比较两个组合类型值的环境中，两个 NULL 域值被认为相等，并且一个 NULL 被认为大于一个非 NULL。为了得到组合类型的一致的排序和索引行为，这样做是必要的。
   </para>
   
<!--==========================orignal english content==========================
   <para>
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</literal> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison"/>).
  </para>
____________________________________________________________________________-->
   <para>
   每一边都会被计算并且它们会被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>或者
   <literal>&gt;=</literal>时或者具有与这些类似的语义时，允许组合类型的比较（更准确地说，如果一个操作符是一个 B 树操作符类的成员，或者是一个 B 树操作符类的<literal>=</literal>成员的否定词，它就可以是一个行比较操作符）。
   上述操作符的行为与用于行构造器（见<xref linkend="row-wise-comparison"/>）的<literal>IS [ NOT ] DISTINCT FROM</literal>相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</literal>,
   <literal>*&lt;&gt;</literal>,
   <literal>*&lt;</literal>,
   <literal>*&lt;=</literal>,
   <literal>*&gt;</literal>, and
   <literal>*&gt;=</literal>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally for
   materialized views and might be useful for other specialized purposes
   such as replication but are not intended to be generally useful for
   writing queries.
  </para>
____________________________________________________________________________-->
  <para>
   为了支持包含无默认 B 树操作符类的元素的行匹配，为组合类型比较定义了下列操作符：
   <literal>*=</literal>、
   <literal>*&lt;&gt;</literal>、
   <literal>*&lt;</literal>、
   <literal>*&lt;=</literal>、
   <literal>*&gt;</literal>以及
   <literal>*&gt;=</literal>。
   这些操作符比较两行的内部二进制表达。即使两行用相等操作符的比较为真，两行也可能
   具有不同的二进制表达。行在这些比较操作符之下的排序是决定性的，其他倒没什么意义。
   这些操作符在内部被用于物化视图并且可能对其他如复制之类的特殊功能有用，但是它们
   并不打算用在书写查询这类普通用途中。
  </para>

  </sect2>
 </sect1>

 <sect1 id="functions-srf">
<!--==========================orignal english content==========================
  <title>Set Returning Functions</title>
____________________________________________________________________________-->
  <title>集合返回函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-srf">
   <primary>set returning functions</primary>
   <secondary>functions</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-srf">
   <primary>集合返回函数</primary>
   <secondary>函数</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>generate_series</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>generate_series</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"/> and
   <xref linkend="functions-srf-subscripts"/>.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"/> for ways to combine multiple
   set-returning functions.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述那些可能返回多于一行的函数。目前这个类中被使用最广泛的是级数生成函数， 如<xref linkend="functions-srf-series"/>和<xref linkend="functions-srf-subscripts"/>所述。其他更特殊的集合返回函数在本手册的其他地方描述。
   组合多集合返回函数的方法可见<xref linkend="queries-tablefunctions"/>。
  </para>

  <table id="functions-srf-series">
<!--==========================orignal english content==========================
   <title>Series Generating Functions</title>
____________________________________________________________________________-->
   <title>级数生成函数</title>
   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
      <entry><type>int</type>, <type>bigint</type> or <type>numeric</type></entry>
      <entry><type>setof int</type>, <type>setof bigint</type>, or <type>setof numeric</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of one
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
      <entry><type>int</type>、<type>bigint</type>或者<type>numeric</type></entry>
      <entry><type>setof int</type>、<type>setof bigint</type>或者<type>setof numeric</type>（与参数类型相同）</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为 1
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
      <entry><type>int</type>, <type>bigint</type> or <type>numeric</type></entry>
      <entry><type>setof int</type>, <type>setof bigint</type> or <type>setof numeric</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
      <entry><type>int</type>、<type>bigint</type>或者<type>numeric</type></entry>
      <entry><type>setof int</type>、<type>setof bigint</type>或者<type>setof numeric</type>（与参数类型相同）</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</type>)</function></literal></entry>
      <entry><type>timestamp</type> or <type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type> or <type>setof timestamp with time zone</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</type>)</function></literal></entry>
      <entry><type>timestamp</type>或<type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type>或<type>setof timestamp with time zone</type>（和参数类型相同）</entry>
      <entry>
       产生一系列值，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned for <literal>NULL</literal> inputs. It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
             1.1
             2.4
             3.7
(3 rows)

-&minus; this example relies on the date-plus-integer operator
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   当<parameter>step</parameter>为正时，如果<parameter>start</parameter>大于<parameter>stop</parameter>则返回零行。相反，当<parameter>step</parameter>为负时，如果<parameter>start</parameter>小于<parameter>stop</parameter>则返回零行。对于<literal>NULL</literal>输入也会返回零行。<parameter>step</parameter>为零是一个错误。下面是一些例子：
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series 
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- 这个例子依赖于日期+整数操作符
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>

  <table id="functions-srf-subscripts">
<!--==========================orignal english content==========================
   <title>Subscript Generating Functions</title>
____________________________________________________________________________-->
   <title>下标生成函数</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       Generate a series comprising the given array's subscripts.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       生成一个级数组成给定数组的下标。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       Generate a series comprising the given array's subscripts. When
       <parameter>reverse</parameter> is true, the series is returned in
       reverse order.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
       生成一个级数组成给定数组的下标。当<parameter>reverse</parameter>为真，级数以逆序返回。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <function>generate_subscripts</function> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or for NULL arrays (but valid subscripts are returned for NULL array
   elements).  Some examples follow:
<programlisting>
-&minus; basic usage
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
-&minus;-
 1
 2
 3
 4
(4 rows)

-&minus; presenting an array, the subscript and the subscripted
-&minus; value requires a subquery
SELECT * FROM arrays;
         a          
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-&minus; unnest a 2D array
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
-&minus;-&minus;-&minus;-&minus;-
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>generate_subscripts</function>是一个快捷函数，它为给定数组的指定维度生成一组合法的下标。对于不具有请求维度的数组返回零行，对于 NULL 数组也返回零行（但是会对 NULL 数组元素返回合法的下标）。下面是一些例子：
<programlisting>
-- 基本使用
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

-- 表示一个数组，下标和被下标的值需要一个子查询
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- 平面化一个 2D 数组
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
  
<!--==========================orignal english content==========================
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the output which starts from 1 and increments by 1 for each row
   of the function's output.  This is most useful in the case of set returning
   functions such as <function>unnest()</function>.

<programlisting>
-&minus; set returning function WITH ORDINALITY
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   当<literal>FROM</literal>子句中的一个函数后面有<literal>WITH ORDINALITY</literal>时，输出中会追加一个<type>bigint</type>列，它的值从1开始并且该函数输出的每一行加1。这在<function>unnest()</function>之类的集合返回函数中最有用。

<programlisting>
-- set returning function WITH ORDINALITY
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>

 </sect1>

 <sect1 id="functions-info">
<!--==========================orignal english content==========================
  <title>System Information Functions and Operators</title>
____________________________________________________________________________-->
  <title>系统信息函数和运算符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-session-table"/> shows several
   functions that extract session and system information.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-session-table"/>展示了多个可以抽取会话和系统信息的函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-views"/> for more
   information.
  </para>
____________________________________________________________________________-->
  <para>
   除了本节列出的函数，还有一些与统计系统相关的函数也提供系统信息。详见<xref linkend="monitoring-stats-views"/>。
  </para>

   <table id="functions-info-session-table">
<!--==========================orignal english content==========================
    <title>Session Information Functions</title>
____________________________________________________________________________-->
    <title>会话信息函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>name of current database (called <quote>catalog</quote> in the SQL standard)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前数据库名（SQL 标准中称作<quote>目录</quote>）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>name of current database</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前数据库名</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>text of the currently executing query, as submitted
       by the client (might contain more than one statement)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>当前正在执行的查询的文本，和客户端提交的一样（可能包含多于一个语句）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_role</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>equivalent to <function>current_user</function></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_role</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>等效于<function>current_user</function></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
       <entry>name of current schema</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
       <entry>当前模式名</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
       <entry>names of schemas in search path, optionally including implicit schemas</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
       <entry>搜索路径中的模式名，可以选择是否包含隐式模式</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>user name of current execution context</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>当前执行上下文的用户名</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>address of the remote connection</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>远程连接的地址</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>port of the remote connection</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>远程连接的端口</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>address of the local connection</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>本地连接的地址</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>port of the local connection</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>本地连接的端口</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <!-&minus; See also the entry for this in monitoring.sgml -&minus;>
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
        Process ID of the server process attached to the current session
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <!-- See also the entry for this in monitoring.sgml -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
        与当前会话关联的服务器进程的进程 ID
       </entry>
      </row>
      
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
       <entry>Process ID(s) that are blocking specified server process ID from acquiring a lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
       <entry>阻塞指定服务器进程ID获得锁的进程 ID</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>configuration load time</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>配置载入时间</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_current_logfile(<optional><type>text</type></optional>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>Primary log file name, or log in the requested format,
       currently in use by the logging collector</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_current_logfile(<optional><type>text</type></optional>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>当前日志收集器在使用的主日志文件名或者所要求格式的日志的文件名</entry>
      </row>
      
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
       <entry>OID of session's temporary schema, or 0 if none</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
       <entry>会话的临时模式的 OID，如果没有则为 0</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>is schema another session's temporary schema?</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>模式是另一个会话的临时模式吗？</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_jit_available()</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>is <acronym>JIT</acronym> compilation available in this session
       (see <xref linkend="jit"/>)? Returns <literal>false</literal> if <xref
       linkend="guc-jit"/> is set to false.</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_jit_available()</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>这个会话中<acronym>JIT</acronym>编译是否可用（见<xref linkend="jit"/>）？如果<xref
       linkend="guc-jit"/>被设置为假，则返回<literal>false</literal>。</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
       <entry>channel names that the session is currently listening on</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
       <entry>会话当前正在监听的频道名称</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_notification_queue_usage()</function></literal></entry>
       <entry><type>double</type></entry>
       <entry>fraction of the asynchronous notification queue currently occupied (0-1)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_notification_queue_usage()</function></literal></entry>
       <entry><type>double</type></entry>
       <entry>异步通知队列当前被占用的分数（0-1）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>server start time</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>服务器启动时间</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_safe_snapshot_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
       <entry>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_safe_snapshot_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
       <entry>阻止指定服务器进程ID获取安全快照的进程ID</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>current nesting level of <productname>PostgreSQL</productname> triggers
       (0 if not called, directly or indirectly, from inside a trigger)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry><productname>PostgreSQL</productname>触发器的当前嵌套层次（如果没有调用则为 0，直接或间接，从一个触发器内部开始）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>session user name</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>会话用户名</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>equivalent to <function>current_user</function></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>等价于<function>current_user</function></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry><productname>PostgreSQL</productname> version information. See also <xref linkend="guc-server-version-num"/> for a machine-readable version.</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry><productname>PostgreSQL</productname>版本信息。机器可读的版本还可见<xref linkend="guc-server-version-num"/>。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     <function>current_catalog</function>,
     <function>current_role</function>,
     <function>current_schema</function>,
     <function>current_user</function>,
     <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  (In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.)
    </para>
____________________________________________________________________________-->
    <para>
     <function>current_catalog</function>、<function>current_role</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>和<function>user</function>在<acronym>SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号（在 PostgreSQL 中，圆括号可以有选择性地被用于<function>current_schema</function>，但是不能和其他的一起用）。
    </para>
   </note>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_database</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_database</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_query</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_query</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_role</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_role</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_schema</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_schema</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>current_user</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>current_user</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>模式</primary>
    <secondary>当前</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>search path</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>搜索路径</primary>
    <secondary>当前</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>session_user</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>session_user</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>user</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>用户</primary>
    <secondary>当前</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>user</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>用户</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization"/>.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role"/>.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
    <function>current_role</function> and <function>user</function> are
    synonyms for <function>current_user</function>.  (The SQL standard draws
    a distinction between <function>current_role</function>
    and <function>current_user</function>, but <productname>PostgreSQL</productname>
    does not, since it unifies users and roles into a single kind of entity.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>session_user</function>通常是发起当前数据库连接的用户，不过超级用户可以用<xref linkend="sql-set-session-authorization"/>修改这个设置。<function>current_user</function>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<xref linkend="sql-set-role"/>改变。它也会在函数执行的过程中随着属性<literal>SECURITY DEFINER</literal>的改变而改变。在 Unix 的说法里，那么会话用户是<quote>真实用户</quote>，而当前用户是<quote>有效用户</quote>。<function>current_role</function>以及<function>user</function>是<function>current_user</function>的同义词（SQL标准在<function>current_role</function>和<function>current_user</function>之间做了区分，但<productname>PostgreSQL</productname>不区分，因为它把用户和角色统一成了一种实体）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>current_schema</function> returns the name of the schema that is
    first in the search path (or a null value if the search path is
    empty).  This is the schema that will be used for any tables or
    other named objects that are created without specifying a target schema.
    <function>current_schemas(boolean)</function> returns an array of the names of all
    schemas presently in the search path.  The Boolean option determines whether or not
    implicitly included system schemas such as <literal>pg_catalog</literal> are included in the
    returned search path.
   </para>
____________________________________________________________________________-->
   <para>
    <function>current_schema</function>返回在搜索路径中的第一个模式名（如果搜索路径是空则返回空值）。 如果创建表或者其它命名对象时没有声明目标模式，那么它将是被用于这些对象的模式。<function>current_schemas(boolean)</function>返回一个在搜索路径中出现的所有模式名的数组。布尔选项决定<literal>pg_catalog</literal>这样的隐式包含的系统模式是否包含在返回的搜索路径中。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The search path can be altered at run time.  The command is:
<programlisting>
SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     搜索路径可以在运行时修改。命令是：
<programlisting>
SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>
</programlisting>
    </para>
   </note>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
     <function>inet_client_addr</function> returns the IP address of the
     current client, and <function>inet_client_port</function> returns the
     port number.
     <function>inet_server_addr</function> returns the IP address on which
     the server accepted the current connection, and
     <function>inet_server_port</function> returns the port number.
     All these functions return NULL if the current connection is via a
     Unix-domain socket.
   </para>
____________________________________________________________________________-->
   <para>
     <function>inet_client_addr</function>返回当前客户端的 IP 地址，<function>inet_client_port</function>返回它的端口号。 <function>inet_server_addr</function>返回接受当前连接的服务器的 IP 地址，而<function>inet_server_port</function>返回对应的端口号。如果连接是通过 Unix 域套接字进行的，那么所有这些函数都返回 NULL。
   </para>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_blocking_pids</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_blocking_pids</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_blocking_pids</function> returns an array of the process IDs
    of the sessions that are blocking the server process with the specified
    process ID, or an empty array if there is no such server process or it is
    not blocked.  One server process blocks another if it either holds a lock
    that conflicts with the blocked process's lock request (hard block), or is
    waiting for a lock that would conflict with the blocked process's lock
    request and is ahead of it in the wait queue (soft block).  When using
    parallel queries the result always lists client-visible process IDs (that
    is, <function>pg_backend_pid</function> results) even if the actual lock is held
    or awaited by a child worker process.  As a result of that, there may be
    duplicated PIDs in the result.  Also note that when a prepared transaction
    holds a conflicting lock, it will be represented by a zero process ID in
    the result of this function.
    Frequent calls to this function could have some impact on database
    performance, because it needs exclusive access to the lock manager's
    shared state for a short time.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_blocking_pids</function>返回一个进程 ID 的数组，数组中的进程中的会话阻塞了指定进程 ID 所代表的服务器进程，如果指定的服务器进程不存在或者没有被阻塞则返回空数组。如果一个进程持有与另一个进程加锁请求冲突的锁（硬锁），或者前者正在等待一个与后者加锁请求冲突的锁并且前者在该锁的等待队列中位于后者的前面（软锁），则前者会阻塞后者。在使用并行查询时，这个函数的结果总是会列出客户端可见的进程 ID（即<function>pg_backend_pid</function>的结果），即便实际的锁是由工作者进程所持有或者等待也是如此。这样造成的后果是，结果中可能会有很多重复的 PID。还要注意当一个预备事务持有一个冲突锁时，这个函数的结果中它将被表示为一个为零的进程 ID。对这个函数的频繁调用可能对数据库性能有一些影响，因为它需要短时间地独占访问锁管理器的共享状态。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_conf_load_time</function> returns the
    <type>timestamp with time zone</type> when the
    server configuration files were last loaded.
    (If the current session was alive at the time, this will be the time
    when the session itself re-read the configuration files, so the
    reading will vary a little in different sessions.  Otherwise it is
    the time when the postmaster process re-read the configuration files.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_conf_load_time</function>返回服务器配置文件最近被载入的<type>timestamp with time zone</type>（如果当前会话在那时就已经存在，这个值将是该会话自己重新读取配置文件的时间，因此在不同的会话中这个读数会有一点变化。如果不是这样，这个值就是 postmaster 进程重读配置文件的时间）。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_current_logfile</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_current_logfile</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>Logging</primary>
    <secondary>pg_current_logfile function</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>Logging</primary>
    <secondary>pg_current_logfile function</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>current_logfiles</primary>
     <secondary>and the pg_current_logfile function</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>current_logfiles</primary>
     <secondary>and the pg_current_logfile function</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>Logging</primary>
    <secondary>current_logfiles file and the pg_current_logfile
    function</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>Logging</primary>
    <secondary>current_logfiles file and the pg_current_logfile
    function</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_current_logfile</function> returns, as <type>text</type>,
    the path of the log file(s) currently in use by the logging collector.
    The path includes the <xref linkend="guc-log-directory"/> directory
    and the log file name.  Log collection must be enabled or the return value
    is <literal>NULL</literal>.  When multiple log files exist, each in a
    different format, <function>pg_current_logfile</function> called
    without arguments returns the path of the file having the first format
    found in the ordered list: <systemitem>stderr</systemitem>, <systemitem>csvlog</systemitem>.
    <literal>NULL</literal> is returned when no log file has any of these
    formats.  To request a specific file format supply, as <type>text</type>,
    either <systemitem>csvlog</systemitem> or <systemitem>stderr</systemitem> as the value of the
    optional parameter. The return value is <literal>NULL</literal> when the
    log format requested is not a configured
    <xref linkend="guc-log-destination"/>.  The
    <function>pg_current_logfile</function> reflects the contents of the
    <filename>current_logfiles</filename> file.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_current_logfile</function>以<type>text</type>类型返回当前被日志收集器使用的日志文件的路径。该路径包括<xref linkend="guc-log-directory"/>目录和日志文件名。日志收集必须被启用，否则返回值为<literal>NULL</literal>。当多个日志文件存在并且每一个都有不同的格式时，不带参数调用<function>pg_current_logfile</function>会返回这样的文件的路径：在所有的文件中，没有任何文件的格式在列表<systemitem>stderr</systemitem>、<systemitem>csvlog</systemitem>中排在这个文件的格式前面。如果没有任何日志文件有上述格式，则返回<literal>NULL</literal>。要请求一种特定的文件格式，可以以<type>text</type>将<systemitem>csvlog</systemitem>或者<systemitem>stderr</systemitem>作为可选参数的值。当所请求的日志格式不是已配置的<xref linkend="guc-log-destination"/>时，会返回<literal>NULL</literal>。<function>pg_current_logfile</function>反映了<filename>current_logfiles</filename>文件的内容。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_my_temp_schema</function> returns the OID of the current
    session's temporary schema, or zero if it has none (because it has not
    created any temporary tables).
    <function>pg_is_other_temp_schema</function> returns true if the
    given OID is the OID of another session's temporary schema.
    (This can be useful, for example, to exclude other sessions' temporary
    tables from a catalog display.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_my_temp_schema</function>返回当前会话临时模式的 OID，如果没有使用临时模式（因为它没有创建任何临时表）则返回零。如果给定的 OID 是另一个会话的临时模式的 OID，则<function>pg_is_other_temp_schema</function>返回真（这是有用的，例如，要将其他会话的临时表从一个目录显示中排除）。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_notification_queue_usage</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_notification_queue_usage</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_listening_channels</function> returns a set of names of
    asynchronous notification channels that the current session is listening
    to.  <function>pg_notification_queue_usage</function> returns the
    fraction of the total available space for notifications currently
    occupied by notifications that are waiting to be processed, as a
    <type>double</type> in the range 0-1.
    See <xref linkend="sql-listen"/> and <xref linkend="sql-notify"/>
    for more information.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_listening_channels</function>返回当前会话正在监听的异步通知频道的名称的集合。<function>pg_notification_queue_usage</function>返回等待处理的通知占可用的通知空间的比例，它是一个 0-1 范围内的<type>double</type>值。详见<xref linkend="sql-listen"/>和<xref linkend="sql-notify"/>。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_postmaster_start_time</function> returns the
    <type>timestamp with time zone</type> when the
    server started.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_postmaster_start_time</function>返回服务器启动的<type>timestamp with time zone</type>。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_safe_snapshot_blocking_pids</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_safe_snapshot_blocking_pids</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_safe_snapshot_blocking_pids</function> returns an array of
    the process IDs of the sessions that are blocking the server process with
    the specified process ID from acquiring a safe snapshot, or an empty array
    if there is no such server process or it is not blocked.  A session
    running a <literal>SERIALIZABLE</literal> transaction blocks
    a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal> transaction from
    acquiring a snapshot until the latter determines that it is safe to avoid
    taking any predicate locks.  See <xref linkend="xact-serializable"/> for
    more information about serializable and deferrable transactions.  Frequent
    calls to this function could have some impact on database performance,
    because it needs access to the predicate lock manager's shared
    state for a short time.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_safe_snapshot_blocking_pids</function>一个进程ID的数组，它们代表阻止指定进程ID对应的服务器进程获取安全快照的会话，如果没有这类服务器进程或者它没有被阻塞，则会返回一个空数组。一个运行着<literal>SERIALIZABLE</literal>事务的会话会阻止<literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>事务获取快照，直到后者确定避免拿到任何谓词锁是安全的。更多有关可序列化以及可延迟事务的信息请参考<xref linkend="xact-serializable"/>。频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要短时间访问谓词锁管理器的共享状态。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>version</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>version</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>version</function> returns a string describing the
    <productname>PostgreSQL</productname> server's version. You can also
    get this information from <xref linkend="guc-server-version"/> or
    for a machine-readable version, <xref linkend="guc-server-version-num"/>.
    Software developers should use <literal>server_version_num</literal>
    (available since 8.2) or <xref linkend="libpq-pqserverversion"/> instead
    of parsing the text version.
   </para>
____________________________________________________________________________-->
   <para>
    <function>version</function>返回一个描述<productname>PostgreSQL</productname>服务器版本的字符串。你也可以从<xref linkend="guc-server-version"/>或者一个机器可读的版本<xref linkend="guc-server-version-num"/>得到这个信息。软件开发者应该使用<literal>server_version_num</literal>（从 8.2 开始可用）或者<xref linkend="libpq-pqserverversion"/>，而不必解析文本形式的版本。
   </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-access-table"/> lists functions that
   allow the user to query object access privileges programmatically.
   See <xref linkend="ddl-priv"/> for more information about
   privileges.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-access-table"/>列出那些允许用户编程查询对象访问权限的函数。参阅<xref linkend="ddl-priv"/>获取更多有关权限的信息。
  </para>

   <table id="functions-info-access-table">
<!--==========================orignal english content==========================
    <title>Access Privilege Inquiry Functions</title>
____________________________________________________________________________-->
    <title>访问权限查询函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for any column of table</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表中任意列上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for any column of table</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表中任意列上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for column</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有列的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for column</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有列的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for database</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有数据库的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for database</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有数据库的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for foreign-data wrapper</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有外部数据包装器上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for foreign-data wrapper</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有外部数据包装器上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for function</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有函数上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for function</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有函数上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for language</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有语言上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for language</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有语言上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for schema</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有模式上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for schema</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有模式上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for sequence</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有序列上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for sequence</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有序列上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for foreign server</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有外部服务器上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for foreign server</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有外部服务器上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for table</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for table</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for tablespace</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有表空间上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for tablespace</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有表空间上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>user</parameter>,
                                  <parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>user</parameter>,
                                  <parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有类型的特权</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有类型的特权</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does user have privilege for role</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>用户有没有角色上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have privilege for role</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户有没有角色上的权限</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>row_security_active</function>(<parameter>table</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>does current user have row level security active for table</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>row_security_active</function>(<parameter>table</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>当前用户是否在表上开启了行级安全性</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>has_type_privilege</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>has_type_privilege</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>row_security_active</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>row_security_active</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>has_table_privilege</function> checks whether a user
    can access a table in a particular way.  The user can be
    specified by name, by OID (<literal>pg_authid.oid</literal>),
    <literal>public</literal> to indicate the PUBLIC pseudo-role, or if the argument is
    omitted
    <function>current_user</function> is assumed.  The table can be specified
    by name or by OID.  (Thus, there are actually six variants of
    <function>has_table_privilege</function>, which can be distinguished by
    the number and types of their arguments.)  When specifying by name,
    the name can be schema-qualified if necessary.
    The desired access privilege type
    is specified by a text string, which must evaluate to one of the
    values <literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
    <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>.  Optionally,
    <literal>WITH GRANT OPTION</literal> can be added to a privilege type to test
    whether the privilege is held with grant option.  Also, multiple privilege
    types can be listed separated by commas, in which case the result will
    be <literal>true</literal> if any of the listed privileges is held.
    (Case of the privilege string is not significant, and extra whitespace
    is allowed between but not within privilege names.)
    Some examples:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_table_privilege</function>判断一个用户是否可以用某种特定的方式访问一个表。 该用户可以通过名字或者 OID （<literal>pg_authid.oid</literal>） 来指定，也可以用<literal>public</literal>表示 PUBLIC 伪角色。如果省略该参数，则使用<function>current_user</function>。 该表可以通过名字或者 OID 指定（因此，实际上有六种 <function>has_table_privilege</function>的变体，我们可以通过它们的参数数目和类型来区分它们） 。如果用名字指定，那么在必要时该名字可以是模式限定的。 所希望的权限类型是用一个文本串来指定的，它必须是下面的几个值之一： <literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</literal>、<literal>REFERENCES</literal>或<literal>TRIGGER</literal>。<literal>WITH GRANT OPTION</literal>可以被选择增加到一个权限类型来测试是否该权限是使用转授选项得到。另外，可以使用逗号分隔来列出多个权限类型，在这种情况下只要具有其中之一的权限则结果为<literal>真</literal>（权限字符串的大小写并不重要，可以在权限名称之间出现额外的空白，但是在权限名内部不能有空白）。一些例子：
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_sequence_privilege</function> checks whether a user
    can access a sequence in a particular way.  The possibilities for its
    arguments are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to one of
    <literal>USAGE</literal>,
    <literal>SELECT</literal>, or
    <literal>UPDATE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_sequence_privilege</function>检查一个用户是否能以某种特定方式访问一个序列。它的参数可能性和<function>has_table_privilege</function>相似。所希望测试的访问权限类型必须是下列之一：<literal>USAGE</literal>、<literal>SELECT</literal>或<literal>UPDATE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_any_column_privilege</function> checks whether a user can
    access any column of a table in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that the desired access privilege type must evaluate to some
    combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table,
    so <function>has_any_column_privilege</function> will always return
    <literal>true</literal> if <function>has_table_privilege</function> does for the same
    arguments.  But <function>has_any_column_privilege</function> also succeeds if
    there is a column-level grant of the privilege for at least one column.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_any_column_privilege</function>检查一个用户是否能以特定方式访问一个表的任意列。其参数可能性和<function>has_table_privilege</function>类似，除了所希望的访问权限类型必须是下面值的某种组合：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>或<literal>REFERENCES</literal>。注意在表层面上具有这些权限的任意一个都会隐式地把它授权给表中的每一列，因此如果<function>has_table_privilege</function>对同样的参数返回真则<function>has_any_column_privilege</function>将总是返回<literal>真</literal>。但是如果在至少一列上有一个该权限的列级授权，<function>has_any_column_privilege</function>也会成功。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_column_privilege</function> checks whether a user
    can access a column in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    with the addition that the column can be specified either by name
    or attribute number.
    The desired access privilege type must evaluate to some combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_column_privilege</function>检查一个用户是否能以特定方式访问一个列。它的参数可能性与<function>has_table_privilege</function>类似，并且列还可以使用名字或者属性号来指定。希望的访问权限类型必须是下列值的某种组合：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>或<literal>REFERENCES</literal>。注意在表级别上具有这些权限中的任意一种将会隐式地把它授予给表上的每一列。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_database_privilege</function> checks whether a user
    can access a database in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal>,
    <literal>CONNECT</literal>,
    <literal>TEMPORARY</literal>, or
    <literal>TEMP</literal> (which is equivalent to
    <literal>TEMPORARY</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_database_privilege</function>检查一个用户是否能以特定方式访问一个数据库。它的参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是以下值的某种组合：<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>或<literal>TEMP</literal>（等价于<literal>TEMPORARY</literal>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_function_privilege</function> checks whether a user
    can access a function in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a function by a text string rather than by OID,
    the allowed input is the same as for the <type>regprocedure</type> data type
    (see <xref linkend="datatype-oid"/>).
    The desired access privilege type must evaluate to
    <literal>EXECUTE</literal>.
    An example is:
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_function_privilege</function>检查一个用户是否能以特定方式访问一个函数。其参数可能性类似<function>has_table_privilege</function>。在用一个文本串而不是 OID 指定一个函数时，允许的输入和<type>regprocedure</type>数据类型一样（参阅 <xref linkend="datatype-oid"/>）。希望的访问权限类型必须是<literal>EXECUTE</literal>。一个例子：
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_foreign_data_wrapper_privilege</function> checks whether a user
    can access a foreign-data wrapper in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_foreign_data_wrapper_privilege</function>检查一个用户是否能以特定方式访问一个外部数据包装器。它的参数可能性类似于<function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_language_privilege</function> checks whether a user
    can access a procedural language in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_language_privilege</function>检查一个用户是否可以以某种特定的方式访问一个过程语言。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_schema_privilege</function> checks whether a user
    can access a schema in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal> or
    <literal>USAGE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_schema_privilege</function>检查一个用户是否可以以某种特定的方式访问一个模式。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>CREATE</literal>或<literal>USAGE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_server_privilege</function> checks whether a user
    can access a foreign server in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_server_privilege</function>检查一个用户是否可以以某种特定的方式访问一个外部服务器。 其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>USAGE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>has_tablespace_privilege</function> checks whether a user
    can access a tablespace in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>CREATE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_tablespace_privilege</function>检查一个用户是否可以以某种特定的方式访问一个表空间。其参数可能性类似 <function>has_table_privilege</function>。希望的访问权限类型必须是<literal>CREATE</literal>。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <function>has_type_privilege</function> checks whether a user
    can access a type in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a type by a text string rather than by OID,
    the allowed input is the same as for the <type>regtype</type> data type
    (see <xref linkend="datatype-oid"/>).
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>has_type_privilege</function>检查一个用户是否能以特定的方式访问一种类型。其参数的可能性类同于<function>has_table_privilege</function>。在用字符串而不是 OID 指定类型时，允许的输入和<type>regtype</type>数据类型相同（见<xref linkend="datatype-oid"/>）。期望的访问特权类型必须等于<literal>USAGE</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_has_role</function> checks whether a user
    can access a role in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that <literal>public</literal> is not allowed as a user name.
    The desired access privilege type must evaluate to some combination of
    <literal>MEMBER</literal> or
    <literal>USAGE</literal>.
    <literal>MEMBER</literal> denotes direct or indirect membership in
    the role (that is, the right to do <command>SET ROLE</command>), while
    <literal>USAGE</literal> denotes whether the privileges of the role
    are immediately available without doing <command>SET ROLE</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_has_role</function>检查一个用户是否可以以某种特定的方式访问一个角色。其参数可能性类似 <function>has_table_privilege</function>，除了<literal>public</literal>不能被允许作为一个用户名。希望的访问权限类型必须是下列值的某种组合：<literal>MEMBER</literal>或<literal>USAGE</literal>。<literal>MEMBER</literal>表示该角色中的直接或间接成员关系（即使用<command>SET ROLE</command>的权力），而<literal>USAGE</literal>表示不做<command>SET ROLE</command>的情况下该角色的权限是否立即可用。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <function>row_security_active</function> checks whether row level
    security is active for the specified table in the context of the
    <function>current_user</function> and environment. The table can
    be specified by name or by OID.
   </para>
____________________________________________________________________________-->
   <para>
    <function>row_security_active</function>检查在
    <function>current_user</function>的上下文和环境中是否为指定的
    表激活了行级安全性。表可以用名称或者 OID 指定。
   </para>
<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-aclitem-fn-table"/> shows the operators
   available for the <type>aclitem</type> type, which is the catalog
   representation of access privileges.  See <xref linkend="ddl-priv"/>
   for information about how to read access privilege values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-aclitem-fn-table"/> 显示了<type>aclitem</type>类型的可用操作符，它是访问权限的目录表示。 有关如何读取访问权限值的信息，请参阅 <xref linkend="ddl-priv"/>。
  </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>acldefault</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>acldefault</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>aclitemeq</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>aclitemeq</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>aclcontains</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>aclcontains</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>aclexplode</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>aclexplode</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>makeaclitem</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>makeaclitem</primary>
   </indexterm>

    <table id="functions-aclitem-op-table">
<!--==========================orignal english content==========================
     <title><type>aclitem</type> Operators</title>
____________________________________________________________________________-->
     <title><type>aclitem</type> Operators</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>equal</entry>
        <entry><literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>equal</entry>
        <entry><literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>contains element</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>包含元素</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>contains element</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>包含元素</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-aclitem-fn-table"/> shows some additional
    functions to manage the <type>aclitem</type> type.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-aclitem-fn-table"/> 显示了一些额外的函数来管理<type>aclitem</type>类型。
   </para>

   <table id="functions-aclitem-fn-table">
<!--==========================orignal english content==========================
    <title><type>aclitem</type> Functions</title>
____________________________________________________________________________-->
    <title><type>aclitem</type> Functions</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>acldefault</function>(<parameter>type</parameter>,
        <parameter>ownerId</parameter>)</literal></entry>
       <entry><type>aclitem[]</type></entry>
       <entry>get the default access privileges for an object belonging to <parameter>ownerId</parameter></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>acldefault</function>(<parameter>type</parameter>,
        <parameter>ownerId</parameter>)</literal></entry>
       <entry><type>aclitem[]</type></entry>
       <entry>获取属于<parameter>ownerId</parameter>的对象的默认访问权限。</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>aclexplode</function>(<parameter>aclitem[]</parameter>)</literal></entry>
       <entry><type>setof record</type></entry>
       <entry>get <type>aclitem</type> array as tuples</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>aclexplode</function>(<parameter>aclitem[]</parameter>)</literal></entry>
       <entry><type>setof record</type></entry>
       <entry>获取 <type>aclitem</type> 数组为元组</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>makeaclitem</function>(<parameter>grantee</parameter>, <parameter>grantor</parameter>, <parameter>privilege</parameter>, <parameter>grantable</parameter>)</literal></entry>
       <entry><type>aclitem</type></entry>
       <entry>build an <type>aclitem</type> from input</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>makeaclitem</function>(<parameter>grantee</parameter>, <parameter>grantor</parameter>, <parameter>privilege</parameter>, <parameter>grantable</parameter>)</literal></entry>
       <entry><type>aclitem</type></entry>
       <entry>从输入中建立一个<type>aclitem</type>。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>acldefault</function> returns the built-in default access
    privileges for an object of type <parameter>type</parameter> belonging to
    role <parameter>ownerId</parameter>.  These represent the access
    privileges that will be assumed when an object's ACL entry is null.
    (The default access privileges are described in <xref linkend="ddl-priv"/>.)
    The <parameter>type</parameter> parameter is a <type>CHAR</type>: write
    'c' for <literal>COLUMN</literal>,
    'r' for <literal>TABLE</literal> and table-like objects,
    's' for <literal>SEQUENCE</literal>,
    'd' for <literal>DATABASE</literal>,
    'f' for <literal>FUNCTION</literal> or <literal>PROCEDURE</literal>,
    'l' for <literal>LANGUAGE</literal>,
    'L' for <literal>LARGE OBJECT</literal>,
    'n' for <literal>SCHEMA</literal>,
    't' for <literal>TABLESPACE</literal>,
    'F' for <literal>FOREIGN DATA WRAPPER</literal>,
    'S' for <literal>FOREIGN SERVER</literal>,
    or
    'T' for <literal>TYPE</literal> or <literal>DOMAIN</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>acldefault</function>返回属于角色<parameter>ownerId</parameter>的<parameter>type</parameter>类型的对象的内置默认访问权限。 这些代表了当对象的ACL条目为空时将被假定的访问权限。 (默认的访问权限在<xref linkend="ddl-priv"/>中描述了)。
     <parameter>type</parameter> 参数是一个 <type>CHAR</type>: 
    'c' for <literal>COLUMN</literal>,
    'r' for <literal>TABLE</literal> 和类表对象,
    's' for <literal>SEQUENCE</literal>,
    'd' for <literal>DATABASE</literal>,
    'f' for <literal>FUNCTION</literal> 或者 <literal>PROCEDURE</literal>,
    'l' for <literal>LANGUAGE</literal>,
    'L' for <literal>LARGE OBJECT</literal>,
    'n' for <literal>SCHEMA</literal>,
    't' for <literal>TABLESPACE</literal>,
    'F' for <literal>FOREIGN DATA WRAPPER</literal>,
    'S' for <literal>FOREIGN SERVER</literal>,
    'T' for <literal>TYPE</literal> 或者 <literal>DOMAIN</literal>.
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>aclexplode</function> returns an <type>aclitem</type> array
    as a set of rows. Output columns are grantor <type>oid</type>,
    grantee <type>oid</type> (<literal>0</literal> for <literal>PUBLIC</literal>),
    granted privilege as <type>text</type> (<literal>SELECT</literal>, ...)
    and whether the privilege is grantable as <type>boolean</type>.
    <function>makeaclitem</function> performs the inverse operation.
   </para>
____________________________________________________________________________-->
   <para>
    <function>aclexplode</function>返回一个<type>aclitem</type>数组作为行集。输出的列是grantor <type>oid</type>, grantee <type>oid</type> (<literal>0</literal> for <literal>PUBLIC</literal>), 被授权为 <type>text</type> (<literal>SELECT</literal>, ...)
    以及权限是否可以被授予<type>boolean</type>。<function>makeaclitem</function>执行反向操作。
   </para>
<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-schema-table"/> shows functions that
   determine whether a certain object is <firstterm>visible</firstterm> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  To list the names of all visible tables:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-schema-table"/>展示了决定是否一个特定对象在当前模式搜索路径中<firstterm>可见</firstterm>的函数。例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。这等价于在语句中表可以被用名称引用但不加显式的模式限定。要列出所有可见表的名字：
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>search path</primary>
    <secondary>object visibility</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>搜索路径</primary>
    <secondary>对象可见性</secondary>
   </indexterm>

   <table id="functions-info-schema-table">
<!--==========================orignal english content==========================
    <title>Schema Visibility Inquiry Functions</title>
____________________________________________________________________________-->
    <title>模式可见性查询函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is collation visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>排序规则在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is conversion visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>转换在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is function visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>函数在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is operator class visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符类在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is operator visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is operator family visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>操作符族在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_statistics_obj_is_visible(<parameter>stat_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is statistics object visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_statistics_obj_is_visible(<parameter>stat_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>是搜索路径中的统计信息对象</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is table visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>表在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is text search configuration visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索配置在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is text search dictionary visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索字典在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is text search parser visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索解析器在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is text search template visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>文本搜索模板在搜索路径中可见吗？</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>is type (or domain) visible in search path</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>类型（或域）在搜索路径中可见吗？</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_statistics_obj_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_statistics_obj_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Each function performs the visibility check for one type of database
    object.  Note that <function>pg_table_is_visible</function> can also be used
    with views, materialized views, indexes, sequences and foreign tables;
    <function>pg_function_is_visible</function> can also be used with
    procedures and aggregates;
    <function>pg_type_is_visible</function> can also be used with domains.
    For functions and operators, an object in
    the search path is visible if there is no object of the same name
    <emphasis>and argument data type(s)</emphasis> earlier in the path.  For operator
    classes, both name and associated index access method are considered.
   </para>
____________________________________________________________________________-->
   <para>
    每一个函数对一种数据库对象执行可见性检查。注意<function>pg_table_is_visible</function>也可被用于视图、物化视图、索引、序列和外部表，<function>pg_function_is_visible</function>也能被用于过程和聚集，<function>pg_type_is_visible</function>也可以被用于域。对于函数和操作符，如果在路径中更早的地方没有出现具有相同名称<emphasis>和参数数据类型</emphasis>的对象，该对象在搜索路径中是可见的。对于操作符类，名称和相关的索引访问方法都要考虑。
   </para>

<!--==========================orignal english content==========================
   <para>
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</type>, <type>regtype</type>,
    <type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>,
    or <type>regdictionary</type>),
    for example:
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
   </para>
____________________________________________________________________________-->
   <para>
    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<type>regclass</type>、<type>regtype</type>、<type>regprocedure</type>、<type>regoperator</type>、<type>regconfig</type>或<type>regdictionary</type>）将会很方便。例如：
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    注意以这种方式测试一个非模式限定的类型名没什么意义 &mdash; 如果该名称完全能被识别，它必须是可见的。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>format_type</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>format_type</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_statisticsobjdef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_statisticsobjdef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_index_column_has_property</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_index_column_has_property</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_index_has_property</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_index_has_property</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_indexam_has_property</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_indexam_has_property</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>collation for</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>collation for</primary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regnamespace</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regnamespace</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>to_regrole</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>to_regrole</primary>
   </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-catalog-table"/> lists functions that
   extract information from the system catalogs.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-catalog-table"/>列出了从系统目录抽取信息的函数。
  </para>

   <table id="functions-info-catalog-table">
<!--==========================orignal english content==========================
    <title>System Catalog Information Functions</title>
____________________________________________________________________________-->
    <title>系统目录信息函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get SQL name of a data type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个数据类型的 SQL 名字</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get definition of a constraint</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个约束的定义</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get definition of a constraint</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个约束的定义</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get definition of a function or procedure</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个函数或过程的定义</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get argument list of function's or procedure's definition (with default values)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个函数或过程定义的参数列表（带有默认值）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get argument list to identify a function or procedure (without default values)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得标识一个函数或过程的参数列表（不带默认值）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <literal>RETURNS</literal> clause for function (returns null for a procedure)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得函数的<literal>RETURNS</literal>子句（对过程返回空）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE INDEX</command> command for index</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得索引的<command>CREATE INDEX</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE INDEX</command> command for index,
       or definition of just one index column when
       <parameter>column_no</parameter> is not zero</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得索引的<command>CREATE INDEX</command>命令，或者当<parameter>column_no</parameter>为非零时只得到一个索引列的定义</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>get list of SQL keywords and their categories</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>获得 SQL 关键字的列表及其分类</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE RULE</command> command for rule</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得规则的<command>CREATE RULE</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE RULE</command> command for rule</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得规则的<command>CREATE RULE</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get name of the sequence that a serial or identity column uses</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得一个序列列或标识列使用的序列的名称</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_statisticsobjdef(<parameter>statobj_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE STATISTICS</command> command for extended statistics object</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_statisticsobjdef(<parameter>statobj_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为扩展的统计信息对象得到<command>CREATE STATISTICS</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>获得触发器的<command>CREATE [ CONSTRAINT ] TRIGGER</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>获得触发器的<command>CREATE [ CONSTRAINT ] TRIGGER</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>get role name with given OID</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>获得给定 OID 指定的角色名</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令（<emphasis>已废弃</emphasis>）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令（<emphasis>已废弃</emphasis>）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get underlying <command>SELECT</command> command for view or
              materialized view; lines with fields are wrapped to specified
              number of columns, pretty-printing is implied</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得视图或物化视图的底层<command>SELECT</command>命令；带域的行被包装成指定的列数，并隐含了优质打印</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_index_column_has_property(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>test whether an index column has a specified property</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_index_column_has_property(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>测试一个索引列是否有指定的性质</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_index_has_property(<parameter>index_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>test whether an index has a specified property</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_index_has_property(<parameter>index_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>测试一个索引是否有指定的性质</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_indexam_has_property(<parameter>am_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>test whether an index access method has a specified property</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_indexam_has_property(<parameter>am_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>测试一个索引访问方法是否有指定的性质</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>get the set of storage option name/value pairs</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>获得存储选项的名称/值对的集合</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
       <entry>get the set of database OIDs that have objects in the tablespace</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
       <entry>获得在该表空间中有对象的数据库的 OID 的集合</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get the path in the file system that this tablespace is located in</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得这个表空间所在的文件系统的路径</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>get the data type of any value</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>获得任意值的数据类型</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get the collation of the argument</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>获得该参数的排序规则</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
       <entry>get the OID of the named relation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
       <entry>得到指定关系的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
       <entry>get the OID of the named function</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
       <entry>得到指定函数的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
       <entry>get the OID of the named function</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
       <entry>得到指定函数的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
       <entry>get the OID of the named operator</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
       <entry>得到指定操作符的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
       <entry>get the OID of the named operator</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
       <entry>得到指定操作符的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>get the OID of the named type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>得到指定类型的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regnamespace(<parameter>schema_name</parameter>)</function></literal></entry>
       <entry><type>regnamespace</type></entry>
       <entry>get the OID of the named schema</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regnamespace(<parameter>schema_name</parameter>)</function></literal></entry>
       <entry><type>regnamespace</type></entry>
       <entry>得到指定模式的 OID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>to_regrole(<parameter>role_name</parameter>)</function></literal></entry>
       <entry><type>regrole</type></entry>
       <entry>get the OID of the named role</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>to_regrole(<parameter>role_name</parameter>)</function></literal></entry>
       <entry><type>regrole</type></entry>
       <entry>得到指定角色的 OID</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <function>format_type</function> returns the SQL name of a data type that
   is identified by its type OID and possibly a type modifier.  Pass NULL
   for the type modifier if no specific modifier is known.
  </para>
____________________________________________________________________________-->
  <para>
   <function>format_type</function>返回一个数据类型的 SQL 名称，它由它的类型 OID 标识并且可能是一个类型修饰符。如果不知道相关的修饰符，则为类型修饰符传递 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_keywords</function> returns a set of records describing
   the SQL keywords recognized by the server. The <structfield>word</structfield> column
   contains the keyword.  The <structfield>catcode</structfield> column contains a
   category code: <literal>U</literal> for unreserved, <literal>C</literal> for column name,
   <literal>T</literal> for type or function name, or <literal>R</literal> for reserved.
   The <structfield>catdesc</structfield> column contains a possibly-localized string
   describing the category.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_keywords</function>返回一组记录描述服务器识别的 SQL 关键字。<structfield>word</structfield>列包含关键字。<structfield>catcode</structfield>列包含一个分类码：<literal>U</literal>为未被预定，<literal>C</literal> 为列名，<literal>T</literal>类型或函数名，<literal>R</literal>为预留。<structfield>catdesc</structfield>列包含一个可能本地化的描述分类的字符串。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_constraintdef</function>,
   <function>pg_get_indexdef</function>, <function>pg_get_ruledef</function>,
   <function>pg_get_statisticsobjdef</function>, and
   <function>pg_get_triggerdef</function>, respectively reconstruct the
   creating command for a constraint, index, rule, extended statistics object,
   or trigger. (Note that this is a decompiled reconstruction, not the
   original text of the command.) <function>pg_get_expr</function> decompiles
   the internal form of an individual expression, such as the default value
   for a column.  It can be useful when examining the contents of system
   catalogs.  If the expression might contain Vars, specify the OID of the
   relation they refer to as the second parameter; if no Vars are expected,
   zero is sufficient. <function>pg_get_viewdef</function> reconstructs the
   <command>SELECT</command> query that defines a view. Most of these functions come
   in two variants, one of which can optionally <quote>pretty-print</quote> the
   result.  The pretty-printed format is more readable, but the default format
   is more likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</productname>; avoid using pretty-printed output for dump
   purposes.  Passing <literal>false</literal> for the pretty-print parameter yields
   the same result as the variant that does not have the parameter at all.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_constraintdef</function>、<function>pg_get_indexdef</function>、<function>pg_get_ruledef</function>、<function>pg_get_statisticsobjdef</function>和<function>pg_get_triggerdef</function>分别重建一个约束、索引、规则、扩展统计对象或触发器的创建命令（注意这是一个反编译的重构，而不是命令的原始文本）。<function>pg_get_expr</function>反编译一个表达式的内部形式，例如一个列的默认值。在检查系统目录内容时有用。如果表达式可能包含 Var，在第二个参数中指定它们引用的关系的 OID；如果不会出现 Var，第二个参数设置为 0 即可。<function>pg_get_viewdef</function>重构定义一个视图的<command>SELECT</command>查询。这些函数的大部分都有两种变体，一种可以可选地<quote>优质打印</quote>结果。优质打印的格式可读性更强，但是默认格式更可能被未来版本的<productname>PostgreSQL</productname>以相同的方式解释。在转出目的中避免使用优质打印输出。为优质打印参数传递<literal>假</literal>将得到和不带该参数的变体相同的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_functiondef</function> returns a complete
   <command>CREATE OR REPLACE FUNCTION</command> statement for a function.
   <function>pg_get_function_arguments</function> returns the argument list
   of a function, in the form it would need to appear in within
   <command>CREATE FUNCTION</command>.
   <function>pg_get_function_result</function> similarly returns the
   appropriate <literal>RETURNS</literal> clause for the function.
   <function>pg_get_function_identity_arguments</function> returns the
   argument list necessary to identify a function, in the form it
   would need to appear in within <command>ALTER FUNCTION</command>, for
   instance.  This form omits default values.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_functiondef</function>为一个函数返回一个完整的<command>CREATE OR REPLACE FUNCTION</command>语句。<function>pg_get_function_arguments</function>返回一个函数的参数列表，形式按照它们出现在<command>CREATE FUNCTION</command>中的那样。<function>pg_get_function_result</function>类似地返回函数的合适的<literal>RETURNS</literal>子句。<function>pg_get_function_identity_arguments</function>返回标识一个函数必要的参数列表，形式和它们出现在<command>ALTER FUNCTION</command>中的一样。这种形式忽略默认值。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_serial_sequence</function> returns the name of the
   sequence associated with a column, or NULL if no sequence is associated
   with the column.  If the column is an identity column, the associated
   sequence is the sequence internally created for the identity column.  For
   columns created using one of the serial types
   (<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>), it
   is the sequence created for that serial column definition.  In the latter
   case, this association can be modified or removed with <command>ALTER
   SEQUENCE OWNED BY</command>.  (The function probably should have been called
   <function>pg_get_owned_sequence</function>; its current name reflects the
   fact that it has typically been used with <type>serial</type>
   or <type>bigserial</type> columns.)  The first input parameter is a table name
   with optional schema, and the second parameter is a column name.  Because
   the first parameter is potentially a schema and table, it is not treated as
   a double-quoted identifier, meaning it is lower cased by default, while the
   second parameter, being just a column name, is treated as double-quoted and
   has its case preserved.  The function returns a value suitably formatted
   for passing to sequence functions
   (see <xref linkend="functions-sequence"/>).  A typical use is in reading the
   current value of a sequence for an identity or serial column, for example:
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_serial_sequence</function>返回与一个列相关联的序列的名称，如果与列相关联的序列则返回 NULL。如果该列是一个标识列，相关联的序列是为该标识列内部创建的序列。对于使用序列类型之一（<type>serial</type>、<type>smallserial</type>、<type>bigserial</type>）创建的列，它是为那个序列列定义创建的序列。在后一种情况中，这种关联可以用<command>ALTER SEQUENCE OWNED BY</command>修改或者移除（该函数可能应该已经被<function>pg_get_owned_sequence</function>调用，它当前的名称反映了它通常被<type>serial</type>或<type>bigserial</type>列使用）。第一个输入参数是一个带可选模式的表名，第二个参数是一个列名。因为第一个参数可能是一个模式和表，它不能按照一个双引号包围的标识符来对待，意味着它默认情况下是小写的。而第二个参数只是一个列名，将被当作一个双引号包围的来处理并且会保留其大小写。函数返回的值会被适当地格式化以便传递给序列函数（参见<xref linkend="functions-sequence"/>）。一种典型的用法是为标识列或者序列列读取当前值，例如：
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_userbyid</function> extracts a role's name given
   its OID.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_userbyid</function>抽取给定 OID 的角色的名称。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   <function>pg_index_column_has_property</function>,
   <function>pg_index_has_property</function>, and
   <function>pg_indexam_has_property</function> return whether the
   specified index column, index, or index access method possesses the named
   property. <literal>NULL</literal> is returned if the property name is not
   known or does not apply to the particular object, or if the OID or column
   number does not identify a valid object.  Refer to
   <xref linkend="functions-info-index-column-props"/> for column properties,
   <xref linkend="functions-info-index-props"/> for index properties, and
   <xref linkend="functions-info-indexam-props"/> for access method properties.
   (Note that extension access methods can define additional property names
   for their indexes.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_index_column_has_property</function>、<function>pg_index_has_property</function>和<function>pg_indexam_has_property</function>返回指定的索引列、索引或者索引访问方法是否具有指定性质。如果性质的名称找不到或者不适用于特定的对象，亦或者 OID 或者列号不表示合法的对象，则返回<literal>NULL</literal>。列的性质可参见<xref linkend="functions-info-index-column-props"/>，索引的性质可参见<xref linkend="functions-info-index-props"/>，访问方法的性质可参见<xref linkend="functions-info-indexam-props"/>（注意扩展访问方法可以为其索引定义额外的性质）。
  </para>

  <table id="functions-info-index-column-props">
<!--==========================orignal english content==========================
   <title>Index Column Properties</title>
____________________________________________________________________________-->
   <title>索引列属性</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>asc</literal></entry>
      <entry>Does the column sort in ascending order on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>asc</literal></entry>
      <entry>在向前扫描时列是按照升序排列吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>desc</literal></entry>
      <entry>Does the column sort in descending order on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>desc</literal></entry>
      <entry>在向前扫描时列是按照降序排列吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>Does the column sort with nulls first on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>在向前扫描时列排序会把空值排在前面吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>Does the column sort with nulls last on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>在向前扫描时列排序会把空值排在最后吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>Does the column possess any defined sort ordering?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>列具有已定义的排序顺序吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>Can the column be scanned in order by a <quote>distance</quote>
      operator, for example <literal>ORDER BY col &lt;-&gt; constant</literal> ?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>列能否通过一个<quote>distance</quote>操作符（例如<literal>ORDER BY col &lt;-&gt; constant</literal>）有序地扫描？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>Can the column value be returned by an index-only scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>列值是否可以通过一次只用索引扫描返回？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>Does the column natively support <literal>col = ANY(array)</literal>
      searches?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>列是否天然支持<literal>col = ANY(array)</literal>搜索？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>Does the column support <literal>IS NULL</literal> and
      <literal>IS NOT NULL</literal> searches?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>列是否支持<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>搜索？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-index-props">
<!--==========================orignal english content==========================
   <title>Index Properties</title>
____________________________________________________________________________-->
   <title>索引性质</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>Can the index be used in a <literal>CLUSTER</literal> command?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>索引是否可以用于<literal>CLUSTER</literal>命令？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>Does the index support plain (non-bitmap) scans?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>索引是否支持普通扫描（非位图）？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>Does the index support bitmap scans?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>索引是否支持位图扫描？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>Can the scan direction be changed in mid-scan (to
             support <literal>FETCH BACKWARD</literal> on a cursor without
             needing materialization)?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>在扫描中扫描方向能否被更改（为了支持游标上无需物化的<literal>FETCH BACKWARD</literal>）？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-indexam-props">
<!--==========================orignal english content==========================
   <title>Index Access Method Properties</title>
____________________________________________________________________________-->
   <title>索引访问方法性质</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>Does the access method support <literal>ASC</literal>,
      <literal>DESC</literal> and related keywords in
      <literal>CREATE INDEX</literal>?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>访问方法是否支持<literal>ASC</literal>、<literal>DESC</literal>以及<literal>CREATE INDEX</literal>中的有关关键词？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>Does the access method support unique indexes?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>访问方法是否支持唯一索引？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>Does the access method support indexes with multiple columns?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>访问方法是否支持多列索引？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>Does the access method support exclusion constraints?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>访问方法是否支持排除约束？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>Does the access method support the <literal>INCLUDE</literal>
        clause of <literal>CREATE INDEX</literal>?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>访问方法是否支持<literal>CREATE INDEX</literal>的<literal>INCLUDE</literal>子句？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <function>pg_options_to_table</function> returns the set of storage
   option name/value pairs
   (<replaceable>option_name</replaceable>/<replaceable>option_value</replaceable>) when passed
   <structname>pg_class</structname>.<structfield>reloptions</structfield> or
   <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.
  </para>
____________________________________________________________________________-->
  <para>
   当传入<structname>pg_class</structname>.<structfield>reloptions</structfield>或<structname>pg_attribute</structname>.<structfield>attoptions</structfield>时，<function>pg_options_to_table</function>返回存储选项名称/值对（<replaceable>option_name</replaceable>/<replaceable>option_value</replaceable>）的集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_tablespace_databases</function> allows a tablespace to be
   examined. It returns the set of OIDs of databases that have objects stored
   in the tablespace. If this function returns any rows, the tablespace is not
   empty and cannot be dropped. To display the specific objects populating the
   tablespace, you will need to connect to the databases identified by
   <function>pg_tablespace_databases</function> and query their
   <structname>pg_class</structname> catalogs.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_tablespace_databases</function>允许一个表空间被检查。它返回一组数据库的 OID，这些数据库都有对象存储在该表空间中。如果这个函数返回任何行，则该表空间为非空并且不能被删除。为了显示该表空间中的指定对象，你将需要连接到<function>pg_tablespace_databases</function>标识的数据库并且查询它们的<structname>pg_class</structname>目录。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_typeof</function> returns the OID of the data type of the
   value that is passed to it.  This can be helpful for troubleshooting or
   dynamically constructing SQL queries.  The function is declared as
   returning <type>regtype</type>, which is an OID alias type (see
   <xref linkend="datatype-oid"/>); this means that it is the same as an
   OID for comparison purposes but displays as a type name.  For example:
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-&minus;-&minus;-&minus;-&minus;-&minus;-
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
-&minus;-&minus;-&minus;-&minus;
      4
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_typeof</function>返回传递给它的值的数据类型的 OID。这在检修或者动态构建 SQL 查询时有用。函数被声明为返回<type>regtype</type>，它是一个 OID 别名类型（见<xref linkend="datatype-oid"/>）；这表明它和一个用于比较目的的 OID 相同，但是作为一个类型名称显示。例如：
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The expression <literal>collation for</literal> returns the collation of the
   value that is passed to it.  Example:
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "de_DE"
(1 row)
</programlisting>
  The value might be quoted and schema-qualified.  If no collation is derived
  for the argument expression, then a null value is returned.  If the argument
  is not of a collatable data type, then an error is raised.
  </para>
____________________________________________________________________________-->
  <para>
   表达式<literal>collation for</literal>返回传递给它的值的排序规则。例子：
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</programlisting>
  值可能被加上引号并且变成模式限定的。如果从参数表达式得不到排序规则，则返回一个空值。如果参数不是一个可排序的数据类型，则抛出一个错误。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   The <function>to_regclass</function>, <function>to_regproc</function>,
   <function>to_regprocedure</function>, <function>to_regoper</function>,
   <function>to_regoperator</function>, <function>to_regtype</function>,
   <function>to_regnamespace</function>, and <function>to_regrole</function>
   functions translate relation, function, operator, type, schema, and role
   names (given as <type>text</type>) to objects of
   type <type>regclass</type>, <type>regproc</type>, <type>regprocedure</type>,
   <type>regoper</type>, <type>regoperator</type>, <type>regtype</type>,
   <type>regnamespace</type>, and <type>regrole</type>
   respectively.  These functions differ from a cast from
   text in that they don't accept a numeric OID, and that they return null
   rather than throwing an error if the name is not found (or, for
   <function>to_regproc</function> and <function>to_regoper</function>, if
   the given name matches multiple objects).
  </para>
____________________________________________________________________________-->
  <para>
   <function>to_regclass</function>、<function>to_regproc</function>、<function>to_regprocedure</function>, <function>to_regoper</function>、<function>to_regoperator</function>、<function>to_regtype</function>、<function>to_regnamespace</function>和<function>to_regrole</function>函数把关系、函数、操作符、类型、模式和角色的名称（以<type>text</type>给出）分别转换成、<type>regclass</type>、<type>regproc</type>、<type>regprocedure</type>、<type>regoper</type>、<type>regoperator</type>、<type>regtype</type>、<type>regnamespace</type>和<type>regrole</type>对象。这些函数与 text 转换的不同在于它们不接受数字 OID，并且在名称无法找到时不会抛出错误而是返回空。对于<function>to_regproc</function>和<function>to_regoper</function>，如果给定名称匹配多个对象时返回空。
  </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_identify_object_as_address</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_identify_object_as_address</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_get_object_address</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_get_object_address</primary>
   </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-object-table"/> lists functions related to
   database object identification and addressing.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-object-table"/>列出了与数据库对象
   标识和定位有关的函数。
  </para>

   <table id="functions-info-object-table">
<!--==========================orignal english content==========================
    <title>Object Information and Addressing Functions</title>
____________________________________________________________________________-->
    <title>对象信息和定位函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_describe_object(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get description of a database object</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_describe_object(<parameter>catalog_id</parameter>, <parameter>object_id</parameter>, <parameter>object_sub_id</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>得到一个数据库对象的描述</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_identify_object(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> <type>text</type>, <parameter>name</parameter> <type>text</type>, <parameter>identity</parameter> <type>text</type></entry>
       <entry>get identity of a database object</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_identify_object(<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> <type>text</type>, <parameter>name</parameter> <type>text</type>, <parameter>identity</parameter> <type>text</type></entry>
       <entry>得到一个数据库对象的标识</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_identify_object_as_address(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type></entry>
       <entry>get external representation of a database object's address</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_identify_object_as_address(<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>name</parameter> <type>text[]</type>, <parameter>args</parameter> <type>text[]</type></entry>
       <entry>得到一个数据库对象的地址的外部表示</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_get_object_address(<parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type>)</function></literal></entry>
       <entry><parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type></entry>
       <entry>get address of a database object from its external representation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_get_object_address(<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> <type>text[]</type>, <parameter>args</parameter> <type>text[]</type>)</function></literal></entry>
       <entry><parameter>class_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>int32</type></entry>
       <entry>从一个数据库对象的内部表示得到它的地址</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <function>pg_describe_object</function> returns a textual description of a database
   object specified by catalog OID, object OID, and sub-object ID (such as
   a column number within a table; the sub-object ID is zero when referring
   to a whole object).
   This description is intended to be human-readable, and might be translated,
   depending on server configuration.
   This is useful to determine the identity of an object as stored in the
   <structname>pg_depend</structname> catalog.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_describe_object</function>返回由目录OID、对象OID以及子对象ID（例如表中的一个列号，当子对象引用了一整个对象时其ID为零）指定的数据库对象的文本描述。这种描述是为
   了人类可读的，并且可能是被翻译过的，具体取决于服务器配置。这有助于确定一
   个存储在<structname>pg_depend</structname>目录中的对象的标识。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_identify_object</function> returns a row containing enough information
   to uniquely identify the database object specified by catalog OID, object OID and
   sub-object ID.  This information is intended to be machine-readable,
   and is never translated.
   <parameter>type</parameter> identifies the type of database object;
   <parameter>schema</parameter> is the schema name that the object belongs in, or
   <literal>NULL</literal> for object types that do not belong to schemas;
   <parameter>name</parameter> is the name of the object, quoted if necessary,
   if the name (along with schema name, if pertinent) is sufficient to
   uniquely identify the object, otherwise <literal>NULL</literal>;
   <parameter>identity</parameter> is the complete object identity, with the
   precise format depending on object type, and each name within the format
   being schema-qualified and quoted as necessary.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_identify_object</function>返回一行，其中包含有足以唯一标识
   由目录 OID、对象 OID 和一个（可能为零的）子对象 ID 指定的数据库对象的信息。
   该信息是共机器读取的，并且不会被翻译。<parameter>type</parameter>标识数据库对象
   的类型；<parameter>schema</parameter>是该对象所属的模式名，如果对象类型不属于
   模式则为<literal>NULL</literal>；如果名称（加上方案名，如果相关）足以唯一标识对象，则<parameter>name</parameter>就是对象的名称（必要时会被加上引号），否则为<literal>NULL</literal>；<parameter>identity</parameter>是完整的对象标识，
   它会表现为与对象类型相关的精确格式，并且如有必要，该格式中的每个部分都会
   被模式限定。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_identify_object_as_address</function> returns a row containing
   enough information to uniquely identify the database object specified by
   catalog OID, object OID and sub-object ID.  The returned
   information is independent of the current server, that is, it could be used
   to identify an identically named object in another server.
   <parameter>type</parameter> identifies the type of database object;
   <parameter>object_names</parameter> and <parameter>object_args</parameter>
   are text arrays that together form a reference to the object.
   These three values can be passed to
   <function>pg_get_object_address</function> to obtain the internal address
   of the object.
   This function is the inverse of <function>pg_get_object_address</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_identify_object_as_address</function>返回一行，其中包含有
   足以唯一标识由目录 OID、对象 OID 和一个（可能为零的）子对象 ID 指定的数据
   库对象的信息。返回的信息独立于当前服务器，也就是说，它可以被用来在另一个
   服务器中标识一个具有相同命名的对象。<parameter>type</parameter>标识数据库对象
   的类型；<parameter>object_names</parameter>和<parameter>object_args</parameter>是文本数组，它们一起
   构成了对对象的引用。这三个值可以被传递给
   <function>pg_get_object_address</function>以获得该对象的内部地址。这个函数是
   <function>pg_get_object_address</function>的逆函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>pg_get_object_address</function> returns a row containing enough
   information to uniquely identify the database object specified by its
   type and object name and argument arrays.  The returned values are the
   ones that would be used in system catalogs such as <structname>pg_depend</structname>
   and can be passed to other system functions such as
   <function>pg_identify_object</function> or <function>pg_describe_object</function>.
   <parameter>classid</parameter> is the OID of the system catalog containing the
   object;
   <parameter>objid</parameter> is the OID of the object itself, and
   <parameter>objsubid</parameter> is the sub-object ID, or zero if none.
   This function is the inverse of <function>pg_identify_object_as_address</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_get_object_address</function>返回一行，其中包含有足以唯一
   标识由类型、对象名和参数数组指定的数据库对象的信息。返回值可以被用在诸如
   <structname>pg_depend</structname>等系统目录中并且可以被传递给
   <function>pg_identify_object</function>或<function>pg_describe_object</function>等其他
   系统函数。<parameter>class_id</parameter>是包含该对象的系统目录 OID；
   <parameter>objid</parameter>是对象本身的 OID，而
   <parameter>objsubid</parameter>是子对象 ID，如果没有则为零。这个函数是
   <function>pg_identify_object_as_address</function>的逆函数。
  </para>
  
<!--==========================orignal english content==========================
   <indexterm>
    <primary>col_description</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>col_description</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>obj_description</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>obj_description</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>注释</primary>
    <secondary sortas="database objects">关于数据库对象</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-info-comment-table"/>
    extract comments previously stored with the <xref linkend="sql-comment"/>
    command.  A null value is returned if no
    comment could be found for the specified parameters.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-info-comment-table"/>中展示的函数抽取注释，注释是由<xref linkend="sql-comment"/>命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </para>

   <table id="functions-info-comment-table">
<!--==========================orignal english content==========================
    <title>Comment Information Functions</title>
____________________________________________________________________________-->
    <title>注释信息函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get comment for a table column</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个表列获得注释</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get comment for a database object</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个数据库对象获得注释</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get comment for a database object (<emphasis>deprecated</emphasis>)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个数据库对象获得注释（<emphasis>已被废弃</emphasis>）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>get comment for a shared database object</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>为一个共享数据库对象获得注释</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>col_description</function> returns the comment for a table
    column, which is specified by the OID of its table and its column number.
    (<function>obj_description</function> cannot be used for table columns
    since columns do not have OIDs of their own.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>col_description</function>为一个表列返回注释，该表列由所在表的 OID 和它的列号指定（<function>obj_description</function>不能被用在表列，因为表列没有自己的 OID）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The two-parameter form of <function>obj_description</function> returns the
    comment for a database object specified by its OID and the name of the
    containing system catalog.  For example,
    <literal>obj_description(123456,'pg_class')</literal>
    would retrieve the comment for the table with OID 123456.
    The one-parameter form of <function>obj_description</function> requires only
    the object OID.  It is deprecated since there is no guarantee that
    OIDs are unique across different system catalogs; therefore, the wrong
    comment might be returned.
   </para>
____________________________________________________________________________-->
   <para>
    <function>obj_description</function>的双参数形式返回一个由其 OID 和所在系统目录名称指定的数据库对象的注释。例如，<literal>obj_description(123456,'pg_class')</literal>将会检索出 OID 为123456的表的注释。<function>obj_description</function>的单参数形式只要求对象 OID。它已经被废弃，因为无法保证 OID 在不同系统目录之间是唯一的；这样可能会返回错误的注释。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>shobj_description</function> is used just like
    <function>obj_description</function> except it is used for retrieving
    comments on shared objects.  Some system catalogs are global to all
    databases within each cluster, and the descriptions for objects in them
    are stored globally as well.
   </para>
____________________________________________________________________________-->
   <para>
    <function>shobj_description</function>用起来就像<function>obj_description</function>，但是前者是用于检索共享对象上的注释。某些系统目录对于一个集簇中的所有数据库是全局的，并且其中的对象的描述也是全局存储的。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_current</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_current</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_current_if_assigned</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_current_if_assigned</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>txid_status</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>txid_status</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-txid-snapshot"/>
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-txid-snapshot"/>中展示的函数以一种可导出的形式提供了服务器事务信息。这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </para>

   <table id="functions-txid-snapshot">
<!--==========================orignal english content==========================
    <title>Transaction IDs and Snapshots</title>
____________________________________________________________________________-->
    <title>事务 ID 和快照</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>get current transaction ID, assigning a new one if the current transaction does not have one</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得当前事务 ID，如果当前事务没有 ID 则分配一个新的 ID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_current_if_assigned()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>same as <function>txid_current()</function> but returns null instead of assigning a new transaction ID if none is already assigned</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_current_if_assigned()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>与<function>txid_current()</function>相同，但是在事务没有分配ID时是返回空值而不是分配一个新的事务ID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
       <entry>get current snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
       <entry>获得当前快照</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
       <entry>get in-progress transaction IDs in snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
       <entry>获得快照中正在进行的事务 ID</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>get <literal>xmax</literal> of snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得快照的<literal>xmax</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>get <literal>xmin</literal> of snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>获得快照的<literal>xmin</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>is transaction ID visible in snapshot? (do not use with subtransaction ids)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>事务 ID 在快照中可见吗？（不能用于子事务 ID）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>txid_status(<parameter>bigint</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>report the status of the given transaction: <literal>committed</literal>, <literal>aborted</literal>, <literal>in progress</literal>, or null if the transaction ID is too old</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>txid_status(<parameter>bigint</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>报告给定事务的状态：<literal>committed</literal>、<literal>aborted</literal>、<literal>in progress</literal>，如果事务ID太老则为空值</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The internal transaction ID type (<type>xid</type>) is 32 bits wide and
    wraps around every 4 billion transactions.  However, these functions
    export a 64-bit format that is extended with an <quote>epoch</quote> counter
    so it will not wrap around during the life of an installation.
    The data type used by these functions, <type>txid_snapshot</type>,
    stores information about transaction ID
    visibility at a particular moment in time.  Its components are
    described in <xref linkend="functions-txid-snapshot-parts"/>.
   </para>
____________________________________________________________________________-->
   <para>
    内部事务 ID 类型（<type>xid</type>）是 32 位宽并且每 40 亿个事务就会回卷。但是，这些函数导出一种 64 位格式，它被使用一个<quote>世代</quote>计数器，这样在一个安装的生命期内不会回卷。这些函数使用的数据类型<type>txid_snapshot</type>存储了在一个特定时刻有关事务 ID 可见性的信息。它的成分在<xref linkend="functions-txid-snapshot-parts"/>中描述。
   </para>

   <table id="functions-txid-snapshot-parts">
<!--==========================orignal english content==========================
    <title>Snapshot Components</title>
____________________________________________________________________________-->
    <title>快照成分</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Name</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>名称</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><type>xmin</type></entry>
       <entry>
         Earliest transaction ID (txid) that is still active.  All earlier
         transactions will either be committed and visible, or rolled
         back and dead.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>xmin</type></entry>
       <entry>
         仍然活动的最早的事务 ID （txid）。所有更早的事务要么已经被提交并且可见，要么已经被回滚并且死亡。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>xmax</type></entry>
       <entry>
        First as-yet-unassigned txid.  All txids greater than or equal to this
        are not yet started as of the time of the snapshot, and thus invisible.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>xmax</type></entry>
       <entry>
        第一个还未分配的 txid。所有大于等于它的 txid 在快照的时刻还没有开始，并且因此是不可见的。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>xip_list</type></entry>
       <entry>
        Active txids at the time of the snapshot.  The list
        includes only those active txids between <literal>xmin</literal>
        and <literal>xmax</literal>; there might be active txids higher
        than <literal>xmax</literal>.  A txid that is <literal>xmin &lt;= txid &lt;
        xmax</literal> and not in this list was already completed
        at the time of the snapshot, and thus either visible or
        dead according to its commit status.  The list does not
        include txids of subtransactions.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>xip_list</type></entry>
       <entry>
        在快照时刻活动的 txid。这个列表只包括那些位于<literal>xmin</literal>和<literal>xmax</literal>之间的活动 txid；可能有活动的超过<literal>xmax</literal>的 txid。一个满足<literal>xmin &lt;= txid &lt; xmax</literal>并且不在这个列表中的 txid 在快照时刻已经结束，并且因此根据其提交状态要么可见要么死亡。该列表不包括子事务的 txid。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <type>txid_snapshot</type>'s textual representation is
    <literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <type>txid_snapshot</type>的文本表示是<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>。例如<literal>10:20:10,14,15</literal>表示<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>txid_status(bigint)</function> reports the commit status of a recent
    transaction.  Applications may use it to determine whether a transaction
    committed or aborted when the application and database server become
    disconnected while a <literal>COMMIT</literal> is in progress.
    The status of a transaction will be reported as either
    <literal>in progress</literal>,
    <literal>committed</literal>, or <literal>aborted</literal>, provided that the
    transaction is recent enough that the system retains the commit status
    of that transaction.  If is old enough that no references to that
    transaction survive in the system and the commit status information has
    been discarded, this function will return NULL.  Note that prepared
    transactions are reported as <literal>in progress</literal>; applications must
    check <link
    linkend="view-pg-prepared-xacts"><literal>pg_prepared_xacts</literal></link> if they
    need to determine whether the txid is a prepared transaction.
   </para>
____________________________________________________________________________-->
   <para>
    <function>txid_status(bigint)</function>报告一个近期事务的提交状态。当一个应用和数据库服务器的连接在<literal>COMMIT</literal>正在进行时断开，应用可以用它来判断事务是提交了还是中止了。一个事务的状态将被报告为<literal>in progress</literal>、<literal>committed</literal>或者<literal>aborted</literal>，前提是该事务的发生时间足够近，这样系统才会保留它的提交状态。如果事务太老，则系统中不会留下对该事务的引用并且提交状态信息也已经被抛弃，那么这个函数将会返回NULL。注意，预备事务会被报告为<literal>in progress</literal>，如果应用需要判断该txid是否是一个预备事务，应用必须检查<link linkend="view-pg-prepared-xacts"><literal>pg_prepared_xacts</literal></link>。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-commit-timestamp"/>
    provide information about transactions that have been already committed.
    These functions mainly provide information about when the transactions
    were committed. They only provide useful data when
    <xref linkend="guc-track-commit-timestamp"/> configuration option is enabled
    and only for transactions that were committed after it was enabled.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-commit-timestamp"/>中展示的函数提供了有关于
    已经提交事务的信息。这些函数主要提供有关事务何时被提交的信息。只有当
    <xref linkend="guc-track-commit-timestamp"/>配置选项被启用时它们才能
    提供有用的数据，并且只对已提交事务提供数据。
   </para>

   <table id="functions-commit-timestamp">
<!--==========================orignal english content==========================
    <title>Committed Transaction Information</title>
____________________________________________________________________________-->
    <title>已提交事务信息</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_xact_commit_timestamp</primary></indexterm>
        <literal><function>pg_xact_commit_timestamp(<parameter>xid</parameter>)</function></literal>
       </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>get commit timestamp of a transaction</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_xact_commit_timestamp</primary></indexterm>
        <literal><function>pg_xact_commit_timestamp(<parameter>xid</parameter>)</function></literal>
       </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>得到一个事务的提交时间戳</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_last_committed_xact</primary></indexterm>
        <literal><function>pg_last_committed_xact()</function></literal>
       </entry>
       <entry><parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</parameter> <type>timestamp with time zone</type></entry>
       <entry>get transaction ID and commit timestamp of latest committed transaction</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_last_committed_xact</primary></indexterm>
        <literal><function>pg_last_committed_xact()</function></literal>
       </entry>
       <entry><parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</parameter> <type>timestamp with time zone</type></entry>
       <entry>得到最后一个已提交事务的事务 ID 和提交时间戳</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-controldata"/>
    print information initialized during <command>initdb</command>, such
    as the catalog version. They also show information about write-ahead
    logging and checkpoint processing. This information is cluster-wide,
    and not specific to any one database. They provide most of the same
    information, from the same source, as
    <xref linkend="app-pgcontroldata"/>, although in a form better suited
    to <acronym>SQL</acronym> functions.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-controldata"/>中所展示的函数能打印<command>initdb</command>期间初始化的信息，例如系统目录版本。它们也能显示有关预写式日志和检查点处理的信息。这些信息是集簇范围内的，不与任何特定的一个数据库相关。对于同一种来源，它们返回和<xref linkend="app-pgcontroldata"/>大致相同的信息，不过其形式更适合于<acronym>SQL</acronym>函数。
   </para>

   <table id="functions-controldata">
<!--==========================orignal english content==========================
    <title>Control Data Functions</title>
____________________________________________________________________________-->
    <title>控制数据函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_control_checkpoint</primary></indexterm>
        <literal><function>pg_control_checkpoint()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        Returns information about current checkpoint state.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_control_checkpoint</primary></indexterm>
        <literal><function>pg_control_checkpoint()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        返回有关当前检查点状态的信息。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_control_system</primary></indexterm>
        <literal><function>pg_control_system()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        Returns information about current control file state.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_control_system</primary></indexterm>
        <literal><function>pg_control_system()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        返回有关当前控制文件状态的信息。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_control_init</primary></indexterm>
        <literal><function>pg_control_init()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        Returns information about cluster initialization state.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_control_init</primary></indexterm>
        <literal><function>pg_control_init()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        返回有关集簇初始化状态的信息。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_control_recovery</primary></indexterm>
        <literal><function>pg_control_recovery()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        Returns information about recovery state.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_control_recovery</primary></indexterm>
        <literal><function>pg_control_recovery()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        返回有关恢复状态的信息。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_control_checkpoint</function> returns a record, shown in
    <xref linkend="functions-pg-control-checkpoint"/>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_control_checkpoint</function>返回一个<xref linkend="functions-pg-control-checkpoint"/>中所示的记录
   </para>

   <table id="functions-pg-control-checkpoint">
<!--==========================orignal english content==========================
    <title><function>pg_control_checkpoint</function> Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_checkpoint</function>列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>checkpoint_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>checkpoint_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>redo_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>redo_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>redo_wal_file</literal></entry>
       <entry><type>text</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>redo_wal_file</literal></entry>
       <entry><type>text</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>prev_timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>prev_timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>full_page_writes</literal></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>full_page_writes</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>next_xid</literal></entry>
       <entry><type>text</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>next_xid</literal></entry>
       <entry><type>text</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>next_oid</literal></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>next_oid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>next_multixact_id</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>next_multixact_id</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>next_multi_offset</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>next_multi_offset</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_xid_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_xid_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_active_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_active_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_multi_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_multi_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_multi_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_multi_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>oldest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>oldest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>newest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>newest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>checkpoint_time</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>checkpoint_time</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_control_system</function> returns a record, shown in
    <xref linkend="functions-pg-control-system"/>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_control_system</function>返回一个<xref linkend="functions-pg-control-system"/>中所示的记录
   </para>

   <table id="functions-pg-control-system">
<!--==========================orignal english content==========================
    <title><function>pg_control_system</function> Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_system</function>列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>pg_control_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>pg_control_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>catalog_version_no</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>catalog_version_no</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>system_identifier</literal></entry>
       <entry><type>bigint</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>system_identifier</literal></entry>
       <entry><type>bigint</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>pg_control_last_modified</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>pg_control_last_modified</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_control_init</function> returns a record, shown in
    <xref linkend="functions-pg-control-init"/>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_control_init</function>返回一个<xref linkend="functions-pg-control-init"/>中所示的记录
   </para>

   <table id="functions-pg-control-init">
<!--==========================orignal english content==========================
    <title><function>pg_control_init</function> Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_init</function>列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>max_data_alignment</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>max_data_alignment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>database_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>database_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>blocks_per_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>blocks_per_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>wal_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>wal_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>bytes_per_wal_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>bytes_per_wal_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>max_identifier_length</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>max_identifier_length</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>max_index_columns</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>max_index_columns</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>max_toast_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>max_toast_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>large_object_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>large_object_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>float4_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>float4_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>float8_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>float8_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>data_page_checksum_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>data_page_checksum_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_control_recovery</function> returns a record, shown in
    <xref linkend="functions-pg-control-recovery"/>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_control_recovery</function>返回一个<xref linkend="functions-pg-control-recovery"/>中所示的记录
   </para>

   <table id="functions-pg-control-recovery">
<!--==========================orignal english content==========================
    <title><function>pg_control_recovery</function> Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_recovery</function>列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>min_recovery_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>min_recovery_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>min_recovery_end_timeline</literal></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>min_recovery_end_timeline</literal></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>backup_start_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>backup_start_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>backup_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>backup_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><literal>end_of_backup_record_required</literal></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>end_of_backup_record_required</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="functions-admin">
<!--==========================orignal english content==========================
   <title>System Administration Functions</title>
____________________________________________________________________________-->
   <title>系统管理函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</productname> installation.
   </para>
____________________________________________________________________________-->
   <para>
    这一节描述的函数被用来控制和监视一个<productname>PostgreSQL</productname>安装。
   </para>

  <sect2 id="functions-admin-set">
<!--==========================orignal english content==========================
   <title>Configuration Settings Functions</title>
____________________________________________________________________________-->
   <title>配置设定函数</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-set-table"/> shows the functions
    available to query and alter run-time configuration parameters.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-set-table"/>展示了那些可以用于查询以及修改运行时配置参数的函数。
   </para>

   <table id="functions-admin-set-table">
<!--==========================orignal english content==========================
    <title>Configuration Settings Functions</title>
____________________________________________________________________________-->
    <title>配置设定函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter> [, <parameter>missing_ok</parameter> ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>get current value of setting</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter> [, <parameter>missing_ok</parameter> ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>获得设置的当前值</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>set parameter and return new value</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>设置一个参数并返回新值</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SET</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SET</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The function <function>current_setting</function> yields the
    current value of the setting <parameter>setting_name</parameter>.
    It corresponds to the <acronym>SQL</acronym> command
    <command>SHOW</command>.  An example:
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ISO, MDY
(1 row)
</programlisting>

    If there is no setting named <parameter>setting_name</parameter>,
    <function>current_setting</function> throws an error
    unless <parameter>missing_ok</parameter> is supplied and is
    <literal>true</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>current_setting</function>得到<parameter>setting_name</parameter>设置的当前值。它对应于<acronym>SQL</acronym>命令<command>SHOW</command>。一个例子：
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</programlisting>

    如果没有名为<parameter>setting_name</parameter>的设置，除非提供<parameter>missing_ok</parameter>并且其值为<literal>true</literal>，<function>current_setting</function>会抛出错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>set_config</function> sets the parameter
    <parameter>setting_name</parameter> to
    <parameter>new_value</parameter>.  If
    <parameter>is_local</parameter> is <literal>true</literal>, the
    new value will only apply to the current transaction. If you want
    the new value to apply for the current session, use
    <literal>false</literal> instead. The function corresponds to the
    SQL command <command>SET</command>. An example:
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 off
(1 row)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>set_config</function>将参数<parameter>setting_name</parameter>设置为<parameter>new_value</parameter>。如果 <parameter>is_local</parameter>设置为<literal>true</literal>，那么新值将只应用于当前事务。 如果你希望新值应用于当前会话，那么应该使用<literal>false</literal>。 它等效于 SQL 命令 <command>SET</command>。例如：
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-admin-signal">
<!--==========================orignal english content==========================
   <title>Server Signaling Functions</title>
____________________________________________________________________________-->
   <title>服务器信号函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>信号</primary>
    <secondary sortas="backend">后端进程</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-signal-table"/> send control signals to
    other server processes.  Use of these functions is restricted to
    superusers by default but access may be granted to others using
    <command>GRANT</command>, with noted exceptions.
   </para>
____________________________________________________________________________-->
   <para>
    在<xref linkend="functions-admin-signal-table"/>中展示的函数向其它服务器进程发送控制信号。默认情况下这些函数只能被超级用户使用，但是如果需要，可以利用<command>GRANT</command>把访问特权授予给其他用户。
   </para>

   <table id="functions-admin-signal-table">
<!--==========================orignal english content==========================
    <title>Server Signaling Functions</title>
____________________________________________________________________________-->
    <title>服务器信号函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Cancel a backend's current query.  This is also allowed if the
        calling role is a member of the role whose backend is being canceled or
        the calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can cancel superuser backends.
        </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>取消一个后端的当前查询。如果调用角色是被取消后端的拥有者角色的成员或者调用角色已经被授予<literal>pg_signal_backend</literal>，这也是允许的，不过只有超级用户才能取消超级用户的后端。
        </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Cause server processes to reload their configuration files</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>导致服务器进程重载它们的配置文件</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Rotate server's log file</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>切换服务器的日志文件</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Terminate a backend.  This is also allowed if the calling role
        is a member of the role whose backend is being terminated or the
        calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can terminate superuser backends.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>中止一个后端。如果调用角色是被取消后端的拥有者角色的成员或者调用角色已经被授予<literal>pg_signal_backend</literal>，这也是允许的，不过只有超级用户才能取消超级用户的后端。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Each of these functions returns <literal>true</literal> if
    successful and <literal>false</literal> otherwise.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数中的每一个都在成功时返回<literal>true</literal>，并且在失败时返回<literal>false</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_cancel_backend</function> and <function>pg_terminate_backend</function>
    send signals (<systemitem>SIGINT</systemitem> or <systemitem>SIGTERM</systemitem>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</application> on Unix or the <application>Task
    Manager</application> on <productname>Windows</productname>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_cancel_backend</function>和<function>pg_terminate_backend</function>向由进程 ID 标识的后端进程发送信号（分别是<systemitem>SIGINT</systemitem>或<systemitem>SIGTERM</systemitem>）。一个活动后端的进程 ID可以从<structname>pg_stat_activity</structname>视图的<structfield>pid</structfield>列中找到，或者通过在服务器上列出<command>postgres</command>进程（在 Unix 上使用<application>ps</application>或者在<productname>Windows</productname>上使用<application>任务管理器</application>）得到。一个活动后端的角色可以在<structname>pg_stat_activity</structname>视图的<structfield>usename</structfield>列中找到。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_reload_conf</function> sends a <systemitem>SIGHUP</systemitem> signal
    to the server, causing configuration files
    to be reloaded by all server processes.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_reload_conf</function>给服务器发送一个<systemitem>SIGHUP</systemitem>信号， 导致所有服务器进程重载配置文件。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_rotate_logfile</function> signals the log-file manager to switch
    to a new output file immediately.  This works only when the built-in
    log collector is running, since otherwise there is no log-file manager
    subprocess.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_rotate_logfile</function>给日志文件管理器发送信号，告诉它立即切换到一个新的输出文件。这个函数只有在内建日志收集器运行时才能工作，因为否则就不存在日志文件管理器子进程。
    subprocess.
   </para>

  </sect2>

  <sect2 id="functions-admin-backup">
<!--==========================orignal english content==========================
   <title>Backup Control Functions</title>
____________________________________________________________________________-->
   <title>备份控制函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>backup</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>backup</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_current_wal_flush_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_current_wal_flush_lsn</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_current_wal_insert_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_current_wal_insert_lsn</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_current_wal_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_current_wal_lsn</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_switch_wal</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_switch_wal</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_walfile_name</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_walfile_name</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_walfile_name_offset</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_walfile_name_offset</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_wal_lsn_diff</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_wal_lsn_diff</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-backup-table"/> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    non-exclusive <function>pg_start_backup</function>,
    non-exclusive <function>pg_stop_backup</function>,
    <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function>
    and <function>pg_wal_lsn_diff</function>).
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-backup-table"/>中展示的函数可以辅助制作在线备份。这些函数不能在恢复期间执行（非排他性的<function>pg_start_backup</function>，非排他性的<function>pg_stop_backup</function>，<function>pg_is_in_backup</function>、<function>pg_backup_start_time</function>和<function>pg_wal_lsn_diff</function>除外）。
   </para>

   <table id="functions-admin-backup-table">
<!--==========================orignal english content==========================
    <title>Backup Control Functions</title>
____________________________________________________________________________-->
    <title>备份控制函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Create a named point for performing restore (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>为执行恢复创建一个命名点（默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_current_wal_flush_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Get current write-ahead log flush location</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_current_wal_flush_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>得到当前的预写式日志刷写位置</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_current_wal_insert_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Get current write-ahead log insert location</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_current_wal_insert_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得当前预写式日志插入位置</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_current_wal_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Get current write-ahead log write location</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_current_wal_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得当前预写式日志写入位置</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</parameter> <type>text</type> <optional>, <parameter>fast</parameter> <type>boolean</type> <optional>, <parameter>exclusive</parameter> <type>boolean</type> </optional></optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</parameter> <type>text</type> <optional>, <parameter>fast</parameter> <type>boolean</type> <optional>, <parameter>exclusive</parameter> <type>boolean</type> </optional></optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>准备执行在线备份（默认只限于超级用户或者复制角色，但是可以授予其他用户 EXECUTE 特权来执行该函数）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Finish performing exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>完成执行排他的在线备份（默认只限于超级用户或者复制角色，但是可以授予其他用户 EXECUTE 特权来执行该函数）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_stop_backup(<parameter>exclusive</parameter> <type>boolean</type> <optional>, <parameter>wait_for_archive</parameter> <type>boolean</type> </optional>)</function></literal>
        </entry>
       <entry><type>setof record</type></entry>
       <entry>Finish performing exclusive or non-exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_stop_backup(<parameter>exclusive</parameter> <type>boolean</type>)</function></literal>
        </entry>
       <entry><type>setof record</type></entry>
       <entry>结束执行排他或者非排他的在线备份 （默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>True if an on-line exclusive backup is still in progress.</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果一个在线排他备份仍在进行中则为真。</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>Get start time of an on-line exclusive backup in progress.</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>获得一个进行中的在线排他备份的开始时间。</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_switch_wal()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_switch_wal()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>强制切换到一个新的预写式日志文件（默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_walfile_name(<parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Convert write-ahead log location to file name</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_walfile_name(<parameter>lsn</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>转换预写式日志位置字符串为文件名</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_walfile_name_offset(<parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type>, <type>integer</type></entry>
       <entry>Convert write-ahead log location to file name and decimal byte offset within file</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_walfile_name_offset(<parameter>lsn</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type>, <type>integer</type></entry>
       <entry>转换预写式日志位置字符串为文件名以及文件内的十进制字节偏移</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_wal_lsn_diff(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
       <entry>Calculate the difference between two write-ahead log locations</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_wal_lsn_diff(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
       <entry>计算两个预写式日志位置间的差别</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_start_backup</function> accepts an arbitrary user-defined label for
    the backup.  (Typically this would be the name under which the backup dump
    file will be stored.) When used in exclusive mode, the function writes a
    backup label file (<filename>backup_label</filename>) and, if there are any links
    in the <filename>pg_tblspc/</filename> directory, a tablespace map file
    (<filename>tablespace_map</filename>) into the database cluster's data directory,
    performs a checkpoint, and then returns the backup's starting write-ahead
    log location as text.  The user can ignore this result value, but it is
    provided in case it is useful. When used in non-exclusive mode, the
    contents of these files are instead returned by the
    <function>pg_stop_backup</function> function, and should be written to the backup
    by the caller.

<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/D4445B8
(1 row)
</programlisting>
    There is an optional second parameter of type <type>boolean</type>.  If <literal>true</literal>,
    it specifies executing <function>pg_start_backup</function> as quickly as
    possible.  This forces an immediate checkpoint which will cause a
    spike in I/O operations, slowing any concurrently executing queries.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_start_backup</function>接受一个参数，这个参数可以是备份的任意用户定义的标签（通常这是备份转储文件将被存储的名字）。当被用在排他模式中时，该函数向数据库集簇的数据目录写入一个备份标签文件（<filename>backup_label</filename>）和一个表空间映射文件（<filename>tablespace_map</filename>，如果在<filename>pg_tblspc/</filename>目录中有任何链接），执行一个检查点，然后以文本方式返回备份的起始预写式日志位置。用户可以忽略这个结果值，但是为了可能需要的场合我们还是提供该值。 当在非排他模式中使用时，这些文件的内容会转而由<function>pg_stop_backup</function>函数返回，并且应该由调用者写入到备份中去。
<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</programlisting>
    第二个参数是可选的，其类型为<type>boolean</type>。如果为<literal>true</literal>，它指定尽快执行<function>pg_start_backup</function>。这会强制一个立即执行的检查点，它会导致 I/O 操作的峰值，拖慢任何并发执行的查询。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    In an exclusive backup, <function>pg_stop_backup</function> removes the label file
    and, if it exists, the <filename>tablespace_map</filename> file created by
    <function>pg_start_backup</function>. In a non-exclusive backup, the contents of
    the <filename>backup_label</filename> and <filename>tablespace_map</filename> are returned
    in the result of the function, and should be written to files in the
    backup (and not in the data directory).  There is an optional second
    parameter of type <type>boolean</type>.  If false, the <function>pg_stop_backup</function>
    will return immediately after the backup is completed without waiting for
    WAL to be archived.  This behavior is only useful for backup
    software which independently monitors WAL archiving. Otherwise, WAL
    required to make the backup consistent might be missing and make the backup
    useless.  When this parameter is set to true, <function>pg_stop_backup</function>
    will wait for WAL to be archived when archiving is enabled; on the standby,
    this means that it will wait only when <varname>archive_mode = always</varname>.
    If write activity on the primary is low, it may be useful to run
    <function>pg_switch_wal</function> on the primary in order to trigger
    an immediate segment switch.
   </para>
____________________________________________________________________________-->
   <para>
    在一次排他备份中，<function>pg_stop_backup</function>会移除标签文件以及<function>pg_start_backup</function>创建的<filename>tablespace_map</filename>文件（如果存在）。在一次非排他备份中，<filename>backup_label</filename>和<filename>tablespace_map</filename>的内容会包含在该函数返回的结果中，并且应该被写入到该备份的文件中（这些内容不在数据目录中）。有一个可选的<type>boolean</type>类型的第二参数。如果为假，<function>pg_stop_backup</function>将在备份完成后立即返回而不等待WAL被归档。这种行为仅对独立监控WAL归档的备份软件有用。否则，让备份一致所要求的WAL可能会丢失，进而让备份变得毫无用处。当这个参数被设置为真时，在启用归档的前提下<function>pg_stop_backup</function>将等待WAL被归档，在后备服务器上，这意味只有<varname>archive_mode = always</varname>时才会等待。如果主服务器上的写活动很低，在主服务器上运行<function>pg_switch_wal</function>以触发一次即刻的段切换会很有用。
   </para>

<!--==========================orignal english content==========================
   <para>
    When executed on a primary, the function also creates a backup history file
    in the write-ahead log
    archive area. The history file includes the label given to
    <function>pg_start_backup</function>, the starting and ending write-ahead log locations for
    the backup, and the starting and ending times of the backup.  The return
    value is the backup's ending write-ahead log location (which again
    can be ignored).  After recording the ending location, the current
    write-ahead log insertion
    point is automatically advanced to the next write-ahead log file, so that the
    ending write-ahead log file can be archived immediately to complete the backup.
   </para>
____________________________________________________________________________-->
   <para>
    当在主服务器上执行时，该函数还在预写式日志归档区里创建一个备份历史文件。这个历史文件包含给予<function>pg_start_backup</function>的标签、备份的起始与终止预写式日志位置以及备份的起始和终止时间。返回值是备份的终止预写式日志位置（同样也可以被忽略）。在记录结束位置之后，当前预写式日志插入点被自动地推进到下一个预写式日志文件，这样结束的预写式日志文件可以立即被归档来结束备份。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_switch_wal</function> moves to the next write-ahead log file, allowing the
    current file to be archived (assuming you are using continuous archiving).
    The return value is the ending write-ahead log location + 1 within the just-completed write-ahead log file.
    If there has been no write-ahead log activity since the last write-ahead log switch,
    <function>pg_switch_wal</function> does nothing and returns the start location
    of the write-ahead log file currently in use.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_switch_wal</function>移动到下一个预写式日志文件，允许当前文件被归档（假定你正在使用连续归档）。返回值是在甘冈完成的预写式日志文件中结束预写式日志位置 + 1。如果从上一次预写式日志切换依赖没有预写式日志活动，<function>pg_switch_wal</function>不会做任何事情并且返回当前正在使用的预写式日志文件的开始位置。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_create_restore_point</function> creates a named write-ahead log
    record that can be used as recovery target, and returns the corresponding
    write-ahead log location.  The given name can then be used with
    <xref linkend="guc-recovery-target-name"/> to specify the point up to which
    recovery will proceed.  Avoid creating multiple restore points with the
    same name, since recovery will stop at the first one whose name matches
    the recovery target.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_create_restore_point</function>创建一个命名预写式日志记录，它可以被用作恢复目标，并且返回相应的预写式日志位置。这个给定的名字可以用于<xref linkend="guc-recovery-target-name"/>来指定恢复要进行到的点。避免使用同一个名称创建多个恢复点，因为恢复会停止在第一个匹配名称的恢复目标。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_current_wal_lsn</function> displays the current write-ahead log write
    location in the same format used by the above functions.  Similarly,
    <function>pg_current_wal_insert_lsn</function> displays the current write-ahead log
    insertion location and <function>pg_current_wal_flush_lsn</function> displays the
    current write-ahead log flush location. The insertion location is the <quote>logical</quote>
    end of the write-ahead log at any instant, while the write location is the end of
    what has actually been written out from the server's internal buffers and flush
    location is the location guaranteed to be written to durable storage. The write
    location is the end of what can be examined from outside the server, and is usually
    what you want if you are interested in archiving partially-complete write-ahead log
    files.  The insertion and flush locations are made available primarily for server
    debugging purposes.  These are both read-only operations and do not
    require superuser permissions.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_current_wal_lsn</function>以上述函数所使用的相同格式显示当前预写式日志的写位置。类似地，<function>pg_current_wal_insert_lsn</function>显示当前预写式日志插入点，而<function>pg_current_wal_flush_lsn</function>显示当前预写式日志的刷写点。在任何情况下，插入点是预写式日志的<quote>逻辑</quote>终止点，而写入位置是已经实际从服务器内部缓冲区写出的日志的终止点，刷写位置则是被确保写入到持久存储中的日志的终止点。写入位置是可以从服务器外部检查的终止点，对那些关注归档部分完成预写式日志文件的人来说，这就是他们需要的位置。插入和刷写点主要是为了服务器调试目的而存在的。这些都是只读操作并且不需要超级用户权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can use <function>pg_walfile_name_offset</function> to extract the
    corresponding write-ahead log file name and byte offset from the results of any of the
    above functions.  For example:
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    Similarly, <function>pg_walfile_name</function> extracts just the write-ahead log file name.
    When the given write-ahead log location is exactly at a write-ahead log file boundary, both
    these functions return the name of the preceding write-ahead log file.
    This is usually the desired behavior for managing write-ahead log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived.
   </para>
____________________________________________________________________________-->
   <para>
    你可以使用<function>pg_walfile_name_offset</function>从任何上述函数的结果中抽取相应的预写式日志文件名称以及字节偏移。例如：
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    相似地，<function>pg_walfile_name</function>只抽取预写式日志文件名。当给定的预写式日志位置正好在一个预写式日志文件的边界，这些函数都返回之前的预写式日志文件的名称。这对管理预写式日志归档行为通常是所希望的行为，因为前一个文件是当前需要被归档的最后一个文件。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_wal_lsn_diff</function> calculates the difference in bytes
    between two write-ahead log locations. It can be used with
    <structname>pg_stat_replication</structname> or some functions shown in
    <xref linkend="functions-admin-backup-table"/> to get the replication lag.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_wal_lsn_diff</function>以字节数计算两个预写式日志位置之间的差别。它可以和<structname>pg_stat_replication</structname>或<xref linkend="functions-admin-backup-table"/>中其他的函数一起使用来获得复制延迟。
   </para>

<!--==========================orignal english content==========================
   <para>
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving"/>.
   </para>
____________________________________________________________________________-->
   <para>
    关于正确使用这些函数的细节，请见<xref linkend="continuous-archiving"/>。
   </para>

  </sect2>

  <sect2 id="functions-recovery-control">
<!--==========================orignal english content==========================
   <title>Recovery Control Functions</title>
____________________________________________________________________________-->
   <title>恢复控制函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_last_wal_receive_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_last_wal_receive_lson</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_last_wal_replay_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_last_wal_replay_lsn</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-recovery-info-table"/> provide information
    about the current status of the standby.
    These functions may be executed both during recovery and in normal running.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-recovery-info-table"/>中展示的函数提供有关后备机当前状态的信息。这些函数可以在恢复或普通运行过程中被执行。
   </para>

   <table id="functions-recovery-info-table">
<!--==========================orignal english content==========================
    <title>Recovery Information Functions</title>
____________________________________________________________________________-->
    <title>恢复信息函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>True if recovery is still in progress.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果恢复仍在进行中，为真。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_last_wal_receive_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Get last write-ahead log location received and synced to disk by
        streaming replication. While streaming replication is in progress
        this will increase monotonically. If recovery has completed this will
        remain static at
        the value of the last WAL record received and synced to disk during
        recovery. If streaming replication is disabled, or if it has not yet
        started, the function returns NULL.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_last_wal_receive_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得最后一个收到并由流复制同步到磁盘的预写式日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中收到并同步到磁盘的最后一个 WAL 记录。如果流复制被禁用，或者还没有被启动，该函数返回 NULL。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_last_wal_replay_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Get last write-ahead log location replayed during recovery.
        If recovery is still in progress this will increase monotonically.
        If recovery has completed then this value will remain static at
        the value of the last WAL record applied during that recovery.
        When the server has been started normally without recovery
        the function returns NULL.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_last_wal_replay_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>获得恢复过程中被重放的最后一个预写式日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中被应用的最后一个 WAL 记录。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>Get time stamp of last transaction replayed during recovery.
        This is the time at which the commit or abort WAL record for that
        transaction was generated on the primary.
        If no transactions have been replayed during recovery, this function
        returns NULL.  Otherwise, if recovery is still in progress this will
        increase monotonically.  If recovery has completed then this value will
        remain static at the value of the last transaction applied during that
        recovery.  When the server has been started normally without recovery
        the function returns NULL.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>获得恢复过程中被重放的最后一个事务的时间戳。这是在主机上产生的事务的提交或中止 WAL 记录的时间。如果在恢复过程中没有事务被重放，这个函数返回 NULL。否则，如果恢复仍在进行这将单调增加。如果恢复已经完成，则这个值会保持静止在恢复过程中最后一个被应用的事务。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_is_wal_replay_paused</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_is_wal_replay_paused</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_promote</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_promote</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_wal_replay_pause</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_wal_replay_pause</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_wal_replay_resume</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_wal_replay_resume</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-recovery-control-table"/> control the progress of recovery.
    These functions may be executed only during recovery.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-recovery-control-table"/>中展示的函数空值恢复的进程。这些函数只能在恢复过程中被执行。
   </para>

   <table id="functions-recovery-control-table">
<!--==========================orignal english content==========================
    <title>Recovery Control Functions</title>
____________________________________________________________________________-->
    <title>恢复控制函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_is_wal_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>True if recovery is paused.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_is_wal_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>如果恢复被暂停，为真。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_promote(<parameter>wait</parameter> <type>boolean</type> DEFAULT true, <parameter>wait_seconds</parameter> <type>integer</type> DEFAULT 60)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>
        Promotes a physical standby server.  With <parameter>wait</parameter>
        set to <literal>true</literal> (the default), the function waits until
        promotion is completed or <parameter>wait_seconds</parameter> seconds
        have passed, and returns <literal>true</literal> if promotion is
        successful and <literal>false</literal> otherwise.
        If <parameter>wait</parameter> is set to <literal>false</literal>, the
        function returns <literal>true</literal> immediately after sending
        <literal>SIGUSR1</literal> to the postmaster to trigger the promotion.
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_promote(<parameter>wait</parameter> <type>boolean</type> DEFAULT true, <parameter>wait_seconds</parameter> <type>integer</type> DEFAULT 60)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>
        促进物理备用服务器。 当 <parameter>wait</parameter>设置为<literal>true</literal>（默认值）时，该函数将等待晋升完成或<parameter>wait_seconds</parameter>秒，如果晋升成功，则返回<literal>true</literal>，否则返回<literal>false</literal>。如果<parameter>wait</parameter>被设置为<literal>false</literal>，则会返回<literal>true</literal>。函数在发送后立即返回<literal>true</literal>。<literal>SIGUSR1</literal>给postmaster触发推广。此功能默认只限于超级用户，但其他用户 可以被授予EXECUTE来运行函数。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_wal_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_wal_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>立即暂停恢复（默认仅限于超级用户, 但是可以授予其他用户 EXECUTE 特权来执行该函数）。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_wal_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>Restarts recovery if it was paused (restricted to superusers by default, but other users can be granted EXECUTE to run the function).
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_wal_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>如果恢复被暂停，重启之（默认仅限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    While recovery is paused no further database changes are applied.
    If in hot standby, all new queries will see the same consistent snapshot
    of the database, and no further query conflicts will be generated until
    recovery is resumed.
   </para>
____________________________________________________________________________-->
   <para>
    在恢复被暂停时，不会有进一步的数据库改变被应用。如果在热备模式，所有新的查询将看到数据库的同一个一致快照，并且在恢复被继续之前不会有更多查询冲突会产生。
   </para>

<!--==========================orignal english content==========================
   <para>
    If streaming replication is disabled, the paused state may continue
    indefinitely without problem. While streaming replication is in
    progress WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
   </para>
____________________________________________________________________________-->
   <para>
    如果流复制被禁用，暂停状态可以无限制地继续而不出问题。在流复制进行时，WAL 记录将继续被接收，最后将会填满可用的磁盘空间，取决于暂停的持续时间、WAL 的产生率和可用的磁盘空间。
   </para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
<!--==========================orignal english content==========================
   <title>Snapshot Synchronization Functions</title>
____________________________________________________________________________-->
   <title>快照同步函数</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</firstterm> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</command> commands,
    so that one session sees the effects of that transaction and the other
    does not.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许数据库会话同步它们的快照。一个<firstterm>快照</firstterm>决定对于正在使用该快照的事务哪些数据是可见的。当两个或者更多个会话需要看到数据库中的相同内容时，就需要同步快照。如果两个会话独立开始其事务，就总是有可能有某个第三事务在两个<command>START TRANSACTION</command>命令的执行之间提交，这样其中一个会话就可以看到该事务的效果而另一个则看不到。
   </para>

<!--==========================orignal english content==========================
   <para>
    To solve this problem, <productname>PostgreSQL</productname> allows a transaction to
    <firstterm>export</firstterm> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</firstterm> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
   </para>
____________________________________________________________________________-->
   <para>
    为了解决这个问题，<productname>PostgreSQL</productname>允许一个事务<firstterm>导出</firstterm>它正在使用的快照。只要导出的事务仍然保持打开，其他事务可以<firstterm>导入</firstterm>它的快照，并且因此可以保证它们可以看到和第一个事务看到的完全一样的数据库视图。但是注意这些事务中的任何一个对数据库所作的更改对其他事务仍然保持不可见，和未提交事务所作的修改一样。因此这些事务是针对以前存在的数据同步，而对由它们自己所作的更改则采取正常的动作。
   </para>

<!--==========================orignal english content==========================
   <para>
    Snapshots are exported with the <function>pg_export_snapshot</function> function,
    shown in <xref linkend="functions-snapshot-synchronization-table"/>, and
    imported with the <xref linkend="sql-set-transaction"/> command.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-snapshot-synchronization-table"/>中所示，快照通过<function>pg_export_snapshot</function>函数导出，并且通过<xref linkend="sql-set-transaction"/>命令导入。
   </para>

   <table id="functions-snapshot-synchronization-table">
<!--==========================orignal english content==========================
    <title>Snapshot Synchronization Functions</title>
____________________________________________________________________________-->
    <title>快照同步函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Save the current snapshot and return its identifier</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>保存当前快照并返回它的标识符</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The function <function>pg_export_snapshot</function> saves the current snapshot
    and returns a <type>text</type> string identifying the snapshot.  This string
    must be passed (outside the database) to clients that want to import the
    snapshot.  The snapshot is available for import only until the end of the
    transaction that exported it.  A transaction can export more than one
    snapshot, if needed.  Note that doing so is only useful in <literal>READ
    COMMITTED</literal> transactions, since in <literal>REPEATABLE READ</literal> and
    higher isolation levels, transactions use the same snapshot throughout
    their lifetime.  Once a transaction has exported any snapshots, it cannot
    be prepared with <xref linkend="sql-prepare-transaction"/>.
   </para>
____________________________________________________________________________-->
   <para>
    函数<function>pg_export_snapshot</function>保存当前的快照并且返回一个<type>text</type>串标识该快照。该字符串必须被传递（到数据库外）给希望导入快照的客户端。直到导出快照的事务的末尾，快照都可以被导入。如果需要，一个事务可以导出多于一个快照。注意这样做只在 <literal>READ COMMITTED</literal>事务中有用，因为在<literal>REPEATABLE READ</literal>和更高隔离级别中，事务在它们的生命期中都使用同一个快照。一旦一个事务已经导出了任何快照，它不能使用<xref linkend="sql-prepare-transaction"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    See  <xref linkend="sql-set-transaction"/> for details of how to use an
    exported snapshot.
   </para>
____________________________________________________________________________-->
   <para>
    关于如何使用一个已导出快照的细节请见<xref linkend="sql-set-transaction"/>.
   </para>
  </sect2>
  
  <sect2 id="functions-replication">
<!--==========================orignal english content==========================
   <title>Replication Functions</title>
____________________________________________________________________________-->
   <title>复制函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown
    in <xref linkend="functions-replication-table"/> are for
    controlling and interacting with replication features.
    See <xref linkend="streaming-replication"/>,
    <xref linkend="streaming-replication-slots"/>, and
    <xref linkend="replication-origins"/>
    for information about the underlying features.
    Use of functions for replication origin is restricted to superusers.
    Use of functions for replication slot is restricted to superusers
    and users having <literal>REPLICATION</literal> privilege.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-replication-table"/>中展示的函数
    用于控制以及与复制特性交互。有关底层特性的信息请见
    <xref linkend="streaming-replication"/>、
    <xref linkend="streaming-replication-slots"/>以及
    <xref linkend="replication-origins"/>。复制原点函数的使用仅限于超级用户。 复制槽的函数只限于超级用户和拥有<literal>REPLICATION</literal>权限的用户。
   </para>

<!--==========================orignal english content==========================
   <para>
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication"/>.
   </para>
____________________________________________________________________________-->
   <para>
    很多这些函数在复制协议中都有等价的命令，见
    <xref linkend="protocol-replication"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The functions described in
    <xref linkend="functions-admin-backup"/>,
    <xref linkend="functions-recovery-control"/>, and
    <xref linkend="functions-snapshot-synchronization"/>
    are also relevant for replication.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-backup"/>、
    <xref linkend="functions-recovery-control"/>和
    <xref linkend="functions-snapshot-synchronization"/>
    中描述的函数也与复制相关。
   </para>

   <table id="functions-replication-table">
<!--==========================orignal english content==========================
    <title>Replication <acronym>SQL</acronym> Functions</title>
____________________________________________________________________________-->
    <title>复制 <acronym>SQL</acronym> 函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. The optional second parameter,
        when <literal>true</literal>, specifies that the <acronym>LSN</acronym> for this
        replication slot be reserved immediately; otherwise
        the <acronym>LSN</acronym> is reserved on first connection from a streaming
        replication client. Streaming changes from a physical slot is only
        possible with the streaming-replication protocol &mdash;
        see <xref linkend="protocol-replication"/>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by current session. Temporary slots are also
        released upon any error. This function corresponds
        to the replication protocol command <literal>CREATE_REPLICATION_SLOT
        ... PHYSICAL</literal>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type> </optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        创建一个新的名为<parameter>slot_name</parameter>的物理复制槽。第二个参数是可选的，当它为<literal>true</literal>时，立即为这个物理槽指定要被保留的<acronym>LSN</acronym>。否则该<acronym>LSN</acronym>会被保留在来自一个流复制客户端的第一个连接上。来自一个物理槽的流改变只可能出现在使用流复制协议时 &mdash; 见<xref linkend="protocol-replication"/>。当可选的第三参数<parameter>temporary</parameter>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。临时槽也会在发生任何错误时被释放。这个函数对应于复制协议命令<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</literal>. For logical slots, this must
        be called when connected to the same database the slot was created on.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        丢弃名为<parameter>slot_name</parameter>的物理或逻辑复制槽。
        和复制协议命令<literal>DROP_REPLICATION_SLOT</literal>相同。对于逻辑槽，在连接到在其中创建该槽的同一个数据库时，必须调用这个函数。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by current session. Temporary slots are also
        released upon any error. A call to this function has the same
        effect as the replication protocol command
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        使用输出插件<parameter>plugin</parameter>创建一个名为
        <parameter>slot_name</parameter>的新逻辑（解码）复制槽。当可选的第三参数<parameter>temporary</parameter>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。临时槽也会在发生任何错误时被释放。对这个函数的调用与复制协议命令
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>具有相同的效果。
       </entry>
      </row>
<!--==========================orignal english content==========================
<row>
       <entry>
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_physical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        Copies an existing physical replication slot named <parameter>src_slot_name</parameter>
        to a physical replication slot named <parameter>dst_slot_name</parameter>.
        The copied physical slot starts to reserve WAL from the same <acronym>LSN</acronym> as the
        source slot.
        <parameter>temporary</parameter> is optional. If <parameter>temporary</parameter>
        is omitted, the same value as the source slot is used.
       </entry>
      </row>
____________________________________________________________________________-->
<row>
       <entry>
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_physical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
         将一个名为<parameter>src_slot_name</parameter>的现有物理复制槽复制到一个名为<parameter>dst_slot_name</parameter>的物理复制槽。被复制的物理槽开始从与源槽相同的<acronym>LSN</acronym>开始保留WAL。<parameter>temporary</parameter>是可选的。如果省略了<parameter>temporary</parameter>，则使用与源槽相同的值。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_logical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type></optional></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        Copies an existing logical replication slot named <parameter>src_slot_name</parameter>
        to a logical replication slot named <parameter>dst_slot_name</parameter>
        while changing the output plugin and persistence. The copied logical slot starts
        from the same <acronym>LSN</acronym> as the source logical slot. Both
        <parameter>temporary</parameter> and <parameter>plugin</parameter> are optional.
        If <parameter>temporary</parameter> or <parameter>plugin</parameter> are omitted,
        the same values as the source logical slot are used.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_logical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type></optional></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        复制一个名为<parameter>src_slot_name</parameter>的现有逻辑复制槽。到一个名为<parameter>dst_slot_name</parameter>的逻辑复制槽。同时改变输出插件和持久性。被复制的逻辑槽开始  来自与源逻辑槽相同的<acronym>LSN</acronym>。这两个 <parameter>temporary</parameter>和<parameter>plugin</parameter>是可选的。如果省略了<parameter>temporary</parameter>或<parameter>plugin</parameter>。使用与源逻辑槽相同的值。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point at which since changes have been consumed last.  If
        <parameter>upto_lsn</parameter> and <parameter>upto_nchanges</parameter> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</parameter> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        返回槽<parameter>slot_name</parameter>中的改变，从上一次已经被消费的点开始返回。
        如果<parameter>upto_lsn</parameter>和<parameter>upto_nchanges</parameter>为 NULL，逻辑解码将一
        直继续到 WAL 的末尾。如果<parameter>upto_lsn</parameter>为非 NULL，解码将只包括那些在指
        定 LSN 之前提交的事务。如果<parameter>upto_nchanges</parameter>为非 NULL，
        解码将在其产生的行数超过指定值后停止。不过要注意，
        被返回的实际行数可能更大，因为对这个限制的检查只会在增加了解码每个新的提交事务产生
        的行之后进行。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>text</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变不会被消费， 即在未来的调用中还会返回这些改变。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type> and that
        changes are not consumed; that is, they will be returned again
        on future calls.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回并且这些改变不会被消费，
        即在未来的调用中还会返回这些改变。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <literal><function>pg_replication_slot_advance(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>end_lsn</parameter> <type>pg_lsn</type>)
        <type>bool</type>
       </entry>
       <entry>
        Advances the current confirmed position of a replication slot named
        <parameter>slot_name</parameter>. The slot will not be moved backwards,
        and it will not be moved beyond the current insert location. Returns
        the name of the slot and the real position to which it was advanced to.
        The information of the updated slot is written out at the follow-up
        checkpoint if any advancing is done. In the event of a crash, the
        slot may return to an earlier position.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <literal><function>pg_replication_slot_advance(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>end_lsn</parameter> <type>pg_lsn</type>)
        <type>bool</type>
       </entry>
       <entry>
        将复制槽的当前确认的位置提前到名为<parameter>slot_name</parameter>的复制槽的当前确认位置。该槽不会向后移动，也不会移动到当前插入位置之外。返回该槽的名称和它被推进到的真实位置。
        如果有任何推进，则在后续的检查点中写出更新后的槽的信息。如果发生崩溃，该槽位可能会返回到之前的位置。
       </entry>
      </row>
      
<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-create">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <literal><function>pg_replication_origin_create(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        Create a replication origin with the given external
        name, and return the internal id assigned to it.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-create">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <literal><function>pg_replication_origin_create(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        用给定的外部名称创建一个复制源，并且返回分配给它的内部 id。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-drop">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <literal><function>pg_replication_origin_drop(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Delete a previously created replication origin, including any
        associated replay progress.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-drop">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <literal><function>pg_replication_origin_drop(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        删除一个之前创建的复制源，包括任何相关的重放进度。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <literal><function>pg_replication_origin_oid(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        Lookup a replication origin by name and return the internal id. If no
        corresponding replication origin is found an error is thrown.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <literal><function>pg_replication_origin_oid(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
        用名称查找复制源并且返回内部 id。如果没有找到则抛出错误。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-session-setup">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_setup(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Mark the current session as replaying from the given
        origin, allowing replay progress to be tracked.  Use
        <function>pg_replication_origin_session_reset</function> to revert.
        Can only be used if no previous origin is configured.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-setup">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_setup(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        把当前会话标记为正在从给定的源进行重放，允许重放进度被跟踪。使用
        <function>pg_replication_origin_session_reset</function>可以取消
        标记。只有之前没有源被配置时才能使用。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Cancel the effects
        of <function>pg_replication_origin_session_setup()</function>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        取消<function>pg_replication_origin_session_setup()</function>的效果。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_is_setup()</function></literal>
       </entry>
       <entry>
        <type>bool</type>
       </entry>
       <entry>
        Has a replication origin been configured in the current session?
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_is_setup()</function></literal>
       </entry>
       <entry>
        <type>bool</type>
       </entry>
       <entry>
        当前会话中是否已经配置了一个复制源？
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-session-progress">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_progress(<parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        Return the replay location for the replication origin configured in
        the current session. The parameter <parameter>flush</parameter>
        determines whether the corresponding local transaction will be
        guaranteed to have been flushed to disk or not.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-progress">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_progress(<parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        返回当前会话中配置的复制源的重放位置。参数
        <parameter>flush</parameter>决定对应的本地事务是否被确保
        已经刷入磁盘。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-xact-setup">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_setup(<parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamptz</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Mark the current transaction as replaying a transaction that has
        committed at the given <acronym>LSN</acronym> and timestamp. Can
        only be called when a replication origin has previously been
        configured using
        <function>pg_replication_origin_session_setup()</function>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-setup">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_setup(<parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamptz</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        标记当前事务为正在重放一个已经在给定的<acronym>LSN</acronym>
        和时间戳提交的事务。只有当之前已经用
        <function>pg_replication_origin_session_setup()</function>配置过
        一个复制源时才能被调用。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-xact-reset">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Cancel the effects of
        <function>pg_replication_origin_xact_setup()</function>.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-reset">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        取消<function>pg_replication_origin_xact_setup()</function>的效果。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-advance">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <literal>pg_replication_origin_advance<function>(<parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        Set replication progress for the given node to the given
        location. This primarily is useful for setting up the initial location
        or a new location after configuration changes and similar. Be aware
        that careless use of this function can lead to inconsistently
        replicated data.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-advance">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <literal>pg_replication_origin_advance<function>(<parameter>node_name</parameter> <type>text</type>, <parameter>pos</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        把给定节点的复制进度设置为给定的位置。这主要用于配置更改或者类似
        操作之后设置初始位置或者新位置。注意这个函数的不当使用可能会导致
        不一致的复制数据。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-progress">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_progress(<parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        Return the replay location for the given replication origin. The
        parameter <parameter>flush</parameter> determines whether the
        corresponding local transaction will be guaranteed to have been
        flushed to disk or not.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-progress">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_progress(<parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        返回给定复制元的重放位置。参数
        <parameter>flush</parameter>决定对应的本地事务是否被确保
        已经刷入磁盘。
       </entry>
      </row>
      
<!--==========================orignal english content==========================
      <row>
       <entry id="pg-logical-emit-message-text">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        Emit text logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through WAL. The parameter
        <parameter>transactional</parameter> specifies if the message should
        be part of current transaction or if it should be written immediately
        and decoded as soon as the logical decoding reads the record. The
        <parameter>prefix</parameter> is textual prefix used by the logical
        decoding plugins to easily recognize interesting messages for them.
        The <parameter>content</parameter> is the text of the message.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-logical-emit-message-text">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        发出文本形式的逻辑解码消息。这可以被用来通过 WAL 向逻辑解码插件传递一般消息。参数<parameter>transactional</parameter>指定该消息是否应该是当前事务的一部分或者当逻辑解码读到该记录时该消息是否应该被立刻写入并且解码。<parameter>prefix</parameter>是逻辑解码插件用来识别它们感兴趣的消息的文本前缀。<parameter>content</parameter>是消息的文本。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-logical-emit-message-bytea">
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        Emit binary logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through WAL. The parameter
        <parameter>transactional</parameter> specifies if the message should
        be part of current transaction or if it should be written immediately
        and decoded as soon as the logical decoding reads the record. The
        <parameter>prefix</parameter> is textual prefix used by the logical
        decoding plugins to easily recognize interesting messages for them.
        The <parameter>content</parameter> is the binary content of the
        message.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-logical-emit-message-bytea">
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
        发出二进制逻辑解码消息。这可以被用来通过WAL向逻辑解码插件传递一般性消息。参数<parameter>transactional</parameter>指定该消息是否应该成为当前事务的一部分或者是否应该在逻辑解码过程读到该记录时立刻进行写入和解码。参数<parameter>prefix</parameter>是一个逻辑解码插件使用的文本前缀，逻辑解码插件用它来识别感兴趣的消息。参数<parameter>content</parameter>是消息的二进制内容。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
<!--==========================orignal english content==========================
   <title>Database Object Management Functions</title>
____________________________________________________________________________-->
   <title>数据库对象管理函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-admin-dbsize"/> calculate
    the disk space usage of database objects.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dbsize"/>中展示的函数计算数据库对象使用的磁盘空间。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_size_bytes</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_size_bytes</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>

   <table id="functions-admin-dbsize">
<!--==========================orignal english content==========================
    <title>Database Object Size Functions</title>
____________________________________________________________________________-->
    <title>数据库对象尺寸函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>Number of bytes used to store a particular value (possibly compressed)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>存储一个特定值（可能压缩过）所需的字节数</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Disk space used by the database with the specified OID</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定 OID 的数据库使用的磁盘空间</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Disk space used by the database with the specified name</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定名称的数据库使用的磁盘空间</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        Total disk space used by indexes attached to the specified table
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        附加到指定表的索引所占的总磁盘空间
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        Disk space used by the specified fork (<literal>'main'</literal>,
        <literal>'fsm'</literal>, <literal>'vm'</literal>, or <literal>'init'</literal>)
        of the specified table or index
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        指定表或索引的指定分叉（<literal>'main'</literal>、<literal>'fsm'</literal>、<literal>'vm'</literal>或<literal>'init'</literal>）使用的磁盘空间
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        Shorthand for <literal>pg_relation_size(..., 'main')</literal>
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        <literal>pg_relation_size(..., 'main')的简写</literal>
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_size_bytes(<type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
         Converts a size in human-readable format with size units into bytes
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_size_bytes(<type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
         把人类可读格式的带有单位的尺寸转换成字节数
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         Converts a size in bytes expressed as a 64-bit integer into a
         human-readable format with size units
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         将表示成一个 64位整数的字节尺寸转换为带尺寸单位的人类可读格式
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         Converts a size in bytes expressed as a numeric value into a
         human-readable format with size units
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
         将表示成一个数字值的字节尺寸转换为带尺寸单位的人类可读格式
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        Disk space used by the specified table, excluding indexes
        (but including TOAST, free space map, and visibility map)
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        被指定表使用的磁盘空间，排除索引（但包括 TOAST、空闲空间映射和可见性映射）
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Disk space used by the tablespace with the specified OID</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定 OID 的表空间使用的磁盘空间</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Disk space used by the tablespace with the specified name</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>指定名称的表空间使用的磁盘空间</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        Total disk space used by the specified table,
        including all indexes and <acronym>TOAST</acronym> data
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
        指定表所用的总磁盘空间，包括所有的索引和<acronym>TOAST</acronym>数据
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_column_size</function> shows the space used to store any individual
    data value.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_column_size</function>显示用于存储任意独立数据值的空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_total_relation_size</function> accepts the OID or name of a
    table or toast table, and returns the total on-disk space used for
    that table, including all associated indexes.  This function is
    equivalent to <function>pg_table_size</function>
    <literal>+</literal> <function>pg_indexes_size</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_total_relation_size</function>接受一个表或 TOAST 表的 OID 或名称，并返回该表所使用的总磁盘空间，包括所有相关的索引。这个函数等价于<function>pg_table_size</function> <literal>+</literal> <function>pg_indexes_size</function>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_table_size</function> accepts the OID or name of a table and
    returns the disk space needed for that table, exclusive of indexes.
    (TOAST space, free space map, and visibility map are included.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_table_size</function>接受一个表的 OID 或名称，并返回该表所需的磁盘空间，但是排除索引（TOAST 空间、空闲空间映射和可见性映射包含在内）
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_indexes_size</function> accepts the OID or name of a table and
    returns the total disk space used by all the indexes attached to that
    table.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_indexes_size</function>接受一个表的 OID 或名称，并返回附加到该表的所有索引所使用的全部磁盘空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_database_size</function> and <function>pg_tablespace_size</function>
    accept the OID or name of a database or tablespace, and return the total
    disk space used therein.  To use <function>pg_database_size</function>,
    you must have <literal>CONNECT</literal> permission on the specified database
    (which is granted by default), or be a member of the <literal>pg_read_all_stats</literal>
    role. To use <function>pg_tablespace_size</function>, you must have
    <literal>CREATE</literal> permission on the specified tablespace, or be a member
    of the <literal>pg_read_all_stats</literal> role unless it is the default tablespace for
    the current database.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_database_size</function>以及<function>pg_tablespace_size</function>接受数据库或者表空间的OID或者名称，并且返回它们使用的磁盘空间。要使用<function>pg_database_size</function>，用户必须具有指定数据库上的<literal>CONNECT</literal>权限（默认情况下已经被授予）或者是<literal>pg_read_all_stats</literal>角色的一个成员。要使用<function>pg_tablespace_size</function>，用户必须具有指定表空间上的<literal>CREATE</literal>权限或者是<literal>pg_read_all_stats</literal>角色的一个成员，除非该表空间是当前数据库的默认表空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_relation_size</function> accepts the OID or name of a table, index
    or toast table, and returns the on-disk size in bytes of one fork of
    that relation.  (Note that for most purposes it is more convenient to
    use the higher-level functions <function>pg_total_relation_size</function>
    or <function>pg_table_size</function>, which sum the sizes of all forks.)
    With one argument, it returns the size of the main data fork of the
    relation.  The second argument can be provided to specify which fork
    to examine:
    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>'main'</literal> returns the size of the main
       data fork of the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'fsm'</literal> returns the size of the Free Space Map
       (see <xref linkend="storage-fsm"/>) associated with the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'vm'</literal> returns the size of the Visibility Map
       (see <xref linkend="storage-vm"/>) associated with the relation.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'init'</literal> returns the size of the initialization
       fork, if any, associated with the relation.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_relation_size</function>接受一个表、索引或 TOAST 表的 OID
    或者名称，并且返回那个关系的一个分叉所占的磁盘空间的字节尺寸（注意
    对于大部分目的，使用更高层的函数<function>pg_total_relation_size</function>
    或者<function>pg_table_size</function>会更方便，它们会合计所有分叉的尺寸）。
    如果只得到一个参数，它会返回该关系的主数据分叉的尺寸。提供第二个参数
    可以指定要检查哪个分叉：
    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>'main'</literal>返回该关系主数据分叉的尺寸。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'fsm'</literal>返回与该关系相关的空闲空间映射（见
       <xref linkend="storage-fsm"/>）的尺寸。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'vm'</literal>返回与该关系相关的可见性映射（见
       <xref linkend="storage-vm"/>）的尺寸。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>'init'</literal>返回与该关系相关的初始化分叉（如
       果有）的尺寸。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_size_pretty</function> can be used to format the result of one of
    the other functions in a human-readable way, using bytes, kB, MB, GB or TB
    as appropriate.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_size_pretty</function>可以用于把其它函数之一的结果格式化成一种人类易读的格式，可以根据情况使用字节、kB、MB、GB 或者 TB。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <function>pg_size_bytes</function> can be used to get the size in bytes from a
    string in human-readable format. The input may have units of bytes, kB,
    MB, GB or TB, and is parsed case-insensitively. If no units are specified,
    bytes are assumed.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_size_bytes</function>可以被用来从人类可读格式的字符串得到其中所表示的字节数。其输入可能带有的单位包括字节、kB、MB、GB 或者 TB，并且对输入进行解析时是区分大小写的。如果没有指定单位，会假定单位为字节。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The units kB, MB, GB and TB used by the functions
     <function>pg_size_pretty</function> and <function>pg_size_bytes</function> are defined
     using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is
     1024<superscript>2</superscript> = 1048576 bytes, and so on.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>pg_size_pretty</function>和<function>pg_size_bytes</function>所使用的单位 kB、MB、GB 和 TB 是用 2 的幂而不是 10 的幂来定义，因此 1kB 是 1024 字节，1MB 是 1024<superscript>2</superscript> = 1048576 字节，以此类推。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The functions above that operate on tables or indexes accept a
    <type>regclass</type> argument, which is simply the OID of the table or index
    in the <structname>pg_class</structname> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</type> data type's input
    converter will do the work for you.  Just write the table name enclosed in
    single quotes so that it looks like a literal constant.  For compatibility
    with the handling of ordinary <acronym>SQL</acronym> names, the string
    will be converted to lower case unless it contains double quotes around
    the table name.
   </para>
____________________________________________________________________________-->
   <para>
    上述操作表和索引的函数接受一个<type>regclass</type>参数，它是该表或索引在<structname>pg_class</structname>系统目录中的 OID。你不必手工去查找该 OID，因为<type>regclass</type>数据类型的输入转换器会为你代劳。只写包围在单引号内的表名，这样它看起来像一个文字常量。为了与普通<acronym>SQL</acronym>名称的处理相兼容，该字符串将被转换为小写形式，除非其中在表名周围包含双引号。
   </para>

<!--==========================orignal english content==========================
   <para>
    If an OID that does not represent an existing object is passed as
    argument to one of the above functions, NULL is returned.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个 OID 不表示一个已有的对象并且被作为参数传递给了上述函数，将会返回 NULL。
   </para>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-admin-dblocation"/> assist
    in identifying the specific disk files associated with database objects.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dblocation"/>中展示的函数帮助标识数据库对象相关的磁盘文件。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>

   <table id="functions-admin-dblocation">
<!--==========================orignal english content==========================
    <title>Database Object Location Functions</title>
____________________________________________________________________________-->
    <title>数据库对象定位函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>
        Filenode number of the specified relation
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>
        指定关系的文件结点号
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
        File path name of the specified relation
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
        指定关系的文件路径名
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
        Find the relation associated with a given tablespace and filenode
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
        查找与给定的表空间和文件节点相关的关系
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_relation_filenode</function> accepts the OID or name of a table,
    index, sequence, or toast table, and returns the <quote>filenode</quote> number
    currently assigned to it.  The filenode is the base component of the file
    name(s) used for the relation (see <xref linkend="storage-file-layout"/>
    for more information).  For most tables the result is the same as
    <structname>pg_class</structname>.<structfield>relfilenode</structfield>, but for certain
    system catalogs <structfield>relfilenode</structfield> is zero and this function must
    be used to get the correct value.  The function returns NULL if passed
    a relation that does not have storage, such as a view.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_relation_filenode</function>接受一个表、索引、序列或 TOAST 表的 OID 或名称，返回当前分配给它的<quote>filenode</quote>号。文件结点是关系的文件名的基本组件（详见<xref linkend="storage-file-layout"/>）。对于大多数表结果和<structname>pg_class</structname>.<structfield>relfilenode</structfield>相同，但是对于某些系统目录<structfield>relfilenode</structfield>为零，并且必须使用此函数获取正确的值。 如果传递一个没有存储的关系（如视图），此函数将返回 NULL。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_relation_filepath</function> is similar to
    <function>pg_relation_filenode</function>, but it returns the entire file path name
    (relative to the database cluster's data directory <varname>PGDATA</varname>) of
    the relation.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_relation_filepath</function>与<function>pg_relation_filenode</function>类似，但是它返回关系的整个文件路径名（相对于数据库集簇的数据目录<varname>PGDATA</varname>）。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <function>pg_filenode_relation</function> is the reverse of
    <function>pg_relation_filenode</function>. Given a <quote>tablespace</quote> OID and
    a <quote>filenode</quote>, it returns the associated relation's OID. For a table
    in the database's default tablespace, the tablespace can be specified as 0.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_filenode_relation</function>是<function>pg_relation_filenode</function>的反向函数。给定一个<quote>tablespace</quote> OID 以及一个 <quote>filenode</quote>，它会返回相关关系的 OID。对于一个在数据库的默认表空间中的表，该表空间可以指定为 0。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-collation"/> lists functions used to manage
    collations.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-collation"/>列出了用来管理排序规则的函数。
   </para>

   <table id="functions-admin-collation">
<!--==========================orignal english content==========================
    <title>Collation Management Functions</title>
____________________________________________________________________________-->
    <title>排序规则管理函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_collation_actual_version</primary></indexterm>
        <literal><function>pg_collation_actual_version(<type>oid</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Return actual version of collation from operating system</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_collation_actual_version</primary></indexterm>
        <literal><function>pg_collation_actual_version(<type>oid</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>返回来自操作系统的排序规则的实际版本</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_import_system_collations</primary></indexterm>
        <literal><function>pg_import_system_collations(<parameter>schema</parameter> <type>regnamespace</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>Import operating system collations</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_import_system_collations</primary></indexterm>
        <literal><function>pg_import_system_collations(<parameter>schema</parameter> <type>regnamespace</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>导入操作系统排序规则</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_collation_actual_version</function> returns the actual
    version of the collation object as it is currently installed in the
    operating system.  If this is different from the value
    in <literal>pg_collation.collversion</literal>, then objects depending on
    the collation might need to be rebuilt.  See also
    <xref linkend="sql-altercollation"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_collation_actual_version</function>返回当前安装在操作系统中的该排序规则对象的实际版本。如果这个版本与<literal>pg_collation.collversion</literal>中的值不同，则依赖于该排序规则的对象可能需要被重建。还可以参考<xref linkend="sql-altercollation"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_import_system_collations</function> adds collations to the system
    catalog <literal>pg_collation</literal> based on all the
    locales it finds in the operating system.  This is
    what <command>initdb</command> uses;
    see <xref linkend="collation-managing"/> for more details.  If additional
    locales are installed into the operating system later on, this function
    can be run again to add collations for the new locales.  Locales that
    match existing entries in <literal>pg_collation</literal> will be skipped.
    (But collation objects based on locales that are no longer
    present in the operating system are not removed by this function.)
    The <parameter>schema</parameter> parameter would typically
    be <literal>pg_catalog</literal>, but that is not a requirement;
    the collations could be installed into some other schema as well.
    The function returns the number of new collation objects it created.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_import_system_collations</function>基于在操作系统中找到的所有locale在系统目录<literal>pg_collation</literal>中加入排序规则。这是<command>initdb</command>会使用的函数，更多细节请参考<xref linkend="collation-managing"/>。如果后来在操作系统上安装了额外的locale，可以再次运行这个函数加入新locale的排序规则。匹配<literal>pg_collation</literal>中现有项的locale将被跳过（但是这个函数不会移除以在操作系统中不再存在的locale为基础的排序规则对象）。<parameter>schema</parameter>参数通常是<literal>pg_catalog</literal>，但这不是一种要求，排序规则也可以被安装到其他的方案中。该函数返回其创建的新排序规则对象的数量。
   </para>
   <table id="functions-info-partition">
<!--==========================orignal english content==========================
    <title>Partitioning Information Functions</title>
____________________________________________________________________________-->
    <title>分区信息函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_partition_tree</primary></indexterm>
        <literal><function>pg_partition_tree(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        List information about tables or indexes in a partition tree for a
        given partitioned table or partitioned index, with one row for each
        partition.  Information provided includes the name of the partition,
        the name of its immediate parent, a boolean value telling if the
        partition is a leaf, and an integer telling its level in the hierarchy.
        The value of level begins at <literal>0</literal> for the input table
        or index in its role as the root of the partition tree,
        <literal>1</literal> for its partitions, <literal>2</literal> for
        their partitions, and so on.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_partition_tree</primary></indexterm>
        <literal><function>pg_partition_tree(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        列出一个分区树中的表或索引的相关信息。给定的分区表或分区索引，每张表有一行 分区。 提供的信息包括分区的名称，它的直系父级的名称，一个布尔值，表示该分区是否是一个叶子，以及一个整数，表示它在层次结构中的级别。level的值从<literal>0</literal>开始，表示输入表或索引作为分区树的根，<literal>1</literal>表示其分区，<literal>2</literal>表示其分区，以此类推。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_partition_ancestors</primary></indexterm>
        <literal><function>pg_partition_ancestors(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof regclass</type></entry>
       <entry>
        List the ancestor relations of the given partition,
        including the partition itself.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_partition_ancestors</primary></indexterm>
        <literal><function>pg_partition_ancestors(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof regclass</type></entry>
       <entry>
        列出给定分区的祖先关系，包括分区本身。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_partition_root</primary></indexterm>
        <literal><function>pg_partition_root(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>regclass</type></entry>
       <entry>
        Return the top-most parent of a partition tree to which the given
        relation belongs.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_partition_root</primary></indexterm>
        <literal><function>pg_partition_root(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>regclass</type></entry>
       <entry>
        R返回给定关系所属的分区树的最上层父节点。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    To check the total size of the data contained in
    <structname>measurement</structname> table described in
    <xref linkend="ddl-partitioning-declarative-example"/>, one could use the
    following query:
   </para>
____________________________________________________________________________-->
   <para>
    要检查<xref linkend="ddl-partitioning-declarative-example"/>中描述的<structname>measurement</structname>表中的数据的总大小，可以使用下面的查询:
   </para>

<!--==========================orignal english content==========================
<programlisting>
=# SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
     FROM pg_partition_tree('measurement');
 total_size 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 24 kB
(1 row)
</programlisting>
____________________________________________________________________________-->
<programlisting>
=# SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
     FROM pg_partition_tree('measurement');
 total_size 
------------
 24 kB
(1 row)
</programlisting>
  </sect2>
  
  <sect2 id="functions-admin-index">
<!--==========================orignal english content==========================
   <title>Index Maintenance Functions</title>
____________________________________________________________________________-->
   <title>索引维护函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>brin_summarize_new_values</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>brin_summarize_new_values</primary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary>gin_clean_pending_list</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>gin_clean_pending_list</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>brin_summarize_range</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>brin_summarize_range</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>brin_desummarize_range</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>brin_desummarize_range</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-index-table"/> shows the functions
    available for index maintenance tasks.
    These functions cannot be executed during recovery.
    Use of these functions is restricted to superusers and the owner
    of the given index.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-index-table"/>展示了可用于 索引维护任务的函数。这些函数不能在恢复期间执行。只有超级用户以及给定索引的拥有者才能是用这些函数。
   </para>

   <table id="functions-admin-index-table">
<!--==========================orignal english content==========================
    <title>Index Maintenance Functions</title>
____________________________________________________________________________-->
    <title>索引维护函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>brin_summarize_new_values(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>summarize page ranges not already summarized</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>brin_summarize_new_values(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>对还没有建立概要的页面范围建立概要</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>brin_summarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>summarize the page range covering the given block, if not already summarized</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>brin_summarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>如果还没有对覆盖给定块的页面范围建立概要，则对其建立概要</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>brin_desummarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>de-summarize the page range covering the given block, if summarized</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>brin_desummarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>如果覆盖给定块的页面范围已经建立有概要，则去掉概要</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>gin_clean_pending_list(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>bigint</type></entry>
       <entry>move GIN pending list entries into main index structure</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>gin_clean_pending_list(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>bigint</type></entry>
       <entry>把 GIN 待处理列表项移动到主索引结构中</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>brin_summarize_new_values</function> accepts the OID or name of a
    BRIN index and inspects the index to find page ranges in the base table
    that are not currently summarized by the index; for any such range
    it creates a new summary index tuple by scanning the table pages.
    It returns the number of new page range summaries that were inserted
    into the index.  <function>brin_summarize_range</function> does the same, except
    it only summarizes the range that covers the given block number.
   </para>
____________________________________________________________________________-->
   <para>
    <function>brin_summarize_new_values</function>接收一个 BRIN 索引的 OID 或者名称作为参数并且检查该索引以找到基表中当前还没有被该索引汇总的页面范围。对任意一个这样的范围，它将通过扫描那些表页面创建一个新的摘要索引元组。它会返回被插入到该索引的新页面范围摘要的数量。<function>brin_summarize_range</function>做同样的事情，不过它只对覆盖给定块号的范围建立概要。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <function>gin_clean_pending_list</function> accepts the OID or name of
    a GIN index and cleans up the pending list of the specified index
    by moving entries in it to the main GIN data structure in bulk.
    It returns the number of pages removed from the pending list.
    Note that if the argument is a GIN index built with
    the <literal>fastupdate</literal> option disabled, no cleanup happens and the
    return value is 0, because the index doesn't have a pending list.
    Please see <xref linkend="gin-fast-update"/> and <xref linkend="gin-tips"/>
    for details of the pending list and <literal>fastupdate</literal> option.
   </para>
____________________________________________________________________________-->
   <para>
    <function>gin_clean_pending_list</function>接受一个 GIN 索引的 OID 或者名字，并且通过把指定索引的待处理列表中的项批量移动到主 GIN 数据结构来清理该索引的待处理列表。它会返回从待处理列表中移除的页数。注意如果其参数是一个禁用<literal>fastupdate</literal>选项构建的 GIN 索引，那么不会做清理并且返回值为 0，因为该索引根本没有待处理列表。有关待处理列表和<literal>fastupdate</literal>选项的细节请见<xref linkend="gin-fast-update"/>和<xref linkend="gin-tips"/>。
   </para>

  </sect2>

  <sect2 id="functions-admin-genfile">
<!--==========================orignal english content==========================
   <title>Generic File Access Functions</title>
____________________________________________________________________________-->
   <title>通用文件访问函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-genfile-table"/> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</varname> can be
    accessed unless the user is granted the role
    <literal>pg_read_server_files</literal>.  Use a relative path for files in
    the cluster directory, and a path matching the <varname>log_directory</varname>
    configuration setting for log files.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-genfile-table"/>中展示的函数提供了对数据库服务器所在机器上的文件的本地访问。只能访问数据库集簇目录以及<varname>log_directory</varname>中的文件，除非用户被授予了角色<literal>pg_read_server_files</literal>。 使用相对路径访问集簇目录里面的文件，以及匹配 <varname>log_directory</varname>配置设置的路径访问日志文件。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that granting users the EXECUTE privilege on
    <function>pg_read_file()</function>, or related functions, allows them the
    ability to read any file on the server which the database can read and
    that those reads bypass all in-database privilege checks.  This means that,
    among other things, a user with this access is able to read the contents of the
    <literal>pg_authid</literal> table where authentication information is contained,
    as well as read any file in the database.  Therefore, granting access to these
    functions should be carefully considered.
   </para>
____________________________________________________________________________-->
   <para>
    注意向用户授予<function>pg_read_file()</function>或者相关函数上的EXECUTE特权，函数会允许他们读取服务器上该数据库能读取的任何文件并且这些读取动作会绕过所有的数据库内特权检查。这意味着，除了别的之外，具有这种访问的用户能够读取<literal>pg_authid</literal>表中包含着认证信息的内容，也能读取数据库中的任意文件。因此，授予对这些函数的访问应该要很仔细地考虑。
   </para>

   <table id="functions-admin-genfile-table">
<!--==========================orignal english content==========================
    <title>Generic File Access Functions</title>
____________________________________________________________________________-->
    <title>通用文件访问函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</parameter> <type>text</type> [, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
        List the contents of a directory.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</parameter> <type>text</type> [, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>列出目录中的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_ls_logdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        List the name, size, and last modification time of files in the log
        directory. Access is granted to members of the <literal>pg_monitor</literal>
        role and may be granted to other non-superuser roles.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_ls_logdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        列出日志目录中文件的名称、尺寸以及最后修改时间。访问被授予给<literal>pg_monitor</literal>角色的成员，并且可以被授予给其他非超级用户角色。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_ls_waldir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        List the name, size, and last modification time of files in the WAL
        directory. Access is granted to members of the <literal>pg_monitor</literal>
        role and may be granted to other non-superuser roles.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_ls_waldir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        列出WAL目录中文件的名称、尺寸以及最后修改时间。访问被授予给<literal>pg_monitor</literal>角色的成员，并且可以被授予给其他非超级用户角色。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_ls_archive_statusdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        List the name, size, and last modification time of files in the WAL
        archive status directory. Access is granted to members of the
        <literal>pg_monitor</literal> role and may be granted to other
        non-superuser roles.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_ls_archive_statusdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        列出WAL存档状态目录中文件的名称、大小和最后一次修改时间。访问权限只授予<literal>pg_monitor</literal>角色的成员，也可以授予其他非超级用户角色。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_ls_tmpdir(<optional><parameter>tablespace</parameter> <type>oid</type></optional>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        List the name, size, and last modification time of files in the
        temporary directory for <parameter>tablespace</parameter>.  If
        <parameter>tablespace</parameter> is not provided, the
        <literal>pg_default</literal> tablespace is used.  Access is granted
        to members of the <literal>pg_monitor</literal> role and may be
        granted to other non-superuser roles.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_ls_tmpdir(<optional><parameter>tablespace</parameter> <type>oid</type></optional>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
        为<parameter>tablespace</parameter>列出临时目录中文件的名称、大小和最后一次修改时间。 如果没有提供<parameter>tablespace</parameter>，则在临时目录中的
<literal>pg_default</literal>表空间被使用。 <literal>pg_monitor</literal>角色的成员可以访问，其他非超级用户角色也可以访问。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Return the contents of a text file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>返回一个文本文件的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        Return the contents of a file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>返回一个文件的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</parameter> <type>text</type>[, <parameter>missing_ok</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
        Return information about a file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</parameter> <type>text</type>[, <parameter>missing_ok</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>返回关于一个文件的信息。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!--==========================orignal english content==========================
   <para>
    Some of these functions take an optional <parameter>missing_ok</parameter> parameter,
    which specifies the behavior when the file or directory does not exist.
    If <literal>true</literal>, the function returns NULL (except
    <function>pg_ls_dir</function>, which returns an empty result set). If
    <literal>false</literal>, an error is raised. The default is <literal>false</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数中的某些有一个可选的<parameter>missing_ok</parameter>参数，
    它指定文件或者目录不存在时的行为。如果为<literal>true</literal>，
    函数会返回 NULL （<function>pg_ls_dir</function>除外，它返回一个空
    结果集）。如果为<literal>false</literal>，则发生一个错误。默认是
    <literal>false</literal>。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_ls_dir</function> returns the names of all files (and directories
    and other special files) in the specified directory. The <parameter>
    include_dot_dirs</parameter> indicates whether <quote>.</quote> and <quote>..</quote> are
    included in the result set. The default is to exclude them
    (<literal>false</literal>), but including them can be useful when
    <parameter>missing_ok</parameter> is <literal>true</literal>, to distinguish an
    empty directory from an non-existent directory.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_ls_dir</function>返回指定目录中所有文件（以及目录和其他特殊文件）
    的名称。<parameter>include_dot_dirs</parameter>指示结果集中是否包括
    <quote>.</quote>和<quote>..</quote>。默认是排除它们（<literal>false</literal>），但是
    当<parameter>missing_ok</parameter>为<literal>true</literal>时把它们包括在内是
    有用的，因为可以把一个空目录与一个不存在的目录区分开。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ls_logdir</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ls_logdir</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_ls_logdir</function> returns the name, size, and last modified time
    (mtime) of each file in the log directory. By default, only superusers
    and members of the <literal>pg_monitor</literal> role can use this function.
    Access may be granted to others using <command>GRANT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_ls_logdir</function>返回日志目录中每个文件的名称、尺寸以及最后的修改时间（mtime）。默认情况下，只有超级用户以及<literal>pg_monitor</literal>角色的成员能够使用这个函数。可以使用<command>GRANT</command>把访问授予给其他人。 
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ls_waldir</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ls_waldir</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_ls_waldir</function> returns the name, size, and last modified time
    (mtime) of each file in the write ahead log (WAL) directory. By
    default only superusers and members of the <literal>pg_monitor</literal> role
    can use this function. Access may be granted to others using
    <command>GRANT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_ls_waldir</function>返回预写式日志（WAL）目录中每个文件的名称、尺寸以及最后的修改时间（mtime）。默认情况下，只有超级用户以及<literal>pg_monitor</literal>角色的成员能够使用这个函数。可以使用<command>GRANT</command>把访问授予给其他人。
   </para>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ls_archive_statusdir</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ls_archive_statusdir</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_ls_archive_statusdir</function> returns the name, size, and
    last modified time (mtime) of each file in the WAL archive status
    directory <filename>pg_wal/archive_status</filename>. By default only
    superusers and members of the <literal>pg_monitor</literal> role can
    use this function. Access may be granted to others using
    <command>GRANT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_ls_archive_statusdir</function>返回WAL归档状态目录<filename>pg_wal/archive_status</filename>中每个文件的名称、大小和最后一次修改时间（mtime）。默认情况下，只有超级用户和<literal>pg_monitor</literal>角色的成员才能使用此函数。可使用<command>GRANT</command>授权其他用户访问。
    
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_ls_tmpdir</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_ls_tmpdir</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_ls_tmpdir</function> returns the name, size, and last modified
    time (mtime) of each file in the temporary file directory for the specified
    <parameter>tablespace</parameter>.  If <parameter>tablespace</parameter> is
    not provided, the <literal>pg_default</literal> tablespace is used.  By
    default only superusers and members of the <literal>pg_monitor</literal>
    role can use this function.  Access may be granted to others using
    <command>GRANT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_ls_tmpdir</function>返回指定的<parameter>tablespace</parameter>临时文件目录中每个文件的名称、大小和最后一次修改时间（mtime）。 如果没有提供<parameter>tablespace</parameter>，则使用<literal>pg_default</literal>表空间。 默认情况下，只有超级用户和<literal>pg_monitor</literal>角色的成员才能使用这个函数。 可使用<command>GRANT</command>授权其他用户访问。
   </para>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_read_file</function> returns part of a text file, starting
    at the given <parameter>offset</parameter>, returning at most <parameter>length</parameter>
    bytes (less if the end of file is reached first).  If <parameter>offset</parameter>
    is negative, it is relative to the end of the file.
    If <parameter>offset</parameter> and <parameter>length</parameter> are omitted, the entire
    file is returned.  The bytes read from the file are interpreted as a string
    in the server encoding; an error is thrown if they are not valid in that
    encoding.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_read_file</function>返回一个文本文件的一部分，从给定的<parameter>offset</parameter>开始，返回最多<parameter>length</parameter>字节（如果先到达文件末尾则会稍短）。如果<parameter>offset</parameter>为负，它相对于文件的末尾。如果<parameter>offset</parameter>和<parameter>length</parameter>被忽略，整个文件都被返回。从文件中读的字节被使用服务器编码解释成一个字符串；如果它们在编码中不合法则抛出一个错误。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_read_binary_file</function> is similar to
    <function>pg_read_file</function>, except that the result is a <type>bytea</type> value;
    accordingly, no encoding checks are performed.
    In combination with the <function>convert_from</function> function, this function
    can be used to read a file in a specified encoding:
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_read_binary_file</function>与<function>pg_read_file</function>相似，除了前者的结果是一个<type>bytea</type>值；相应地，不会执行编码检查。通过与<function>convert_from</function>函数结合，这个函数可以用来读取一个指定编码的文件：
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_stat_file</function> returns a record containing the file
    size, last accessed time stamp, last modified time stamp,
    last file status change time stamp (Unix platforms only),
    file creation time stamp (Windows only), and a <type>boolean</type>
    indicating if it is a directory.  Typical usages include:
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_stat_file</function>返回一个记录，其中包含文件尺寸、最后访问时间戳、最后修改时间戳、最后文件状态改变时间戳（只支持 Unix 平台）、文件创建时间戳（只支持 Windows）和一个<type>boolean</type>指示它是否为目录。通常的用法包括：
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-advisory-locks">
<!--==========================orignal english content==========================
   <title>Advisory Lock Functions</title>
____________________________________________________________________________-->
   <title>咨询锁函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-advisory-locks-table"/>
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-advisory-locks-table"/>中展示的函数管理咨询锁。有关正确使用这些函数的细节请参考<xref linkend="advisory-locks"/>。
   </para>

   <table id="functions-advisory-locks-table">
<!--==========================orignal english content==========================
    <title>Advisory Lock Functions</title>
____________________________________________________________________________-->
    <title>咨询锁函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain exclusive session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain exclusive session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain shared session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain shared session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Release an exclusive session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Release an exclusive session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Release all session level advisory locks held by the current session</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>释放当前会话持有的所有会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Release a shared session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Release a shared session level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>释放一个共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain exclusive transaction level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain exclusive transaction level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得排他事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain shared transaction level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Obtain shared transaction level advisory lock</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>获得共享事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain exclusive session level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain exclusive session level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain shared session level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain shared session level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享会话级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得排他事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain shared transaction level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享事务级别咨询锁</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Obtain shared transaction level advisory lock if available</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>如果可能，获得共享事务级别咨询锁</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_lock</function> locks an application-defined resource,
    which can be identified either by a single 64-bit key value or two
    32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a lock on the same resource identifier,
    this function will wait until the resource becomes available.  The lock
    is exclusive.  Multiple lock requests stack, so that if the same resource
    is locked three times it must then be unlocked three times to be
    released for other sessions' use.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_lock</function>锁住一个应用定义的资源，可以使用一个单一64位键值或两个32位键值标识（注意这些两个键空间不重叠）。如果另一个会话已经在同一个资源标识符上持有了一个锁，这个函数将等待直到该资源变成可用。该锁是排他的。多个锁请求会入栈，因此如果同一个资源被锁住三次，则它必须被解锁三次来被释放给其他会话使用。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_lock_shared</function> works the same as
    <function>pg_advisory_lock</function>,
    except the lock can be shared with other sessions requesting shared locks.
    Only would-be exclusive lockers are locked out.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_lock_shared</function>的工作和<function>pg_advisory_lock</function>相同，不过该锁可以与其他请求共享锁的会话共享。只有想要排他的锁请求会被排除。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_try_advisory_lock</function> is similar to
    <function>pg_advisory_lock</function>, except the function will not wait for the
    lock to become available.  It will either obtain the lock immediately and
    return <literal>true</literal>, or return <literal>false</literal> if the lock cannot be
    acquired immediately.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_try_advisory_lock</function>与<function>pg_advisory_lock</function>相似，不过该函数将不会等待锁变为可用。它要么立刻获得锁并返回<literal>true</literal>，要么不能立即获得锁并返回<literal>false</literal>。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_try_advisory_lock_shared</function> works the same as
    <function>pg_try_advisory_lock</function>, except it attempts to acquire
    a shared rather than an exclusive lock.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_try_advisory_lock_shared</function>的工作和<function>pg_try_advisory_lock</function>相同，不过它尝试获得一个共享锁而不是一个排他锁。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_unlock</function> will release a previously-acquired
    exclusive session level advisory lock.  It
    returns <literal>true</literal> if the lock is successfully released.
    If the lock was not held, it will return <literal>false</literal>,
    and in addition, an SQL warning will be reported by the server.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_unlock</function>将会释放之前获得的排他会话级别咨询锁。如果锁被成功释放，它返回<literal>true</literal>。如果锁没有被持有，它将返回<literal>false</literal>并且额外由服务器报告一个 SQL 警告。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_unlock_shared</function> works the same as
    <function>pg_advisory_unlock</function>,
    except it releases a shared session level advisory lock.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_unlock_shared</function>的工作和<function>pg_advisory_unlock</function>相同，除了它释放一个共享的会话级别咨询锁。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_unlock_all</function> will release all session level advisory
    locks held by the current session.  (This function is implicitly invoked
    at session end, even if the client disconnects ungracefully.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_unlock_all</function>将释放当前会话所持有的所有会话级别咨询锁（这个函数隐式地在会话末尾被调用，即使客户端已经不雅地断开）。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_xact_lock</function> works the same as
    <function>pg_advisory_lock</function>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_xact_lock</function>的工作和<function>pg_advisory_lock</function>相同，不过锁是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_advisory_xact_lock_shared</function> works the same as
    <function>pg_advisory_lock_shared</function>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_advisory_xact_lock_shared</function>的工作和<function>pg_advisory_lock_shared</function>相同，除了锁是在当前事务的末尾自动被释放的并且不能被显式释放。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_try_advisory_xact_lock</function> works the same as
    <function>pg_try_advisory_lock</function>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_try_advisory_xact_lock</function>的工作和<function>pg_try_advisory_lock</function>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    <function>pg_try_advisory_xact_lock_shared</function> works the same as
    <function>pg_try_advisory_lock_shared</function>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_try_advisory_xact_lock_shared</function>的工作和<function>pg_try_advisory_lock_shared</function>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </para>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
<!--==========================orignal english content==========================
   <title>Trigger Functions</title>
____________________________________________________________________________-->
   <title>触发器函数</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
      Currently <productname>PostgreSQL</productname> provides one built in trigger
      function, <function>suppress_redundant_updates_trigger</function>,
      which will prevent any update
      that does not actually change the data in the row from taking place, in
      contrast to the normal behavior which always performs the update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
    </para>
____________________________________________________________________________-->
   <para>
      当前<productname>PostgreSQL</productname>提供一个内建的触发器函数<function>suppress_redundant_updates_trigger</function>， 它将阻止任何不会实际更改行中数据的更新发生，这与正常的行为不管数据是否改变始终执行更新相反（这是正常的行为，使得更新运行速度更快，因为不需要检查，并在某些情况下也是有用的）。
    </para>

<!--==========================orignal english content==========================
    <para>
      Ideally, you should normally avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</function>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by an update are actually changed,
      use of this trigger will actually make the update run slower.
    </para>
____________________________________________________________________________-->
    <para>
      理想的情况下，你通常应该避免运行实际上并没有改变记录中数据的更新。 冗余更新会花费大量不必要的时间，尤其是如果有大量索引要改变， 并将最终不得不清理被死亡行占用的空间。但是，在客户端代码中检测这种情况并不总是容易的，甚至不可能做到。 而写表达式来检测它们容易产生错误。作为替代，使用<function>suppress_redundant_updates_trigger</function>可以跳过不改变数据的更新。 但是，你需要小心使用它。触发器需要很短但不能忽略的时间来处理每条记录，所以如果大多数被一个更新影响的记录确实被更改，此触发器的使用将实际上使更新运行得更慢。
    </para>

<!--==========================orignal english content==========================
    <para>
      The <function>suppress_redundant_updates_trigger</function> function can be
      added to a table like this:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      In most cases, you would want to fire this trigger last for each row.
      Bearing in mind that triggers fire in name order, you would then
      choose a trigger name that comes after the name of any other trigger
      you might have on the table.
    </para>
____________________________________________________________________________-->
    <para>
      <function>suppress_redundant_updates_trigger</function>函数可以像这样被加到一个表：
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      在大部分情况下，你可能希望在最后为每行触发这个触发器。考虑到触发器是按照名字顺序被触发，你需要选择一个位于该表所有其他触发器之后的触发器名字。
    </para>
<!--==========================orignal english content==========================
    <para>
       For more information about creating triggers, see
        <xref linkend="sql-createtrigger"/>.
    </para>
____________________________________________________________________________-->
    <para>
       有关创建触发器的更多信息请参考<xref linkend="sql-createtrigger"/>。
    </para>
  </sect1>

  <sect1 id="functions-event-triggers">
<!--==========================orignal english content==========================
   <title>Event Trigger Functions</title>
____________________________________________________________________________-->
   <title>事件触发器函数</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides these helper functions
    to retrieve information from event triggers.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了这些助手函数来从
    事件触发器检索信息。
   </para>

<!--==========================orignal english content==========================
   <para>
    For more information about event triggers,
    see <xref linkend="event-triggers"/>.
   </para>
____________________________________________________________________________-->
   <para>
    更多有关事件触发器的信息请见<xref linkend="event-triggers"/>。
   </para>

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
<!--==========================orignal english content==========================
   <title>Capturing Changes at Command End</title>
____________________________________________________________________________-->
   <title>在命令结束处捕捉更改</title>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_event_trigger_ddl_commands</function> returns a list of
    <acronym>DDL</acronym> commands executed by each user action,
    when invoked in a function attached to a
    <literal>ddl_command_end</literal> event trigger.  If called in any other
    context, an error is raised.
    <function>pg_event_trigger_ddl_commands</function> returns one row for each
    base command executed; some commands that are a single SQL sentence
    may return more than one row.  This function returns the following
    columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belongs in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g. attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>Command tag</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belongs in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>bool</type></entry>
        <entry>True if the command is part of an extension script</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         A complete representation of the command, in internal format.
         This cannot be output directly, but it can be passed to other
         functions to obtain different pieces of information about the
         command.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    当在一个<literal>ddl_command_end</literal>事件触发器的函数中调用时，
    <function>pg_event_trigger_ddl_commands</function>返回被每一个用户动作
    执行的<acronym>DDL</acronym>命令的列表。如果在其他任何环境中
    调用这个函数，会发生错误。
    <function>pg_event_trigger_ddl_commands</function>为每一个被执行的基本
    命令返回一行，某些只有一个单一 SQL 句子的命令可能会返回多于一行。
    这个函数返回下面的列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>对象的子-id（例如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>命令标签</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         该对象所属的模式的名称（如果有），如果没有则为<literal>NULL</literal>。
         没有引号。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象标识的文本表现形式，用模式限定。如果必要，出现在
         该标识中的每一个标识符都会被引用。
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>bool</type></entry>
        <entry>如果该命令是一个扩展脚本的一部分则为真</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         以内部格式表达的该命令的一个完整表现形式。这不能被直接输出，
         但是可以把它传递给其他函数来得到有关于该命令不同部分的信息。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
<!--==========================orignal english content==========================
   <title>Processing Objects Dropped by a DDL Command</title>
____________________________________________________________________________-->
   <title>处理被 DDL 命令删除的对象</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_event_trigger_dropped_objects</function> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</literal> event it is called.
    If called in any other context,
    <function>pg_event_trigger_dropped_objects</function> raises an error.
    <function>pg_event_trigger_dropped_objects</function> returns the following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belonged in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g. attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>bool</type></entry>
        <entry>True if this was one of the root object(s) of the deletion</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         True if there was a normal dependency relationship
         in the dependency graph leading to this object
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         True if this was a temporary object
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</literal>.
         No quoting is applied, and name is never schema-qualified.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         An array that, together with <literal>object_type</literal> and
         <literal>address_args</literal>, can be used by
         the <function>pg_get_object_address()</function> function to
         recreate the object address in a remote server containing an
         identically named object of the same kind
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         Complement for <literal>address_names</literal>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>返回其<literal>sql_drop</literal>事件中命令所删除的所有对象的列表。如果在任何其他环境中被调用，<function>pg_event_trigger_dropped_objects</function>将抛出一个错误。<function>pg_event_trigger_dropped_objects</function>返回下列列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>对象的子ID（如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>bool</type></entry>
        <entry>如果这是删除中的一个根对象则为真</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         指示在依赖图中有一个普通依赖关系指向该对象的标志
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
         如果该对象是一个临时对象则为真
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象所属模式的名称（如果存在）；否则为<literal>NULL</literal>。不应用引用。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         如果模式和名称的组合能被用于对象的一个唯一标识符，则是对象的名称；否则是<literal>NULL</literal>。不应用引用，并且名称不是模式限定的。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         一个数组，它可以和<literal>object_type</literal>及
         <literal>address_args</literal>
         一起通过<function>pg_get_object_address()</function>函数在一台包含有
         同类相同名称对象的远程服务器上重建该对象地址。
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         上述<literal>address_names</literal>的补充。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>pg_event_trigger_dropped_objects</function> function can be used
    in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>可以被这样用在一个事件触发器中：
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
  </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
<!--==========================orignal english content==========================
   <title>Handling a Table Rewrite Event</title>
____________________________________________________________________________-->
   <title>处理表重写事件</title>

<!--==========================orignal english content==========================
     <para>
    The functions shown in
    <xref linkend="functions-event-trigger-table-rewrite"/>
    provide information about a table for which a
    <literal>table_rewrite</literal> event has just been called.
    If called in any other context, an error is raised.
   </para>
____________________________________________________________________________-->
     <para>
       <xref linkend="functions-event-trigger-table-rewrite"/>
       中所示的函数提供刚刚被调用过<literal>table_rewrite</literal>
       事件的表的信息。如果在任何其他环境中调用，会发生错误。
    </para>
    
   <table id="functions-event-trigger-table-rewrite">
<!--==========================orignal english content==========================
    <title>Table Rewrite Information</title>
____________________________________________________________________________-->
    <title>表重写信息</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
____________________________________________________________________________-->
      <row><entry>名称</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_oid</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_oid()</function></literal>
       </entry>
       <entry><type>Oid</type></entry>
       <entry>The OID of the table about to be rewritten.</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_oid</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_oid()</function></literal>
       </entry>
       <entry><type>oid</type></entry>
       <entry>要被重写的表的 OID。</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_reason</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_reason()</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        The reason code(s) explaining the reason for rewriting. The exact
        meaning of the codes is release dependent.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_reason</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_reason()</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        解释重写原因的原因代码。这些代码的确切含义在单独的文档中。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The <function>pg_event_trigger_table_rewrite_oid</function> function can be used
    in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
    可以在一个这样的事件触发器中使用
    <function>pg_event_trigger_table_rewrite_oid</function>函数：
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
  </sect2>
  </sect1>
  <sect1 id="functions-statistics">
<!--==========================orignal english content==========================
   <title>Statistics Information Functions</title>
____________________________________________________________________________-->
   <title>统计信息函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides a function to inspect complex
    statistics defined using the <command>CREATE STATISTICS</command> command.
   </para>
____________________________________________________________________________-->
   <para>
   <productname>PostgreSQL</productname>提供了一个函数来检查使用<command>CREATE STATISTICS</command>命令定义的复杂统计。
   </para>

  <sect2 id="functions-statistics-mcv">
<!--==========================orignal english content==========================
   <title>Inspecting MCV Lists</title>
____________________________________________________________________________-->
   <title>检查MCV列表</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>pg_mcv_list_items</primary>
     <secondary>pg_mcv_list</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>pg_mcv_list_items</primary>
     <secondary>pg_mcv_list</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <function>pg_mcv_list_items</function> returns a list of all items
    stored in a multi-column <acronym>MCV</acronym> list, and returns the
    following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>int</type></entry>
        <entry>index of the item in the <acronym>MCV</acronym> list</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>values stored in the MCV item</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>flags identifying <literal>NULL</literal> values</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>frequency of this <acronym>MCV</acronym> item</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>base frequency of this <acronym>MCV</acronym> item</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>返回存储在多列<acronym>MCV</acronym>列表中的所有项目的列表，并返回以下列:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>int</type></entry>
        <entry> <acronym>MCV</acronym> 列表中的项目索引</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>存储在MCV项目中的值</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>标识<literal>NULL</literal>值的标志</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的频率</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的基本频率</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>pg_mcv_list_items</function> function can be used like this:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

     Values of the <type>pg_mcv_list</type> can be obtained only from the
     <literal>pg_statistic_ext_data.stxdmcv</literal> column.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>函数可以这样使用:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

     <type>pg_mcv_list</type>的值只能从<literal>pg_statistic_ext_data.stxdmcv</literal>列中获得。
   </para>
  </sect2>

  </sect1>
</chapter>
