<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
  <!-- 
  <title>Functions and Operators</title> 
  -->
<title>函数和操作符</title>
  <indexterm zone="functions">
   <!-- 
   <primary>function</primary> 
   -->
   <primary>函数</primary>
  </indexterm>

  <indexterm zone="functions">
   <!-- 
   <primary>operator</primary> 
   -->
   <primary>操作符</primary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming">.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
  </para>
-->
<para>
<productname>PostgreSQL</productname>为内建的数据类型提供了大量的函数和操作符。
用户也可以定义它们自己的函数和操作符，像<xref linkend="server-programming">
里描述的那样。<application>psql</application>命令<command>\df</command>
和<command>\do</command>可以分别用于列出所有实际可用的函数和操作符。
</para>

  <!--
<para>
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.  This chapter is also
   not exhaustive;  additional functions appear in relevant sections of
   the manual.
  </para>
-->
<para>
如果你关心移植性，那么请注意，我们在本章描述的大多数函数和操作符，
除了最琐碎的算术和比较操作符以及一些做了明确标记的函数以外，
都没有在<acronym>SQL</acronym>标准里声明。许多其它<acronym>SQL</acronym>
实现也有这些扩展的功能，并且很多时候不同的数据库产品中这些功能是相互兼容的。
本章也并没有穷尽一切信息；一些附加的函数在本手册的相关章节里出现。
</para>


  <sect1 id="functions-logical">
   <!-- 
   <title>Logical Operators</title> 
   -->
   <title>逻辑操作符</title>

   <indexterm zone="functions-logical">
    <!-- 
<primary>operator</primary>
    <secondary>logical</secondary> 
-->
<primary>操作符</primary>
    <secondary>逻辑</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see> 
-->
<primary>布尔</primary>
    <secondary>操作符</secondary>
    <see>操作符, 逻辑</see>
   </indexterm>
   
<para>
<!--
    The usual logical operators are available:
-->
常用的逻辑操作符有：
    <indexterm>
     <!-- 
 <primary>AND (operator)</primary> 
 -->
 <primary>AND (操作符)</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>OR (operator)</primary> 
 -->
 <primary>OR (操作符)</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>NOT (operator)</primary> 
 -->
 <primary>NOT (操作符)</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>conjunction</primary> 
 -->
 <primary>逻辑与</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>disjunction</primary> 
 -->
 <primary>逻辑或</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>negation</primary> 
 -->
 <primary>逻辑非</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</></member>
     <member><literal>OR</></member>
     <member><literal>NOT</></member>
    </simplelist>
<!-- 
    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</>, which represents <quote>unknown</quote>.
    Observe the following truth tables:
 -->
<acronym>SQL</acronym>使用三值的逻辑体系，真，假和<literal>null</>，
这时<literal>null</>代表<quote>未知</quote>。观察下面真值表：  
    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
   <!--
<para>
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operand
    without affecting the result.  But see <xref
    linkend="syntax-express-eval"> for more information about the
    order of evaluation of subexpressions.
   </para>
-->
<para>
操作符<literal>AND</literal>和<literal>OR</literal>都是可交换的，也就是说，
你可以交换左右操作数而不影响结果。但是请参阅<xref linkend="syntax-express-eval">
获取有关子表达式计算顺序的更多信息。
</para>
  </sect1>

  <sect1 id="functions-comparison">
   <!-- 
   <title>Comparison Operators</title> 
   -->
   <title>比较操作符</title>

   <indexterm zone="functions-comparison">
    <!-- 
<primary>comparison</primary>
    <secondary>operators</secondary> 
-->
<primary>比较</primary>
    <secondary>操作符</secondary>
   </indexterm>
   <!--
<para>
    The usual comparison operators are available, shown in <xref
    linkend="functions-comparison-table">.
   </para>
-->
<para>
可用的比较操作符在<xref linkend="functions-comparison-table">显示。
</para>

   <table id="functions-comparison-table">
    <!-- 
<title>Comparison Operators</title> 
-->
<title>比较操作符</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Operator</entry>
       <entry>Description</entry> 
   -->
   <entry>操作符</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
       <!-- 
   <entry>less than</entry> 
   -->
   <entry>小于</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
       <!-- 
   <entry>greater than</entry> 
   -->
   <entry>大于</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
       <!-- 
   <entry>less than or equal to</entry> 
   -->
   <entry>小于或等于</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
       <!-- 
   <entry>greater than or equal to</entry> 
   -->
   <entry>大于或等于</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
       <!-- 
   <entry>equal</entry> 
   -->
   <entry>等于</entry>
      </row>

      <row>
  <!--
       <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
       <entry>not equal</entry> 
   -->
   <entry> <literal>&lt;&gt;</literal>或<literal>!=</literal> </entry>
   <entry>不等于</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <!--
<para>
     The <literal>!=</literal> operator is converted to
     <literal>&lt;&gt;</literal> in the parser stage.  It is not
     possible to implement <literal>!=</literal> and
     <literal>&lt;&gt;</literal> operators that do different things.
    </para>
-->
<para>
<literal>!=</literal>操作符在分析器阶段被转换成<literal>&lt;&gt;</literal>。
<literal>!=</literal>和<literal>&lt;&gt;</literal>操作符是完全等价的。
</para>
   </note>

   <!--
<para>
    Comparison operators are available for all relevant data types.
    All comparison operators are binary operators that
    return values of type <type>boolean</type>; expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).
   </para>
-->
<para>
比较操作符可以用于所有相关的数据类型。所有比较操作符都是双目操作符，
返回<type>boolean</type>类型数值；像<literal>1 &lt; 2 &lt; 3</literal>
这样的表达式是非法的(因为布尔值和<literal>3</literal>之间不能做比较)。
</para>
<para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
<!-- 
    In addition to the comparison operators, the special
    <token>BETWEEN</token> construct is available:
-->
除了比较操作符以外，我们还可以使用<token>BETWEEN</token>构造。
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    <!-- 
is equivalent to 
-->
等效于
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
<!-- 
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>NOT BETWEEN</literal> does the opposite comparison:
-->
注意<token>BETWEEN</token>认为端点值是包含在范围内的。<literal>NOT BETWEEN</literal>
做相反的比较：
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    <!-- 
is equivalent to 
-->
等效于
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
<!-- 
    <literal>BETWEEN SYMMETRIC</> is the same as <literal>BETWEEN</>
    except there is no requirement that the argument to the left of
    <literal>AND</> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied. 
-->
<literal>BETWEEN SYMMETRIC</>和<literal>BETWEEN</>一样，只是没有要求
<literal>AND</>左边的参数小于或等于右边的参数。如果左面的参数不小于或等于右面的参数，
那么两个参数是自动交换的，所以非空范围总是适用。
   </para>

<para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    <!-- 
To check whether a value is or is not null, use the constructs: 
-->
要检查一个值是否为 NULL ，使用下面的构造：
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    <!-- 
or the equivalent, but nonstandard, constructs: 
-->
或者等效，但并不标准的构造：
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>


   <!--
<para>
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</> is not <quote>equal to</quote>
    <literal>NULL</>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.) This
    behavior conforms to the SQL standard.
   </para>
-->
<para>
<emphasis>不要</emphasis>写<literal><replaceable>expression</replaceable> = NULL</literal>
因为<literal>NULL</>是不<quote>等于</quote><literal>NULL</>的。
NULL 代表一个未知的数值，因此我们无法知道两个未知的数值是否相等。这个行为遵循 SQL 标准。
</para>

  <tip>
   <!--
<para>
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals">
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
   </para>
-->
<para>
有些应用可能要求表达式<literal><replaceable>expression</replaceable> = NULL</literal>
在<replaceable>expression</replaceable>为 NULL 时候返回真。
我们强烈建议这样的应用修改成遵循 SQL 标准。但是，如果这样修改是不可能的，
那么我们可以打开<xref linkend="guc-transform-null-equals">配置参数，
让<productname>PostgreSQL</productname>将<literal>x = NULL</literal>
自动转换成<literal>x IS NULL</literal>。
</para>
  </tip>

  <note>
   <!--
<para>
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</> and <literal>IS NOT NULL</> do not always return
    inverse results for row-valued expressions, i.e., a row-valued
    expression that contains both NULL and non-null values will return false
    for both tests.
    This definition conforms to the SQL standard, and is a change from the
    inconsistent behavior exhibited by <productname>PostgreSQL</productname>
    versions prior to 8.2.
   </para>
-->
<para>
如果<replaceable>expression</replaceable>是行值，
那么当行表达式本身为 NULL 或该行的所有字段都为 NULL 时，<literal>IS NULL</>将为真；
当行表达式本身不为 NULL 并且该行的所有字段都不为 NULL 时，<literal>IS NOT NULL</>
也将为真。因为这个行为，<literal>IS NULL</>和<literal>IS NOT NULL</>
并不总是为行值表达式返回相反的值，也就是，
一个同时包含NULL和non-null值的行值表达式将在两种情况下都返回false。
这个规定符合 SQL 标准，但是与<productname>PostgreSQL</productname>之前的版本不兼容。
</para>
  </note>

   
<para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
<!--
    Ordinary comparison operators yield null (signifying <quote>unknown</>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</> yields null, as does <literal>7 &lt;&gt; NULL</>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </> DISTINCT FROM</literal> constructs:
-->
如果有任何一个输入是 NULL ，那么普通的比较操作符生成 NULL(表示<quote>未知</>)，
而不是true或false。例如，<literal>7 = NULL</>生成null，<literal>7 &lt;&gt; NULL</>
也生成null。当这种行为不适用时，使用<literal>IS <optional> NOT </> DISTINCT FROM</literal>构造：
<synopsis>
<replaceable>expression</replaceable> IS DISTINCT FROM <replaceable>expression</replaceable>
<replaceable>expression</replaceable> IS NOT DISTINCT FROM <replaceable>expression</replaceable>
</synopsis>
<!-- 
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these constructs effectively act as though null
    were a normal data value, rather than <quote>unknown</>. 
-->
对于非 NULL 的输入<literal>IS DISTINCT FROM</literal>与<literal>&lt;&gt;</>
操作符相同。但是，如果两个输入都是 NULL ，那么它将返回假；如果只有一个输入是 NULL ，
那么它将返回真。类似的，对于非 NULL 的输入<literal>IS NOT DISTINCT FROM</literal>
与<literal>=</literal>操作符相同。但是，如果两个输入都是 NULL ，那么它将返回真；
如果只有一个输入是 NULL ，那么它将返回假。这样就很有效地把 NULL 当作一个普通数据值看待，
而不是<quote>未知</>。
   </para>
   
<para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
<!--
    Boolean values can also be tested using the constructs
-->
布尔数值可以用下面的构造进行测试
<synopsis>
<replaceable>expression</replaceable> IS TRUE
<replaceable>expression</replaceable> IS NOT TRUE
<replaceable>expression</replaceable> IS FALSE
<replaceable>expression</replaceable> IS NOT FALSE
<replaceable>expression</replaceable> IS UNKNOWN
<replaceable>expression</replaceable> IS NOT UNKNOWN
</synopsis>
<!-- 
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</>.
    Notice that <literal>IS UNKNOWN</> and <literal>IS NOT UNKNOWN</> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type. 
-->
这些构造将总是返回真或假，从来不返回 NULL ，即使操作数是 NULL 也如此。
NULL 输入被当做逻辑数值<quote>未知</>。请注意实际上<literal>IS UNKNOWN</>
和<literal>IS NOT UNKNOWN</>分别与<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>
相同，只是输入表达式必须是布尔类型。
   </para>
<!--以下是原文自带注释，所以未翻译，特此备注-->
<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   
<para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
  It is possible to check the data type of an expression using the
    constructs
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

  </sect1>

  <sect1 id="functions-math">
   <!-- 
   <title>Mathematical Functions and Operators</title> 
   -->
<title>数学函数和操作符</title>
   <!--
<para>
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
   </para>
-->
<para>
<productname>PostgreSQL</productname>为许多类型提供了数学操作符。
对于那些没有标准的数学传统的类型(比如日期/时间类型)，
我们在随后的章节里描述实际的行为。
</para>

   <!--
<para>
    <xref linkend="functions-math-op-table"> shows the available mathematical operators.
   </para>
-->
<para>
<xref linkend="functions-math-op-table">显示了可用的数学操作符。
</para>

   <table id="functions-math-op-table">
    <!-- 
<title>Mathematical Operators</title> 
-->
<title>数学操作符</title>

    <tgroup cols="4">
     <thead>
      <row>
       <!-- 
   <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
       <!--
   <entry>addition</entry> 
   -->
   <entry>加</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
       <!-- 
   <entry>subtraction</entry> 
   -->
   <entry>减</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
       <!-- 
   <entry>multiplication</entry> 
   -->
   <entry>乘</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
       <!-- 
   <entry>division (integer division truncates the result)</entry> 
   -->
   <entry>除(整数除法将截断结果)</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
       <!-- 
   <entry>modulo (remainder)</entry> 
   -->
   <entry>模(求余)</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
       <!-- 
   <entry>exponentiation</entry> 
   -->
   <entry>幂(指数运算)</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
       <!-- 
   <entry>square root</entry>
   -->
   <entry>平方根</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
       <!-- 
   <entry>cube root</entry> 
   -->
   <entry>立方根</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
       <!-- 
   <entry>factorial</entry> 
   -->
   <entry>阶乘</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
       <!-- 
   <entry>factorial (prefix operator)</entry> 
   -->
   <entry>阶乘(前缀操作符)</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
       <!-- 
   <entry>absolute value</entry> 
   -->
   <entry>绝对值</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <!-- 
   <entry>bitwise AND</entry> 
   -->
   <entry> 二进制 AND </entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <!-- 
   <entry>bitwise OR</entry> 
   -->
   <entry>二进制 OR</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <!-- 
   <entry>bitwise XOR</entry> 
   -->
   <entry>二进制 XOR</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <!-- 
   <entry>bitwise NOT</entry> 
   -->
   <entry>二进制 NOT</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <!-- 
   <entry>bitwise shift left</entry> 
   -->
   <entry>二进制左移</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <!-- 
   <entry>bitwise shift right</entry> 
   -->
   <entry>二进制右移</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The bitwise operators work only on integral data types, whereas
    the others are available for all numeric data types.  The bitwise
    operators are also available for the bit
    string types <type>bit</type> and <type>bit varying</type>, as
    shown in <xref linkend="functions-bit-string-op-table">.
   </para>
-->
<para>
位操作符只能用于整数类型，而其它的操作符可以用于全部数值类型。
位操作符还可以用于位串类型<type>bit</type>和<type>bit varying</type>，
如<xref linkend="functions-bit-string-op-table">所示。
</para>

  <!--
<para>
   <xref linkend="functions-math-func-table"> shows the available
   mathematical functions.  In the table, <literal>dp</literal>
   indicates <type>double precision</type>.  Many of these functions
   are provided in multiple forms with different argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
  </para>
-->
<para>
<xref linkend="functions-math-func-table">显示了可用的数学函数。在该表中，
<literal>dp</literal>表示<type>double precision</type>。
这些函数中有许多都有多种不同的形式，区别是参数不同。除非特别指明，
任何特定形式的函数都返回和它的参数相同的数据类型。处理<type>double precision</type>
数据的函数大多数是在宿主系统的C库的基础上实现的；因此，
精度和数值范围方面的行为是根据宿主系统而变化的。
</para>

   <table id="functions-math-func-table">
    <!-- 
<title>Mathematical Functions</title> 
-->
<title>数学函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>absolute value</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>绝对值</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry>cube root</entry> 
   -->
   <entry>立方根</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <!-- 
<literal><function>ceil(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>ceil(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>smallest integer not less than argument</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>不小于参数的最小的整数</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <!-- 
<literal><function>ceiling(<type>dp</type> or <type>numeric</type>)</function></literal>
-->
<literal><function>ceiling(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>smallest integer not less than argument (alias for <function>ceil</function>)</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>不小于参数的最小整数(<function>ceil</function>的别名)</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry>radians to degrees</entry> 
   -->
   <entry>把弧度转为角度</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</>,
         <parameter>x</parameter> <type>numeric</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
   <entry>integer quotient of <parameter>y</parameter>/<parameter>x</parameter></entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <!-- 
<literal><function>exp(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>exp(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>exponential</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>自然指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <!-- 
<literal><function>floor(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>floor(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>largest integer not greater than argument</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>不大于参数的最大整数</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <!-- 
<literal><function>ln(<type>dp</type> or <type>numeric</type>)</function></literal>
-->
<literal><function>ln(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>natural logarithm</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>自然对数</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <!-- 
<literal><function>log(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>log(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>base 10 logarithm</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>以 10 为底的对数</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <!-- 
   <entry>logarithm to base <parameter>b</parameter></entry> 
   -->
   <entry>以<parameter>b</parameter>为底数的对数</entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <literal><function>mod(<parameter>y</parameter>,
         <parameter>x</parameter>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as argument types)</entry>
       <entry>remainder of <parameter>y</parameter>/<parameter>x</parameter></entry> 
   -->
   <entry>(与参数类型相同)</entry>
       <entry><parameter>y</parameter>/<parameter>x</parameter>的余数(模)</entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry><quote>&pi;</quote> constant</entry> 
   -->
   <entry><quote>&pi;</quote> 常量</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry><parameter>a</> raised to the power of <parameter>b</parameter></entry> 
   -->
   <entry><parameter>a</>的<parameter>b</parameter>次幂</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <!-- 
   <entry><parameter>a</> raised to the power of <parameter>b</parameter></entry> 
   -->
   <entry><parameter>a</>的<parameter>b</parameter>次幂</entry> 
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry>degrees to radians</entry> 
   -->
   <entry>把角度转为弧度</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>

         <primary>round</primary>
        </indexterm>
        <!-- 
<literal><function>round(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>round(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>round to nearest integer</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>圆整为最接近的整数</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <!-- 
   <entry>round to <parameter>s</parameter> decimal places</entry> 
   -->
   <entry>圆整为<parameter>s</parameter> 位小数</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>

         <primary>sign</primary>
        </indexterm>
        <!-- 
<literal><function>sign(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>sign(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>sign of the argument (-1, 0, +1)</entry>
   -->
   <entry>(与输入相同)</entry>
       <entry>参数的符号(-1, 0, +1)</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
        <!-- 
<literal><function>sqrt(<type>dp</type> or <type>numeric</type>)</function></literal>
-->
<literal><function>sqrt(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>square root</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <!-- 
<literal><function>trunc(<type>dp</type> or <type>numeric</type>)</function></literal> 
-->
<literal><function>trunc(<type>dp</type> 或 <type>numeric</type>)</function></literal>
       </entry>
       <!-- 
   <entry>(same as input)</entry>
       <entry>truncate toward zero</entry> 
   -->
   <entry>(与输入相同)</entry>
       <entry>截断(向零靠近)</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <!-- 
   <entry>truncate to <parameter>s</parameter> decimal places</entry> 
   -->
   <entry>截断为<parameter>s</parameter>位小数</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <literal><function>width_bucket(<parameter>op</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>return the bucket to which <parameter>operand</> would
       be assigned in an equidepth histogram with <parameter>count</>
       buckets, in the range <parameter>b1</> to <parameter>b2</></entry>
   -->
   <entry>返回一个桶，这个桶是在一个有<parameter>count</>个桶，
   上界为<parameter>b1</>下界为<parameter>b2</>的等深柱图中
   <parameter>operand</>将被赋予的那个桶。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>op</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>return the bucket to which <parameter>operand</> would
       be assigned in an equidepth histogram with <parameter>count</>
       buckets, in the range <parameter>b1</> to <parameter>b2</></entry>
   -->
   <entry>返回一个桶，这个桶是在一个有<parameter>count</>个桶，
   上界为<parameter>b1</>下界为<parameter>b2</>的等深柱图中
   <parameter>operand</>将被赋予的那个桶。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
  <para>
    <xref linkend="functions-math-random-table"> shows functions for
    generating random numbers.
  </para>
-->
  <para>
    <xref linkend="functions-math-random-table">显示了生成随机数的函数。
  </para>
   <table id="functions-math-random-table">
    <!-- 
    <title>Random Functions</title>
    -->
    <title>随机函数</title>
    
    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       -->
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <!-- 
   <entry>random value in the range 0.0 &lt;= x &lt; 1.0</entry> 
   -->
   <entry>0.0 到 1.0 之间的随机数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>set seed for subsequent <literal>random()</literal> calls (value between -1.0 and
       1.0, inclusive)</entry> 
   -->
   <entry>为随后的<literal>random()</literal>调用设置种子( -1.0 到 1.0 之间，包含)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!-- 
  <para>
   The characteristics of the values returned by
   <literal><function>random()</function></literal> depend
   on the system implementation. It is not suitable for cryptographic
   applications; see <xref linkend="pgcrypto"> module for an alternative.
   </para>
--> 
  <para>
   <literal><function>random()</function></literal>
   返回的值的特征依赖于系统实现。它不适用于用暗码写的应用；
   可用<xref linkend="pgcrypto">模块替代。
   </para>  
   
<!--
  <para>
   Finally, <xref linkend="functions-math-trig-table"> shows the
   available trigonometric functions.  All trigonometric functions
   take arguments and return values of type <type>double
   precision</type>. Trigonometric functions arguments are expressed
   in radians. Inverse functions return values are expressed in
   radians.  See unit transformation functions
   <literal><function>radians()</function></literal> and
   <literal><function>degrees()</function></literal> above.
  </para>
-->
<para>
最后，<xref linkend="functions-math-trig-table">显示了可用的三角函数。
所有三角函数都使用类型为<type>double precision </type>的参数和返回类型。
三角函数参数用弧度来表达。反函数的返回值也是用弧度来表达的。
参阅上面的单元转换函数<literal><function>radians()</function></literal>
和<literal><function>degrees()</function></literal>。
</para>

   <table id="functions-math-trig-table">
    <!-- 
<title>Trigonometric Functions</title> 
-->
<title>三角函数</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Description</entry> 
   -->
   <entry>函数</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>acos</primary>
        </indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>inverse cosine</entry> 
   -->
   <entry>反余弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>inverse sine</entry> 
   -->
   <entry>反正弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>inverse tangent</entry>
   -->
   <entry>反正切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>inverse tangent of
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal></entry> 
-->
<entry><literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal>的反正切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>cosine</entry> 
   -->
   <entry>余弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>cotangent</entry> 
   -->
   <entry>余切</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>sine</entry> 
   -->
   <entry>正弦</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <!-- 
   <entry>tangent</entry> 
   -->
   <entry>正切</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
   <!-- 
   <title>String Functions and Operators</title> 
   -->
   <title>字符串函数和操作符</title>

   <!--
<para>
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Unless otherwise noted, all
    of the functions listed below work on all of these types, but be
    wary of potential effects of automatic space-padding when using the
    <type>character</type> type.  Some functions also exist
    natively for the bit-string types.
   </para>
-->
<para>
本节描述了用于检查和操作字符串数值的函数和操作符。
在这个环境中的字符串包括<type>character</type>,<type>character varying</type>,
<type>text</type>类型的值。除非另外说明，所有下面列出的函数都可以处理这些类型，
不过要小心的是，在使用<type>character</type>类型的时候，需要注意自动填充的潜在影响。
有些函数还可以处理位串类型。
</para>

   <!--
<para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql">.
    <productname>PostgreSQL</> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other">).
   </para>
-->
<para>
<acronym>SQL</acronym>定义了一些字符串函数，用特定的关键字而不是逗号来分隔参数。
详情请见<xref linkend="functions-string-sql">。<productname>PostgreSQL</>
也提供了使用正常的函数调用语法实现的这些函数的版本(参阅
<xref linkend="functions-string-other">)。
</para>

   <note>
    <!--
<para>
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql">.  For other cases, insert an explicit
     coercion to <type>text</> if you need to duplicate the previous behavior.
    </para>
-->
<para>
在<productname>PostgreSQL</productname> 8.3之前，
这些函数将默默接受一些非字符串数据类型的值，由于存在从这些数据类型到<type>text</>
的隐式强制转换，转换后的它们经常发生意外的行为，因此删除了隐式强制转换。
然而，字符串连接操作符(<literal>||</>)仍接受非字符串输入，
只要至少有一个输入是字符串类型，如<xref linkend="functions-string-sql">所示。
对于其它情况下，如果你需要重复以前的行为，插入一个明确的强制转换到<type>text</>。 
</para>
   </note>

   <table id="functions-string-sql">
    <!-- 
<title><acronym>SQL</acronym> String Functions and Operators</title> 
-->
<title><acronym>SQL</acronym> 字符串函数和操作符</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
   -->
   <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>示例</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
        <!--
        String concatenation
        -->
字符串连接
        <indexterm>
         <!-- 
 <primary>character string</primary>
         <secondary>concatenation</secondary>
 -->
 <primary>字符串</primary>
         <secondary>连接</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry>
        <literal><parameter>string</parameter> <literal>||</literal>
        <parameter>non-string</parameter></literal>
        <!-- 
        or
        -->
或
        <literal><parameter>non-string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal>
       </entry>
       <entry> <type>text</type> </entry>
       <entry>
        <!--
        String concatenation with one non-string input
        -->
带有一个非字符串输入的字符串连接
       </entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Number of bits in string</entry> 
   -->
   <entry>字符串的位</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <!-- 
<literal><function>char_length(<parameter>string</parameter>)</function></literal> or <literal><function>character_length(<parameter>string</parameter>)</function></literal> 
-->
<literal><function>char_length(<parameter>string</parameter>)</function></literal> 或 <literal><function>character_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <!--
        Number of characters in string
        -->
字符串中的字符个数 
        <indexterm>
         <!-- 
 <primary>character string</primary>
         <secondary>length</secondary> 
 -->
 <primary>字符串</primary>
         <secondary>长度</secondary> 
        </indexterm>
        <indexterm>
         <!-- 
 <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see> 
 -->
 <primary>长度</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>字符串，长度</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Convert string to lower case</entry> 
   -->
   <entry>把字符串转化为小写</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Number of bytes in string</entry> 
   -->
   <entry>字符串中的字节数</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
       <primary>overlay</primary> 
 </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!--
        Replace substring
        -->
替换子字符串 
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
 <primary>position</primary> 
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Location of specified substring</entry> 
   -->
   <entry>指定子字符串的位置</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
<primary>substring</primary>
</indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!--
        Extract substring
        -->
截取子字符串 
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
       <!-- 
   Extract substring matching POSIX regular expression. See
        <xref linkend="functions-matching"> for more information on pattern
        matching. 
-->
截取匹配POSIX正则表达式的子字符串。参阅<xref linkend="functions-matching">
获取更多关于模式匹配的信息。 
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Extract substring matching <acronym>SQL</acronym> regular expression.
        See <xref linkend="functions-matching"> for more information on
        pattern matching. 
-->
截取匹配<acronym>SQL</acronym>正则表达式的子字符串。
参阅<xref linkend="functions-matching">获取更多关于模式匹配的信息。
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional>
        <optional><parameter>characters</parameter></optional> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Remove the longest string containing only the
        <parameter>characters</parameter> (a space by default) from the
        start/end/both ends of the <parameter>string</parameter> 
-->
从字符串<parameter>string</parameter>的开头/结尾/两边删除只包含
<parameter>characters</parameter>中字符 (缺省是空白)的最长的字符串 
       </entry>
       <entry><literal>trim(both 'x' from 'xTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing
        | both</optional> <optional>from</optional>
        <parameter>string</parameter>
        <optional><parameter>, characters</parameter></optional>
        )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
        Non-standard version of <function>trim()</>
        -->
        <function>trim()</>的非标准版本
       </entry>
       <entry><literal>trim(both from 'xTomxx', 'x')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Convert string to upper case</entry> 
   -->
   <entry>把字符串转化为大写</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other">.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql">.
   </para>
-->
<para>
还有额外的字符串操作函数可以用，它们在<xref linkend="functions-string-other">列出。
它们有些在内部用于实现<xref linkend="functions-string-sql">
列出的<acronym>SQL</acronym>标准字符串函数。 
</para>

   <table id="functions-string-other">
    <!-- 
<title>Other String Functions</title>
-->
<title>其它字符串函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>示例</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <!-- 
<acronym>ASCII</acronym> code of the first character of the
        argument.  For <acronym>UTF8</acronym> returns the Unicode code
        point of the character.  For other multibyte encodings, the
        argument must be an <acronym>ASCII</acronym> character. 
-->
参数中第一个字符的<acronym>ASCII</acronym>编码值。
对于<acronym>UTF8</acronym>返回字符的宽字节编码值。
对于其它的多字节编码，参数必须是一个<acronym>ASCII</acronym>字符。 
       </entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Remove the longest string consisting only of characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter> 
-->
从<parameter>string</parameter>开头和结尾删除只包含
<parameter>characters</parameter>中字符(缺省是空白)的最长字符串。 
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xy')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Character with the given code. For <acronym>UTF8</acronym> the
        argument is treated as a Unicode code point. For other multibyte
        encodings the argument must designate an
        <acronym>ASCII</acronym> character.  The NULL (0) character is not
        allowed because text data types cannot store such bytes. 
-->
给定编码的字符。对于<acronym>UTF8</acronym>这个参数作为宽字节代码处理。
对于其它的多字节编码，这个参数必须指定一个<acronym>ASCII</acronym>字符，
因为text数据类型无法存储NULL数据字节，不能将NULL(0)作为字符参数。 
       </entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type>
         [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Concatenate the text representations of all the arguments.
        NULL arguments are ignored. 
-->
连接所有参数的文本表示。NULL 参数被忽略。
       </entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>,
        <parameter>str</parameter> <type>"any"</type>
        [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Concatenate all but the first argument with separators. The first
        argument is used as the separator string. NULL arguments are ignored. 
-->
连接所有参数，但是第一个参数是分隔符，用于将所有参数分隔。NULL 参数被忽略。
       </entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert</primary>
        </indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Convert string to <parameter>dest_encoding</parameter>.  The
        original encoding is specified by
        <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
        Conversions can be defined by <command>CREATE CONVERSION</command>.
        Also there are some predefined conversions. See <xref
        linkend="conversion-names"> for available conversions. 
-->
把原来编码为<parameter>src_encoding</parameter>的字符串转换为
<parameter>dest_encoding</parameter>编码。
在这种编码格式中<parameter>string</parameter>必须是有效的。
用<command>CREATE CONVERSION</command>定义转换。
这也有些预定义的转换。 参阅<xref linkend="conversion-names">显示可用的转换。
       </entry>
       <entry><literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal></entry>
       <!-- 
   <entry><literal>text_in_utf8</literal> represented in Latin-1
       encoding (ISO 8859-1)</entry> 
   -->
   <entry><literal>text_in_utf8</literal> 用 Latin-1
       编码表示 (ISO 8859-1)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_from</primary>
        </indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Convert string to the database encoding.  The original encoding
        is specified by <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding. 
-->
把原来编码为<parameter>src_encoding</parameter>的字符串转换为数据库编码格式。
这种编码格式中，<parameter>string</parameter>必须是有效的。
       </entry>
       <entry><literal>convert_from('text_in_utf8', 'UTF8')</literal></entry>
       <!-- 
   <entry><literal>text_in_utf8</literal> represented in the current database encoding</entry> 
   -->
   <entry><literal>text_in_utf8</literal> 用当前数据库编码表示</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_to</primary>
        </indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Convert string to <parameter>dest_encoding</parameter>. 
-->
将字符串转化为<parameter>dest_encoding</parameter>编码格式。
       </entry>
       <entry><literal>convert_to('some text', 'UTF8')</literal></entry>
       <!-- 
   <entry><literal>some text</literal> represented in the UTF8 encoding</entry> 
   -->
   <entry><literal>some text</literal> 用 UTF8 编码表示</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Decode binary data from textual representation in <parameter>string</>.
        Options for <parameter>format</> are same as in <function>encode</>. 
-->
把用<parameter>string</>表示的文本里面的二进制数据解码。
<parameter>format</>选项和<function>encode</>相同。
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
       <!-- 
   Encode binary data into a textual representation.  Supported
        formats are: <literal>base64</>, <literal>hex</>, <literal>escape</>.
        <literal>escape</> converts zero bytes and high-bit-set bytes to
        octal sequences (<literal>\</><replaceable>nnn</>) and
        doubles backslashes.
-->
把二进制数据编码为文本表示。支持的格式有：<literal>base64</>, 
<literal>hex</>, <literal>escape</>。<literal>escape</>
转换零字节和高位设置字节为八进制序列(<literal>\</><replaceable>nnn</>)
和双反斜杠。
       </entry>
       <entry><literal>encode(E'123\\000\\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
         <!-- 
 Format arguments according to a format string.
         This function is similar to the C function <function>sprintf</>.
         See <xref linkend="functions-string-format">. 
 -->
 根据格式字符串格式参数。这个函数类似C函数<function>sprintf</>。
 参阅<xref linkend="functions-string-format">。
       </entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Convert the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters. 
-->
把每个单词的第一个字母转为大写，其它的保留小写。
单词是一系列字母数字组成的字符，用非字母数字分隔。
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>,
        <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return first <replaceable>n</> characters in the string. When <replaceable>n</>
        is negative, return all but last |<replaceable>n</>| characters. 
-->
返回字符串的前<replaceable>n</>个字符。当<replaceable>n</>是负数时，
返回除最后|<replaceable>n</>|个字符以外的所有字符。
        </entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <!-- 
Number of characters in <parameter>string</parameter> 
-->
<parameter>string</parameter>中字符的数目
       </entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
        <!-- 
Number of characters in <parameter>string</parameter> in the given
        <parameter>encoding</parameter>. The <parameter>string</parameter>
        must be valid in this encoding. 
-->
指定<parameter>encoding</parameter>编码格式的<parameter>string</parameter>的字符数。
在这个编码格式中，<parameter>string</parameter>必须是有效的。
       </entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the
        right). 
-->
通过填充字符<parameter>fill</parameter>(缺省时为空白)，
把<parameter>string</parameter>填充为<parameter>length</parameter>长度。
如果<parameter>string</parameter>已经比<parameter>length</parameter>长则将其尾部截断。
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>
-->
从字符串<parameter>string</parameter>的开头删除只包含<parameter>characters</parameter>
中字符(缺省是一个空白)的最长的字符串。
       </entry>
       <entry><literal>ltrim('zzzytrim', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Calculates the MD5 hash of <parameter>string</parameter>,
        returning the result in hexadecimal 
-->
计算<parameter>string</parameter>的MD5散列，以十六进制返回结果。
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>
        <!-- 
Current client encoding name 
-->
当前客户端编码名称
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example">.
-->
返回适用于<acronym>SQL</acronym>语句的标识符形式(使用适当的引号进行界定)。
只有在必要的时候才会添加引号(字符串包含非标识符字符或者会转换大小写的字符)。
嵌入的引号被恰当地写了双份。又见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example">. 
-->
返回适用于在<acronym>SQL</acronym>语句里当作文本使用的形式(使用适当的引号进行界定)。
嵌入的引号和反斜杠被恰当地写了双份。请注意，当输入是null时，
<function>quote_literal</function>返回null；如果参数可能为null，
通常<function>quote_nullable</function>更适用。
又见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Coerce the given value to text and then quote it as a literal.
        Embedded single-quotes and backslashes are properly doubled. 
-->
将给定的值强制转换为text，加上引号作为文本。嵌入的引号和反斜杠被恰当地写了双份。
       </entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, return <literal>NULL</>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example">. 
-->
返回适用于在<acronym>SQL</acronym>语句里当作字符串使用的形式(使用适当的引号进行界定)。
或者，如果参数为空，返回<literal>NULL</>。嵌入的引号和反斜杠被恰当地写了双份。
又见<xref linkend="plpgsql-quote-literal-example">。
       </entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Coerce the given value to text and then quote it as a literal;
        or, if the argument is null, return <literal>NULL</>.
        Embedded single-quotes and backslashes are properly doubled. 
-->
将给定的参数值转化为text，加上引号作为文本；或者，如果参数为空，
返回<literal>NULL</>。嵌入的引号和反斜杠被恰当地写了双份。
       </entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <literal><function>regexp_matches(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>
        <!-- 
Return all captured substrings resulting from matching a POSIX regular
        expression against the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"> for more information. 
-->
返回<parameter>string</parameter>中所有匹配POSIX正则表达式的子字符串。
参阅<xref linkend="functions-posix-regexp">获得更多信息。
       </entry>
       <entry><literal>regexp_matches('foobarbequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <literal><function>regexp_replace(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Replace substring(s) matching a POSIX regular expression. See
        <xref linkend="functions-posix-regexp"> for more information. 
-->
替换匹配 POSIX 正则表达式的子字符串。参见<xref linkend="functions-posix-regexp">
以获取更多模式匹配的信息。
       </entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
        <!-- 
Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"> for more
        information. 
-->
用POSIX正则表达式作为分隔符，分隔<parameter>string</parameter>。
参阅<xref linkend="functions-posix-regexp">以获取更多模式匹配的信息。
       </entry>
       <entry><literal>regexp_split_to_array('hello world', E'\\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
        <!-- 
Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"> for more
        information. 
-->
用POSIX正则表达式作为分隔符，分隔<parameter>string</parameter>。
参阅<xref linkend="functions-posix-regexp">以获取更多模式匹配的信息。
       </entry>
       <entry><literal>regexp_split_to_table('hello world', E'\\s+')</literal></entry>
       <entry><literal>hello</literal><para><literal>world</literal></para>(2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Repeat <parameter>string</parameter> the specified
       <parameter>number</parameter> of times</entry> 
   -->
   <entry>将<parameter>string</parameter>重复<parameter>number</parameter>次</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
   <!-- 
   Replace all occurrences in <parameter>string</parameter> of substring
        <parameter>from</parameter> with substring <parameter>to</parameter> 
-->
把字符串<parameter>string</parameter>里出现地所有子字符串<parameter>from</parameter>
替换成子字符串<parameter>to</parameter>
       </entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return reversed string. 
-->
返回颠倒的字符串
       </entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>,
         <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Return last <replaceable>n</> characters in the string. When <replaceable>n</>
        is negative, return all but first |<replaceable>n</>| characters. 
-->
返回字符串中的后<replaceable>n</>个字符。当<replaceable>n</>是负值时，
返回除前|<replaceable>n</>|个字符以外的所有字符。
       </entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated. 
-->
使用填充字符<parameter>fill</parameter>(缺省时为空白)，
把<parameter>string</parameter>填充到<parameter>length</parameter>长度。
如果<parameter>string</parameter>已经比<parameter>length</parameter>长则将其从尾部截断。
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter> 
-->
从字符串<parameter>string</parameter>的结尾删除只包含
<parameter>characters</parameter>中字符(缺省是个空白)的最长的字符串。
       </entry>
       <entry><literal>rtrim('trimxxxx', 'x')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
   <!-- 
   Split <parameter>string</parameter> on <parameter>delimiter</parameter>
        and return the given field (counting from one) 
-->
根据<parameter>delimiter</parameter>分隔<parameter>string</parameter>
返回生成的第 field 个子字符串(1为基)。
       </entry>
       <entry><literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <!-- 
Location of specified substring (same as
        <literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>, but note the reversed
        argument order) 
-->
指定的子字符串的位置。和<literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>一样，不过参数顺序相反。
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Extract substring (same as
        <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)
-->
抽取子字符串。和<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)一样
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
       <!-- 
   Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from another encoding
       (only supports conversion from  <literal>LATIN1</>, <literal>LATIN2</>, <literal>LATIN9</>,
       and <literal>WIN1250</> encodings)
   -->
   把<parameter>string</parameter>从其它编码转换为<acronym>ASCII</acronym>
   (仅支持<literal>LATIN1</>, <literal>LATIN2</>, <literal>LATIN9</>, <literal>WIN1250</>编码)。
       </entry>
       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type>
        or <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
   <!-- 
   Convert <parameter>number</parameter> to its equivalent hexadecimal
        representation 
-->
把<parameter>number</parameter>转换成十六进制表现形式
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        <!-- 
Any character in <parameter>string</parameter> that matches a
        character in the <parameter>from</parameter> set is replaced by
        the corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are removed. 
-->
把在<parameter>string</parameter>中包含的任何匹配<parameter>from</parameter>
中字符的字符转化为对应的在<parameter>to</parameter>中的字符。
如果<parameter>from</parameter>比<parameter>to</parameter>长，
删掉在<parameter>from</parameter>中出现的额外的字符。
       </entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions">).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
   </para>
-->
<para>
<function>concat</function>, <function>concat_ws</function>和<function>format</function>
函数是可变的，所以用<literal>VARIADIC</literal>
关键字标记传递的数值以连接或者格式化为一个数组是可能的。
见<xref linkend="xfunc-sql-variadic-functions">。数组的元素对函数来说是单独的普通参数。
如果可变数组的元素是NULL，那么<function>concat</function>和<function>concat_ws</function>
返回NULL，但是<function>format</function>把NULL作为零元素数组对待。
</para>

   <!--
<para>
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate">.
   </para>
-->
<para>
又见<xref linkend="functions-aggregate">里面的聚合函数<function>string_agg</function>。
</para>

   <table id="conversion-names">
    <!-- 
<title>Built-in Conversions</title> 
-->
<title>内置的转换</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry><!-- Conversion Name -->转换名
        <footnote>
         <!--
<para>
          The conversion names follow a standard naming scheme: The
          official name of the source encoding with all
          non-alphanumeric characters replaced by underscores, followed
          by <literal>_to_</literal>, followed by the similarly processed
          destination encoding name. Therefore, the names might deviate
          from the customary encoding names.
         </para>
-->
<para>
转换名遵循一个标准的命名模式：将源编码中的所有非字母数字字符用下划线替换，
后面跟着<literal>_to_</literal>，然后后面再跟着经过相似处理的目标编码的名字。
因此这些名字可能和客户的编码名字不同。
</para>
        </footnote>
       </entry>
       <!-- 
   <entry>Source Encoding</entry>
       <entry>Destination Encoding</entry> 
   -->
   <entry>源编码</entry>
       <entry>目的编码</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>tcvn_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_tcvn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <!-- 
<title><function>format</function></title> 
-->
<title><function>格式化</function></title>

    <indexterm>
     <!-- 
     <primary>format</primary>
     -->
     <primary>格式化</primary>
    </indexterm>

    <!--
<para>
     The function <function>format</> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</>.
    </para>
-->
<para>
函数<function>format</>生成根据格式字符串格式化了的输出，风格类似于C函数<function>sprintf</>。
</para>
    
<para>
<synopsis>
<function>format</>(<parameter>formatstr</> <type>text</> [, <parameter>formatarg</> <type>"any"</> [, ...] ])
</synopsis>
<!--
     <replaceable>formatstr</> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <replaceable>formatarg</> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
-->
<replaceable>formatstr</>是指定结果如何格式化的格式字符串。格式字符串中的文本直接拷贝到结果中，
除非已经使用了<firstterm>格式说明符</>。格式说明符在字符串中作为占位符使用，
定义后续函数参数应该格式化并且插入到结果中。每个<replaceable>formatarg</>
参数根据这种数据类型的通常输出规则转化为文本，然后根据格式说明符格式化并且插入到结果中。
    </para>
   
<para>
 <!--
     Format specifiers are introduced by a <literal>%</> character and have
     the form
-->
格式说明符由<literal>%</>字符引进，格式为
<synopsis>
%[<replaceable>position</>][<replaceable>flags</>][<replaceable>width</>]<replaceable>type</>
</synopsis>
    <!-- 
    where the component fields are:
    -->
组件的字段有：
     <variablelist>
      <varlistentry>
       <term><replaceable>position</replaceable> (optional)</term>
       <listitem>
        <para>
         <!-- 
 A string of the form <literal><replaceable>n</>$</> where
         <replaceable>n</> is the index of the argument to print.
         Index 1 means the first argument after
         <replaceable>formatstr</>.  If the <replaceable>position</> is
         omitted, the default is to use the next argument in sequence. 
 -->
 <literal><replaceable>n</>$</>格式的字符串，这里的<replaceable>n</>
 是要打印的参数的索引。索引为1表示在<replaceable>formatstr</>
 之后的第一个参数。如果省略了<replaceable>position</>，
 默认使用序列中的下一个参数。
        </para>

       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>flags</replaceable> (optional)</term>
       <listitem>
        <!--
<para>
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <replaceable>width</>
         field is also specified.
        </para>
-->
<para>
附加选项，控制如何格式化格式说明符的输出。当前只支持负号(<literal>-</>)，
负号导致格式说明符的输出是左对齐的。这是没有影响的，除非指定了
<replaceable>width</>字段。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>width</replaceable> (optional)</term>
       <listitem>
        <!--
<para>
         Specifies the <emphasis>minimum</> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</>) to use the next function argument as the
         width; or a string of the form <literal>*<replaceable>n</>$</> to
         use the <replaceable>n</>th function argument as the width.
        </para>
-->
<para>
声明字符数的<emphasis>minimum</>值用来显示格式说明符的输出。需要补充宽度时，
空白添加到输出的左侧或右侧（取决于<literal>-</>标志）。一个比较小的宽度不会导致输出的截断，
只是简单的忽略了。宽度可以用下列方法指定：一个正整数；一个星号(<literal>*</>)
表示使用下一个函数参数作为宽度；或一个格式为<literal>*<replaceable>n</>$</>
的字符串表示使用第<replaceable>n</>个函数参数作为宽度。
</para>

        <!--
<para>
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</> flag had been specified) within a
         field of length <function>abs</>(<replaceable>width</replaceable>).
        </para>
-->
<para>
如果宽度来自函数参数，那么这个参数在作为格式说明符的数值之前消耗掉。
如果宽度参数是负的，那么结果是左对齐的（就像声明了<literal>-</>标志一样），
并且字段长度为<function>abs</>(<replaceable>width</replaceable>)。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>type</replaceable> (required)</term>
       <listitem>
       
<para>
 <!--
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
-->
格式转换的类型用来产生格式说明符的输出。支持下列的类型：
         <itemizedlist>
          <listitem>
<!-- 
           <para>
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
           </para>
 -->
<para>
<literal>s</literal>格式参数值为简单的字符串。空值作为空字符串对待。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null.
           </para>
-->
<para>
<literal>I</literal>将参数值作为SQL标识符对待，如果需要，双写它。值为空是错误的。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</>, without
            quotes.
           </para>
-->
<para>
<literal>L</literal>引用参数值作为SQL文字。空值用字符串<literal>NULL</>显示，没有引用。
</para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <!--
<para>
     In addition to the format specifiers described above, the special sequence
     <literal>%%</> may be used to output a literal <literal>%</> character.
    </para>
-->
<para>
除了上述的格式说明符，特殊的序列<literal>%%</>可以用作输出<literal>%</>字符。
</para>
    
<para>
<!--
     Here are some examples of the basic format conversions:
-->
这里有一些基本的格式转换的例子：
<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing one, two, three, %</>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>
    
<para>
<!--
     Here are examples using <replaceable>width</replaceable> fields
     and the <literal>-</> flag:
-->
这里是使用<replaceable>width</replaceable>字段和<literal>-</>标志的例子：
<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </><computeroutput>|       foo|</>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </><computeroutput>|       foo|</>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>
</screen>
    </para>
    
<para>
<!--
     These examples show use of <replaceable>position</> fields:
-->
下面是使用<replaceable>position</>字段的例子：
<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing three, two, one</>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </><computeroutput>|       bar|</>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </><computeroutput>|       foo|</>
</screen>
    </para>
   
<para>
 <!--
     Unlike the standard C function <function>sprintf</>,
     <productname>PostgreSQL</>'s <function>format</> function allows format
     specifiers with and without <replaceable>position</> fields to be mixed
     in the same format string.  A format specifier without a
     <replaceable>position</> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</> function does not require all
     function arguments to be used in the format string.
     For example:
-->
和C函数<function>sprintf</>不同，<productname>PostgreSQL</>的<function>format</>
函数允许带有或不带有<replaceable>position</>字段的格式说明符在相同的格式字符串中混合使用。
没有<replaceable>position</>字段的格式说明符总是使用最后消耗参数的下一个参数。
另外，<function>format</>函数不要求在格式字符串中使用所有函数参数。例如：
<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing three, two, three</>
</screen>
    </para>

    <!--
<para>
     The <literal>%I</> and <literal>%L</> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example">.
    </para>
-->
<para>
<literal>%I</>和<literal>%L</>格式说明符对于安全构造动态SQL语句尤其有用。
参阅<xref linkend="plpgsql-quote-literal-example">。
</para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
   <!-- 
   <title>Binary String Functions and Operators</title> 
   -->
   <title>二进制字符串函数和操作符</title>

   <indexterm zone="functions-binarystring">
    <!-- 
<primary>binary data</primary>
    <secondary>functions</secondary> 
-->
<primary>二进制数据</primary>
    <secondary>函数</secondary>
   </indexterm>

   <!--
<para>
    This section describes functions and operators for examining and
    manipulating values of type <type>bytea</type>.
   </para>
-->
<para>
本节描述那些检查和操作类型为<type>bytea</type>数值的函数和操作符。
</para>

   <!--
<para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql">.
    <productname>PostgreSQL</> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other">).
   </para>
-->
<para>
<acronym>SQL</acronym>定义了一些字符串函数，
在这些函数里使用关键字而不是逗号来分隔参数。
详情请见<xref linkend="functions-binarystring-sql">。
<productname>PostgreSQL</>也提供了使用常用语法进行函数调用的函数的版本
(参阅<xref linkend="functions-binarystring-other">)。
</para>

   <note>
    <!--
<para>
     The sample results shown on this page assume that the server parameter
     <link linkend="guc-bytea-output"><varname>bytea_output</></link> is set
     to <literal>escape</literal> (the traditional PostgreSQL format).
    </para>
-->
<para>
本页面例子的结果在假设服务器的参数<link linkend="guc-bytea-output"><varname>bytea_output</></link>
设置为<literal>escape</literal>的基础上的（传统的PostgreSQL格式）。
</para>
   </note>

   <table id="functions-binarystring-sql">
    <!-- 
<title><acronym>SQL</acronym> Binary String Functions and Operators</title> 
-->
<title><acronym>SQL</acronym> 二进制字符串函数和操作符</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
        <!-- 
String concatenation 
-->
字符串连接
        <indexterm>
         <!-- 
 <primary>binary string</primary>
         <secondary>concatenation</secondary> 
 -->
 <primary>二进制字符串</primary>
         <secondary>连接</secondary>
        </indexterm>
       </entry>
       <entry><literal>E'\\\\Post'::bytea || E'\\047gres\\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Number of bytes in binary string</entry>
   -->
   <entry>二进制字符串中的字节数</entry>
       <entry><literal>octet_length(E'jo\\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Replace substring 
-->
替换子串
       </entry>
       <entry><literal>overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002\\003mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Location of specified substring</entry> 
   -->
   <entry>特定子字符串的位置</entry>
      <entry><literal>position(E'\\000om'::bytea in E'Th\\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Extract substring 
-->
截取子串
       </entry>
       <entry><literal>substring(E'Th\\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Remove the longest string containing only the bytes in
        <parameter>bytes</parameter> from the start
        and end of <parameter>string</parameter> 
-->
从<parameter>string</parameter>的开头和结尾删除只包含
<parameter>bytes</parameter>中字节的最长字符串
       </entry>
       <entry><literal>trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other">.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql">.
   </para>
-->
<para>
还有一些二进制字符串处理函数可以使用，在<xref linkend="functions-binarystring-other">
列出。其中有一些是在内部使用，用于实现<xref linkend="functions-binarystring-sql">
列出的<acronym>SQL</acronym>标准的字符串函数。
</para>

   <table id="functions-binarystring-other">
    <!-- 
<title>Other Binary String Functions</title> 
-->
<title>其它二进制字符串函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Remove the longest string consisting only of bytes
        in <parameter>bytes</parameter> from the start and end of
        <parameter>string</parameter> 
-->
从<parameter>string</parameter>的开头和结尾删除只包含<parameter>bytes</parameter>
中字节的最长的字符串
      </entry>
      <entry><literal>btrim(E'\\000trim\\000'::bytea, E'\\000'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
       <!-- 
   Decode binary data from textual representation in <parameter>string</>.
       Options for <parameter>format</> are same as in <function>encode</>. 
   -->
   把<parameter>string</>中的文本表示解码为二进制数据。<parameter>format</>
   的选项和<function>encode</>相同。
      </entry>
      <entry><literal>decode(E'123\\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
       <!-- 
   Encode binary data into a textual representation.  Supported
       formats are: <literal>base64</>, <literal>hex</>, <literal>escape</>.
       <literal>escape</> converts zero bytes and high-bit-set bytes to
       octal sequences (<literal>\</><replaceable>nnn</>) and
       doubles backslashes. 
   -->
   把二进制数据编码为文本表现形式。支持的格式：<literal>base64</>, 
   <literal>hex</>, <literal>escape</>。<literal>escape</>
   转换零字节和高位设置字节为八进制序列(<literal>\</><replaceable>nnn</>)
   和双写反斜杠。
      </entry>
      <entry><literal>encode(E'123\\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
       <!-- 
   Extract bit from string 
   -->
   从字符串中抽取位
       </entry>
       <entry><literal>get_bit(E'Th\\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
        <!-- 
Extract byte from string 
-->
从字符串中抽取字节
       </entry>
       <entry><literal>get_byte(E'Th\\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>
       <!-- 
   Length of binary string
   -->
   二进制字符串的长度
       <indexterm>
        <!-- 
<primary>binary string</primary>
        <secondary>length</secondary> 
-->
<primary>二进制字符串</primary>
        <secondary>长度</secondary> 
       </indexterm>
       <indexterm>
        <!-- 
<primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see> 
-->
<primary>长度</primary>
        <secondary sortas="binary string">二进制字符串</secondary>
        <see>二进制字符串，长度</see> 
       </indexterm>
      </entry>
      <entry><literal>length(E'jo\\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
       <!-- 
   Calculates the MD5 hash of <parameter>string</parameter>,
       returning the result in hexadecimal
   -->
   计算<parameter>string</parameter>的MD5散列值，以十六进制方式返回结果。
      </entry>
      <entry><literal>md5(E'Th\\000omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9689aaf18 b4958c334c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <literal><function>set_bit(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Set bit in string 
-->
设置字符串中的位
       </entry>
       <entry><literal>set_bit(E'Th\\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <literal><function>set_byte(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        <!-- 
Set byte in string 
-->
设置字符串中的字节
       </entry>
       <entry><literal>set_byte(E'Th\\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   <function>get_byte</> and <function>set_byte</> number the first byte
   of a binary string as byte 0.
   <function>get_bit</> and <function>set_bit</> number bits from the
   right within each byte; for example bit 0 is the least significant bit of
   the first byte, and bit 15 is the most significant bit of the second byte.
  </para>
-->
<para>
<function>get_byte</>和<function>set_byte</>数以二进制字符串的第一个字节为0字节。
<function>get_bit</>和<function>set_bit</>从每个字节的右边取位；
例如位0是第一个字节的最低位，位15是第二个字节的最高位。
</para>

  <!--
<para>
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"> and the large object functions
   in <xref linkend="lo-funcs">.
   </para>
-->
<para>
又见<xref linkend="functions-aggregate">中的聚合函数<function>string_agg</function>，
和<xref linkend="lo-funcs">中的大对象函数。
</para>
 </sect1>


  <sect1 id="functions-bitstring">
   <!-- 
   <title>Bit String Functions and Operators</title> 
   -->
   <title>位串函数和操作符</title>

   <indexterm zone="functions-bitstring">
    <!-- 
<primary>bit strings</primary>
    <secondary>functions</secondary> 
-->
<primary>位串</primary>
    <secondary>函数</secondary> 
   </indexterm>

   <!--
<para>
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  Aside from the
    usual comparison operators, the operators
    shown in <xref linkend="functions-bit-string-op-table"> can be used.
    Bit string operands of <literal>&amp;</literal>, <literal>|</literal>,
    and <literal>#</literal> must be of equal length.  When bit
    shifting, the original length of the string is preserved, as shown
    in the examples.
   </para>
-->
<para>
本节描述用于检查和操作位串的函数和操作符，也就是操作类型为<type>bit</type>
和<type>bit varying</type>值的函数和操作符。除了常用的比较操作符之外，
还可以使用<xref linkend="functions-bit-string-op-table">里显示的操作符。
<literal>&amp;</literal>, <literal>|</literal>,<literal>#</literal>
的位串操作数必须等长。在移位的时候，保留原始的位串长度(并以 0 填充)，如例子所示。
</para>

   <table id="functions-bit-string-op-table">
    <!-- 
<title>Bit String Operators</title> 
-->
<title>位串操作符</title>

    <tgroup cols="4">
     <thead>
      <row>
       <!-- 
   <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry> 
   -->
   <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
       <!-- 
   <entry>concatenation</entry> 
   -->
   <entry>连接</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <!-- 
   <entry>bitwise AND</entry> 
   -->
   <entry>位与</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <!-- 
   <entry>bitwise OR</entry> 
   -->
   <entry>位或</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <!-- 
   <entry>bitwise XOR</entry> 
   -->
   <entry>位异或</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <!-- 
   <entry>bitwise NOT</entry> 
   -->
   <entry>位非</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <!-- 
   <entry>bitwise shift left</entry> 
   -->
   <entry>位左移</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <!-- 
   <entry>bitwise shift right</entry> 
   -->
   <entry>位右移</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The following <acronym>SQL</acronym>-standard functions work on bit
    strings as well as character strings:
    <literal><function>length</function></literal>,
    <literal><function>bit_length</function></literal>,
    <literal><function>octet_length</function></literal>,
    <literal><function>position</function></literal>,
    <literal><function>substring</function></literal>,
    <literal><function>overlay</function></literal>.
   </para>
-->
<para>
下面的<acronym>SQL</acronym>标准函数除了可以用于字符串之外，也可以用于位串：
<literal><function>length</function></literal>,
<literal><function>bit_length</function></literal>,
<literal><function>octet_length</function></literal>,
<literal><function>position</function></literal>,
<literal><function>substring</function></literal>,
<literal><function>overlay</function></literal>。
</para>

   <!--
<para>
    The following functions work on bit strings as well as binary
    strings:
    <literal><function>get_bit</function></literal>,
    <literal><function>set_bit</function></literal>.
    When working with a bit string, these functions number the first
    (leftmost) bit of the string as bit 0.
   </para>
-->
<para>
下面的函数用于位串和二进制字符串：<literal><function>get_bit</function></literal>，
<literal><function>set_bit</function></literal>。当用于位串时，
这些函数位数从字符串的第一位（最左边）作为0位 。
</para>
   
<para>
<!--
    In addition, it is possible to cast integral values to and from type
    <type>bit</>.
    Some examples:
-->
另外，我们可以在整数和<type>bit</>之间来回转换。例子：
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
<!-- 
    Note that casting to just <quote>bit</> means casting to
    <literal>bit(1)</>, and so will deliver only the least significant
    bit of the integer. 
-->
请注意，只是转换为<quote>bit</>的意思是转换成<literal>bit(1)</>，因此只会转换成整数的最低位。
   </para>

    <note>
     <!--
<para>
      Casting an integer to <type>bit(n)</> copies the rightmost
      <literal>n</> bits.  Casting an integer to a bit string width wider
      than the integer itself will sign-extend on the left.
     </para>
-->
<para>
将整数转换成<type>bit(n)</>拷贝了最右边的<literal>n</>位。
将一个整数转换成比它宽一些的位字符串将在左边符号扩展。
</para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
  <!-- 
  <title>Pattern Matching</title> 
  -->
  <title>模式匹配</title>

  <indexterm zone="functions-matching">
   <!-- 
   <primary>pattern matching</primary> 
   -->
   <primary>模式匹配</primary>
  </indexterm>

   <!--
<para>
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
   </para>
-->
<para>
<productname>PostgreSQL</productname>提供了三种实现模式匹配的方法：
传统<acronym>SQL</acronym>的<function>LIKE</function>操作符、SQL99 新增的
<function>SIMILAR TO</function>操作符、<acronym>POSIX</acronym>风格的正则表达式。
除了基本的<quote>这个字符串匹配这个模式</>操作符之外，
也可以使用函数抽取或替换匹配的子字符串并且在匹配的位置分隔字符串。
</para>

   <tip>
    <!--
<para>
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
    </para>
-->
<para>
如果你的模式匹配要求比这些还多，请考虑用 Perl 或 Tcl 写一个用户定义函数。
</para>
   </tip>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <!--
<para>
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
    </para>
-->
<para>
如果该<replaceable>string</replaceable>匹配提供的<replaceable>pattern</replaceable>，
那么<function>LIKE</function>表达式返回真。和我们想像的一样，如果<function>LIKE</function>
返回真，那么<function>NOT LIKE</function>表达式将返回假，反之亦然。
一个等效的表达式是<literal>NOT (<replaceable>string</replaceable> LIKE
 <replaceable>pattern</replaceable>)</literal>。
</para>

    <!--
<para>
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
    </para>
-->
<para>
如果<replaceable>pattern</replaceable>不包含百分号或者下划线，那么该模式只代表它本身；
这时候<function>LIKE</function>的行为就像等号操作符。在<replaceable>pattern</replaceable>
里的下划线(<literal>_</literal>)匹配任何单个字符；而一个百分号(<literal>%</literal>)
匹配零或多个任何序列。
</para>
  
<para>
 <!--
    Some examples:
-->
一些例子：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>
   <!--
<para>
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
   </para>
-->
<para>
<function>LIKE</function>模式匹配总是覆盖整个字符串。因此，
如果想要匹配在字符串内部任何位置的序列，该模式必须以百分号开头和结尾。
</para>

   <!--
<para>
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
   </para>
-->
<para>
要匹配下划线或者百分号本身，在<replaceable>pattern</replaceable>
里相应的字符必须前导转义字符。缺省的转义字符是反斜杠，
但是你可以用<literal>ESCAPE</literal>子句指定一个。要匹配转义字符本身，
写两个转义字符。
</para>

   <note>
    <!--
<para>
     If you have <xref linkend="guc-standard-conforming-strings"> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"> for more information.
    </para>
-->
<para>
如果你关闭了<xref linkend="guc-standard-conforming-strings">选项，
那么在文本字符串常量里的任意反斜杠都需要双写。
参阅<xref linkend="sql-syntax-strings">获取更多信息。
</para>
   </note>

   <!--
<para>
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
   </para>
-->
<para>
我们也可以通过写成<literal>ESCAPE ''</literal>的方式关闭转义机制，
这时，我们就不能关闭下划线和百分号的特殊含义。
</para>

   <!--
<para>
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
   </para>
-->
<para>
关键字<token>ILIKE</token>可以用于替换<token>LIKE</token>，
令该匹配就当前的区域设置是大小写无关的。这个特性不是<acronym>SQL</acronym>标准，
是<productname>PostgreSQL</productname>扩展。
</para>

   <!--
<para>
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.
   </para>
-->
<para>
操作符<literal>~~</literal>等效于<function>LIKE</function>，而<literal>~~*</literal>
等效于<function>ILIKE</function>。还有<literal>!~~</literal>和<literal>!~~*</literal>
操作符分别代表<function>NOT LIKE</function>和<function>NOT ILIKE</function>。
所有这些操作符都是<productname>PostgreSQL</productname>特有的。
</para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
   <!-- 
   <title><function>SIMILAR TO</function> Regular Expressions</title> 
   -->
   <title><function>SIMILAR TO</function> 正则表达式</title>

   <indexterm>
    <!-- 
<primary>regular expression</primary> 
-->
<primary>正则表达式</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build --> <!--这一句是原文自带注释 -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <!-- 
<primary>substring</primary> 
-->
<primary>子字符串</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <!--
<para>
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common regular
    expression notation.
   </para>
-->
<para>
<function>SIMILAR TO</function>根据自己的模式是否匹配给定字符串而返回真或者假。
它和<function>LIKE</function>非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。
SQL 标准的正则表达式是在<function>LIKE</function>
表示法和普通的正则表达式表示法之间古怪的交叉。
</para>

   <!--
<para>
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</> and <literal>%</> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</> and <literal>.*</> in POSIX regular
    expressions).
   </para>
-->
<para>
类似<function>LIKE</function>，<function>SIMILAR TO</function>
操作符只有在它的模式匹配整个字符串的时候才能成功；
这一点和普通的正则表达式的行为不同，在普通的正则表达式里，
模式匹配字符串的任意部分。和<function>LIKE</function>类似的地方还有
<function>SIMILAR TO</function>使用<literal>_</>和<literal>%</>
分别匹配单个字符和任意字符串(这些和 POSIX 正则表达式里的<literal>.</>
和<literal>.*</>兼容)。
</para>
  
<para>
 <!--
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
-->
除了这些从<function>LIKE</function>借用的功能之外，<function>SIMILAR TO</function>
支持下面这些从 POSIX 正则表达式借用的模式匹配元字符：
   <itemizedlist>
    <listitem>
     <!-- 
 <para>
      <literal>|</literal> denotes alternation (either of two alternatives).
     </para> 
 -->
<para>
<literal>|</literal>表示选择(两个候选之一)
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
     </para>
-->
<para>
<literal>*</literal>表示重复前面的项零次或更多次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
     </para>
-->
<para>
<literal>+</literal>表示重复前面的项一次或更多次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
     </para>
-->
<para>
<literal>?</literal>表示重复前面的项零次或一次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>{</><replaceable>m</><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</> times.
     </para>
-->
<para>
<literal>{</><replaceable>m</><literal>}</literal>表示重复前面的项正好<replaceable>m</>次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>{</><replaceable>m</><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</> or more times.
     </para>
-->
<para>
<literal>{</><replaceable>m</><literal>,}</literal>表示重复前面的项<replaceable>m</>或更多次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
      denotes repetition of the previous item at least <replaceable>m</> and
      not more than <replaceable>n</> times.
     </para>
-->
<para>
<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
表示重复前面的项至少<replaceable>m</>次，最多不超过<replaceable>n</>次
</para>
    </listitem>
    <listitem>
     <!--
<para>
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
     </para>
-->
<para>
Parentheses <literal>()</literal>把项组合成一个逻辑项
</para>
    </listitem>
    <listitem>
     <!--
<para>
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
     </para>
-->
<para>
<literal>[...]</literal> 声明一个字符类，只在POSIX正则表达式中
</para>
    </listitem>
   </itemizedlist>

    <!-- 
Notice that the period (<literal>.</>) is not a metacharacter
    for <function>SIMILAR TO</>. 
-->
请注意点(<literal>.</>)对于<function>SIMILAR TO</>来说不是元字符。
   </para>

   <!--
<para>
    As with <function>LIKE</>, a backslash disables the special meaning
    of any of these metacharacters; or a different escape character can
    be specified with <literal>ESCAPE</>.
   </para>
-->
<para>
和<function>LIKE</>一样，反斜杠关闭所有这些元字符的特殊含义；
当然我们也可以用<literal>ESCAPE</>声明另外一个转义字符。
</para>
 
<para>
  <!--
    Some examples:
-->
一些例子：
<programlisting>
'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <!--
<para>
    The <function>substring</> function with three parameters,
    <function>substring(<replaceable>string</replaceable> from
    <replaceable>pattern</replaceable> for
    <replaceable>escape-character</replaceable>)</function>, provides
    extraction of a substring that matches an SQL
    regular expression pattern.  As with <literal>SIMILAR TO</>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern that should be returned on success, the pattern must contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</>). <!&#045- " font-lock sanity &#045->
    The text matching the portion of the pattern
    between these markers is returned.
   </para>
-->
<para>
带三个参数的<function>substring(<replaceable>string</replaceable> from 
<replaceable>pattern</replaceable> for 
<replaceable>escape-character</replaceable>)</function>
函数提供了一个从字符串中抽取一个匹配 SQL 正则表达式模式的子字符串功能。
和<literal>SIMILAR TO</>一样，声明的模式必须匹配整个字符串，
否则函数失效并返回 NULL 。为了标识在成功的时候应该返回的模式部分，
模式必须出现后跟双引号(<literal>"</>)的两个转义字符。
匹配这两个标记之间的模式的字符串将被返回。
</para>
   
<para>
<!--
    Some examples, with <literal>#&quot;</> delimiting the return string:
-->
一些例子，以<literal>#&quot;</>分隔返回的字符串：
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-posix-regexp">
   <!-- 
   <title><acronym>POSIX</acronym> Regular Expressions</title> 
   -->
   <title><acronym>POSIX</acronym> 正则表达式</title>

   <indexterm zone="functions-posix-regexp">
    <!-- 
<primary>regular expression</primary>
    <seealso>pattern matching</seealso> 
-->
<primary>正则表达式</primary>
    <seealso>模式匹配</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

   <!--
<para>
    <xref linkend="functions-posix-table"> lists the available
    operators for pattern matching using POSIX regular expressions.
   </para>
-->
<para>
<xref linkend="functions-posix-table">列出了所有用于 POSIX 正则表达式的操作符。
</para>

   <table id="functions-posix-table">
    <!-- 
<title>Regular Expression Match Operators</title> 
-->
<title>正则表达式匹配操作符</title>

    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry> 
   -->
   <entry>操作符</entry>
       <entry>描述</entry>
       <entry>例子</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
        <!-- 
<entry>Matches regular expression, case sensitive</entry> 
-->
<entry>匹配正则表达式，大小写相关</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
        <!-- 
<entry>Matches regular expression, case insensitive</entry> 
-->
<entry>匹配正则表达式，大小写无关</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
        <!-- 
<entry>Does not match regular expression, case sensitive</entry> 
-->
<entry>不匹配正则表达式，大小写相关</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
        <!-- 
<entry>Does not match regular expression, case insensitive</entry> 
-->
<entry>不匹配正则表达式，大小写无关</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <!--
<para>
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
    </para>
-->
<para>
<acronym>POSIX</acronym>正则表达式提供了比<function>LIKE</function>和<function>SIMILAR TO</>
操作符更强大的模式匹配的方法。许多 Unix 工具，比如<command>egrep</command>,
<command>sed</command>,<command>awk</command>使用类似的模式匹配语言。
</para>

    <!--
<para>
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
    </para>
-->
<para>
正则表达式是一个字符序列，它是定义一个字符串集合(一个<firstterm>正则集合</firstterm>
)的缩写。如果一个字符串是正则表达式描述的正则集合中的一员时，
我们就说这个字符串匹配该正则表达式。和<function>LIKE</function>一样，
模式字符准确地匹配字符串字符，除非在正则表达式语言里有特殊字符
(不过正则表达式用的特殊字符和<function>LIKE</function>用的不同)。
和<function>LIKE</function>不一样的是，正则表达式可以匹配字符串里的任何位置，
除非该正则表达式明确地锚定在字符串的开头或者结尾。
</para>
    
<para>
<!--
     Some examples:
-->
一些例子：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

    <!--
<para>
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
    </para>
-->
<para>
<acronym>POSIX</acronym>模式语言将在下面详细描述。
</para>

    <!--
<para>
     The <function>substring</> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
    </para>
-->
<para>
带两个参数的<function>substring(<replaceable>string</replaceable> from
 <replaceable>pattern</replaceable>)</function>
函数提供了从字符串中抽取一个匹配 POSIX 正则表达式模式的子字符串的方法。
如果没有匹配它返回 NULL ，否则就是文本中匹配模式的那部分。
但是如果该模式包含任何圆括弧，那么将返回匹配第一对子表达式(对应第一个左圆括弧的)的文本。
如果你想在表达式里使用圆括弧而又不想导致这个例外，
那么你可以在整个表达式外边放上一对圆括弧。如果你需要在想抽取的子表达式前有圆括弧，
参阅描述的非捕获性圆括弧。
</para>
   
<para>
<!--
    Some examples:
-->
一些例子：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>
    <!--
<para>
     The <function>regexp_replace</> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</>,
     <replaceable>pattern</>, <replaceable>replacement</>
     <optional>, <replaceable>flags</> </optional>).
     The <replaceable>source</> string is returned unchanged if
     there is no match to the <replaceable>pattern</>.  If there is a
     match, the <replaceable>source</> string is returned with the
     <replaceable>replacement</> string substituted for the matching
     substring.  The <replaceable>replacement</> string can contain
     <literal>\</><replaceable>n</>, where <replaceable>n</> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</> specifies case-insensitive
     matching, while flag <literal>g</> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</>) are
     described in <xref linkend="posix-embedded-options-table">.
    </para>
-->
<para>
<function>regexp_replace</function>(<replaceable>source</>,
<replaceable>pattern</>, <replaceable>replacement</>
<optional>, <replaceable>flags</> </optional>)函数提供了将匹配 POSIX 
正则表达式模式的子字符串替换为新文本的功能。如果没有匹配 pattern 的子字符串，
那么返回不加修改的<replaceable>source</>字符串。如果有匹配，
则返回的 <replaceable>source</>字符串里面的对应子字符串将被<replaceable>replacement</>
字符串替换掉。<replaceable>replacement</>字符串可以包含<literal>\</><replaceable>n</>，
这里的<replaceable>n</>是 1 到 9 ，表明源字符串中匹配第<replaceable>n</>
个圆括弧子表达式的部分将插入在该位置，并且它可以包含<literal>\&amp;</>
表示应该插入匹配整个模式的字符串。如果你需要放一个文本反斜杠在替换文本里，
那么写<literal>\\</>。可选的<replaceable>flags</>
参数包含零个或多个改变函数行为的单字母标记。<literal>i</>表示进行大小写无关的匹配，
<literal>g</>表示替换每一个匹配的子字符串而不仅仅是第一个。支持的标记（不是<literal>g</>）在
<xref linkend="posix-embedded-options-table">中描述。
</para>
   
<para>
<!--
    Some examples:
-->
一些例子：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

    <!--
<para>
     The <function>regexp_matches</> function returns a text array of
     all of the captured substrings resulting from matching a POSIX
     regular expression pattern.  It has the syntax
     <function>regexp_matches</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     The function can return no rows, one row, or multiple rows (see
     the <literal>g</> flag below).  If the <replaceable>pattern</>
     does not match, the function returns no rows.  If the pattern
     contains no parenthesized subexpressions, then each row
     returned is a single-element text array containing the substring
     matching the whole pattern.  If the pattern contains parenthesized
     subexpressions, the function returns a text array whose
     <replaceable>n</>'th element is the substring matching the
     <replaceable>n</>'th parenthesized subexpression of the pattern
     (not counting <quote>non-capturing</> parentheses; see below for
     details).
     The <replaceable>flags</> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>g</> causes the function to find
     each match in the string, not only the first one, and return a row for
     each such match.  Supported flags (though
     not <literal>g</>)
     are described in <xref linkend="posix-embedded-options-table">.
    </para>
-->
<para>
<function>regexp_matches</function>(<replaceable>string</>, <replaceable>pattern</><optional>, 
<replaceable>flags</> </optional>)函数返回一个从匹配POSIX正则表达式模式中获取的所有子串结果的text数组。
这个函数可以返回零行，一行，或者多行（参阅下面的<literal>g</>标记）。如果<replaceable>pattern</>
没有匹配，则函数返回零行。如果模式包含没有括号的子表达式，则每行返回的是单元素的文本数组，
其中包含的子串相匹配整个模式。如果模式包含有括号的子表达式，函数返回一个文本数组，它的第
<replaceable>n</>个元素是子串匹配模式括号子表达式内的第<replaceable>n</>个元素。
（不计<quote>非捕获</>的括号；详细信息参阅下面）。参数<replaceable>flags</>是一个可选的text字符串，
含有0或者更多单字母标记来改变函数行为。标记<literal>g</>导致查找字符串中的每个匹配，而不仅是第一个，
每个匹配返回一行，支持的标记（不是<literal>g</>）在<xref linkend="posix-embedded-options-table">里描述。
</para>
   
<para>
<!--
    Some examples:
-->
一些例子：
<programlisting>
SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
 regexp_matches 
----------------
 {bar,beque}
(1 row)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches 
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)

SELECT regexp_matches('foobarbequebaz', 'barbeque');
 regexp_matches 
----------------
 {barbeque}
(1 row)
</programlisting>
   </para>
   
<para>
<!--
    It is possible to force <function>regexp_matches()</> to always
    return one row by using a sub-select;  this is particularly useful
    in a <literal>SELECT</> target list when you want all rows
    returned, even non-matching ones:
-->
使用select子句，可能强制<function>regexp_matches()</>总是返回一行；
当你想要返回<literal>SELECT</>目标列表中的所有行，甚至没有匹配的情况下，是有特别有用的。
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
   </para>

    <!--
<para>
     The <function>regexp_split_to_table</> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     If there is no match to the <replaceable>pattern</>, the function returns the
     <replaceable>string</>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table">.
    </para>
-->
<para>
<function>regexp_split_to_table</function>(<replaceable>string</>, <replaceable>pattern</><optional>,
 <replaceable>flags</> </optional>)函数使用POSIX正则表达式模式作为分隔符，分隔字符串。
如果没有匹配<replaceable>pattern</>，函数将返回<replaceable>string</>。如果有至少一个匹配，
每个匹配返回从最后一个匹配结束（或者字符串的开头）到匹配开始的文本。当没有更多的匹配，
返回最后一个匹配的结束到字符串的结束的文本。<replaceable>flags</>参数是一个可选text字符串，
含有0或者更多单字母标记来改变函数行为。<function>regexp_split_to_table</function>
支持的标记在<xref linkend="posix-embedded-options-table">里描述。
</para>

    <!--
<para>
     The <function>regexp_split_to_array</> function behaves the same as
     <function>regexp_split_to_table</>, except that <function>regexp_split_to_array</>
     returns its result as an array of <type>text</>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</>.
    </para>
-->
<para>
除了<function>regexp_split_to_array</>返回结果为text数组，<function>regexp_split_to_array</>
函数行为与<function>regexp_split_to_table</>相同，使用语法<function>regexp_split_to_array</function>
(<replaceable>string</>, <replaceable>pattern</><optional>, <replaceable>flags</> </optional>)。
参数与<function>regexp_split_to_table</>相同。
</para>
   
<para>
<!--
    Some examples:
-->
一些例子：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

   <!--
<para>
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_matches</>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
   </para>
-->
<para>
作为最后一个例子表明，发生在字符串的开始或结束或紧接前一个的匹配，regexp分隔函数忽略零长度匹配，
这样实现<function>regexp_matches</>严格上来说是违背了的正则表达式匹配的定义，但在实际使用中，
通常是最便利的的行为。如Perl等软件系统，使用了类似的定义。
</para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
    <!-- 
<title>Regular Expression Details</title>
-->
<title>正则表达式细节</title>

   <!--
<para>
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
   </para>
-->
<para>
<productname>PostgreSQL</productname>的正则表达式使用 Henry Spencer 写的一个包来实现。
下面的大部分描述都是从他的手册页里逐字拷贝过来的。
</para>

   <!--
<para>
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</> <acronym>RE</acronym>s or <acronym>ERE</>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</> <acronym>RE</acronym>s or <acronym>BRE</>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</> <acronym>RE</acronym>s or <acronym>ARE</>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
   </para>
-->
<para>
正则表达式(<acronym>RE</acronym>s)，在<acronym>POSIX</acronym> 1003.2中定义，
它有两种形式：<firstterm>扩展</> <acronym>RE</acronym>或<acronym>ERE</>
(基本上就是在<command>egrep</command>里的那些)，<firstterm>基本</><acronym>RE</acronym>
或<acronym>BRE</>(基本上就是在<command>ed</command>里的那些)。<productname>PostgreSQL</productname>
两种形式都实现了，并且还做了一些 POSIX 里面没有的，
但是因为在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。
使用了那些非 POSIX 扩展的正则表达式叫<firstterm>高级</><acronym>RE</acronym>
或<acronym>ARE</>。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容(以及更多的限制)。
我们首先描述 ARE 和 ERE 形式，描述那些只适用于 ARE 的特性，然后描述与 BRE 的区别是什么。
</para>

   <note>
    <!--
<para>
     <productname>PostgreSQL</> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</>
     to the RE pattern, as described in <xref linkend="posix-metasyntax">.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
    </para>
-->
<para>
<productname>PostgreSQL</>总是初始化一个遵循ARE规则的正则表达式。然而，
更多限制的ERE或BRE规则可以通过在RE模式前放置一个<firstterm>embedded option</>来选择，
描述在<xref linkend="posix-metasyntax">。这对于期望完全兼容<acronym>POSIX</acronym> 
1003.2规则的应用程序是有用的。
</para>
   </note>

   <!--
<para>
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
   </para>
-->
<para>
一个正则表达式定义为一个或多个<firstterm>分支</firstterm>，
由<literal>|</literal>分隔。它匹配其中任何一个分支的东西。
</para>

   <!--
<para>
    A branch is zero or more <firstterm>quantified atoms</> or
    <firstterm>constraints</>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
   </para>
-->
<para>
一个分支是零个或多个<firstterm>有修饰的原子</>或<firstterm>约束</>连接而成。
一个原子匹配第一个，后面的原子匹配第二个，以此类推；一个空分支匹配空字符串。
</para>

   <!--
<para>
    A quantified atom is an <firstterm>atom</> possibly followed
    by a single <firstterm>quantifier</>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table">.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table">.
   </para>
-->
<para>
一个有修饰的原子是一个<firstterm>原子</>，后面可能跟着一个<firstterm>量词</>。
没有量词的时候，它匹配一个原子，有量词的时候，它可以匹配若干个原子。
<firstterm>原子</firstterm>可以是在<xref linkend="posix-atoms-table">里面显示的任何可能。
可能的量词和他们的含义在<xref linkend="posix-quantifiers-table">里显示。
</para>

   <!--
<para>
    A <firstterm>constraint</> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table">;
    some more constraints are described later.
   </para>
-->
<para>
一个<firstterm>约束</>匹配一个空字符串，但只是在满足特定条件下才匹配。
约束可以在能够使用原子的地方使用，只是它不能跟着量词。
最简单的原子在<xref linkend="posix-constraints-table">里显示；更多的约束稍后描述。
</para>


   <table id="posix-atoms-table">
    <!-- 
<title>Regular Expression Atoms</title>
-->
<title>正则表达式原子</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Atom</entry>
       <entry>Description</entry> 
   -->
   <entry>原子</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</><replaceable>re</><literal>)</> </entry>
       <!-- 
   <entry> (where <replaceable>re</> is any regular expression)
       matches a match for
       <replaceable>re</>, with the match noted for possible reporting </entry> 
   -->
   <entry> (<replaceable>re</> 是任意正则表达式)匹配一个对<replaceable>re</>
   的匹配，有可报告的匹配信息。</entry>
       </row>

       <row>
       <entry> <literal>(?:</><replaceable>re</><literal>)</> </entry>
       <!-- 
   <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</> set of parentheses)
       (AREs only) </entry> 
   -->
   <entry> 同上，但是匹配不会被报告(一个<quote>非捕获</>圆括弧)，只在 ARE 中有。</entry>
       </row>

       <row>
       <entry> <literal>.</> </entry>
       <!-- 
   <entry> matches any single character </entry> 
   -->
   <entry>匹配任意单个字符</entry>
       </row>

       <row>
       <entry> <literal>[</><replaceable>chars</><literal>]</> </entry>
       <!-- 
   <entry> a <firstterm>bracket expression</>,
       matching any one of the <replaceable>chars</> (see
       <xref linkend="posix-bracket-expressions"> for more detail) </entry> 
   -->
   <entry>一个<firstterm>方括弧表达式</>，匹配任意的<replaceable>字符</>
   (参阅<xref linkend="posix-bracket-expressions">获取更多细节)</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>k</> </entry>
       <!-- 
   <entry> (where <replaceable>k</> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</> matches a backslash character </entry> 
   -->
   <entry> (<replaceable>k</>是非字母数字字符)匹配一个当作普通字符看待的特定字符，
   比如<literal>\\</>匹配一个反斜杠。</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>c</> </entry>
       <!-- 
   <entry> where <replaceable>c</> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</>, see <xref linkend="posix-escape-sequences">
       (AREs only; in EREs and BREs, this matches <replaceable>c</>) </entry> 
   -->
   <entry><replaceable>c</>是一个字母数字(可能跟着其它字符)，它是一个<firstterm>转义</>，
   参阅<xref linkend="posix-escape-sequences">。仅存在于 ARE 中；在 ERE 和 BRE 中，
   它匹配<replaceable>c</>。</entry>
       </row>

       <row>
       <entry> <literal>{</> </entry>
       <!-- 
   <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</> (see below) </entry> 
   -->
   <entry>如果后面跟着一个非数字字符，那么就匹配左花括弧<literal>{</>；
   如果跟着一个数字，那么它是<replaceable>范围</>的开始(见下面)</entry>
       </row>

       <row>
       <entry> <replaceable>x</> </entry>
       <!-- 
   <entry> where <replaceable>x</> is a single character with no other
       significance, matches that character </entry> 
   -->
   <entry>这里的<replaceable>x</>是一个没有其它特征的单个字符，则匹配该字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    An RE cannot end with a backslash (<literal>\</>).
   </para>
-->
<para>
RE不能以(<literal>\</>)结尾。
</para>

   <note>
    <!--
<para>
     If you have <xref linkend="guc-standard-conforming-strings"> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"> for more information.
    </para>
-->
<para>
如果关闭了<xref linkend="guc-standard-conforming-strings">，
任何文本字符串常量中的反斜杠都需要双写。参阅<xref linkend="sql-syntax-strings">
获取更多信息。
</para>
   </note>

   <table id="posix-quantifiers-table">
    <!-- 
<title>Regular Expression Quantifiers</title> 
-->
<title>正则表达式量词</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Quantifier</entry>
       <entry>Matches</entry> 
   -->
   <entry>量词</entry>
       <entry>匹配</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</> </entry>
       <!-- 
   <entry> a sequence of 0 or more matches of the atom </entry> 
   -->
   <entry>一个匹配 0 或者更多个原子的序列</entry>
       </row>

       <row>
       <entry> <literal>+</> </entry>
       <!-- 
   <entry> a sequence of 1 or more matches of the atom </entry> 
   -->
   <entry>一个匹配 1 或者更多个原子的序列</entry>
       </row>

       <row>
       <entry> <literal>?</> </entry>
       <!-- 
   <entry> a sequence of 0 or 1 matches of the atom </entry> 
   -->
   <entry>一个匹配 0 或者 1个原子的序列</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}</> </entry>
       <!-- 
   <entry> a sequence of exactly <replaceable>m</> matches of the atom </entry>
   -->
   <entry>一个正好匹配<replaceable>m</>个原子的序列</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}</> </entry>
       <!-- 
   <entry> a sequence of <replaceable>m</> or more matches of the atom </entry>
   -->
   <entry>一个匹配<replaceable>m</>个或者更多原子的序列</entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
       <!-- 
   <entry> a sequence of <replaceable>m</> through <replaceable>n</>
       (inclusive) matches of the atom; <replaceable>m</> cannot exceed
       <replaceable>n</> </entry> 
   -->
   <entry>一个匹配<replaceable>m</>到<replaceable>n</>个(包含两端)原子的序列；
   <replaceable>m</>不能比<replaceable>n</>大</entry>
       </row>

       <row>
       <entry> <literal>*?</> </entry>
       <!-- 
   <entry> non-greedy version of <literal>*</> </entry>
   -->
       <entry><literal>*</>的非贪婪模式</entry>
   </row>

       <row>
       <entry> <literal>+?</> </entry>
       <!-- 
   <entry> non-greedy version of <literal>+</> </entry> 
   -->
   <entry><literal>+</>的非贪婪模式</entry>
       </row>

       <row>
       <entry> <literal>??</> </entry>
       <!-- 
   <entry> non-greedy version of <literal>?</> </entry> 
   -->
   <entry><literal>?</>的非贪婪模式</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}?</> </entry>
       <!--
   <entry> non-greedy version of <literal>{</><replaceable>m</><literal>}</> </entry>
   -->
   <entry><literal>{</><replaceable>m</><literal>}</>的非贪婪模式</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}?</> </entry>
       <!-- 
   <entry> non-greedy version of <literal>{</><replaceable>m</><literal>,}</> </entry>
   -->
   <entry><literal>{</><replaceable>m</><literal>,}</>的非贪婪模式</entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</> </entry>
       <!--
   <entry> non-greedy version of <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
   -->
   <entry><literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>的非贪婪模式</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    The forms using <literal>{</><replaceable>...</><literal>}</>
    are known as <firstterm>bounds</>.
    The numbers <replaceable>m</> and <replaceable>n</> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
   </para>
-->
<para>
<literal>{</><replaceable>...</><literal>}</>的形式被称作<firstterm>范围</>。
一个范围内的数字<replaceable>m</>和<replaceable>n</>都是无符号十进制整数，
允许的数值从 0 到 255 (闭区间)。
</para>

    <!--
<para>
     <firstterm>Non-greedy</> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"> for more detail.
   </para>
-->
<para>
<firstterm>非贪婪</>的量词(只在 ARE 中可用)匹配对应的正常(<firstterm>贪婪</>)模式，
区别是它寻找最少的匹配，而不是最多的匹配。参阅<xref linkend="posix-matching-rules">
获取细节。
</para>

   <note>
    <!--
<para>
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
    </para>
-->
<para>
一个量词不能紧跟在另外一个量词后面，例如，<literal>**</>是非法的。
量词不能是表达式或者子表达式的开头，也不能跟在<literal>^</literal>
或<literal>|</literal>后面。
</para>
   </note>

   <table id="posix-constraints-table">
    <!-- 
<title>Regular Expression Constraints</title> 
-->
<title>正则表达式约束</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Constraint</entry>
       <entry>Description</entry> 
   -->
   <entry>约束</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</> </entry>
       <!-- 
   <entry> matches at the beginning of the string </entry> 
   -->
   <entry>匹配字符串的开头</entry>
       </row>

       <row>
       <entry> <literal>$</> </entry>
       <!-- 
   <entry> matches at the end of the string </entry> 
   -->
   <entry>匹配字符串的结尾</entry>
       </row>

       <row>
       <entry> <literal>(?=</><replaceable>re</><literal>)</> </entry>
       <!-- 
   <entry> <firstterm>positive lookahead</> matches at any point
       where a substring matching <replaceable>re</> begins
       (AREs only) </entry> 
   -->
   <entry><firstterm>正前瞻</>匹配任何匹配<replaceable>re</>
   的子字符串起始点(只在 ARE 中有)</entry>
       </row>

       <row>
       <entry> <literal>(?!</><replaceable>re</><literal>)</> </entry>
       <!-- 
   <entry> <firstterm>negative lookahead</> matches at any point
       where no substring matching <replaceable>re</> begins
       (AREs only) </entry> 
   -->
   <entry><firstterm>负前瞻</>匹配任何不匹配<replaceable>re</>
   的子字符串起始点(只在 ARE 中有)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Lookahead constraints cannot contain <firstterm>back references</>
    (see <xref linkend="posix-escape-sequences">),
    and all parentheses within them are considered non-capturing.
   </para>
-->
<para>
前瞻约束不能包含<firstterm>后引用</>(参阅<xref linkend="posix-escape-sequences">)，
并且在其中的所有圆括弧都被认为是不捕获的。
</para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
    <!-- 
<title>Bracket Expressions</title> 
-->
<title>方括弧表达式</title>

   <!--
<para>
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
   </para>
-->
<para>
<firstterm>方括弧表达式</firstterm>是一个包围在<literal>[]</literal>里的字符列表。
它通常匹配任意单个列表中的字符(又见下文)。如果列表以<literal>^</literal>开头，
它匹配任意单个(又见下文)<emphasis>不在</>该列表中的字符。如果该列表中两个字符用
<literal>-</literal>隔开，那它就是那两个字符(包括在内)之间的所有字符范围的缩写，
比如，在<acronym>ASCII</acronym>里<literal>[0-9]</literal>包含任何十进制数字。
两个范围共享一个终点是非法的，比如<literal>a-c-e</literal>。这个范围与字符集关系密切，
可移植的程序不应该依靠它们。
</para>

   <!--
<para>
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
   </para>
-->
<para>
想在列表中包含文本<literal>]</literal>，可以让它做列表的首字符(如果用到了，
跟在<literal>^</literal> 后面)。想在列表中包含文本<literal>-</literal>，
可以让它做列表的首字符或者末字符，或者一个范围的第二个终点。
想在列表中把文本<literal>-</literal>当做范围的起点，把它用<literal>[.</literal>
和<literal>.]</literal>包围起来，这样它就成为一个集合元素(见下文)。
除了这些字符本身，和一些用<literal>[</literal>的组合(见下段)，
以及转义(只在 ARE 中有效)以外，所有其它特殊字符在方括弧表达式里都失去它们的特殊含义。
特别是，在 ERE 和 BRE 规则下<literal>\</literal>不是特殊的，但在 ARE 里，
它是特殊的(还是引入一个转义)。
</para>

   <!--
<para>
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
   </para>
-->
<para>
在一个方括弧表达式里，一个集合元素(一个字符、一个当做一个字符的多字符序列、
或者一个表示上面两种情况的集合序列)包含在<literal>[.</literal>和<literal>.]</literal>
里面的时候表示该集合元素的字符序列。该序列是该方括弧列表的一个元素。
这允许一个包含多字符集合元素的方括弧表达式就可以匹配多于一个字符，比如，
如果集合序列包含一个<literal>ch</literal>集合元素，那么<literal>[[.ch.]]*c</literal>
匹配<literal>chchcc</literal>的头五个字符。译注：其实把 [. 和 .] 括起来的整体当一个字符看就行了。
</para>

   <note>
    <!--
<para>
     <productname>PostgreSQL</> currently does not support multi-character collating
     elements. This information describes possible future behavior.
    </para>
-->
<para>
<productname>PostgreSQL</>目前不支持多字符集合元素。这些信息描述了将来可能有的行为。
</para>
   </note>

   <!--
<para>
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
   </para>
-->
<para>
在方括弧表达式里，在<literal>[=</literal>和<literal>=]</literal>
里包围的集合元素是一个<firstterm>等效表</>，代表等于这里所有集合元素的字符序列，
包括它本身(如果没有其它等效集合元素，那么就好像封装元素是<literal>[.</literal>
和<literal>.]</literal>)。比如，如果<literal>o</literal>和<literal>^</literal>
是一个等效表的成员，那么<literal>[[=o=]]</literal>,<literal>[[=^=]]</literal>,
<literal>[o^]</literal>都是同义的。一个等效表不能是一个范围的端点。
</para>

   <!--
<para>
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  Standard
    character class names are: <literal>alnum</literal>,
    <literal>alpha</literal>, <literal>blank</literal>,
    <literal>cntrl</literal>, <literal>digit</literal>,
    <literal>graph</literal>, <literal>lower</literal>,
    <literal>print</literal>, <literal>punct</literal>,
    <literal>space</literal>, <literal>upper</literal>,
    <literal>xdigit</literal>.  These stand for the character classes
    defined in
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
    A locale can provide others.  A character class cannot be used as
    an endpoint of a range.
   </para>
-->
<para>
在方括弧表达式里，在<literal>[:</literal>和<literal>:]</literal>
里面封装的字符表名字代表属于该表的所有字符的列表。标准的字符表名字是：
 <literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</literal>,
 <literal>cntrl</literal>, <literal>digit</literal>, <literal>graph</literal>,
 <literal>lower</literal>, <literal>print</literal>, <literal>punct</literal>,
 <literal>space</literal>, <literal>upper</literal>, <literal>xdigit</literal>。
 它们代表在<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>
 里定义的字符表。本地化设置可能会提供其它的表。字符表不能用做一个范围的端点。
</para>

   <!--
<para>
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</> character (as
    defined by
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
   </para>
-->
<para>
在方括弧表达式里有两个特例：方括弧表达式<literal>[[:&lt;:]]</literal>和
<literal>[[:&gt;:]]</literal>是约束，分别匹配一个单词开头和结束的空串。
单词定义为一个单词字符序列，前面和后面都没有其它单词字符。
单词字符是一个<literal>alnum</>字符(和<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>
里定义的一样)或者一个下划线。这是一个扩展，兼容<acronym>POSIX</acronym> 1003.2 ，
但那里面并没有说明，而且在准备移植到其它系统里去的软件里一定要小心使用。
通常下面描述的约束转义更好些；他们并非更标准，但是更容易输入。
</para>
   </sect3>

   <sect3 id="posix-escape-sequences">
    <!-- 
<title>Regular Expression Escapes</title> 
-->
<title>正则表达式转义</title>

   <!--
<para>
    <firstterm>Escapes</> are special sequences beginning with <literal>\</>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
   </para>
-->
<para>
<firstterm>转义</>是以<literal>\</>开头，后面跟着一个字母数字字符的特殊序列。
转义有好几种变体：字符项、表缩写、约束转义、后引用。在 ARE 里，如果一个<literal>\</>
后面跟着一个字母数字，但是并未组成一个合法的转义，那么它是非法的。在 ERE 里则没有转义：
在方括弧表达式之外，一个跟着字母数字字符的<literal>\</>只是表示该字符是一个普通的字符，
而在一个方括弧表达式里，<literal>\</>是一个普通的字符(后者实际上是 ERE 和 ARE 之间的不兼容)。
</para>

   <!--
<para>
    <firstterm>Character-entry escapes</> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table">.
   </para>
-->
<para>
<firstterm>字符项转义</>用于方便我们声明正则表达式里那些不可打印的字符。
它们在<xref linkend="posix-character-entry-escapes-table">里列出。
</para>

   <!--
<para>
    <firstterm>Class-shorthand escapes</> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table">.
   </para>
-->
<para>
<firstterm>类缩写转义</>用来提供一些常用的字符类缩写。
他们在<xref linkend="posix-class-shorthand-escapes-table">里列出。
</para>

   <!--
<para>
    A <firstterm>constraint escape</> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table">.
   </para>
-->
<para>
<firstterm>约束转义</>是一个约束，如果满足特定的条件，它匹配该空字符串，以转义形式写出。
它们在<xref linkend="posix-constraint-escapes-table">里列出。
</para>

   <!--
<para>
    A <firstterm>back reference</> (<literal>\</><replaceable>n</>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</>
    (see <xref linkend="posix-constraint-backref-table">).  For example,
    <literal>([bc])\1</> matches <literal>bb</> or <literal>cc</>
    but not <literal>bc</> or <literal>cb</>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
   </para>
-->
<para>
<firstterm>后引用</>(<literal>\</><replaceable>n</>)匹配数字<replaceable>n</>
指定的前面的圆括弧子表达式匹配的同一个字符串(参阅<xref linkend="posix-constraint-backref-table">)。
比如，<literal>([bc])\1</>匹配<literal>bb</>或<literal>cc</>但是不匹配<literal>bc</>或<literal>cb</>。
正则表达式里的子表达式必须完全在后引用前面。子表达式以它的括号的顺序排序。
非捕获圆括弧并不定义子表达式。
</para>

   <note>
    
<para>
<!--
     Keep in mind that an escape's leading <literal>\</> will need to be
     doubled when entering the pattern as an SQL string constant.  For example:
-->
请注意，如果把模式当作一个 SQL 字符串常量输入，那么转义前导的<literal>\</>需要双倍地写：
<programlisting>
'123' ~ E'^\\d{3}' <lineannotation>true</lineannotation>
</programlisting>
    </para>

   </note>

   <table id="posix-character-entry-escapes-table">
    <!-- 
<title>Regular Expression Character-entry Escapes</title> 
-->
<title>正则表达式字符项转义</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Escape</entry>
       <entry>Description</entry> 
   -->
   <entry>转义</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</> </entry>
       <!-- 
   <entry> alert (bell) character, as in C </entry> 
   -->
   <entry>警笛(铃声)字符，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\b</> </entry>
       <!-- 
   <entry> backspace, as in C </entry> 
   -->
   <entry>退格，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\B</> </entry>
       <!-- 
   <entry> synonym for backslash (<literal>\</>) to help reduce the need for backslash
       doubling </entry> 
   -->
   <entry><literal>\</>的同义词，用于减少反斜杠加倍的需要</entry>
       </row>

       <row>
       <entry> <literal>\c</><replaceable>X</> </entry>
       <!-- 
   <entry> (where <replaceable>X</> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</>, and whose other bits are all zero </entry> 
   -->
   <entry>(这里<replaceable>X</>是任意字符)字符的低 5 位和<replaceable>X</>
   里的相同，其它位都是 0</entry>
       </row>

       <row>
       <entry> <literal>\e</> </entry>
       <!-- 
   <entry> the character whose collating-sequence name
       is <literal>ESC</>,
       or failing that, the character with octal value 033 </entry> 
   -->
   <entry>集合序列名字是<literal>ESC</>的字符，如果不是，
   则是八进制值为 033 的字符</entry>
       </row>

       <row>
       <entry> <literal>\f</> </entry>
       <!-- 
   <entry> form feed, as in C </entry> 
   -->
   <entry>进纸，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\n</> </entry>
       <!-- 
   <entry> newline, as in C </entry> 
   -->
   <entry>新行，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\r</> </entry>
       <!-- 
   <entry> carriage return, as in C </entry> 
   -->
   <entry>回车，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\t</> </entry>
       <!-- 
   <entry> horizontal tab, as in C </entry> 
   -->
   <entry>水平制表符，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\u</><replaceable>wxyz</> </entry>
       <!-- 
   <entry> (where <replaceable>wxyz</> is exactly four hexadecimal digits)
       the UTF16 (Unicode, 16-bit) character <literal>U+</><replaceable>wxyz</>
       in the local byte ordering </entry> 
   -->
   <entry>(这里的<replaceable>wxyz</>是恰好四位十六进制位)本机字节序的 UTF-16 字符
   <literal>U+</><replaceable>wxyz</></entry>
       </row>

       <row>
       <entry> <literal>\U</><replaceable>stuvwxyz</> </entry>
       <!-- 
   <entry> (where <replaceable>stuvwxyz</> is exactly eight hexadecimal
       digits)
       reserved for a hypothetical Unicode extension to 32 bits
       </entry> 
   -->
   <entry>(这里的<replaceable>stuvwxyz</>是恰好八位十六进制位)
   为假想中的 Unicode 32 位扩展保留的</entry>
       </row>

       <row>
       <entry> <literal>\v</> </entry>
       <!-- 
   <entry> vertical tab, as in C </entry> 
   -->
   <entry>垂直制表符，和 C 里一样</entry>
       </row>

       <row>
       <entry> <literal>\x</><replaceable>hhh</> </entry>
       <!-- 
   <entry> (where <replaceable>hhh</> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</><replaceable>hhh</>
       (a single character no matter how many hexadecimal digits are used)
       </entry> 
   -->
   <entry>(这里的<replaceable>hhh</>是一个十六进制序列)十六进制值为
   <literal>0x</><replaceable>hhh</>的字符(不管用了几个十六进制位，
   都是一个字符)</entry>
       </row>

       <row>
       <entry> <literal>\0</> </entry>
       <!-- 
   <entry> the character whose value is <literal>0</> (the null byte)</entry> 
   -->
   <entry>值为<literal>0</>的字符 (null 字节)</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xy</> </entry>
       <!-- 
   <entry> (where <replaceable>xy</> is exactly two octal digits,
       and is not a <firstterm>back reference</>)
       the character whose octal value is
       <literal>0</><replaceable>xy</> </entry> 
   -->
   <entry>(这里的<replaceable>xy</>是恰好两个八进制位，
   并且不是一个<firstterm>后引用</>)八进制值为<literal>0</><replaceable>xy</>
   的字符 </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xyz</> </entry>
       <!-- 
   <entry> (where <replaceable>xyz</> is exactly three octal digits,
       and is not a <firstterm>back reference</>)
       the character whose octal value is
       <literal>0</><replaceable>xyz</> </entry> 
   -->
   <entry>(这里的<replaceable>xyz</>是恰好三位八进制位，
   并且不是一个<firstterm>后引用</>)八进制值为<literal>0</><replaceable>xyz</>
   的字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Hexadecimal digits are <literal>0</>-<literal>9</>,
    <literal>a</>-<literal>f</>, and <literal>A</>-<literal>F</>.
    Octal digits are <literal>0</>-<literal>7</>.
   </para>
-->
<para>
十六进制位是<literal>0</>-<literal>9</>, <literal>a</>-<literal>f</>,
 <literal>A</>-<literal>F</>。八进制位是<literal>0</>-<literal>7</>。
</para>

   <!--
<para>
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</> is <literal>]</> in ASCII, but
    <literal>\135</> does not terminate a bracket expression.
   </para>
-->
<para>
字符项转义总是被当作普通字符。比如，<literal>\135</>是 ASCII 中的<literal>]</>，
但<literal>\135</>并不终止一个方括弧表达式。
</para>

   <table id="posix-class-shorthand-escapes-table">
    <!-- 
<title>Regular Expression Class-shorthand Escapes</title> 
-->
<title>正则表达式类缩写转义</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Escape</entry>
       <entry>Description</entry> 
   -->
   <entry>转义</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</> </entry>
       <entry> <literal>[[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\s</> </entry>
       <entry> <literal>[[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\w</> </entry>
       <!-- 
   <entry> <literal>[[:alnum:]_]</>
       (note underscore is included) </entry> 
   -->
   <entry> <literal>[[:alnum:]_]</>
       (注意，这里是包含下划线的) </entry>
       </row>

       <row>
       <entry> <literal>\D</> </entry>
       <entry> <literal>[^[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\S</> </entry>
       <entry> <literal>[^[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\W</> </entry>
       <!-- 
   <entry> <literal>[^[:alnum:]_]</>
       (note underscore is included) </entry> 
   -->
   <entry> <literal>[^[:alnum:]_]</>
       (注意，这里是包含下划线的) </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Within bracket expressions, <literal>\d</>, <literal>\s</>,
    and <literal>\w</> lose their outer brackets,
    and <literal>\D</>, <literal>\S</>, and <literal>\W</> are illegal.
    (So, for example, <literal>[a-c\d]</> is equivalent to
    <literal>[a-c[:digit:]]</>.
    Also, <literal>[a-c\D]</>, which is equivalent to
    <literal>[a-c^[:digit:]]</>, is illegal.)
   </para>
-->
<para>
在方括弧表达式里，<literal>\d</>, <literal>\s</>, <literal>\w</>
会失去他们的外层方括弧，而 <literal>\D</>, <literal>\S</>, <literal>\W</> 
是非法的。比如<literal>[a-c\d]</>等效于<literal>[a-c[:digit:]]</>。
同样<literal>[a-c\D]</>原来等效于<literal>[a-c^[:digit:]]</>的，也是非法的。
</para>

   <table id="posix-constraint-escapes-table">
    <!-- 
<title>Regular Expression Constraint Escapes</title> 
-->
<title>正则表达式约束转义</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Escape</entry>
       <entry>Description</entry> 
   -->
   <entry>转义</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</> </entry>
       <!-- 
   <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"> for how this differs from
       <literal>^</>) </entry> 
   -->
   <entry>只匹配字符串开头(参阅<xref linkend="posix-matching-rules">
   获取它和<literal>^</>区别的信息)</entry>
       </row>

       <row>
       <entry> <literal>\m</> </entry>
       <!-- 
   <entry> matches only at the beginning of a word </entry> 
   -->
   <entry>只匹配一个词的开头</entry>
       </row>

       <row>
       <entry> <literal>\M</> </entry>
       <!-- 
   <entry> matches only at the end of a word </entry> 
   -->
   <entry>只匹配一个词的结尾</entry>
       </row>

       <row>
       <entry> <literal>\y</> </entry>
       <!-- 
   <entry> matches only at the beginning or end of a word </entry> 
   -->
   <entry>只匹配一个词的开头或者结尾</entry>
       </row>

       <row>
       <entry> <literal>\Y</> </entry>
       <!-- 
   <entry> matches only at a point that is not the beginning or end of a
       word </entry> 
   -->
   <entry>只匹配那些既不是词的开头也不是词的结尾的点</entry>
       </row>

       <row>
       <entry> <literal>\Z</> </entry>
       <!-- 
   <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"> for how this differs from
       <literal>$</>) </entry> 
   -->
   <entry>只匹配一个字符串的结尾(参阅<xref linkend="posix-matching-rules">
   获取它和<literal>$</>区别的信息)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</> and <literal>[[:&gt;:]]</> above.
    Constraint escapes are illegal within bracket expressions.
   </para>
-->
<para>
一个词的定义是上面<literal>[[:&lt;:]]</>和<literal>[[:&gt;:]]</>的声明。
在方括弧表达式里，约束转义是非法的。
</para>

   <table id="posix-constraint-backref-table">
    <!-- 
<title>Regular Expression Back References</title> 
-->
<title>正则表达式后引用</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Escape</entry>
       <entry>Description</entry> 
   -->
   <entry>转义</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</><replaceable>m</> </entry>
       <!-- 
   <entry> (where <replaceable>m</> is a nonzero digit)
       a back reference to the <replaceable>m</>'th subexpression </entry> 
   -->
   <entry>(这里的<replaceable>m</>是一个非零十进制位)
   一个指向第<replaceable>m</>个子表达式的后引用</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>mnn</> </entry>
      <!-- 
  <entry> (where <replaceable>m</> is a nonzero digit, and
      <replaceable>nn</> is some more digits, and the decimal value
       <replaceable>mnn</> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</>'th subexpression </entry> 
   -->
   <entry>(这里的<replaceable>m</>是一个非零十进制位，<replaceable>nn</>
   是更多的十进制位，并且十进制数值<replaceable>mnn</>
   不能大于到这个位置为止的闭合捕获圆括弧的个数)一个指向第<replaceable>mnn</>
   个子表达式的后引用</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <!--
<para>
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
    </para>
-->
<para>
在八进制字符项转义和后引用之间有一个继承的歧义存在，这个歧义是通过跟着的启发分析解决的，
像上面描述的那样。前导零总是表示这是一个八进制转义。而单个非零数字，
如果没有跟着任何其它数字，那么总是认为是后引用。
一个多数据位的非零开头的序列也认为是后引用(只要它在合适的子表达式后面，
也就是说，数值在后引用的合法范围内)，否则就认为是一个八进制。
</para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
    <!-- 
<title>Regular Expression Metasyntax</title> 
-->
<title>正则表达式元语法</title>

   <!--
<para>
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
   </para>
-->
<para>
除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。
</para>

   <!--
<para>
    An RE can begin with one of two special <firstterm>director</> prefixes.
    If an RE begins with <literal>***:</>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</> parameter to a regex function.)
    If an RE begins with <literal>***=</>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
   </para>
-->
<para>
正则表达式可以以两个特殊的<firstterm>指示器</>前缀之一开始：
如果一个正则表达式以<literal>***:</>开头，那么剩下的正则表达式都被当作 ARE 。
（这在<productname>PostgreSQL</>中通常没有影响，因为正则表达式被假设为ARE；
但是如果ERE或BRE模式被<replaceable>flags</>参数指定为正则表达式函数时是有影响的。）
如果一个的正则表达式以<literal>***=</>开头，那么剩下的正则表达式被当作一个文本串，
所有的字符都被认为是一个普通字符。
</para>

   <!--
<para>
    An ARE can begin with <firstterm>embedded options</>:
    a sequence <literal>(?</><replaceable>xyz</><literal>)</>
    (where <replaceable>xyz</> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table">.
    Note that these same option letters are used in the <replaceable>flags</>
    parameters of regex functions.
   </para>
-->
<para>
一个 ARE 可以以<firstterm>嵌入选项</>开头：一个<literal>(?</><replaceable>xyz</><literal>)</>
序列(这里的<replaceable>xyz</>是一个或多个字母字符)声明影响剩余正则表达式的选项。
这些选项覆盖任何前面判断的选项&mdash;它们可以重写正则表达式操作符隐含的大小写敏感性，
或者正则表达式函数的<replaceable>flags</>参数。可用的选项字母在
<xref linkend="posix-embedded-options-table">显示。请注意，
正则表达式函数的<replaceable>flags</>参数使用相同的选项字母。
</para>

   <table id="posix-embedded-options-table">
    <!-- 
<title>ARE Embedded-option Letters</title> 
-->
<title>ARE 嵌入选项字母</title>

    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Option</entry>
       <entry>Description</entry> 
   -->
   <entry>选项</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</> </entry>
       <!-- 
   <entry> rest of RE is a BRE </entry> 
   -->
   <entry>剩余的正则表达式是 BRE</entry>
       </row>

       <row>
       <entry> <literal>c</> </entry>
       <!-- 
   <entry> case-sensitive matching (overrides operator type) </entry> 
   -->
   <entry>大小写敏感匹配(覆盖操作符类型)</entry>
       </row>

       <row>
       <entry> <literal>e</> </entry>
       <!-- 
   <entry> rest of RE is an ERE </entry> 
   -->
   <entry>剩余的正则表达式是 ERE</entry>
       </row>

       <row>
       <entry> <literal>i</> </entry>
       <!-- 
   <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules">) (overrides operator type) </entry> 
   -->
   <entry>大小写不敏感匹配(参阅<xref linkend="posix-matching-rules">)(覆盖操作符类型)</entry>
       </row>

       <row>
       <entry> <literal>m</> </entry>
       <!-- 
   <entry> historical synonym for <literal>n</> </entry> 
   -->
   <entry><literal>n</>的历史同义词</entry>
       </row>

       <row>
       <entry> <literal>n</> </entry>
       <!-- 
   <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules">) </entry> 
   -->
   <entry>新行敏感匹配(参阅<xref linkend="posix-matching-rules">) </entry>
       </row>

       <row>
       <entry> <literal>p</> </entry>
       <!-- 
   <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules">) </entry> 
   -->
   <entry>部分新行敏感匹配(参阅<xref linkend="posix-matching-rules">)</entry>
       </row>

       <row>
       <entry> <literal>q</> </entry>
       <!-- 
   <entry> rest of RE is a literal (<quote>quoted</>) string, all ordinary
       characters </entry> 
   -->
   <entry>重置正则表达式为一个文本(<quote>引起</>)字符串，所有都是普通字符。</entry>
       </row>

       <row>
       <entry> <literal>s</> </entry>
       <!-- 
   <entry> non-newline-sensitive matching (default) </entry> 
   -->
   <entry>非新行敏感匹配(缺省)</entry>
       </row>

       <row>
       <entry> <literal>t</> </entry>
       <!-- 
   <entry> tight syntax (default; see below) </entry> 
   -->
   <entry>紧语法(缺省，见下文) </entry>
       </row>

       <row>
       <entry> <literal>w</> </entry>
       <!-- 
   <entry> inverse partial newline-sensitive (<quote>weird</>) matching
       (see <xref linkend="posix-matching-rules">) </entry> 
   -->
   <entry>反转部分新行敏感(<quote>怪异</>)匹配(参阅<xref linkend="posix-matching-rules">)</entry>
       </row>

       <row>
       <entry> <literal>x</> </entry>
       <!-- 
   <entry> expanded syntax (see below) </entry> 
   -->
   <entry>扩展的语法(见下文)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Embedded options take effect at the <literal>)</> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</> director if any).
   </para>
-->
<para>
嵌入的选项在终止其序列的<literal>)</>发生作用。他们只在 ARE 的开始处起作用(如果有，
则在任何<literal>***:</>指示器后面)。
</para>
   
<para>
    <!-- 
In addition to the usual (<firstterm>tight</>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</> syntax,
    available by specifying the embedded <literal>x</> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule: 
-->
除了通常的(<firstterm>紧</>)正则表达式语法(这种情况下所有字符都重要)，
还有一种<firstterm>扩展</>语法，可以通过声明嵌入的<literal>x</>选项获得。
在扩展语法里，正则表达式中的空白字符被忽略，就像那些在<literal>#</>
和新行之间的字符一样（或正则表达式的结尾）。
这样就允许我们给一个复杂的正则表达式分段和注释。不过这个基本规则上有三种例外：
    <itemizedlist>
     <listitem>
 <!--
      <para>
       a white-space character or <literal>#</> preceded by <literal>\</> is
       retained
      </para>
-->
<para>
前置了<literal>\</>的空白字符或者 <literal>#</>保留
</para>
     </listitem>
     <listitem>
      <!--
<para>
       white space or <literal>#</> within a bracket expression is retained
      </para>
-->
<para>
方括弧里的空白或者<literal>#</>保留
</para>
     </listitem>
     <listitem>
      <!--
<para>
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</>
      </para>
-->
<para>
在多字符符号里面不能出现空白和注释，比如<literal>(?:</>
</para>
     </listitem>
    </itemizedlist>
<!-- 
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</> character class.
-->
在这里，空白是空格、水平制表符、新行、和任何属于<replaceable>space</>(空白)字符表的字符。
   </para>

   <!--
<para>
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</><replaceable>ttt</><literal>)</>
    (where <replaceable>ttt</> is any text not containing a <literal>)</>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
   </para>
-->
<para>
最后，在 ARE 里，方括弧表达式外面，序列<literal>(?#</><replaceable>ttt</><literal>)</>
(这里的<replaceable>ttt</>是任意不包含<literal>)</>的文本)是一个注释，完全被忽略。
同样，这样的东西是不允许出现在多字符符号的字符中间的，比如<literal>(?:</>。
这样的注释是比有用的机制的更久远的历史造成的，他们的用法已经废弃了；
我们应该使用扩展语法代替他。
</para>

   <!--
<para>
    <emphasis>None</> of these metasyntax extensions is available if
    an initial <literal>***=</> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
   </para>
-->
<para>
如果声明了一个初始化的<literal>***=</>指示器，那么所有这些元语法扩展都
<emphasis>不能</>使用，因为这样表示把用户输入当作一个文本字符串而不是正则表达式对待。
</para>
   </sect3>

   <sect3 id="posix-matching-rules">
    <!-- 
<title>Regular Expression Matching Rules</title> 
-->
<title>正则表达式匹配规则</title>

   <!--
<para>
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</> or
    <firstterm>non-greedy</>.
   </para>
-->
<para>
在正则表达式可以匹配给出的字符串中多于一个子字符串的情况下，
正则表达式匹配字符串中最靠前的那个子字符串。
如果正则表达式可以匹配在那个位置开始的多个子字符串，要么是取最长的子字符串，
要么是最短的，具体哪种，取决于正则表达式是<firstterm>贪婪</>的还是
<firstterm>非贪婪</>的。
</para>

  
<para>
    <!-- 
Whether an RE is greedy or not is determined by the following rules: 
-->
一个正则表达式是否贪婪取决于下面规则：
    <itemizedlist>
     <listitem>
 <!--
      <para>
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
      </para>
-->
<para>
大多数原子，以及所有约束，都没有贪婪属性(因为它们毕竟无法匹配个数变化的文本)。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       Adding parentheses around an RE does not change its greediness.
      </para>
-->
<para>
在一个正则表达式周围加上圆括弧并不会改变其贪婪性。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</><replaceable>m</><literal>}</>
       or
       <literal>{</><replaceable>m</><literal>}?</>)
       has the same greediness (possibly none) as the atom itself.
      </para>
-->
<para>
一个带一个固定重复次数的量词(<literal>{</><replaceable>m</><literal>}</>
或<literal>{</><replaceable>m</><literal>}?</>)
量化的原子和原子自身有着同样的贪婪性(可能是没有)。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       A quantified atom with other normal quantifiers (including
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
       with <replaceable>m</> equal to <replaceable>n</>)
       is greedy (prefers longest match).
      </para>
-->
<para>
一个带其它普通的量词(包括<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
中<replaceable>m</>等于<replaceable>n</>的情况)量化的原子是贪婪的(首选最长匹配)。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       A quantified atom with a non-greedy quantifier (including
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>
       with <replaceable>m</> equal to <replaceable>n</>)
       is non-greedy (prefers shortest match).
      </para>
-->
<para>
一个带非贪婪量词(包括<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>
中<replaceable>m</>等于<replaceable>n</>的情况)量化原子是非贪婪的(首选最短匹配)。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
      </para>
-->
<para>
一个分支(也就是一个没有顶级<literal>|</>操作的正则表达式)
和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       An RE consisting of two or more branches connected by the
       <literal>|</> operator is always greedy.
      </para>
-->
<para>
一个由<literal>|</>操作符连接起来的两个或者更多分支组成的正则表达式总是贪婪的。
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
   </para>
-->
<para>
上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子，
而且也适用于包含量化原子的分支和整个正则表达式。这里的意思是，
匹配是按照分支或者整个正则表达式<emphasis>作为一个整体</>
匹配最长或者最短的子字符串的可能。一旦整个匹配的长度确定，
那么匹配任意子表达式的部分就基于该子表达式的贪婪属性进行判断，
在正则表达式里面靠前的子表达式的优先级高于靠后的子表达式。
</para>
   
<para>
<!--
    An example of what this means:
-->
一个表达这些的例子：
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!-- 
    In the first case, the RE as a whole is greedy because <literal>Y*</>
    is greedy.  It can match beginning at the <literal>Y</>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</>.
    The output is the parenthesized part of that, or <literal>123</>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</>
    is non-greedy.  It can match beginning at the <literal>Y</>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</>.
    The subexpression <literal>[0-9]{1,3}</> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</>. 
-->
在第一个例子里，正则表达式作为整体是贪婪的，因为<literal>Y*</>是贪婪的。
它可以匹配从<literal>Y</>开始的东西，并且它匹配从这个位置开始的最长的字符串，
也就是<literal>Y123</>。输出是这里的圆括弧包围的部分，或者说是<literal>123</>。
在第二个例子里，正则表达式总体上是一个非贪婪的正则表达式 ，因为<literal>Y*?</>
是非贪婪的。它可以匹配从<literal>Y</>开始的最短的子字符串，也就是说<literal>Y1</>。
子表达式<literal>[0-9]{1,3}</>是贪婪的，但是它不能修改总体匹配长度的决定；
因此它被迫只匹配<literal>1</>。
   </para>
   <!--
<para>
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</> relative to each other.
   </para>
-->
<para>
简单说，如果一个正则表达式同时包含贪婪和非贪婪的子表达式，
那么总匹配长度要么是最长可能，要么是最短可能，取决于给整个正则表达式赋予的贪婪属性。
给子表达式赋予的贪婪属性只影响在这个匹配里，各个子表达式之间相互允许 <quote>吃进</>的多少。
</para>

   <!--
<para>
    The quantifiers <literal>{1,1}</> and <literal>{1,1}?</>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
   </para>
-->
<para>
量词<literal>{1,1}</>和<literal>{1,1}?</>
可以分别用于在一个子表达式或者整个正则表达式上强制贪婪或者非贪婪。
</para>

   <!--
<para>
    Match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</>
    matches the three middle characters of <literal>abbbc</>;
    <literal>(week|wee)(night|knights)</>
    matches all ten characters of <literal>weeknights</>;
    when <literal>(.*).*</>
    is matched against <literal>abc</> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</> is matched against <literal>bc</>
    both the whole RE and the parenthesized
    subexpression match an empty string.
   </para>
-->
<para>
匹配长度是以字符衡量的，而不是集合的元素。一个空字符串会被认为比什么都不匹配长。
比如：<literal>bb*</>匹配<literal>abbbc</>的中间三个字符；
<literal>(week|wee)(night|knights)</>匹配<literal>weeknights</>的所有十个字符；
而<literal>(.*).*</>匹配<literal>abc</>的时候，圆括弧包围的子表达式匹配所有三个字符；
而如果用<literal>(a*)*</>匹配<literal>bc</>，那么正则表达式和圆括弧子表达式都匹配空字符串。
</para>

   <!--
<para>
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</> becomes <literal>[xX]</>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</> becomes <literal>[xX]</>
    and <literal>[^x]</> becomes <literal>[^xX]</>.
   </para>
-->
<para>
如果声明了大小写无关的匹配，那么效果就好像把所有字母上的大小写区别取消了一样。
如果一个存在大小写差别的字母以一个普通字符的形式出现在方括弧表达式外面，
那么它实际上被转换成一个包含大小写的方括弧表达式，也就是说，<literal>x</>
变成<literal>[xX]</>。如果它出现在一个方括弧表达式里面，
那么它的所有大小写的同族都被加入方括弧表达式中，也就是说，<literal>[x]</>
变成<literal>[xX]</>而<literal>[^x]</>变成 <literal>[^xX]</>。
</para>

   <!--
<para>
    If newline-sensitive matching is specified, <literal>.</>
    and bracket expressions using <literal>^</>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</> and <literal>$</>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</> and <literal>\Z</>
    continue to match beginning or end of string <emphasis>only</>.
   </para>
-->
<para>
如果声明了新行敏感匹配，<literal>.</>和使用<literal>^</>
的方括弧表达式将永远不会匹配新行字符(这样，匹配就绝对不会跨新行，
除非正则表达式明确地安排了这样的情况)并且<literal>^</>和<literal>$</>
除了分别匹配字符串开头和结尾之外，还将分别匹配新行后面和前面的空字符串。
但是 ARE 转义<literal>\A</>和<literal>\Z</>
仍然<emphasis>只</>匹配字符串的开头和结尾。
</para>

   <!--
<para>
    If partial newline-sensitive matching is specified,
    this affects <literal>.</> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</>
    and <literal>$</>.
   </para>
-->
<para>
如果声明了部分新行敏感匹配，那么它影响<literal>.</>和方括弧表达式，
这个时候和新行敏感匹配一样，但是不影响<literal>^</>和<literal>$</>。
</para>

   <!--
<para>
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</> and <literal>$</>
    as with newline-sensitive matching, but not <literal>.</>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
   </para>
-->
<para>
如果声明了反转部分新行敏感匹配，那么它影响<literal>^</>和<literal>$</>，
作用和新行敏感匹配里一样，但是不影响<literal>.</>和方括弧表达式。
这个没什么太多用途，只是为了对称提供的。
</para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
    <!-- 
<title>Limits and Compatibility</title> 
-->
<title>限制和兼容性</title>

   <!--
<para>
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
   </para>
-->
<para>
在这个实现里，对正则表达式的长度没有特别的限制，但是，
那些希望能够有很好移植行的程序应该避免写超过 256 字节的正则表达式 ，
因为 POSIX 兼容的实现可以拒绝接受这样的正则表达式。
</para>

   <!--
<para>
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
   </para>
-->
<para>
ARE 实际上和 POSIX ERE 不兼容的唯一的特性是在方括弧表达式里<literal>\</>
并不失去它特殊的含义。所有其它 ARE 特性都使用在 POSIX ERE 里面是非法或者是未定义、
未声明效果的语法；指示器的<literal>***</>就是在 POSIX 的 BRE 和 ERE 之外的语法。
</para>

   <!--
<para>
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</>, <literal>\B</>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
   </para>
-->
<para>
许多 ARE 扩展都是从 Perl 那里借来的，但是有些我做了修改，清理了一下，
以及一些 Perl 里没有出现的扩展。要注意的不兼容包括<literal>\b</>, <literal>\B</>，
对结尾的新行缺乏特别的处理，对那些新行敏感匹配的附加的补齐方括弧表达式，
在前瞻约束里对圆括弧和方括弧引用的限制，以及最长/最短匹配(而不是第一匹配)语义。
</para>
   
<para>
<!-- 
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</>:
 -->
<productname>PostgreSQL</> 7.4 之前的版本里的 ARE 和 ERE 存在两个非常显著的不兼容： 
    <itemizedlist>
     <listitem>
 <!--
      <para>
       In AREs, <literal>\</> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
      </para>
-->
<para>
在 ARE 里，后面跟着一个字母数字的<literal>\</>要么是一个转义，要么是错误，
但是在以前的版本里，它只是写那个字母数字的另外一种方法。这个应该不是什么问题，
因为在以前的版本里没有什么原因让我们写这样的序列。
</para>
     </listitem>
     <listitem>
      <!--
<para>
       In AREs, <literal>\</> remains a special character within
       <literal>[]</>, so a literal <literal>\</> within a bracket
       expression must be written <literal>\\</>.
      </para>
-->
<para>
在 ARE 里，<literal>\</>在<literal>[]</>里还是一个特殊字符，
因此在方括弧表达式里的一个文本<literal>\</>必须写成<literal>\\</>。
</para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
    <!-- 
<title>Basic Regular Expressions</title> 
-->
<title>基本正则表达式</title>

   <!--
<para>
    BREs differ from EREs in several respects.
    In BREs, <literal>|</>, <literal>+</>, and <literal>?</>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</> and <literal>\}</>,
    with <literal>{</> and <literal>}</>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</> and <literal>\)</>,
    with <literal>(</> and <literal>)</> by themselves ordinary characters.
    <literal>^</> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</> and <literal>\&gt;</>
    are synonyms for
    <literal>[[:&lt;:]]</> and <literal>[[:&gt;:]]</>
    respectively; no other escapes are available in BREs.
   </para>
-->
<para>
BRE 在几个方面和 ERE 不太一样。在BRE里，<literal>|</>, <literal>+</>,<literal>?</>
都是普通字符，它们没有等效的功能替换。范围的分隔符是<literal>\{</>和<literal>\}</>，
因为<literal>{</>和<literal>}</>本身是普通字符。嵌套的子表达式的圆括弧是<literal>\(</>
和<literal>\)</>，因为<literal>(</>和<literal>)</>自身是普通字符。
除非在正则表达式开头或者是圆括弧封装的子表达式开头，<literal>^</>都是普通字符，
除非在正则表达式结尾或者是圆括弧封装的子表达式的结尾，<literal>$</>是一个普通字符，
而如果<literal>*</>出现在正则表达式开头或者是圆括弧封装的子表达式开头
(前面可能有<literal>^</>)，那么它是个普通字符。最后，可以用单数字的后引用，
以及<literal>\&lt;</>和<literal>\&gt;</>分别是<literal>[[:&lt;:]]</>和<literal>[[:&gt;:]]</>
的同义词；在BRE里没有其它的转义。
</para>
   </sect3>

<!-- end re_syntax.n man page -->

  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
   <!-- 
   <title>Data Type Formatting Functions</title> 
   -->
   <title>数据类型格式化函数</title>

   <indexterm>
    <!-- 
<primary>formatting</primary> 
-->
<primary>格式化</primary>
   </indexterm>

   <!--
<para>
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
   </para>
-->
<para>
<productname>PostgreSQL</productname>格式化函数提供一套有效的工具用于把各
种数据类型转换成格式化的字符串以及反过来从格式化的字符串转换成指定的数据类型。
<xref linkend="functions-formatting-table">列出了这些函数。
这些函数都遵循一个公共的调用习惯：第一个参数是待格式化的值，
而第二个是定义输出或输入格式的模板。
</para>
   <!--
<para>
    A single-argument <function>to_timestamp</function> function is also
    available;  it accepts a
    <type>double precision</type> argument and converts from Unix epoch
    (seconds since 1970-01-01 00:00:00+00) to
    <type>timestamp with time zone</type>.
    (<type>Integer</type> Unix epochs are implicitly cast to
    <type>double precision</type>.)
   </para>
-->
<para>
单参数<function>to_timestamp</function>函数也可以使用；它接受一个<type>double precision</type>
参数，并且从Unix纪元（秒自1970-01-01 00:00:00+00）转换为<type>timestamp with time zone</type>
类型。（<type>Integer</type>类型的Unix纪元隐含的转换为<type>double precision</type>类型。）
</para>

    <table id="functions-formatting-table">
     <!-- 
 <title>Formatting Functions</title> 
 -->
 <title>格式化函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>convert time stamp to string</entry> 
-->
<entry>把时间戳转换成字符串</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>convert interval to string</entry> 
-->
<entry>把时间间隔转为字符串</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>convert integer to string</entry> 
-->
<entry>把整数转换成字符串</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>convert real/double precision to string</entry> 
-->
<entry>把实数/双精度数转换成字符串</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>convert numeric to string</entry> 
-->
<entry>把数字转换成字符串</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <!-- 
<entry>convert string to date</entry> 
-->
<entry>把字符串转换成日期</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
        <!-- 
<entry>convert string to numeric</entry> 
-->
<entry>把字符串转换成数字</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>convert string to time stamp</entry> 
-->
<entry>把字符串转换成时间戳</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_timestamp(<type>double precision</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>convert Unix epoch to time stamp</entry> 
-->
<entry>把 Unix 纪元转换成时间戳</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    In a <function>to_char</> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.
   </para>
-->
<para>
在<function>to_char</>输出模板字符串里，该函数族可以识别一些特定的模式，
并且把给定的数值正确地格式化成相应的数据。任何不属于模板模式的文本都简单地逐字拷贝。
同样，在一个输入模板字符串里(对其他函数)，模板模式标识数值由输入数据字符串提供。
</para>

  <!--
<para>
   <xref linkend="functions-formatting-datetime-table"> shows the
   template patterns available for formatting date and time values.
  </para>
-->
<para>
<xref linkend="functions-formatting-datetime-table">显示了可以用于格式化日期和时间值的模版。
</para>

    <table id="functions-formatting-datetime-table">
     <!-- 
 <title>Template Patterns for Date/Time Formatting</title> 
 -->
 <title>用于日期/时间格式化的模式</title>
     <tgroup cols="2">
      <thead>
       <row>
        <!-- 
<entry>Pattern</entry>
        <entry>Description</entry> 
-->
<entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
        <!-- 
<entry>hour of day (01-12)</entry> 
-->
<entry>一天的小时数(01-12)</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
        <!-- 
<entry>hour of day (01-12)</entry> 
-->
<entry>一天的小时数(01-12)</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
        <!-- 
<entry>hour of day (00-23)</entry> 
-->
<entry>一天的小时数(00-23)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <!-- 
<entry>minute (00-59)</entry> 
-->
<entry>分钟(00-59)</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
        <!-- 
<entry>second (00-59)</entry> 
-->
<entry>秒(00-59)</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
        <!-- 
<entry>millisecond (000-999)</entry> 
-->
<entry>毫秒(000-999)</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
        <!-- 
<entry>microsecond (000000-999999)</entry> 
-->
<entry>微秒(000000-999999)</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
        <!-- 
<entry>seconds past midnight (0-86399)</entry>
-->
<entry>午夜后的秒(0-86399)</entry>
       </row>
       <row>
        <!-- 
<entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>meridiem indicator (without periods)</entry> 
-->
<entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> 或 <literal>pm</literal></entry>
        <entry>正午指示器(没有周期)</entry>
       </row>
       <row>
        <!-- 
<entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>meridiem indicator (with periods)</entry> 
-->
<entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> 或 <literal>p.m.</literal></entry>
        <entry>正午指示器(有周期)</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <!-- 
<entry>year (4 or more digits) with comma</entry> 
-->
<entry>带逗号的年(4 或更多位)</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
        <!-- 
<entry>year (4 or more digits)</entry> 
-->
<entry>年(4 或更多位)</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
        <!-- 
<entry>last 3 digits of year</entry>
-->
<entry>年的后三位</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
        <!-- 
<entry>last 2 digits of year</entry> 
-->
<entry>年的后两位</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
        <!-- 
<entry>last digit of year</entry> 
-->
<entry>年的最后一位</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
        <!-- 
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
-->
<entry>ISO 8601周编号的年(4 位或更多位)</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
        <!-- 
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
-->
<entry>ISO 8601周编号年的最后三位</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
        <!-- 
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
-->
<entry>ISO 8601周编号年的最后两位</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
        <!-- 
        <entry>last digit of ISO 8601 week-numbering year</entry>
-->
<entry>ISO 8601周编号年的最后一位</entry>
       </row>
       <row>
        <!-- 
<entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
        <entry>era indicator (without periods)</entry> 
-->
<entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> 或 <literal>ad</literal></entry>
        <entry>纪元标识(没有周期)</entry>
       </row>
       <row>
        <!-- 
<entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
        <entry>era indicator (with periods)</entry> 
-->
<entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> 或 <literal>a.d.</literal></entry>
        <entry>纪元标识(有周期)</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
        <!-- 
<entry>full upper case month name (blank-padded to 9 chars)</entry> 
-->
<entry>全长大写月份名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
        <!-- 
<entry>full capitalized month name (blank-padded to 9 chars)</entry> 
-->
<entry>全长首字母大写月份名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
        <!-- 
<entry>full lower case month name (blank-padded to 9 chars)</entry> 
-->
<entry>全长小写月份名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
        <!-- 
<entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry> 
-->
<entry>大写缩写月份名(英文3 字符，本地化的长度不同)</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
        <!-- 
<entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
<entry>首字母大写缩写月份名(英文3 字符，本地化的长度不同)</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
        <!-- 
<entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry> 
-->
<entry>小写缩写月份名(英文3 字符，本地化的长度不同)</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
        <!-- 
<entry>month number (01-12)</entry> 
-->
<entry>月份数(01-12)</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
        <!-- 
<entry>full upper case day name (blank-padded to 9 chars)</entry> 
-->
<entry>全长大写日期名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
        <!-- 
<entry>full capitalized day name (blank-padded to 9 chars)</entry> 
-->
<entry>全长首字母大写日期名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
        <!-- 
<entry>full lower case day name (blank-padded to 9 chars)</entry> 
-->
<entry>全长小写日期名(空白填充为 9 字符)</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
        <!-- 
<entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry> 
-->
<entry>缩写大写日期名(英文3 字符，本地化长度不同)</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
        <!-- 
<entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry> 
-->
<entry>缩写首字母大写日期名(英文3 字符，本地化长度不同)</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
        <!-- 
<entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry> 
-->
<entry>缩写小写日期名(英文3 字符，本地化长度不同)</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
        <!-- 
<entry>day of year (001-366)</entry> 
-->
<entry>一年里的日(001-366)</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
        <!-- 
<entry>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</entry>
-->
<entry>ISO 8601周编号年的日（001-371；年的第一天是第一个ISO周的星期一）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
        <!-- 
<entry>day of month (01-31)</entry> 
-->
<entry>一个月里的日(01-31)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <!-- 
<entry>day of the week, Sunday(<literal>1</>) to Saturday(<literal>7</>)</entry> 
-->
<entry>一周里的日，星期日（<literal>1</>）到星期六（<literal>7</>）</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
        <!-- 
<entry>ISO 8601 day of the week, Monday(<literal>1</>) to Sunday(<literal>7</>)</entry> 
-->
<entry>ISO 8601一周里的日，星期一（<literal>1</>）到星期日（<literal>7</>）</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
        <!-- 
<entry>week of month (1-5) (the first week starts on the first day of the month)</entry> 
-->
<entry>一个月里的周数(1-5)(第一周从该月第一天开始)</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
        <!-- 
<entry>week number of year (1-53) (the first week starts on the first day of the year)</entry>
-->
<entry>一年里的周数(1-53)(第一周从该年的第一天开始)</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
        <!-- 
<entry>week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)</entry>
-->
<entry>ISO 8601周编号年里的周数(01-53；第一个星期四在第一周里)</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
        <!-- 
<entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
-->
<entry>世纪(2 位)(20 世纪从 2001-01-01 开始)</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
        <!-- 
<entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry> 
-->
<entry>儒略日(自公元前 4714 年 11 月 24日午夜来的天数)</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
        <!-- 
<entry>quarter (ignored by <function>to_date</> and <function>to_timestamp</>)</entry> 
-->
<entry>季度（<function>to_date</>和<function>to_timestamp</>忽略此项）</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
        <!-- 
<entry>month in upper case Roman numerals (I-XII; I=January)</entry> 
-->
<entry>罗马数字的月份(I-XII ；I=January)(大写)</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
        <!-- 
<entry>month in lower case Roman numerals (i-xii; i=January)</entry> 
-->
<entry>罗马数字的月份(i-xii ；i=January)(小写)</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
        <!-- 
<entry>upper case time-zone name</entry> 
-->
<entry>时区名(大写)</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
        <!-- 
<entry>lower case time-zone name</entry> 
-->
<entry>时区名(小写)</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
        <!-- 
        <entry>time-zone offset</entry>
        -->
        <entry>时区偏移</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"> shows the
    modifier patterns for date/time formatting.
   </para>
-->
<para>
有一些修饰词可以应用于模板来修改它们的行为。比如，<literal>FMMonth</literal>
就是带着<literal>FM</literal>前缀的<literal>Month</literal>模式。
<xref linkend="functions-formatting-datetimemod-table">
显示了用于日期/时间格式化的修饰词模式。
</para>

    <table id="functions-formatting-datetimemod-table">
     <!-- 
 <title>Template Pattern Modifiers for Date/Time Formatting</title> 
 -->
 <title>日期/时间格式化的模板模式修饰词</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>修饰词</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <!-- 
<entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress padding blanks and trailing zeroes)</entry> 
-->
<entry><literal>FM</literal> 前缀</entry>
        <entry>填充模式(抑制填充空白和尾随零)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
        <!-- 
<entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry> 
<entry><literal>DDTH</literal>, e.g., <literal>12TH</></entry>
-->
<entry><literal>TH</literal> 后缀</entry>
        <entry>大写顺序数后缀</entry>
        <entry><literal>DDTH</literal>, 例如, <literal>12TH</></entry>
       </row>
       <row>
        <!-- 
<entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry> 
<entry><literal>DDth</literal>, e.g., <literal>12th</></entry>
-->
<entry><literal>th</literal> 后缀</entry>
        <entry>小写顺序数后缀</entry>
        <entry><literal>DDth</literal>, 例如, <literal>12th</></entry>
       </row>
       <row>
        <!-- 
<entry><literal>FX</literal> prefix</entry>
        <entry>fixed format global option (see usage notes)</entry> 
-->
<entry><literal>FX</literal> 前缀</entry>
        <entry>固定格式全局选项(见用法须知)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
        <!-- 
<entry><literal>TM</literal> prefix</entry>
        <entry>translation mode (print localized day and month names based on
         <xref linkend="guc-lc-time">)</entry> 
 -->
 <entry><literal>TM</literal> 前缀</entry>
        <entry>翻译模式(基于<xref linkend="guc-lc-time">显示本地化的日期和月份名)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
        <!-- 
<entry><literal>SP</literal> suffix</entry>
        <entry>spell mode (not implemented)</entry> 
-->
<entry><literal>SP</literal> 后缀</entry>
        <entry>拼写模式(未实现)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  
<para>
 <!--
    Usage notes for date/time formatting:
-->
日期/时间格式化的用法须知：
    <itemizedlist>
     <listitem>
<!--
      <para>
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
      </para>
-->
<para>
<literal>FM</literal>抑制前导的零或尾随的空白。如果没有使用它的话，
会在输出中增加这些填充最终把输出变成固定宽度的模式。
在<productname>PostgreSQL</productname>中，<literal>FM</literal>只修改下一个规范；
而在Oracle中<literal>FM</literal>影响所有随后的规范，
并且重复的<literal>FM</literal>修饰符切换填充模式的打开和关闭。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>TM</literal> does not include trailing blanks.
      </para>
-->
<para>
<literal>TM</literal>不包含结尾空白。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces in the input string unless the
       <literal>FX</literal> option is used. For example,
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> works, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects one space only.
       <literal>FX</literal> must be specified as the first item in
       the template.
      </para>
-->
<para>
如果没有使用<literal>FX</literal>，<function>to_timestamp</function>和<function>to_date</function>
在转换字符串的时候忽略多个空白。比如<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>
是正确的，但是<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal>
会返回一个错误，因为<function>to_timestamp</function>只预料会有一个空白。
<literal>FX</literal>必须做为模板里的第一个项声明。
</para>
     </listitem>

     <listitem>
<!-- 
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       exist to handle input formats that cannot be converted by
       simple casting.  These functions interpret input liberally,
       with minimal error checking.  While they produce valid output,
       the conversion can yield unexpected results.  For example,
       input to these functions is not restricted by normal ranges,
       thus <literal>to_date('20096040','YYYYMMDD')</literal> returns
       <literal>2014-01-17</literal> rather than causing an error.
       Casting does not have this behavior.
      </para>
-->
<para>
<function>to_timestamp</function>和<function>to_date</function>
用来处理不能通过简单转换被转换的输入格式。
这些函数用最小的错误检查解释输入。当它们产生有效的输出时，
转换可以产生预想不到的结果。例如，这些函数的输入不受正常范围的约束，
因此<literal>to_date('20096040','YYYYMMDD')</literal>返回
<literal>2014-01-17</literal>而不是引起一个错误。
类型转换没有这样的行为。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains pattern key words.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.  In <function>to_date</>, <function>to_number</>,
       and <function>to_timestamp</>, double-quoted strings skip the number of
       input characters contained in the string, e.g. <literal>"XX"</>
       skips two input characters.
      </para>
-->
<para>
在<function>to_char</function>模板里可以有普通文本，并且它们会被逐字输出。
你可以把一个字符串放到双引号里强迫它解释成一个文本，即使它里面包含模式关键字也如此。
比如<literal>'"Hello Year "YYYY'</literal>中的<literal>YYYY</literal>将被年份数据代替，
但是<literal>Year</literal>里单独的<literal>Y</literal>会。在<function>to_date</>，
<function>to_number</>和<function>to_timestamp</>里，加双引号的字符串忽略包含在字符串中的输入字符的数量，
例如，<literal>"XX"</>忽略两个输入字符。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045- "" font-lock sanity :-) &#045->
      </para>
-->
<para>
如果你想在输出里有双引号，那么你必须在它们前面放反斜杠，比如<literal>'\"YYYY Month\"'</literal>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       If the year format specification is less than four digits, e.g.
       <literal>YYY</>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.
       <literal>95</> becomes 1995.
      </para>
-->
<para>
如果年份的格式规范少于四个字节，例如<literal>YYY</>，并且提供的年份少于四个字节，
那么年份将调整为接近于2020，例如<literal>95</>成为1995。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The <literal>YYYY</literal> conversion from string to <type>timestamp</type> or
       <type>date</type> has a restriction when processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
      </para>
-->
<para>
如果你使用的年份长于4位字符，那么用<literal>YYYY</literal>从字符串向<type>timestamp</type>
或<type>date</type>做转换时要受到限制。你必须在<literal>YYYY</literal>
后面使用一些非数字字符或者模板，否则年份总是解释为 4 位数字。比如对于 20000 年：
<literal>to_date('200001131', 'YYYYMMDD')</literal>将会被解释成一个 4 位数字的年份，
最好在年后面使用一个非数字的分隔符，像<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>
或<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       In conversions from string to <type>timestamp</type> or
       <type>date</type>, the <literal>CC</literal> (century) field is ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the year is computed
       as the year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
      </para>
-->
<para>
在从字符串向<type>timestamp</type>或<type>date</type>转换的时候，如果有<literal>YYY</literal>,
<literal>YYYY</literal>或<literal>Y,YYY</literal>字段，那么<literal>CC</literal>字段会被忽略。
如果<literal>CC</literal>与<literal>YY</literal>或<literal>Y</literal>一起使用，
那么年份用指定的世纪计算。如果指定了世纪而没有指定年，那么假设使用这个世纪的第一年。
</para>
     </listitem>

     <listitem>
      
<para>
<!--
       An ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified to <function>to_timestamp</function> and
       <function>to_date</function> in one of two ways:
-->
ISO 8601周编号日期（有别于公历日期）可以用下面的两种方法之一声明为
<function>to_timestamp</function>和<function>to_date</function>：
       <itemizedlist>
        <listitem>
<!-- 
         <para>
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
         </para>
 -->
<para>
年，周编号和工作日：例如<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
返回日期<literal>2006-10-19</literal>。如果你省略工作日，那么它假设为1（星期一）。
</para>
        </listitem>
        <listitem>
         <!--
<para>
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
         </para>
-->
<para>
年和一年中的日：例如<literal>to_date('2006-291', 'IYYY-IDDD')</literal>返回
<literal>2006-10-19</literal>。
</para>
        </listitem>
       </itemizedlist>
      </para>
      <!--
<para>
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</> or <quote>day of month</> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
      </para>
-->
<para>
试图用ISO 8601周编号字段和公历日期字段混合输入日期是没有意义的，
并且将导致一个错误。在ISO 8601周编号年的范围，<quote>月</>
和<quote>月中的天</>的概念没有意义。在公历年的范围，ISO周没有意义。
</para>

      <caution>
<!-- 
       <para>
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"> for more
        information.)
       </para>
-->
<para>
虽然<function>to_date</function>拒绝公历和ISO周编号日期字段的混合，
但是<function>to_char</function>并不拒绝，因为像<literal>YYYY-MM-DD (IYYY-IDDD)</>
这样的输出格式说明是有用的。但是要避免像<literal>IYYY-MM-DD</>这样写；
它将会在年的开始附近产生意外的结果。（参阅<xref linkend="functions-datetime-extract">
获取更多信息。）
</para>
      </caution>      
     </listitem>

     <listitem>
      <!--
<para>
       In a conversion from string to <type>timestamp</type>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       values are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds,
       but 300, because the conversion counts it as 12 + 0.3 seconds.
       This means for the format <literal>SS:MS</literal>, the input values
       <literal>12:3</literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must use
       <literal>12:003</literal>, which the conversion counts as
       12 + 0.003 = 12.003 seconds.
      </para>
-->
<para>
将字符串转化为<type>timestamp</type>时，毫秒(<literal>MS</literal>)和微秒(<literal>US</literal>)
都是用小数点后面的位数转换的。比如<literal>to_timestamp('12:3', 'SS:MS')</literal>
不是 3 毫秒, 而是 300 毫秒，因为转换把它看做 12+0.3 秒。这意味着对于格式<literal>SS:MS</literal>
而言，输入值<literal>12:3</literal>,<literal>12:30</literal>,<literal>12:300</literal>
声明了相同的毫秒数。对于 3 毫秒，你必须使用<literal>12:003</literal>，
那么转换会把它看做 12+0.003 = 12.003 秒。
</para>

<!--      
<para>
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
      </para>
-->
<para>
这个更复杂的例子<literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>
是 15小时、12分钟、2秒+20毫秒+1230微秒 = 2.021230秒。
</para>
     </listitem>

     <listitem>
      <!--
<para>
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
      </para>
-->
<para>
<function>to_char(..., 'ID')</function>的星期编号匹配<function>extract(isodow from ...)</function>
函数，但是<function>to_char(..., 'D')</function>的星期编号不匹配<function>extract(dow from ...)</function>
的天编号。
</para>
     </listitem>

     <listitem>
      <!--
<para>
        <function>to_char(interval)</function> formats <literal>HH</> and
        <literal>HH12</> as shown on a 12-hour clock, i.e. zero hours
        and 36 hours output as <literal>12</>, while <literal>HH24</>
        outputs the full hour value, which can exceed 23 for intervals.
      </para>
-->
<para>
<function>to_char(interval)</function>将<literal>HH</>和<literal>HH12</>格式化为12小时，
也就是零时和36时输出是<literal>12</>，而<literal>HH24</>可以输出完整的小时数，
时间间隔可以超过23。
</para>
     </listitem>

    </itemizedlist>
   </para>

  <!--
<para>
   <xref linkend="functions-formatting-numeric-table"> shows the
   template patterns available for formatting numeric values.
  </para>
-->
<para>
<xref linkend="functions-formatting-numeric-table">显示了用于数值格式化的模板模式。
</para>

    <table id="functions-formatting-numeric-table">
     <!-- 
 <title>Template Patterns for Numeric Formatting</title> 
 -->
 <title>数值格式化的模版模式</title>
     <tgroup cols="2">
      <thead>
       <row>
        <!-- 
<entry>Pattern</entry>
        <entry>Description</entry> 
-->
<entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
        <!-- 
<entry>value with the specified number of digits</entry> 
-->
<entry>带有指定数值位数的值</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
        <!-- 
<entry>value with leading zeros</entry> 
-->
<entry>带前导零的值</entry>
       </row>
       <row>
   <!--
        <entry><literal>.</literal> (period)</entry>        
<entry>decimal point</entry> 
-->
<entry><literal>.</literal> (句点)</entry>
<entry>小数点</entry>
       </row>
       <row>
   <!--
        <entry><literal>,</literal> (comma)</entry>
       <entry>group (thousand) separator</entry> 
-->
<entry><literal>,</literal> (逗号)</entry>
<entry>分组(千) 分隔符</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
        <!-- 
<entry>negative value in angle brackets</entry> 
-->
<entry>尖括号内负值</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
        <!-- 
<entry>sign anchored to number (uses locale)</entry>
-->
<entry>带符号的数值(使用区域设置)</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
        <!-- 
<entry>currency symbol (uses locale)</entry> 
-->
<entry>货币符号(使用区域设置)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <!-- 
<entry>decimal point (uses locale)</entry>
-->
<entry>小数点(使用区域设置)</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
        <!-- 
<entry>group separator (uses locale)</entry> 
-->
<entry>分组分隔符(使用区域设置)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <!-- 
<entry>minus sign in specified position (if number &lt; 0)</entry> 
-->
<entry>在指明的位置的负号(如果数字 &lt; 0)</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
        <!-- 
<entry>plus sign in specified position (if number &gt; 0)</entry>
-->
<entry>在指明的位置的正号(如果数字 &gt; 0)</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
       <!-- 
   <entry>plus/minus sign in specified position</entry> 
   -->
    <entry>在指明的位置的正/负号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
        <!-- 
<entry>Roman numeral (input between 1 and 3999)</entry> 
-->
<entry>罗马数字(输入在 1 和 3999 之间)</entry>
       </row>
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <!-- 
<entry>ordinal number suffix</entry> 
-->
<entry>序数后缀</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
        <!-- 
<entry>shift specified number of digits (see notes)</entry> 
-->
<entry>移动指定位(小数)(参阅注解)</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
        <!-- 
<entry>exponent for scientific notation</entry> 
-->
<entry>指数为科学记数法</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   
<para>
<!--
    Usage notes for numeric formatting:
-->
数字格式化的用法须知：
    <itemizedlist>
     <listitem>
<!-- 
      <para>
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.
      </para>
 -->
<para>
使用<literal>SG</literal>, <literal>PL</literal>, <literal>MI</literal>
生成的符号并不挂在数字上面；比如，<literal>to_char(-12, 'MI9999')</literal>
生成<literal>'-&nbsp;&nbsp;12'</literal>；但是<literal>to_char(-12, 'S9999')</literal>
<literal>'&nbsp;&nbsp;-12'</literal>。Oracle里的实现不允许在<literal>9</literal>
前面使用<literal>MI</literal>，而是要求<literal>9</literal>在<literal>MI</literal>前面。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>9</literal> results in a value with the same number of
       digits as there are <literal>9</literal>s. If a digit is
       not available it outputs a space.
      </para>
-->
<para>
<literal>9</literal>声明和<literal>9</literal>的个数相同的数字位数的数值。
如果某个数值位没有数字，则输出一个空白。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
      </para>
-->
<para>
<literal>TH</literal>不会转换小于零的数值，也不会转换小数。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
      </para>
-->
<para>
<literal>PL</literal>, <literal>SG</literal>, <literal>TH</literal>
是<productname>PostgreSQL</productname>扩展。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>V</literal> effectively
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.
       <function>to_char</function> does not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
      </para>
-->
<para>
<literal>V</literal>方便地把输入值乘以 <literal>10^<replaceable>n</replaceable></literal>，
这里<replaceable>n</replaceable>是跟在<literal>V</literal>后面的数字。
<function>to_char</function>不支持把<literal>V</literal>
与一个小数点组合在一起使用(也就是说<literal>99.9V99</literal>是不允许的)。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
      </para>
-->
<para>
<literal>EEEE</literal>（科学记数法）不能和任何其他格式化的模式或修饰符以外的数字和小数点模式混合使用，
并且必须在格式化字符串的后面（例如，<literal>9.99EEEE</literal>是合法的模式）。
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM9999</literal>
    is the <literal>9999</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"> shows the
    modifier patterns for numeric formatting.
   </para>
-->
<para>
一定的修饰符可以应用于任何模板模式来改变其行为。例如，<literal>FM9999</literal>
是<literal>9999</literal>模式和<literal>FM</literal>修饰符。
<xref linkend="functions-formatting-numericmod-table">显示了数字格式的修饰符模式。
</para>

    <table id="functions-formatting-numericmod-table">
     <!-- 
 <title>Template Pattern Modifiers for Numeric Formatting</title> 
 -->
 <title>数字格式的模板模式修饰符</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>修饰符</entry>
        <entry>描述</entry>
        <entry>示例</entry>
       </row>
      </thead>
      <tbody>
       <row>
   <!-- 
        <entry><literal>FM</literal> prefix</entry>
       <entry>fill mode (suppress padding blanks and trailing zeroes)</entry> 
-->
<entry><literal>FM</literal> 前缀</entry>
<entry>填充模式 (抑制填充空白和尾随零)</entry>
        <entry><literal>FM9999</literal></entry>
       </row>
       <row>
        <!-- 
<entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
-->
<entry><literal>TH</literal> 后缀</entry>
        <entry>大写顺序数后缀</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
        <!-- 
<entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
-->
<entry><literal>th</literal> 后缀</entry>
        <entry>小写顺序数后缀</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   <xref linkend="functions-formatting-examples-table"> shows some
   examples of the use of the <function>to_char</function> function.
  </para>
-->
<para>
<xref linkend="functions-formatting-examples-table">显示了一些
<function>to_char</function>函数的用法。
</para>

    <table id="functions-formatting-examples-table">
     <!-- 
 <title><function>to_char</function> Examples</title> 
 -->
 <title><function>to_char</function> 示例</title>
     <tgroup cols="2">
      <thead>
       <row>
        <!-- 
<entry>Expression</entry>
        <entry>Result</entry> 
-->
<entry>表达式</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
   <!-- 
   <title>Date/Time Functions and Operators</title> 
   -->
   <title>时间/日期函数和操作符</title>

  <!--
<para>
   <xref linkend="functions-datetime-table"> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting">.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime">.
  </para>
-->
<para>
<xref linkend="functions-datetime-table">显示了可以用于处理日期/时间数值的函数，
随后一节里描述了细节。<xref linkend="operators-datetime-table">
演示了基本算术操作符的行为(<literal>+</literal>,<literal>*</literal>, 等)。
而与格式化相关的函数，可以参考<xref linkend="functions-formatting">。
你应该很熟悉<xref linkend="datatype-datetime">的日期/时间数据类型的背景知识。
</para>

  <!--
<para>
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</> and <literal>*</> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
  </para>
-->
<para>
所有下述函数和操作符接收的<type>time</type>或<type>timestamp</type>输入实际上都来自两种可能：
一种是接收<type>time with time zone</type>或<type>timestamp with time zone</type>，
另外一种是接收<type>time without time zone</type>或<type>timestamp without time zone</type>。
出于简化考虑，这些变种没有独立显示出来。还有，<literal>+</>和<literal>*</>
操作符都是以可交换的操作符对(比如，date + integer 和 integer + date)；
我们只显示了这样的交换操作符对中的一个。
</para>

    <table id="operators-datetime-table">
     <!-- 
 <title>Date/Time Operators</title> 
 -->
 <title>日期/时间操做符</title>

     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>操作符</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
        <entry><literal>integer '3'</literal> (days)</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
     <!-- 
 <title>Date/Time Functions</title> 
 -->
 <title>日期/时间函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <!-- 
<entry>Subtract arguments, producing a <quote>symbolic</> result that
        uses years and months, rather than just days</entry>
-->
<entry>减去参数后的<quote>符号化</>结果，使用年和月，不只是使用天</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <!-- 
<entry>Subtract from <function>current_date</function> (at midnight)</entry> 
-->
<entry>从<function>current_date</function>减去参数后的结果（在午夜）</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current">
        </entry>
-->
<entry>实时时钟的当前时间戳（在语句执行时变化）；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <!-- 
<entry>Current date;
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当前的日期；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <!-- 
<entry>Current time of day;
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当日时间；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当前事务开始时的时间戳；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>Get subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract">
        </entry> 
-->
<entry>获取子域(等效于<function>extract</function>)；又见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>Get subfield (equivalent to
         <function>extract</function>); see <xref linkend="functions-datetime-extract">
        </entry> 
-->
<entry>获取子域(等效于<function>extract</function>)；又见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <!-- 
<entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
        </entry> 
-->
<entry>截断成指定的精度；又见<xref linkend="functions-datetime-trunc">
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <!-- 
        <entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
        </entry>
        -->
        <entry>截取指定的精度，又见<xref linkend="functions-datetime-trunc">
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>Get subfield; see <xref linkend="functions-datetime-extract">
        </entry> 
-->
<entry>获取子域；又见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>Get subfield; see <xref linkend="functions-datetime-extract">
        </entry> 
-->
<entry>获取子域；又见<xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>Test for finite date (not +/-infinity)</entry> 
-->
<entry>测试是否为有穷日期(不是 +/-无穷)</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>Test for finite time stamp (not +/-infinity)</entry> 
-->
<entry>测试是否为有穷时间戳(不是 +/-无穷)</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>Test for finite interval</entry> 
-->
<entry>测试是否为有穷时间间隔</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <!-- 
<entry>Adjust interval so 30-day time periods are represented as months</entry> 
-->
<entry>按照每月 30 天调整时间间隔</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <!-- 
<entry>Adjust interval so 24-hour time periods are represented as days</entry> 
-->
<entry>按照每天 24 小时调整时间间隔</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <!-- 
<entry>Adjust interval using <function>justify_days</> and <function>justify_hours</>, with additional sign adjustments</entry> 
-->
<entry>使用<function>justify_days</>和<function>justify_hours</>调整时间间隔的同时进行正负号调整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
        <!-- 
<entry>Current time of day;
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当日时间；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <!-- 
<entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当前事务开始时的时间戳；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
         <!-- 
         Create date from year, month and day fields
         -->
         为年、月和日字段创建日期
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
         <!-- 
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields
         -->
         从年、月、周、天、小时、分钟和秒字段中创建间隔
        </entry>
        <entry><literal>make_interval(days := 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
         <!-- 
         Create time from hour, minute and seconds fields
         -->
         从小时、分钟和秒字段中创建时间
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
         <!-- 
         Create timestamp from year, month, day, hour, minute and seconds fields
         -->
         从年、月、日、小时、分钟和秒字段中创建时间戳
        </entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
         <!-- 
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields. When <parameter>timezone</parameter> is not specified,
         then current time zone is used.
         -->
         从年、月、日、小时、分钟和秒字段中创建带有时区的时间戳。
         没有指定<parameter>timezone</parameter>时，使用当前的时区。
        </entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当前事务开始时的时间戳；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>实时时钟的当前时间戳；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>Current date and time
         (like <function>clock_timestamp</>, but as a <type>text</> string);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>与<function>clock_timestamp</>相同，但结果是一个<type>text</>
字符串；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
        </entry> 
-->
<entry>当前事务开始时的时间戳；见<xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<para>
<!--
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    In addition to these functions, the SQL <literal>OVERLAPS</> operator is
    supported:
-->
除了这些函数以外，还支持 SQL 的<literal>OVERLAPS</>操作符：
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    <!-- 
This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</> <literal>&lt;=</>
    <replaceable>time</> <literal>&lt;</> <replaceable>end</>, unless
    <replaceable>start</> and <replaceable>end</> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap. 
-->
这个表达式在两个时间域(用它们的终点定义)重叠的时候生成真值，在不重叠是生成假值。
终点可以用一对日期、时间、时间戳来声明；或者是一个后面跟着一个时间间隔的日期、
时间、时间戳。当提供一对值，不管先写开始还是结束；<literal>OVERLAPS</>
自动将这对值较早的作为开始。每段时间取值为半开区间<replaceable>开始</> <literal>&lt;=</>
 <replaceable>时间</> <literal>&lt;</> <replaceable>结束</>，除非<replaceable>开始</>
 和<replaceable>结束</>相等，此时表示单一的时刻。
 这意味着两个时间段只有一个共同的端点没有重叠。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <!--
<para>
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set to <literal>CST7CDT</literal>,
   <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>
   will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>,
   while adding <literal>interval '24 hours'</literal> to the same initial
   <type>timestamp with time zone</type> produces
   <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is
   a change in daylight saving time at <literal>2005-04-03 02:00</literal> in time zone
   <literal>CST7CDT</literal>.
  </para>
-->
<para>
当把<type>interval</type>值添加到<type>timestamp with time zone</type>上(或从中减去)的时候，
days 部分会按照指定的天数增加或减少<type>timestamp with time zone</type>的日期。
对于横跨夏令时的变化(会话的时区设置被识别为夏时制)，<literal>interval '1 day'</literal>
并不一定等于<literal>interval '24 hours'</literal>。例如，当会话的时区设置为<literal>CST7CDT</literal>
的时候<literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>
的结果是<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>，
而将<literal>interval '24 hours'</literal>增加到相同的<type>timestamp with time zone</type>
之上的结果则是<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>，
因为<literal>CST7CDT</literal>时区在<literal>2005-04-03 02:00</literal>的时候有一个夏令时变更。
</para>

  <!--
<para>
   Note there can be ambiguity in the <literal>months</> field returned by
   <function>age</> because different months have different numbers of
   days.  <productname>PostgreSQL</>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</> uses April to yield
   <literal>1 mon 1 day</>, while using May would yield <literal>1 mon 2
   days</> because May has 31 days, while April has only 30.
  </para>
-->
<para>
注意<function>age</>返回的<literal>months</>字段可能有歧义，
因为不同的月份有不同的天数。<productname>PostgreSQL</>的方法是当计算部分月数时，
采用两个日期较早的月。例如：<literal>age('2004-06-01', '2004-04-30')</>
使用4月份产生<literal>1 mon 1 day</>，当用5月分时产生<literal>1 mon 2 days</>，
因为5月有31天，而4月只有30天。
</para>

<!-- 
  <para>
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</>, then subtract the
   results; this produces the
   number of <emphasis>seconds</> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</>; there is a daylight saving time change between the
   two dates used:
  </para>
-->
<para>
日期和时间戳的减法也是复杂的。概念上讲，一种简单的方法是使用
<literal>EXTRACT(EPOCH FROM ...)</>转换每个值为秒数，然后相减；
这样就生成了两个值之间的<emphasis>秒</>数。
这将适应月中天数的变化、时区的变化和夏令时调整。
使用<quote><literal>-</></quote>操作符减去日期或者时间戳值，
返回两个值之间的天数（24小时）和小时/分钟/秒，也做相应的调整。
<function>age</>函数返回年、月、天和小时/分钟/秒，
先执行字段对应字段的减法，然后根据本地字段值做调整。
下列的查询解释了这些方法之间的不同。相同的结果可以用
<literal>timezone = 'US/Eastern'</>产生；使用的两个值之间有夏令时的变化：
</para>
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>
  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <!--
<para>
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:
-->
<para>
<function>extract</function>函数从日期/时间数值里抽取子域，比如年、小时等。
<replaceable>source</replaceable>必须是一个<type>timestamp</type>, <type>time</type>,
<type>interval</type>类型的值表达式(类型为<type>date</type>的表达式转换为
<type>timestamp</type>，因此也可以用)。<replaceable>field</replaceable>
是一个标识符或者字符串，它指定从源数据中抽取的域。<function>extract</function>
函数返回类型为<type>double precision</type>的数值。下列数值是有效数据域的名字：
    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
<!-- 
       <para>
        The century
       </para>
 -->
<para>
世纪
</para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <!--
<para>
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
       </para>
-->
<para>
第一个世纪从 0001-01-01 00:00:00 AD 开始，尽管那时候人们还不知道这是第一个世纪。
这个定义适用于所有使用阳历的国家。没有 0 世纪，我们直接从公元前 1 世纪到公元 1 世纪。
如果你认为这个不合理，那么请把抱怨发给：梵蒂冈，罗马圣彼得教堂，教皇收。
</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <!--
<para>
        For <type>timestamp</type> values, the day (of the month) field
        (1 - 31) ; for <type>interval</type> values, the number of days
       </para>
-->
<para>
对于<type>timestamp</type>值，(月份)里的日期(1-31)；对于<type>interval</type>，天数
</para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <!--
<para>
        The year field divided by 10
       </para>
-->
<para>
年份除以 10
</para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <!--
<para>
        The day of the week as Sunday(<literal>0</>) to
        Saturday(<literal>6</>)
       </para>
-->
<para>
每周的星期号，星期天(<literal>0</>)到星期六(<literal>6</>)
</para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <!--
<para>
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
       </para>
-->
<para>
请注意，<function>extract</function>的星期几编号和<function>to_char(..., 'D')</function>函数不同。
</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <!--
<para>
        The day of the year (1 - 365/366)
       </para>
-->
<para>
一年的第几天(1-365/366)
</para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <!--
<para>
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
       </para>
-->
<para>
对于<type>timestamp with time zone</type>值而言，
是自 1970-01-01 00:00:00-00 UTC以来的秒数(结果可能是负数)；
对于<type>date</type>和<type>timestamp</type>值而言，
是自 1970-01-01 00:00:00 当地时间以来的秒数；
对于<type>interval</type>值而言，它是时间间隔的总秒数。
</para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <!--
<para>
        Here is how you can convert an epoch value back to a time
        stamp:
       </para>
-->
<para>
下面是把 epoch 值转换回时间戳的方法：
</para>
<screen>
SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';
</screen>
       <!--
<para>
        (The <function>to_timestamp</> function encapsulates the above
        conversion.)
       </para>
-->
<para>
（<function>to_timestamp</>函数封装上面的转换。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <!--
<para>
        The hour field (0 - 23)
       </para>
-->
<para>
小时域(0-23)
</para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <!--
<para>
        The day of the week as Monday(<literal>1</>) to
        Sunday(<literal>7</>)
       </para>
-->
<para>
周中的第几天 [1-7] 星期一：(<literal>1</>)星期天：(<literal>7</>)。
</para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <!--
<para>
        This is identical to <literal>dow</> except for Sunday.  This
        matches the <acronym>ISO</> 8601 day of the week numbering.
       </para>
-->
<para>
除了星期天外，都与<literal>dow</>相同。这与<acronym>ISO</> 8601标准周中的第几天编码相匹配。
</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <!--
<para>
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
        </para>
-->
<para>
日期中的<acronym>ISO</acronym> 8601周编号年（不适用于间隔）。
</para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <!--
<para>
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
       </para>
-->
<para>
<acronym>ISO</acronym> 8601周编号年以带有包含1月4日的周的周一开始，
所以在年初的1月或12月下旬的<acronym>ISO</acronym>年可能会不同于阳历的年。
见<literal>week</literal>字段获取更多信息。
</para>
       <!--
<para>
        This field is not available in PostgreSQL releases prior to 8.3.
       </para>
-->
<para>
这个域不能用于 PostgreSQL 8.3之前的版本。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <!--
<para>
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
       </para>
-->
<para>
秒域(包括小数部分)乘以 1,000,000 。请注意它包括全部的秒。
</para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <!--
<para>
        The millennium
       </para>
-->
<para>
千年
</para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <!--
<para>
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
       </para>
-->
<para>
20 世纪(19xx 年)里面的年份在第二个千年里。第三个千年从 2001 年 1 月 1 日零时开始。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <!--
<para>
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
       </para>
-->
<para>
秒域(包括小数部分)乘以 1000 。请注意它包括完整的秒。
</para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <!--
<para>
        The minutes field (0 - 59)
       </para>
-->
<para>
分钟域(0-59)
</para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <!--
<para>
        For <type>timestamp</type> values, the number of the month
        within the year (1 - 12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0 - 11)
       </para>
-->
<para>
对于<type>timestamp</type>值，它是一年里的月份数(1-12)；对于<type>interval</type>值，
它是月的数目，然后对 12 取模(0-11)
</para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <!--
<para>
        The quarter of the year (1 - 4) that the date is in
       </para>
-->
<para>
该天所在的该年的季度(1-4)
</para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <!--
<para>
        The seconds field, including fractional parts (0 -
        59<footnote><simpara>60 if leap seconds are
        implemented by the operating system</simpara></footnote>)
       </para>
-->
<para>
秒域，包括小数部分(0-59)<footnote><simpara>如果操作系统实现了润秒，那么上限是 60 。
</simpara></footnote>)
</para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <!--
<para>
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> uses <acronym>UT1</> because
        leap seconds are not handled.)
       </para>
-->
<para>
与 UTC 的时区偏移量，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区。
（技术角度讲，<productname>PostgreSQL</productname>使用<acronym>UT1</>，因为不处理闰秒。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <!--
<para>
        The hour component of the time zone offset
       </para>
-->
<para>
时区偏移量的小时部分。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <!--
<para>
        The minute component of the time zone offset
       </para>
-->
<para>
时区偏移量的分钟部分。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <!--
<para>
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
       </para>
-->
<para>
该天在所在的年份里是第几个<acronym>ISO</acronym> 8601周编号的周。
按照定义，ISO周在周一开始并且该年的第一周包含该年的一月四日。换句话说，
一年的第一个星期四在第一周。
</para>
       <!--
<para>
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</> is part of the 53rd week of year
        2004, and <literal>2006-01-01</> is part of the 52nd week of year
        2005, while <literal>2012-12-31</> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</> field together with
        <literal>week</> to get consistent results.
       </para>
-->
<para>
在ISO周编号系统里，一月的头几天可能是前一年的第 52 或者第 53 周，
十二月的后几天可能是下一年第一周。比如，<literal>2005-01-01</>是 2004 年的第 53 周，
而<literal>2006-01-01</>是 2005 年的第 52 周，<literal>2012-12-31</>是2013年的第一周。
建议<literal>isoyear</>字段和<literal>week</>一起使用以得到一致的结果。
</para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <!--
<para>
        The year field.  Keep in mind there is no <literal>0 AD</>, so subtracting
        <literal>BC</> years from <literal>AD</> years should be done with care.
       </para>
-->
<para>
年份域。要记住这里没有<literal>0 AD</>，所以从<literal>AD</>年里抽取<literal>BC</>年应该小心些。
</para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <!--
<para>
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting">.
   </para>
-->
<para>
<function>extract</function>函数主要的用途是运算。
对于用于显示的日期/时间数值格式化，参阅<xref linkend="functions-formatting">。
</para>
   
<para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>函数是在传统的<productname>Ingres</productname>
函数的基础上制作的(该函数等效于<acronym>SQL</acronym>标准函数<function>extract</function>)：
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!-- 
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>. 
-->
请注意这里的 <replaceable>field</replaceable>参数必须是一个字符串值，而不是一个名字。
有效的<function>date_part</function>数域名和<function>extract</function>是一样的。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <!--
<para>
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
   </para>
-->
<para>
<function>date_trunc</function>函数在概念上和用于数字的<function>trunc</function>函数类似。
</para>
   
<para>
<synopsis>
date_trunc('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type> or <type>interval</>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is of type
    <type>timestamp</type> or <type>interval</>
    with all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>是<type>timestamp</type>或<type>interval</>
类型的值表达式(<type>date</type>和<type>time</type>类型的值都分别自动转换成
<type>timestamp</type>或<type>interval</>)。用<replaceable>field</replaceable>
选择对该时间戳值用什么样的精度进行截断。返回的数值是<type>timestamp</type>
或<type>interval</>类型，所有小于选定的精度的域都设置为零(日期和月份域则为 1)。
   </para>
<para>
   <!-- 
   Valid values for <replaceable>field</replaceable> are: 
   -->
   <replaceable>field</replaceable>的有效数值是： 
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>
<para>
    <!-- 
Examples: 
-->
例子：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen>
   </para>

  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
    <!-- 
<primary>time zone</primary>
    <secondary>conversion</secondary> 
-->
<primary>时区</primary>
    <secondary>转换</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <!--
<para>
    The <literal>AT TIME ZONE</literal> construct allows conversions
    of time stamps to different time zones.  <xref
    linkend="functions-datetime-zoneconvert-table"> shows its
    variants.
   </para>
-->
<para>
<literal>AT TIME ZONE</literal>构造允许把时间戳转换成不同的时区。
<xref linkend="functions-datetime-zoneconvert-table">显示了其变体。
</para>

    <table id="functions-datetime-zoneconvert-table">
     <!-- 
 <title><literal>AT TIME ZONE</literal> Variants</title> 
 -->
 <title><literal>AT TIME ZONE</literal> 变体</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Expression</entry>
        <entry>Return Type</entry>
        <entry>Description</entry> 
-->
<entry>表达式</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <!-- 
<entry>Treat given time stamp <emphasis>without time zone</> as located in the specified time zone</entry>
-->
<entry>把给出的<emphasis>不带时区</>的时间戳转换成给定时区的时间戳</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
        <!-- 
<entry>Convert given time stamp <emphasis>with time zone</> to the new time
        zone, with no time zone designation</entry> 
-->
<entry>把给出的<emphasis>带时区</>的时间戳转换成未指定时区的时间戳</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <!-- 
<entry>Convert given time <emphasis>with time zone</> to the new time zone</entry> 
-->
<entry>把给出的<emphasis>带时区</>的时间转换成给定时区的时间</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    In these expressions, the desired time zone <replaceable>zone</> can be
    specified either as a text string (e.g., <literal>'PST'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones">.
   </para>
-->
<para>
在这些表达式里，<replaceable>zone</>可以声明为文本串(比如<literal>'PST'</literal>)
或者一个时间间隔(比如<literal>INTERVAL '-08:00'</literal>)。在文本的情况下，
可用的时区名字在<xref linkend="datatype-timezones">有详细描述。
</para>
  
<para>
 <!--
    Examples (assuming the local time zone is <literal>PST8PDT</>):
-->
例子(假设本地时区是<literal>PST8PDT</>)：
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen>
<!-- 
    The first example takes a time stamp without time zone and interprets it as MST time
    (UTC-7), which is then converted to PST (UTC-8) for display.  The second example takes
    a time stamp specified in EST (UTC-5) and converts it to local time in MST (UTC-7). 
-->
第一个例子接受一个无时区的时间戳然后把它解释成 MST(UTC-7) 时间生成 UTC 时间戳，
然后把这个时间转换为 PST(UTC-8) 显示。第二个例子接受一个声明为 EST(UTC-5) 的时间戳，
然后把它转换成 MST(UTC-7) 的当地时间。
   </para>
   <!--
<para>
    The function <literal><function>timezone</function>(<replaceable>zone</>,
    <replaceable>timestamp</>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</> AT TIME ZONE
    <replaceable>zone</></literal>.
   </para>
-->
<para>
<literal><function>timezone</function>(<replaceable>zone</>, <replaceable>timestamp</>)</literal>
函数等效于 SQL 兼容的构造<literal><replaceable>timestamp</> AT TIME ZONE <replaceable>zone</></literal>。
</para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <!-- 
   <title>Current Date/Time</title> 
   -->
   <title>当前日期/时间</title>

   <indexterm>
    <!-- 
<primary>date</primary>
    <secondary>current</secondary> 
-->
<primary>日期</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>time</primary>
    <secondary>current</secondary> 
-->
<primary>时间</primary>
    <secondary>当前</secondary>
   </indexterm>

<para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>提供许多返回当前日期和时间的函数。
这些符合 SQL 标准的函数全部都按照当前事务的开始时刻返回结果：
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>
    <!--
<para>
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
    </para>
-->
<para>
<function>CURRENT_TIME</function>和<function>CURRENT_TIMESTAMP</function>
返回带有时区的值；<function>LOCALTIME</function>和<function>LOCALTIMESTAMP</function>
返回不带时区的值。
</para>

    <!--
<para>
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
    </para>
-->
<para>
<function>CURRENT_TIME</function>,<function>CURRENT_TIMESTAMP</function>,
<function>LOCALTIME</function>,<function>LOCALTIMESTAMP</function>
可以有选择地获取一个精度参数，该精度导致结果的秒数域园整到指定小数位。
如果没有精度参数，将给予所能得到的全部精度。
</para>
   
<para>
<!--
    Some examples:
-->
一些例子：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>
   <!--
<para>
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
   </para>
-->
<para>
因为这些函数全部都按照当前事务的开始时刻返回结果，
所以它们的值在事务运行的整个期间内都不改变。我们认为这是一个特性：
目的是为了允许一个事务在<quote>当前时间</quote>上有连贯的概念，
这样在同一个事务里的多个修改可以保持同样的时间戳。
</para>

   <note>
    <!--
<para>
     Other database systems might advance these values more
     frequently.
    </para>
-->
<para>
许多其它数据库系统更频繁地更新这些数值。
</para>
   </note>
  
<para>
 <!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>同样也提供了返回实时时间值的函数，
它们的返回值会在事务中随时间的前进而变化。这些不附合 SQL 标准的函数列表如下：
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>
   <!--
<para>
    <function>transaction_timestamp()</> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</> and <function>transaction_timestamp()</>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</>, it returns the actual current time,
    but as a formatted <type>text</> string rather than a <type>timestamp
    with time zone</> value.
    <function>now()</> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
   </para>
-->
<para>
<function>transaction_timestamp()</>等效于<function>CURRENT_TIMESTAMP</function>，
不过其命名准确的表明了其含义。<function>statement_timestamp()</>
返回当前事务开始时刻的时间戳(更准确的说是收到客户端最后一条命令的时间)。
<function>statement_timestamp()</>和<function>transaction_timestamp()</>
在一个事务的第一条命令里返回值相同，但是在随后的命令中却不一定相同。
c<function>clock_timestamp()</>返回实时时钟的当前时间戳，
因此它的值甚至在同一条 SQL 命令中都会变化。<function>timeofday()</>是一个历史的
<productname>PostgreSQL</productname>函数，类似于<function>clock_timestamp()</>，
它也返回实时时钟的当前时间戳，不过它返回一个格式化了的<type>text</>字符串，
而不是<type>timestamp with time zone</>值。<function>now()</>
是传统的<productname>PostgreSQL</productname>和<function>transaction_timestamp()</function>等效的函数。
</para>
   
<para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
所有日期/时间类型还接受特殊的文本值<literal>now</literal>，
用于声明当前的日期和时间(重申：当前事务的开始时刻)。
因此，下面三个都返回相同的结果：
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT
</programlisting>
   </para>


    <tip>
     <!--
<para>
      You do not want to use the third form when specifying a <literal>DEFAULT</>
      clause while creating a table.  The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
     </para>
-->
<para>
在创建表的时候你不应该用第三种形式声明一个<literal>DEFAULT</>值。
系统将在分析这个常量的时候把<literal>now</literal>转换为一个<type>timestamp</type>，
因此这个缺省值就会变成创建表的时间！而前两种形式要到实际使用缺省值的时候才计算，
因为它们是函数调用。因此它们可以给出每次插入行的时刻。
</para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
   <!-- 
   <title>Delaying Execution</title> 
   -->
   <title>延时执行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
   <primary>sleep</primary>
   </indexterm>
   <indexterm>
    <primary>delay</primary>
   </indexterm>

<para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
下面的这个函数可以用于让服务器进程延时执行：
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</>)
pg_sleep_until(<type>timestamp with time zone</>)
</synopsis>
<!-- 
    <function>pg_sleep</function> makes the current session's process
    sleep until <replaceable>seconds</replaceable> seconds have
    elapsed.  <replaceable>seconds</replaceable> is a value of type
    <type>double precision</>, so fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function for larger
    sleep times specified as an <type>interval</>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
 -->
<function>pg_sleep</function>让当前的会话进程休眠<replaceable>seconds</replaceable>
秒以后再执行。<replaceable>seconds</replaceable>是一个<type>double precision</>
类型的值，所以可以指定带小数的秒数。<function>pg_sleep_for</function>
对于指定为<type>interval</>的较长睡眠时间是一个便利函数。
<function>pg_sleep_until</function>在需要特定唤醒时间时比较便利。例如：
<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <!--
<para>
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
      </para>
-->
<para>
有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用的。
休眠的时间将至少等于指定的时间，也有可能由于服务器荷载较重等原因而比指定的时间长。
特别的，<function>pg_sleep_until</function>并不保证能准确的在指定的时间唤醒，
但是它不会提早唤醒。
</para>
   </note>

   <warning>
     <!--
<para>
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
     </para>
-->
<para>
请确保调用<function>pg_sleep</function>或它的变体的会话没有持有不必要的锁。
否则其它会话可能必须等待这个休眠的会话释放所持有的锁，从而减慢系统速度。
</para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
  <!-- 
  <title>Enum Support Functions</title> 
  -->
  <title>支持枚举函数</title>

  
<para>
<!--
   For enum types (described in <xref linkend="datatype-enum">),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table">. The examples
   assume an enum type created as:
-->
对于枚举类型(描述在<xref linkend="datatype-enum">)，
有一些函数允许简洁的编写没有硬编码特定的枚举类型值。
这些列在<xref linkend="functions-enum-table">。像下面的创建枚举类型的例子：
<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
    <!-- 
<title>Enum Support Functions</title> 
-->
<title>支持枚举函数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry> 
   -->
   <entry>函数</entry>
       <entry>描述</entry>
       <entry>示例</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
       <!-- 
   <entry>Returns the first value of the input enum type</entry> 
   -->
   <entry>返回输入枚举类型的第一个值</entry> 
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
       <!-- 
   <entry>Returns the last value of the input enum type</entry> 
   -->
   <entry>返回输入枚举类型的最后一个值</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
       <!-- 
   <entry>Returns all values of the input enum type in an ordered array</entry> 
   -->
   <entry>以一个有序的数组的形式返回输入枚举类型的所有值</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
       <!-- 
   Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type. 
-->
返回在给定两个枚举值之间的范围，作为一个有序数组。该值必须是相同的枚举类型。
如果第一个参数为空，其结果将从枚举类型的第一个值开始。 如果第二参数为空，
其结果将以枚举类型的最后一个值结束。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Notice that except for the two-argument form of <function>enum_range</>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as suggested by the examples.
   </para>
-->
<para>
请注意，除了两个参数形式的<function>enum_range</>外，这些函数忽略传递给他们的具体值，
他们只关心声明的数据类型。null或一个特定类型的值可以通过，得到相同的结果。
更常见于这些功能应用于表列或函数的参数而不是一个硬性的类型名称，
就像例子中建议的那样。
</para>
 </sect1>

 <sect1 id="functions-geometry">
  <!-- 
  <title>Geometric Functions and Operators</title> 
  -->
  <title>几何函数和操作符</title>

   <!--
<para>
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table">, <xref
    linkend="functions-geometry-func-table">, and <xref
    linkend="functions-geometry-conv-table">.
   </para>
-->
<para>
有许多内置函数和操作符支持几何类型<type>point</type>, <type>box</type>,
<type>lseg</type>, <type>line</type>, <type>path</type>, <type>polygon</type>,
<type>circle</type>，在<xref linkend="functions-geometry-op-table">,
<xref linkend="functions-geometry-func-table">,
<xref linkend="functions-geometry-conv-table">中展示。
</para>

   <caution>
    <!--
<para>
     Note that the <quote>same as</> operator, <literal>~=</>, represents
     the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of these types also have an <literal>=</> operator, but
     <literal>=</> compares
     for equal <emphasis>areas</> only.  The other scalar comparison operators
     (<literal>&lt;=</> and so on) likewise compare areas for these types.
    </para>
-->
<para>
请注意<quote>相同</>操作符<literal>~=</>表示<type>point</type>,<type>box</type>,
<type>polygon</type>,<type>circle</type>类型在一般意义上相同。
这些类型有些还有一个<literal>=</>操作符，不过它只是比较相同的<emphasis>面积</>。
其它的标量比较操作符(<literal>&lt;=</>等)也是为这些类型比较面积。
</para>
   </caution>

   <table id="functions-geometry-op-table">
     <!-- 
 <title>Geometric Operators</title> 
 -->
 <title>几何操作符</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <!-- 
<entry>Translation</entry> 
-->
<entry>平移</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <!-- 
<entry>Translation</entry> 
-->
<entry>平移</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
        <!-- 
<entry>Scaling/rotation</entry> 
-->
<entry>伸缩/旋转</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
        <!-- 
<entry>Scaling/rotation</entry> 
-->
<entry>伸缩/旋转</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <!-- 
<entry>Point or box of intersection</entry> 
-->
<entry>交点或者交面</entry>
        <entry><literal>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <!-- 
<entry>Number of points in path or polygon</entry> 
-->
<entry>路径或多边形顶点数</entry>
        <entry><literal># '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
        <!-- 
<entry>Length or circumference</entry> 
-->
<entry>长度或者周长</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
        <!-- 
<entry>Center</entry> 
-->
<entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
        <!-- 
<entry>Closest point to first operand on second operand</entry> 
-->
<entry>第一个操作数相对第二个操作数的最近点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <!-- 
<entry>Distance between</entry> 
-->
<entry>间距</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <!-- 
<entry>Overlaps?  (One point in common makes this true.)</entry> 
-->
<entry>重叠？（有一个共同点为真。）</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <!-- 
<entry>Is strictly left of?</entry> 
-->
<entry>是否严格在左?</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <!-- 
<entry>Is strictly right of?</entry> 
-->
<entry>是否严格在右?</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <!-- 
<entry>Does not extend to the right of?</entry> 
-->
<entry>是否没有延伸到右边?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <!-- 
<entry>Does not extend to the left of?</entry> 
-->
<entry>是否没有延伸到左边?</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
        <!-- 
<entry>Is strictly below?</entry> 
-->
<entry>严格在下?</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
        <!-- 
<entry>Is strictly above?</entry> 
-->
<entry>严格在上?</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
        <!-- 
<entry>Does not extend above?</entry> 
-->
<entry>没有延伸到上面?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
        <!-- 
<entry>Does not extend below?</entry> 
-->
<entry>没有延伸到下面?</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
        <!-- 
<entry>Is below (allows touching)?</entry>
-->
<entry>低于(允许接触)?</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
        <!-- 
<entry>Is above (allows touching)?</entry> 
-->
<entry>高于(允许接触)?</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
        <!-- 
<entry>Intersects?</entry> 
-->
<entry>相交?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <!-- 
<entry>Is horizontal?</entry>
-->
<entry>水平?</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <!-- 
<entry>Are horizontally aligned?</entry> 
-->
<entry>水平对齐?</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <!-- 
<entry>Is vertical?</entry> 
-->
<entry>竖直?</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <!-- 
<entry>Are vertically aligned?</entry> 
-->
<entry>竖直对齐?</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
        <!-- 
<entry>Is perpendicular?</entry>
-->
<entry>垂直?</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
        <!-- 
<entry>Are parallel?</entry> 
-->
<entry>平行?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <!-- 
<entry>Contains?</entry> 
-->
<entry>包含?</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <!-- 
<entry>Contained in or on?</entry> 
-->
<entry>包含或在...上?</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
        <!-- 
<entry>Same as?</entry> 
-->
<entry>与...相同?</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <!--
<para>
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</> and <literal>&lt;@</> were respectively
     called <literal>~</> and <literal>@</>.  These names are still
     available, but are deprecated and will eventually be removed.
    </para>
-->
<para>
在<productname>PostgreSQL</productname> 8.2 之前，包含操作符<literal>@&gt;</>
和<literal>&lt;@</>被分别称为<literal>~</>和<literal>@</>。
我们反对使用这两个旧名字(当前仍然可以使用)，它们将来会被废除。
</para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
     <!-- 
 <title>Geometric Functions</title> 
 -->
 <title>几何函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>area</entry> 
-->
<entry>面积</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</>)</function></literal></entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>center</entry> 
-->
<entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>diameter of circle</entry> 
-->
<entry>圆直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>vertical size of box</entry> 
-->
<entry>矩形的竖直高度</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>a closed path?</entry> 
-->
<entry>闭合路径?</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>an open path?</entry> 
-->
<entry>开路径?</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>length</entry>
-->
<entry>长度</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</>)</function></literal></entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>number of points</entry> 
-->
<entry>点数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</>)</function></literal></entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>number of points</entry> 
-->
<entry>点数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
        <!-- 
<entry>convert path to closed</entry> 
-->
<entry>把路径转换为闭合</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<![IGNORE[
<!-- Not defined by this name. Implements the intersection operator '#' -->
       <row>
        <entry><literal><function>point(<type>lseg</>, <type>lseg</>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>intersection</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
]]>
       <row>
        <entry><literal><function>popen(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
        <!-- 
<entry>convert path to open</entry> 
-->
<entry>把路径转换为开放</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>radius of circle</entry> 
-->
<entry>圆半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <!-- 
<entry>horizontal size of box</entry> 
-->
<entry>矩形的水平尺寸</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
     <!-- 
 <title>Geometric Type Conversion Functions</title> 
 -->
 <title>几何类型转换函数</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
        <!-- 
<entry>circle to box</entry> 
-->
<entry>将圆转换成矩形</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <!-- 
<entry>points to box</entry> 
-->
<entry>将点转换成矩形</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <!-- 
<entry>polygon to box</entry> 
-->
<entry>将多边形转换成矩形</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
        <!-- 
<entry>box to circle</entry> 
-->
<entry>矩形转换成圆</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <!-- 
<entry>center and radius to circle</entry> 
-->
<entry>将圆心和半径转换成圆</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <!-- 
<entry>polygon to circle</entry> 
-->
<entry>将多边形转换成圆</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
        <!-- 
        <entry>points to line</entry>
        -->
        <entry>两点成线</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
        <!-- 
<entry>box diagonal to line segment</entry> 
-->
<entry>矩形对角线转化成线段</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
        <!-- 
<entry>points to line segment</entry> 
-->
<entry>点转换成线段</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
        <!-- 
<entry>polygon to path</entry> 
-->
<entry>多边形转换成路径</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>construct point</entry> 
-->
<entry>结点</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>center of box</entry> 
-->
<entry>矩形的中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>center of circle</entry> 
-->
<entry>圆心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>center of line segment</entry> 
-->
<entry>线段的中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <!-- 
<entry>center of polygon</entry> 
-->
<entry>多边形的中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
        <!-- 
<entry>box to 4-point polygon</entry> 
-->
<entry>矩形转换成 4 点多边形</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <!-- 
<entry>circle to 12-point polygon</entry> 
-->
<entry>圆转换成 12 点多边形</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <!--
<entry>circle to <replaceable class="parameter">npts</replaceable>-point polygon</entry>
-->
<entry>圆转换成<replaceable class="parameter">npts</replaceable>点多边形</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <!-- 
<entry>path to polygon</entry> 
-->
<entry>路径转换成多边形</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <!--
<para>
     It is possible to access the two component numbers of a <type>point</>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</> is a <type>point</> column then
     <literal>SELECT p[0] FROM t</> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</> changes the Y coordinate.
     In the same way, a value of type <type>box</> or <type>lseg</> can be treated
     as an array of two <type>point</> values.
    </para>
-->
<para>
我们可以把一个<type>point</>的两个组成部分当作索引分别为 0 和 1 的数组元素进行访问。
比如，如果<literal>t.p</>是一个<type>point</>字段，那么<literal>SELECT p[0] FROM t</>
检索 X 座标而<literal>UPDATE t SET p[1] = ...</>改变 Y 座标。同样，
<type>box</>或<type>lseg</>的值可以当作两个<type>point</>的数组值看待。
</para>

    <!--
<para>
     The <function>area</function> function works for the types
     <type>box</type>, <type>circle</type>, and <type>path</type>.
     The <function>area</function> function only works on the
     <type>path</type> data type if the points in the
     <type>path</type> are non-intersecting.  For example, the
     <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>
     will not work;  however, the following visually identical
     <type>path</type>
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
     will work.  If the concept of an intersecting versus
     non-intersecting <type>path</type> is confusing, draw both of the
     above <type>path</type>s side by side on a piece of graph paper.
    </para>
-->
<para>
<function>area</function>函数可以用于<type>box</type>, <type>circle</type>,
 <type>path</type>类型。<function>area</function>函数操作<type>path</type>数据类型的时候，
 只有在<type>path</type>的点没有交叉的情况下才可用。比如，<type>path</type>
 <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>是不行的，
 而下面的视觉等效<type>path</type> <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
就可以。如果交叉和不交叉的<type>path</type>概念让你糊涂，那么把上面两个<type>path</type>
都画在纸上，你就明白了。
</para>

  </sect1>


 <sect1 id="functions-net">
  <!-- 
  <title>Network Address Functions and Operators</title> 
  -->
  <title>网络地址函数和操作符</title>

  <!--
<para>
   <xref linkend="cidr-inet-operators-table"> shows the operators
   available for the <type>cidr</type> and <type>inet</type> types.
   The operators <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>,
   <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal>
   test for subnet inclusion.  They
   consider only the network parts of the two addresses (ignoring any
   host part) and determine whether one network is identical to
   or a subnet of the other.
  </para>
-->
<para>
<xref linkend="cidr-inet-operators-table">显示了可以用于<type>cidr</type>
和<type>inet</type>的操作符。操作符<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>,
 <literal>&gt;&gt;</literal>, <literal>&gt;&gt;=</literal>和<literal>&amp;&amp;</literal>用于测试子网包含：
它们只考虑两个地址的网络部分，忽略任何主机部分，
然后判断其中一个网络是等于另外一个还是另外一个的子网。
</para>

    <table id="cidr-inet-operators-table">
     <!-- 
 <title><type>cidr</type> and <type>inet</type> Operators</title> 
 -->
 <title><type>cidr</type> 和 <type>inet</type> 操作符</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
-->
<entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <!-- 
<entry>is less than</entry> 
-->
<entry>小于</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <!-- 
<entry>is less than or equal</entry> 
-->
<entry>小于或等于</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
        <!-- 
<entry>equals</entry>
-->
<entry>等于</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <!-- 
<entry>is greater or equal</entry> 
-->
<entry>大于或等于</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <!-- 
<entry>is greater than</entry> 
-->
<entry>大于</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <!-- 
<entry>is not equal</entry> 
-->
<entry>不等于</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <!-- 
        <entry>is contained by</entry>
-->
<entry>包含于</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
        <!-- 
        <entry>is contained by or equals</entry>
-->
<entry>包含于或等于</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <!-- 
<entry>contains</entry> 
-->
<entry>包含</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
        <!-- 
<entry>contains or equals</entry> 
-->
<entry>包含或等于</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <!-- 
        <entry>contains or is contained by</entry>
        -->
        <entry>包含或包含于</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
       <entry> <literal>~</literal> </entry>
        <!-- 
<entry>bitwise NOT</entry> 
-->
<entry>位非</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
        <!-- 
<entry>bitwise AND</entry> 
-->
<entry>位与</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
        <!-- 
<entry>bitwise OR</entry> 
-->
<entry>位或</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
        <!-- 
<entry>addition</entry> 
-->
<entry>加</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <!-- 
<entry>subtraction</entry> 
-->
<entry>减</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <!-- 
<entry>subtraction</entry> 
-->
<entry>减</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   <xref linkend="cidr-inet-functions-table"> shows the functions
   available for use with the <type>cidr</type> and <type>inet</type>
   types.  The <function>abbrev</function>, <function>host</function>,
   and <function>text</function>
   functions are primarily intended to offer alternative display
   formats.
  </para>
-->
<para>
<xref linkend="cidr-inet-functions-table">显示了所有可以用于<type>cidr</type>
和<type>inet</type>的函数。函数<function>abbrev</function>, <function>host</function>,
 <function>text</function>主要是为了提供可选的显示格式用的。
</para>

    <table id="cidr-inet-functions-table">
     <!-- 
 <title><type>cidr</type> and <type>inet</type> Functions</title> 
 -->
 <title><type>cidr</type> 和 <type>inet</type> 函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>abbreviated display format as text</entry> 
-->
<entry>缩写显示格式文本</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>abbreviated display format as text</entry> 
-->
<entry>缩写显示格式文本</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <!-- 
<entry>broadcast address for network</entry> 
-->
<entry>网络广播地址</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>extract family of address; <literal>4</literal> for IPv4,
         <literal>6</literal> for IPv6</entry> 
 -->
 <entry>抽取地址族; <literal>4</literal> 为 IPv4,
         <literal>6</literal> 为 IPv6</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>extract IP address as text</entry> 
-->
<entry>将主机地址类型抽出为文本</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <!-- 
<entry>construct host mask for network</entry> 
-->
<entry>为网络构造主机掩码</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>extract netmask length</entry> 
-->
<entry>抽取子网掩码长度</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <!-- 
<entry>construct netmask for network</entry> 
-->
<entry>为网络构造子网掩码</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
        <!-- 
<entry>extract network part of address</entry> 
-->
<entry>抽取地址的网络部分</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <!-- 
<entry>set netmask length for <type>inet</type> value</entry> 
-->
<entry>为<type>inet</type>数值设置子网掩码长度</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
        <!-- 
<entry>set netmask length for <type>cidr</type> value</entry> 
-->
<entry>为<type>cidr</type>数值设置子网掩码长度</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>extract IP address and netmask length as text</entry> 
-->
<entry>把 IP 地址和掩码长度抽取为文本</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   Any <type>cidr</> value can be cast to <type>inet</> implicitly
   or explicitly; therefore, the functions shown above as operating on
   <type>inet</> also work on <type>cidr</> values.  (Where there are
   separate functions for <type>inet</> and <type>cidr</>, it is because
   the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</> value to <type>cidr</>.
   When this is done, any bits to the right of the netmask are silently zeroed
   to create a valid <type>cidr</> value.
   In addition,
   you can cast a text value to <type>inet</> or <type>cidr</>
   using normal casting syntax: for example,
   <literal>inet(<replaceable>expression</>)</literal> or
   <literal><replaceable>colname</>::cidr</literal>.
  </para>
-->
<para>
任何<type>cidr</>值都能够被隐含或明确的转换为<type>inet</>值，
因此上述能够操作<type>inet</>值的函数也同样能够操作<type>cidr</>值。
而将某些操作<type>inet</>和<type>cidr</>的函数单独分隔开是因为它们的行为不同。
<type>inet</>值也可以转换为<type>cidr</>值，
此时子网掩码右侧的所有位都将无声的转换为零以获得一个有效的<type>cidr</>值。
另外，你还可以使用常规的类型转换语法将一个文本字符串转换为<type>inet</>或<type>cidr</>值。
例如：<literal>inet(<replaceable>expression</>)</literal>或<literal><replaceable>colname</>::cidr</literal>。
</para>

  <!--
<para>
   <xref linkend="macaddr-functions-table"> shows the functions
   available for use with the <type>macaddr</type> type.  The function
   <literal><function>trunc(<type>macaddr</type>)</function></literal> returns a MAC
   address with the last 3 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
  </para>
-->
<para>
<xref linkend="macaddr-functions-table">显示了可以用于<type>macaddr</type>类型的函数。
函数<literal><function>trunc(<type>macaddr</type>)</function></literal>返回一个 MAC 地址，
该地址的最后三个字节设置为零。这样可以把剩下的前缀与一个制造商相关联。
</para>

    <table id="macaddr-functions-table">
     <!-- 
 <title><type>macaddr</type> Functions</title> 
 -->
 <title><type>macaddr</type> 函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
        <!-- 
<entry>set last 3 bytes to zero</entry> 
-->
<entry>把后三个字节置为零</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    The <type>macaddr</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    lexicographical ordering, and the bitwise arithmetic operators
    (<literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>)
    for NOT, AND and OR.
   </para>
-->
<para>
<type>macaddr</type>类型还支持标准关系操作符(<literal>&gt;</literal>, <literal>&lt;=</literal>
等)用于词法排序，和按位运算符(<literal>~</literal>, <literal>&amp;</literal> 和
 <literal>|</literal>)非，与和或。
</para>

  </sect1>


 <sect1 id="functions-textsearch">
  <!-- 
  <title>Text Search Functions and Operators</title> 
  -->
  <title>文本检索函数和操作符</title>

   <indexterm zone="datatype-textsearch">
    <!-- 
<primary>full text search</primary>
    <secondary>functions and operators</secondary> 
-->
<primary>全文检索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <!-- 
<primary>text search</primary>
    <secondary>functions and operators</secondary> 
-->
<primary>文本检索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

  <!--
<para>
   <xref linkend="textsearch-operators-table">,
   <xref linkend="textsearch-functions-table"> and
   <xref linkend="textsearch-functions-debug-table">
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
  </para>
-->
<para>
<xref linkend="textsearch-operators-table">，<xref linkend="textsearch-functions-table">
和<xref linkend="textsearch-functions-debug-table">概述了提供全文检索函数和操作符。
详见<xref linkend="textsearch"> <productname>PostgreSQL</productname>文本检索功能的说明。
</para>

    <table id="textsearch-operators-table">
     <!-- 
 <title>Text Search Operators</title> 
 -->
 <title>文本检索操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>操作符</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
        <!-- 
<entry><type>tsvector</> matches <type>tsquery</> ?</entry> 
-->
<entry><type>tsvector</> 匹配 <type>tsquery</> ?</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
        <!-- 
<entry>deprecated synonym for <literal>@@</></entry> 
-->
<entry>弃用的<literal>@@</>的同义词</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <!-- 
<entry>concatenate <type>tsvector</>s</entry> 
-->
<entry>连接<type>tsvector</>s</entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <!-- 
<entry>AND <type>tsquery</>s together</entry> 
-->
<entry><type>tsquery</>与</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
       <!-- 
   <entry>OR <type>tsquery</>s together</entry> 
   -->
    <entry><type>tsquery</>或</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
        <!-- 
<entry>negate a <type>tsquery</></entry> 
-->
<entry><type>tsquery</>非</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <!-- 
<entry><type>tsquery</> contains another ?</entry> 
-->
<entry><type>tsquery</> 包含另一个?</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <!-- 
<entry><type>tsquery</> is contained in ?</entry> 
-->
<entry><type>tsquery</> 包含于 ?</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <!--
<para>
      The <type>tsquery</> containment operators consider only the lexemes
      listed in the two queries, ignoring the combining operators.
     </para>
-->
<para>
<type>tsquery</>的操作符只考虑两个查询列出的项的情况，忽略组合的操作符。
</para>
    </note>

    <!--
<para>
     In addition to the operators shown in the table, the ordinary B-tree
     comparison operators (<literal>=</>, <literal>&lt;</>, etc) are defined
     for types <type>tsvector</> and <type>tsquery</>.  These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
    </para>
-->
<para>
除了显示在表中的操作符，还为类型<type>tsvector</>和<type>tsquery</>
定义了普通的B-tree比较操作符（<literal>=</>, <literal>&lt;</>等）。
它们对于文本检索不是很有用，但是允许使用。例如，建在这些类型列上的唯一索引。
</para>

    <table id="textsearch-functions-table">
     <!-- 
 <title>Text Search Functions</title> 
 -->
 <title>文本检索函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
        <!-- 
<entry>get default text search configuration</entry> 
-->
<entry>获取文本检索的默认配置</entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <!-- 
<entry>number of lexemes in <type>tsvector</></entry> 
-->
<entry><type>tsvector</>的单词数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <!-- 
<entry>number of lexemes plus operators in <type>tsquery</></entry> 
-->
<entry><type>tsquery</>中的单词加上操作符的数量</entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <!-- 
<entry>produce <type>tsquery</> ignoring punctuation</entry> 
-->
<entry>产生<type>tsquery</>忽略标点</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>get indexable part of a <type>tsquery</></entry> 
-->
<entry>获取<type>tsquery</>可索引的部分</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<type>tsvector</>, <type>"char"</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <!-- 
<entry>assign weight to each element of <type>tsvector</></entry> 
-->
<entry>给<type>tsvector</>的每个元素赋予权值</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <!-- 
<entry>remove positions and weights from <type>tsvector</></entry> 
-->
<entry>删除<type>tsvector</>中的位置和权值</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <!-- 
<entry>normalize words and convert to <type>tsquery</></entry> 
-->
<entry>标准化单词并转换为<type>tsquery</></entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">document</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <!-- 
<entry>reduce document text to <type>tsvector</></entry> 
-->
<entry>减少文档中的文本到 <type>tsvector</></entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">options</replaceable> <type>text</> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>display a query match</entry> 
-->
<entry>显示一个查询的匹配项</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <!-- 
<entry>rank document for query</entry> 
-->
<entry>文档查询排名</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <!-- 
<entry>rank document for query using cover density</entry> 
-->
<entry>排序文件查询使用覆盖密度</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">target</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">substitute</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <!-- 
<entry>replace target with substitute within query</entry> 
-->
<entry>替换带有查询的替代目标</entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">select</replaceable> <type>text</>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
        <!-- 
<entry>replace using targets and substitutes from a <command>SELECT</> command</entry> 
-->
<entry>从一条<command>SELECT</>命令的替代目标做替换</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <!-- 
<entry>trigger function for automatic <type>tsvector</> column update</entry> 
-->
<entry>自动更新<type>tsvector</>列的触发器函数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <!-- 
<entry>trigger function for automatic <type>tsvector</> column update</entry> 
-->
<entry>自动更新<type>tsvector</>列的触发器函数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <!--
<para>
    All the text search functions that accept an optional <type>regconfig</>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config">
    when that argument is omitted.
   </para>
-->
<para>
所有的文本检索函数，接受一个选项<type>regconfig</>参数。当这个参数忽略，
使用由<xref linkend="guc-default-text-search-config">指定的配置。
</para>
  </note>

  <!--
<para>
   The functions in
   <xref linkend="textsearch-functions-debug-table">
   are listed separately because they are not usually used in everyday text
   searching operations.  They are helpful for development and debugging
   of new text search configurations.
  </para>
-->
<para>
<xref linkend="textsearch-functions-debug-table">单独列出的函数，
因为他们通常不用于每天的文本检索操作。它们有助于开发调试新文本检索配置。
</para>

    <table id="textsearch-functions-debug-table">
     <!-- 
 <title>Text Search Debugging Functions</title> 
 -->
 <title>文本检索调试函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>, OUT <replaceable class="PARAMETER">token</> <type>text</>, OUT <replaceable class="PARAMETER">dictionaries</> <type>regdictionary[]</>, OUT <replaceable class="PARAMETER">dictionary</> <type>regdictionary</>, OUT <replaceable class="PARAMETER">lexemes</> <type>text[]</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>test a configuration</entry> 
-->
<entry>测试一个配置</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="PARAMETER">dict</replaceable> <type>regdictionary</>, <replaceable class="PARAMETER">token</replaceable> <type>text</>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
        <!-- 
<entry>test a dictionary</entry> 
-->
<entry>测试一个数据字典</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="PARAMETER">parser_name</replaceable> <type>text</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>test a parser</entry> 
-->
<entry>测试一个解析</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="PARAMETER">parser_oid</replaceable> <type>oid</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>test a parser</entry> 
-->
<entry>测试一个解析</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="PARAMETER">parser_name</> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>get token types defined by parser</entry> 
-->
<entry>由解析器获取分词类型的定义</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="PARAMETER">parser_oid</> <type>oid</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>get token types defined by parser</entry> 
-->
<entry>由解析器获取分词类型的定义</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="PARAMETER">sqlquery</replaceable> <type>text</>, <optional> <replaceable class="PARAMETER">weights</replaceable> <type>text</>, </optional> OUT <replaceable class="PARAMETER">word</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">ndoc</replaceable> <type>integer</>, OUT <replaceable class="PARAMETER">nentry</replaceable> <type>integer</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <!-- 
<entry>get statistics of a <type>tsvector</> column</entry> 
-->
<entry>获取<type>tsvector</>列的统计数据</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">
  <!-- 
  <title>XML Functions</title>
  -->
  <title>XML 函数</title>

  <!--
<para>
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  Check <xref
   linkend="datatype-xml"> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are not repeated here.  Use of most of these
   functions requires the installation to have been built
   with <command>configure &#045;-with-libxml</>.
  </para>
-->
<para>
在本节描述的函数和像函数的表达式操作都是基于<type>xml</type>类型的值。
查看<xref linkend="datatype-xml">获取关于<type>xml</type>类型的信息。
像函数表达式的<function>xmlparse</function>和<function>xmlserialize</function>
用来转换为和从类型<type>xml</type>转换，不在这里重复。
使用这些函数需要安装与配置了<command>configure --with-libxml</>。
</para>

  <sect2 id="functions-producing-xml">
   <!-- 
   <title>Producing XML Content</title> 
   -->
   <title>生成XML内容</title>

   <!--
<para>
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
   </para>
-->
<para>
一组函数和像函数的表达式可用于从SQL数据生成XML内容。
所以它们特别适合于查询结果格式化成在客户端应用程序处理的XML文件。
</para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <!--
<para>
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;-</literal></quote> or end with a
     <quote><literal>-</literal></quote> so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
    </para>
-->
<para>
<function>xmlcomment</function>函数创建一个包含XML注释的特定文本内容的值。
文本中不能包含<quote><literal>--</literal></quote>或以<quote><literal>-</literal></quote>
的结束，这样的文本是有效的XML注释。如果参数是空，结果是空。
</para>

   
<para>
 <!--
     Example:
-->
例子：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>

   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <!--
<para>
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
    </para>
-->
<para>
函数<function>xmlconcat</function>连接一个独立的XML值列表来创建一个包含XML内容片段的单值。
忽略空值；只有当参数都为空时结果是空。
</para>
    
<para>
<!--
     Example:
-->
例子：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>


    <!--
<para>
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
    </para>
-->
<para>
XML声明，如果存在，结合如下。如果所有参数使用相同的XML版本声明，则在结果中使用版本。
否则不用版本。如果所有的参数值有独立的声明值<quote>yes</quote>，
然后这个值在结果里使用。如果所有的参数值有独立的声明，并且至少有一个是<quote>no</quote>，
然后这个值在结果里使用。否则结果将没有独立声明。如果结果决定需要一个独立的声明，
但没有声明版本，将使用一个带有版本1.0的版本声明，因为XML需要一个XML声明包含版本声明。
忽略并且在所有情况下删除编码声明。
</para>

   
<para>
 <!--
     Example:
-->
例子：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>

   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <!--
<para>
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
    </para>
-->
<para>
<function>xmlelement</function>表达式生成一个带有给定名称，属性和内容的XML元素。
</para>
  
<para>
<!--
     Examples:
-->
例子：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    
<para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
不是有效的XML元素和属性名的名称由序列<literal>_x<replaceable>HHHH</replaceable>_</literal>
替换有问题的字符转义，这里的<replaceable>HHHH</replaceable>
是字符的16进制形式的Unicode代码点。例如：
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>
    
<para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
如果属性值是一个列引用则不用指定明确的属性名称，在这种情况下，列的名称将默认为属性名。
在其它情况下，属性必须给予一个明确的名称。因此，这个例子是有效的：
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     <!-- 
 But these are not: 
 -->
 但是这些不是: 
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    
<para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
如果指定了元素内容，将根据它的数据类型格式化。如果内容自身是<type>xml</type>类型，
可以构造复杂的xml文档。例如：
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>
<!-- 
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary">.  The particular behavior for
     individual data types is expected to evolve in order to align the
     SQL and PostgreSQL data types with the XML Schema specification,
     at which point a more precise description will appear.
-->
将其它类型的内容格式化为有效的xml字符串数据。这意味着特殊的字符&lt;, &gt;,
和&amp;将转化为实体。二进制数据（<type>bytea</type>数据类型）
将用base64或16进制编码表示，取决于配置参数<xref linkend="guc-xmlbinary">的设置。
单个数据类型的特定行为预计将发展为了使SQL和PostgreSQL数据类型和XML架构规范一致，
到时将出现更准确描述。
    </para>

   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <!--
<para>
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
    </para>
-->
<para>
<function>xmlforest</function>表达式生成一个使用指定的名称和内容的XML 森林（序列）元素。 
</para>

    
<para>
<!--
     Examples:
-->
示例:
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>
<!-- 
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
在第二个例子可以看出，如果内容值为列引用，元素名称可以省略。在这种情况下，
默认使用列名。否则，必须指定名称。
    </para>


    <!--
<para>
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
    </para>
-->
<para>
非法XML名的元素名称，像上面的<function>xmlelement</function>转义处理。
类似的，内容数据转义生成有效的XML内容， 除非它已经是<type>xml</type>类型的。
</para>

    <!--
<para>
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
    </para>
-->
<para>
请注意，如果包含一个以上的元素，XML的森林不是有效的XML文档，
所以在<function>xmlelement</function>里面封装<function>xmlforest</function>表达式可能是有用的。
</para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <!--
<para>
     The <function>xmlpi</function> expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence <literal>?&gt;</literal>.
    </para>
-->
<para>
<function>xmlpi</function>表达式创建一条XML处理指令。
如果存在，内容必须不能包含字符序列<literal>?&gt;</literal>。
</para>
    
<para>
<!--
     Example:
-->
示例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>

   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <!--
<para>
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
    </para>
-->
<para>
<function>xmlroot</function>更改XML值的根节点属性。如果指定一个版本，
它替换根节点的版本声明值;如果指定一个standalone设置，它替换根节点的standalone声明值。
</para>


<para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>

   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <!--
<para>
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"> for additional information
     about aggregate functions.
    </para>
-->
<para>
不像这里描述的其它函数，函数<function>xmlagg</function>是一个聚合函数。
它连接聚合函数调用的输入值，很像<function>xmlconcat</function>，
除了连接发生在多行而不是发生在多个单行的表达式。
请参阅<xref linkend="functions-aggregate">获取关于聚合函数的更多信息。
</para>
    
<para>
<!--
     Example:
-->
示例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>
    
<para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates">. For example:
-->
为了确定连接顺序，要添加一个<literal>ORDER BY</>子句到聚合调用，
描述在<xref linkend="syntax-aggregates">。示例：
<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   
<para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
建议在之前的版本中使用下面非标准的方法，在特例中可能仍然有用:
<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
    <title>XML Predicates</title>

    <!--
<para>
     The expressions described in this section check properties
     of <type>xml</type> values.
    </para>
-->
<para>
这节描述的表达式检查<type>xml</type>值的属性。
</para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <!--
<para>
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"> about the difference
     between documents and content fragments.
    </para>
-->
<para>
如果参数XML值是一个合法的XML文档，表达式<literal>IS DOCUMENT</literal>返回真。
否则返回假（例如，内容片段）或如果参数为空则返回空。请参阅<xref linkend="datatype-xml">
获取关于文档和内容片段之间的不同。
</para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY REF</optional> <replaceable>xml</replaceable> <optional>BY REF</optional>)
</synopsis>

    <!--
<para>
     The function <function>xmlexists</function> returns true if the
     XPath expression in the first argument returns any nodes, and
     false otherwise.  (If either argument is null, the result is
     null.)
    </para>
-->
<para>
如果第一个参数中的XPath表达式返回任何节点，那么函数<function>xmlexists</function>返回真，
否则返回假。（如果其他参数是null，结果是null。）
</para>
 
<para>
 <!--
     Example:
-->
示例：
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <!--
<para>
     The <literal>BY REF</literal> clauses have no effect in
     PostgreSQL, but are allowed for SQL conformance and compatibility
     with other implementations.  Per SQL standard, the
     first <literal>BY REF</literal> is required, the second is
     optional.  Also note that the SQL standard specifies
     the <function>xmlexists</function> construct to take an XQuery
     expression as first argument, but PostgreSQL currently only
     supports XPath, which is a subset of XQuery.
    </para>
-->
<para>
在PostgreSQL中，<literal>BY REF</literal>子句没有影响，
但是为了与SQL的一致性和其他实现的兼容性是允许的。SQL标准中，
第一个<literal>BY REF</literal>是必须的，第二个<literal>BY REF</literal>是可选的。
也请注意，SQL标准声明<function>xmlexists</function>构造接受XQuery表达式作为第一个参数，
但是PostgreSQL目前只接受XQuery的一个子集XPath。
</para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <!--
<para>
     These functions check whether a <type>text</> string is well-formed XML,
     returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"> configuration
     parameter is set to <literal>DOCUMENT</>, or the latter if it is set to
     <literal>CONTENT</>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</> will succeed.
    </para>
-->
<para>
这些函数检查<type>text</>字符串是不是格式良好的XML，返回布尔结果。
<function>xml_is_well_formed_document</function>检查格式良好的文档，
<function>xml_is_well_formed_content</function>检查格式良好的内容。
<function>xml_is_well_formed</function>如果<xref linkend="guc-xmloption">参数设置为
<literal>DOCUMENT</>则检查文档，如果设置为<literal>CONTENT</>则检查内容。
这意味着<function>xml_is_well_formed</function>有助于看到一个简单到类型<type>xml</>
的转换是否会成功，而另外两个函数有助于看到相应的<function>XMLPARSE</>变体是否会成功。
</para>
    
<para>
<!--
     Examples:
-->
示例：
<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>
<!-- 
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最后一个示例显示了检查包括命名空间是否正确匹配。
    </para>

   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
   <!-- 
   <title>Processing XML</title> 
   -->
   <title>处理XML</title>

   <indexterm>
    <primary>XPath</primary>
   </indexterm>

   <!--
<para>
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions.
   </para>
-->
<para>
PostgreSQL提供了<function>xpath</function>和<function>xpath_exists</function>
函数处理<type>xml</type>数据类型的值，计算XPath 1.0表达式的结果。
</para>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <!--
<para>
    The function <function>xpath</function> evaluates the XPath
    expression <replaceable>xpath</replaceable> (a <type>text</> value)
    against the XML value
    <replaceable>xml</replaceable>.  It returns an array of XML values
    corresponding to the node set produced by the XPath expression.
    If the XPath expression returns a scalar value rather than a node set,
    a single-element array is returned.
   </para>
-->
<para>
<function>xpath</function>函数，对XML值<replaceable>xml</replaceable>
计算XPath表达式<replaceable>xpath</replaceable>（<type>text</>值）的结果。
它返回一个XML值的数组对应XPath表达式所产生的节点集。
如果XPath表达式返回一个标量值而不是节点集，那么返回一个单个元素的数组。
</para>

  <!--
<para>
    The second argument must be a well formed XML document. In particular,
    it must have a single root node element.
  </para>
-->
<para>
第二个参数必须是一个完整的XML文档。特别是，它必须有一个根节点元素。
</para>

   <!--
<para>
    The optional third argument of the function is an array of namespace
    mappings.  This array should be a two-dimensional <type>text</> array with
    the length of the second axis being equal to 2 (i.e., it should be an
    array of arrays, each of which consists of exactly 2 elements).
    The first element of each array entry is the namespace name (alias), the
    second the namespace URI. It is not required that aliases provided in
    this array be the same as those being used in the XML document itself (in
    other words, both in the XML document and in the <function>xpath</function>
    function context, aliases are <emphasis>local</>).
   </para>
-->
<para>
该函数的第三个参数是一个命名空间的数组映射。这个数组应该是一个两维<type>text</>数组，
第二个维的长度等于2（它应该是一个数组的数组，其中每个正好包含2个元素）。
每个数组项的第一个元素是命名空间名称的别名，第二个元素是命名空间 URI。
这个数组的别名不是必须提供的，与在XML文档本身使用的相同。（换句话说，
在XML文档和在<function>xpath</function>函数的上下文中，别名是<emphasis>local</>）。
</para>
   
<para>
<!--
    Example:
-->
示例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
   </para>
   
<para>
<!--
    To deal with default (anonymous) namespaces, do something like this:
-->
处理默认的命名空间，像下面这样做：
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
   </para>

   <indexterm>
    <primary>xpath_exists</primary>
   </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <!--
<para>
    The function <function>xpath_exists</function> is a specialized form
    of the <function>xpath</function> function.  Instead of returning the
    individual XML values that satisfy the XPath, this function returns a
    Boolean indicating whether the query was satisfied or not.  This
    function is equivalent to the standard <literal>XMLEXISTS</> predicate,
    except that it also offers support for a namespace mapping argument.
   </para>
-->
<para>
<function>xpath_exists</function>函数是<function>xpath</function>函数的一种特殊化形式。
这个函数返回一个布尔值表明是否满足这个查询，而不是返回满足XPath的单个XML值。
这个函数相当于标准的<literal>XMLEXISTS</>，除了它还对命名空间映射参数提供支持。
</para>
   
<para>
<!--
    Example:
-->
示例：
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
   </para>

  </sect2>

  <sect2 id="functions-xml-mapping">
   <!-- 
   <title>Mapping Tables to XML</title> 
   -->
   <title>到XML的映射表</title>

   <indexterm zone="functions-xml-mapping">
    <!-- 
<primary>XML export</primary> 
-->
<primary>XML 导出</primary>
   </indexterm>

   
<para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
下面的函数映射关系表的内容到XML值。可以将它们认为XML导出功能：
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
    <!-- 
The return type of each function is <type>xml</type>. 
-->
每个函数的返回类型是<type>xml</type>。
   </para>


   <!--
<para>
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>tbl</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
   </para>
-->
<para>
<function>table_to_xml</function>映射命名表的内容，作为参数<parameter>tbl</parameter>传递。
<type>regclass</type>类型接受使用常用符号的字符串标识表，包括可选的模式资格和双引号。
<function>query_to_xml</function>执行查询，这个查询的文本作为<parameter>query</parameter>
参数传递，并映射结果集。<function>cursor_to_xml</function>从参数<parameter>cursor</parameter>
指定的游标中获取指定数量的行。如果大数据表需要映射，建议使用这个变体，
因为结果值是通过每个函数在内存中构建的。
</para>
   
<para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
如果<parameter>tableforest</parameter>是假值，则结果的XML文档像这样：
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>
<!-- 
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
如果<parameter>tableforest</parameter>是真值，结果是一个像这样的XML内容片段：
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>
<!-- 
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
如果没有可用的表名，也就是当映射一个查询或游标时，
第一个格式用字符串<literal>table</literal>，第二个格式用<literal>row</literal>。
   </para>

   <!--
<para>
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
   </para>
-->
<para>
这些格式是给用户选择使用的。第一种格式是适当的XML文档，在许多应用程序中比较重要。
如果结果值是稍后重新组合成一个文件，则第二种格式在<function>cursor_to_xml</function>
函数中更有用。这些函数用来产生上述讨论的XML内容，特别是<function>xmlelement</function>，
可以用来尝试更改结果。
</para>

   <!--
<para>
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
   </para>
-->
<para>
数据值以上面描述的函数<function>xmlelement</function>相同的方式映射。
</para>

   
<para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
参数<parameter>nulls</parameter>取决于在输出中是否包含空值。如果真，列中的空值表示为：
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
   <!-- 
   where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output. 
-->
这里的<literal>xsi</literal>是XML架构实例的XML命名空间前缀。
将为结果值添加一个适当的命名空间声明。如果假，包含空值的列会从输出中简单的省略。
   </para>

   <!--
<para>
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
   </para>
-->
<para>
参数的<parameter>targetns</parameter>指定想要结果的XML命名空间。
如果没有特别想要的命名空间，应传递一个空字符串。
</para>
   
<para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
下面的函数返回描述由上述相应的函数执行映射的 XML 架构文档:
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!-- 
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents. 
-->
重要的是要传递相同的参数以获取匹配的XML数据映射和XML架构文档。
   </para>
   
<para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
下列函数在一个文档（或森林）中生成XML数据映射和相应的XML架构，
联系在一起。它们在想要自我包含和自我描述结果的时候可能很有用：
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>
   
<para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
此外，下列函数还可用于生成类似整个模式或整个当前数据库的映射：
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!-- 
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
请注意这些可能产生大量的数据，是需要在内存中建立的。
当请求大数据量的模式或数据库的内容映射时，可能值得考虑映射表分别替代，可能甚至通过游标。
   </para>
  
<para>
 <!--
    The result of a schema content mapping looks like this:
-->
一个模式内容映射的结果像这样：
<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!-- 
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above. 
-->
其中一个表映射的格式取决于上面所述的<parameter>tableforest</parameter>参数。
   </para>

   
<para>
<!--
    The result of a database content mapping looks like this:
-->
一个数据库内容映射的结果像这样：
<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!-- 
    where the schema mapping is as above. 
-->
模式映射如上所述。
   </para>

   <!--
<para>
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
   </para>
-->
<para>
使用这些函数产生的输出作为例子，<xref linkend="xslt-xml-html">显示一个XSLT样式表转换
<function>table_to_xml_and_xmlschema</function>的输出到HTML文档，
该文档中包含了一个表数据的表格格式副本。以类似的方式，
这些函数的结果可以转换成其它基于XML的格式。
</para>

   <figure id="xslt-xml-html">
    <!-- 
<title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title> 
-->
<title> XSLT样式表--将SQL/XML输出转换成HTML</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
  <!-- 
  <title>JSON Functions and Operators</title> 
  -->
  <title>JSON 函数和操作符</title>

  <indexterm zone="functions-json">
    <primary>JSON</primary>
    <!-- 
    <secondary>functions and operators</secondary>
-->
<secondary>函数和操作符</secondary>
  </indexterm>

   <!--
<para>
   <xref linkend="functions-json-op-table"> shows the operators that
   are available for use with the two JSON data types (see <xref
   linkend="datatype-json">).
   </para>
-->
<para>
<xref linkend="functions-json-op-table">显示了可以用于这两个JSON
（参阅<xref linkend="datatype-json">）数据类型的操作符。
</para>

  <table id="functions-json-op-table">
     <!-- 
     <title><type>json</> and <type>jsonb</> Operators</title>
 -->
 <title><type>json</>和<type>jsonb</>操作符</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Description</entry>
        <entry>Example</entry> 
        <entry>Example Result</entry>
        -->
<entry>操作符</entry>
        <entry>右操作数的类型</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>示例结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>int</type></entry>
        <!-- 
        <entry>Get JSON array element (indexed from zero)</entry>
-->
<entry>获取JSON数组元素（索引从0开始）</entry>
        <entry><literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</literal></entry>
        <entry><literal>{"c":"baz"}</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
        <entry>Get JSON object field by key</entry>
-->
<entry>通过秘钥获取JSON对象字段</entry>
        <entry><literal>'{"a": {"b":"foo"}}'::json-&gt;'a'</literal></entry>
        <entry><literal>{"b":"foo"}</literal></entry>
       </row>
        <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>int</type></entry>
        <!-- 
        <entry>Get JSON array element as <type>text</></entry>
-->
<entry>获取JSON数组元素为<type>text</></entry>
        <entry><literal>'[1,2,3]'::json-&gt;&gt;2</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
        <entry>Get JSON object field as <type>text</></entry>
-->
<entry>获取JSON对象字段为<type>text</></entry>
        <entry><literal>'{"a":1,"b":2}'::json-&gt;&gt;'b'</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <!-- 
<entry>Get JSON object at specified path</entry> 
-->
<entry>在指定的路径获取JSON对象</entry>
        <entry><literal>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</literal></entry>
        <entry><literal>{"c": "foo"}</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <!-- 
        <entry>Get JSON object at specified path as <type>text</></entry>
-->
<entry>在指定的路径获取JSON对象为<type>text</></entry>
        <entry><literal>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
<!-- 
   <para>   
    There are parallel variants of these operators for both the
    <type>json</type> and <type>jsonb</type> types.
    The field/element/path extraction operators
    return the same type as their left-hand input (either <type>json</type>
    or <type>jsonb</type>), except for those specified as
    returning <type>text</>, which coerce the value to text.
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such element exists.
   </para>
-->
<para>   
有<type>json</type>和<type>jsonb</type>类型的这些操作符的并行变体。
字段/元素/路径提取操作符返回和它们的左侧输入相同的类型
（不管是<type>json</type>还是<type>jsonb</type>），
除了那些指定返回<type>text</>类型的操作符，它们强制值为文本类型。
如果JSON输入的结构没有正确匹配要求，那么字段/元素/路径提取操作符返回NULL，
而不是失败；例如，如果不存在这样的元素。
</para>  
  </note>   
<!-- 
  <para>   
   The standard comparison operators shown in  <xref
   linkend="functions-comparison-table"> are available for
   <type>jsonb</type>, but not for <type>json</type>. They follow the
   ordering rules for B-tree operations outlined at <xref
   linkend="json-indexing">.
  </para>
--> 
<para>   
<xref linkend="functions-comparison-table">
中显示的标准比较操作符可以用于<type>jsonb</type>，
但是不能用于<type>json</type>。
它们遵循<xref linkend="json-indexing">
中概述的B-tree操作符排序规则。
</para>  
   
<!-- 
  <para>
   Some further operators also exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table">.
   Many of these operators can be indexed by
   <type>jsonb</> operator classes.  For a full description of
   <type>jsonb</> containment and existence semantics, see <xref
   linkend="json-containment">.  <xref linkend="json-indexing">
   describes how these operators can be used to effectively index
   <type>jsonb</> data.
  </para>
-->
<para>
一些更深一步的操作符只为<type>jsonb</type>存在，在
<xref linkend="functions-jsonb-op-table">中显示。
许多这样的操作符可以用<type>jsonb</>操作符类索引。
<type>jsonb</>容器和存在语义的详细描述，请查看
<xref linkend="json-containment">。<xref linkend="json-indexing">
描述了这些操作符如何用于有效的索引<type>jsonb</>数据。
</para>
  <table id="functions-jsonb-op-table">
     <!--
     <title>Additional <type>jsonb</> Operators</title>
     -->
     <title>额外的 <type>jsonb</> 操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
        <entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        -->
        <entry>操作符</entry>
        <entry>右操作数的类型</entry>
        <entry>描述</entry>
        <entry>示例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>@&gt;</literal></entry>
        <entry><type>jsonb</type></entry>
        <!--
        <entry>Does the left JSON value contain within it the right value?</entry>
        -->
        <entry>左侧的JSON值包含右侧的值吗？</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;@</literal></entry>
        <entry><type>jsonb</type></entry>
        <!--
        <entry>Is the left JSON value contained within the right value?</entry>
        -->
        <entry>左侧的JSON值包含在右侧的值中吗？</entry>
        <entry><literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>?</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
        <entry>Does the key/element <emphasis>string</emphasis> exist within
        the JSON value?</entry>
        -->
        <entry>键/元素<emphasis>字符串</emphasis> 包含JSON值吗？</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal></entry>
       </row>
       <row>
        <entry><literal>?|</literal></entry>
        <entry><type>text[]</type></entry>
        <!--
        <entry>Do any of these key/element <emphasis>strings</emphasis> exist?</entry>
        -->
        <entry>是否存在任一键/元素<emphasis>字符串</emphasis>？</entry>
        <entry><literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</literal></entry>
       </row>
       <row>
        <entry><literal>?&amp;</literal></entry>
        <entry><type>text[]</type></entry>
        <!--
        <entry>Do all of these key/element <emphasis>strings</emphasis> exist?</entry>
        -->
        <entry>是否所有键/元素<emphasis>字符串</emphasis>都存在？</entry>
        <entry><literal>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>
   
  <!--
<para>
   <xref linkend="functions-json-creation-table"> shows the functions that are
   available for creating <type>json</type> values.
   (Currently, there are no equivalent functions for <type>jsonb</>, but you
   can cast the result of one of these functions to <type>jsonb</>.)
  </para>
-->
<para>
<xref linkend="functions-json-creation-table">显示了可以用于创建<type>json</type>
值的函数。（目前，对于<type>jsonb</>来说没有等效的函数，
但是你可以转换这些函数的结果到<type>jsonb</>。）
</para>

  <indexterm>
   <primary>to_json</primary>
  </indexterm>
  <indexterm>
   <primary>array_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>row_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>json_object</primary>
  </indexterm>
  <table id="functions-json-creation-table">
    <!-- 
    <title>JSON Creation Functions</title>
-->
<title>JSON 创建函数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <!-- 
   <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry> 
   -->
   <entry>函数</entry>
       <entry>描述</entry>
       <entry>示例</entry>
       <entry>示例结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <literal>to_json(anyelement)</literal>
       </entry>
       <!-- 
   <entry>
         Returns the value as JSON.  Arrays and composites are converted
         (recursively) to arrays and objects; otherwise, if there is a cast
         from the type to <type>json</type>, the cast function will be used to
         perform the conversion; otherwise, a JSON scalar value is produced.
         For any scalar type other than a number, a Boolean, or a null value,
         the text representation will be used, properly quoted and escaped
         so that it is a valid JSON string.
       </entry> 
   -->
<entry>
作为JSON返回该值。数组和复合被转换（递归的）成数组和对象；另外，
如果有一个转换从该类型到<type>json</type>，则将使用该转换函数执行转换；
否则，产生JSON标量值。对于任意标量类型，除了数字、布尔或空值，
将使用该文本表示，适当的引用和逃逸，使其是一个有效的JSON字符串。
</entry> 
       <entry><literal>to_json('Fred said "Hi."'::text)</literal></entry>
       <entry><literal>"Fred said \"Hi.\""</literal></entry>
      </row>
      <row>
       <entry>
         <literal>array_to_json(anyarray [, pretty_bool])</literal>
       </entry>
       <!-- 
       <entry>
         Returns the array as a JSON array. A PostgreSQL multidimensional array
         becomes a JSON array of arrays. Line feeds will be added between
         dimension-1 elements if <parameter>pretty_bool</parameter> is true.
       </entry>
       -->
<entry>
作为JSON数组返回该数组。PostgreSQL多维数组变成JSON数组中的数组。
如果<parameter>pretty_bool</parameter>为真，
则在维度-1元素之间添加换行。
</entry>
       <entry><literal>array_to_json('{{1,5},{99,100}}'::int[])</literal></entry>
       <entry><literal>[[1,5],[99,100]]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>row_to_json(record [, pretty_bool])</literal>
       </entry>
       <!-- 
   <entry>
         Returns the row as a JSON object. Line feeds will be added between
         level-1 elements if <parameter>pretty_bool</parameter> is true.
       </entry> 
   -->
<entry>
作为JSON对象返回行。如果<parameter>pretty_bool</parameter>为 true，
将在级别-1元素之间添加换行符。
</entry>
       <entry><literal>row_to_json(row(1,'foo'))</literal></entry>
       <entry><literal>{"f1":1,"f2":"foo"}</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_build_array(VARIADIC "any")</literal>
       </entry>
       <!-- 
   <entry>
         Builds a possibly-heterogeneously-typed JSON array out of a variadic
         argument list.
       </entry> 
   -->
   <entry>
建立一个可能不同类型的JSON数组，由可变参数列表组成。
       </entry>
       <entry><literal>json_build_array(1,2,'3',4,5)</literal></entry>
       <entry><literal>[1, 2, "3", 4, 5]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_build_object(VARIADIC "any")</literal>
       </entry>
       <!-- 
       <entry>
         Builds a JSON object out of a variadic argument list.  By
         convention, the argument list consists of alternating
         keys and values.
       </entry>
       -->
       <entry>
         建立一个JSON对象的可变参数列表。按照惯例，
         该参数列表由交替的键和值组成。
       </entry>
       <entry><literal>json_build_object('foo',1,'bar',2)</literal></entry>
       <entry><literal>{"foo": 1, "bar": 2}</literal></entry>
      </row>       
      <row>
       <entry>
         <literal>json_object(text[])</literal>
       </entry>
       <!-- 
       <entry>
         Builds a JSON object out of a text array.  The array must have either
         exactly one dimension with an even number of members, in which case
         they are taken as alternating key/value pairs, or two dimensions
         such that each inner array has exactly two elements, which
         are taken as a key/value pair.
       </entry>
       -->
       <entry>
         建立一个JSON对象的文本数组。该数组必须正好有一维偶数个数的成员，
         在这种情况下，将它们看做交替的键/值对，或者两维，
         这样每个内部数组正好有两个元素，它们被看做是键/值对。
       </entry>
       <entry><para><literal>json_object('{a, 1, b, "def", c, 3.5}')</></para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</></para></entry>
       <entry><literal>{"a": "1", "b": "def", "c": "3.5"}</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_object(keys text[], values text[])</literal>
       </entry>
       <!-- 
       <entry>
         This form of <function>json_object</> takes keys and values pairwise from two separate
         arrays. In all other respects it is identical to the one-argument form.
       </entry>
       -->
       <entry>
         这种形式的<function>json_object</>从两个分开的数组中成对的获取键和值。
         在所有其他方面，它与一维的形式相同。
       </entry>
       <entry><literal>json_object('{a, b}', '{1,2}')</literal></entry>
       <entry><literal>{"a": "1", "b": "2"}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>       
       
  <note>
<!-- 
    <para>
     <function>array_to_json</> and <function>row_to_json</> have the same
     behavior as <function>to_json</> except for offering a pretty-printing
     option.  The behavior described for <function>to_json</> likewise applies
     to each individual value converted by the other JSON creation functions.
    </para>
-->
<para>
<function>array_to_json</>和<function>row_to_json</>的行为与
<function>to_json</>相同，除了提供了一个整齐打印的选项。
描述的<function>to_json</>的行为也应用到每个由其他JSON创建函数转换的单独的值。
</para>
  </note>       
       
  <note>
<!-- 
    <para>
     The <xref linkend="hstore"> extension has a cast
     from <type>hstore</type> to <type>json</type>, so that
     <type>hstore</type> values converted via the JSON creation functions
     will be represented as JSON objects, not as primitive string values.
    </para>
-->
<para>
<xref linkend="hstore">扩展从<type>hstore</type>转换到<type>json</type>，
所以通过JSON创建函数转换的<type>hstore</type>值将表示为JSON对象，
而不是作为原始的字符串值。
</para>
  </note>       

<!-- 
  <para>
   <xref linkend="functions-json-processing-table"> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
  </para>
-->
<para>
<xref linkend="functions-json-processing-table">显示了可以用于处理
<type>json</type>和<type>jsonb</type>值的函数。
</para>
  
  <indexterm>
   <primary>json_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>json_each</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each</primary>
  </indexterm>
  <indexterm>
   <primary>json_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_recordset</primary>
  </indexterm>
  <table id="functions-json-processing-table">
    <!-- 
    <title>JSON Processing Functions</title>
    -->
    <title>JSON 处理函数</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
       -->
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>示例</entry>
       <entry>示例结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>json_array_length(json)</literal>
         </para><para><literal>jsonb_array_length(jsonb)</literal>
       </para></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>
         Returns the number of elements in the outermost JSON array.
       </entry>
   -->
   <entry>
         返回最外层的JSON数组元素的数量。
       </entry>
       <entry><literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_each(json)</literal>
         </para><para><literal>jsonb_each(jsonb)</literal>
       </para></entry>
       <entry><para><literal>setof key text, value json</literal>
         </para><para><literal>setof key text, value jsonb</literal>
       </para></entry>       
       <!-- 
   <entry>
         Expands the outermost JSON object into a set of key/value pairs.
       </entry> 
   -->
   <entry>
        扩展最外层的JSON对象为一组键/值对。
       </entry>
       <entry><literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_each_text(json)</literal>
         </para><para><literal>jsonb_each_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof key text, value text</type></entry>
       <!-- 
   <entry>
         Expands the outermost JSON object into a set of key/value pairs. The
         returned values will be of type <type>text</>.
       </entry> 
   -->
   <entry>
        扩展最外层的JSON对象为一组键/值对。返回值为<type>text</>类型。
       </entry>
       <entry><literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path(from_json json, VARIADIC path_elems text[])</literal>
        </para><para><literal>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type>
       </para></entry> 
       <!-- 
   <entry>
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         (equivalent to <literal>#&gt;</literal> operator).
       </entry> 
   -->
   <entry>
        返回由<parameter>path_elems</parameter>指出的JSON对象
        （等效于<literal>#&gt;</literal>操作符）。
       </entry>
       <entry><literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</literal></entry>
       <entry><literal>{"f5":99,"f6":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path_text(from_json json, VARIADIC path_elems text[])</literal>
         </para><para><literal>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         as <type>text</>
         (equivalent to <literal>#&gt;&gt;</literal> operator).
         </entry> 
   -->
   <entry>
        作为<type>text</>返回由<replaceable>path_elems</replaceable>
        指出的JSON值（等效于<literal>#&gt;&gt;</literal>操作符）。
       </entry>
       <entry><literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</literal></entry>
       <entry><literal>foo</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object_keys(json)</literal>
         </para><para><literal>jsonb_object_keys(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <!-- 
   <entry>
          Returns set of keys in the outermost JSON object.
       </entry> 
   -->
   <entry>
          返回JSON对象中最外面的一组键。
       </entry>
       <entry><literal>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal></entry>
       <entry>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </entry>
      </row>
      <row>
       <entry>
       <entry><para><literal>json_populate_record(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_record(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>anyelement</type></entry>
       <!-- 
   <entry>
         Expands the object in <replaceable>from_json</replaceable> to a row
         whose columns match the record type defined by <replaceable>base</>
         (see note below).
       </entry> 
   -->
   <entry>
扩展<replaceable>from_json</replaceable>里的对象到一行，
 这行的字段匹配<replaceable>base</>定义的记录类型（查看下面的注意）。
       </entry>
       <entry><literal>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_recordset(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_recordset(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>setof anyelement</type></entry>
       <!-- 
   <entry>
         Expands the outermost array of objects
         in <replaceable>from_json</replaceable> to a set of rows whose
         columns match the record type defined by <replaceable>base</> (see
         note below).
       </entry> 
   -->
   <entry>
         扩展<replaceable>from_json</replaceable>里面最外层的对象数组到一个行的集合，
 这个集合的字段匹配<replaceable>base</>定义的记录类型（见下面的注意）。
       </entry>
       <entry><literal>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
 </programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements(json)</literal>
         </para><para><literal>jsonb_array_elements(jsonb)</literal>
       </para></entry>
       <entry><para><type>setof json</type>
         </para><para><type>setof jsonb</type>
       </para></entry>
      <!-- 
   <entry>
         Expands a JSON array to a set of JSON values.
       </entry> 
   -->
   <entry>
         扩展一个JSON数组到一组JSON值的集合。
       </entry>
       <entry><literal>select * from json_array_elements('[1,true, [2,false]]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements_text(json)</literal>
         </para><para><literal>jsonb_array_elements_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <!-- 
       <entry>      
         Expands a JSON array to a set of <type>text</> values.
       </entry>
       -->
       <entry>      
        扩展一个JSON数组到一组<type>text</>值的集合。
       </entry>
       <entry><literal>select * from json_array_elements_text('["foo", "bar"]')</literal></entry>
       <entry>      
<programlisting>      
   value
-----------
 foo
 bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_typeof(json)</literal>
         </para><para><literal>jsonb_typeof(jsonb)</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <!-- 
       <entry>
         Returns the type of the outermost JSON value as a text string.
         Possible types are
         <literal>object</>, <literal>array</>, <literal>string</>, <literal>number</>,
         <literal>boolean</>, and <literal>null</>.
       </entry>
       -->
       <entry>
         作为文本字符串返回最外面的JSON值的类型。
         可能的类型有
         Returns the type of the outermost JSON value as a text string.
         Possible types are<literal>object</>、<literal>array</>、<literal>string</>、
         <literal>number</>、<literal>boolean</>和<literal>null</>。
       </entry>
       <entry><literal>json_typeof('-123.4')</literal></entry>
       <entry><literal>number</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_to_record(json)</literal>
          </para><para><literal>jsonb_to_record(jsonb)</literal>
       </para></entry>
       <entry><type>record</type></entry>
       <!-- 
       <entry>
         Builds an arbitrary record from a JSON object (see note below).  As
         with all functions returning <type>record</>, the caller must
         explicitly define the structure of the record with an <literal>AS</>
         clause.
       </entry>
       -->
       <entry>
         从一个JSON对象中建立一个任意的记录（参见下面的注意）。
         因为所有函数都返回<type>record</>，调用者必须用<literal>AS</>
         子句明确的定义记录的结构。
       </entry>
       <entry><literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text) </literal></entry>
       <entry>
<programlisting>
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_to_recordset(json)</literal>
         </para><para><literal>jsonb_to_recordset(jsonb)</literal>
       </para></entry>
       <entry><type>setof record</type></entry>
       <!-- 
       <entry>
         Builds an arbitrary set of records from a JSON array of objects (see
         note below).  As with all functions returning <type>record</>, the
         caller must explicitly define the structure of the record with
         an <literal>AS</> clause.
       </entry>
       -->
       <entry>
         从一个JSON的对象数组中建立一个任意的记录集（参见下面的注意）。
         因为所有函数都返回<type>record</>，调用者必须用<literal>AS</>
         子句明确的定义记录的结构。
       </entry>
       <entry><literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</literal></entry>
       <entry>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </entry>
      </row>       
     </tbody>
    </tgroup>
   </table>

  <note>
    <!--
<para>
      Many of these functions and operators will convert Unicode escapes in
      JSON strings to the appropriate single character.  This is a non-issue
      if the input is type <type>jsonb</>, because the conversion was already
      done; but for <type>json</> input, this may result in throwing an error,
      as noted in <xref linkend="datatype-json">.
    </para>
-->
<para>
许多这些函数和操作符将转换JSON字符串中的Unicode转义到相应的单字符。
如果输入的类型是<type>jsonb</>，那么这将不是一个问题，因为转换早已完成；
但是如果是<type>json</>输入，那么会导致抛出一个错误，就像
<xref linkend="datatype-json">中记录的那样。
</para>
  </note>

  <note>
    <!--
<para>
      In <function>json_populate_record</>, <function>json_populate_recordset</>,
      <function>json_to_record</> and <function>json_to_recordset</>,
      type coercion from the JSON is <quote>best effort</> and may not result
      in desired values for some types.  JSON keys are matched to
      identical column names in the target row type.  JSON fields that do not
      appear in the target row type will be omitted from the output, and
      target columns that do not match any JSON field will simply be NULL.
    </para>
-->
<para>
在<function>json_populate_record</>、<function>json_populate_recordset</>、
<function>json_to_record</>和<function>json_to_recordset</>中，
JSON的类型转换是<quote>尽力而为</>的，并且对某些类型来说可能不会产生期望值。
JSON键匹配目标行类型中完全相同的字段名。没有出现在目标行类型中的JSON字段将从输出中省略，
并且不匹配任何JSON字段的目标字段将是NULL。
</para>
  </note>

  <note>
    <!--
<para>
      The <literal>json_typeof</> function's <literal>null</> return value
      should not be confused with a SQL NULL.  While
      calling <literal>json_typeof('null'::json)</> will
      return <literal>null</>, calling <literal>json_typeof(NULL::json)</>
      will return a SQL NULL.
    </para>
-->
<para>
<literal>json_typeof</>函数的<literal>null</>返回值不应该与SQL NULL混淆。
当调用<literal>json_typeof('null'::json)</>时，将返回<literal>null</>，
调用<literal>json_typeof(NULL::json)</>时，返回SQL NULL。
</para>
  </note>

  <!--
<para>
    See also <xref linkend="functions-aggregate"> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, and the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object.
    </para>
-->
<para>
参阅<xref linkend="functions-aggregate">获取有关聚合函数<function>json_agg</function>
的信息，<function>json_agg</function>聚合记录值为JSON，
聚合函数<function>json_object_agg</function>聚合值对到JSON对象。
</para>
 </sect1>

 <sect1 id="functions-sequence">
  <!-- 
  <title>Sequence Manipulation Functions</title> 
  -->
  <title>序列操作函数</title>

  <indexterm>
   <!-- 
   <primary>sequence</primary> 
   -->
   <primary>序列</primary>
  </indexterm>
  <indexterm>
   <primary>nextval</primary>
  </indexterm>
  <indexterm>
   <primary>currval</primary>
  </indexterm>
  <indexterm>
   <primary>lastval</primary>
  </indexterm>
  <indexterm>
   <primary>setval</primary>
  </indexterm>

  <!--
<para>
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence">.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table">, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
  </para>
-->
<para>
本节描述用于操作<firstterm>序列对象</firstterm>的函数，
也叫序列生成器或者就叫序列。序列对象都是用<xref linkend="sql-createsequence">
创建的特殊的单行表。一个序列对象通常用于为一个表的行生成唯一的标识符。
在<xref linkend="functions-sequence-table">
中列出的序列函数为我们从序列对象中获取后续的序列值提供了简单的、多用户安全的方法。
</para>

   <table id="functions-sequence-table">
   <!-- 
   <title>Sequence Functions</title> 
   -->
    <title>序列函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Function</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>函数</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>currval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <!-- 
<entry>Return value most recently obtained with
        <function>nextval</function> for specified sequence</entry> 
-->
<entry>返回最近一次用<function>nextval</function>获取的指定序列的数值</entry>
      </row>
      <row>
        <entry><literal><function>lastval()</function></literal></entry>
        <entry><type>bigint</type></entry>
        <!-- 
<entry>Return value most recently obtained with
        <function>nextval</function> for any sequence</entry> 
-->
<entry>返回最近一次用<function>nextval</function>获取的任意序列的数值</entry>
      </row>
      <row>
        <entry><literal><function>nextval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <!-- 
<entry>Advance sequence and return new value</entry> 
-->
<entry>递增序列并返回新值</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <!-- 
<entry>Set sequence's current value</entry> 
-->
<entry>设置序列的当前数值</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>, <type>boolean</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <!-- 
<entry>Set sequence's current value and <literal>is_called</literal> flag</entry> 
-->
<entry>设置序列的当前数值以及<literal>is_called</literal>标志</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--
  <para>
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</> argument, which is simply the OID of the sequence in the
   <structname>pg_class</> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
-->
<para>
被序列函数操作的序列是用<type>regclass</>参数声明的，它只是序列在<structname>pg_class</>
系统表里面的 OID 。不过，你不需要手工查找 OID ，因为<type>regclass</>
数据类型的输入转换器会帮你做这件事。只要写出单引号包围的序列名字即可，
因此它看上去像文本常量。要达到和处理普通<acronym>SQL</acronym>名字的兼容性，
这个字符串将转换成小写，除非在序列名字周围包含双引号，因此
<programlisting>
<!-- 
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></> 
-->
nextval('foo')      <lineannotation>操作序列号 <literal>foo</literal></>
nextval('FOO')      <lineannotation>操作序列号<literal>foo</literal></>
nextval('"Foo"')    <lineannotation>操作序列号 <literal>Foo</literal></>
</programlisting>
   <!-- 
   The sequence name can be schema-qualified if necessary: 
   -->
   必要时序列名可以用模式修饰：
<programlisting>
<!-- 
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></> 
-->
nextval('myschema.foo')     <lineannotation>操作<literal>myschema.foo</literal></>
nextval('"myschema".foo')   <lineannotation>同上</lineannotation>
nextval('foo')              <lineannotation>在搜索路径中查找<literal>foo</literal></>
</programlisting>
<!-- 
   See <xref linkend="datatype-oid"> for more information about
   <type>regclass</>. 
-->
参阅<xref linkend="datatype-oid">获取有关<type>regclass</>的更多信息。
  </para>

  <note>
   <!--
<para>
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</>, not <type>regclass</>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</> to <type>regclass</> before the function is
    invoked.
   </para>
-->
<para>
在<productname>PostgreSQL</productname> 8.1之前，序列函数的参数类型是<type>text</>
而不是<type>regclass</>，而上面描述的从文本字符串到 OID 值的转换将在每次调用的时候发生。
为了向下兼容，这个机制仍然存在，但是在内部实际上是在函数调用前隐含地将<type>text</>
转换成<type>regclass</>实现的。
</para>

   <!--
<para>
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</> constant instead of <type>regclass</>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</>
</programlisting>
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
   </para>
-->
<para>
如果你把一个序列函数的参数写成一个无修饰的文本字符串，那么它将变成类型为<type>regclass</>
的常量。因为这只是一个 OID ，它将跟踪最初标识的序列，而不管后面是否改名、模式是否变化等等。
这种<quote>提前绑定</>的行为通常是字段缺省和视图里面引用序列所需要的。
但是有时候你可能想要<quote>推迟绑定</>，这个时候序列的引用是在运行时解析的。
要获取推迟绑定的行为，我们可以强制存储为<type>text</>常量，而不是<type>regclass</>常量：
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> 在运行时查找</>
</programlisting>
请注意，推迟绑定是<productname>PostgreSQL</productname>版本 8.1 之前唯一可用的行为，
因此你可能需要在旧的应用里如此使用来保留旧有的语意。
</para>

   <!--
<para>
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
   </para>
-->
<para>
当然，序列函数的参数也可以是表达式。如果它是一个文本表达式，那么隐含的转换将导致运行时的查找。
</para>
  </note>

<para>
<!--
   The available sequence functions are:
-->
用的序列函数有：
    <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
<!-- 
       <para>
        Advance the sequence object to its next value and return that
        value.  This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely receive
        a distinct sequence value.
       </para> 
-->
<para>
递增序列对象到它的下一个数值并且返回该值。这个动作是自动完成的：
即使多个会话并发运行<function>nextval</function>，每个进程也会安全地收到一个唯一的序列值。
</para>

       <!--
<para>
        If a sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        special parameters in the <xref linkend="sql-createsequence"> command;
        see its command reference page for more information.
       </para>
-->
<para>
如果一个序列对象是带着缺省参数创建的，那么对它连续调用<function>nextval</function>
将返回从1开始的后续的数值。其他的行为可以通过使用<xref linkend="sql-createsequence">
命令里的特殊参数获取；参考其命令参考页获取更多信息。
</para>

       <important>
        <!--
<para>
         To avoid blocking concurrent transactions that obtain numbers from the
         same sequence, a <function>nextval</function> operation is never
         rolled back; that is, once a value has been fetched it is considered
         used, even if the transaction that did the
         <function>nextval</function> later aborts.  This means that aborted
         transactions might leave unused <quote>holes</quote> in the sequence
         of assigned values.
        </para>
-->
<para>
为了避免从同一个序列获取数值的当前事务被阻塞，<function>nextval</function>
操作决不会回滚；也就是说，一旦一个数值已经被抓走，那么就认为它已经用过了，
即使调用<function>nextval</function>的事务后面又退出了也一样。
这就意味着退出的事务可能在序列赋予的数值中留下未使用的<quote>空洞</quote>。
</para>
       </important>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <!--
<para>
        Return the value most recently obtained by <function>nextval</function>
        for this sequence in the current session.  (An error is
        reported if <function>nextval</function> has never been called for this
        sequence in this session.)  Because this is returning
        a session-local value, it gives a predictable answer whether or not
        other sessions have executed <function>nextval</function> since the
        current session did.
       </para>
-->
<para>
在当前会话中返回最近一次<function>nextval</function>抓到的该序列的数值。
如果在本会话中从未在该序列上调用过<function>nextval</function>，那么会报告一个错误。
因为此函数返回一个会话范围的数值，它也能给出一个可预计的结果，
可以判断其它会话是否执行过<function>nextval</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>lastval</function></term>
      <listitem>
       <!--
<para>
        Return the value most recently returned by
        <function>nextval</> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it fetches the
        value of the last sequence used by <function>nextval</function>
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
       </para>
-->
<para>
返回当前会话里最近一次<function>nextval</>返回的数值。这个函数等效于<function>currval</function>，
只是它不用序列名作为参数，它抓取当前会话里面最近一次<function>nextval</function>
使用的序列的值。如果当前会话还没有调用过<function>nextval</function>，
那么调用<function>lastval</function>是会报错的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <!--
<para>
        Reset the sequence object's counter value.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value reported by <function>currval</> is
        also set to the specified value.  In the three-parameter form,
        <literal>is_called</literal> can be set to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</> has the same effect as
        the two-parameter form. If it is set to <literal>false</literal>, the
        next <function>nextval</function> will return exactly the specified
        value, and sequence advancement commences with the following
        <function>nextval</function>.  Furthermore, the value reported by
        <function>currval</> is not changed in this case.  For example,

<screen>
SELECT setval('foo', 42);           <lineannotation>Next <function>nextval</> will return 43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</> will return 42</lineannotation>
</screen>

        The result returned by <function>setval</function> is just the value of its
        second argument.
       </para>
-->
<para>
重置序列对象的计数器数值。2个参数的形式设置序列的<literal>last_value</literal>
字段为声明数值并且将其<literal>is_called</literal>字段设置为<literal>true</literal>，
表示下一次<function>nextval</function>将在返回数值之前递增该序列。<function>currval</>
报告的值也设定为指定的值。在3个参数形式里<literal>is_called</literal>可以设置为<literal>true</literal>
或<literal>false</literal>。设置为<literal>true</>和2参数的形式影响相同。
如果你把它设置为<literal>false</literal>，那么下一次<function>nextval</function>
将返回这里声明的数值而随后<function>nextval</function>才开始递增该序列。
因此在这种情况下<function>currval</>报告的值没有改变。比如，
<screen>
SELECT setval('foo', 42);           <lineannotation>下次<function>nextval</>将返回43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>和上面一样</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>下次<function>nextval</>将返回42</lineannotation>
</screen>
<function>setval</function>返回的结果就是它的第二个参数的数值。
</para>
       <important>
        <!--
<para>
         Because sequences are non-transactional, changes made by
         <function>setval</function> are not undone if the transaction rolls
         back.
        </para>
-->
<para>
因为序列是非事务性的，如果事务回滚了，由<function>setval</function>所做的改变也不会取消。
</para>
       </important>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>

 </sect1>


 <sect1 id="functions-conditional">
  <!-- 
  <title>Conditional Expressions</title> 
  -->
  <title>条件表达式</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
   <!-- 
   <primary>conditional expression</primary> 
   -->
   <primary>条件表达式</primary>
  </indexterm>

  <!--
<para>
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
  </para>
-->
<para>
本节描述在<productname>PostgreSQL</productname>里可用的<acronym>SQL</acronym>兼容的条件表达式。
</para>

  <tip>
   <!--
<para>
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a stored procedure
    in a more expressive programming language.
   </para>
-->
<para>
如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个存储过程。
</para>
  </tip>

  <sect2 id="functions-case">
   <title><literal>CASE</></title>

  
<para>
<!--
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:
-->
<token>CASE</token>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句。
<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>
<!-- 
   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
-->
<token>CASE</token>子句可以用于任何表达式可以存在的地方。<replaceable>condition</replaceable>
是一个返回<type>boolean</type>的表达式。如果条件的结果为真，那么<token>CASE</token>
表达式的结果就是符合条件的<replaceable>result</replaceable>，并且不再处理剩余的
<token>CASE</token>表达式。如果条件的结果为假，那么以相同方式搜寻任何随后的<token>WHEN</token>
子句。如果没有<token>WHEN</token> <replaceable>condition</replaceable>为真，
那么表达式的结果就是在<token>ELSE</token>子句里的<replaceable>result</replaceable>。
如果省略了<token>ELSE</token>子句且没有匹配的条件，结果为 NULL 。
  </para>
   
<para>
<!--
    An example:
-->
一个例子：
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>
  <!--
<para>
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"> for more details.
  </para>
-->
<para>
所有<replaceable>result</replaceable>表达式的数据的类型都必须可以转换成单一的输出类型。
参阅<xref linkend="typeconv-union-case">获取更多细节。
</para>
  
<para>
<!--
   There is a <quote>simple</> form of <token>CASE</token> expression
   that is a variant of the general form above:
-->
下面这个<quote>简单的</><token>CASE</token>表达式是上面的通用形式的一个特殊的变种：
<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>
<!-- 
   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
-->
先计算<replaceable>expression</replaceable>的值，然后与每个<token>WHEN</token>
子句里声明的<replaceable>value</replaceable>表达式对比，直到找到一个相等的。
如果没有找到匹配的，则返回在<token>ELSE</token>子句里的<replaceable>result</replaceable>
(或者 NULL)。这个类似于 C 里的<function>switch</function>语句。
  </para>
   
<para>
<!--
    The example above can be written using the simple
    <token>CASE</token> syntax:
-->
上面的例子可以用简单<token>CASE</token>语法来写：
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>
   
<para>
<!--
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
-->
<token>CASE</token>表达式并不计算任何对于判断结果并不需要的子表达式。比如，
下面是一个可以避免被零除的方法：
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <!--
<para>
     As described in <xref linkend="syntax-express-eval">, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
    </para>
-->
<para>
正如在<xref linkend="xfunc-volatility">中描述的那样，
表达式的子表达式会在不同的时间评估，所以
<quote><token>CASE</token>仅评估必须的子表达式</quote>的原则不是铁定的。
例如，一个常量<literal>1/0</>子表达式将通常在规划时间导致被零除错误，
即使它在一个在运行时永远不会进入的<token>CASE</token>分支里。
</para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
  
<para>
<!--
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
-->
<function>COALESCE</function>返回它的第一个非 NULL 的参数值。如果所有参数都是null那么返回null。
它常用于在显示数据时用缺省值替换 NULL 。比如：
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
<!-- 
   This returns <varname>description</> if it is not null, otherwise
   <varname>short_description</> if it is not null, otherwise <literal>(none)</>. 
-->
如果<varname>description</>非空那么返回它，否则如果<varname>short_description</>非空则返回它，
否则返回<literal>(none)</>。
  </para>


   <!--
<para>
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</> and <function>IFNULL</>, which are used in some other
    database systems.
   </para>
-->
<para>
和<token>CASE</token>表达式一样，<function>COALESCE</function>只计算需要用来判断结果的参数；
也就是说，在第一个非空参数右边的参数不会被计算。
这个符合 SQL 标准的函数提供了与某些其它数据库系统中的<function>NVL</>
和<function>IFNULL</>类似的功能。
</para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  
<para>
<!--
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
-->
当且仅当<replaceable>value1</replaceable>等于<replaceable>value2</replaceable>时，
<function>NULLIF</function>才返回 null 。否则它返回<replaceable>value1</replaceable>。
这些可以用于执行上面给出的<function>COALESCE</function>例子的反例：
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
  </para>
  <!--
<para>
   In this example, if <literal>value</literal> is <literal>(none)</>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
  </para>
-->
<para>
在这个例子中，如果<literal>value</literal>是<literal>(none)</>那么返回 null，否则返回<literal>value</literal>。
</para>

  </sect2>

  <sect2 id="functions-greatest-least">
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <!--
<para>
    The <function>GREATEST</> and <function>LEAST</> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
   </para>
-->
<para>
<function>GREATEST</>和<function>LEAST</>函数从一个任意数字表达式的列表里选取最大或者最小的数值。
这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型(参阅<xref linkend="typeconv-union-case">
获取细节)。列表中的 NULL 值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL 。
</para>

   <!--
<para>
    Note that <function>GREATEST</> and <function>LEAST</> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
   </para>
-->
<para>
请注意<function>GREATEST</>和<function>LEAST</>都不是 SQL 标准，但却是很常见的扩展。
某些其他的数据库在任意一个参数为NULL时返回NULL，而不是所有参数都是NULL时。
</para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
  <!-- 
  <title>Array Functions and Operators</title> 
  -->
  <title>数组函数和操作符</title>

  <!--
<para>
   <xref linkend="array-operators-table"> shows the operators
   available for array types.
  </para>
-->
<para>
<xref linkend="array-operators-table">显示了可以用于 array 类型的操作符。
</para>

    <table id="array-operators-table">
     <!-- 
 <title>Array Operators</title> 
 -->
 <title>Array 操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>操作符</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <!-- 
<entry>equal</entry> 
-->
<entry>等于</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <!-- 
<entry>not equal</entry> 
-->
<entry>不等于</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <!-- 
<entry>less than</entry> 
-->
<entry>小于</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <!-- 
<entry>greater than</entry> 
-->
<entry>大于</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <!-- 
<entry>less than or equal</entry> 
-->
<entry>小于或等于</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <!-- 
<entry>greater than or equal</entry> 
-->
<entry>大于或等于</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <!-- 
<entry>contains</entry> 
-->
<entry>包含</entry>
        <entry><literal>ARRAY[1,4,3] @&gt; ARRAY[3,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <!-- 
<entry>is contained by</entry> 
-->
<entry>被包含于</entry>
        <entry><literal>ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <!-- 
<entry>overlap (have elements in common)</entry> 
-->
<entry>重叠(有共同元素)</entry>
        <entry><literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <!-- 
<entry>array-to-array concatenation</entry> 
-->
<entry>数组与数组连接</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <!-- 
<entry>array-to-array concatenation</entry> 
-->
<entry>数组与数组连接</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <!-- 
<entry>element-to-array concatenation</entry> 
-->
<entry>元素与数组连接</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <!-- 
<entry>array-to-element concatenation</entry> 
-->
<entry>数组与元素连接</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   Array comparisons compare the array contents element-by-element,
   using the default B-tree comparison function for the element data type.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
  </para>
-->
<para>
数组比较是使用默认的 B-Tree 比较函数对所有元素逐一进行比较的。
多维数组的元素按照行顺序进行访问(最后的下标变化最快)。如果两个数组的内容相同但维数不等，
那么决定排序顺序的首要因素将是维数(原文：the first difference in the dimensionality information
 determines the sort order)，这与<productname>PostgreSQL</> 8.2 之前的版本不同：
老版本认为内容相同的两个数组相等，即使它们的维数或下标范围并不相同。
</para>

  <!--
<para>
   See <xref linkend="arrays"> for more details about array operator
   behavior.  See <xref linkend="indexes-types"> for more details about
   which operators support indexed operations.
  </para>
-->
<para>
参阅<xref linkend="arrays">获取有关数组操作符行为的更多细节。
参阅<xref linkend="indexes-types">获取哪个操作符支持索引操作的更多细节。
</para>

  <!--
<para>
   <xref linkend="array-functions-table"> shows the functions
   available for use with array types. See <xref linkend="arrays">
   for more information  and examples of the use of these functions.
  </para>
-->
<para>
<xref linkend="array-functions-table">显示了可以用于数组类型的函数。
参阅<xref linkend="arrays">获取更多信息以及使用这些函数的例子。
</para>

  <indexterm>
    <primary>array_append</primary>
  </indexterm>
  <indexterm>
    <primary>array_cat</primary>
  </indexterm>
  <indexterm>
    <primary>array_ndims</primary>
  </indexterm>
  <indexterm>
    <primary>array_dims</primary>
  </indexterm>
  <indexterm>
    <primary>array_fill</primary>
  </indexterm>
  <indexterm>
    <primary>array_length</primary>
  </indexterm>
  <indexterm>
    <primary>array_lower</primary>
  </indexterm>
  <indexterm>
    <primary>array_prepend</primary>
  </indexterm>
  <indexterm>
    <primary>array_remove</primary>
  </indexterm>
  <indexterm>
    <primary>array_replace</primary>
  </indexterm>
  <indexterm>
    <primary>array_to_string</primary>
  </indexterm>
 <indexterm>
    <primary>array_upper</primary>
  </indexterm>
  <indexterm>
    <primary>cardinality</primary>
  </indexterm>
  <indexterm>
    <primary>string_to_array</primary>
  </indexterm>
  <indexterm>
    <primary>unnest</primary>
  </indexterm>

    <table id="array-functions-table">
    <!-- 
<title>Array Functions</title> 
-->
 <title>Array 函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>例子</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>array_append</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>append an element to the end of an array</entry> 
-->
<entry>向数组末尾添加元素</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_cat</function>(<type>anyarray</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>concatenate two arrays</entry> 
-->
<entry>连接两个数组</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_ndims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>returns the number of dimensions of the array</entry> 
-->
<entry>返回数组的维数</entry>
        <entry><literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_dims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>returns a text representation of array's dimensions</entry> 
-->
<entry>返回数组维数的文本表示</entry>
        <entry><literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_fill</function>(<type>anyelement</type>, <type>int[]</type>,
          <optional>, <type>int[]</type></optional>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>returns an array initialized with supplied value and
         dimensions, optionally with lower bounds other than 1</entry> 
 -->
 <entry>返回数组初始化提供的值和维度，可选下界不是1</entry>
        <entry><literal>array_fill(7, ARRAY[3], ARRAY[2])</literal></entry>
        <entry><literal>[2:4]={7,7,7}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_length</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>returns the length of the requested array dimension</entry> 
-->
<entry>返回数组维度的长度</entry>
        <entry><literal>array_length(array[1,2,3], 1)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_lower</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>returns lower bound of the requested array dimension</entry> 
-->
<entry>返回数组维数的下界</entry>
        <entry><literal>array_lower('[0:2]={1,2,3}'::int[], 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_prepend</function>(<type>anyelement</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>append an element to the beginning of an array</entry> 
-->
<entry>向数组开头添加元素</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_remove</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>remove all elements equal to the given value from the array
         (array must be one-dimensional)</entry> 
 -->
 <entry>从数组中删除所有等于给定值的元素（数组必须是一维的）</entry>
        <entry><literal>array_remove(ARRAY[1,2,3,2], 2)</literal></entry>
        <entry><literal>{1,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_replace</function>(<type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <!-- 
<entry>replace each array element equal to the given value with a new value</entry>
-->
<entry>用新值替换每个等于给定值的数组元素</entry>
        <entry><literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal></entry>
        <entry><literal>{1,2,3,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_to_string</function>(<type>anyarray</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>concatenates array elements using supplied delimiter and
         optional null string</entry> 
 -->
 <entry>使用分隔符和null字符串连接数组元素</entry>
        <entry><literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal></entry>
        <entry><literal>1,2,3,*,5</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_upper</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <!-- 
<entry>returns upper bound of the requested array dimension</entry> 
-->
<entry>返回数组维数的上界</entry>
        <entry><literal>array_upper(ARRAY[1,8,3,7], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>cardinality</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
        <!--
        <entry>returns the total number of elements in the array, or 0 if the array is empty</entry>
        -->
        <entry>返回数组中的总元素数量，或者如果数组是空的则为0</entry>
        <entry><literal>cardinality(ARRAY[[1,2],[3,4]])</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>string_to_array</function>(<type>text</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text[]</type></entry>
        <!-- 
<entry>splits string into array elements using supplied delimiter and
         optional null string</entry> 
 -->
 <entry>使用指定的分隔符和null字符串把字符串分裂成数组元素</entry>
        <entry><literal>string_to_array('xx~^~yy~^~zz', '~^~', 'yy')</literal></entry>
        <entry><literal>{xx,NULL,zz}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>setof anyelement</type></entry>
        <!-- 
<entry>expand an array to a set of rows</entry> 
-->
<entry>扩大一个数组为一组行</entry>
        <entry><literal>unnest(ARRAY[1,2])</literal></entry>
        <entry><literallayout class="monospaced">1
2</literallayout>(2 rows)</entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>, <type>anyarray</type> [, ...])
         </literal>
        </entry>
        <entry><type>setof anyelement, anyelement [, ...]</type></entry>
        <!--
        <entry>expand multiple arrays (possibly of different types) to a set
         of rows.  This is only allowed in the FROM clause; see
         <xref linkend="queries-tablefunctions"></entry>
         -->
         <entry>扩展多个数组（可能是不同的类型）到一组行。
         仅在FROM子句中允许这样做；参阅
         <xref linkend="queries-tablefunctions"></entry>
        <entry><literal>unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</literal></entry>
        <entry><literallayout class="monospaced">1    foo
2    bar
NULL baz</literallayout>(3 rows)</entry>
       </row>
       </tbody>
     </tgroup>
    </table>

   <!--
<para>
    In <function>string_to_array</function>, if the delimiter parameter is
    NULL, each character in the input string will become a separate element in
    the resulting array.  If the delimiter is an empty string, then the entire
    input string is returned as a one-element array.  Otherwise the input
    string is split at each occurrence of the delimiter string.
   </para>
-->
<para>
在<function>string_to_array</function>中，如果分隔符参数是NULL，
输入字符串中的每个字符将在结果数组中变成一个独立的元素。如果分隔符是一个空白字符串，
那么整个输入字符串将变为一元素的数组。否则输入字符串将在每个分隔字符串处分裂。
</para>

   <!--
<para>
    In <function>string_to_array</function>, if the null-string parameter
    is omitted or NULL, none of the substrings of the input will be replaced
    by NULL.
    In <function>array_to_string</function>, if the null-string parameter
    is omitted or NULL, any null elements in the array are simply skipped
    and not represented in the output string.
   </para>
-->
<para>
在<function>string_to_array</function>中，如果省略null字符串参数或为NULL，
将没有输入字符串的子串被NULL代替。在<function>array_to_string</function>中，
如果省略null字符串参数或为NULL，在数组中的任何null元素将简单的跳过，
并且不再输出字符串中出现。
</para>

   <note>
    <!--
<para>
     There are two differences in the behavior of <function>string_to_array</>
     from pre-9.1 versions of <productname>PostgreSQL</>.
     First, it will return an empty (zero-element) array rather than NULL when
     the input string is of zero length.  Second, if the delimiter string is
     NULL, the function splits the input into individual characters, rather
     than returning NULL as before.
    </para>
-->
<para>
在<productname>PostgreSQL</>版本9.1之前，<function>string_to_array</>有两个行为上的不同。
第一，当输入字符串长度为零时，它将返回一个空（零元素）数组而不是NULL。第二，
如果分隔字符串是NULL时，函数分隔输入为单独的字符，而不是和以前一样返回NULL。
</para>
   </note>

   <!--
<para>
    See also <xref linkend="functions-aggregate"> about the aggregate
    function <function>array_agg</function> for use with arrays.
   </para>
-->
<para>
也可以参阅<xref linkend="functions-aggregate">获取关于
<function>array_agg</function>聚合函数使用数组的信息。
</para>
  </sect1>

 <sect1 id="functions-range">
  <!-- 
  <title>Range Functions and Operators</title> 
  -->
  <title>范围函数和操作符</title>

  <!--
<para>
   See <xref linkend="rangetypes"> for an overview of range types.
  </para>
-->
<para>
参阅<xref linkend="rangetypes">获取范围类型的概述。
</para>

  <!--
<para>
   <xref linkend="range-operators-table"> shows the operators
   available for range types.
  </para>
-->
<para>
<xref linkend="range-operators-table">显示了范围类型可用的操作符。
</para>

    <table id="range-operators-table">
     <!-- 
 <title>Range Operators</title> 
 -->
 <title>范围操作符</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>操作符</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <!-- 
<entry>equal</entry> 
-->
<entry>等于</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <!-- 
<entry>not equal</entry> 
-->
<entry>不等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <!-- 
<entry>less than</entry> 
-->
<entry>小于</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <!-- 
<entry>greater than</entry> 
-->
<entry>大于</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <!-- 
<entry>less than or equal</entry>
-->
<entry>小于或等于</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <!-- 
<entry>greater than or equal</entry> 
-->
<entry>大于或等于</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <!-- 
<entry>contains range</entry> 
-->
<entry>包含范围</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <!-- 
<entry>contains element</entry> 
-->
<entry>包含元素</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <!-- 
<entry>range is contained by</entry> 
-->
<entry>范围包含于</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <!-- 
<entry>element is contained by</entry> 
-->
<entry>元素包含于</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <!-- 
<entry>overlap (have points in common)</entry> 
-->
<entry>重叠 (有共同点)</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <!-- 
<entry>strictly left of</entry> 
-->
<entry>严格在左</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <!-- 
<entry>strictly right of</entry> 
-->
<entry>严格在右</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <!-- 
<entry>does not extend to the right of</entry> 
-->
<entry>没有延伸到右边</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <!-- 
<entry>does not extend to the left of</entry> 
-->
<entry>没有延伸到左边</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>-|-</literal> </entry>
        <!-- 
<entry>is adjacent to</entry> 
-->
<entry>相邻</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <!-- 
<entry>union</entry> 
-->
<entry>并集</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <!-- 
<entry>intersection</entry> 
-->
<entry>交集</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <!-- 
<entry>difference</entry> 
-->
<entry>差集</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   The simple comparison operators <literal>&lt;</literal>,
   <literal>&gt;</literal>, <literal>&lt;=</literal>, and
   <literal>&gt;=</literal> compare the lower bounds first, and only if those
   are equal, compare the upper bounds.  These comparisons are not usually
   very useful for ranges, but are provided to allow B-tree indexes to be
   constructed on ranges.
  </para>
-->
<para>
简单的比较操作符<literal>&lt;</literal>，<literal>&gt;</literal>，<literal>&lt;=</literal>
和<literal>&gt;=</literal>先比较下界，只有下界相等时才比较上界。
这种比较通常对范围不是很好用，但是为了在范围中允许构建B-tree索引才提供的。
</para>

  <!--
<para>
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
  </para>
-->
<para>
左于/右于/邻近操作符当包含空范围时也会返回false；也就是，
不认为空范围在其他范围之前或之后。
</para>

  <!--
<para>
   The union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented.
  </para>
-->
<para>
并集和差集操作符在结果范围需要包含两个不相交的子范围时失败，因此不能表示这样一个范围。
</para>

  <!--
<para>
   <xref linkend="range-functions-table"> shows the functions
   available for use with range types.
  </para>
-->
<para>
<xref linkend="range-functions-table">显示了可以和范围一起使用的函数。
</para>

  <indexterm>
    <primary>lower</primary>
  </indexterm>
  <indexterm>
    <primary>upper</primary>
  </indexterm>
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>

    <table id="range-functions-table">
     <!-- 
 <title>Range Functions</title> 
 -->
 <title>范围函数</title>
     <tgroup cols="5">
      <thead>
       <row>
        <!-- 
<entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry> 
-->
<entry>函数</entry>
        <entry>返回类型</entry>
        <entry>描述</entry>
        <entry>示例</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <!-- 
<entry>range's element type</entry>
        <entry>lower bound of range</entry> 
-->
<entry>范围元素类型</entry>
        <entry>范围的下界</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <!-- 
<entry>range's element type</entry>
        <entry>upper bound of range</entry>
-->
<entry>范围元素类型</entry>
        <entry>范围的上界</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>is the range empty?</entry> 
-->
<entry>范围是空的?</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>is the lower bound inclusive?</entry> 
-->
<entry>包涵下界?</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>is the upper bound inclusive?</entry> 
-->
<entry>包含上界?</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>is the lower bound infinite?</entry> 
-->
<entry>下界无穷?</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
        <!-- 
<entry>is the upper bound infinite?</entry> 
-->
<entry>上界无穷?</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <!--
<para>
   The <function>lower</> and  <function>upper</> functions return null
   if the range is empty or the requested bound is infinite.
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
  </para>
-->
<para>
如果范围是空或者需要的界限是无穷的，<function>lower</>和<function>upper</>
函数返回null。<function>lower_inc</function>, <function>upper_inc</function>,
 <function>lower_inf</function>和<function>upper_inf</function>函数均对空范围返回false。
</para>
  </sect1>

 <sect1 id="functions-aggregate">
  <!-- 
  <title>Aggregate Functions</title> 
  -->
  <title>聚合函数</title>

  <indexterm zone="functions-aggregate">
   <!-- 
   <primary>aggregate function</primary>
   <secondary>built-in</secondary> 
   -->
   <primary>聚合函数</primary>
   <secondary>内建</secondary>
  </indexterm>

  <!--
<para>
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in normal aggregate functions
   are listed in
   <xref linkend="functions-aggregate-table"> and
   <xref linkend="functions-aggregate-statistics-table">.
   The built-in ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"> and
   <xref linkend="functions-hypothetical-table">.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates">.
   Consult <xref linkend="tutorial-agg"> for additional introductory
   information.
  </para>
-->
<para>
<firstterm>聚合函数</firstterm>从一组输入值里计算一个结果。
<xref linkend="functions-aggregate-table">和<xref linkend="functions-aggregate-statistics-table">
显示了内建的普通聚合函数。<xref linkend="functions-orderedset-table">
和<xref linkend="functions-hypothetical-table">中列出了内建的顺序集聚合函数。
聚合函数的特殊语法在<xref linkend="syntax-aggregates">里解释。
请参考<xref linkend="tutorial-agg">获取额外的介绍性信息。
</para>

  <table id="functions-aggregate-table">
   <!-- 
   <title>General-Purpose Aggregate Functions</title> 
   -->
   <title>通用聚合函数</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Function</entry>
      <entry>Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry> 
  -->
  <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <!-- 
  <entry>
       any
      </entry>
      <entry>
       array of the argument type
      </entry>
      <entry>input values, including nulls, concatenated into an array</entry> 
  -->
  <entry>
       任意
      </entry>
      <entry>
       参数类型的数组
      </entry>
      <entry>输入值，包括空，连接到一个数组</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, or <type>interval</type>
      </entry>
      <!-- 
  <entry>
       <type>numeric</type> for any integer-type argument,
       <type>double precision</type> for a floating-point argument,
       otherwise the same as the argument data type
      </entry>
      <entry>the average (arithmetic mean) of all input values</entry> 
  -->
  <entry>
       对于任何整数类型输入，结果都是<type>numeric</type>类型。
   对于任何浮点输入，结果都是<type>double precision</type>类型。
   否则和输入数据类型相同。
      </entry>
      <entry>所有输入值的均值(算术平均)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <!-- 
  <entry>
        same as argument data type
      </entry>
      <entry>the bitwise AND of all non-null input values, or null if none</entry> 
  -->
  <entry>
        和参数数据类型相同
      </entry>
      <entry>所有非 NULL 输入值的按位与(AND)，如果全部输入值皆为 NULL ，那么结果也为 NULL 。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <!-- 
  <entry>
        same as argument data type
      </entry>
      <entry>the bitwise OR of all non-null input values, or null if none</entry> 
  -->
  <entry>
       和参数数据类型相同
      </entry>
      <entry>所有非 NULL 输入值的按位或(OR)，如果全部输入值皆为 NULL ，那么结果也为 NULL 。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <!-- 
  <entry>true if all input values are true, otherwise false</entry> 
  -->
  <entry>如果所有输入值都是真，则为真，否则为假。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <!-- 
  <entry>true if at least one input value is true, otherwise false</entry> 
  -->
  <entry>如果至少有一个输入值为真，则为真，否则为假。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
      <!-- 
  <entry>number of input rows</entry> 
  -->
  <entry>输入行数</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
      <!-- 
  <entry>any</entry> 
  -->
  <entry>任意</entry>
      <entry><type>bigint</type></entry>
      <!-- 
  <entry>
       number of input rows for which the value of <replaceable
       class="parameter">expression</replaceable> is not null
      </entry>
  -->
  <entry>
      计算所有输入行中满足<replaceable class="parameter">expression</replaceable>不为 NULL 的行数。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <!-- 
  <entry>equivalent to <function>bool_and</function></entry> 
  -->
  <entry>等效于<function>bool_and</function></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <!-- 
      <entry>aggregates values as a JSON array</entry>
  -->
  <entry>聚合值作为JSON数组</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <!--
      <entry>aggregates name/value pairs as a JSON object</entry>
      -->
<entry>聚合名字/值对作为JSON对象</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <!-- 
  <entry>any array, numeric, string, or date/time type</entry>
      <entry>same as argument type</entry>
      <entry>
       maximum value of <replaceable
       class="parameter">expression</replaceable> across all input
       values
      </entry> 
  -->
  <entry>任意数组、数值、字符串、日期/时间类型</entry>
      <entry>和参数数据类型相同</entry>
      <entry>
       有输入行中<replaceable class="parameter">expression</replaceable>的最大值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <!-- 
  <entry>any array, numeric, string, or date/time type</entry>
      <entry>same as argument type</entry>
      <entry>
       minimum value of <replaceable
       class="parameter">expression</replaceable> across all input
       values
      </entry> 
  -->
  <entry>任意数组、数值、字符串、日期/时间类型</entry>
      <entry>和参数数据类型相同</entry>
      <entry>
       所有输入行中<replaceable class="parameter">expression</replaceable>的最小值
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
       (<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</type>)
      </entry>
      <!-- 
  <entry>
       same as argument types
      </entry>
      <entry>input values concatenated into a string, separated by delimiter</entry> 
  -->
  <entry>
       和参数数据类型相同
      </entry>
      <entry>输入值连接成为一个字符串，用分隔符分开</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>,
       <type>interval</type>, or <type>money</>
      </entry>
      <!-- 
  <entry>
       <type>bigint</type> for <type>smallint</type> or
       <type>int</type> arguments, <type>numeric</type> for
       <type>bigint</type> arguments, otherwise the same as the
       argument data type
      </entry>
      <entry>sum of <replaceable class="parameter">expression</replaceable> across all input values</entry>
  -->
  <entry>
       对于<type>smallint</type>或<type>int</type>参数，输出类型为<type>bigint</type>。
   对于<type>bigint</type>参数，输出类型为<type>numeric</type>，否则和参数数据类型相同。
      </entry>
      <entry>所有输入行的<replaceable class="parameter">expression</replaceable>总和。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <!-- 
  <entry>concatenation of XML values (see also <xref linkend="functions-xml-xmlagg">)</entry> 
  -->
  <entry>连接 XML 值 (也可以参阅 <xref linkend="functions-xml-xmlagg">)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
  </para>
-->
<para>
请注意，除了<function>count</function>以外，这些函数在没有输入行时返回 NULL 。
尤其要指出的是<function>sum</function>函数在没有输入行时返回 NULL ，而不是零。
<function>array_agg</function>函数在没有输入行时返回null而不是空数组。
必要时可以用<function>coalesce</function>把 NULL 替换成零或空数组。
</para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
   
<para>
<!--
      Boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      As for <function>any</function> and <function>some</function>,
      it seems that there is an ambiguity built into the standard syntax:
-->
<function>bool_and</function>和<function>bool_or</function>布尔聚合对应标准的 SQL 
聚合<function>every</function>和<function>any</function>或<function>some</function>。
对于<function>any</function>和<function>some</function>，标准语法里面似乎有些内置的歧义：
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
<!-- 
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates. 
-->
这里的<function>ANY</function>既可以被认为是引出一个子查询，
也可以被认为是一个聚合(如果子查询返回布尔值的1行的话)。因此标准的名字无法用于这些聚合。
    </para>

  </note>

  <note>
   
<para>
<!--
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
-->
习惯了其它 SQL 数据库管理系统的用户可能被用于全表计算的<function>count</function>
的性能(之慢)惊住了。一个类似下面这样的查询：
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
<!-- 
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index which includes all rows in
    the table. 
-->
将需要努力与表的大小成正比：<productname>PostgreSQL</productname>
将需要扫面整个表或包含表中所有行的完整的索引。
   </para>
  </note>
  
<para>
<!--
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>,
   <function>json_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates">.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:
-->
聚合函数<function>array_agg</function>，<function>json_agg</function>，<function>json_object_agg</function>，<function>string_agg</function>
和<function>xmlagg</function>，以及类似用户定义的聚合函数，根据输入值的顺序产生意义不同的结果值。
这个顺序默认没有指定，但是可以通过在聚合函数调用时，写一个<literal>ORDER BY</>子句来控制，
就像<xref linkend="syntax-aggregates">描述的那样。另外，
通常可以从一个已排序的子查询中提供输入值。例如：
<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

<!-- 
   But this syntax is not allowed in the SQL standard, and is
   not portable to other database systems.
-->
但此语法在SQL标准里不允许，不能移植到其它数据库系统。
  </para>

  <!--
<para>
   <xref linkend="functions-aggregate-statistics-table"> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Where the description mentions
   <replaceable class="parameter">N</replaceable>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <replaceable class="parameter">N</replaceable> is zero.
  </para>
-->
<para>
<xref linkend="functions-aggregate-statistics-table">展示了用于统计分析的聚合函数。
单独列出这些函数仅仅是为了避免和那些经常使用的聚合函数混在一起而已。
"描述"列中的<replaceable class="parameter">N</replaceable>
表示所有输入行中使得输入表达式不为 NULL 的行数。总的来说，如果计算本身变得没有意义，
那么返回值将是 NULL 。例如当<replaceable class="parameter">N</replaceable>为零的时候。
</para>

  <indexterm>
   <!-- 
   <primary>statistics</primary> 
   -->
   <primary>统计</primary>
  </indexterm>
  <indexterm>
   <!-- 
   <primary>linear regression</primary> 
   -->
   <primary>线性回归</primary>
  </indexterm>

  <table id="functions-aggregate-statistics-table">
   <!-- 
   <title>Aggregate Functions for Statistics</title> 
   -->
   <title>统计聚合函数</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry> 
  -->
  <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>correlation</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>correlation coefficient</entry> 
  -->
  <entry>相关系数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>population covariance</entry> 
  -->
  <entry>总体协方差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>covariance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>sample covariance</entry> 
  -->
  <entry>样本协方差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!--
  <entry>average of the independent variable
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
  -->
  <entry>自变量的平均值
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>average of the dependent variable
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
  -->
  <entry>因变量的平均值
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <!-- 
  <entry>number of input rows in which both expressions are nonnull</entry> 
  -->
  <entry>两个表达式都不为 NULL 的输入行数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regression intercept</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>y-intercept of the least-squares-fit linear equation
      determined by the (<replaceable
      class="parameter">X</replaceable>, <replaceable
      class="parameter">Y</replaceable>) pairs</entry> 
  -->
  <entry>
  根据所有输入的点(<replaceable class="parameter">X</replaceable>, <replaceable
      class="parameter">Y</replaceable>)按照最小二乘法拟合成一个线性方程，然后返回该直线的 Y 轴截距</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>square of the correlation coefficient</entry> 
  -->
  <entry>相关系数的平方</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regression slope</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>slope of the least-squares-fit linear equation determined
      by the (<replaceable class="parameter">X</replaceable>,
      <replaceable class="parameter">Y</replaceable>) pairs</entry> 
  -->
  <entry>
  根据所有输入的点(<replaceable class="parameter">X</replaceable>,
      <replaceable class="parameter">Y</replaceable>)按照最小二乘法拟合成一个线性方程，
  然后返回该直线的斜率。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the independent variable)</entry> 
  -->
  <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (自变量的<quote>平方和</quote>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      products</quote> of independent times dependent
      variable)</entry> 
  -->
  <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> (自变量和因变量的<quote>乘方积</quote>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the dependent variable)</entry>
  -->
  <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (因变量的<quote>平方和</quote>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
  <!--
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>historical alias for <function>stddev_samp</function></entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
  <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry><function>stddev_samp</function>的别名(历史原因)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
  <!--
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>      
  <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>population standard deviation of the input values</entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
  <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry>总体标准差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <!-- 
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>sample standard deviation of the input values</entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
      <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry>样本标准差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <!-- 
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>historical alias for <function>var_samp</function></entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
      <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry><function>var_samp</function>的别名(历史原因)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
        <secondary>population</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <!-- 
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>population variance of the input values (square of the population standard deviation)</entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
      <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry>总体方差(总体标准差的平方)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
        <secondary>sample</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <!-- 
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
      </entry>
      <entry>sample variance of the input values (square of the sample standard deviation)</entry> 
  -->
  <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, 或 <type>numeric</type>
      </entry>
      <entry>
       对于浮点类型的输入返回<type>double precision</type>，其他输入返回<type>numeric</type>
      </entry>
      <entry>样本方差(样本标准差的平方)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
<!--
   <para>
   <xref linkend="functions-orderedset-table"> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</> functions.
  </para> 
-->
<para>
<xref linkend="functions-orderedset-table">显示了一些使用
<firstterm>顺序集聚合</>语法的聚合函数。这些函数有时被称为
<quote>逆分布</>函数。
</para>  
  
  <indexterm>
   <!--
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
   -->
   <primary>顺序集聚合</primary>
   <secondary>内建</secondary>
  </indexterm>
  <indexterm>
   <!--
   <primary>inverse distribution</primary>
   -->
   <primary>逆分布</primary>
  </indexterm>  
  
  <table id="functions-orderedset-table">
   <!--
   <title>Ordered-Set Aggregate Functions</title>
   -->
   <title>顺序集聚合函数</title>

   <tgroup cols="5">
    <thead>
     <row>
      <!--
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      -->
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚合的参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>mode</primary>
        <secondary>statistical</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
      <!--
      any sortable type
      -->
      任意可排序类型
      </entry>
      <entry>
       <!--
       same as sort expression
       -->
       和排序表达式相同
      </entry>
      <entry>
       <!--
       returns the most frequent input value (arbitrarily choosing the first
       one if there are multiple equally-frequent results)
       -->
       返回最频繁的输入值（如果有多个相同频繁的结果，则返回第一个）
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>continuous</secondary>
       </indexterm>
       <indexterm>
        <primary>median</primary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <!--
       <type>double precision</type> or <type>interval</type>
       -->
       <type>double precision</type> 或 <type>interval</type>
      </entry>
      <entry>
       <!--
       same as sort expression
       -->
       和排序表达式相同
      </entry>
      <entry>
       <!--
       continuous percentile: returns a value corresponding to the specified
       fraction in the ordering, interpolating between adjacent input items if
       needed
       -->
       连续的百分位：返回一个值对应于排序中指定的分数，
       如果需要，插入到临近的输入项之间。
      </entry>
     </row>

      <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       <!--
       <type>double precision</type> or <type>interval</type>
       -->
       <type>double precision</type> 或 <type>interval</type>
      </entry>
      <entry>
       <!--
       array of sort expression's type
       -->
       排序表达式的数组的类型
      </entry>
      <entry>
       <!--
       multiple continuous percentile: returns an array of results matching
       the shape of the <literal>fractions</literal> parameter, with each
       non-null element replaced by the value corresponding to that percentile
       -->
       多个连续的百分位：返回结果的数组，匹配<literal>fractions</literal>
       参数的模型，每个非空元素被对应于该百分位的值替代
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>discrete</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <!--
       any sortable type
       -->
       任意可排序类型
      </entry>
      <entry>
       <!--
       same as sort expression
       -->
       和排序表达式相同
      </entry>
      <entry>
       <!--
       discrete percentile: returns the first input value whose position in
       the ordering equals or exceeds the specified fraction
       -->
       不连续的百分位：返回第一个在排序位置中等于或超过指定分数的输入值
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
       <!--
       any sortable type
       -->
       任意可排序类型
      </entry>
      <entry>
       <!-- 
       array of sort expression's type 
       -->
       排序表达式数组的类型
      </entry>
      <entry>
       <!--
       multiple discrete percentile: returns an array of results matching the
       shape of the <literal>fractions</literal> parameter, with each non-null
       element replaced by the input value corresponding to that percentile
       -->
       多个不连续的百分位：返回一个结果数组，匹配<literal>fractions</literal>
       参数的模型，每个非空元素被对应于该分数的输入值替代
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--
   <para>
   All the aggregates listed in <xref linkend="functions-orderedset-table">
   ignore null values in their sorted input.  For those that take
   a <replaceable>fraction</replaceable> parameter, the fraction value must be
   between 0 and 1; an error is thrown if not.  However, a null fraction value
   simply produces a null result.
  </para>
-->
<para>
所有在<xref linkend="functions-orderedset-table">中列出的聚合都在它们的排序输入中忽略空值。
对于那些接受<replaceable>fraction</replaceable>参数的聚合，
该分数值必须介于0和1之间；如果不是的话会抛出一个错误。不过，
一个空的分数值会生成一个空的结果。
</para>

  <indexterm>
   <!--
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
   -->
   <primary>假想集聚合</primary>
   <secondary>内建</secondary>
  </indexterm>
  
<!--
   <para>
   Each of the aggregates listed in
   <xref linkend="functions-hypothetical-table"> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window">.  In each case, the aggregate result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows computed from the <replaceable>sorted_args</replaceable>.
  </para>
--> 
<para>
<xref linkend="functions-hypothetical-table">中列出的每个聚合都和
<xref linkend="functions-window">中定义的相同名字的窗口函数关联。
在不同情况下，聚合结果是根据<replaceable>args</replaceable>
构造的<quote>hypothetical</>行返回的关联窗口函数的值，
如果这样的一行已经添加到<replaceable>sorted_args</replaceable>
计算而来的排序行组中。
</para> 
  
  <table id="functions-hypothetical-table">
   <!--
   <title>Hypothetical-Set Aggregate Functions</title>
   -->
   <title>假想集聚合函数</title>

   <tgroup cols="5">
    <thead>
     <row>
      <!-- 
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      -->
      <entry>函数</entry>
      <entry>直接参数类型</entry>
      <entry>聚合的参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
       <!--
       rank of the hypothetical row, with gaps for duplicate rows
       -->
       假设行的排列，重复的行为空白
      </entry>
     </row>
     
     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
       <!--
       rank of the hypothetical row, without gaps
       -->
       假设行的排列，没有空白
      </entry>
     </row>     
     
     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <!--
       relative rank of the hypothetical row, ranging from 0 to 1
       -->
       假设行的相对排列，从0到1
      </entry>    
     </row>
     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <!-- 
       relative rank of the hypothetical row, ranging from
       1/<replaceable>N</> to 1
       -->
       假设行的相对排列，从1/<replaceable>N</>到1
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!-- 
  <para>
   For each of these hypothetical-set aggregates, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</> clause.
  </para>
-->
<para>
对于每个这些假想集聚合，<replaceable>args</replaceable>
中给出的直接参数列表必须匹配<replaceable>sorted_args</replaceable>
中给出的聚合参数的数量和类型。不像大多数内建聚合，这些聚合是非直接的，
它们不抛弃包含空值的输入行。空值根据<literal>ORDER BY</>
子句中指定的规则排序。
</para>
 </sect1>

 <sect1 id="functions-window">
  <!-- 
  <title>Window Functions</title> 
  -->
  <title>窗口函数</title>

  <indexterm zone="functions-window">
   <!-- 
   <primary>window function</primary>
   <secondary>built-in</secondary> 
   -->
   <primary>窗口函数</primary>
   <secondary>内建</secondary>
  </indexterm>

  <!--
<para>
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"> for syntax
   details.
   </para>
-->
<para>
<firstterm>窗口函数</firstterm>提供跨行相关的当前查询行集执行计算的能力。
参阅<xref linkend="tutorial-window">获取这个特性的介绍，
参阅<xref linkend="syntax-window-functions">获取语法细节。
</para>

  <!--
<para>
   The built-in window functions are listed in
   <xref linkend="functions-window-table">.  Note that these functions
   <emphasis>must</> be invoked using window function syntax; that is an
   <literal>OVER</> clause is required.
  </para>
-->
<para>
<xref linkend="functions-window-table">列出了内建的窗口函数。
注意<emphasis>必须</>使用窗口函数的语法调用这些函数；一个<literal>OVER</>子句是必需的。
</para>

  <!--
<para>
   In addition to these functions, any built-in or user-defined normal
   aggregate function (but not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</>
   clause follows the call; otherwise they act as regular aggregates.
  </para>
-->
<para>
除了这些函数外，任何内建的或用户定义的普通聚合函数（但不是顺序集或假想集聚合）
都可以作为窗口函数；参见<xref linkend="functions-aggregate">获取内建聚合函数的列表。
仅当调用跟着<literal>OVER</>子句的聚合函数，作为窗口函数；否则它们作为常规的聚合。
</para>

  <table id="functions-window-table">
   <!-- 
   <title>General-Purpose Window Functions</title> 
   -->
   <title>通用窗口函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry> 
  -->
  <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <!-- 
  <entry>number of the current row within its partition, counting from 1</entry> 
  -->
  <entry>在其分区中的当前行号，从1计</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <!--
  <entry>rank of the current row with gaps; same as <function>row_number</> of its first peer</entry>
  -->
  <entry>有间隔的当前行排名；与它的第一个相同行的<function>row_number</>相同</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <!-- 
  <entry>rank of the current row without gaps; this function counts peer groups</entry> 
  -->
  <entry>没有间隔的当前行排名；这个函数计数对等组。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!-- 
  <entry>relative rank of the current row: (<function>rank</> - 1) / (total rows - 1)</entry> 
  -->
  <entry>当前行的相对排名: (<function>rank</> - 1) / (总行数 - 1)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <!--
  <entry>relative rank of the current row: (number of rows preceding or peer with current row) / (total rows)</entry>
  -->
  <entry>当前行的相对排名：(前面的行数或与当前行相同的行数)/(总行数)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <!-- 
  <entry>integer ranging from 1 to the argument value, dividing the
       partition as equally as possible</entry> 
   -->
   <entry>从1到参数值的整数范围，尽可能相等的划分分区。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
         lag(<replaceable class="parameter">value</replaceable> <type>any</>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</>
             [, <replaceable class="parameter">default</replaceable> <type>any</> ]])
       </function>
      </entry>
      <!-- 
  <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows before the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>.
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
      </entry> 
  -->
  <entry>
       <type>类型同 <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       计算分区当前行的前<replaceable class="parameter">offset</replaceable>
   行，返回<replaceable class="parameter">value</replaceable> 。如果没有这样的行，
   返回<replaceable class="parameter">default</replaceable>替代。
   <replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>
   都是当前行计算的结果。如果忽略了，则<replaceable class="parameter">offset</replaceable>
   默认是1，<replaceable class="parameter">default</replaceable>默认是 null。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
         lead(<replaceable class="parameter">value</replaceable> <type>any</>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</>
              [, <replaceable class="parameter">default</replaceable> <type>any</> ]])
       </function>
      </entry>
  <!-- 
  <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows after the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>.
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
      </entry>
  -->
    <entry>
       <type>类型同<replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       计算分区当前行的后<replaceable class="parameter">offset</replaceable>行，
   返回<replaceable class="parameter">value</replaceable>。如果没有这样的行，
   返回<replaceable class="parameter">default</replaceable>替代。
  <replaceable class="parameter">offset</replaceable>和<replaceable class="parameter">default</replaceable>
  都是当前行计算的结果。如果忽略了，则<replaceable class="parameter">offset</replaceable>
  默认是1，<replaceable class="parameter">default</replaceable>默认是 null。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <!-- 
  <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the first row of the window frame
      </entry> 
  -->
  <entry>
       <type>类型同<replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
      返回窗口第一行的计算<replaceable class="parameter">value</replaceable>值。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <!-- 
  <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the last row of the window frame
      </entry> 
  -->
  <entry>
       <type>类型同<replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
      返回窗口最后一行的计算<replaceable class="parameter">value</replaceable>值。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</>, <replaceable class="parameter">nth</replaceable> <type>integer</>)
       </function>
      </entry>
      <!-- 
  <entry>
       <type>same type as <replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the <replaceable class="parameter">nth</replaceable>
       row of the window frame (counting from 1); null if no such row
      </entry> 
  -->
  <entry>
       <type>类型同<replaceable class="parameter">value</replaceable></type>
      </entry>
      <entry>
      返回窗口第<replaceable class="parameter">nth</replaceable>行的计算
  <replaceable class="parameter">value</replaceable>值（行从1计数）；没有这样的行则返回 null。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   All of the functions listed in
   <xref linkend="functions-window-table"> depend on the sort ordering
   specified by the <literal>ORDER BY</> clause of the associated window
   definition.  Rows that are not distinct in the <literal>ORDER BY</>
   ordering are said to be <firstterm>peers</>; the four ranking functions
   are defined so that they give the same answer for any two peer rows.
  </para>
-->
<para>
在<xref linkend="functions-window-table">列出的所有函数，
依赖于与窗口定义有关的<literal>ORDER BY</>子句指定的排序。
<firstterm>同行</>是说在<literal>ORDER BY</>排序时不唯一的行。
定义的这四个排名函数，对于任何两个同行的答案相同。
</para>

  <!--
<para>
   Note that <function>first_value</>, <function>last_value</>, and
   <function>nth_value</> consider only the rows within the <quote>window
   frame</>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</> and
   sometimes also <function>nth_value</>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</> or
   <literal>ROWS</>) to the <literal>OVER</> clause.
   See <xref linkend="syntax-window-functions"> for more information
   about frame specifications.
  </para>
-->
<para>
注意<function>first_value</>，<function>last_value</>，和<function>nth_value</>
只考虑<quote>window frame</>内的行，其默认情况下，包含从分区的开始行直到当前行的最后同行。
像<function>last_value</>和<function>nth_value</>有时会给出没有用的结果。
您可以通过向<literal>OVER</>子句添加合适的框架规范（<literal>RANGE</>或者<literal>ROWS</>）
来重新定义该框架。参阅<xref linkend="syntax-window-functions">获取框架定义的信息。
</para>

  <!--
<para>
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</> and the default window frame
   definition produces a <quote>running sum</> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</>.
   Other frame specifications can be used to obtain other effects.
  </para>
-->
<para>
当一个聚合函数作为窗口函数使用时，将聚合超过当前行的窗框内的行。
一个使用<literal>ORDER BY</>和默认窗框定义处理<quote>运行时求和</>类型的行为的聚合函数，
可能不是想要的结果。为了获取超过整个分区聚合，忽略<literal>ORDER BY</>
或者使用<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</>。
其它窗框规格可以用来获取其它的效果。
</para>

  <note>
   <!--
<para>
    The SQL standard defines a <literal>RESPECT NULLS</> or
    <literal>IGNORE NULLS</> option for <function>lead</>, <function>lag</>,
    <function>first_value</>, <function>last_value</>, and
    <function>nth_value</>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</>.
    Likewise, the standard's <literal>FROM FIRST</> or <literal>FROM LAST</>
    option for <function>nth_value</> is not implemented: only the
    default <literal>FROM FIRST</> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</> by reversing the <literal>ORDER BY</>
    ordering.)
   </para>
-->
<para>
SQL 标准为<function>lead</>, <function>lag</>, <function>first_value</>, <function>last_value</>,
和<function>nth_value</>定义了一个<literal>RESPECT NULLS</>或<literal>IGNORE NULLS</>选项。
这个在<productname>PostgreSQL</productname>没有实现：行为总是与标准默认相同，即<literal>RESPECT NULLS</>。
同样用于<function>nth_value</>的标准<literal>FROM FIRST</>或<literal>FROM LAST</>
选项也没有实现：只支持默认<literal>FROM FIRST</>行为。
（您可以通过<literal>ORDER BY</>排序取反获取到<literal>FROM LAST</>的结果。）
</para>
  </note>

 </sect1>

 <sect1 id="functions-subquery">
  <!-- 
  <title>Subquery Expressions</title> 
  -->
  <title>子查询表达式</title>

  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>subquery</primary>
  </indexterm>

  <!--
<para>
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
-->
<para>
本节描述<productname>PostgreSQL</productname>里面与<acronym>SQL</acronym>
兼容的子查询表达式。所有本节中的表达式都返回布尔值(真/假)结果。
</para>

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</>.
  </para>
-->
<para>
<token>EXISTS</token>的参数是一个任意的<command>SELECT</>语句，或者说<firstterm>子查询</firstterm>。
系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么<token>EXISTS</token>的结果就为
<quote>真</>；如果子查询没有返回任何行，那么<token>EXISTS</token>的结果是<quote>假</>。
</para>

  <!--
<para>
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
  </para>
-->
<para>
子查询可以引用包围它的查询的变量，这些变量在该子查询的每一次计算中都起常量的作用。
</para>

  <!--
<para>
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
  </para>
-->
<para>
这个子查询通常只是运行到能判断它是否可以生成至少一行为止，而不是等到全部结束。
在这里写有副作用的子查询是不明智的(比如调用序列函数)；这些副作用是否发生是很难判断的。
</para>

  <!--
<para>
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
  </para>
-->
<para>
因为结果只取决于是否会返回行，而不取决于这些行的内容，
所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用下面的形式写
<literal>EXISTS</>测试：<literal>EXISTS(SELECT 1 WHERE ...)</literal>。
不过这条规则也有例外，比如那些使用<token>INTERSECT</token>的子查询。
</para>
  
<para>
<!--
   This simple example is like an inner join on <literal>col2</>, but
   it produces at most one output row for each <literal>tab1</> row,
   even if there are several matching <literal>tab2</> rows:
-->
下面这个简单的例子类似在<literal>col2</>上的一次内连接，
但是它为每个<literal>tab1</>的行生成最多一个输出，
即使存在多个匹配<literal>tab2</>的行也如此：
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</> if any equal subquery row is found.
   The result is <quote>false</> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
-->
<para>
右边是一个圆括弧括起来的子查询，它必须只返回一个字段。
左边表达式对子查询结果的每一行进行一次计算和比较。如果找到任何相等的子查询行，
则<token>IN</token>结果为<quote>真</>。如果没有找到任何相等行，则结果为<quote>假</>
(包括子查询没有返回任何行的情况)。
</para>

  <!--
<para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边行生成 NULL ，
那么<token>IN</token>的结果将是 NULL ，而不是假。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>

  <!--
<para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
-->
<para>
和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
</para>

<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</> if any equal subquery row is found.
   The result is <quote>false</> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
-->
<para>
左边是一个行构造器(如<xref linkend="sql-syntax-row-constructors">所述)，右边是一个圆括弧括起来的子查询，
它必须返回和左边行构造器一样多的字段。左边表达式对子查询结果的每一行进行一次计算和比较。
如果找到相等的子查询行，则<token>IN</token>结果为<quote>真</>。如果没有找到任何相等行，
则结果为<quote>假</>(包括子查询没有返回任何行的情况)。
</para>

  <!--
<para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
  </para>
-->
<para>
表达式或子查询行里的 NULL 遵照 SQL 处理布尔值和 NULL 组合时的规则。
如果两个行对应的字段都相等且非空，那么这两行相等；如果任意对应字段不等且非空，
那么这两行不等；否则结果是未知(NULL)。如果每一行的结果都是不等或 NULL ，
并且至少有一个 NULL ，那么<token>IN</token>的结果是 NULL 。
</para>
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</> if any equal row is found.
  </para>
-->
<para>
右边是一个圆括弧括起来的子查询，它必须只返回一个字段。
左边表达式对子查询结果的每一行进行一次计算和比较。如果只找到不相等的子查询行
(包括子查询没有返回任何行的情况)，则<token>NOT IN</token>结果为<quote>真</>。
如果找到任何相等行，则结果为<quote>假</>。
</para>
  <!--
<para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边行生成 NULL ，
那么<token>NOT IN</token>的结果将是 NULL ，而不是真。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>

  <!--
<para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
-->
<para>
和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
</para>

<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</> if any equal row is found.
  </para>
-->
<para>
左边是一个行构造器(如<xref linkend="sql-syntax-row-constructors">所述)，
右边是一个圆括弧括起来的子查询，它必须返回和左边行构造器一样多的字段。
左边表达式对子查询结果的每一行进行一次计算和比较。如果只出现不相等的子查询行，
则<token>NOT IN</token>结果为<quote>真</>。(包括子查询没有返回任何行的情况)。
如果找到相等的子查询行，则结果为<quote>假</>。
</para>

  <!--
<para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
  </para>
-->
<para>
表达式或子查询行里的 NULL 遵照 SQL 处理布尔值和 NULL 组合时的规则。
如果两个行对应的字段都相等且非空，那么这两行相等；如果任意对应字段不等且非空，
那么这两行不等；否则结果是未知(NULL)。如果每一行的结果都是不等或 NULL ，
并且至少有一个 NULL ，那么<token>NOT IN</token>的结果是 NULL 。
</para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</> if any true result is obtained.
   The result is <quote>false</> if no true result is found (including the
   case where the subquery returns no rows).
  </para>
-->
<para>
右边是一个圆括弧括起来的子查询，它必须只返回一个字段。
左边表达式使用<replaceable>operator</replaceable>对子查询结果的每一行进行一次计算和比较，
其结果必须是布尔值。如果至少获得一个真值，则<token>ANY</token>结果为<quote>真</>。
如果全部获得假值，则结果是<quote>假</>(包括子查询没有返回任何行的情况)。
</para>

  <!--
<para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
  </para>
-->
<para>
<token>SOME</token>是<token>ANY</token>的同意词。<token>IN</token>等效于<literal>= ANY</literal>。
</para>

  <!--
<para>
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
请注意，如果没有获得任何真值并且至少有一个右边行在该操作符上生成 NULL ，
那么<token>ANY</token>的结果将是 NULL ，而不是假。
这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>

  <!--
<para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
-->
<para>
和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
</para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</> if the comparison
   returns true for any subquery row.
   The result is <quote>false</> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if the comparison does not return true for any row,
   and it returns NULL for at least one row.
  </para>
-->
<para>
左边是一个行构造器(如<xref linkend="sql-syntax-row-constructors">所述)，
右边是一个圆括弧括起来的子查询，它必须返回和左边行构造器一样多的字段。
左边表达式使用<replaceable>operator</replaceable>对子查询结果的每一行进行一次计算和比较。
如果至少获得一个真值，则<token>ANY</token>结果为<quote>真</>。
如果全部获得假值，则结果是<quote>假</>(包括子查询没有返回任何行的情况)。
如果没有获得任何真值并且至少有一个行返回 NULL ，那么结果将是 NULL。
</para>

  <!--
<para>
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
  </para>
-->
<para>
查看<xref linkend="row-wise-comparison">获取关于行构造比较含义的细节。
</para>
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</> if any false result is found.
   The result is NULL if the comparison does not return false for any row,
   and it returns NULL for at least one row.
  </para>
-->
<para>
右边是一个圆括弧括起来的子查询，它必须只返回一个字段。
左边表达式使用<replaceable>operator</replaceable>对子查询结果的每一行进行一次计算和比较，
其结果必须是布尔值。如果全部获得真值，<token>ALL</token>结果为<quote>真</>
(包括子查询没有返回任何行的情况)。如果至少获得一个假值，则结果是<quote>假</>。
如果比较不会返回任何假值，并且至少一个行返回 NULL，则结果为 NULL。
</para>

  <!--
<para>
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
  </para>
-->
<para>
<token>NOT IN</token>等效于<literal>&lt;&gt; ALL</literal>。
</para>

  <!--
<para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
-->
<para>
和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
</para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</> if the comparison returns false for any
   subquery row.
   The result is NULL if the comparison does not return false for any
   subquery row, and it returns NULL for at least one row.
  </para>
-->
<para>
左边是一个行构造器(如<xref linkend="sql-syntax-row-constructors">所述)，
右边是一个圆括弧括起来的子查询，它必须返回和左边行构造器一样多的字段。
左边表达式使用 <replaceable>operator</replaceable>对子查询结果的每一行进行一次计算和比较。
如果全部获得真值，<token>ALL</token>结果为<quote>真</>
(包括子查询没有返回任何行的情况)。如果至少获得一个假值，则结果是<quote>假</>。
如果比较不会返回任何假值，并且至少一个行返回 NULL，则结果为 NULL。
</para>

  <!--
<para>
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
  </para>
-->
<para>
查看<xref linkend="row-wise-comparison">以获取关于行构造比较含义的细节。
</para>
  </sect2>

  <sect2>
   <!-- 
   <title>Single-row Comparison</title> 
   -->
   <title>单行比较</title>

   <indexterm zone="functions-subquery">
    <!-- 
<primary>comparison</primary>
    <secondary>subquery result row</secondary> 
-->
<primary>比较</primary>
    <secondary>子查询结果行</secondary>
   </indexterm>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

  <!--
<para>
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
  </para>
-->
<para>
左边是一个行构造器(如<xref linkend="sql-syntax-row-constructors">所述)，
右边是一个圆括弧括起来的子查询，它必须返回和左边行构造器一样多的字段。
而且，该子查询不能返回超过 1 行结果(返回零行相当于 NULL)。
左边表达式对子查询的唯一结果行进行计算和比较。
</para>

  <!--
<para>
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
  </para>
-->
<para>
查看<xref linkend="row-wise-comparison">以获取关于行构造比较含义的细节。
</para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
  <!-- 
  <title>Row and Array Comparisons</title> 
  -->
  <title>行和数组比较</title>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <!--
   <primary>composite type</primary>
   <secondary>comparison</secondary>
   -->
   <primary>复合类型</primary>
   <secondary>比较</secondary>
  </indexterm>

  <indexterm>
  <!-- 
   <primary>row-wise comparison</primary> 
   -->
   <primary>逐行比较</primary>
  </indexterm>

  <indexterm>
   <!-- 
   <primary>comparison</primary>
   <secondary>composite type</secondary>
   -->
   <primary>比较</primary>
   <secondary>复合类型</secondary>
  </indexterm>

  <indexterm>
   <!--
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
   -->
   <primary>比较</primary>
   <secondary>行构造函数</secondary>
  </indexterm>

  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

  <!--
<para>
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
-->
<para>
本节描述几个特殊的构造，用于在多组值之间进行多重比较。
这些形式语法上和上一节的子查询形式相关，但是不涉及子查询。
这种形式涉及的数组子表达式是<productname>PostgreSQL</productname>的扩展；
其它的是<acronym>SQL</acronym>兼容的。所有本节记录的表达式形式都返回布尔值(真/假)。
</para>

  <sect2>
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<para>
<!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for
-->
右边是一个圆括弧包围的标量列表。如果左边的表达式结果等于任何右边表达式中的一个，
结果为<quote>真</>。它是下面这种方式的缩写
<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>
  <!--
<para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边表达式的值为 NULL ，
那么<token>IN</token>的结果将是 NULL ，而不是假。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
 
<para>
 <!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for
-->
右边是一个圆括弧包围的标量列表。如果左边的表达式结果不等于任何右边表达式，结果为<quote>真</quote>。
它是下面这种方式的缩写
<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>
  <!--
<para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边表达式的值为 NULL ，
那么<token>NOT IN</token>的结果将是 NULL ，而不是真。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>

  <tip>
  <!--
<para>
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
  </para>
-->
<para>
<literal>x NOT IN y</literal>在所有场合都等价于<literal>NOT (x IN y)</literal>。
但是，在处理 NULL 的时候，用<token>NOT IN</token>比用<token>IN</token>更容易迷惑新手。
最好用正逻辑来表达你的条件。
</para>
  </tip>
  </sect2>

  <sect2>
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</> if any true result is obtained.
   The result is <quote>false</> if no true result is found (including the
   case where the array has zero elements).
  </para>
-->
<para>
右边是一个圆括弧包围的表达式，它必须生成一个数组值。左边表达式使用<replaceable>operator</replaceable>
对数组的每一个元素进行一次计算和比较，其结果必须是布尔值。如果至少获得一个真值，
则<token>ANY</token>结果为<quote>真</>。如果全部获得假值，则结果是<quote>假</>
(包括数组不含任何元素的情况)。
</para>

  <!--
<para>
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
如果数组表达式的值为 NULL ，那么<token>ANY</token>的结果也为 NULL 。
如果左边表达式的值为 NULL ，那么<token>ANY</token>的结果通常也为 NULL
(某些不严格的比较操作符可能得到不同的结果)。另外，
如果右边的数组表达式中包含 NULL 元素并且没有为真的比较结果，
那么<token>ANY</token>的结果将是 NULL(某些不严格的比较操作符可能得到不同的结果)，
而不是假。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>

  <!--
<para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
  </para>
-->
<para>
<token>SOME</token>是<token>ANY</token>的同意词。
</para>
  </sect2>

  <sect2>
   <title><literal>ALL</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

  <!--
<para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</> if any false result is found.
  </para>
-->
<para>
右边是一个圆括弧包围的表达式，它必须生成一个数组值。左边表达式使用<replaceable>operator</replaceable>
对数组的每一个元素进行一次计算和比较，其结果必须是布尔值。如果全部获得真值，<token>ALL</token>
结果为<quote>真</>(包括数组不含任何元素的情况)。如果至少获得一个假值，则结果是<quote>假</>。
</para>

  <!--
<para>
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
-->
<para>
如果数组表达式的值为 NULL ，那么<token>ALL</token>的结果也为 NULL 。
如果左边表达式的值为 NULL ，那么<token>ALL</token>的结果通常也为 NULL
(某些不严格的比较操作符可能得到不同的结果)。另外，
如果右边的数组表达式中包含 NULL 元素并且没有为假的比较结果，那么<token>ALL</token>
的结果将是 NULL(某些不严格的比较操作符可能得到不同的结果)，而不是真。
这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。
</para>
  </sect2>

  <sect2 id="row-wise-comparison">
   <!-- 
   <title>Row Constructor Comparison</title> 
   -->
   <title>行构造器比较</title>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

  <!--
<para>
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The two row values must have the same number of fields.
   Each side is evaluated and they are compared row-wise.  Row constructor
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</>,
   <literal>&lt;&gt;</>,
   <literal>&lt;</>,
   <literal>&lt;=</>,
   <literal>&gt;</> or
   <literal>&gt;=</>.
   Every row element must be of a type which has a default B-tree operator
   class or the attempted comparison may generate an error.
  </para>
-->
<para>
两边都是一个<xref linkend="sql-syntax-row-constructors">所述的行构造器；
两个行的字段数必须相同。两边都被计算并且逐行比较。目前，行构造器比较的
<replaceable>operator</replaceable>操作符仅允许为 <literal>=</>, <literal>&lt;&gt;</>,
 <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</>或<literal>&gt;=</>。
每个行元素必须是有缺省B-tree操作符类的类型，否则尝试比较可能会产生错误。
</para>
  <note>
<!-- 
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para> 
-->
<para>
如果比较使用较早的字段解决，那么与元素的数量或类型相关的错误可能不会发生。
</para>
  </note>
  <!--
<para>
   The <literal>=</> and <literal>&lt;&gt;</> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
  </para>
-->
<para>
<literal>=</>和<literal>&lt;&gt;</>与其它操作符稍有区别。如果两行对应的元素全都非空且相等，
那么这两行就被认为是相等的；如果两行对应的元素中有任意一对非空且不等，
那么这两行就被认为是不等的；否则这两行的比较结果是未知(NULL)。
</para>

  <!--
<para>
   For the <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</> and
   <literal>&gt;=</> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</>
   yields true, not null, because the third pair of elements are not
   considered.
  </para>
-->
<para>
对于 <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</>, <literal>&gt;=</>操作符，
行中的元素将按照从左到右的顺序依次进行比较，直到遇见一对不相等的元素或者一对 NULL 值。
如果这对元素中存在至少一个 NULL 值，那么比较的结果是 NULL ；
否则这对元素的比较结果就是最终的比较结果。例如，<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</>
的结果是真而不是 NULL ，因为比较到第二对元素的时候就已经得到了最终结果，不需要对第三对元素进行比较了。
</para>

  <note>
   <!--
<para>
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</> and <literal>&gt;=</>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</>
    was implemented as
    <literal>a &lt; c AND b &lt; d</>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</>.
   </para>
-->
<para>
在<productname>PostgreSQL</productname> 8.2之前，<literal>&lt;</>, <literal>&lt;=</>,
 <literal>&gt;</>, <literal>&gt;=</>并不遵守 SQL 标准。比如，<literal>ROW(a,b) &lt; ROW(c,d)</>
将等价于<literal>a &lt; c AND b &lt; d</>，而正确的做法应当是等价于<literal>a &lt; c OR (a = c AND b &lt; d)</>。
</para>
  </note>

<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <!--
<para>
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
  </para>
-->
<para>
这个构造类似于<literal>&lt;&gt;</literal>行比较，但是它对 NULL 输入不生成 NULL ，
而是认为任何 NULL 都不等于任何非 NULL ，并且 NULL 之间是相等的。因此，
结果要么是真要么是假，而绝不会是未知(NULL)。
</para>

<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <!--
<para>
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
  </para>
-->
<para>
这个构造类似于<literal>=</literal>行比较，但是它对 NULL 输入不生成 NULL ，
而是认为任何 NULL 都不等于任何非 NULL ，并且 NULL 之间是相等的。
因此，结果要么是真要么是假，而绝不会是未知(NULL)。
</para>

  </sect2>

  <sect2 id="composite-type-comparison">
   <!--
   <title>Composite Type Comparison</title>
   -->
   <title>复合类型比较</title>

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

   <!--
<para>
    The SQL specification requires row-wise comparison to return NULL if the
    result depends on comparing two NULL values or a NULL and a non-NULL.
    <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison">) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery">).
    In other contexts where two composite-type values are compared, two
    NULL field values are considered equal, and a NULL is considered larger
    than a non-NULL.  This is necessary in order to have consistent sorting
    and indexing behavior for composite types.
   </para>
-->
<para>
如果结果依赖于比较两个NULL值或一个NULL值和一个非NULL值，SQL 规范要求逐行比较返回 NULL。
<productname>PostgreSQL</productname>仅当比较两个行构造的结果（就像<xref linkend="row-wise-comparison">
中描述的那样）或一个行构造器和子查询的输出时这样做
(就像<xref linkend="functions-subquery">描述的那样)。在其它情况下，两个复合类型的值进行比较，
认为两个NULL字段值是相等的，并且NULL大于非NULL。这是必要的，如此才能有一致的排序和复合类型的索引行为。
</para>

<!-- 
  <para>
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</>,
   <literal>&lt;&gt;</>,
   <literal>&lt;</>,
   <literal>&lt;=</>,
   <literal>&gt;</> or
   <literal>&gt;=</>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison">).
  </para>
-->
<para>
每一方都要评估并且它们是逐行比较的。仅在<replaceable>operator</replaceable>
是<literal>=</>、<literal>&lt;&gt;</>、<literal>&lt;</>、<literal>&lt;=</>、
<literal>&gt;</>或<literal>&gt;=</>，或具有相似语义的操作符时允许比较复合类型。
（具体来说，一个操作符可以是一个行比较操作符，如果它是B-tree操作符类的一员，
或者是B-tree操作符类<literal>=</>成员的否定。）以上操作符在行构造器上的缺省行为和
<literal>IS [ NOT ] DISTINCT FROM</literal>是相同的
（参阅<xref linkend="row-wise-comparison">）。
</para>
<!-- 
  <para>
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</>,
   <literal>*&lt;&gt;</>,
   <literal>*&lt;</>,
   <literal>*&lt;=</>,
   <literal>*&gt;</>, and
   <literal>*&gt;=</>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally for
   materialized views and might be useful for other specialized purposes
   such as replication but are not intended to be generally useful for
   writing queries.
  </para>
-->
<para>
为了支持包含没有缺省B-tree操作符类的元素的行匹配，为复合类型比较定义了下列操作符：
<literal>*=</>、<literal>*&lt;&gt;</>、<literal>*&lt;</>、<literal>*&lt;=</>、
<literal>*&gt;</>和<literal>*&gt;=</>。这些操作符比较两行的内部二进制表示。
两行可能有不同的二进制表示，即使用等号操作符比较两行返回真。
这些比较操作符下的行排序是动态的，但是没什么意义。
这些操作符内部的用于物化视图，并且可能对于其他特殊用途，
比如替换有用，但是并不打算用于普通的写查询。
</para>
  </sect2>
 </sect1>

 <sect1 id="functions-srf">
  <!-- 
  <title>Set Returning Functions</title> 
  -->
  <title>返回集合的函数</title>

  <indexterm zone="functions-srf">
   <!-- 
   <primary>set returning functions</primary>
   <secondary>functions</secondary> 
   -->
   <primary>返回集合的函数</primary>
   <secondary>函数</secondary>
  </indexterm>

  <indexterm>
   <primary>generate_series</primary>
  </indexterm>

  <!--
<para>
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"> and
   <xref linkend="functions-srf-subscripts">.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"> for ways to combine multiple
   set-returning functions.
   </para>
-->
<para>
本节描述那些可能返回多于一行的函数。在这个类中最广泛使用的函数是序列号生成函数，
如<xref linkend="functions-srf-series">和<xref linkend="functions-srf-subscripts">所述。
另外，更专业的集合返回函数在这个手册的其他地方描述。
参阅<xref linkend="queries-tablefunctions">获取组合多个设置返回函数的方法。
</para>

  <table id="functions-srf-series">
   <!-- 
   <title>Series Generating Functions</title>
   -->
   <title> 序列号生成函数</title>
   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry> 
  -->
  <entry>函数</entry>
      <entry>参数类型</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
      <!-- 
  <entry><type>int</type> or <type>bigint</type></entry>
      <entry><type>setof int</type> or <type>setof bigint</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of one
      </entry> 
  -->
  <entry><type>int</type> 或 <type>bigint</type></entry>
      <entry><type>setof int</type> 或 <type>setof bigint</type> (与参数类型相同)</entry>
      <entry>
       生成一个数值序列，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为 1 。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
      <!-- 
  <entry><type>int</type> or <type>bigint</type></entry>
      <entry><type>setof int</type> or <type>setof bigint</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
      </entry> 
  -->
  <entry><type>int</type> 或 <type>bigint</type></entry>
      <entry><type>setof int</type> 或 <type>setof bigint</type> (与参数类型相同)</entry>
      <entry>
        生成一个数值序列，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</>)</function></literal></entry>
      <!-- 
  <entry><type>timestamp</type> or <type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type> or <type>setof timestamp with time zone</type> (same as argument type)</entry>
      <entry>
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
      </entry> 
  -->
  <entry><type>timestamp</type> 或 <type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type> 或 <type>setof timestamp with time zone</type> (与参数类型相同)</entry>
      <entry>
       生成一个数值序列，从<parameter>start</parameter>到<parameter>stop</parameter>，步长为<parameter>step</parameter>。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<para>
<!--
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned for <literal>NULL</literal> inputs. It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
-->
如果<parameter>step</parameter>是正数且<parameter>start</parameter>大于<parameter>stop</parameter>，
那么返回零行。相反，如果<parameter>step</parameter>是负数且<parameter>start</parameter>
小于<parameter>stop</parameter>，那么也返回零行。如果输入是<literal>NULL</literal>，同样产生零行。
<parameter>step</parameter>为零则是一个错误。下面是一些例子：
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

-- this example relies on the date-plus-integer operator
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>


  <table id="functions-srf-subscripts">
   <!-- 
   <title>Subscript Generating Functions</title> 
   -->
   <title>下标生成函数</title>
   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry> 
  -->
  <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <!-- 
  <entry>
       Generate a series comprising the given array's subscripts.
      </entry> 
  -->
  <entry>
       生成一系列包括给定数组的下标。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <!-- 
  <entry>
       Generate a series comprising the given array's subscripts. When
       <parameter>reverse</parameter> is true, the series is returned in
       reverse order.
      </entry> 
  -->
  <entry>
       生成一系列包括给定数组的下标。当<parameter>reverse</parameter>为真时，
   该系列则以相反的顺序返回。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>
  
<para>
<!--
   <function>generate_subscripts</> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or for NULL arrays (but valid subscripts are returned for NULL array
   elements).  Some examples follow:
-->
<function>generate_subscripts</>是一个为给定数组中的指定维度生成有效下标集的便利函数。
如果数组中没有所请求的维度或者NULL数组，返回0行（但是会给数组元素为空的返回有效下标）。
下面一些例子：
<programlisting>
-- basic usage
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

-- presenting an array, the subscript and the subscripted
-- value requires a subquery
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- unnest a 2D array
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>

  <indexterm>
   <primary>ordinality</primary>
  </indexterm>

  <para>
<!-- 
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the output which starts from 1 and increments by 1 for each row
   of the function's output.  This is most useful in the case of set returning
   functions such as <function>unnest()</>.
-->
当<literal>FROM</literal>子句中的一个函数带有<literal>WITH ORDINALITY</literal>
前缀时，一个<type>bigint</type>字段添加到输出中，该字段从1开始增长，步长为1。
这在设置返回函数比如<function>unnest()</>的情况下非常有用。

<programlisting>
-- set returning function WITH ORDINALITY
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_clog         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_xlog         | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>
 </sect1>

 <sect1 id="functions-info">
  <!-- 
  <title>System Information Functions</title> 
  -->
  <title>系统信息函数</title>

  <!--
<para>
   <xref linkend="functions-info-session-table"> shows several
   functions that extract session and system information.
  </para>
-->
<para>
<xref linkend="functions-info-session-table">显示了几个抽取会话及系统信息的函数。
</para>

  <!--
<para>
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-views"> for more
   information.
  </para>
-->
<para>
另外在本节所列出的函数，有一些函数有关统计系统，也提供系统信息。
参阅<xref linkend="monitoring-stats-views">获取更多信息。
</para>

   <table id="functions-info-session-table">
    <!-- 
<title>Session Information Functions</title> 
-->
<title>会话信息函数</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>name of current database (called <quote>catalog</quote> in the SQL standard)</entry> 
   -->
   <entry>当前数据库名（在SQL标准里叫<quote>catalog</quote>）</entry>
      </row>

      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>name of current database</entry> 
   -->
   <entry>当前数据库名</entry>
      </row>

      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>text of the currently executing query, as submitted
       by the client (might contain more than one statement)</entry> 
   -->
   <entry>当前执行的查询文本，由客户端提交（可能包含多于1句）</entry>
      </row>

      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>name of current schema</entry> 
   -->
   <entry>当前模式名</entry>
      </row>

      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
       <!-- 
   <entry>names of schemas in search path, optionally including implicit schemas</entry> 
   -->
   <entry>搜索路径中的模式名字，包括可选的隐式模式</entry>
      </row>

      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>user name of current execution context</entry> 
   -->
   <entry>当前执行环境下的用户名</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <!-- 
   <entry>address of the remote connection</entry> 
   -->
   <entry>连接的远端地址</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>port of the remote connection</entry> 
   -->
   <entry>连接的远端端口</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <!-- 
   <entry>address of the local connection</entry> 
   -->
   <entry>连接的本地地址</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>port of the local connection</entry> 
   -->
   <entry>连接的本地端口</entry>
      </row>

      <row>
       <!-- See also the entry for this in monitoring.sgml -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>
        Process ID of the server process attached to the current session
       </entry> 
   -->
   <entry>
        连接到当前会话的服务器进程 ID
       </entry>
      </row>

      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <!-- 
   <entry>configuration load time</entry> 
   -->
   <entry>配置加载时间</entry>
      </row>

      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is schema another session's temporary schema?</entry> 
   -->
   <entry>是否为另一个会话的临时模式?</entry>
      </row>

      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
       <!-- 
   <entry>channel names that the session is currently listening on</entry> 
   -->
   <entry>正在侦听的当前会话的信道名称</entry>
      </row>

      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
       <!-- 
   <entry>OID of session's temporary schema, or 0 if none</entry> 
   -->
   <entry>会话的临时模式的OID，不存在则为 0</entry>
      </row>

      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <!-- 
   <entry>server start time</entry> 
   -->
   <entry>服务器启动时间</entry>
      </row>

      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>current nesting level of <productname>PostgreSQL</> triggers
       (0 if not called, directly or indirectly, from inside a trigger)</entry> 
   -->
   <entry><productname>PostgreSQL</> 触发器的当前嵌套级别
   （如果没有直接或间接的从一个触发器内部调用，那么是0）
       </entry>
      </row>

      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>session user name</entry> 
   -->
   <entry>会话用户名</entry>
      </row>

      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>equivalent to <function>current_user</function></entry> 
   -->
   <entry>等价于 <function>current_user</function></entry>
      </row>

      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry><productname>PostgreSQL</> version information</entry> 
   -->
   <entry><productname>PostgreSQL</> 版本信息</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <!--
<para>
     <function>current_catalog</function>, <function>current_schema</function>,
     <function>current_user</function>, <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  (In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.)
    </para>
-->
<para>
<function>current_catalog</function>, <function>current_schema</function>,
<function>current_user</function>, <function>session_user</function>,
和<function>user</function>在<acronym>SQL</acronym>里有特殊的语法：
调用他们时结尾不能跟圆括号。（在 PostgreSQL，<function>current_schema</function>
可选的可以有括号，但是其它的不能。）
</para>
   </note>

   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>

   <indexterm>
    <primary>current_database</primary>
   </indexterm>

   <indexterm>
    <primary>current_query</primary>
   </indexterm>

   <indexterm>
    <primary>current_schema</primary>
   </indexterm>

   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>

   <indexterm>
    <primary>current_user</primary>
   </indexterm>

   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>schema</primary>
    <secondary>current</secondary> 
-->
<primary>模式</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>search path</primary>
    <secondary>current</secondary> 
-->
<primary>搜索路径</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>session_user</primary> 
-->
<primary>会话用户</primary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>user</primary>
    <secondary>current</secondary>
-->
<primary>用户</primary>
    <secondary>当前</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>user</primary> 
-->
<primary>用户</primary>
   </indexterm>

   <!--
<para>
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization">.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role">.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
   </para>
-->
<para>
<function>session_user</function>通常是连接当前数据库的初始用户，
不过超级用户可以用<xref linkend="sql-set-session-authorization">修改这个设置。
<function>current_user</function>是用于权限检查的用户标识。通常，它总是等于会话用户，
但是可以通过<xref linkend="sql-set-role">改变它。
在函数执行的过程中随着属性<literal>SECURITY DEFINER</literal>的改变，其值也会改变。
用 Unix 术语来说，会话用户是<quote>真实用户</quote>，而当前用户是<quote>有效用户</quote>。
</para>

   <!--
<para>
    <function>current_schema</function> returns the name of the schema that is
    first in the search path (or a null value if the search path is
    empty).  This is the schema that will be used for any tables or
    other named objects that are created without specifying a target schema.
    <function>current_schemas(boolean)</function> returns an array of the names of all
    schemas presently in the search path.  The Boolean option determines whether or not
    implicitly included system schemas such as <literal>pg_catalog</> are included in the
    returned search path.
   </para>
-->
<para>
<function>current_schema</function>返回在搜索路径前端的模式名字(如果搜索路径为空则返回 NULL)。
如果创建表或者其它命名对象时没有声明目标模式，那么它将是用于这些对象的模式。
<function>current_schemas(boolean)</function>返回一个搜索路径中所有模式名字的数组。
布尔选项决定像<literal>pg_catalog</>这样隐含包含的系统模式是否包含在返回的搜索路径中。
</para>

   <note>
    
<para>
<!--
     The search path can be altered at run time.  The command is:
-->
搜索路径可以通过运行时设置更改。命令是：
<programlisting>
SET search_path TO <replaceable>schema</> <optional>, <replaceable>schema</>, ...</optional>
</programlisting>
    </para>
   </note>

   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>

   <!--
<para>
    <function>pg_listening_channels</function> returns a set of names of
    channels that the current session is listening to.  See <xref
    linkend="sql-listen"> for more information.
   </para>
-->
<para>
<function>pg_listening_channels</function>返回当前会话正在监听的一组信道名称。
见<xref linkend="sql-listen">获取更多信息。
</para>

   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>

   <!--
<para>
     <function>inet_client_addr</function> returns the IP address of the
     current client, and <function>inet_client_port</function> returns the
     port number.
     <function>inet_server_addr</function> returns the IP address on which
     the server accepted the current connection, and
     <function>inet_server_port</function> returns the port number.
     All these functions return NULL if the current connection is via a
     Unix-domain socket.
   </para>
-->
<para>
<function>inet_client_addr</function>返回当前客户端的IP地址，
而<function>inet_client_port</function>则返回当前客户端的端口号。
<function>inet_server_addr</function>返回服务器接收当前连接用的 IP 地址，
而<function>inet_server_port</function>返回接收当前连接的端口号。
如果是通过 Unix-domain socket 连接的，那么所有这些函数都返回 NULL 。
</para>

   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>

   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>

   <!--
<para>
    <function>pg_my_temp_schema</function> returns the OID of the current
    session's temporary schema, or zero if it has none (because it has not
    created any temporary tables).
    <function>pg_is_other_temp_schema</function> returns true if the
    given OID is the OID of another session's temporary schema.
    (This can be useful, for example, to exclude other sessions' temporary
    tables from a catalog display.)
   </para>
-->
<para>
<function>pg_my_temp_schema</function>返回当前会话的临时模式 OID ，
如果不存在的话则返回 0(因为没有创建任何临时表)。<function>pg_is_other_temp_schema</function>
返回给定的 OID 是否为其它会话的临时模式 OID ，这个函数是有实用价值的，
比如，在显示一个目录的时候排除掉其它会话的临时表。
</para>

   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>

   <!--
<para>
    <function>pg_postmaster_start_time</function> returns the
    <type>timestamp with time zone</type> when the
    server started.
   </para>
-->
<para>
<function>pg_postmaster_start_time</function>返回服务器启动时的<type>timestamp with time zone</type>。
</para>

   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>

   <!--
<para>
    <function>pg_conf_load_time</function> returns the
    <type>timestamp with time zone</type> when the
    server configuration files were last loaded.
    (If the current session was alive at the time, this will be the time
    when the session itself re-read the configuration files, so the
    reading will vary a little in different sessions.  Otherwise it is
    the time when the postmaster process re-read the configuration files.)
   </para>
-->
<para>
<function>pg_conf_load_time</function>返回最后加载服务器配置文件的时间戳。
（如果当前会话在那时还活动，将是当前会话本身重新读取配置文件的时间，
所以读取的时间会在不同的会话中稍微有所不同。否则，
它是postmaster进程重新读取配置文件的时间。）
</para>

   <indexterm>
    <primary>version</primary>
   </indexterm>

   <!--
<para>
    <function>version</function> returns a string describing the
    <productname>PostgreSQL</productname> server's version.
   </para>
-->
<para>
<function>version</function>返回一个描述<productname>PostgreSQL</productname>服务器版本信息的字符串。
</para>

  <indexterm>
   <!-- 
   <primary>privilege</primary>
   <secondary>querying</secondary> 
   -->
   <primary>权限</primary>
   <secondary>查询</secondary>
  </indexterm>

  <!--
<para>
   <xref linkend="functions-info-access-table"> lists functions that
   allow the user to query object access privileges programmatically.
   See <xref linkend="ddl-priv"> for more information about
   privileges.
  </para>
-->
<para>
<xref linkend="functions-info-access-table">列出那些允许用户在程序里查询对象访问权限的函数。
参阅<xref linkend="ddl-priv">获取更多有关权限的信息。
</para>

   <table id="functions-info-access-table">
    <!-- 
<title>Access Privilege Inquiry Functions</title> 
-->
<title>访问权限查询函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for any column of table</entry> 
   -->
   <entry>指定用户是否有访问表任何列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for any column of table</entry> 
   -->
   <entry>当前用户是否有访问表任何列的权限</entry> 
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for column</entry> 
   -->
   <entry>指定用户是否有访问列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for column</entry> 
   -->
   <entry>当前用户是否有访问列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for database</entry> 
   -->
   <entry>指定用户是否有访问数据库的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for database</entry> 
   -->
   <entry>当前用户是否有访问数据库的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for foreign-data wrapper</entry> 
   -->
   <entry>指定用户是否有访问外部数据封装器的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for foreign-data wrapper</entry> 
   -->
   <entry>当前用户是否有访问外部数据封装器的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for function</entry> 
   -->
   <entry>指定用户是否有访问函数的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for function</entry> 
   -->
   <entry>当前用户是否有访问函数的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for language</entry> 
   -->
   <entry>指定用户是否有访问语言的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for language</entry> 
   -->
   <entry>当前用户是否有访问语言的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for schema</entry> 
   -->
   <entry>指定用户是否有访问模式的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for schema</entry> 
   -->
   <entry>当前用户是否有访问模式的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for sequence</entry> 
   -->
   <entry>指定用户是否有访问序列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for sequence</entry>
   -->
   <entry>当前用户是否有访问序列的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for foreign server</entry> 
   -->
   <entry>指定用户是否有访问外部服务的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for foreign server</entry> 
   -->
   <entry>当前用户是否有访问外部服务的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for table</entry> 
   -->
   <entry>指定用户是否有访问表的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for table</entry> 
   -->
   <entry>当前用户是否有访问表的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for tablespace</entry> 
   -->
   <entry>指定用户是否有访问表空间的权限</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for tablespace</entry> 
   -->
   <entry>当前用户是否有访问表空间的权限</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does user have privilege for role</entry>
   -->
   <entry>指定用户是否有角色的权限</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>does current user have privilege for role</entry>
   -->
   <entry>当前用户是否有角色的权限</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>

   <!--
<para>
    <function>has_table_privilege</function> checks whether a user
    can access a table in a particular way.  The user can be
    specified by name, by OID (<literal>pg_authid.oid</literal>),
    <literal>public</> to indicate the PUBLIC pseudo-role, or if the argument is
    omitted
    <function>current_user</function> is assumed.  The table can be specified
    by name or by OID.  (Thus, there are actually six variants of
    <function>has_table_privilege</function>, which can be distinguished by
    the number and types of their arguments.)  When specifying by name,
    the name can be schema-qualified if necessary.
    The desired access privilege type
    is specified by a text string, which must evaluate to one of the
    values <literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</>,
    <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>.  Optionally,
    <literal>WITH GRANT OPTION</> can be added to a privilege type to test
    whether the privilege is held with grant option.  Also, multiple privilege
    types can be listed separated by commas, in which case the result will
    be <literal>true</> if any of the listed privileges is held.
    (Case of the privilege string is not significant, and extra whitespace
    is allowed between but not within privilege names.)
    Some examples:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>
-->
<para>
<function>has_table_privilege</function>检查用户是否可以用特定的方式访问表。
用户可以通过名字或OID（pg_authid.oid）来指定，<literal>public</>表明PUBLIC伪角色，
或如果缺省该参数，则使用<function>current_user</function>。该表可以通过名字或者 OID 声明。
因此，实际上有六种<function>has_table_privilege</function>变体，
我们可以通过它们的参数数目和类型来区分它们。如果用名字声明，那么在必要时可以用模式进行修饰。
所希望的权限类型是用一个文本字符串来声明的，必须是<literal>SELECT</literal>, <literal>INSERT</literal>,
<literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</>, <literal>REFERENCES</literal>
或<literal>TRIGGER</literal>之一。可选，可以添加<literal>WITH GRANT OPTION</>到权限类型，
以测试权限是否拥有授权选项。也可以用逗号分隔多个列出的权限类型，如果拥有任何所列出的权限，
则结果便为<literal>true</>。（权限字符串不区分大小写，
权限名之间允许有额外空白但不属于权限名的部分。）一些例子：
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
</para>

   <!--
<para>
    <function>has_sequence_privilege</function> checks whether a user
    can access a sequence in a particular way.  The possibilities for its
    arguments are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to one of
    <literal>USAGE</literal>,
    <literal>SELECT</literal>, or
    <literal>UPDATE</literal>.
   </para>
-->
<para>
<function>has_sequence_privilege</function>检查用户是否可以用特定的方式访问序列。
参数可能与<function>has_table_privilege</function>类似。
想要的访问权限必须为<literal>USAGE</literal>，<literal>SELECT</literal>或<literal>UPDATE</literal>之一。
</para>

   <!--
<para>
    <function>has_any_column_privilege</function> checks whether a user can
    access any column of a table in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</>,
    except that the desired access privilege type must evaluate to some
    combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table,
    so <function>has_any_column_privilege</function> will always return
    <literal>true</> if <function>has_table_privilege</> does for the same
    arguments.  But <function>has_any_column_privilege</> also succeeds if
    there is a column-level grant of the privilege for at least one column.
   </para>
-->
<para>
<function>has_any_column_privilege</function>检查用户是否可以用特定的方式访问表的任何列。
其参数可能与<function>has_table_privilege</>类似，除了想要的权限类型必须是<literal>SELECT</literal>，
<literal>INSERT</literal>，<literal>UPDATE</literal>，或<literal>REFERENCES</literal>的一些组合。
请注意，在表级别拥有任何这些权限隐含授予它为每个表列，因此如果与 <function>has_table_privilege</>
参数相同，<function>has_any_column_privilege</function>总是返回<literal>true</>。
但是如果有至少一列的列级权限授予也成功。
</para>

   <!--
<para>
    <function>has_column_privilege</function> checks whether a user
    can access a column in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    with the addition that the column can be specified either by name
    or attribute number.
    The desired access privilege type must evaluate to some combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table.
   </para>
-->
<para>
<function>has_column_privilege</function>检查用户是否可以用特定的方式访问一列。
其可能的参数类似于<function>has_table_privilege</function>，
可以通过列名或属性数添加列。想要的访问权限类型必须是<literal>SELECT</literal>，
<literal>INSERT</literal>，<literal>UPDATE</literal>，或<literal>REFERENCES</literal>的一些组合。
请注意，在表级别拥有任何这些权限隐含授予它为每个表列。
</para>

   <!--
<para>
    <function>has_database_privilege</function> checks whether a user
    can access a database in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal>,
    <literal>CONNECT</literal>,
    <literal>TEMPORARY</literal>, or
    <literal>TEMP</literal> (which is equivalent to
    <literal>TEMPORARY</literal>).
   </para>
-->
<para>
<function>has_database_privilege</function>检查一个用户是否能以特定方式访问一个数据库。
它可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>CREATE</literal>，
<literal>CONNECT</literal>，<literal>TEMPORARY</literal>，<literal>TEMP</literal>
(等价于<literal>TEMPORARY</literal>)的一些组合。
</para>

   <!--
<para>
    <function>has_function_privilege</function> checks whether a user
    can access a function in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a function by a text string rather than by OID,
    the allowed input is the same as for the <type>regprocedure</> data type
    (see <xref linkend="datatype-oid">).
    The desired access privilege type must evaluate to
    <literal>EXECUTE</literal>.
    An example is:
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>
-->
<para>
<function>has_function_privilege</function>检查一个用户是否能以特定方式访问一个函数。
它可能的参数类似<function>has_table_privilege</function>。
我们声明一个函数用的是文本字符串而不是 OID ，允许的输入和<type>regprocedure</>
数据类型一样(参阅<xref linkend="datatype-oid">)。权限类型必须是<literal>EXECUTE</literal>。
一个例子如下：
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
</para>

   <!--
<para>
    <function>has_foreign_data_wrapper_privilege</function> checks whether a user
    can access a foreign-data wrapper in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
-->
<para>
<function>has_foreign_data_wrapper_privilege</function>
检查一个用户是否能以特定的方式访问外部数据封装器。
它的可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>USAGE</literal>。
</para>

   <!--
<para>
    <function>has_language_privilege</function> checks whether a user
    can access a procedural language in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
-->
<para>
<function>has_language_privilege</function>检查一个用户是否能以特定方式访问一个过程语言。
它可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>USAGE</literal>。
</para>

   <!--
<para>
    <function>has_schema_privilege</function> checks whether a user
    can access a schema in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal> or
    <literal>USAGE</literal>.
   </para>
-->
<para>
<function>has_schema_privilege</function>检查一个用户是否能以特定方式访问一个模式。
它可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>CREATE</literal>
或<literal>USAGE</literal>的一些组合。
</para>

   <!--
<para>
    <function>has_server_privilege</function> checks whether a user
    can access a foreign server in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
   </para>
-->
<para>
<function>has_server_privilege</function>检查一个用户是否能以特定方式访问一个外部服务器。
它可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>USAGE</literal>。
</para>

   <!--
<para>
    <function>has_tablespace_privilege</function> checks whether a user
    can access a tablespace in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>CREATE</literal>.
   </para>
-->
<para>
<function>has_tablespace_privilege</function>检查一个用户是否能以特定方式访问一个表空间。
它可能的参数类似<function>has_table_privilege</function>。权限类型必须是<literal>CREATE</literal>。
</para>

   <!--
<para>
    <function>pg_has_role</function> checks whether a user
    can access a role in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that <literal>public</> is not allowed as a user name.
    The desired access privilege type must evaluate to some combination of
    <literal>MEMBER</literal> or
    <literal>USAGE</literal>.
    <literal>MEMBER</literal> denotes direct or indirect membership in
    the role (that is, the right to do <command>SET ROLE</>), while
    <literal>USAGE</literal> denotes whether the privileges of the role
    are immediately available without doing <command>SET ROLE</>.
   </para>
-->
<para>
<function>pg_has_role</function>检查一个用户是否能以特定方式访问一个角色。
它可能的参数类似<function>has_table_privilege</function>，除了<literal>public</>
不能用做用户名。权限类型必须是<literal>MEMBER</literal>或<literal>USAGE</literal>的一些组合。
<literal>MEMBER</literal>表示的是角色中的直接或间接成员关系(也就是<command>SET ROLE</>
的权限)，而<literal>USAGE</literal>表示角色的权限是否无需<command>SET ROLE</>即可立即生效。
</para>

  <!--
<para>
   <xref linkend="functions-info-schema-table"> shows functions that
   determine whether a certain object is <firstterm>visible</> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  To list the names of all visible tables:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>
-->
<para>
<xref linkend="functions-info-schema-table">
显示了那些判断一个对象是否在当前模式搜索路径中<firstterm>可见</>的函数。
比如，如果一个表所在的模式在搜索路径中，并且没有同名的表出现在搜索路径的更靠前的地方，
那么就说这个表是可见的。它等效于表可以不带明确模式修饰进行引用。比如，要列出所有可见表的名字：
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting> 
</para>

   <indexterm>
    <!-- 
<primary>search path</primary>
    <secondary>object visibility</secondary> 
-->
<primary>搜索路径</primary>
    <secondary>对象可见性</secondary>
   </indexterm>

   <table id="functions-info-schema-table">
    <!-- 
<title>Schema Visibility Inquiry Functions</title> 
-->
<title>模式可见性查询函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is collation visible in search path</entry> 
   -->
   <entry>该排序是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is conversion visible in search path</entry> 
   -->
   <entry>该转换是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is function visible in search path</entry> 
   -->
   <entry>该函数是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is operator class visible in search path</entry> 
   -->
   <entry>该操作符类是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is operator visible in search path</entry> 
   -->
   <entry>该操作符是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is operator family visible in search path</entry> 
   -->
   <entry>该操作符族是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is table visible in search path</entry> 
   -->
   <entry>该表是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is text search configuration visible in search path</entry> 
   -->
   <entry>该文本检索配置是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is text search dictionary visible in search path</entry>
   -->
   <entry>该文本检索词典是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is text search parser visible in search path</entry> 
   -->
   <entry>该文本搜索解析是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is text search template visible in search path</entry> 
   -->
   <entry>该文本检索模板是否在搜索路径中可见</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is type (or domain) visible in search path</entry> 
   -->
   <entry>该类型（或域）是否在搜索路径中可见</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>

   <!--
<para>
    Each function performs the visibility check for one type of database
    object.  Note that <function>pg_table_is_visible</function> can also be used
    with views, indexes and sequences; <function>pg_type_is_visible</function>
    can also be used with domains. For functions and operators, an object in
    the search path is visible if there is no object of the same name
    <emphasis>and argument data type(s)</> earlier in the path.  For operator
    classes, both name and associated index access method are considered.
   </para>
-->
<para>
每个函数执行一种数据库对象类型的可见性检查。请注意<function>pg_table_is_visible</function>
还可用于视图、索引、序列。<function>pg_type_is_visible</function>还可用于域。
对于函数和操作符，如果在搜索路径中没有名字相同并且<emphasis>参数的数据类型</>
也相同的对象出现在路径中更靠前的位置，那么该对象就是可见的。对于操作符类，
则要同时考虑名字和相关的索引访问方法。
</para>

   <!--
<para>
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</>, <type>regtype</>,
    <type>regprocedure</>, <type>regoperator</>, <type>regconfig</>,
    or <type>regdictionary</>),
    for example:
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
   </para>
-->
<para>
所有这些函数都需要使用 OID 来标识要被检查的对象。如果你想通过名字测试对象，
那么使用 OID 别名类型(<type>regclass</>, <type>regtype</>, <type>regprocedure</>,
 <type>regoperator</>, <type>regconfig</>或<type>regdictionary</>)将会很方便。例如：
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
请注意用这种方法测试一个未经修饰的名字没什么意义，因为如果一个名字可以被识别，
那它首先必须是可见的。
</para>

   <indexterm>
    <primary>format_type</primary>
   </indexterm>

   <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>

   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>

   <indexterm>
    <primary>collation for</primary>
   </indexterm>

   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>

   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>

   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>

   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>

  <!--
<para>
   <xref linkend="functions-info-catalog-table"> lists functions that
   extract information from the system catalogs.
  </para>
-->
<para>
<xref linkend="functions-info-catalog-table">列出了从系统表中抽取信息的函数。
</para>

   <table id="functions-info-catalog-table">
    <!-- 
<title>System Catalog Information Functions</title> 
-->
<title>系统表信息函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get SQL name of a data type</entry> 
   -->
   <entry>获取一个数据类型的 SQL 名称</entry>
      </row>
      <row>
       <entry><literal><function>pg_describe_object(<parameter>catalog_id</parameter>, <parameter>object_id</parameter>, <parameter>object_sub_id</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get description of a database object</entry> 
   -->
   <entry>获取一个数据库对象的描述</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object(<parameter>catalog_id</parameter> <type>oid</>, <parameter>object_id</parameter> <type>oid</>, <parameter>object_sub_id</parameter> <type>integer</>)</function></literal></entry>
       <entry><parameter>type</> <type>text</>, <parameter>schema</> <type>text</>, <parameter>name</> <type>text</>, <parameter>identity</> <type>text</></entry>
       <!-- 
   <entry>get identity of a database object</entry> 
   -->
   <entry>获取一个数据库对象的身份</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get definition of a constraint</entry> 
   -->
   <entry>获取一个约束的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get definition of a constraint</entry> 
   -->
   <entry>获取一个约束的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry> 
   -->
   <entry>反编译一个表达式的内部形式，假设其中的任何 Var 都引用第二个参数指出的关系</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry> 
   -->
   <entry>反编译一个表达式的内部形式，假设其中的任何 Var 都引用第二个参数指出的关系</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get definition of a function</entry> 
   -->
   <entry>获取一个函数的定义</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get argument list of function's definition (with default values)</entry> 
   -->
   <entry>获取函数定义的参数列表（带默认值）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get argument list to identify a function (without default values)</entry> 
   -->
   <entry>获取参数列表来确定一个函数 (不带默认值)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <literal>RETURNS</> clause for function</entry> 
   -->
   <entry>获取函数的<literal>RETURNS</>子句</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE INDEX</> command for index</entry> 
   -->
   <entry>获取索引的<command>CREATE INDEX</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE INDEX</> command for index,
       or definition of just one index column when
       <parameter>column_no</> is not zero</entry> 
   -->
   <entry>获取索引的<command>CREATE INDEX</>命令，如果<parameter>column_no</>不为零，
   则只获取一个索引字段的定义。</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
       <!-- 
   <entry>get list of SQL keywords and their categories</entry> 
   -->
   <entry>获取SQL关键字和类别列表</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE RULE</> command for rule</entry> 
   -->
   <entry>为规则获取<command>CREATE RULE</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE RULE</> command for rule</entry> 
   -->
   <entry>为规则获取<command>CREATE RULE</>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get name of the sequence that a <type>serial</type>, <type>smallserial</type> or <type>bigserial</type> column
       uses</entry> 
   -->
   <entry>获取一个<type>serial</type>，<type>smallserial</type>或<type>bigserial</type>字段使用的序列名</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</> command for trigger</entry> 
   -->
   <entry>为触发器获取<command>CREATE [ CONSTRAINT ] TRIGGER</>命令 </entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</>)</entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</> command for trigger</entry> 
   -->
   <entry>为触发器获取<command>CREATE [ CONSTRAINT ] TRIGGER</>命令 </entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
       <!-- 
   <entry>get role name with given OID</entry> 
   -->
   <entry>获取给定 OID 的角色名</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
   -->
   <entry>为视图或物化视图获取底层的<command>SELECT</command>命令(<emphasis>已废弃</emphasis>)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!--
   <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
   -->
   <entry>为视图或物化视图获取底层的<command>SELECT</command>命令(<emphasis>已废弃</emphasis>)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!--
   <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
   -->
   <entry>为视图或物化视图获取底层的<command>SELECT</command>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get underlying <command>SELECT</command> command for view or materialized view</entry> 
   -->
   <entry>为视图或物化视图获取底层的<command>SELECT</command>命令</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get underlying <command>SELECT</command> command for view or
              materialized view; lines with fields are wrapped to specified
              number of columns, pretty-printing is implied</entry> 
  -->
<entry>为视图或物化视图获取底层的<command>SELECT</command>命令；行字段被换到指定的列数，打印是隐含的</entry>
      </row>
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
       <!-- 
   <entry>get the set of storage option name/value pairs</entry> 
   -->
   <entry>获取存储选项名称/值对的集合</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
       <!-- 
   <entry>get the set of database OIDs that have objects in the tablespace</entry> 
   -->
   <entry>获取在指定的表空间有元素的数据库 OID 集合</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get the path in the file system that this tablespace is located in</entry> 
   -->
   <entry>获取表空间所在的文件系统的路径</entry>
      </row>
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <!-- 
   <entry>get the data type of any value</entry> 
   -->
   <entry>获取任何值的数据类型</entry>
      </row>
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get the collation of the argument</entry> 
   -->
   <entry>获取参数的排序</entry>
      </row>
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
       <!--
       <entry>get the OID of the named relation</entry>
       -->
       <entry>获取命名关系的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
       <!--
       <entry>get the OID of the named function</entry>
       -->
       <entry>获取命名函数的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
       <!--
       <entry>get the OID of the named function</entry>
       -->
       <entry>获取命名函数的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
       <!--
       <entry>get the OID of the named operator</entry>
       -->
       <entry>获取命名操作符的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
       <!--
       <entry>get the OID of the named operator</entry>
       -->
       <entry>获取命名操作符的OID</entry>
      </row>
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <!-- 
       <entry>get the OID of the named type</entry>
       -->
       <entry>获取命名类型的OID</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   <function>format_type</function> returns the SQL name of a data type that
   is identified by its type OID and possibly a type modifier.  Pass NULL
   for the type modifier if no specific modifier is known.
  </para>
-->
<para>
<function>format_type</function>通过某个数据类型的类型 OID 以及可能的类型修饰词返回其 SQL 名称。
如果不知道具体的修饰词，那么在类型修饰词的位置传入 NULL 。
</para>

  <!--
<para>
   <function>pg_get_keywords</function> returns a set of records describing
   the SQL keywords recognized by the server. The <structfield>word</> column
   contains the keyword.  The <structfield>catcode</> column contains a
   category code: <literal>U</> for unreserved, <literal>C</> for column name,
   <literal>T</> for type or function name, or <literal>R</> for reserved.
   The <structfield>catdesc</> column contains a possibly-localized string
   describing the category.
  </para>
-->
<para>
<function>pg_get_keywords</function>返回一组记录描述服务器识别的 SQL 关键字。
<structfield>word</>列包含关键字。<structfield>catcode</>列包含一个分类代码：
<literal>U</>通用的，<literal>C</>列名，<literal>T</>类型或函数名，或<literal>R</>保留。
<structfield>catdesc</>列包含了一个可能本地化描述分类的字符串。
</para>

  <!--
<para>
   <function>pg_get_constraintdef</function>,
   <function>pg_get_indexdef</function>, <function>pg_get_ruledef</function>,
   and <function>pg_get_triggerdef</function>, respectively reconstruct the
   creating command for a constraint, index, rule, or trigger. (Note that this
   is a decompiled reconstruction, not the original text of the command.)
   <function>pg_get_expr</function> decompiles the internal form of an
   individual expression, such as the default value for a column.  It can be
   useful when examining the contents of system catalogs.  If the expression
   might contain Vars, specify the OID of the relation they refer to as the
   second parameter; if no Vars are expected, zero is sufficient.
   <function>pg_get_viewdef</function> reconstructs the <command>SELECT</>
   query that defines a view. Most of these functions come in two variants,
   one of which can optionally <quote>pretty-print</> the result.  The
   pretty-printed format is more readable, but the default format is more
   likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</>; avoid using pretty-printed output for dump
   purposes.  Passing <literal>false</> for the pretty-print parameter yields
   the same result as the variant that does not have the parameter at all.
  </para>
-->
<para>
<function>pg_get_constraintdef</function>，<function>pg_get_indexdef</function>，
<function>pg_get_ruledef</function>，和<function>pg_get_triggerdef</function>
分别从一个约束、索引、规则或触发器上重新构造创建它们的命令(反编译的重新构造，
而不是该命令的原文)。<function>pg_get_expr</function>反编译一个独立表达式的内部形式，
比如一个字段的缺省值。在检查系统表的内容的时候很有用。如果表达式可能包含Var，
那么指定他们参考的关联的OID为第二个参数；如果没有Var，0就足够了。
<function>pg_get_viewdef</function>重新构造出定义视图的<command>SELECT</>查询。
这些函数大多数都有两个变种，其中一个是<quote>适合打印</>的结果。这种格式更容易读，
但是缺省的格式更有可能被将来的<productname>PostgreSQL</>版本用同样的方法解释；
如果是用于转储，那么尽可能避免使用适合打印的格式。给 pretty-print参数传递<literal>false</>
生成的结果和没有这个参数的变种生成的结果是完全一样。
</para>

  <!--
<para>
   <function>pg_get_functiondef</> returns a complete
   <command>CREATE OR REPLACE FUNCTION</> statement for a function.
   <function>pg_get_function_arguments</function> returns the argument list
   of a function, in the form it would need to appear in within
   <command>CREATE FUNCTION</>.
   <function>pg_get_function_result</function> similarly returns the
   appropriate <literal>RETURNS</> clause for the function.
   <function>pg_get_function_identity_arguments</function> returns the
   argument list necessary to identify a function, in the form it
   would need to appear in within <command>ALTER FUNCTION</>, for
   instance.  This form omits default values.
  </para>
-->
<para>
<function>pg_get_functiondef</>为函数返回一个完整的<command>CREATE OR REPLACE FUNCTION</>语句。
<function>pg_get_function_arguments</function>返回一个函数的参数列表，
这种格式需要在<command>CREATE FUNCTION</>中使用。<function>pg_get_function_result</function>
为函数简单的返回适当的<literal>RETURNS</>子句。<function>pg_get_function_identity_arguments</function>
返回需要的参数列表以标识函数，这种格式需要在<command>ALTER FUNCTION</>中使用。这种形式省略了默认值。
</para>

  <!--
<para>
   <function>pg_get_serial_sequence</function> returns the name of the
   sequence associated with a column, or NULL if no sequence is associated
   with the column.  The first input parameter is a table name with
   optional schema, and the second parameter is a column name.  Because
   the first parameter is potentially a schema and table, it is not treated
   as a double-quoted identifier, meaning it is lower cased by default,
   while the second parameter, being just a column name, is treated as
   double-quoted and has its case preserved.  The function returns a value
   suitably formatted for passing to sequence functions (see <xref
   linkend="functions-sequence">).  This association can be modified or
   removed with <command>ALTER SEQUENCE OWNED BY</>.  (The function
   probably should have been called
   <function>pg_get_owned_sequence</function>; its current name reflects the fact
   that it's typically used with <type>serial</> or <type>bigserial</>
   columns.)
  </para>
-->
<para>
<function>pg_get_serial_sequence</function>返回与一个字段相关的序列名字；
如果没有任何序列与给定的字段相关则返回 NULL 。第一个输入参数是可选模式的表名，
第二个参数是列名。因为第一个参数可能是一个模式和表，它不是视为一个双引号的标识符，
意味着默认情况下小写，而第二个参数只是列名称，被视为双引号括起来的，并保留其大小写。
这个名字经过了合适的格式化，可以传递给序列函数(参阅<xref linkend="functions-sequence">)。
这种相关性可以通过<command>ALTER SEQUENCE OWNED BY</>修改或删除。
（其实将这个函数命名为<function>pg_get_owned_sequence</function>或许更为妥当，
因为它的当前名字反映了它通常用于<type>serial</>或<type>bigserial</>字段的事实。）
</para>

  <!--
<para>
   <function>pg_get_userbyid</function> extracts a role's name given
   its OID.
  </para>
-->
<para>
<function>pg_get_userbyid</function>通过角色的 OID 抽取对应的用户名。
</para>

  <!--
<para>
   <function>pg_options_to_table</function> returns the set of storage
   option name/value pairs
   (<literal>option_name</>/<literal>option_value</>) when passed
   <structname>pg_class</>.<structfield>reloptions</> or
   <structname>pg_attribute</>.<structfield>attoptions</>.
  </para>
-->
<para>
<function>pg_options_to_table</function>当通过<structname>pg_class</>.<structfield>reloptions</>
或<structname>pg_attribute</>.<structfield>attoptions</>时返回存储选项名字/值对
（<literal>option_name</>/<literal>option_value</>）的集合。
</para>

  <!--
<para>
   <function>pg_tablespace_databases</function> allows a tablespace to be
   examined. It returns the set of OIDs of databases that have objects stored
   in the tablespace. If this function returns any rows, the tablespace is not
   empty and cannot be dropped. To display the specific objects populating the
   tablespace, you will need to connect to the databases identified by
   <function>pg_tablespace_databases</function> and query their
   <structname>pg_class</> catalogs.
  </para>
-->
<para>
<function>pg_tablespace_databases</function>允许检查一个表空间的状况，
它返回在该表空间中保存了对象的数据库 OID 集合。如果这个函数返回数据行，
那么该表空间就是非空的，因此不能删除。要显示该表空间中的特定对象，
你需要把<function>pg_tablespace_databases</function>
返回的数据库标识与 <structname>pg_class</>表连接进行查询。
</para>

  <!--
<para>
   <function>pg_describe_object</function> returns a textual description of a database
   object specified by catalog OID, object OID and a (possibly zero) sub-object ID.
   This description is intended to be human-readable, and might be translated,
   depending on server configuration.
   This is useful to determine the identity of an object as stored in the
   <structname>pg_depend</structname> catalog.
  </para>
-->
<para>
<function>pg_describe_object</function>返回由目录OID，对象OID和一个（或许0个）
子对象ID指定的数据库对象的描述。这个描述趋向于人类易读，并且可能是经过翻译的，取决于服务器的配置。
这有助于确定一个对象的标识存储在<structname>pg_depend</structname>目录中。
</para>

  <!--
<para>
   <function>pg_identify_object</function> returns a row containing enough information
   to uniquely identify the database object specified by catalog OID, object OID and a
   (possibly zero) sub-object ID.  This information is intended to be machine-readable,
   and is never translated.
   <parameter>type</> identifies the type of database object;
   <parameter>schema</> is the schema name that the object belongs in, or
   <literal>NULL</> for object types that do not belong to schemas;
   <parameter>name</> is the name of the object, quoted if necessary, only
   present if it can be used (alongside schema name, if pertinent) as a unique
   identifier of the object, otherwise <literal>NULL</>;
   <parameter>identity</> is the complete object identity, with the precise format
   depending on object type, and each part within the format being
   schema-qualified and quoted as necessary.
  </para>
-->
<para>
<function>pg_identify_object</function>返回一个包含足够信息来唯一的标识由系统OID，
对象OID和一个（或许0个）子对象ID指定的数据库对象的行。这个信息趋向于机器易读，并且从不翻译。
<parameter>type</>标识数据库对象的类型；<parameter>schema</>是对象属于的模式名，或 <literal>NULL</>
表明对象类型不属于模式；<parameter>name</> 是对象的名字，如果需要就加上双引号，
只有在它可以用作对象的唯一标识符时使用（如果相关，跟随模式名），否则为<literal>NULL</>；
<parameter>identity</>是完整的对象身份，根据对象类型有精确的格式，并且格式内的每个部分都是模式限定的，
必要时加双引号。
</para>

  
<para>
<!--
   <function>pg_typeof</function> returns the OID of the data type of the
   value that is passed to it.  This can be helpful for troubleshooting or
   dynamically constructing SQL queries.  The function is declared as
   returning <type>regtype</>, which is an OID alias type (see
   <xref linkend="datatype-oid">); this means that it is the same as an
   OID for comparison purposes but displays as a type name.  For example:
-->
<function>pg_typeof</function>返回传递给它的值的数据类型OID。
这可能有利于故障排除或动态构造SQL查询。函数声明返回OID别名类型的<type>regtype</>
（参阅<xref linkend="datatype-oid">）；这意味着它和比较目的的OID相同但显示类型名称。例如：
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</programlisting>
  </para>
 
<para>
<!--
   The expression <literal>collation for</literal> returns the collation of the
   value that is passed to it.  Example:
-->
表达式<literal>collation for</literal>返回传递给它的值的排序。例如
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</programlisting>
<!-- 
  The value might be quoted and schema-qualified.  If no collation is derived
  for the argument expression, then a null value is returned.  If the argument
  is not of a collatable data type, then an error is raised. 
-->
值可能是引号括起来的并且模式限制的。如果没有为参数表达式排序，那么返回一个null值。
如果参数不是排序的类型，那么抛出一个错误。
  </para>

<!--
   <para>
   The <function>to_regclass</function>, <function>to_regproc</function>,
   <function>to_regprocedure</function>, <function>to_regoper</function>,
   <function>to_regoperator</function>, and <function>to_regtype</function>
   functions translate relation, function, operator, and type names to objects
   of type <type>regclass</>, <type>regproc</>, <type>regprocedure</type>,
   <type>regoper</>, <type>regoperator</type>, and <type>regtype</>,
   respectively.  These functions differ from a cast from
   text in that they don't accept a numeric OID, and that they return null
   rather than throwing an error if the name is not found (or, for
   <function>to_regproc</function> and <function>to_regoper</function>, if
   the given name matches multiple objects).
  </para>
-->
<para>
<function>to_regclass</function>、<function>to_regproc</function>、
<function>to_regprocedure</function>、<function>to_regoper</function>、
<function>to_regoperator</function>和<function>to_regtype</function>
函数分别转换关系、函数、操作符和类型名到类型为<type>regclass</>、
<type>regproc</>、<type>regprocedure</type>、<type>regoper</>、
<type>regoperator</type>和<type>regtype</>的对象。
这些函数与文本转换的区别在于它们不接受数字OID，
并且如果没有找到名字，它们返回空而不是抛出一个错误
（或者，对于<function>to_regproc</function>和<function>to_regoper</function>，
是如果给出的名字匹配多个对象）。
</para>
   <indexterm>
    <primary>col_description</primary>
   </indexterm>

   <indexterm>
    <primary>obj_description</primary>
   </indexterm>

   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>

   <indexterm>
    <!--
<primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary> 
-->
<primary>注释</primary>
    <secondary sortas="database objects">关于数据库对象</secondary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref linkend="functions-info-comment-table">
    extract comments previously stored with the <xref linkend="sql-comment">
    command.  A null value is returned if no
    comment could be found for the specified parameters.
   </para>
-->
<para>
<xref linkend="functions-info-comment-table">显示的函数将原来用<xref linkend="sql-comment">
命令存储的评注抽取出来。如果没有找到，则返回 NULL 。
</para>

   <table id="functions-info-comment-table">
    <!-- 
<title>Comment Information Functions</title> 
-->
<title>注释信息函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get comment for a table column</entry> 
   -->
   <entry>获取一个表字段的评注</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get comment for a database object</entry> 
   -->
   <entry>获取一个数据库对象的评注</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get comment for a database object (<emphasis>deprecated</emphasis>)</entry>
   -->
   <entry>获取一个数据库对象的评注(<emphasis>已废弃</emphasis>)</entry>
      </row>
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get comment for a shared database object</entry> 
   -->
   <entry>获取一个共享数据库对象的评注</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    <function>col_description</function> returns the comment for a table
    column, which is specified by the OID of its table and its column number.
    (<function>obj_description</function> cannot be used for table columns
    since columns do not have OIDs of their own.)
   </para>
-->
<para>
<function>col_description</function>返回一个表中字段的评注，它是通过表 OID 和字段号来声明的。
<function>obj_description</function>不能用于表字段，因为字段没有自己的 OID 。

</para>

   <!--
<para>
    The two-parameter form of <function>obj_description</function> returns the
    comment for a database object specified by its OID and the name of the
    containing system catalog.  For example,
    <literal>obj_description(123456,'pg_class')</literal>
    would retrieve the comment for the table with OID 123456.
    The one-parameter form of <function>obj_description</function> requires only
    the object OID.  It is deprecated since there is no guarantee that
    OIDs are unique across different system catalogs; therefore, the wrong
    comment might be returned.
   </para>
-->
<para>
带有两个参数的<function>obj_description</function>返回一个数据库对象的评注，
该对象是通过其 OID 和其所属的系统表名字声明的。比如，<literal>obj_description(123456,'pg_class')</literal>
将返回 OID 为 12345 的表的评注。只带一个参数的<function>obj_description</function>
只要求对象 OID ，现在已经废弃了，因为我们不再保证 OID 在不同的系统表之间是唯一的，
因此可能会返回错误的评注。
</para>

   <!--
<para>
    <function>shobj_description</function> is used just like
    <function>obj_description</function> except it is used for retrieving
    comments on shared objects.  Some system catalogs are global to all
    databases within each cluster, and the descriptions for objects in them
    are stored globally as well.
   </para>
-->
<para>
<function>shobj_description</function>和<function>obj_description</function>差不多，
不同之处仅在于前者用于共享对象。一些系统表是通用于集群中所有数据库的全局表，
因此这些表的评注也是全局存储的。
</para>

   <indexterm>
    <primary>txid_current</primary>
   </indexterm>

   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>

   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref linkend="functions-txid-snapshot">
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
   </para>
-->
<para>
<xref linkend="functions-txid-snapshot">显示的函数在一个输出形式中提供服务器事务信息。
这些函数的主要用途是为了确定在两个快照之间有哪个事务提交。
</para>

   <table id="functions-txid-snapshot">
    <!-- 
<title>Transaction IDs and Snapshots</title> 
-->
<title>事务ID和快照</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>get current transaction ID</entry>
   -->
   <entry>获取当前事务 ID</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
       <!-- 
   <entry>get current snapshot</entry> 
   -->
   <entry>获取当前快照</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
       <!-- 
   <entry>get in-progress transaction IDs in snapshot</entry> 
   -->
   <entry>获取在快照中进行中的事务ID</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>get <literal>xmax</literal> of snapshot</entry> 
   -->
   <entry>获取快照的 <literal>xmax</literal></entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>get <literal>xmin</literal> of snapshot</entry> 
   -->
   <entry>获取快照的<literal>xmin</literal></entry>
      </row>
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>is transaction ID visible in snapshot? (do not use with subtransaction ids)</entry> 
   -->
   <entry>在快照中事务ID是否可见？(不使用子事务ID)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The internal transaction ID type (<type>xid</>) is 32 bits wide and
    wraps around every 4 billion transactions.  However, these functions
    export a 64-bit format that is extended with an <quote>epoch</> counter
    so it will not wrap around during the life of an installation.
    The data type used by these functions, <type>txid_snapshot</type>,
    stores information about transaction ID
    visibility at a particular moment in time.  Its components are
    described in <xref linkend="functions-txid-snapshot-parts">.
   </para>
-->
<para>
内部事务 ID 类型(<type>xid</>)是32位，每40亿事务循环。然而这些函数导出一个64位格式，
是使用一个<quote>epoch</>计数器扩展，所以在安装过程中不会循环。
这些函数使用的数据类型<type>txid_snapshot</type>，存储在某时刻事物ID可见性的信息。
其组件描述在<xref linkend="functions-txid-snapshot-parts">。
</para>

   <table id="functions-txid-snapshot-parts">
    <!-- 
<title>Snapshot Components</title> 
-->
<title>快照组件</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Name</entry>
       <entry>Description</entry> 
   -->
   <entry>名字</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>xmin</type></entry>
       <!-- 
   <entry>
         Earliest transaction ID (txid) that is still active.  All earlier
         transactions will either be committed and visible, or rolled
         back and dead.
       </entry> 
   -->
   <entry>
         最早的事务ID（txid）仍然活动。所有较早事务将是可见提交了，或者要么死掉回滚了。
       </entry>
      </row>

      <row>
       <entry><type>xmax</type></entry>
       <!-- 
   <entry>
        First as-yet-unassigned txid.  All txids greater than or equal to this
        are not yet started as of the time of the snapshot, and thus invisible.
       </entry> 
   -->
   <entry>
        首先作为尚未分配的txid。所有大于或等于此的txids作为这时的快照都是尚未开始的，因此不可见。
       </entry>
      </row>

      <row>
       <entry><type>xip_list</type></entry>
       <!-- 
   <entry>
        Active txids at the time of the snapshot.  The list
        includes only those active txids between <literal>xmin</>
        and <literal>xmax</>; there might be active txids higher
        than <literal>xmax</>.  A txid that is <literal>xmin &lt;= txid &lt;
        xmax</literal> and not in this list was already completed
        at the time of the snapshot, and thus either visible or
        dead according to its commit status.  The list does not
        include txids of subtransactions.
       </entry> 
   -->
   <entry>
       在当前快照活动的txids。这个列表只包含在<literal>xmin</>和<literal>xmax</>
   之间的活动txids；有可能活动的txids高于<literal>xmax</>。
   一个<literal>xmin &lt;= txid &lt; xmax</literal>，并且不在这个列表中的txid，
   是在快照的这个时间已经完成的，因此要么可见或死掉对应它的提交状态。
   这个列表不包含子事务的txids。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    <type>txid_snapshot</>'s textual representation is
    <literal><replaceable>xmin</>:<replaceable>xmax</>:<replaceable>xip_list</></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
   </para>
-->
<para>
<type>txid_snapshot</>的文本表示为：<literal><replaceable>xmin</>:<replaceable>xmax</>:<replaceable>xip_list</></literal>。
例如<literal>10:20:10,14,15</literal>意思为：<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>。
</para>
  </sect1>

  <sect1 id="functions-admin">
   <!-- 
   <title>System Administration Functions</title> 
   -->
   <title>系统管理函数</title>

   <!--
<para>
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</> installation.
   </para>
-->
<para>
这节描述的函数用来控制和监视<productname>PostgreSQL</>安装。
</para>

  <sect2 id="functions-admin-set">
   <!-- 
   <title>Configuration Settings Functions</title> 
   -->
   <title>配置设置函数</title>

   <!--
<para>
    <xref linkend="functions-admin-set-table"> shows the functions
    available to query and alter run-time configuration parameters.
   </para>
-->
<para>
<xref linkend="functions-admin-set-table">显示了用于查询和修改运行时配置参数的函数。
</para>

   <table id="functions-admin-set-table">
    <!-- 
<title>Configuration Settings Functions</title> 
-->
<title>配置设置函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>get current value of setting</entry> 
   -->
   <entry>获取当前的设置值</entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>set parameter and return new value</entry> 
   -->
   <entry>设置参数并返回新值</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <!-- 
<primary>SET</primary> 
-->
<primary>设置</primary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>SHOW</primary> 
-->
<primary>显示</primary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary> 
-->
<primary>配置</primary>
    <secondary sortas="server">服务器</secondary>
    <tertiary>函数</tertiary>
   </indexterm>
   
<para>
<!--
    The function <function>current_setting</function> yields the
    current value of the setting <parameter>setting_name</parameter>.
    It corresponds to the <acronym>SQL</acronym> command
    <command>SHOW</command>.  An example:
-->
<function>current_setting</function>用于以查询形式获取<parameter>setting_name</parameter>
设置的当前值。它和<acronym>SQL</acronym>命令<command>SHOW</command>是等效的。比如：
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</programlisting>
   </para>
   
<para>
<!--
    <function>set_config</function> sets the parameter
    <parameter>setting_name</parameter> to
    <parameter>new_value</parameter>.  If
    <parameter>is_local</parameter> is <literal>true</literal>, the
    new value will only apply to the current transaction. If you want
    the new value to apply for the current session, use
    <literal>false</literal> instead. The function corresponds to the
    SQL command <command>SET</command>. An example:
-->
<function>set_config</function>将参数<parameter>setting_name</parameter>
设置为<parameter>new_value</parameter>。如果<parameter>is_local</parameter>
为<literal>true</literal>，那么新值将只应用于当前事务。
如果你希望新值应用于当前会话，那么应该使用<literal>false</literal>。
它等效于 SQL 命令<command>SET</command>。比如：
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-admin-signal">
   <!-- 
   <title>Server Signaling Functions</title>
   -->
   <title>服务器信号函数</title>

   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary> 
-->
<primary>信号</primary>
    <secondary sortas="backend">后端进程</secondary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref
    linkend="functions-admin-signal-table"> send control signals to
    other server processes.  Use of these functions is usually restricted
    to superusers, with noted exceptions.
   </para>
-->
<para>
 <xref linkend="functions-admin-signal-table">里的函数向其他服务器进程发送控制信号。
 通常这些函数的使用限制为超级用户，除了提到的例外。
</para>

   <table id="functions-admin-signal-table">
    <!-- 
<title>Server Signaling Functions</title> 
-->
<title>服务器信号函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Cancel a backend's current query.  You can execute this against
        another backend that has exactly the same role as the user calling the
        function.  In all other cases, you must be a superuser.
        </entry> 
-->
<entry>取消一个后端的当前查询。您可以对另一个后端执行这个函数，
   这个后端有和调用这个函数的用户相同的角色。在所有其他情况下，您必须是超级用户。
        </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Cause server processes to reload their configuration files</entry> 
   -->
   <entry>导致所有服务器进程重新装载它们的配置文件</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Rotate server's log file</entry> 
   -->
   <entry>滚动服务器的日志文件</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Terminate a backend.  You can execute this against
        another backend that has exactly the same role as the user
        calling the function.  In all other cases, you must be a
        superuser.
       </entry> 
   -->
   <entry>终止一个后端。您可以对另一个后端执行这个函数，
   这个后端有和调用这个函数的用户相同的角色。在所有其他情况下，您必须是超级用户。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Each of these functions returns <literal>true</literal> if
    successful and <literal>false</literal> otherwise.
   </para>
-->
<para>
如果成功，这些函数返回<literal>true</literal>，否则返回<literal>false</literal>。
</para>

   <!--
<para>
    <function>pg_cancel_backend</> and <function>pg_terminate_backend</>
    send signals (<systemitem>SIGINT</> or <systemitem>SIGTERM</>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</> on Unix or the <application>Task
    Manager</> on <productname>Windows</>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
   </para>
-->
<para>
<function>pg_cancel_backend</>和<function>pg_terminate_backend</>
向由 pid 标识的后端进程发送一个信号（分别是<systemitem>SIGINT</>或<systemitem>SIGTERM</>）。
一个活动的后端进程的 PID 可以从<structname>pg_stat_activity</structname>视图的
<structfield>pid</structfield>字段找到，或者在服务器上列出<command>postgres</command>进程
（在Unix上使用<application>ps</>或在<productname>Windows</>上使用<application>Task Manager</>）。
一个活动的后端角色可以从<structname>pg_stat_activity</structname>视图的
<structfield>usename</structfield>字段找到。
</para>

   <!--
<para>
    <function>pg_reload_conf</> sends a <systemitem>SIGHUP</> signal
    to the server, causing configuration files
    to be reloaded by all server processes.
   </para>
-->
<para>
<function>pg_reload_conf</>给服务器发送一个<systemitem>SIGHUP</>信号，
导致所有服务器进程重新装载配置文件。
</para>

   <!--
<para>
    <function>pg_rotate_logfile</> signals the log-file manager to switch
    to a new output file immediately.  This works only when the built-in
    log collector is running, since otherwise there is no log-file manager
    subprocess.
   </para>
-->
<para>
<function>pg_rotate_logfile</>给日志文件管理器发送信号，告诉它立即切换到一个新的输出文件。
这个函数只有在内建的日志收集器运行的时候才有用，否则根本不存在日志文件管理器子进程。
</para>

  </sect2>

  <sect2 id="functions-admin-backup">
   <!-- 
   <title>Backup Control Functions</title> 
   -->
   <title>备份控制函数</title>

   <indexterm>
    <!-- 
<primary>backup</primary> 
-->
<primary>备份</primary>
   </indexterm>
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_insert_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
   <indexterm>
    <primary>pg_switch_xlog</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name_offset</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_location_diff</primary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref
    linkend="functions-admin-backup-table"> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function>
    and <function>pg_xlog_location_diff</function>).
   </para>
-->
<para>
<xref linkend="functions-admin-backup-table">里的函数帮助我们进行在线备份。
这些函数不能在恢复时执行（除了<function>pg_is_in_backup</function>, 
<function>pg_backup_start_time</function>和<function>pg_xlog_location_diff</function>）
</para>

   <table id="functions-admin-backup-table">
    <!-- 
<title>Backup Control Functions</title> 
-->
<title>备份控制函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</> <type>text</>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Create a named point for performing restore (restricted to superusers)</entry> 
   -->
   <entry>为执行恢复创建一个命名点 (限制为超级用户)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_insert_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Get current transaction log insert location</entry> 
   -->
   <entry>获取当前事务日志的插入位置</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Get current transaction log write location</entry> 
   -->
   <entry>获取当前事务日志的写入位置</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</> <type>text</> <optional>, <parameter>fast</> <type>boolean</> </optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Prepare for performing on-line backup (restricted to superusers or replication roles)</entry>
   -->
   <entry>准备执行在线备份(限制为超级用户或复制的角色)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Finish performing on-line backup (restricted to superusers or replication roles)</entry> 
   -->
   <entry>完成执行在线备份 (限制为超级用户或复制的角色)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <!-- 
   <entry>True if an on-line exclusive backup is still in progress.</entry> 
   -->
   <entry>如果在线专属备份仍在进行中则为真。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <!-- 
   <entry>Get start time of an on-line exclusive backup in progress.</entry> 
   -->
   <entry>获取进行中的在线专属备份的开始时间。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_switch_xlog()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Force switch to a new transaction log file (restricted to superusers)</entry> 
   -->
   <entry>强制转向一个新的事务日志文件(限制为超级用户)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name(<parameter>location</> <type>pg_lsn</>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Convert transaction log location string to file name</entry> 
   -->
   <entry>将事务日志的位置字符串转换为文件名</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name_offset(<parameter>location</> <type>pg_lsn</>)</function></literal>
        </entry>
       <entry><type>text</>, <type>integer</></entry>
       <!-- 
   <entry>Convert transaction log location string to file name and decimal byte offset within file</entry>
   -->
   <entry>将事务日志的位置字符串转换为文件名并返回在文件中的字节偏移量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_location_diff(<parameter>location</> <type>pg_lsn</>, <parameter>location</> <type>pg_lsn</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
       <!-- 
   <entry>Calculate the difference between two transaction log locations</entry> 
   -->
   <entry>计算两个事务日志位置之间的区别</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  
<para>
<!--
    <function>pg_start_backup</> accepts an
    arbitrary user-defined label for the backup.  (Typically this would be
    the name under which the backup dump file will be stored.)  The function
    writes a backup label file (<filename>backup_label</>) into the
    database cluster's data directory, performs a checkpoint,
    and then returns the backup's starting transaction log location as text.
    The user can ignore this result value, but it is
    provided in case it is useful.
-->
<function>pg_start_backup</>接受一个用户定义的备份标签(通常这是备份转储文件存放地点的名字)。
这个函数向数据库集群的数据目录写入一个备份标签文件(<filename>backup_label</>)，执行一次检查点，
然后以文本方式返回备份的事务日志起始位置。用户可以忽略这个返回值，提供它只是为了万一需要的场合。
<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</programlisting>
<!-- 
    There is an optional second parameter of type <type>boolean</type>.  If <literal>true</>,
    it specifies executing <function>pg_start_backup</> as quickly as
    possible.  This forces an immediate checkpoint which will cause a
    spike in I/O operations, slowing any concurrently executing queries. 
-->
这个函数有第二个可选的类型为<type>boolean</type>的参数。如果为<literal>true</>，
那么指定尽可能快的执行<function>pg_start_backup</>。这强制一个立即的检查点，
将导致I/O操作有一个尖峰，减缓任何当前执行的查询。
   </para>
   <!--
<para>
    <function>pg_stop_backup</> removes the label file created by
    <function>pg_start_backup</>, and creates a backup history file in
    the transaction log archive area.  The history file includes the label given to
    <function>pg_start_backup</>, the starting and ending transaction log locations for
    the backup, and the starting and ending times of the backup.  The return
    value is the backup's ending transaction log location (which again
    can be ignored).  After recording the ending location, the current
    transaction log insertion
    point is automatically advanced to the next transaction log file, so that the
    ending transaction log file can be archived immediately to complete the backup.
   </para>
-->
<para>
<function>pg_stop_backup</>删除<function>pg_start_backup</>创建的标签文件，
并且在事务日志归档区里创建一个备份历史文件。这个历史文件包含给予<function>pg_start_backup</>
的标签、备份的事务日志起始与终止位置、备份的起始和终止时间。
返回值是备份的事务日志终止位置(同样也可以忽略)。计算出终止位置后，
当前事务日志的插入点将自动前进到下一个事务日志文件，这样，
结束的事务日志文件可以被立即归档从而完成备份。
</para>

   <!--
<para>
    <function>pg_switch_xlog</> moves to the next transaction log file, allowing the
    current file to be archived (assuming you are using continuous archiving).
    The return value is the ending transaction log location + 1 within the just-completed transaction log file.
    If there has been no transaction log activity since the last transaction log switch,
    <function>pg_switch_xlog</> does nothing and returns the start location
    of the transaction log file currently in use.
   </para>
-->
<para>
<function>pg_switch_xlog</>移动到下一个事务日志文件，以允许将当前日志文件归档
(假定你使用连续归档)。返回值是刚刚完成的事务日志文件的事务日志结束位置 + 1。
如果自从最后一次事务日志切换以来没有活动的事务日志，那么<function>pg_switch_xlog</>
什么事也不做，直接返回当前使用的事务日志文件的开始位置。
</para>

   <!--
<para>
    <function>pg_create_restore_point</> creates a named transaction log
    record that can be used as recovery target, and returns the corresponding
    transaction log location.  The given name can then be used with
    <xref linkend="recovery-target-name"> to specify the point up to which
    recovery will proceed.  Avoid creating multiple restore points with the
    same name, since recovery will stop at the first one whose name matches
    the recovery target.
   </para>
-->
<para>
<function>pg_create_restore_point</>创建一个可以用作恢复目标的命名的事务日志记录，
并返回相应的事务日志位置。给定的名字可以被<xref linkend="recovery-target-name">
使用以指定恢复将进行到的点。避免使用相同的名字创建多个恢复点，
因为恢复将在第一个名字匹配恢复目标的位置停止。
</para>

   <!--
<para>
    <function>pg_current_xlog_location</> displays the current transaction log write
    location in the same format used by the above functions.  Similarly,
    <function>pg_current_xlog_insert_location</> displays the current transaction log
    insertion point.  The insertion point is the <quote>logical</> end
    of the transaction log
    at any instant, while the write location is the end of what has actually
    been written out from the server's internal buffers.  The write location
    is the end of what can be examined from outside the server, and is usually
    what you want if you are interested in archiving partially-complete transaction log
    files.  The insertion point is made available primarily for server
    debugging purposes.  These are both read-only operations and do not
    require superuser permissions.
   </para>
-->
<para>
<function>pg_current_xlog_location</>使用与前面那些函数相同的格式显示当前事务日志的写入位置。
类似的，<function>pg_current_xlog_insert_location</>显示当前事务日志的插入位置。
插入点是事务日志在某个瞬间的<quote>逻辑终点</>，
而实际的写入位置则是从服务器内部缓冲区写出时的终点。写入位置是可以从服务器外部检测到的终点，
如果想归档部分完成的事务日志文件，那么这个通常就是你想要的结果。插入点主要用于服务器调试目的。
上述两个函数既是只读操作也不需要超级用户权限。
</para>

   
<para>
<!--
    You can use <function>pg_xlogfile_name_offset</> to extract the
    corresponding transaction log file name and byte offset from the results of any of the
    above functions.  For example:
-->
可以使用<function>pg_xlogfile_name_offset</>
从前述函数的返回结果中抽取相应的事务日志文件名称和字节偏移量。例如：
<programlisting>
postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
<!-- 
    Similarly, <function>pg_xlogfile_name</> extracts just the transaction log file name.
    When the given transaction log location is exactly at a transaction log file boundary, both
    these functions return the name of the preceding transaction log file.
    This is usually the desired behavior for managing transaction log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived. 
-->
类似的，<function>pg_xlogfile_name</>仅仅抽取事务日志文件名称。
如果给定的事务日志位置恰好位于事务日志文件的交界上，这两个函数都返回前一个事务日志文件的名字。
这对于管理事务日志归档来说通常是期望的行为，因为前一个文件是当前最后一个需要归档的文件。
   </para>
   <!--
<para>
    <function>pg_xlog_location_diff</> calculates the difference in bytes
    between two transaction log locations. It can be used with
    <structname>pg_stat_replication</structname> or some functions shown in
    <xref linkend="functions-admin-backup-table"> to get the replication lag.
   </para>
-->
<para>
<function>pg_xlog_location_diff</>计算两个事务日志位置之间在字节上的不同。
它可以和<structname>pg_stat_replication</structname>或<xref linkend="functions-admin-backup-table">
里面的一些函数一起使用以获取复制滞后。
</para>

   <!--
<para>
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving">.
   </para>
-->
<para>
有关正确使用这些函数的细节，参阅<xref linkend="continuous-archiving">。
</para>

  </sect2>

  <sect2 id="functions-recovery-control">
   <!-- 
   <title>Recovery Control Functions</title> 
   -->
   <title>恢复控制函数</title>

   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_receive_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_replay_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref
    linkend="functions-recovery-info-table"> provide information
    about the current status of the standby.
    These functions may be executed both during recovery and in normal running.
   </para>
-->
<para>
<xref linkend="functions-recovery-info-table">里显示的函数提供了当前备机状态的信息。
这些函数可能在恢复期间或正常运行中执行。
</para>

   <table id="functions-recovery-info-table">
    <!-- 
<title>Recovery Information Functions</title>
-->
<title>恢复信息函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <!-- 
   <entry>True if recovery is still in progress.
       </entry> 
   -->
   <entry>如果恢复仍然在进行中则返回true。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_receive_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Get last transaction log location received and synced to disk by
        streaming replication. While streaming replication is in progress
        this will increase monotonically. If recovery has completed this will
        remain static at
        the value of the last WAL record received and synced to disk during
        recovery. If streaming replication is disabled, or if it has not yet
        started, the function returns NULL.
       </entry> 
   -->
   <entry>获取最后一个事务日志接收并通过流媒体复制同步到磁盘的位置。
   如果流复制仍在进行，这将单调增加。如果恢复已完成，
   那么这个值将保持静止在恢复期间最后接收和同步到磁盘的WAL记录值。
   如果不能用流复制，或还没有开始，这个函数返回NULL。 
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_replay_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <!-- 
   <entry>Get last transaction log location replayed during recovery.
        If recovery is still in progress this will increase monotonically.
        If recovery has completed then this value will remain static at
        the value of the last WAL record applied during that recovery.
        When the server has been started normally without recovery
        the function returns NULL.
       </entry> 
   -->
   <entry>获取最后一个事物日志在恢复时重放的位置。如果恢复仍在进行，这将单调增加。
   如果恢复已经完成，那么这个值将保持静止在恢复期间最后应用的WAL记录值。
   当服务已经没有恢复的正常启动时，这个函数返回NULL。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <!-- 
   <entry>Get time stamp of last transaction replayed during recovery.
        This is the time at which the commit or abort WAL record for that
        transaction was generated on the primary.
        If no transactions have been replayed during recovery, this function
        returns NULL.  Otherwise, if recovery is still in progress this will
        increase monotonically.  If recovery has completed then this value will
        remain static at the value of the last transaction applied during that
        recovery.  When the server has been started normally without recovery
        the function returns NULL.
       </entry> 
   -->
   <entry>获取最后一个事物在恢复时重放的时间戳。这是为在主节点上生成的事务提交或终止WAL记录的时间。
   如果没有事务在恢复时重放，那么这个函数返回NULL。否则，如果恢复仍在进行，
   那么这将单调增加。如果恢复已经完成，那么这个值将保持静止在恢复时最后事务应用的值。
   当服务已经没有恢复的正常启动时，这个函数返回NULL。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_is_xlog_replay_paused</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_pause</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_resume</primary>
   </indexterm>

   <!--
<para>
    The functions shown in <xref
    linkend="functions-recovery-control-table"> control the progress of recovery.
    These functions may be executed only during recovery.
   </para>
-->
<para>
<xref linkend="functions-recovery-control-table">里的函数控制恢复的进程。
这些函数可能只在恢复时被执行。
</para>

   <table id="functions-recovery-control-table">
    <!-- 
<title>Recovery Control Functions</title> 
-->
<title>恢复控制函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_xlog_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <!-- 
   <entry>True if recovery is paused.
       </entry>
   -->
   <entry>如果恢复暂停则返回true。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <!-- 
       <entry>Pauses recovery immediately (restricted to superusers).
       </entry> 
   -->
   <entry>立即暂停恢复（受限于超级用户）。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <!-- 
       <entry>Restarts recovery if it was paused (restricted to superusers).
       </entry> 
   -->
   <entry>如果恢复暂停了那么重新启动（受限于超级用户）。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    While recovery is paused no further database changes are applied.
    If in hot standby, all new queries will see the same consistent snapshot
    of the database, and no further query conflicts will be generated until
    recovery is resumed.
   </para>
-->
<para>
当恢复暂停时，没有进一步的数据库更改。如果是在热备里，所有新的查询将看到相同一致的数据库快照，
并且不会有进一步的查询冲突产生，直到恢复继续。
</para>

   <!--
<para>
    If streaming replication is disabled, the paused state may continue
    indefinitely without problem. While streaming replication is in
    progress WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
   </para>
-->
<para>
如果不能使用流复制，那么暂停状态将没有问题的无限的延续。
当流复制正在进行时，将连续接收WAL记录，这将最终填满可用磁盘空间，取决于暂停的持续时间，
WAL生成的速度和可用的磁盘空间。
</para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
   <!-- 
   <title>Snapshot Synchronization Functions</title> 
   -->
   <title>快照同步函数</title>

   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</> commands,
    so that one session sees the effects of that transaction and the other
    does not.
   </para>
-->
<para>
<productname>PostgreSQL</>允许数据库会话同步他们的快照。<firstterm>snapshot</>
决定哪个数据对于使用这个快照的事务是可见的。当两个或更多会话需要查看数据库中相同的内容时，
快照同步是必须的。如果两个会话只是单独的启动它们的事务，仍然可能有某些事务在这两个
<command>START TRANSACTION</>命令执行之间提交，所以一个会话看到了那个事务的影响而另外一个没有看到。
</para>

   <!--
<para>
    To solve this problem, <productname>PostgreSQL</> allows a transaction to
    <firstterm>export</> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
   </para>
-->
<para>
要解决这些问题，<productname>PostgreSQL</>允许一个事务<firstterm>export</>
它正在使用的快照。只要导出事务保持打开，其他事务可以<firstterm>import</>
它的快照，因此来保证他们看到的是与第一个事务看到的完全相同的数据库视图。
但是要注意的是，由任一这些事务做出的任何数据库更改对其他事务保持不可见，
对由未提交的事务做出的更改同样适用。所以事务是与已经存在的数据同步的，
但是对它们自己做的更改正常动作。
</para>

   <!--
<para>
    Snapshots are exported with the <function>pg_export_snapshot</> function,
    shown in <xref linkend="functions-snapshot-synchronization-table">, and
    imported with the <xref linkend="sql-set-transaction"> command.
   </para>
-->
<para>
快照是由<function>pg_export_snapshot</>函数输出的，在<xref linkend="functions-snapshot-synchronization-table">
里面显示，并且是由<xref linkend="sql-set-transaction">命令输入的。
</para>

   <table id="functions-snapshot-synchronization-table">
    <!-- 
<title>Snapshot Synchronization Functions</title> 
-->
<title>快照同步函数</title>
    <tgroup cols="3">
     <thead>
      <row><!-- 
  <entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Save the current snapshot and return its identifier</entry> 
   -->
   <entry>保存当前的快照并返回它的标识符</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The function <function>pg_export_snapshot</> saves the current snapshot
    and returns a <type>text</> string identifying the snapshot.  This string
    must be passed (outside the database) to clients that want to import the
    snapshot.  The snapshot is available for import only until the end of the
    transaction that exported it.  A transaction can export more than one
    snapshot, if needed.  Note that doing so is only useful in <literal>READ
    COMMITTED</> transactions, since in <literal>REPEATABLE READ</> and
    higher isolation levels, transactions use the same snapshot throughout
    their lifetime.  Once a transaction has exported any snapshots, it cannot
    be prepared with <xref linkend="sql-prepare-transaction">.
   </para>
-->
<para>
函数<function>pg_export_snapshot</>保存当前的快照并返回一个<type>text</>字符串标识这个快照。
这个字符串必须传递（在数据库外面）给想要导入快照的客户端。这个快照只在事务结束输出它之前是可以导入的。
如果需要的话，一个事务可以输出多个快照。请注意，这样做只在<literal>READ COMMITTED</>事务中有用，
因为在<literal>REPEATABLE READ</>和更高的隔离级别，事务在他们的生存周期中使用相同的快照。
一旦一个事务已经输出了任何的快照，它就不能使用<xref linkend="sql-prepare-transaction">做好准备了。
</para>

   <!--
<para>
    See  <xref linkend="sql-set-transaction"> for details of how to use an
    exported snapshot.
   </para>
-->
<para>
参阅<xref linkend="sql-set-transaction">获取如何使用一个输出的快照的信息。
</para>
  </sect2>

  <sect2 id="functions-replication">
   <!--
   <title>Replication Functions</title>
   -->
   <title>复制函数</title>
<!--
    <para>
    The functions shown in <xref linkend="functions-replication-table"> are
    for controlling and interacting with replication features.
    See <xref linkend="streaming-replication">
    and <xref linkend="streaming-replication-slots"> for information about the
    underlying features.  Use of these functions is restricted to superusers.
   </para>
-->
<para>
<xref linkend="functions-replication-table">中显示的函数是为了控制和与复制功能交互的。
参阅<xref linkend="streaming-replication">和<xref linkend="streaming-replication-slots">
获取关于基本功能的信息。这些函数的使用受限于超级用户。
</para>
<!-- 
   <para>
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication">.
   </para>
-->
<para>
在复制协议中有许多这些函数的相等命令；参阅<xref linkend="protocol-replication">。
</para>
<!-- 
   <para>
    The functions described in <xref linkend="functions-snapshot-synchronization">, <xref
    linkend="functions-recovery-control">, and <xref
    linkend="functions-admin-backup"> are also relevant for replication.
   </para>
-->
<para>
<xref linkend="functions-snapshot-synchronization">、<xref
    linkend="functions-recovery-control">和<xref
    linkend="functions-admin-backup">中描述的函数也是与复制相关的。
</para>
   <table id="functions-replication-table">
    <!--
    <title>Replication <acronym>SQL</acronym> Functions</title>
    -->
    <title>复制 <acronym>SQL</acronym> 函数</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       -->
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        <!-- 
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. Streaming changes from a physical slot
        is only possible with the streaming-replication protocol - see <xref
        linkend="protocol-replication">. Corresponds to the replication protocol
        command <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>. 
        -->
        创建一个名为<parameter>slot_name</parameter>的新物理复制槽。
        从物理槽流动更改仅在有流复制槽协议的时候是可能的——参阅
        <xref linkend="protocol-replication">。对应于复制协议命令
        <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
        <!--
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</>.
        -->
        删除名为<parameter>slot_name</parameter>的物理或逻辑复制槽。
        和复制协议命令<literal>DROP_REPLICATION_SLOT</>相同。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
        <!-- 
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>.  A call to this function has the same
        effect as the replication protocol command
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
        -->
        使用输出插件<parameter>plugin</parameter>创建一个新的名为
        <parameter>slot_name</parameter>的逻辑（解码）复制槽。
        调用此函数和复制协议命令<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>
        的效果相同。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        <!-- 
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point at which since changes have been consumed last.  If
        <parameter>upto_lsn</> and <parameter>upto_nchanges</> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit. 
        -->
        返回槽<parameter>slot_name</parameter>中的变化，从最后一次访问的点开始。
        如果<parameter>upto_lsn</>和<parameter>upto_nchanges</>为NULL，
        逻辑解码将持续到WAL的结束。如果<parameter>upto_lsn</>非空，
        解码将只包括那些在指定LSN之前提交的事务。如果
        <parameter>upto_nchanges</parameter>非空，
        解码将在解码的行数超过指定的值时停止。不过，请注意，
        实际返回的行数可能稍多些，因为这个限制仅在解码每个新的事务提交，
        产生添加的行之后检查。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>text</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
        <!-- 
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls. 
        -->
        表现就像<function>pg_logical_slot_get_changes()</function>函数那样，
        除了没有消耗修改；也就是它们将在未来的调用中再次返回。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        <!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
        -->
        表现就像<function>pg_logical_slot_get_changes()</function>函数那样，
        除了修改作为<type>bytea</type>返回。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
        <!-- 
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type> and that
        changes are not consumed; that is, they will be returned again
        on future calls. 
        -->
        表现就像<function>pg_logical_slot_get_changes()</function>函数，
        除了修改作为<type>bytea</type>返回，并且不消耗修改；
        也就是，它们将在未来的调用中再次返回。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="functions-admin-dbobject">
   <!-- 
   <title>Database Object Management Functions</title>
   -->
   <title>数据库对象管理函数</title>

   <!--
<para>
    The functions shown in <xref linkend="functions-admin-dbsize"> calculate
    the disk space usage of database objects.
   </para>
-->
<para>
<xref linkend="functions-admin-dbsize">里显示的函数计算数据库对象使用的磁盘空间。
</para>

   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>

   <table id="functions-admin-dbsize">
    <!-- 
<title>Database Object Size Functions</title> 
-->
<title>数据库对象尺寸函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <!-- 
   <entry>Number of bytes used to store a particular value (possibly compressed)</entry> 
   -->
   <entry>存储一个指定的数值需要的字节数(可能压缩过)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>Disk space used by the database with the specified OID</entry> 
   -->
   <entry>指定 OID 代表的数据库使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>Disk space used by the database with the specified name</entry> 
   -->
   <entry>指定名称的数据库使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>
        Total disk space used by indexes attached to the specified table
       </entry> 
   -->
   <entry>
        附加到指定表的索引使用的总磁盘空间
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>
        Disk space used by the specified fork (<literal>'main'</literal>,
        <literal>'fsm'</literal>, <literal>'vm'</>, or <literal>'init'</>)
        of the specified table or index
       </entry> 
   -->
   <entry>
        指定表或索引的指定分叉树(<literal>'main'</literal>, <literal>'fsm'</literal>
<literal>'vm'</>或 <literal>'init'</>)使用的磁盘空间
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>
        Shorthand for <literal>pg_relation_size(..., 'main')</literal>
       </entry> 
   -->
   <entry>
        <literal>pg_relation_size(..., 'main')的简写</literal>
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>
         Converts a size in bytes expressed as a 64-bit integer into a
         human-readable format with size units
       </entry> 
   -->
   <entry>
        把用64位整数表示的字节计算的尺寸转换成一个人类易读的尺寸
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>
         Converts a size in bytes expressed as a numeric value into a
         human-readable format with size units
       </entry> 
   -->
   <entry>
        把用数值表示的字节计算的尺寸转换成一个人类易读的尺寸
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>
        Disk space used by the specified table, excluding indexes
        (but including TOAST, free space map, and visibility map)
       </entry> 
   -->
   <entry>
        指定的表使用的磁盘空间，不计索引（但是包含TOAST，自由空间映射和可见性映射）
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>Disk space used by the tablespace with the specified OID</entry> 
   -->
   <entry>指定 OID 代表的表空间使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>Disk space used by the tablespace with the specified name</entry> 
   -->
   <entry>指定名字的表空间使用的磁盘空间</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <!-- 
   <entry>
        Total disk space used by the specified table,
        including all indexes and <acronym>TOAST</> data
       </entry> 
   -->
   <entry>
        指定的表使用的总磁盘空间，包括所有的索引和<acronym>TOAST</>数据
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    <function>pg_column_size</> shows the space used to store any individual
    data value.
   </para>
-->
<para>
<function>pg_column_size</>显示用于存储某个独立数据值的空间。
</para>

   <!--
<para>
    <function>pg_total_relation_size</> accepts the OID or name of a
    table or toast table, and returns the total on-disk space used for
    that table, including all associated indexes.  This function is
    equivalent to <function>pg_table_size</function>
    <literal>+</> <function>pg_indexes_size</function>.
   </para>
-->
<para>
<function>pg_total_relation_size</>接受一个表或压缩表的OID或名字，
并且返回那个表使用的总的在磁盘上的空间，包括所有相关的索引。
这个函数相当于<function>pg_table_size</function>
 <literal>+</> <function>pg_indexes_size</function>
</para>

   <!--
<para>
    <function>pg_table_size</> accepts the OID or name of a table and
    returns the disk space needed for that table, exclusive of indexes.
    (TOAST space, free space map, and visibility map are included.)
   </para>
-->
<para>
<function>pg_table_size</>接受一个表的OID或名字，并且返回那个表需要的磁盘空间，
不包括索引。（包含TOAST空间，自由空间映射和可见性映射）
</para>

   <!--
<para>
    <function>pg_indexes_size</> accepts the OID or name of a table and
    returns the total disk space used by all the indexes attached to that
    table.
   </para>
-->
<para>
<function>pg_indexes_size</>接受一个表的OID或名字，
并且返回所有附加到这个表上的索引使用的总的磁盘空间。
</para>

   <!--
<para>
    <function>pg_database_size</function> and <function>pg_tablespace_size</>
    accept the OID or name of a database or tablespace, and return the total
    disk space used therein.  To use <function>pg_database_size</function>,
    you must have <literal>CONNECT</> permission on the specified database
    (which is granted by default).  To use <function>pg_tablespace_size</>,
    you must have <literal>CREATE</> permission on the specified tablespace,
    unless it is the default tablespace for the current database.
   </para>
-->
<para>
<function>pg_database_size</function>和<function>pg_tablespace_size</>
接受一个数据库或表空间的OID或名字，并且返回该对象使用的总的磁盘空间。
要使用<function>pg_database_size</function>，你必须在指定的数据库上
拥有<literal>CONNECT</>权限（缺省赋予的）。要使用<function>pg_tablespace_size</>，
你必须在指定的表空间上拥有<literal>CREATE</>权限，除非它是当前数据库的缺省表空间。
</para>


<para>
   <!--
    <function>pg_relation_size</> accepts the OID or name of a table, index
    or toast table, and returns the on-disk size in bytes of one fork of
    that relation.  (Note that for most purposes it is more convenient to
    use the higher-level functions <function>pg_total_relation_size</>
    or <function>pg_table_size</>, which sum the sizes of all forks.)
    With one argument, it returns the size of the main data fork of the
    relation.  The second argument can be provided to specify which fork
    to examine:
-->
<para>
<function>pg_relation_size</>接受一个表、索引、压缩表的 OID 或者名字，
然后返回该关系的一个分支以字节计的磁盘大小。（请注意，
对于大多数场合，使用高级函数<function>pg_total_relation_size</>
或<function>pg_table_size</>更加方便，它们统计所有分支的总和。）
带有一个参数，它返回该关系的主数据分支的大小。
可以提供第二个参数声明检测那个分支：
</para>

    <itemizedlist spacing="compact">
     <listitem>
      <!-- 
      <para>
       <literal>'main'</literal> returns the size of the main
       data fork of the relation.
      </para>
      -->
      <para>
       <literal>'main'</literal>返回这个关系的主数据支路的大小。
      </para>
     </listitem>
     <listitem>
      <!--
      <para>
      <literal>'fsm'</literal> returns the size of the Free Space Map
       (see <xref linkend="storage-fsm">) associated with the relation.
      </para>
      -->
      <para>
<literal>'fsm'</literal>返回和这个关系有关的自由空间映射
（参阅<xref linkend="storage-fsm">）的大小。
      </para>
     </listitem>
     <listitem>
      <!-- 
      <para>
       <literal>'vm'</literal> returns the size of the Visibility Map
       (see <xref linkend="storage-vm">) associated with the relation.
      </para>
      -->
      <para>
       <literal>'vm'</literal>返回和这个关系有关的可见性映射
（参阅<xref linkend="storage-vm">）的大小。
      </para>
     </listitem>
     <listitem>
      <!-- 
      <para>
       <literal>'init'</literal> returns the size of the initialization
       fork, if any, associated with the relation.
      </para>
      -->
      <para>
       <literal>'init'</literal>返回和这个关系有关的初始分支的大小，如果有。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    <function>pg_size_pretty</> can be used to format the result of one of
    the other functions in a human-readable way, using kB, MB, GB or TB as
    appropriate.
   </para>
-->
<para>
<function>pg_size_pretty</>用于把其它函数的结果格式化成一种人类易读的格式，
可以根据情况使用KB 、MB 、GB 、TB 。
</para>

   <!--
<para>
    The functions above that operate on tables or indexes accept a
    <type>regclass</> argument, which is simply the OID of the table or index
    in the <structname>pg_class</> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</> data type's input
    converter will do the work for you.  Just write the table name enclosed in
    single quotes so that it looks like a literal constant.  For compatibility
    with the handling of ordinary <acronym>SQL</acronym> names, the string
    will be converted to lower case unless it contains double quotes around
    the table name.
   </para>
-->
<para>
以上操作在表或索引上的函数接受一个<type>regclass</>参数，这个参数简单的是表的OID
或<structname>pg_class</>系统目录中的索引。你不需要手动的去查看OID，
因为<type>regclass</>数据类型的输入转换将为你做这件事。只需要写下包含在单引号中的表名，
这样看起来像是一个字符串常量。为了与普通的<acronym>SQL</acronym>名字的处理兼容，
这个字符串将被转换成小写，除非表名用双引号括起。
</para>

   <!--
<para>
    If an OID that does not represent an existing object is passed as
    argument to one of the above functions, NULL is returned.
   </para>
-->
<para>
如果一个不代表活动对象的OID传递给以上一个函数的参数，那么返回NULL。
</para>

   <!--
<para>
    The functions shown in <xref linkend="functions-admin-dblocation"> assist
    in identifying the specific disk files associated with database objects.
   </para>
-->
<para>
<xref linkend="functions-admin-dblocation">里显示的函数帮助标识指定的与数据库对象有关的磁盘文件。
</para>

   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>

   <table id="functions-admin-dblocation">
    <!-- 
<title>Database Object Location Functions</title> 
-->
<title>数据库对象位置函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <!-- 
   <entry>
        Filenode number of the specified relation
       </entry>
   -->
   <entry>
        指定关系的文件节点数
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>
        File path name of the specified relation
       </entry> 
   -->
   <entry>
        指定关系的文件路径名
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
        <!--
        Find the relation associated with a given tablespace and filenode
        -->
        找出与一个给定表空间和节点相关的关系
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    <function>pg_relation_filenode</> accepts the OID or name of a table,
    index, sequence, or toast table, and returns the <quote>filenode</> number
    currently assigned to it.  The filenode is the base component of the file
    name(s) used for the relation (see <xref linkend="storage-file-layout">
    for more information).  For most tables the result is the same as
    <structname>pg_class</>.<structfield>relfilenode</>, but for certain
    system catalogs <structfield>relfilenode</> is zero and this function must
    be used to get the correct value.  The function returns NULL if passed
    a relation that does not have storage, such as a view.
   </para>
-->
<para>
<function>pg_relation_filenode</>接受一个表、索引、序列或压缩表的OID或者名字，
并且返回当前分配给它的<quote>filenode</>数。文件节点是关系使用的文件名字的基本组件
（参阅<xref linkend="storage-file-layout">获取更多信息）。对大多数表来说，
结果和<structname>pg_class</>.<structfield>relfilenode</>相同，但对确定的系统目录来说，
<structfield>relfilenode</>为0而且这个函数必须用来获取正确的值。
如果传递一个没有存储的关系，比如一个视图，那么这个函数返回NULL。
</para>

   <!--
<para>
    <function>pg_relation_filepath</> is similar to
    <function>pg_relation_filenode</>, but it returns the entire file path name
    (relative to the database cluster's data directory <varname>PGDATA</>) of
    the relation.
   </para>
-->
<para>
<function>pg_relation_filepath</>类似于<function>pg_relation_filenode</>，
但是它返回关系的整个文件路径名（相对于数据库集群的数据目录<varname>PGDATA</>）。
</para>

<!-- 
   <para>
    <function>pg_filenode_relation</> is the reverse of
    <function>pg_relation_filenode</>. Given a <quote>tablespace</> OID and
    a <quote>filenode</>, it returns the associated relation's OID. For a table
    in the database's default tablespace, the tablespace can be specified as 0.
   </para>
-->
<para>
<function>pg_filenode_relation</>是<function>pg_relation_filenode</>的逆反。
给出一个<quote>tablespace</> OID和<quote>filenode</>，
它返回相关关系的OID。对于一个数据库的缺省表空间中的表，
该表空间可以指定为0。
</para>
  </sect2>

  <sect2 id="functions-admin-genfile">
   <!-- 
   <title>Generic File Access Functions</title> 
   -->
   <title>通用文件访问函数</title>

   <!--
<para>
    The functions shown in <xref
    linkend="functions-admin-genfile-table"> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</> can be
    accessed.  Use a relative path for files in the cluster directory,
    and a path matching the <varname>log_directory</> configuration setting
    for log files.  Use of these functions is restricted to superusers.
   </para>
-->
<para>
<xref linkend="functions-admin-genfile-table">
里的函数提供了对数据库服务器所在机器上的文件的本地访问接口。
只有那些在数据库集群目录和<varname>log_directory</>目录里面的文件可以访问。
使用相对路径访问集群目录里面的文件，以及匹配<varname>log_directory</>
配置设置的路径访问日志文件。只有超级用户才能使用这些函数。
</para>

   <table id="functions-admin-genfile-table">
    <!-- 
<title>Generic File Access Functions</title> 
-->
<title>通用文件访问函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</> <type>text</>)</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <!-- 
   <entry>List the contents of a directory</entry> 
   -->
   <entry>列出目录中的文件</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <!-- 
   <entry>Return the contents of a text file</entry> 
   -->
   <entry>返回一个文本文件的内容</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</>])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <!-- 
   <entry>Return the contents of a file</entry> 
   -->
   <entry>返回一个文件的内容</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</> <type>text</>)</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <!-- 
   <entry>Return information about a file</entry> 
   -->
   <entry>返回一个文件的信息</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
   <!--
<para>
    <function>pg_ls_dir</> returns all the names in the specified
    directory, except the special entries <quote><literal>.</></> and
    <quote><literal>..</></>.
   </para>
-->
<para>
<function>pg_ls_dir</>返回指定目录里面的除了特殊项<quote><literal>.</></>
和<quote><literal>..</></>之外的所有名字。
</para>

   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
   <!--
<para>
    <function>pg_read_file</> returns part of a text file, starting
    at the given <parameter>offset</>, returning at most <parameter>length</>
    bytes (less if the end of file is reached first).  If <parameter>offset</>
    is negative, it is relative to the end of the file.
    If <parameter>offset</> and <parameter>length</> are omitted, the entire
    file is returned.  The bytes read from the file are interpreted as a string
    in the server encoding; an error is thrown if they are not valid in that
    encoding.
   </para>
-->
<para>
<function>pg_read_file</>返回一个文本文件的一部分，从<parameter>offset</>开始，
返回最多<parameter>length</>字节(如果先达到文件结尾，则小于这个数值)。
如果<parameter>offset</>是负数，那么它就是相对于文件结尾回退的长度。
如果省略了<parameter>offset</>和<parameter>length</>，则返回整个文件。
从文件读取到的字节在服务器编码里被解释为一个字符串；
如果它们在那种编码下是不可用的则抛出一个错误。
</para>

   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
  
<para>
 <!--
    <function>pg_read_binary_file</> is similar to
    <function>pg_read_file</>, except that the result is a <type>bytea</type> value;
    accordingly, no encoding checks are performed.
    In combination with the <function>convert_from</> function, this function
    can be used to read a file in a specified encoding:
-->
<function>pg_read_binary_file</>类似于<function>pg_read_file</>，
除了结果是<type>bytea</type>值；因此，不执行编码检查。
与<function>convert_from</>函数结合，这个函数可以用来读取用指定编码的一个文件。
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>

   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
  
<para>
 <!--
    <function>pg_stat_file</> returns a record containing the file
    size, last accessed time stamp, last modified time stamp,
    last file status change time stamp (Unix platforms only),
    file creation time stamp (Windows only), and a <type>boolean</type>
    indicating if it is a directory.  Typical usages include:
-->
<function>pg_stat_file</>返回一个记录，这个记录包含文件大小，
最后访问的时间戳，最后修改的时间戳，最后文件状态改变的时间戳（只在Unix平台上），
文件创建的时间戳（只在Windows），和一个<type>boolean</type>表明是否为一个路径。
典型的用法包括：
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-advisory-locks">
   <!-- 
   <title>Advisory Lock Functions</title> 
   -->
   <title>咨询锁函数</title>

   <!--
<para>
    The functions shown in <xref linkend="functions-advisory-locks-table">
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks">.
   </para>
-->
<para>
<xref linkend="functions-advisory-locks-table">中的函数用于管理咨询锁(Advisory Lock)。
有关正确使用这些函数的细节，参阅<xref linkend="advisory-locks">。
</para>

   <table id="functions-advisory-locks-table">
    <!-- 
<title>Advisory Lock Functions</title> 
-->
<title>咨询锁函数</title>
    <tgroup cols="3">
     <thead>
      <!-- 
  <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry> 
  -->
  <row><entry>名字</entry> <entry>返回类型</entry> <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain exclusive session level advisory lock</entry> 
   -->
   <entry>获取排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain exclusive session level advisory lock</entry> 
   -->
   <entry>获取排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain shared session level advisory lock</entry> 
   -->
   <entry>获取共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain shared session level advisory lock</entry>
   -->
   <entry>获取共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Release an exclusive session level advisory lock</entry> 
   -->
   <entry>释放一个排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Release an exclusive session level advisory lock</entry> 
   -->
   <entry>释放一个排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Release all session level advisory locks held by the current session</entry> 
   -->
   <entry>释放所有当前会话持有的会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Release a shared session level advisory lock</entry> 
   -->
   <entry>释放一个共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Release a shared session level advisory lock</entry> 
   -->
   <entry>释放一个共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain exclusive transaction level advisory lock</entry> 
   -->
   <entry>获取排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain exclusive transaction level advisory lock</entry> 
   -->
   <entry>获取排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain shared transaction level advisory lock</entry> 
   -->
   <entry>获取共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <!-- 
   <entry>Obtain shared transaction level advisory lock</entry> 
   -->
   <entry>获取共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain exclusive session level advisory lock if available</entry> 
   -->
   <entry>尝试获取排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain exclusive session level advisory lock if available</entry> 
   -->
   <entry>尝试获取排他会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain shared session level advisory lock if available</entry> 
   -->
   <entry>尝试获取共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain shared session level advisory lock if available</entry> 
   -->
   <entry>尝试获取共享会话级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain exclusive transaction level advisory lock if available</entry> 
   -->
   <entry>尝试获取排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain exclusive transaction level advisory lock if available</entry> 
   -->
   <entry>尝试获取排他事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain shared transaction level advisory lock if available</entry> 
   -->
   <entry>尝试获取共享事务级别咨询锁</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>Obtain shared transaction level advisory lock if available</entry> 
   -->
   <entry>尝试获取共享事务级别咨询锁</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_lock</> locks an application-defined resource,
    which can be identified either by a single 64-bit key value or two
    32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a lock on the same resource identifier,
    this function will wait until the resource becomes available.  The lock
    is exclusive.  Multiple lock requests stack, so that if the same resource
    is locked three times it must then be unlocked three times to be
    released for other sessions' use.
   </para>
-->
<para>
<function>pg_advisory_lock</>锁定一个应用程序定义的资源，
该资源可以用一个 64 位或两个不重叠的 32 位键值标识。如果已经有另外的会话锁定了该资源，
那么该函数将会阻塞到该资源可用为止。这个锁是排它的。多个锁定请求将会被压入栈中，因此，
如果同一个资源被锁定了三次，那么它必须被解锁三次以将资源释放给其它会话使用。
</para>

   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_lock_shared</> works the same as
    <function>pg_advisory_lock</>,
    except the lock can be shared with other sessions requesting shared locks.
    Only would-be exclusive lockers are locked out.
   </para>
-->
<para>
<function>pg_advisory_lock_shared</>类似于<function>pg_advisory_lock</>，
不同之处仅在于共享锁可以和其它请求共享锁的会话共享，但排他锁除外。
</para>

   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
   <!--
<para>
    <function>pg_try_advisory_lock</> is similar to
    <function>pg_advisory_lock</>, except the function will not wait for the
    lock to become available.  It will either obtain the lock immediately and
    return <literal>true</>, or return <literal>false</> if the lock cannot be
    acquired immediately.
   </para>
-->
<para>
<function>pg_try_advisory_lock</>类似于<function>pg_advisory_lock</>，
不同之处在于该函数不会阻塞以等待资源的释放。它要么立即获得锁并返回<literal>true</>，
要么返回<literal>false</>表示目前不能锁定。
</para>

   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
   <!--
<para>
    <function>pg_try_advisory_lock_shared</> works the same as
    <function>pg_try_advisory_lock</>, except it attempts to acquire
    a shared rather than an exclusive lock.
   </para>
-->
<para>
<function>pg_try_advisory_lock_shared</>类似于<function>pg_try_advisory_lock</>，
不同之处在于该函数尝试获得一个共享锁而不是一个排它锁。
</para>

   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_unlock</> will release a previously-acquired
    exclusive session level advisory lock.  It
    returns <literal>true</> if the lock is successfully released.
    If the lock was not held, it will return <literal>false</>,
    and in addition, an SQL warning will be reported by the server.
   </para>
-->
<para>
<function>pg_advisory_unlock</>释放先前取得的排他会话级别咨询锁。
如果释放成功则返回<literal>true</>。如果指定的锁并未持有，
那么它将返回<literal>false</>并且服务器会报告一条 SQL 警告消息。
</para>

   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_unlock_shared</> works the same as
    <function>pg_advisory_unlock</>,
    except it releases a shared session level advisory lock.
   </para>
-->
<para>
<function>pg_advisory_unlock_shared</>类似于<function>pg_advisory_unlock</>，
不同之处在于该函数释放的是共享会话级别咨询锁。
</para>

   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_unlock_all</> will release all session level advisory
    locks held by the current session.  (This function is implicitly invoked
    at session end, even if the client disconnects ungracefully.)
   </para>
-->
<para>
<function>pg_advisory_unlock_all</>将会释放当前会话持有的所有会话级别咨询锁，
该函数在会话结束的时候被隐含调用，即使客户端异常地断开连接也是一样。
</para>

   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_xact_lock</> works the same as
    <function>pg_advisory_lock</>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
   </para>
-->
<para>
<function>pg_advisory_xact_lock</>类似于<function>pg_advisory_lock</>，
不同之处在于锁是自动在当前事务的结束释放的，而且不能被显式的释放。
</para>

   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
   <!--
<para>
    <function>pg_advisory_xact_lock_shared</> works the same as
    <function>pg_advisory_lock_shared</>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
   </para>
-->
<para>
<function>pg_advisory_xact_lock_shared</>类似于 <function>pg_advisory_lock_shared</>，
不同之处在于锁是自动在当前事务的结束释放的，而且不能被显式的释放。
</para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
   <!--
<para>
    <function>pg_try_advisory_xact_lock</> works the same as
    <function>pg_try_advisory_lock</>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
   </para>
-->
<para>
<function>pg_try_advisory_xact_lock</>类似于<function>pg_try_advisory_lock</>，
不同之处在于锁，如果得到，是自动在当前事务的结束释放的，而且不能被显式的释放。
</para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
   <!--
<para>
    <function>pg_try_advisory_xact_lock_shared</> works the same as
    <function>pg_try_advisory_lock_shared</>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
   </para>
-->
<para>
<function>pg_try_advisory_xact_lock_shared</>类似于<function>pg_try_advisory_lock_shared</>，
不同之处在于锁，如果得到，是自动在当前事务的结束释放的，而且不能被显式的释放。
</para>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
   <!-- 
   <title>Trigger Functions</title> 
   -->
   <title>触发器函数</title>

   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>

   <!--
<para>
      Currently <productname>PostgreSQL</> provides one built in trigger
      function, <function>suppress_redundant_updates_trigger</>,
      which will prevent any update
      that does not actually change the data in the row from taking place, in
      contrast to the normal behavior which always performs the update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
    </para>
-->
<para>
当前<productname>PostgreSQL</>提供一个内建的触发器函数，<function>suppress_redundant_updates_trigger</>，
其将阻止任何不会实际更改行中的数据发生，相反不管数据是否已经改变始终执行的更新这种不正常的行为。
（这是正常的行为，使得更新运行速度更快，因为不需要检查，并在某些情况下也是有用的。） 
</para>

    <!--
<para>
      Ideally, you should normally avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by an update are actually changed,
      use of this trigger will actually make the update run slower.
    </para>
-->
<para>
理想的情况下，你通常应该避免运行实际上并没有改变记录中的数据的更新。
冗余更新会花费大量不必要的时间，尤其是如果有大量索引要改变，
并且最终将不得不清空死行中的空间。然而，在客户端代码检测这种情况并不总是容易的或甚至可能的，
而写表达式以检测到它们容易产生错误。另一种方法是使用<function>suppress_redundant_updates_trigger</>，
它可以跳过不改变数据的更新。不过你应该小心使用这个命令。触发器为每条记录花费小但有意义的时间，
所以如果更新实际改变会影响大多数记录，那么此触发器的使用将实际上使更新运行得更慢。 
</para>

    
<para>
<!--
      The <function>suppress_redundant_updates_trigger</> function can be
      added to a table like this:
-->
<function>suppress_redundant_updates_trigger</>函数可以添加到一个表：
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
</programlisting>
      <!-- 
  In most cases, you would want to fire this trigger last for each row.
      Bearing in mind that triggers fire in name order, you would then
      choose a trigger name that comes after the name of any other trigger
      you might have on the table. 
  -->
在大多数情况下，你可能想要在每行的后面触发这个触发器。记住触发器是以名字的顺序触发的，
你应该在表中你有的任何其他触发器后面选择一个触发器名字。
    </para>

    <!--
<para>
       For more information about creating triggers, see
        <xref linkend="SQL-CREATETRIGGER">.
    </para>
-->
<para>
更多有关创建触发器的信息请参阅<xref linkend="SQL-CREATETRIGGER">。
</para>
  </sect1>

  <sect1 id="functions-event-triggers">
   <!-- 
   <title>Event Trigger Functions</title> 
   -->
   <title>事件触发函数</title>

   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>

   <!--
<para>
    Currently <productname>PostgreSQL</> provides one built-in event trigger
    helper function, <function>pg_event_trigger_dropped_objects</>.
   </para>
-->
<para>
当前<productname>PostgreSQL</>提供一个内建的事件触发帮助函数 <function>pg_event_trigger_dropped_objects</>。
</para>

   
<para>
<!--
    <function>pg_event_trigger_dropped_objects</> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</> event it is called.
    If called in any other context,
    <function>pg_event_trigger_dropped_objects</> raises an error.
    <function>pg_event_trigger_dropped_objects</> returns the following columns:
-->
<function>pg_event_trigger_dropped_objects</>返回一个在<literal>sql_drop</>
事件中调用的命令删除的所有对象的列表。如果在任何其他上下文中调用，
<function>pg_event_trigger_dropped_objects</>将抛出一个错误。
<function>pg_event_trigger_dropped_objects</>返回下列的字段：
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry> 
-->
<entry>名字</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
        <!-- 
<entry>OID of catalog the object belonged in</entry> 
-->
<entry>对象所在的目录的OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
        <!-- 
<entry>OID the object had within the catalog</entry> 
-->
<entry>目录中对象的OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>int32</type></entry>
        <!-- 
<entry>Object sub-id (e.g. attribute number for columns)</entry> 
-->
<entry>对象的sub-id(例如，字段的属性个数)</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>Type of the object</entry> 
-->
<entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</>.
         No quoting is applied.
        </entry> 
-->
<entry>
        如果有，为对象所在模式的名字；否则为<literal>NULL</>。不用双引号。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</>.
         No quoting is applied, and name is never schema-qualified.
        </entry> 
-->
<entry>
        如果模式和名字的组合可以用来唯一的标识对象，那么就是对象的名字；否则为<literal>NULL</>。
不用双引号，并且名字是从不模式限定的。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <!-- 
<entry>
         Text rendering of the object identity, schema-qualified. Each and every
         identifier present in the identity is quoted if necessary.
        </entry> 
-->
<entry>
         对象身份的文本表现，模式限定的。每个标识符在身份中出现时要在必要时引用。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   
<para>
<!--
    The <function>pg_event_trigger_dropped_objects</> function can be used
    in an event trigger like this:
-->
<function>pg_event_trigger_dropped_objects</> 函数可以在一个事务触发器中使用：
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE PROCEDURE test_event_trigger_for_drops();
</programlisting>
    </para>

     <!--
<para>
       For more information about event triggers,
       see <xref linkend="event-triggers">.
    </para>
-->
<para>
关于事务触发器的更多信息请参阅<xref linkend="event-triggers">。
</para>
  </sect1>

</chapter>
