<!-- doc/src/sgml/pgbench.sgml -->

<refentry id="pgbench">
 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <!--
  <refmiscinfo>Application</refmiscinfo>
  -->
  <refmiscinfo>应用</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <!--
  <refpurpose>run a benchmark test on <productname>PostgreSQL</productname></refpurpose>
  -->
  <refpurpose>在<productname>PostgreSQL</productname>上运行一个基准测试</refpurpose>
 </refnamediv>

 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>
 <!--
<para>
  <application>pgbench</application> is a simple program for running benchmark
  tests on <productname>PostgreSQL</>.  It runs the same sequence of SQL
  commands over and over, possibly in multiple concurrent database sessions,
  and then calculates the average transaction rate (transactions per second).
  By default, <application>pgbench</application> tests a scenario that is
  loosely based on TPC-B, involving five <command>SELECT</>,
  <command>UPDATE</>, and <command>INSERT</> commands per transaction.
  However, it is easy to test other cases by writing your own transaction
  script files.
 </para>
-->
<para>
<application>pgbench</application>是在<productname>PostgreSQL</>上运行基准测试的简单程序。
它一遍一遍的运行SQL命令的相同序列，可能是在多个并行的数据库会话上，
然后计算平均事务率（每秒钟事务数）。默认的，<application>pgbench</application>
测试基于TPC-B的宽松的情节，每个事务包括5个<command>SELECT</>、<command>UPDATE</>
和<command>INSERT</>命令。不过，通过写你自己的事务脚本文件，可以很容易的测试其他情况。
</para>

 
<para>
  <!--
  Typical output from pgbench looks like:
  -->
  通常来自pgbench的输出看起来像：

<screen>
transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>
<!--
  The first six lines report some of the most important parameter
  settings.  The next line reports the number of transactions completed
  and intended (the latter being just the product of number of clients
  and number of transactions per client); these will be equal unless the run
  failed before completion.  (In <option>-T</> mode, only the actual
  number of transactions is printed.)
  The last two lines report the number of transactions per second,
  figured with and without counting the time to start database sessions.
-->
前六行报告了一些比较重要的参数设置。下一行报告了事务完成/打算的数量
（后者正好是客户端数量和每客户端的事务数量的乘积）；
它们将是相等的，除非运行在完成之前失败。（在<option>-T</>模式，
只打印事务的实际数量。）最后两行报告了每秒的事务数量，
计算和不计算启动数据库会话的时间。
 </para>

  
<para>
<!-- 
   The default TPC-B-like transaction test requires specific tables to be
   set up beforehand.  <application>pgbench</> should be invoked with
   the <option>-i</> (initialize) option to create and populate these
   tables.  (When you are testing a custom script, you don't need this
   step, but will instead need to do whatever setup your test needs.)
   Initialization looks like: 
-->
缺省TPC-B风格的事务测试需要事先设置好特定的表。<application>pgbench</>
应该使用<option>-i</>（初始化）选项调用，以创建和填充这些表。
（当你在测试一个自定义的脚本时，不需要这个步骤，但是需要做你的测试需要的步骤。）
初始化看起来像这样：

<programlisting>
pgbench -i <optional> <replaceable>other-options</> </optional> <replaceable>dbname</>
</programlisting>

<!--
   where <replaceable>dbname</> is the name of the already-created
   database to test in.  (You may also need <option>-h</>,
   <option>-p</>, and/or <option>-U</> options to specify how to
   connect to the database server.)
-->
这里的<replaceable>dbname</>是早已创建的要测试的数据库的名字。
（可能也需要<option>-h</>、<option>-p</>和/或<option>-U</>
选项来指定如何连接到数据库服务器。）
  </para>

  <caution>
   <!--
<para>
    <literal>pgbench -i</> creates four tables <structname>pgbench_accounts</>,
    <structname>pgbench_branches</>, <structname>pgbench_history</>, and
    <structname>pgbench_tellers</>,
    destroying any existing tables of these names.
    Be very careful to use another database if you have tables having these
    names!
   </para>
-->
<para>
<literal>pgbench -i</>创建四个表<structname>pgbench_accounts</>、
<structname>pgbench_branches</>、<structname>pgbench_history</>
和<structname>pgbench_tellers</>，销毁任何已存在的同名的表。
如果你有这些名字的表，要非常小心的使用另外一个数据库。
</para>
  </caution>

  
<para>
<!-- 
   At the default <quote>scale factor</> of 1, the tables initially
   contain this many rows: 
-->
缺省<quote>比例因子</>为1，表最初包含这些行：
<screen>
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
<!--
   You can (and, for most purposes, probably should) increase the number
   of rows by using the <option>-s</> (scale factor) option.  The
   <option>-F</> (fillfactor) option might also be used at this point.
-->
你可以（对于大多数目的，可能应该）使用<option>-s</>（比例因子）选项增加行数。
<option>-F</>（填充因子）选项也可以用于这点。
  </para>

<para>
<!-- 
   Once you have done the necessary setup, you can run your benchmark
   with a command that doesn't include <option>-i</>, that is
-->
一旦你完成了必要的步骤，你可以用一个不包含<option>-i</>
的命令运行你的benchmark，也就是
<programlisting>
pgbench <optional> <replaceable>options</> </optional> <replaceable>dbname</>
</programlisting>

<!-- 
   In nearly all cases, you'll need some options to make a useful test.
   The most important options are <option>-c</> (number of clients),
   <option>-t</> (number of transactions), <option>-T</> (time limit),
   and <option>-f</> (specify a custom script file).
   See below for a full list. 
-->
在几乎所有情况下，你都将需要一些选项来做一个有用的测试。
最重要的选项是<option>-c</>（客户端的数量）、<option>-t</>（事务的数量）、
<option>-T</>（时间限制）和<option>-f</>（声明一个自定义的脚本文件）。
见下文的完整列表。
  </para>
 </refsect1>

 <refsect1>
  <!--
  <title>Options</title>
  -->
  <title>选项</title>

  <!--
<para>
   The following is divided into three subsections: Different options are used
   during database initialization and while running benchmarks, some options
   are useful in both cases.
  </para>
-->
<para>
下面分成了三个章节：不同的选项在数据库初始化和运行benchmark时使用，
有些选项在两种情况下都使用。
</para>

 <refsect2 id="pgbench-init-options">
  <!--
  <title>Initialization Options</title>
  -->
  <title>初始化选项</title>

   
<para>
<!-- 
    <application>pgbench</application> accepts the following command-line
    initialization arguments:
-->
<application>pgbench</application>接受下列的命令行初始化参数：
    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <listitem>
<!--
       <para>
        Required to invoke initialization mode.
       </para>
-->
<para>
要求调用初始化模式。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</></term>
      <listitem>
       <!--
<para>
        Create the <structname>pgbench_accounts</>,
        <structname>pgbench_tellers</> and
        <structname>pgbench_branches</> tables with the given fillfactor.
        Default is 100.
       </para>
-->
<para>
用给定的填充因子创建<structname>pgbench_accounts</>、<structname>pgbench_tellers</>
和<structname>pgbench_branches</>表。缺省是100。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <listitem>
       <!--
<para>
        Perform no vacuuming after initialization.
       </para>
-->
<para>
在初始化之后不执行清理。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <listitem>
       <!--
<para>
        Switch logging to quiet mode, producing only one progress message per 5
        seconds. The default logging prints one message each 100000 rows, which
        often outputs many lines per second (especially on good hardware).
       </para>
-->
<para>
日志切换到安静模式，每5秒钟只产生一条进度信息。缺省的日志输出是每100000行一条信息，
通常每秒输出多行（特别是在好的硬件上）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <listitem>
       <!--
<para>
        Multiply the number of rows generated by the scale factor.
        For example, <literal>-s 100</> will create 10,000,000 rows
        in the <structname>pgbench_accounts</> table. Default is 1.
        When the scale is 20,000 or larger, the columns used to
        hold account identifiers (<structfield>aid</structfield> columns)
        will switch to using larger integers (<type>bigint</type>),
        in order to be big enough to hold the range of account
        identifiers.
       </para>
-->
<para>
乘以比例因子生成的行数。例如，<literal>-s 100</>将在
<structname>pgbench_accounts</>表中创建10,000,000行。缺省是1。
当比例是20,000或更大时，用于保存计数标识符的字段（<structfield>aid</structfield>字段）
将切换到使用更大的整数(<type>bigint</type>)，以足够保存计数标识符的范围。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <!--
<para>
        Create foreign key constraints between the standard tables.
       </para>
-->
<para>
在标准表之间创建外键约束。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable></option></term>
      <listitem>
       <!--
<para>
        Create indexes in the specified tablespace, rather than the default
        tablespace.
       </para>
-->
<para>
在指定的表空间中创建索引，而不是在缺省的表空间中。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable></option></term>
      <listitem>
       <!--
<para>
        Create tables in the specified tablespace, rather than the default
        tablespace.
       </para>
-->
<para>
在指定的表空间中创建表，而不是在缺省的表空间中。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <!--
<para>
        Create all tables as unlogged tables, rather than permanent tables.
       </para>
-->
<para>
创建所有的表为unlogged表，而不是永久表。
</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
  <!--
  <title>Benchmarking Options</title>
  -->
  <title>基准选项</title>

   
<para>
<!-- 
    <application>pgbench</application> accepts the following command-line
    benchmarking arguments: 
-->
<application>pgbench</application>接受下列的命令行基准参数：

    <variablelist>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</></term>
      <listitem>
<!--
       <para>
        Number of clients simulated, that is, number of concurrent database
        sessions.  Default is 1.
       </para>
-->
<para>
模拟客户端的数量，也就是并发数据库会话的数量。缺省是1。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <listitem>
       <!--
<para>
        Establish a new connection for each transaction, rather than
        doing it just once per client session.
        This is useful to measure the connection overhead.
       </para>
-->
<para>
为每个事务建立一个新的连接，而不是每客户端会话只执行一次。
这对于测量连接开销是有用的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <listitem>
       <!--
<para>
        Print debugging output.
       </para>
-->
<para>
打印调试输出。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</><literal>=</><replaceable>value</></term>
      <listitem>
       <!--
<para>
        Define a variable for use by a custom script (see below).
        Multiple <option>-D</> options are allowed.
       </para>
-->
<para>
定义一个自定义脚本使用的变量（见下文）。允许使用多个<option>-D</>选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>filename</></term>
      <listitem>
       <!--
<para>
        Read transaction script from <replaceable>filename</>.
        See below for details.
        <option>-N</option>, <option>-S</option>, and <option>-f</option>
        are mutually exclusive.
       </para>
-->
<para>
从<replaceable>filename</>中读取事务脚本。见下文获取细节。
<option>-N</option>、<option>-S</option>、和<option>-f</option>是互相排斥的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</></term>
      <listitem>
       <!--
<para>
        Number of worker threads within <application>pgbench</application>.
        Using more than one thread can be helpful on multi-CPU machines.
        The number of clients must be a multiple of the number of threads,
        since each thread is given the same number of client sessions to manage.
        Default is 1.
       </para>
-->
<para>
<application>pgbench</application>中工作线程的数量。在多CPU的机器上使用多个线程会很有帮助。
客户端的数量必须是线程数量的倍数，因为每个线程都有相同数量的客户端会话管理。
缺省是1。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <listitem>
       <!--
<para>
        Write the time taken by each transaction to a log file.
        See below for details.
       </para>
-->
<para>
记录每个事务写入日志文件的时间。见下文获取细节。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</></term>
      <listitem>
       
<para>
        <!--
Protocol to use for submitting queries to the server:
-->
提交查询到服务器使用的协议：
          <itemizedlist>
           <listitem>
<!--
            <para><literal>simple</>: use simple query protocol.</para>
-->
<para>
<literal>simple</>：使用简单的查询协议。
</para>
           </listitem>
           <listitem>
            <!--
<para><literal>extended</>: use extended query protocol.</para>
-->
<para>
<literal>extended</>：使用扩展的查询协议。
</para>
           </listitem>
           <listitem>
            <!--
<para><literal>prepared</>: use extended query protocol with prepared statements.</para>
-->
<para>
<literal>prepared</>：使用带有预备语句的扩展查询协议。
</para>
           </listitem>
          </itemizedlist>
<!-- 
        The default is simple query protocol.  (See <xref linkend="protocol">
        for more information.) 
-->
缺省是简单的查询协议。（参阅<xref linkend="protocol">获取更多信息。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <listitem>
       <!--
<para>
        Perform no vacuuming before running the test.
        This option is <emphasis>necessary</>
        if you are running a custom test scenario that does not include
        the standard tables <structname>pgbench_accounts</>,
        <structname>pgbench_branches</>, <structname>pgbench_history</>, and
        <structname>pgbench_tellers</>.
       </para>
-->
<para>
运行测试时不执行清理。如果你正在运行一个不包含标准表<structname>pgbench_accounts</>、
<structname>pgbench_branches</>、<structname>pgbench_history</>、和
<structname>pgbench_tellers</>的自定义测试，那么该选项是<emphasis>必需的</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <listitem>
       <!--
<para>
        Do not update <structname>pgbench_tellers</> and
        <structname>pgbench_branches</>.
        This will avoid update contention on these tables, but
        it makes the test case even less like TPC-B.
       </para>
-->
<para>
不要更新<structname>pgbench_tellers</>和<structname>pgbench_branches</>。
这将避免争用这些表，但是它使得测试用例更不像TPC-B。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <listitem>
       <!--
<para>
        Report the average per-statement latency (execution time from the
        perspective of the client) of each command after the benchmark
        finishes.  See below for details.
       </para>
-->
<para>
在benchmark完成后报告每个命令的平均每语句延迟（从客户的角度看的执行时间）。
见下文获取细节。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <listitem>
       <!--
<para>
        Report the specified scale factor in <application>pgbench</>'s
        output.  With the built-in tests, this is not necessary; the
        correct scale factor will be detected by counting the number of
        rows in the <structname>pgbench_branches</> table.  However, when testing
        custom benchmarks (<option>-f</> option), the scale factor
        will be reported as 1 unless this option is used.
       </para>
-->
<para>
在<application>pgbench</>的输出中报告指定的比例因子。在内建的测试中，这不是必需的；
正确的比例因子将通过计数<structname>pgbench_branches</>表中的行数检测到。
不过，在测试自定义benchmark(<option>-f</>选项)时，比例因子将报告为1，除非使用了该选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <listitem>
       <!--
<para>
        Perform select-only transactions instead of TPC-B-like test.
       </para>
-->
<para>
执行只有select的事务，替代类似TPC-B的测试。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</></term>
      <listitem>
       <!--
<para>
        Number of transactions each client runs.  Default is 10.
       </para>
-->
<para>
每个客户端运行的事务数量。缺省是10。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</></term>
      <listitem>
       <!--
<para>
        Run the test for this many seconds, rather than a fixed number of
        transactions per client. <option>-t</option> and
        <option>-T</option> are mutually exclusive.
       </para>
-->
<para>
运行测试这么多秒，而不是每客户端固定数量的事务。<option>-t</option>
和<option>-T</option>是互相排斥的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <listitem>
       <!--
<para>
        Vacuum all four standard tables before running the test.
        With neither <option>-n</> nor <option>-v</>, pgbench will vacuum the
        <structname>pgbench_tellers</> and <structname>pgbench_branches</>
        tables, and will truncate <structname>pgbench_history</>.
       </para>
-->
<para>
在运行测试之前清理四个标准表。既不用<option>-n</>也不用<option>-v</>，
pgbench将清理<structname>pgbench_tellers</>和<structname>pgbench_branches</>表，
截断<structname>pgbench_history</>表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=<replaceable>seconds</></option></term>
      <listitem>
       <!--
<para>
        Length of aggregation interval (in seconds). May be used only together
        with <application>-l</application> - with this option, the log contains
        per-interval summary (number of transactions, min/max latency and two
        additional fields useful for variance estimation).
       </para>
-->
<para>
汇总时间间隔的长度（以秒计）。可能只与<application>-l</application>选项一起使用，
日志包含每间隔的总结（事务的数量、最小/最大延迟和可用于方差估计的两个额外字段）。
</para>
       <!--
<para>
        This option is not currently supported on Windows.
       </para>
-->
<para>
目前在Windows上不支持这个选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=<replaceable>rate</></option></term>
      <listitem>
       <!--
<para>
        Sampling rate, used when writing data into the log, to reduce the
        amount of log generated. If this option is given, only the specified
        fraction of transactions are logged. 1.0 means all transactions will
        be logged, 0.05 means only 5% of the transactions will be logged.
       </para>
-->
<para>
采样率，在写入数据到日志时使用，以减少生成日志的数量。如果给出了这个选项，
则只记录指定比例的事务。1.0意味着记录所有事务，0.05意味着只记录了5%的事务。
</para>
       <!--
<para>
        Remember to take the sampling rate into account when processing the
        log file. For example, when computing tps values, you need to multiply
        the numbers accordingly (e.g. with 0.01 sample rate, you'll only get
        1/100 of the actual tps).
       </para>
-->
<para>
在处理日志文件时记得计算上采样率。例如，计算tps值时，需要乘以相应的数字
（比如，0.01的采样率，将只得到1/100的实际tps）。
</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
  <!--
  <title>Common Options</title>
  -->
  <title>公共选项</title>
   
<para>
<!-- 
    <application>pgbench</application> accepts the following command-line
    common arguments:
-->
<application>pgbench</application>接受下列的命令行公共参数：
    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</></term>
      <listitem>
<!--
       <para>
        The database server's host name
       </para>
-->
<para>
数据库服务器的主机名
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</></term>
      <listitem>
       <!--
<para>
        The database server's port number
       </para>
-->
<para>
数据库服务器的端口号
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</></term>
      <listitem>
       <!--
<para>
        The user name to connect as
       </para>
-->
<para>
要连接的用户名
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</></term>
      <term><option>--version</></term>
      <listitem>
       <!--
<para>
        Print the <application>pgbench</application> version and exit.
       </para>
-->
<para>
打印<application>pgbench</application>的版本并退出。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</></term>
      <term><option>--help</></term>
      <listitem>
       <!--
<para>
        Show help about <application>pgbench</application> command line
        arguments, and exit.
       </para>
-->
<para>
显示关于<application>pgbench</application>命令行参数的帮助并退出。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

 <refsect2>
  <!--
  <title>What is the <quote>Transaction</> Actually Performed in pgbench?</title>
  -->
  <title>什么是在pgbench上实际执行的<quote>事务</>？</title>

  <!--
<para>
   The default transaction script issues seven commands per transaction:
  </para>
-->
<para>
缺省的事务脚本每事务发出7个命令：
</para>

  <orderedlist>
   <listitem>
<para><literal>BEGIN;</literal></para>
</listitem>
   <listitem>
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para>
</listitem>
   <listitem>
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para>
</listitem>
   <listitem>
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para>
</listitem>
   <listitem>
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para>
</listitem>
   <listitem>
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para>
</listitem>
   <listitem>
<para><literal>END;</literal></para>
</listitem>
  </orderedlist>

  <!--
<para>
   If you specify <option>-N</>, steps 4 and 5 aren't included in the
   transaction.  If you specify <option>-S</>, only the <command>SELECT</> is
   issued.
  </para>
-->
<para>
如果你声明了<option>-N</>，那么不包含步骤4和5。如果你声明了<option>-S</>，
那么只发出<command>SELECT</>。
</para>
 </refsect2>

 <refsect2>
  <!--
  <title>Custom Scripts</title>
  -->
  <title>自定义脚本</title>

  <!--
<para>
   <application>pgbench</application> has support for running custom
   benchmark scenarios by replacing the default transaction script
   (described above) with a transaction script read from a file
   (<option>-f</option> option).  In this case a <quote>transaction</>
   counts as one execution of a script file.  You can even specify
   multiple scripts (multiple <option>-f</option> options), in which
   case a random one of the scripts is chosen each time a client session
   starts a new transaction.
  </para>
-->
<para>
<application>pgbench</application>支持运行自定义的benchmark脚本，
通过使用从文件中读取的事务脚本(<option>-f</option>选项)
替换缺省的事务脚本（上面描述了）。在这种情况下，一个<quote>事务</>
被认为是一个脚本文件的一次执行。你可以声明多个脚本（多个<option>-f</option>选项），
在这种情况下，每次客户端会话启动一个新的事务时随机选择一个脚本。
</para>

  <!--
<para>
   The format of a script file is one SQL command per line; multiline
   SQL commands are not supported.  Empty lines and lines beginning with
   <literal>-&#045;</> are ignored.  Script file lines can also be
   <quote>meta commands</>, which are interpreted by <application>pgbench</>
   itself, as described below.
  </para>
-->
<para>
脚本文件的格式是每行一个SQL命令；不支持一行多个SQL命令。
忽略空行和以<literal>--</>开始的行。脚本文件行也可以是<quote>元命令</>，
被<application>pgbench</>本身解读，就像下面描述的那样。
</para>

  <!--
<para>
   There is a simple variable-substitution facility for script files.
   Variables can be set by the command-line <option>-D</> option,
   explained above, or by the meta commands explained below.
   In addition to any variables preset by <option>-D</> command-line options,
   the variable <literal>scale</> is preset to the current scale factor.
   Once set, a variable's
   value can be inserted into a SQL command by writing
   <literal>:</><replaceable>variablename</>.  When running more than
   one client session, each session has its own set of variables.
  </para>
-->
<para>
脚本文件有一个简单的变量替换设施。变量可以通过命令行<option>-D</>选项设置，
在上文中解释了，或者通过上文解释的元命令设置。除了预先通过<option>-D</>
命令行选项设置的任何变量外，变量<literal>scale</>是为当前比例因子预设的。
一旦设置，变量的值可以通过书写<literal>:</><replaceable>variablename</>
插入到SQL命令中。当运行多于一个客户端会话时，每个会话都有它自己的变量设置。
</para>

  <!--
<para>
   Script file meta commands begin with a backslash (<literal>\</>).
   Arguments to a meta command are separated by white space.
   These meta commands are supported:
  </para>
-->
<para>
脚本文件元命令以反斜杠(<literal>\</>)开始。元命令的参数通过空格分隔开。
支持这些元命令：
</para>

  <variablelist>
   <varlistentry>
    <term>
     <literal>\set <replaceable>varname</> <replaceable>operand1</> [ <replaceable>operator</> <replaceable>operand2</> ]</literal>
    </term>

    <listitem>
     <!--
<para>
      Sets variable <replaceable>varname</> to a calculated integer value.
      Each <replaceable>operand</> is either an integer constant or a
      <literal>:</><replaceable>variablename</> reference to a variable
      having an integer value.  The <replaceable>operator</> can be
      <literal>+</>, <literal>-</>, <literal>*</>, or <literal>/</>.
     </para>
-->
<para>
设置变量<replaceable>varname</>为一个经过计算的整数值。
每个<replaceable>operand</>是一个整数常量或者一个<literal>:</><replaceable>variablename</>
到一个有整数值的变量的引用。<replaceable>operator</>可以是
<literal>+</>, <literal>-</>, <literal>*</>, 或 <literal>/</>。
</para>

     <!--
<para>
      Example:
<programlisting>
\set ntellers 10 * :scale
</programlisting></para>
-->
<para>
例子：
<programlisting>
\set ntellers 10 * :scale
</programlisting>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setrandom <replaceable>varname</> <replaceable>min</> <replaceable>max</></literal>
    </term>

    <listitem>
     <!--
<para>
      Sets variable <replaceable>varname</> to a random integer value
      between the limits <replaceable>min</> and <replaceable>max</> inclusive.
      Each limit can be either an integer constant or a
      <literal>:</><replaceable>variablename</> reference to a variable
      having an integer value.
     </para>
-->
<para>
设置变量<replaceable>varname</>为范围<replaceable>min</>到<replaceable>max</>
（包含）之间的随机整数值。每个限制可以是一个整数常量或者一个
<literal>:</><replaceable>variablename</>到一个有整数值的变量的引用。
</para>

     <!--
<para>
      Example:
<programlisting>
\setrandom aid 1 :naccounts
</programlisting></para>
-->
<para>
例子：
<programlisting>
\setrandom aid 1 :naccounts
</programlisting>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep <replaceable>number</> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <!--
<para>
      Causes script execution to sleep for the specified duration in
      microseconds (<literal>us</>), milliseconds (<literal>ms</>) or seconds
      (<literal>s</>).  If the unit is omitted then seconds are the default.
      <replaceable>number</> can be either an integer constant or a
      <literal>:</><replaceable>variablename</> reference to a variable
      having an integer value.
     </para>
-->
<para>
导致脚本执行睡眠指定的持续时间，单位是微妙(<literal>us</>)、毫秒(<literal>ms</>)
或秒(<literal>s</>)。如果省略了单位，则缺省是秒。<replaceable>number</>
可以是一个整数常量或者一个<literal>:</><replaceable>variablename</>
到一个有整数值的变量的引用。
</para>

     <!--
<para>
      Example:
<programlisting>
\sleep 10 ms
</programlisting></para>
-->
<para>
例子：
<programlisting>
\sleep 10 ms
</programlisting>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>varname</> <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>

    <listitem>
     <!--
<para>
      Sets variable <replaceable>varname</> to the result of the shell command
      <replaceable>command</>. The command must return an integer value
      through its standard output.
     </para>
-->
<para>
设置变量<replaceable>varname</>为shell命令<replaceable>command</>的结果。
该命令必须通过它的标准输出返回一个整数值。
</para>

     <!--
<para><replaceable>argument</> can be either a text constant or a
      <literal>:</><replaceable>variablename</> reference to a variable of
      any types. If you want to use <replaceable>argument</> starting with
      colons, you need to add an additional colon at the beginning of
      <replaceable>argument</>.
     </para>
-->
<para>
<replaceable>argument</>可以是一个文本常量或者一个<literal>:</><replaceable>variablename</>
到一个任何类型的变量的引用。如果你想要使用以冒号开始的<replaceable>argument</>，
你需要在<replaceable>argument</>的开始添加一个额外的冒号。
</para>

     <!--
<para>
      Example:
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
-->
<para>
例子：
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>

    <listitem>
     <!--
<para>
      Same as <literal>\setshell</literal>, but the result is ignored.
     </para>
-->
<para>
和<literal>\setshell</literal>相同，但是忽略结果。
</para>

     <!--
<para>
      Example:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
-->
<para>
例子：
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting>
</para>
    </listitem>
   </varlistentry>
  </variablelist>

<para>
<!-- 
   As an example, the full definition of the built-in TPC-B-like
   transaction is:
-->
作为一个示例，内建的类TPC-B的事务的全部定义是：
<programlisting>
\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>
<!--
   This script allows each iteration of the transaction to reference
   different, randomly-chosen rows.  (This example also shows why it's
   important for each client session to have its own variables &mdash;
   otherwise they'd not be independently touching different rows.)
-->
这个脚本允许事务的每次迭代的引用不同，随机选取行。
这个示例也显示了为什么每个客户端会话有它自己的变量是重要的 &mdash;
否则它们不能独立的访问不同的行。
  </para>
 </refsect2>

 <refsect2>
  <!--
  <title>Per-Transaction Logging</title>
  -->
  <title>每事务的日志</title>

  <!--
<para>
   With the <option>-l</> option but without the <option>-&#045;aggregate-interval</option>,
   <application>pgbench</> writes the time taken by each transaction
   to a log file.  The log file will be named
   <filename>pgbench_log.<replaceable>nnn</></filename>, where
   <replaceable>nnn</> is the PID of the pgbench process.
   If the <option>-j</> option is 2 or higher, creating multiple worker
   threads, each will have its own log file. The first worker will use the
   same name for its log file as in the standard single worker case.
   The additional log files for the other workers will be named
   <filename>pgbench_log.<replaceable>nnn</>.<replaceable>mmm</></filename>,
   where <replaceable>mmm</> is a sequential number for each worker starting
   with 1.
  </para>
-->
<para>
带有<option>-l</>选项，但是不带有<option>--aggregate-interval</option>，
<application>pgbench</>将每个事务花费的时间写入到日志文件中。
日志文件将命名为<filename>pgbench_log.<replaceable>nnn</></filename>，
这里的<replaceable>nnn</>是pgbench进程的PID。如果<option>-j</>
选项是2或更高，则创建多个工作线程，每个都将拥有它自己的日志文件。
第一个工作线程的日志文件名字和标准的单个工作线程情况相同。
其他工作线程的日志文件将命名为<filename>pgbench_log.<replaceable>nnn</>.<replaceable>mmm</></filename>，
这里的<replaceable>mmm</>是每个工作线程的序列号，起始值为1。
</para>

  <!--
<para>
   The format of the log is:

<synopsis>
<replaceable>client_id</> <replaceable>transaction_no</> <replaceable>time</> <replaceable>file_no</> <replaceable>time_epoch</> <replaceable>time_us</>
</synopsis>

   where <replaceable>time</> is the total elapsed transaction time in microseconds,
   <replaceable>file_no</> identifies which script file was used
   (useful when multiple scripts were specified with <option>-f</>),
   and <replaceable>time_epoch</>/<replaceable>time_us</> are a
   UNIX epoch format timestamp and an offset
   in microseconds (suitable for creating a ISO 8601
   timestamp with fractional seconds) showing when
   the transaction completed.
  </para>
-->
<para>
日志格式是：
<synopsis>
<replaceable>client_id</> <replaceable>transaction_no</> <replaceable>time</> <replaceable>file_no</> <replaceable>time_epoch</> <replaceable>time_us</>
</synopsis>
这里的<replaceable>time</>是事务运行的总时间，以毫秒计，
<replaceable>file_no</>标识出使用哪个脚本文件（在使用<option>-f</>
声明了多个脚本时有用），<replaceable>time_epoch</>/<replaceable>time_us</>
是一个UNIX纪元格式的时间戳和以毫秒计的时间偏移（适用于创建一个以分数计的ISO 8601的时间戳），
显示事务是何时完成的。
</para>

  <!--
<para>
   Here are example outputs:
<screen>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
</screen></para>
-->
<para>
这里是示例输出：
<screen>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
</screen>
</para>

  <!--
<para>
   When running a long test on hardware that can handle a lot of transactions,
   the log files can become very large.  The <option>-&#045;sampling-rate</> option
   can be used to log only a random sample of transactions.
  </para>
-->
<para>
在可以处理大量事务的硬件上运行一个长文本时，日志文件会变得非常大。
<option>--sampling-rate</>选项可以用来只记录一个随机的事务样本。
</para>
 </refsect2>

 <refsect2>
  <!--
  <title>Aggregated Logging</title>
  -->
  <title>聚合的日志</title>
  
  <!--
<para>
   With the <option>-&#045;aggregate-interval</option> option, the logs use a bit different format:

<synopsis>
<replaceable>interval_start</> <replaceable>num_of_transactions</> <replaceable>latency_sum</> <replaceable>latency_2_sum</> <replaceable>min_latency</> <replaceable>max_latency</>
</synopsis>

   where <replaceable>interval_start</> is the start of the interval (UNIX epoch
   format timestamp), <replaceable>num_of_transactions</> is the number of transactions
   within the interval, <replaceable>latency_sum</replaceable> is a sum of latencies
   (so you can compute average latency easily). The following two fields are useful
   for variance estimation - <replaceable>latency_sum</> is a sum of latencies and
   <replaceable>latency_2_sum</> is a sum of 2nd powers of latencies. The last two
   fields are <replaceable>min_latency</> - a minimum latency within the interval, and
   <replaceable>max_latency</> - maximum latency within the interval. A transaction is
   counted into the interval when it was committed.
  </para>
-->
<para>
带有<option>--aggregate-interval</option>选项，日志会使用一个稍微不同的格式：
<synopsis>
<replaceable>interval_start</> <replaceable>num_of_transactions</> <replaceable>latency_sum</> <replaceable>latency_2_sum</> <replaceable>min_latency</> <replaceable>max_latency</>
</synopsis>
这里的<replaceable>interval_start</>是间隔的开始（UNIX纪元格式的时间戳），
<replaceable>num_of_transactions</>是间隔内事务的数量，<replaceable>latency_sum</replaceable>
是延迟的总和（这样你可以非常容易的计算平均延迟）。下列的两个字段对于方差估计是有帮助的-
<replaceable>latency_sum</>是延迟的总和，<replaceable>latency_2_sum</>是延迟的二次方的总和。
最后两个字段是<replaceable>min_latency</>-间隔的最小延迟，<replaceable>max_latency</>-
间隔的最大延迟。当事务已经提交了时，计入间隔。
</para>

<para>
   <!--
   Here is example outputs:
   -->
   这里是一个示例输出：
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

  <!--
<para>
   Notice that while the plain (unaggregated) log file contains index
   of the custom script files, the aggregated log does not. Therefore if
   you need per script data, you need to aggregate the data on your own.
  </para>
-->
<para>
请注意，当纯（未聚合）日志文件包含自定义脚本文件的索引时，聚合日志不包含。
因此，如果你需要每脚本的数据，你需要自己聚合数据。
</para>

 </refsect2>

 <refsect2>
  <!--
  <title>Per-Statement Latencies</title>
  -->
  <title>每个语句的延迟</title>

  <!--
<para>
   With the <option>-r</> option, <application>pgbench</> collects
   the elapsed transaction time of each statement executed by every
   client.  It then reports an average of those values, referred to
   as the latency for each statement, after the benchmark has finished.
  </para>
-->
<para>
对于<option>-r</>选项，<application>pgbench</>收集每个客户端执行的每个语句的事务时间。
然后报告一个平均值，在benchmark完成之后，当做每个语句延迟的参考。
</para>

<para>
   <!--
   For the default script, the output will look similar to this:
   -->
   对于缺省的脚本，输出看起来像这样：
<screen>
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.004386        \set nbranches 1 * :scale
        0.001343        \set ntellers 10 * :scale
        0.001212        \set naccounts 100000 * :scale
        0.001310        \setrandom aid 1 :naccounts
        0.001073        \setrandom bid 1 :nbranches
        0.001005        \setrandom tid 1 :ntellers
        0.001078        \setrandom delta -5000 5000
        0.326152        BEGIN;
        0.603376        UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454643        SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528491        UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335435        UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371851        INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212976        END;
</screen>
  </para>

  <!--
<para>
   If multiple script files are specified, the averages are reported
   separately for each script file.
  </para>
-->
<para>
如果声明了多个脚本文件，那么为每个脚本文件单独报告平均值。
</para>

  <!--
<para>
   Note that collecting the additional timing information needed for
   per-statement latency computation adds some overhead.  This will slow
   average execution speed and lower the computed TPS.  The amount
   of slowdown varies significantly depending on platform and hardware.
   Comparing average TPS values with and without latency reporting enabled
   is a good way to measure if the timing overhead is significant.
  </para>
-->
<para>
请注意，收集额外的时间信息需要每语句延迟计算加上一些开销。
这将减缓平均执行速度并降低计算的TPS。降低的值根据平台和硬件会有很大的变化。
启用和不启用延迟报告来计算TPS的平均值，是测量时间开销是否重要的一个很好的方法。
</para>
 </refsect2>

 <refsect2>
  <!--
  <title>Good Practices</title>
  -->
  <title>好的实践</title>

  <!--
<para>
   It is very easy to use <application>pgbench</> to produce completely
   meaningless numbers.  Here are some guidelines to help you get useful
   results.
  </para>
-->
<para>
使用<application>pgbench</>可以非常简单的生成完全毫无意义的数字。
这里有一些指导，帮助你获取有用的结果。
</para>

  <!--
<para>
   In the first place, <emphasis>never</> believe any test that runs
   for only a few seconds.  Use the <option>-t</> or <option>-T</> option
   to make the run last at least a few minutes, so as to average out noise.
   In some cases you could need hours to get numbers that are reproducible.
   It's a good idea to try the test run a few times, to find out if your
   numbers are reproducible or not.
  </para>
-->
<para>
首先，<emphasis>决不</>相信任何只运行几秒钟的测试。使用<option>-t</>
或<option>-T</>选项使测试最少运行几分钟，以平均噪音。
在某些情况下，你可能需要几小时才能获得可再生的数字。
尝试让测试多运行几次是一个好的想法，以找出你的数字是否再生了。
</para>

  <!--
<para>
   For the default TPC-B-like test scenario, the initialization scale factor
   (<option>-s</>) should be at least as large as the largest number of
   clients you intend to test (<option>-c</>); else you'll mostly be
   measuring update contention.  There are only <option>-s</> rows in
   the <structname>pgbench_branches</> table, and every transaction wants to
   update one of them, so <option>-c</> values in excess of <option>-s</>
   will undoubtedly result in lots of transactions blocked waiting for
   other transactions.
  </para>
-->
<para>
对于缺省的类TPC-B测试情况，初始化比例因子(<option>-s</>)
应该至少和你要测试的最大客户端数量(<option>-c</>)一样大；
否则你大多会测量到更新争用。在<structname>pgbench_branches</>表中只有<option>-s</>行，
并且每个事务都想更新它们中的一条，所以<option>-c</>值大于<option>-s</>时，
将会毫无疑问的导致大量事务锁住，等待其他事务。
</para>

  <!--
<para>
   The default test scenario is also quite sensitive to how long it's been
   since the tables were initialized: accumulation of dead rows and dead space
   in the tables changes the results.  To understand the results you must keep
   track of the total number of updates and when vacuuming happens.  If
   autovacuum is enabled it can result in unpredictable changes in measured
   performance.
  </para>
-->
<para>
缺省的测试情节也对表被初始化了多久很敏感：表中死行的积累和死区会改变结果。
要理解结果，你必须跟踪更新的总数量和何时发生了清理。如果启用了自动清理，
那么它会导致在测量的性能中有不可预知的改变。
</para>

  <!--
<para>
   A limitation of <application>pgbench</> is that it can itself become
   the bottleneck when trying to test a large number of client sessions.
   This can be alleviated by running <application>pgbench</> on a different
   machine from the database server, although low network latency will be
   essential.  It might even be useful to run several <application>pgbench</>
   instances concurrently, on several client machines, against the same
   database server.
  </para>
-->
<para>
<application>pgbench</>的一个限制是在尝试测试大量的客户端会话时，它本身会成为瓶颈。
这个可以通过在不同的机器上从数据库服务器运行<application>pgbench</>来减轻，
尽管少量的网络延迟是必然的。在几个客户端机器上，对同一个数据库服务器，
同时运行几个<application>pgbench</>实例可能也有帮助，
</para>
 </refsect2>
 </refsect1>
</refentry>
