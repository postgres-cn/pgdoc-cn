<!-- doc/src/sgml/information_schema.sgml -->

<chapter id="information-schema">
 <title>信息模式</title>

 <indexterm zone="information-schema">
  <primary>信息模式</primary>
 </indexterm>

 <para>
  信息模式由一组视图构成，它们包含定义在当前数据库中对象的信息。信息模式以 SQL 标准定义，因此能够被移植并且保持稳定 &mdash; 系统目录则不同，它们是与<productname>PostgreSQL</productname>相关的并且是为了实现的考虑而建模的。不过，信息模式视图不包含与<productname>PostgreSQL</productname>-相关特性有关的信息。要咨询那些信息你需要查询系统目录或其他<productname>PostgreSQL</productname>-相关视图。
 </para>

 <note>
  <para>
   当在数据库中查询约束信息时，一个期望返回一行的标准兼容的查询可能返回多行。这是因为 SQL 标准要求约束名在一个模式中唯一，但是<productname>PostgreSQL</productname>并不强制这种限制。<productname>PostgreSQL</productname>自动产生的约束名避免在相同的模式中重复，但是用户能够指定这种重复的名称。
  </para>

  <para>
   这个问题可能在查询信息模式视图时出现，例如<literal>check_constraint_routine_usage</>、
   <literal>check_constraints</>、<literal>domain_constraints</>和
   <literal>referential_constraints</>。一些其他视图也有相似的问题，但是它们包含了表名来帮助区分重复行，例如<literal>constraint_column_usage</>、
   <literal>constraint_table_usage</>、<literal>table_constraints</>。
  </para>
 </note>


 <sect1 id="infoschema-schema">
  <title>模式</title>

  <para>
   信息模式本身是一个名为<literal>information_schema</literal>的模式。这个模式自动存在于所有数据库中。这个模式的拥有者是集簇中的初始数据库用户，并且该用户自然地拥有这个模式上的所有特权，包括删除它的能力（但是这样节省的空间是很小的）。
  </para>

  <para>
   默认情况下，信息模式不在模式搜索路径中，因此你需要使用限定名访问其中的所有对象。因为信息模式中的某些对象的名称是可能出现在用户应用中的一般名称，如果你想把该信息模式放在路径中，你应该小心。
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>数据类型</title>

  <para>
   信息模式视图的列使用定义在信息模式中的特殊数据类型。它们被定义为普通内建类型之上的简单域。你不应在信息模式之外使用这些类型进行工作，但是如果你的应用从信息模式中进行选择，那你的应用就必须准备好面对它们。
  </para>

  <para>
   这些类型是：

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       一种非负整数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       一种字符串（没有指定最大长度）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       一种字符串。这种类型被用于 SQL 标识符，类型<type>character_data</type>被用于任何其他类型的文本数据。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       在类型<type>timestamp with time zone</type>之上的一个域。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       一种字符串域，它包含<literal>YES</literal>或<literal>NO</literal>。这被用来在信息模式中表示布尔（真/假）（信息模式是在类型<type>boolean</type>被加到 SQL 标准之前被发明的，因此这个惯例是用来使信息模式向后兼容）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   信息模式中的每一列都是这五种类型之一。
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal>是一个表，它总是包含一行和一列，其中包含了当前数据库（SQL 术语中的当前目录）的名字。
  </para>

  <table>
   <title><literal>information_schema_catalog_name</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含这个信息模式的数据库名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <para>
   视图<literal>administrable_role_authorizations</literal>标识当前用户对其有管理选项的所有角色。
  </para>

  <table>
   <title><literal>administrable_role_authorizations</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被授予这个角色的成员关系的角色名（可以是当前用户，或者在嵌套角色成员关系情况下的一个不同角色）
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>角色名</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>总是 <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   视图<literal>applicable_roles</literal>当前用户可以使用其特权的所有角色。这意味着有某种角色授权链从当前用户到讨论中的角色。当前用户本身也是一个可应用的角色。可应用的角色的集合通常被用于权限检查。
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title><literal>applicable_roles</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被授予这个角色的成员关系的角色名（可以是当前用户，或者在嵌套角色成员关系情况下的一个不同角色）
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个角色的名字</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal>表示被授予者在该角色上有管理选项，<literal>NO</literal>表示没有管理选项
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   视图<literal>attributes</literal>包含数据库中定义的组合数据类型的属性的有关信息（注意该视图并不给出有关表列的信息，表列有时候在 PostgreSQL 上下文环境中也被称为属性）。只有当前用户能够访问（由于是拥有者获得的权限或是在类型上有某些特权）的那些属性会被显示。
  </para>

  <table>
   <title><literal>attributes</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该数据类型的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该数据类型的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>数据类型名</entry>
     </row>

     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>属性名</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>属性在该数据类型内部的顺序位置（从 1 开始计算）</entry>
     </row>

     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该属性的默认表达式</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该属性是可能为空的，值为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该属性是一个内建类型，此列值为该属性的数据类型；如果该属性是某种数组，此列值为<literal>ARRAY</literal>（在这种情况下，见视图<literal>element_types</literal>）；其他情况，此列值为<literal>USER-DEFINED</literal>（在这种情况下，该类型在<literal>attribute_udt_name</literal>和相关列中标识）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符或位串类型，这里是声明的最大长度；如果没有声明最大长度，则对于所有其他数据类型为空。
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的数据库名（总是当前数据库），如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的模式名，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该属性排序规则的名称，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这列包含这个属性类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种准确数字类型，这列包含这个属性类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个属性类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个属性包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</>中不可用的特性（关于时间间隔类型属性的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型被定义的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型被定义的模式名
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型的名称
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列的数据类型描述符的一个标识符，在从属于该表的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   关于某些列的详情，参见<xref linkend="infoschema-columns">之下的一个相似结构的视图。
  </para>
 </sect1>

 <sect1 id="infoschema-character-sets">
  <title><literal>character_sets</literal></title>

  <para>
   视图<literal>character_sets</literal>标识当前数据库中可用的字符集。因为 PostgreSQL 不支持在同一个数据库中有多个字符集，这个视图只显示一个字符集，它就是数据库编码。
  </para>

  <para>
   注意下列术语在 SQL 标准中是怎样使用的：
   <variablelist>
    <varlistentry>
     <term>字元集（character repertoire）</term>
     <listitem>
      <para>
       字符的一个抽象集合，例如<literal>UNICODE</literal>、<literal>UCS</literal>或<literal>LATIN1</literal>。它不作为一个 SQL 对象显示，但是在这个视图中可见。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>字符编码形式（character encoding form）</term>
     <listitem>
      <para>
       某种字元集的一种编码。大部分较老的字元集只使用一种编码形式，并且因此它们没有独立的名字（例如<literal>LATIN1</literal>就是一种适用于<literal>LATIN1</literal>字元集的编码形式）。但是 Unicode 就有几种编码形式如<literal>UTF8</literal>、<literal>UTF16</literal>等等（并非全部被 PostgreSQL 支持）。编码形式不作为一个 SQL 对象显示，但是在这个视图中可见。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>字符集（character set）</term>
     <listitem>
      <para>
       一个标识一种字元集、一种字符编码以及一种默认排序规则的命名 SQL 对象。一个预定义的字符集通常具有和一种编码形式相同的名字，但是用户可以定义其他名字。例如，字符集<literal>UTF8</literal>通常标识字元集<literal>UCS</literal>、编码形式<literal>UTF8</literal>以及某种默认排序规则。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   你可以把 PostgreSQL 中的一种<quote>编码</quote>想成一个字符集或是一种字符编码形式。它们将具有相同的名字，并且在一个数据库中只能用其中一个。
  </para>

  <table>
   <title><literal>character_sets</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集并未被实现为模式对象，因此这一列为空。</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集并未被实现为模式对象，因此这一列为空。</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>该字符集的名字，当前实现为显示该数据库编码的名字</entry>
     </row>

     <row>
      <entry><literal>character_repertoire</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字元集，如果编码为<literal>UTF8</literal>则显示<literal>UCS</literal>，否则只显示编码名称</entry>
     </row>

     <row>
      <entry><literal>form_of_use</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字符编码形式，与数据库编码相同</entry>
     </row>

     <row>
      <entry><literal>default_collate_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该默认排序规则的数据库名（如果任意排序规则被标识，总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>default_collate_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该默认排序规则的模式名</entry>
     </row>

     <row>
      <entry><literal>default_collate_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       默认排序规则的名字。该默认排序规则被标识为匹配当前数据库的<literal>COLLATE</literal>和<literal>CTYPE</literal>设置的排序规则。如果没有那种排序规则，那么这一列和相关模式以及目录列为空。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   视图<literal>check_constraint_routine_usage</literal>标识被检查约束琐事使用的例程（函数和过程）。只有被一个当前启用的角色所拥有的例程才被显示。
  </para>

  <table>
   <title><literal>check_constraint_routine_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       该函数的<quote>指定名称</quote>。详见<xref linkend="infoschema-routines">。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   视图<literal>check_constraints</literal>包含所有检查约束，不管是定义在一个表上的还是定义在一个域上的，它们被一个当前启用的角色所拥有（表或域的拥有者就是约束的拥有者）。
  </para>

  <table>
   <title><literal>check_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>该检查约束的检查表达式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
  <title><literal>collations</literal></title>

  <para>
   视图<literal>collations</literal>包含在当前数据库中可用的排序规则。
  </para>

  <table>
   <title><literal>collations</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的模式名</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>默认排序规则的名称</entry>
     </row>

     <row>
      <entry><literal>pad_attribute</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       总是<literal>NO PAD</literal>（另一种选择<literal>PAD
       SPACE</literal>没有被 PostgreSQL 支持）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab"> <!-- max 44 characters -->
  <title><literal>collation_character_set_applicability</literal></title>

  <para>
   视图<literal>collation_character_set_applicability</literal>标识可用的排序规则适用于哪些字符集。在 PostgreSQL 中，每个数据库中只有一种字符集（解释见<xref linkend="infoschema-character-sets">），因此这个视图没有提供很有用的信息。
  </para>

  <table>
   <title><literal>collation_character_set_applicability</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的模式名</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>默认排序规则的名称</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集还未被实现为模式对象，所以这一列为空</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集还未被实现为模式对象，所以这一列为空</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字符集名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   视图<literal>column_domain_usage</literal>标识所有使用定义在当前数据库中并且被一个当前启用的角色拥有的域的列（表列或视图列）。
  </para>

  <table>
   <title><literal>column_domain_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>域名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
  <title><literal>column_options</literal></title>

  <para>
   视图<literal>column_options</literal>包含为当前数据库中外部表列定义的所有选项。只有当前用户能够访问（作为拥有者或具有某些特权）的那些外部表列才被显示。
  </para>

  <table>
   <title><literal>column_options</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部表名</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   视图<literal>column_privileges</literal>标识所有授予给一个当前启用的角色或者被一个当前启用的角色授予的特权。对每一个列、授予者、被授予者的组合只有一行。
  </para>

  <para>
   如果一个特权被授予在一整个表上，它在这个视图中被显示为在每一列上授予，但是只有可用于列粒度的特权类型才会这样：
   <literal>SELECT</literal>、<literal>INSERT</literal>、
   <literal>UPDATE</literal>、<literal>REFERENCES</literal>。
  </para>

  <table>
   <title><literal>column_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表名</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>或
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   视图<literal>column_udt_usage</literal>标识所有使用被一个当前启用的角色拥有的数据类型的列。注意在<productname>PostgreSQL</productname>中，内建数据类型的行为和用户定义的类型相似，因此它们也被包括在这里。详见<xref linkend="infoschema-columns">。
  </para>

  <table>
   <title><literal>column_udt_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的模式名
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）的名称
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   视图<literal>columns</literal>包含数据库中有关所有表列（或视图列）的信息。系统列（<literal>oid</>等）不被包括在内。只有那些当前用户能够访问（作为拥有者或具有某些特权）的列才被显示。
  </para>

  <table>
   <title><literal>columns</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该列在表内的顺序位置（从 1 开始计）</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该列的默认表达式</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列可以为空，则为<literal>YES</literal>，否则为<literal>NO</literal>。一个非空约束是让一列成为不能为空的方法，但还有其他方法。
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列的数据类型是一种内建类型，则为该列的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况下该类型被标识在<literal>udt_name</literal>和相关列中）。如果该列基于一个域，这一列引用该域底层的类型（该列被标识在<literal>domain_name</literal>和相关列中）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种字符或位串类型，这里是声明的最大长度；如果没有声明最大长度或者所有其他数据类型，这里为空。
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这列包含这个属性类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种准确数字类型，这列包含这个属性类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个属性类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个属性包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</productname>中不可用的特性（关于时间间隔类型属性的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的数据库名（总是当前数据库），如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的模式名，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该属性排序规则的名称，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该列有一个域类型，这里是该域所在的数据库名（总是当前数据库），否则为空。
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该列有一个域类型，这里是该域所在的模式名，否则为空。
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果该列有一个域类型，这里是该域的名称，否则为空。</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的模式名
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）的名称
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列的数据类型描述符的一个标识符，在从属于该表的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列是可更新的，则为<literal>YES</literal>，否则为<literal>NO</literal>（基表中的列总是可更新的，视图中的列则不一定）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   因为在 SQL 中有多种方式定义数据类型，而<productname>PostgreSQL</productname>还包含额外的方式来定义数据类型，它们在信息模式中的表示可能有点困难。列<literal>data_type</literal>应该标识列的底层内建类型。在<productname>PostgreSQL</productname>中，这表示定义在系统目录模式<literal>pg_catalog</literal>中的类型。如果应用能够特别地（例如以不同方式格式化数字类型或使用精度列中的数据）处理总所周知的内建类型，这列可能会有用。列<literal>udt_name</literal>、<literal>udt_schema</literal>和<literal>udt_catalog</literal>总是标识列的底层数据类型，即使该列是基于一个域的（因为<productname>PostgreSQL</productname>对待内建类型和用户定义类型的方式是一样的，内建类型也出现在这里。这是 SQL 标准的一种扩展）。如果一个应用想要根据该类型以不同的方式处理数据，就应该使用这些列，因为在那种情况下即使该列真地基于一个域也没有关系。如果该列是基于一个域，该域的标识被存储在列<literal>domain_name</literal>、<literal>domain_schema</literal>和<literal>domain_catalog</literal>。如果你想要把列和它们相关的数据类型配对并且把域视作单独的类型，你可以写<literal>coalesce(domain_name,
   udt_name)</literal>等等。
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   视图<literal>constraint_column_usage</literal>标识在当前数据库中被某个约束使用的所有列。只有包含在被一个当前启用的角色拥有的表中的那些列才被显示。对于一个检查约束，这个视图标识被用在该检查约束中的列。对于一个外键约束，这个视图标识外键引用的列。对于一个唯一或主键约束，这个视图标识被约束的列。
  </para>

  <table>
   <title><literal>constraint_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表所在的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表所在的模式名
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表名
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列名
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   视图<literal>constraint_table_usage</literal>标识在当前数据库中被某个约束使用的所有表（这与视图<literal>table_constraints</literal>不同，它标识哪些表约束定义在哪些表上）。对于一个外键约束，这个视图标识该外键引用的表。对于一个唯一或主键约束，这个视图仅标识该约束属于的表。检查约束和非空约束不被包括在这个视图中。
  </para>

  <table>
   <title><literal>constraint_table_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的表的模式名
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被某个约束使用的表名</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   视图<literal>data_type_privileges</literal>标识当前用户能够访问（作为被描述对象的拥有者或者具有其上的某种特权）的所有数据类型描述符。只要一个数据类型被用在一个表列、一个域或一个函数（作为参数或返回类型）就会生成一个数据类型描述符并且在那个实例中存储一些有关该数据类型如何被使用的信息（例如，声明的最大长度，如果适用）。每一个数据类型描述符被赋予一个任意的标识符，它在被赋予给一个对象（表、域、函数）的数据类型描述符中唯一。这个视图对于应用可能没什么用，但是它被用于定义信息模式中的一些其他视图。
  </para>

  <table>
   <title><literal>data_type_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该被描述对象的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该被描述对象的模式名</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该描述对象的名字</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       被描述对象的类型：<literal>TABLE</literal>（从属于表的一列的数据类型描述符）、<literal>DOMAIN</literal> （从属于域的数据类型描述符）、<literal>ROUTINE</literal>（从属于函数的一个参数或返回数据类型的数据类型描述符）。
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       数据类型描述符的标识符，它在同一对象的数据类型描述符之间唯一。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   视图<literal>domain_constraints</literal>包含所有属于当前数据库中定义的域的约束。只有当前用户能访问的那些域才被显示（作为拥有者或具有某些特权）。
  </para>

  <table>
   <title><literal>domain_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的且初始就被延迟，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   视图<literal>domain_udt_usage</literal>标识所有基于被一个当前启用的角色拥有的数据类型的域。注意在<productname>PostgreSQL</productname>中，内建数据类型的行为相似于用户定义的类型，因此它们也被包括在这里。
  </para>

  <table>
   <title><literal>domain_udt_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型的名称</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   视图<literal>domains</literal>包含定义在当前数据库中的所有域。只有当前用户能够访问（作为拥有者或具有某些特权）的域才被显示。
  </para>

  <table>
   <title><literal>domains</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该域的数据类型如果是一种内建类型，这里是该域的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一个字符或位串类型，这里是声明的最大长度；如果没有声明最大长度，则对于所有其他数据类型为空。
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      如果该域有一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此域排序规则的数据库名（总是当前数据库），如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此域排序规则的模式名，如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该域排序规则的名称，如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一种数字类型，这列包含这个域类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       
       如果该域有一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一种准确数字类型，这列包含这个域类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个域类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个域包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</productname>中不可用的特性（关于时间间隔类型域的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该域的默认表达式</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型的名称</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该域的数据类型描述符的一个标识符，在从属于该域的数据类型标识符之中唯一（这不重要，因为一个域只包含一个数据类型描述符）。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   视图<literal>element_types</literal>包含数组元素的数据类型描述符。当一个表列、组合类型属性、域、函数参数或函数返回值被定义为一种数组类型，相应的信息模式视图只在列<literal>data_type</literal>中包含<literal>ARRAY</literal>。要获得该数组元素类型的信息，你可以连接该相应的视图和这个视图。例如，要显示一个表的列及其数据类型和数组元素类型，你可以：
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   这个视图只包括当前用户能够访问（作为拥有者或具有某些特权）的对象。
  </para>

  <table>
   <title><literal>element_types</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含使用被描述的数组的对象的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含使用被描述的数组的对象的模式名
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       使用被描述的模式的对象名
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       使用被描述的数组的对象的类型：<literal>TABLE</literal>（被一个表列使用的数组）、<literal>USER-DEFINED TYPE</literal>（被组合类型的一个属性使用的数组）、<literal>DOMAIN</literal> （被域使用的数组）、<literal>ROUTINE</literal>（被函数的一个参数或返回数据类型使用的数组）。
      </entry>
     </row>

     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被描述的数组的数据类型描述符的标识符。使用这个去与其他信息模式视图的<literal>dtd_identifier</literal>列连接。
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果数组元素的数据类型是内建类型，这里是数组元素的数据类型，否则为<literal>USER-DEFINED</literal>（在那种情况下，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含元素类型排序规则的数据库名（总是当前数据库）, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含元素类型排序规则的模式名, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素类型的排序规则名, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>还未被实现</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素的数据类型所在的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素的数据类型所在的模式名
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       模式的数据类型名
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该元素的数据类型描述符的标识符。当前无用。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   视图<literal>enabled_roles</literal>标识当前<quote>已被启用的角色</quote>。已被启用的角色被递归地定义为：当前用户以及被授予给具有自动继承的已被启用角色的所有角色。换句话说，就是当前用户是其直接或间接成员的所有角色。
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   为了权限检查，<quote>可应用角色</quote>的集合被应用，它会比已被启用角色的集合包含的角色范围更宽。因此通常使用视图<literal>applicable_roles</literal>要更好。
  </para>

  <table>
   <title><literal>enabled_roles</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>角色名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <para>
   视图<literal>foreign_data_wrapper_options</literal>包含为当前数据库中外部数据包装器定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部数据包装器被显示。
  </para>

  <table>
   <title><literal>foreign_data_wrapper_options</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部数据包装器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部数据包装器的名字</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <para>
   视图<literal>foreign_data_wrappers</literal>包含定义在当前数据库中的所有外部数据包装器。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部数据包装器才会被显示。
  </para>

  <table>
   <title><literal>foreign_data_wrappers</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部数据包装器的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部数据包装器的名字</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部服务器拥有者的名字</entry>
     </row>

     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>实现这个外部数据包装器的库文件名</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>用于实现这个外部数据包装器的语言</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <para>
   视图<literal>foreign_server_options</literal>包含为当前数据库中外部服务器定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部服务器才会被显示。
  </para>

  <table>
   <title><literal>foreign_server_options</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <para>
   视图<literal>foreign_servers</literal>包含当前数据库中定义的所有外部服务器。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部服务器才会被显示。
  </para>

  <table>
   <title><literal>foreign_servers</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被该外部服务器使用的外部数据包装器的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被该外部服务器所使用的外部数据包装器的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>外部服务器类型信息（如果在创建时指定过）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>外部服务器版本信息（如果在创建时指定过）</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的拥有者名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
  <title><literal>foreign_table_options</literal></title>

  <para>
   视图<literal>foreign_table_options</literal>包含为当前数据库中外部表定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部表才会被显示。
  </para>

  <table>
   <title><literal>foreign_table_options</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部表的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
  <title><literal>foreign_tables</literal></title>

  <para>
   视图<literal>foreign_tables</literal>包含定义在当前数据库中的所有外部表。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部表才会被显示。
  </para>

  <table>
   <title><literal>foreign_tables</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部表所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部表的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   视图<literal>key_column_usage</literal>标识当前数据库中所有被某种唯一、主键或外键约束限制的列。检查约束不被包括在这个视图中。只有那些当前用户能够访问的列才会被显示（作为拥有者或具有某些特权）。
  </para>

  <table>
   <title><literal>key_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表所在的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被这个约束限制的列名</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该列在约束键中的顺序位置（从 1 开始计数）</entry>
     </row>

     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>对于一个外键约束，被引用行在其唯一约束中的顺序位置（从 1 开始计数）；对于其他约束为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   视图<literal>parameters</literal>包含当前数据库中所有函数的参数的有关信息。只有那些当前用户能够访问（作为拥有者或具有某些特权）的函数才会被显示。
  </para>

  <table>
   <title><literal>parameters</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines">。
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该参数在函数参数列表中的顺序位置（从 1 开始计数）
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal>表示输入参数，
       <literal>OUT</literal>表示输出参数，
       <literal>INOUT</literal>表示输入输出参数。
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>参数名，如果参数没有名称则为空</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该参数的数据类型如果是一种内建类型，这里是该参数的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型所在的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型所在的模式名
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型的名字
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该参数的数据类型描述符的一个标识符，在从属于该函数的数据类型标识符之中唯一（这不重要，因为一个域只包含一个数据类型描述符）。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>
     
     <row>
      <entry><literal>parameter_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该参数的默认表达式，如果没有或者该函数不被一个当前启用的角色拥有则为空值。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   视图<literal>referential_constraints</literal>包含当前数据库中的所有引用（外键）约束。只有那些当前用户具有其引用表上写权限（作为拥有者或具有某些除<literal>SELECT</literal>之外的特权）的约束才会被显示。
  </para>

  <table>
   <title><literal>referential_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的模式名
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的名字
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的匹配选项：
       <literal>FULL</literal>、<literal>PARTIAL</literal>或<literal>NONE</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的更新规则：
       <literal>CASCADE</literal>、<literal>SET NULL</literal>、
       <literal>SET DEFAULT</literal>、<literal>RESTRICT</literal>或
       <literal>NO ACTION</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的删除规则：
       <literal>CASCADE</literal>、<literal>SET NULL</literal>、
       <literal>SET DEFAULT</literal>、<literal>RESTRICT</literal>或
       <literal>NO ACTION</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   视图<literal>role_column_grants</literal>标识所有在列上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>column_privileges</literal>中找到。这个视图和<literal>column_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的列。
  </para>

  <table>
   <title><literal>role_column_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表名</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>或
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
  视图<literal>role_routine_grants</literal>标识所有在函数上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>routine_privileges</literal>中找到。这个视图和<literal>routine_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的函数。
  </para>

  <table>
   <title><literal>role_routine_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines">。
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能会重复）</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为<literal>EXECUTE</literal>（函数唯一的特权类型）</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
  视图<literal>role_table_grants</literal>标识所有在表或视图上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>table_privileges</literal>中找到。这个视图和<literal>table_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的表。
  </para>

  <table>
   <title><literal>role_table_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该特权的类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>、
       <literal>REFERENCES</literal>或<literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       在 SQL 标准中，<literal>WITH HIERARCHY OPTION</literal>是一个独立的（子）特权，它允许在表继承层级上的特定操作。在 PostgreSQL 中，这被包括在<literal>SELECT</literal>特权中，因此这一列在特权为<literal>SELECT</literal>时显示<literal>YES</literal>，其他时候显示<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
  <title><literal>role_udt_grants</literal></title>

  <para>
  视图<literal>role_udt_grants</literal>标识所有在用户定义类型上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>udt_privileges</literal>中找到。这个视图和<literal>udt_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的对象。因为数据类型在 PostgreSQL 中并没有真正的特权，而是只有一个给<literal>PUBLIC</literal>的隐式授予，这个视图为空。
  </para>

  <table>
   <title><literal>role_udt_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
  视图<literal>role_usage_grants</literal>标识所有在多种对象上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>usage_privileges</literal>中找到。这个视图和<literal>usage_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的对象。
  </para>

  <table>
   <title><literal>role_usage_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该对象的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果适用，则为包含该对象的模式名，否则为一个空字符串</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>对象的名字</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>或<literal>DOMAIN</literal>或<literal>FOREIGN DATA WRAPPER</literal>或<literal>FOREIGN SERVER</literal>或<literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   视图<literal>routine_privileges</literal>标识所有在函数上授予的特权，其授予者或被授予者是一个当前已被启用的角色。对于每一种函数、授予者和被授予者的组合，这里都有一行。
  </para>

  <table>
   <title><literal>routine_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines">。
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能重复）</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>EXECUTE</literal>（函数唯一的特权类型）</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   视图<literal>routines</literal>包含当前数据库中所有的函数。只有那些当前用户能够访问（作为拥有者或具有某些特权）的函数才会被显示。
  </para>

  <table>
   <title><literal>routines</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。这是一个在模式中唯一标识该函数的名称，即使该函数真正的名称已经被重载。专用名的格式尚未被定义，它应当仅被用来与指定例程名称的其他实例进行比较。
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能重复）</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是<literal>FUNCTION</literal>（未来可能会有其他例程的类型）
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该函数的返回数据类型如果是一种内建类型，这里是该数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>type_udt_name</literal>和相关列中）。
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</>中的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该函数的返回数据类型所在的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的返回数据类型所在的模式名
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的返回数据类型的名字
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</>中总是有无限制的最大势</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该函数返回数据类型的数据类型描述符的一个标识符，在从属于该函数的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该函数是一个 SQL 函数，则为<literal>SQL</literal>，否则为<literal>EXTERNAL</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该函数的源文本（如果该函数不属于一个当前已被启用的角色，则为空）。（根据 SQL 标准，只有<literal>routine_body</literal>为<literal>SQL</literal>时这一列才适用。但是在<productname>PostgreSQL</productname>中，它将会包含该函数被创建时所指定的任何源文本。）
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果这个函数是一个 C 函数，则为该函数的外部名称（链接符号），否则为空（这会产生和显示在<literal>routine_definition</literal>中相同的值）。
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该函数所用的语言</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是<literal>GENERAL</literal>（SQL 标准定义了其他参数风格，但在<productname>PostgreSQL</>中不可用）
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该函数被声明为不变（在 SQL 标准中被称为确定性的），则为<literal>YES</literal>，否则为<literal>NO</literal>（你不能通过该信息模式查询在<productname>PostgreSQL</>中可用的其他易变级别）。
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是<literal>MODIFIES</literal>，表示该函数可能修改 SQL 数据。这种信息对<productname>PostgreSQL</>没有用处。
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该函数在任一参数为空时自动返回空值，则为<literal>YES</literal>，否则为<literal>NO</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       总是<literal>YES</literal>（反例是一个用户定义类型的方法，这是在<productname>PostgreSQL</>不可用的一种特性）。
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该函数以当前用户的特权运行，则为<literal>INVOKER</literal>；如果该函数以定义它的用户的特权运行，则为<literal>DEFINER</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       当前总是<literal>NO</literal>。另一个选项<literal>YES</literal>应用于一个<productname>PostgreSQL</>中不可用的特性。
      </entry>
     </row>

     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   视图<literal>schemata</literal>包含当前数据库中被当前用户（作为属主或具有某些特权）可访问的所有模式。
  </para>

  <table>
   <title><literal>schemata</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式的名称</entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式拥有者的名称</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   视图<literal>sequences</literal>包含所有定义在当前数据库中的序列。只有那些当前用户能够访问（作为拥有者或具有某些特权）的序列才会被显示。
  </para>

  <table>
   <title><literal>sequences</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该序列的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该序列的模式名</entry>
     </row>

     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该序列的名字</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该序列的数据类型。在<productname>PostgreSQL</productname>中，这在当前总是<literal>bigint</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       这列包含这个序列数据类型（见上文）的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      这列包含这个序列数据类型（见上文）的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。
      </entry>
     </row>

     <row>
      <entry><literal>start_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的开始值</entry>
     </row>

     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的最小值</entry>
     </row>

     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的最大值</entry>
     </row>

     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的增量</entry>
     </row>

     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该序列会循环，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   注意依照 SQL 标准，开始值、最小值、最大值和增量值被作为字符串返回。
  </para>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   表<literal>sql_features</literal>包含的信息指示了哪些 SQL 标准中定义的正式特性被<productname>PostgreSQL</productname>所支持。这和<xref linkend="features">中的信息一样。这里你也能找到一些额外的背景信息。
  </para>

  <table>
   <title><literal>sql_features</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该特性的标识符字符串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该特性的描述性名称</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该子特性的标识符字符串，或者如果不是一个子特性则为一个长度为零的字符串</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该子特性的描述性名称，或者如果不是一个子特性则为一个长度为零的字符串</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该特性被当前版本的<productname>PostgreSQL</>完全支持，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该特性被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   表<literal>sql_implementation_info</literal>包含的信息指示剩下的由 SQL 标准实现定义的多个方面。这类信息主要用来在 ODBC 接口的情境中使用；其它接口的用户可能将发现这类信息用处不大。由于这个原因，个体实现信息项没有在这里描述，你将会在 ODBC 接口的描述中找到它们。
  </para>

  <table>
   <title><literal>sql_implementation_info</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该实现信息项的标识符字符串</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该实现信息项的描述性名称</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       该实现信息项的值，如果该值被包含在<literal>character_value</literal>列中则为空
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该实现信息项的值，如果该值被包含在<literal>integer_value</literal>列中则为空
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于该实现信息项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <para>
   表<literal>sql_languages</literal>为每一种被<productname>PostgreSQL</productname>支持的 SQL 语言绑定包含一行。<productname>PostgreSQL</productname>支持在 C 中的直接 SQL 和嵌入式 SQL，这是你从这张表中知道的所有东西。
  </para>

  <para>
   这个表在 SQL:2008 中已被从 SQL 标准中移除，因此这里没有项引用 SQL:2003 之后的标准。
  </para>

  <table>
   <title><literal>sql_languages</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该语言定义的源名称，总是<literal>ISO 9075</literal>，即 SQL 标准
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>sql_language_source</literal>中引用的标准被通过的年份。
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该语言绑定的标准一致性级别。对于 ISO 9075:2003 总是<literal>CORE</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空（这个值与一个早期版本的 SQL 标准相关）。</entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       语言绑定风格，为<literal>DIRECT</literal>或<literal>EMBEDDED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果绑定风格为<literal>EMBEDDED</literal>，则为编程语言，否则为空。<productname>PostgreSQL</>仅支持 C 语言。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <para>
   表<literal>sql_packages</literal>包含的信息指示哪些定义在 SQL 标准中的特性包被<productname>PostgreSQL</productname>支持。特性包上的背景信息可参考<xref linkend="features">。
  </para>

  <table>
   <title><literal>sql_packages</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该包的标识符字符串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该包的描述性名称</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该包被当前版本的<productname>PostgreSQL</>支持，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该包被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   表<literal>sql_parts</literal>包含的信息指示哪些定义在 SQL 标准中的部分被<productname>PostgreSQL</productname>支持。
  </para>

  <table>
   <title><literal>sql_parts</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>包含该部分编号的一个标识符字符串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该部分的描述性名称</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果当前版本的<productname>PostgreSQL</>完全支持该部分，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该部分被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   表<literal>sql_sizing</literal>包含有关<productname>PostgreSQL</>中多种尺寸限制和最大值的信息。这类信息主要用来在 ODBC 接口的情境中使用；其它接口的用户可能将发现这类信息用处不大。由于这个原因，个体实现信息项没有在这里描述，你将会在 ODBC 接口的描述中找到它们。
  </para>

  <table>
   <title><literal>sql_sizing</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该尺寸项的标识符</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该尺寸项的描述性名称</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       尺寸项的值，如果尺寸是不受限制或不能确定的则为 0，如果尺寸项适用的特性不受支持则为空
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于尺寸项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <para>
   表<literal>sql_sizing_profiles</literal>包含有关 SQL 标准的多种 profile 所需的<literal>sql_sizing</literal>值的信息。<productname>PostgreSQL</>不追踪任何 SQL profile，因此这个表为空。
  </para>

  <table>
   <title><literal>sql_sizing_profiles</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该尺寸项的标识符</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该尺寸项的描述性名称</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>一个 profile 的标识符字符串</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       该 SQL profile 对尺寸项所要求的值，如果该 profile 对尺寸项没有限制则为 0，如果该 profile 不要求该尺寸项所适用的任何特性则为空
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于该 profile 中尺寸项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   视图<literal>table_constraints</literal>包含属于特定表的所有约束，这些表要满足的条件是：当前用户拥有表或者是当前用户在表上具有某种除<literal>SELECT</literal>之外的特权。
  </para>

  <table>
   <title><literal>table_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该约束的类型：<literal>CHECK</literal>、
       <literal>FOREIGN KEY</literal>、<literal>PRIMARY KEY</literal>或<literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的并且是初始已被延迟，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   视图<literal>table_privileges</literal>标识在表或视图上所有被授予的特权，这些特权必须是被一个当前已被启用角色授出或者被授予给一个当前已被启用角色。对每一个表、授予者和被授予者的组合都有一行。
  </para>

  <table>
   <title><literal>table_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>、
       <literal>REFERENCES</literal>或<literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       在 SQL 标准中，<literal>WITH HIERARCHY OPTION</literal>是一个独立的（子）特权，它允许在表继承层级上的特定操作。在 PostgreSQL 中，这被包括在<literal>SELECT</literal>特权中，因此这一列在特权为<literal>SELECT</literal>时显示<literal>YES</literal>，其他时候显示<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   视图<literal>tables</literal>包含定义在当前数据库中的所有表和视图。只有那些当前用户能够访问（作为拥有者或具有某些特权）的表和视图才会被显示。
  </para>

  <table>
   <title><literal>tables</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该表的类型：<literal>BASE TABLE</literal>表示一个持久的基本表（常见表类型），<literal>VIEW</literal>表示一个视图，<literal>FOREIGN TABLE</literal>表示一个外部表，<literal>LOCAL TEMPORARY</literal>表示一个临时表
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是包含其底层数据类型的数据库名（总是当前数据库），否则为空。
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是包含其底层数据类型的模式名，否则为空。
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是其底层数据类型的名称，否则为空。
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该表能够被插入，则为<literal>YES</literal>，否则为<literal>NO</literal>（基本表总是能被插入，而视图则不一定）。
      </entry>
     </row>

     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该表是一个有类型的表，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>还未被实现</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
  <title><literal>triggered_update_columns</literal></title>

  <para>
   对于当前数据库中指定一个列列表（如<literal>UPDATE OF column1, column2</literal>）的触发器，视图<literal>triggered_update_columns</literal>标识这些列。没有指定一个列列表的触发器不被包括在这个视图中。只有那些当前用户拥有或具有某种除<literal>SELECT</literal>之外特权的列才会被显示。
  </para>

  <table>
   <title><literal>triggered_update_columns</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的模式名</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器的名称</entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含触发器所在的表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含触发器所在的表的模式名</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>触发器所在的表的名称</entry>
     </row>

     <row>
      <entry><literal>event_object_column</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>触发器所在的列的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   视图<literal>triggers</literal>包含所有定义在当前数据库中表和视图上的触发器，并且只显示当前用户拥有的触发器或者是当前用户在其上具有某种除<literal>SELECT</literal>之外特权的触发器。
  </para>

  <table>
   <title><literal>triggers</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的模式名</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器的名称</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发该触发器的事件（<literal>INSERT</literal>、
       <literal>UPDATE</literal>或<literal>DELETE</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含触发器所在的表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器所在的表的模式名</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器所在的表的名称</entry>
     </row>

     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>还未被实现</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发器的<literal>WHEN</literal>条件，如果没有则为空（如果该表不被一个当前已启用角色拥有也是为空）
      </entry>
     </row>

     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该触发器执行的语句（当前总是
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       标识触发器是对每个被处理的行触发一次还是为每个语句触发一次（<literal>ROW</literal>或<literal>STATEMENT</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>action_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发器在什么时候触发（<literal>BEFORE</literal>、
       <literal>AFTER</literal>或<literal>INSTEAD OF</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>action_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Triggers in <productname>PostgreSQL</productname>中的触发器有两点与 SQL 标准不兼容，这会影响在该信息模式中的表示。第一，在<productname>PostgreSQL</productname>中触发器的名字是局限于每个表的，而不是独立于模式对象。因此可能在一个模式中会有重复的触发器名称，只要它们属于不同的表（<literal>trigger_catalog</literal>和<literal>trigger_schema</literal>才真正标识了触发器被定义在哪个表上）。第二，在<productname>PostgreSQL</productname>中触发器可以被定义为在多个事件上触发（例如<literal>ON INSERT OR
   UPDATE</literal>），而在 SQL 标准中只允许一个。如果一个触发器被定义为在多个事件上触发，它在信息模式中被表示为多行，每一行对应于一类事件。作为这两个问题的结果，视图<literal>triggers</literal>的主键实际上是<literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal>，而不是<literal>(trigger_catalog, trigger_schema, trigger_name)</literal>（这是 SQL 标准指定的）。尽管如此，如果你以符合 SQL 标准（在模式中触发器名称唯一并且每个触发器只能有一种事件类型）的方式定义你的触发器，这将不会影响你。
  </para>

  <note>
   <para>
    在<productname>PostgreSQL</> 9.1 之前，这个视图的列
    <structfield>action_timing</structfield>、
    <structfield>action_reference_old_table</structfield>、
    <structfield>action_reference_new_table</structfield>、
    <structfield>action_reference_old_row</structfield>和
    <structfield>action_reference_new_row</structfield>
    分别被命名为
    <structfield>condition_timing</structfield>、
    <structfield>condition_reference_old_table</structfield>、
    <structfield>condition_reference_new_table</structfield>、
    <structfield>condition_reference_old_row</structfield>和
    <structfield>condition_reference_new_row</structfield>。
    那也是它们在 SQL:1999 标准中的命名。新的命名遵循 SQL:2003 及其后的版本。
   </para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
  <title><literal>udt_privileges</literal></title>

  <para>
  视图<literal>udt_privileges</literal>标识所有在用户定义类型上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。对每一个列、授予者和被授予者的组合都有一行。这个视图只显示组合类型（原因见下面的<xref linkend="infoschema-user-defined-types">）。域特权见<xref linkend="infoschema-usage-privileges">。
  </para>

  <table>
   <title><literal>udt_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   视图<literal>usage_privileges</literal>标识所有在多种对象上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。在<productname>PostgreSQL</productname>中，这当前适用于排序规则、域、外部数据包装器、外部服务器和序列。对每一个对象、授予者和被授予者都有一行。
  </para>

  <para>
   由于在<productname>PostgreSQL</productname>中排序规则并没有真正的特权，这个视图对所有排序规则显示由拥有者授予给<literal>PUBLIC</literal>的隐式非可授予的<literal>USAGE</literal>特权。但是对其他对象类型则显示真实的特权。
  </para>

  <para>
   在 PostgreSQL 中，序列也支持除<literal>USAGE</literal>之外的<literal>SELECT</literal>和<literal>UPDATE</literal>特权。这些是非标准的并且因此在该信息模式中不可见。
  </para>

  <table>
   <title><literal>usage_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该对象的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果适用，则是包含该对象的模式名，否则为一个空字符串</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该对象的名称</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>或<literal>DOMAIN</literal>或<literal>FOREIGN DATA WRAPPER</literal>或<literal>FOREIGN SERVER</literal>或<literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-defined-types">
  <title><literal>user_defined_types</literal></title>

  <para>
   视图<literal>user_defined_types</literal>目前包含定义在当前数据库中的所有组合类型。只有那些当前用户能够访问（作为拥有者或具有某些特权）的类型才会被显示。
  </para>

  <para>
   SQL 知道两种用户定义类型：结构类型（在<productname>PostgreSQL</productname>中也被称为组合类型）以及独特类型（在<productname>PostgreSQL</productname>没有实现）。要经得起未来的考验，请使用列<literal>user_defined_type_category</literal>来区分它们。其他用户定义类型如基类型和枚举（都是<productname>PostgreSQL</productname>的扩展）不会被显示在这里。对于域，请见<xref linkend="infoschema-domains">。
  </para>

  <table>
   <title><literal>user_defined_types</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       当前总是<literal>STRUCTURED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_instantiable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_final</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_form</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>reference_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>source_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>ref_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <para>
   视图<literal>user_mapping_options</literal>包含在当前数据库中为用户映射定义的所有选项。只有那些当前用户能够访问其相应外部服务器（作为拥有者或具有某些特权）的用户映射才会被显示。
  </para>

  <table>
   <title><literal>user_mapping_options</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被映射的用户名，如果映射是公共的则为<literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器的名称</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>选项的值。除非当前用户是被映射的用户或者映射是<literal>PUBLIC</literal>的并且当前用户是服务器拥有者或者超级用户，这一列将显示为空。这样做的目的是保护作为用户映射选项存储的口令信息。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <para>
   视图<literal>user_mappings</literal>包含定义在当前数据库中的所有用户映射。只有当前用户能够访问其对应外部服务器（作为拥有者或具有某些特权）的用户映射才会被显示。
  </para>

  <table>
   <title><literal>user_mappings</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被映射的用户名，如果映射是公共的则为<literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   视图<literal>view_column_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有列。只有当包含一列的表被一个当前已被启用角色拥有时，该列才会被包括在这个视图中。
  </para>

  <note>
   <para>
    系统表列不被包括。在某个时候这应该会被修复。
   </para>
  </note>

  <table>
   <title><literal>view_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的模式名
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的名称
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被该视图所使用的列名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
  视图<literal>view_routine_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有例程（函数和过程）。只有被一个当前已被启用角色拥有的例程才会被包括在这个视图中。
  </para>

  <table>
   <title><literal>view_routine_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该视图的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>该视图的名称</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines">。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
  视图<literal>view_table_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有表。只有被一个当前已被启用角色拥有的表才会被包括在这个视图中。
  </para>

  <note>
   <para>
    系统表没有被包括。这应当会在某个时候被修复。
   </para>
  </note>

  <table>
   <title><literal>view_table_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的模式名
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的名称
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   视图<literal>views</literal>包含定义在当前数据库中的所有视图。只有当前用户能够访问（作为拥有者或具有某些特权）的视图才会被显示。
  </para>

  <table>
   <title><literal>views</literal>列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

     <row>
      <entry><literal>view_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       定义视图的查询表达式（如果该视图不被一个当前已被启用角色拥有则为空）
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</>中不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该视图是可更新的（允许<command>UPDATE</command>和<command>DELETE</command>），则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该视图是可插入的（允许<command>INSERT</command>），则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
        如果该视图上有一个<literal>INSTEAD OF</>
       <command>UPDATE</>触发器，则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_deletable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
      如果该视图上有一个<literal>INSTEAD OF</>
       <command>DELETE</>触发器，则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
      如果该视图上有一个<literal>INSTEAD OF</>
       <command>INSERT</>触发器，则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
