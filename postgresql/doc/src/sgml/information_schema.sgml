<!-- doc/src/sgml/information_schema.sgml -->

<chapter id="information-schema">
 <!-- 
 <title>The Information Schema</title> 
 -->
 <title>信息模式</title>

 <indexterm zone="information-schema">
  <!-- 
  <primary>information schema</primary> 
  -->
  <primary>信息模式</primary>
 </indexterm>

 <!--
<para>
  The information schema consists of a set of views that contain
  information about the objects defined in the current database.  The
  information schema is defined in the SQL standard and can therefore
  be expected to be portable and remain stable &mdash; unlike the system
  catalogs, which are specific to
  <productname>PostgreSQL</productname> and are modeled after
  implementation concerns.  The information schema views do not,
  however, contain information about
  <productname>PostgreSQL</productname>-specific features; to inquire
  about those you need to query the system catalogs or other
  <productname>PostgreSQL</productname>-specific views.
 </para>
-->
<para>
信息模式由一组视图组成，它们包含有关当前数据库里定义的对象的信息。
信息模式是 SQL 标准里定义的，因此可以认为是可以移植的，并且是相对稳定的&mdash;
和系统表不一样，系统表是<productname>PostgreSQL</productname>特有的，
是在实现的基础上进行建模的。但信息模式视图不包含有关<productname>PostgreSQL</productname>
特有的特性的信息；你可以查询系统表或者其它<productname>PostgreSQL</productname>
特定的视图查询它。 
</para>

 <note>
  <!--
<para>
   When querying the database for constraint information, it is possible
   for a standard-compliant query that expects to return one row to
   return several.  This is because the SQL standard requires constraint
   names to be unique within a schema, but
   <productname>PostgreSQL</productname> does not enforce this
   restriction.  <productname>PostgreSQL</productname>
   automatically-generated constraint names avoid duplicates in the
   same schema, but users can specify such duplicate names.
  </para>
-->
<para>
当查询数据库约束信息时，一个标准兼容的查询有可能返回一到多行。
这是因为在一个模式中SQL标准查询约束名是唯一的，但是<productname>PostgreSQL</productname>
并不强制这个约束。<productname>PostgreSQL</productname>
自动产生约束名避免在同一个模式中重复，但是用户可以指定重复的名字。
</para>

  <!--
<para>
   This problem can appear when querying information schema views such
   as <literal>check_constraint_routine_usage</>,
   <literal>check_constraints</>, <literal>domain_constraints</>, and
   <literal>referential_constraints</>.  Some other views have similar
   issues but contain the table name to help distinguish duplicate
   rows, e.g., <literal>constraint_column_usage</>,
   <literal>constraint_table_usage</>, <literal>table_constraints</>.
  </para>
-->
<para>
当查询信息模式视图（如<literal>check_constraint_routine_usage</>,
<literal>check_constraints</>, <literal>domain_constraints</>,和
<literal>referential_constraints</>）时会出现这样的问题。
一些其他视图有相似的问题，但是包含表明以帮助辨别重复的行，
例如<literal>constraint_column_usage</>, <literal>constraint_table_usage</>,
 <literal>table_constraints</>。
</para>
 </note>


 <sect1 id="infoschema-schema">
  <!-- 
  <title>The Schema</title> 
  -->
  <title>关于这个模式</title>

  <!--
<para>
   The information schema itself is a schema named
   <literal>information_schema</literal>.  This schema automatically
   exists in all databases.  The owner of this schema is the initial
   database user in the cluster, and that user naturally has all the
   privileges on this schema, including the ability to drop it (but
   the space savings achieved by that are minuscule).
  </para>
-->
<para>
信息模式本身是一个叫<literal>information_schema</literal>的模式。
这个模式自动存在于所有数据库中。这个模式的所有者是数据库集群中的最初的数据库用户，
并且这个用户天然就拥有这个模式上的所有权限，包括删除它的权限
（不过这么干省下来的空间小的可怜）。 
</para>

  <!--
<para>
   By default, the information schema is not in the schema search
   path, so you need to access all objects in it through qualified
   names.  Since the names of some of the objects in the information
   schema are generic names that might occur in user applications, you
   should be careful if you want to put the information schema in the
   path.
  </para>
-->
<para>
缺省的时候，信息模式不在模式搜索路径中，因此，你需要用全称来访问里面的所有对象。
因为信息模式里的一些对象的名字是可能在用户应用中出现的普通名字，所以，
如果你想把信息模式放在路径中的话，那你一定要小心。 
</para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <!-- 
  <title>Data Types</title> 
  -->
  <title>数据类型</title>
  <!--
<para>
   The columns of the information schema views use special data types
   that are defined in the information schema.  These are defined as
   simple domains over ordinary built-in types.  You should not use
   these types for work outside the information schema, but your
   applications must be prepared for them if they select from the
   information schema.
  </para>
-->
<para>
信息模式视图的字段使用的是特殊的数据类型，它们是在信息模式里定义的。
这些都是在内置类型上定义的简单的域。你不应当在信息模式之外的地方使用这些类型工作，
但是如果你的应用从信息模式中选取了数据，那么它必须面对它们。 
</para>
  
<para>
<!--
   These types are:
-->
这些类型是： 
   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
<!-- 
      <para>
       A nonnegative integer.
      </para>
 -->
<para>
非负整数。 
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <!--
<para>
       A character string (without specific maximum length).
      </para>
-->
<para>
一个字符串（没有声明最大长度）。 
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <!--
<para>
       A character string.  This type is used for SQL identifiers, the
       type <type>character_data</type> is used for any other kind of
       text data.
      </para>
-->
<para>
一个字符串。这个类型用于SQL标识符，类型<type>character_data</type>
用于任何其它类型的文本数据。 
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <!--
<para>
       A domain over the type <type>timestamp with time zone</type>
      </para>
-->
<para>
一个在类型<type>timestamp with time zone</type>上的域。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <!--
<para>
       A character string domain that contains
       either <literal>YES</literal> or <literal>NO</literal>.  This
       is used to represent Boolean (true/false) data in the
       information schema.  (The information schema was invented
       before the type <type>boolean</type> was added to the SQL
       standard, so this convention is necessary to keep the
       information schema backward compatible.)
      </para>
-->
<para>
一个字符串域要么包含<literal>YES</literal>要么包含<literal>NO</literal>。
这在信息模式中用来表示Boolean (true/false)数据。
（在<type>boolean</type>类型被添加到SQL标准之前信息模式被发明出来，
为保持信息模式向前兼容这个约定是必须的。） 
</para>
     </listitem>
    </varlistentry>
   </variablelist>

<!-- 
   Every column in the information schema has one of these five types. 
-->
信息模式里的每个字段都有这五种类型之一。 
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <!-- 
  <title><literal>information_schema_catalog_name</literal></title> 
  -->
  <title><literal>information_schema_catalog_name</literal></title>

  <!--
<para>
   <literal>information_schema_catalog_name</literal> is a table that
   always contains one row and one column containing the name of the
   current database (current catalog, in SQL terminology).
  </para>
-->
<para>
<literal>information_schema_catalog_name</literal>是一个总是包含一行一列的表，
里面包含当前数据库的名字（用SQL术语来说，是当前目录）。 
</para>

  <table>
   <!-- 
   <title><literal>information_schema_catalog_name</literal> Columns</title> 
   -->
   <title><literal>information_schema_catalog_name</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains this information schema</entry> 
  -->
  <entry>包含这个信息模式的数据库名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <!--
<para>
   The view <literal>administrable_role_authorizations</literal>
   identifies all roles that the current user has the admin option
   for.
  </para>
-->
<para>
视图<literal>administrable_role_authorizations</literal>标识当前用户有管理员选项的所有角色。 
</para>

  <table>
   <!-- 
   <title><literal>administrable_role_authorizations</literal> Columns</title> 
   -->
   <title><literal>administrable_role_authorizations</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships) 
   -->
   赋予角色成员的角色名称（可以是当前用户，或者一个在角色成员关系中嵌套的不同角色）
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of a role</entry> 
  -->
  <entry>角色名称</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Always <literal>YES</literal></entry> 
  -->
  <entry>总是 <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <!--
<para>
   The view <literal>applicable_roles</literal> identifies all roles
   whose privileges the current user can use.  This means there is
   some chain of role grants from the current user to the role in
   question.  The current user itself is also an applicable role.  The
   set of applicable roles is generally used for permission checking.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>
-->
<para>
视图<literal>applicable_roles</literal>标识当前用户所属的所有组。
这意味着有一些角色束缚限制由当前用户授予问题中的角色。当前用户本身也是一个可用的角色。
这个适合的可用角色组通常被用做许可检查。
<indexterm><primary>可用的角色</primary></indexterm>
<indexterm><primary>角色</primary><secondary>可用的</secondary></indexterm>
</para>

  <table>
   <!-- 
   <title><literal>applicable_roles</literal> Columns</title> 
   -->
   <title><literal>applicable_roles</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships) 
   -->
   赋予角色成员的角色名称（可以是当前用户，或者一个在角色成员关系嵌套中的不同的角色成员）
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of a role</entry> 
  -->
  <entry>角色名</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the grantee has the admin option on
       the role, <literal>NO</literal> if not 
   -->
   如果授权者有管理员权限的话为<literal>YES</literal>, 否则为<literal>NO</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <!--
<para>
   The view <literal>attributes</literal> contains information about
   the attributes of composite data types defined in the database.
   (Note that the view does not give information about table columns,
   which are sometimes called attributes in PostgreSQL contexts.)
   Only those attributes are shown that the current user has access to (by way
   of being the owner of or having some privilege on the type).
  </para>
-->
<para>
视图<literal>attributes</literal>包含有关在数据库中定义的复合数据类型的属性信息。
（注意，视图不会提供表字段的信息，在PostgreSQL环境中有时被叫做属性。）
只有当前用户有权限时才显示这些属性（通过成为它的所有者或者在这个类型上有某些权限）。
</para>

  <table>
   <!-- 
   <title><literal>attributes</literal> Columns</title> 
   -->
   <title><literal>attributes</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the data type (always the current database)</entry> 
  -->
  <entry>包含数据类型的数据库名称（总是在当前数据库中）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the data type</entry> 
  -->
  <entry>包含数据类型的模式名称</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the data type</entry> 
  -->
  <entry>数据类型名称</entry>
     </row>

     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the attribute</entry> 
  -->
  <entry>属性名</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Ordinal position of the attribute within the data type (count starts at 1)</entry> 
  -->
  <entry>数据类型中的属性的顺序位置（从1开始计数）</entry>
     </row>

     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Default expression of the attribute</entry> 
  -->
  <entry>属性的默认表达式</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the attribute is possibly nullable,
       <literal>NO</literal> if it is known not nullable. 
   -->
   如果属性可能为空则为<literal>YES</literal>，如果不为空则为<literal>NO</literal>。 
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Data type of the attribute, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>attribute_udt_name</literal> and
       associated columns). 
   -->
   如果它是内建类型，那么是属性的数据类型，或者如果它是一些数组，
   那么是<literal>ARRAY</literal>（在这种情况下，查看视图<literal>element_types</literal>），
   其它情况是<literal>USER-DEFINED</literal>（在这种情况下，
   在<literal>attribute_udt_name</literal>和相关字段中定义类型）。 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared. 
   -->
   如果<literal>data_type</literal>标识一个字符或比特流类型，那么是声明的最大长度；
   对于所有其它的数据类型或如果没有声明最大长度都用null。 
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding. 
   -->
   如果<literal>data_type</literal>识别一个字符类型，
   那么最大可能长度在一个数据的字节（bytes）中；对于所有其它的数据类型为null。
   最大的字节长度取决于声明的字符最大长度（参考上文）和服务器的编码。 
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database containing the collation of the attribute
       (always the current database), null if default or the data type
       of the attribute is not collatable 
   -->
   包含属性排序规则的数据库名称（总是当前数据库），
   缺省或属性的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema containing the collation of the attribute,
       null if default or the data type of the attribute is not
       collatable
   -->
   包含属性排序规则的模式名，缺省或属性的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      <!-- 
  Name of the collation of the attribute, null if default or the
       data type of the attribute is not collatable 
   -->
   属性的排序规则的名称，缺省或属性的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this attribute.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个数字类型，那么该字段
   （隐含地或者公开地）包含属性类型的精度。该精度表明了有效数字的位数。
   它可以用在十进制（base 10）或者二进制（base 2）中，按照说明在字段
   <literal>numeric_precision_radix</literal>中。对于所有其它的数据类型，该字段为null。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个数字类型，该字段表明基于字段
   <literal>numeric_precision</literal>和字段<literal>numeric_scale</literal>中的值。
   值要么是2要么是10. 对于所有其它的数据类型，字段是null。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this attribute.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个精确的数字类型，那么该字段
   （公开地或隐含地）包含属性类型的数值范围。该数值范围表明了小数点右边有效数字位数。
   它可以用在十进制(base 10)或者二进制(base 2)中，详细说明在字段
   <literal>numeric_precision_radix</literal>中。对于所有其它的数据类型，该字段为null。 
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       attribute, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个日期，时间，时间戳，或者间隔类型，
   该字段（公开地或隐含地）包含属性类型的精确到小数部分的秒，就是说，
   秒的值小数位数保持到小数点后面。对于所有其它的数据类型，该字段是null。 
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this attribute, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null. 
   -->
   如果<literal>data_type</literal>标识一个间隔类型，
   该字段包含为这个属性包含的字段的时间间隔说明，例如，
   <literal>YEAR TO MONTH</literal>, <literal>DAY TO SECOND</literal>等等。
   如果没有声明字段限制（也就是，间隔接受所有字段），和对所有其他数据类型，该字段都是null。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type attributes) 
   -->
   在<productname>PostgreSQL</>中的不适用特性
   （参阅<literal>datetime_precision</literal>获取间隔类型属性的小数秒精度）
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the attribute data type is defined in
       (always the current database) 
   -->
   属性数据类型被指定的数据库名（总是在当前数据库中） 
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that the attribute data type is defined in 
   -->
   属性数据类型被指定的模式名称 
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the attribute data type 
   -->
   属性数据类型名称 
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry> 
  -->
  <entry>总是null，因为在<productname>PostgreSQL</>中数组的最大基数总是不受限</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.) 
   -->
   字段的数据类型描述符的一个标示符，在表格的数据类型描述符中是唯一的。
   这个对于加入其它的这样的标示符的实例是主要有用的。
   （标示符的特定格式没有指定且也不保证在以后的版本中不会改变） 
      </entry>
     </row>

     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>在<productname>PostgreSQL</>中的不适用特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   See also under <xref linkend="infoschema-columns">, a similarly
   structured view, for further information on some of the columns.
  </para>
-->
<para>
也可以在<xref linkend="infoschema-columns">中查阅，一个类似的结构视图，一些字段的进一步详细信息。 
</para>
 </sect1>

 <sect1 id="infoschema-character-sets">
  <title><literal>character_sets</literal></title>

  <!--
<para>
   The view <literal>character_sets</literal> identifies the character
   sets available in the current database.  Since PostgreSQL does not
   support multiple character sets within one database, this view only
   shows one, which is the database encoding.
  </para>
-->
<para>
视图<literal>character_sets</literal>标识在当前数据库中可用的字符集。
因为PostgreSQL不支持在一个数据库中有多个字符集，所以这个视图只能显示一个，
也就是数据库编码。
</para>
  
<para>
   <!-- 
   Take note of how the following terms are used in the SQL standard: 
   -->
   请注意下列条目在SQL标准中是怎样使用的：
   <variablelist>
    <varlistentry>
     <!-- 
 <term>character repertoire</term> 
 -->
 <term>字符指令系统</term>
     <listitem>
<!--
      <para>
       An abstract collection of characters, for
       example <literal>UNICODE</literal>, <literal>UCS</literal>, or
       <literal>LATIN1</literal>.  Not exposed as an SQL object, but
       visible in this view.
      </para>
-->
<para>
一个概要的字符集合，例如<literal>UNICODE</literal>, <literal>UCS</literal>,
或<literal>LATIN1</literal>。不是作为一个SQL对象公开的，但是在这个视图中可见。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!-- 
 <term>character encoding form</term> 
 -->
 <term>字符编码形式</term>
     <listitem>
      <!--
<para>
       An encoding of some character repertoire.  Most older character
       repertoires only use one encoding form, and so there are no
       separate names for them (e.g., <literal>LATIN1</literal> is an
       encoding form applicable to the <literal>LATIN1</literal>
       repertoire).  But for example Unicode has the encoding forms
       <literal>UTF8</literal>, <literal>UTF16</literal>, etc. (not
       all supported by PostgreSQL).  Encoding forms are not exposed
       as an SQL object, but are visible in this view.
      </para>
-->
<para>
一些字符指令系统的编码。大多数老旧的字符指令系统只使用一种编码形式，并且因此他们没有单独的名字
（例如<literal>LATIN1</literal>是一种适用于<literal>LATIN1</literal>指令系统的编码形式）。
但是例如Unicode有编码形式<literal>UTF8</literal>, <literal>UTF16</literal>等等。
（不是所有都被PostgreSQL支持）。编码形式不是作为SQL对象公开的，但是在这个视图中可见。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!-- 
 <term>character set</term> 
 -->
 <term>字符集</term>
     <listitem>
      <!--
<para>
       A named SQL object that identifies a character repertoire, a
       character encoding, and a default collation.  A predefined
       character set would typically have the same name as an encoding
       form, but users could define other names.  For example, the
       character set <literal>UTF8</literal> would typically identify
       the character repertoire <literal>UCS</literal>, encoding
       form <literal>UTF8</literal>, and some default collation.
      </para>
-->
<para>
一个标志字符指令系统的命名的SQL对象，一种字符编码，和一个缺省的排序规则。
一个预定义的字符集通常和编码形式有相同的名称，但是用户可以定义其他名称。
例如，字符集<literal>UTF8</literal>通常识别字符指令系统<literal>UCS</literal>，
编码形式<literal>UTF8</literal>和一些缺省的排序规则。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
<!-- 
   You can think of an <quote>encoding</quote> in PostgreSQL either as
   a character set or a character encoding form.  They will have the
   same name, and there can only be one in one database.
-->
你可以认为PostgreSQL中的一个<quote>encoding</quote>是一个字符集或一种字符编码形式。
他们将有相同的名称，并且在一个数据库中只能有一个。
  </para>

  <table>
   <!-- 
   <title><literal>character_sets</literal> Columns</title> 
   -->
   <title><literal>character_sets</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
     <!-- 
 <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
   <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Character sets are currently not implemented as schema objects, so this column is null.</entry> 
  -->
  <entry>字符集当前还没有作为模式对象实现，所以这个字段是null。</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Character sets are currently not implemented as schema objects, so this column is null.</entry> 
  -->
  <entry>字符集当前还没有作为模式对象实现，所以这个字段是null。</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the character set, currently implemented as showing the name of the database encoding</entry> 
  -->
  <entry>字符集的名称，目前是作为数据库编码的显示名称实现的。</entry>
     </row>

     <row>
      <entry><literal>character_repertoire</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Character repertoire, showing <literal>UCS</literal> if the encoding is <literal>UTF8</literal>, else just the encoding name</entry>
  -->
  <entry>字符系统指令，如果编码是<literal>UTF8</literal>则显示<literal>UCS</literal>，否则只显示编码名称</entry>
     </row>

     <row>
      <entry><literal>form_of_use</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Character encoding form, same as the database encoding</entry> 
  -->
  <entry>字符编码形式，和数据库编码相同</entry>
     </row>

     <row>
      <entry><literal>default_collate_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the default collation (always the current database, if any collation is identified)</entry>
  -->
  <entry>包含缺省排序规则的数据库名（总是当前数据库，如果指定了任意排序规则）</entry>
     </row>

     <row>
      <entry><literal>default_collate_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the default collation</entry> 
  -->
  <entry>包含缺省排序规则的模式名</entry>
     </row>

     <row>
      <entry><literal>default_collate_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!-- 
   Name of the default collation.  The default collation is
       identified as the collation that matches
       the <literal>COLLATE</literal> and <literal>CTYPE</literal>
       settings of the current database.  If there is no such
       collation, then this column and the associated schema and
       catalog columns are null. 
   -->
   缺省排序规则名。缺省排序规则指定为匹配<literal>COLLATE</literal>和<literal>CTYPE</literal>
   当前数据库设置的规则。如果没有这种规则，那么这个字段和相关的模式和目录字段为null。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <!--
<para>
   The view <literal>check_constraint_routine_usage</literal>
   identifies routines (functions and procedures) that are used by a
   check constraint.  Only those routines are shown that are owned by
   a currently enabled role.
  </para>
-->
<para>
视图<literal>check_constraint_routine_usage</literal>标识被一个检查约束条件使用的日常活动
（函数和程序）。只有那些属于当前启用角色的日常活动被显示。 
</para>

  <table>
   <!-- 
   <title><literal>check_constraint_routine_usage</literal> Columns</title> 
   -->
   <title><literal>check_constraint_routine_usage</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the constraint (always the current database)</entry> 
  -->
  <entry>包含该约束的数据库名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the constraint</entry> 
  -->
  <entry>包含该约束的模式名字</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the constraint</entry> 
  -->
  <entry>约束的名字</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the function (always the current database)</entry> 
  -->
  <entry>包含函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the function</entry> 
  -->
  <entry>包含函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!-- 
   The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information.
   -->
   函数的<quote>专用名</quote>。参阅<xref linkend="infoschema-routines">获取详细信息。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <!--
<para>
   The view <literal>check_constraints</literal> contains all check
   constraints, either defined on a table or on a domain, that are
   owned by a currently enabled role.  (The owner of the table or
   domain is the owner of the constraint.)
  </para>
-->
<para>
视图<literal>check_constraints</literal>包含所有当前用户拥有的检查约束，
可能是定义在表上的，也可能是定义在域上的。（表或者域的所有者就是约束的所有者。）
</para>

  <table>
   <!-- 
   <title><literal>check_constraints</literal> Columns</title> 
   -->
   <title><literal>check_constraints</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the constraint (always the current database)</entry> 
  -->
  <entry>包含此约束的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the constraint</entry> 
  -->
  <entry>包含此约束的模式的名字</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the constraint</entry> 
  -->
  <entry>约束的名字</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <!-- 
  <entry>The check expression of the check constraint</entry> 
  -->
  <entry>检查约束的检查表达式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
  <title><literal>collations</literal></title>

  <!--
<para>
   The view <literal>collations</literal> contains the collations
   available in the current database.
  </para>
-->
<para>
视图<literal>collations</literal>包含当前数据库可用的排序规则。
</para>

  <table>
   <!-- 
   <title><literal>collations</literal> Columns</title> 
   -->
   <title><literal>collations</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
     <!-- 
 <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
   <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the collation (always the current database)</entry> 
  -->
  <entry>包含该排序规则的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the collation</entry> 
  -->
  <entry>包含该排序规则的模式的名字</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the default collation</entry> 
  -->
  <entry>缺省排序规则的名字</entry>
     </row>

     <row>
      <entry><literal>pad_attribute</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       <!-- 
   Always <literal>NO PAD</literal> (The alternative <literal>PAD
       SPACE</literal> is not supported by PostgreSQL.) 
   -->
   总是<literal>NO PAD</literal>（PostgreSQL不支持可替代的<literal>PAD SPACE</literal>。）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab"> <!-- max 44 characters -->
  <title><literal>collation_character_set_applicability</literal></title>

  <!--
<para>
   The view <literal>collation_character_set_applicability</literal>
   identifies which character set the available collations are
   applicable to.  In PostgreSQL, there is only one character set per
   database (see explanation
   in <xref linkend="infoschema-character-sets">), so this view does
   not provide much useful information.
  </para>
-->
<para>
视图<literal>collation_character_set_applicability</literal>指定可用的排序规则适用于哪个字符集。
在PostgreSQL中，每个数据库只有一个字符集（参阅<xref linkend="infoschema-character-sets">里面的说明），
所以该视图并不提供多少有用的信息。
</para>

  <table>
   <!-- 
   <title><literal>collation_character_set_applicability</literal> Columns</title> 
   -->
   <title><literal>collation_character_set_applicability</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the collation (always the current database)</entry> 
  -->
  <entry>包含该排序规则的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the collation</entry> 
  -->
  <entry>包含该排序规则的模式的名字</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the default collation</entry> 
  -->
  <entry>缺省排序规则的名字</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Character sets are currently not implemented as schema objects, so this column is null</entry>
  -->
  <entry>字符集当前没有作为模式对象实现，所以这个字段是null。</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Character sets are currently not implemented as schema objects, so this column is null</entry>
  -->
  <entry>字符集当前没有作为模式对象实现，所以这个字段是null。</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the character set</entry>
  -->
  <entry>字符集的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <!--
<para>
   The view <literal>column_domain_usage</literal> identifies all
   columns (of a table or a view) that make use of some domain defined
   in the current database and owned by a currently enabled role.
  </para>
-->
<para>
视图<literal>column_domain_usage</literal>标识所有使用了一些域的字段（表或者视图的），
这些域是在当前数据库中定义的并且是当前用户拥有的。
</para>

  <table>
   <!-- 
   <title><literal>column_domain_usage</literal> Columns</title> 
   -->
   <title><literal>column_domain_usage</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the domain (always the current database)</entry> 
  -->
  <entry>包含该域的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the domain</entry> 
  -->
  <entry>包含该域的模式的名字</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain</entry> 
  -->
  <entry>该域的名字</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the table (always the current database)</entry> 
  -->
  <entry>包含该表的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the table</entry> 
  -->
  <entry>包含此表的模式名字</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table</entry> 
  -->
  <entry>表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the column</entry> 
  -->
  <entry>字段的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
  <title><literal>column_options</literal></title>

  <!--
<para>
   The view <literal>column_options</literal> contains all the
   options defined for foreign table columns in the current database.  Only
   those foreign table columns are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>column_options</literal>包含所有在当前数据库中为外表字段定义的选项。
当前用户登录后只显示这些外表字段（通过成为所有者或拥有某些权限）。
</para>

  <table>
   <!-- 
   <title><literal>column_options</literal> Columns</title> 
   -->
   <title><literal>column_options</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the foreign table (always the current database)</entry> 
  -->
  <entry>包含该外表的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the foreign table</entry> 
  -->
  <entry>包含该外表的模式的名字</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign table</entry> 
  -->
  <entry>外表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the column</entry> 
  -->
  <entry>字段的名字</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of an option</entry> 
  -->
  <entry>选项的名字</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Value of the option</entry> 
  -->
  <entry>选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <!--
<para>
   The view <literal>column_privileges</literal> identifies all
   privileges granted on columns to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of
   column, grantor, and grantee.
  </para>
-->
<para>
视图<literal>column_privileges</literal>标出所有在当前用户的字段上赋予的权限或者当前用户赋予的字段的权限。
每个字段、授权人和被赋予权利的用户组成一行。
</para>

  <!--
<para>
   If a privilege has been granted on an entire table, it will show up in
   this view as a grant for each column, but only for the
   privilege types where column granularity is possible:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>
-->
<para>
如果权限被赋予整个表，它将在这个视图中显示为每一个字段赋权，但是它只为字段粒度有意义的权限类型：
<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>REFERENCES</literal>。
</para>

  <table>
   <!-- 
   <title><literal>column_privileges</literal> Columns</title> 
   -->
   <title><literal>column_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>赋予权限的用户的名字</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that the privilege was granted to</entry> 
  -->
  <entry>被赋予权限的用户的名字</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
  -->
  <entry>包含该字段的表所在的数据库名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the table that contains the column</entry> 
  -->
  <entry>包含该字段的表所在的模式的名字</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table that contains the column</entry> 
  -->
  <entry>包含该字段的表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the column</entry> 
  -->
  <entry>该字段的名字</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal> 
   -->
   权限类型：<literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, 或者 <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可以赋予，为<literal>YES</literal> ，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <!--
<para>
   The view <literal>column_udt_usage</literal> identifies all columns
   that use data types owned by a currently enabled role.  Note that in
   <productname>PostgreSQL</productname>, built-in data types behave
   like user-defined types, so they are included here as well.  See
   also <xref linkend="infoschema-columns"> for details.
  </para>
-->
<para>
视图<literal>column_udt_usage</literal>标出所有使用属于当前用户的数据类型的字段。
请注意，在<productname>PostgreSQL</productname>里，内置的数据类型的行为和用户定义的类型相似，
因此它们也在这里包括进来了。参阅<xref linkend="infoschema-columns">获取细节。 
</para>

  <table>
   <!-- 
   <title><literal>column_udt_usage</literal> Columns</title> 
   -->
   <title><literal>column_udt_usage</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database) 
   -->
   这个字段数据类型（如果适用，就是域的基础类型）定义所在的数据库名字（总是当前数据库）。 
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in 
   -->
   字段数据类型（如果适用，就是域的基础类型）定义所在的模式名字。 
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the column data type (the underlying type of the
       domain, if applicable) 
   -->
   字段数据类型的名称（如果适用，就是域的基础类型）
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the table (always the current database)</entry> 
  -->
  <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the table</entry>
  -->
  <entry>包含该表的模式的名称</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table</entry> 
  -->
  <entry>表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the column</entry> 
  -->
  <entry>字段的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <!--
<para>
   The view <literal>columns</literal> contains information about all
   table columns (or view columns) in the database.  System columns
   (<literal>oid</>, etc.) are not included.  Only those columns are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>
-->
<para>
视图<literal>columns</literal>包含有关数据库中所有表字段（或者视图字段）的信息。
不包括系统字段（比如<literal>oid</>等）。只有那些当前用户有权访问的字段才会显示出来
（要么是所有者，要么是有些权限）。 
</para>

  <table>
  <!-- 
  <title><literal>columns</literal> Columns</title> 
  -->
   <title><literal>columns</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the table (always the current database)</entry> 
  -->
  <entry>包含表的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the table</entry> 
  -->
  <entry>包含表的模式的名字</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table</entry> 
  -->
  <entry>表的名字</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the column</entry> 
  -->
  <entry>字段的名字</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Ordinal position of the column within the table (count starts at 1)</entry> 
  -->
  <entry>字段在表中的位置序号（从 1 开始）</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Default expression of the column</entry> 
  -->
  <entry>字段的缺省表达式</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the column is possibly nullable,
       <literal>NO</literal> if it is known not nullable.  A not-null
       constraint is one way a column can be known not nullable, but
       there can be others. 
   -->
   如果字段可能为空，则为<literal>YES</literal>，如果知道它不能为空，则为<literal>NO</literal>。
   非空约束是我们得知字段不能为空的一个手段，但是还可能有其它的。 
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Data type of the column, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).  If the column is based on a domain, this column
       refers to the type underlying the domain (and the domain is
       identified in <literal>domain_name</literal> and associated
       columns). 
   -->
   如果它是一个内置类型，那么为字段的数据类型，如果它是某种数组，
   则为<literal>ARRAY</literal>（在这种情况下，参阅视图<literal>element_types</literal>），
   否则就是<literal>USER-DEFINED</literal>（这时，类型定义在<literal>udt_name</literal>和相关的字段上）。
   如果字段基于域，这个字段引用底层域类型（而域是在<literal>domain_name</literal>和相关字段里定义的）。 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared. 
   -->
   如果<literal>data_type</literal>标识一个字符或者位串类型，那么就是声明的最大长度；
   如果是其它类型或者没有定义最大长度，就是空。
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding. 
   -->
   如果<literal>data_type</literal>标识一个字符类型，就是以字节记的最大可能长度；
   所有其它类型都是空。最大字节长度取决于声明的字节最大长度（见上文）和服务器编码。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this column.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个数值类型，这个字段包含
   （声明的或隐含的）这个字段的数据类型的精度。精度表示有效小数位的长度。
   它可以用十进制或者二进制来表示，这一点在<literal>numeric_precision_radix</literal>
   字段里声明。对于其它数据类型，这个字段是空。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个数值类型，这个字段标识字段
   <literal>numeric_precision</literal>和<literal>numeric_scale</literal>
   里的数据是多少进制的。值要么是 2 要么是 10。对于所有其它数据类型，这个字段是空。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this column.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个精确的数值类型，
   那么这个字段包含（声明的或者隐含的）这个字段上这个类型的数值范围。
   数值范围表明小数点右边的有效小数位的数目。它可以用十进制（10为基）
   或者二进制（二为基）来表示，正如字段<literal>numeric_precision_radix</literal>
   声明的那样。对于所有其它数据类型，这个字段是空。
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       column, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个日期，时间，时间戳，或者间隔类型，
   该字段（公开地或隐含地）包含该字段类型的小数秒精度，就是说，
   小数位数保持到小数点后面。对于所有其它的数据类型，该字段是null。 
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this column, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null. 
   -->
   如果<literal>data_type</literal>标识一个间隔类型，这个字段包含这个字段时间间隔声明，
   例如，<literal>YEAR TO MONTH</literal>, <literal>DAY TO SECOND</literal>等等。
   如果没有指定字段限制（也就是，间隔接受所有字段），或对于所有其他数据类型，这个字段是null。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type columns) 
   -->
   用于一个<productname>PostgreSQL</productname>不可用的特性
   （参阅<literal>datetime_precision</literal>获取间隔类型字段的小数秒精度）
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database containing the collation of the column
       (always the current database), null if default or the data type
       of the column is not collatable 
   -->
   包含该字段的排序规则的数据库的名字（总是当前数据库），缺省或者字段的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema containing the collation of the column, null
       if default or the data type of the column is not collatable 
   -->
   包含该字段的排序规则的模式的名字，缺省或者字段的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the collation of the column, null if default or the
       data type of the column is not collatable 
   -->
   字段的排序规则的名字，缺省或者字段的数据类型不可排序时为null。
      </entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   If the column has a domain type, the name of the database that
       the domain is defined in (always the current database), else
       null. 
   -->
   如果字段是域类型，就是该域定义所在的数据库的名字（总是当前数据库），否则为null。
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   If the column has a domain type, the name of the schema that
       the domain is defined in, else null. 
   -->
   如果字段是域类型，就是域定义所在的模式的名字，否则为null。
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>If the column has a domain type, the name of the domain, else null.</entry> 
  -->
  <entry>如果字段是域类型，就是该域的名字，否则为null。</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database) 
   -->
   这个字段数据类型（如果适用，就是底层域类型）定义所在的数据库的名字（总是当前数据库）。 
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in 
   -->
   这个字段数据类型（如果适用，就是底层域类型）定义所在的模式名字。 
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the column data type (the underlying type of the
       domain, if applicable) 
   -->
   这个字段数据类型（如果适用，就是底层域类型）的名字。 
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为在<productname>PostgreSQL</>里数组总是有无限的最大维数 </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.) 
   -->
   一个该字段的数据类型描述符的标识符，在属于这个表中的所有的数据类型描述符中唯一。
   这个字段主要用于和其它这样的标识符实例连接。
   （这个标识符的确切格式没有定义并且不保证在将来的版本中保持一样。） 
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the column is updatable,
       <literal>NO</literal> if not (Columns in base tables are always
       updatable, columns in views not necessarily) 
   -->
   如果字段为可更新则为<literal>YES</literal>，否则为<literal>NO</literal>
   （基表中的字段总是可以更新的，而试图中的字段则不一定） 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Since data types can be defined in a variety of ways in SQL, and
   <productname>PostgreSQL</productname> contains additional ways to
   define data types, their representation in the information schema
   can be somewhat difficult.  The column <literal>data_type</literal>
   is supposed to identify the underlying built-in type of the column.
   In <productname>PostgreSQL</productname>, this means that the type
   is defined in the system catalog schema
   <literal>pg_catalog</literal>.  This column might be useful if the
   application can handle the well-known built-in types specially (for
   example, format the numeric types differently or use the data in
   the precision columns).  The columns <literal>udt_name</literal>,
   <literal>udt_schema</literal>, and <literal>udt_catalog</literal>
   always identify the underlying data type of the column, even if the
   column is based on a domain.  (Since
   <productname>PostgreSQL</productname> treats built-in types like
   user-defined types, built-in types appear here as well.  This is an
   extension of the SQL standard.)  These columns should be used if an
   application wants to process data differently according to the
   type, because in that case it wouldn't matter if the column is
   really based on a domain.  If the column is based on a domain, the
   identity of the domain is stored in the columns
   <literal>domain_name</literal>, <literal>domain_schema</literal>,
   and <literal>domain_catalog</literal>.  If you want to pair up
   columns with their associated data types and treat domains as
   separate types, you could write <literal>coalesce(domain_name,
   udt_name)</literal>, etc.
  </para>
-->
<para>
因为数据类型在SQL里可以用多种方法定义，并且<productname>PostgreSQL</productname>包含额外的定义数据类型的方法，
因此他们在信息模式里的表现形式可能不太一样。字段<literal>data_type</literal>
会被用于标识该字段底层的内置数据类型。在<productname>PostgreSQL</productname>里，
这意味着类型将定义在系统表模式<literal>pg_catalog</literal>里。如果应用可以很好地处理那些重要的内置类型
（比如，对数值类型格式化成不同的东西，或者使用在精度字段里的数据），那么这个字段是有用的。
字段<literal>udt_name</literal>, <literal>udt_schema</literal>, 和 <literal>udt_catalog</literal>
总是标识该字段的底层数据类型，即使字段是基于域的也一样。（因为<productname>PostgreSQL</productname>
把内置类型看作和用户定义类型一样，所以，内置类型也在这里出现。这是对SQL标准的一个扩展。）
如果一个应用想根据数据类型的不同而区别处理数据，那么应该使用这些字段，
因为在这种情况下它不会在意这个字段是否真正基于域的。如果这个字段基于一个域，
那么该域的标识保存在字段<literal>domain_name</literal>, <literal>domain_schema</literal>,
和<literal>domain_catalog</literal>里。如果你想把字段和他们相关的数据类型凑成对儿，
并且把域当作不同的类型处理， 你可以这么写<literal>coalesce(domain_name,udt_name)</literal>等等。 
</para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <!--
<para>
   The view <literal>constraint_column_usage</literal> identifies all
   columns in the current database that are used by some constraint.
   Only those columns are shown that are contained in a table owned by
   a currently enabled role.  For a check constraint, this view
   identifies the columns that are used in the check expression.  For
   a foreign key constraint, this view identifies the columns that the
   foreign key references.  For a unique or primary key constraint,
   this view identifies the constrained columns.
  </para>
-->
<para>
视图<literal>constraint_column_usage</literal>标识在当前数据库中使用了某种约束的所有字段。
只有那些属于当前用户的表中的字段才会被显示出来。对于检查约束，这个视图标识用在检查表达式里的字段。
对于外键约束，这个视图标识外键引用的字段。对于唯一或主键约束，这个视图标识被约束的字段。 
</para>

  <table>
   <title><literal>constraint_column_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that contains the table that contains the
       column that is used by some constraint (always the current
       database) 
   -->
   被某个（些）约束使用的字段所在的表所在的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that contains the table that contains the
       column that is used by some constraint 
   -->
   被某个（些）约束使用的字段所在的表所在的模式名 
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the table that contains the column that is used by some
       constraint 
   -->
   被某个（些）约束使用的字段所在的表名 
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the column that is used by some constraint
   -->
   被某个（些）约束使用的字段名 
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the constraint (always the current database)</entry> 
  -->
  <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the constraint</entry> 
  -->
  <entry>包含该约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the constraint</entry> 
  -->
  <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <!--
<para>
   The view <literal>constraint_table_usage</literal> identifies all
   tables in the current database that are used by some constraint and
   are owned by a currently enabled role.  (This is different from the
   view <literal>table_constraints</literal>, which identifies all
   table constraints along with the table they are defined on.)  For a
   foreign key constraint, this view identifies the table that the
   foreign key references.  For a unique or primary key constraint,
   this view simply identifies the table the constraint belongs to.
   Check constraints and not-null constraints are not included in this
   view.
  </para>
-->
<para>
视图<literal>constraint_table_usage</literal>标识当前数据库中被某些约束使用并且被当前用户拥有的所有表。
（它和视图<literal>table_constraints</literal>不同，这个视图标识所有约束以及他们定义所在的表。）
对于一个外键约束，这个事务标识外键引用的表。对于唯一或者主键约束，这个视图只是简单标识这个约束所属的表。
检查约束和非空约束没有包含在这个视图中。 
</para>

  <table>
   <!-- 
   <title><literal>constraint_table_usage</literal> Columns</title> 
   -->
   <title><literal>constraint_table_usage</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that contains the table that is used by
       some constraint (always the current database) 
   -->
   包含被某些约束使用的表的数据库名（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that contains the table that is used by some
       constraint 
   -->
   包含被某些约束使用的表的模式的字 
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table that is used by some constraint</entry> 
  -->
  <entry>被某些约束使用的表名</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the constraint (always the current database)</entry> 
  -->
  <entry>包含该约束的数据库名（总是当前数据库） </entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the constraint</entry> 
  -->
  <entry>包含约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the constraint</entry>
  -->
  <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <!--
<para>
   The view <literal>data_type_privileges</literal> identifies all
   data type descriptors that the current user has access to, by way
   of being the owner of the described object or having some privilege
   for it.  A data type descriptor is generated whenever a data type
   is used in the definition of a table column, a domain, or a
   function (as parameter or return type) and stores some information
   about how the data type is used in that instance (for example, the
   declared maximum length, if applicable).  Each data type
   descriptor is assigned an arbitrary identifier that is unique
   among the data type descriptor identifiers assigned for one object
   (table, domain, function).  This view is probably not useful for
   applications, but it is used to define some other views in the
   information schema.
  </para>
-->
<para>
视图<literal>data_type_privileges</literal>标识当前用户可访问的所有数据类型描述符，
只要他是被描述对象的所有者或者有某些权限。一个数据类型描述符是在一种数据类型用在表字段，
域，或者函数（参数或者返回类型）定义的时候生成的，它包含一些有关这个数据类型在该实例中如何使用的信息
（比如，声明的最大长度——如果有的话）。每种数据类型描述符都赋予了一个任意的标识符，
这个标识符在赋予某个对象 （表，域，函数）的所有数据类型描述符标识符中唯一。
这个视图可能对应用没什么用，但是用于在信息模式中定义一些其它的视图。
</para>

  <table>
   <!-- 
   <title><literal>data_type_privileges</literal> Columns</title> 
   -->
   <title><literal>data_type_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the described object (always the current database)</entry> 
  -->
  <entry>包含被描述的对象的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the described object</entry> 
  -->
  <entry>包含被描述对象的模式名</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the described object</entry> 
  -->
  <entry>被描述对象的名字</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The type of the described object: one of
       <literal>TABLE</literal> (the data type descriptor pertains to
       a column of that table), <literal>DOMAIN</literal> (the data
       type descriptors pertains to that domain),
       <literal>ROUTINE</literal> (the data type descriptor pertains
       to a parameter or the return data type of that function). 
   -->
   被描述对象的类型：<literal>TABLE</literal>（数据类型描述符属于该表的一个字段），
   <literal>DOMAIN</literal>数据类型描述符属于该域），<literal>ROUTINE</literal>
   （数据类型描述符属于该函数的一个参数或者返回的数据类型）之一。 
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The identifier of the data type descriptor, which is unique
       among the data type descriptors for that same object. 
   -->
   这个数据类型描述符的标识符，在用于同一个对象上的所有数据类型描述符中是唯一的。 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <!--
<para>
   The view <literal>domain_constraints</literal> contains all constraints
   belonging to domains defined in the current database.  Only those domains
   are shown that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
-->
<para>
视图<literal>domain_constraints</literal>包含属于所有在当前数据库中定义的域的约束。 
只有当前用户有权访问的域才显示（通过成为其所有者或有某些权限）。
</para>

  <table>
   <!-- 
   <title><literal>domain_constraints</literal> Columns</title>
   -->
   <title><literal>domain_constraints</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
     <!-- 
 <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
   <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the constraint (always the current database)</entry> 
  -->
  <entry>包含此约束的数据库名（总是当前数据库） </entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the constraint</entry> 
  -->
  <entry>包含此约束的模式名</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the constraint</entry> 
  -->
  <entry>约束名</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the domain (always the current database)</entry> 
  -->
  <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the domain</entry> 
  -->
  <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain</entry> 
  -->
  <entry>域名</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry> 
  -->
  <entry>如果约束可以推迟，则为<literal>YES</literal>，如果不行，则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
  -->
  <entry>如果约束可以推迟，且为初始推迟，则为<literal>YES</literal>，否则为<literal>NO</literal>。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <!--
<para>
   The view <literal>domain_udt_usage</literal> identifies all domains
   that are based on data types owned by a currently enabled role.
   Note that in <productname>PostgreSQL</productname>, built-in data
   types behave like user-defined types, so they are included here as
   well.
  </para>
-->
<para>
视图<literal>domain_udt_usage</literal>标识所有使用当前用户拥有的数据类型的域。
请注意，在<productname>PostgreSQL</productname>里，内置数据类型的行为和用户定义的类型一样，
因此它们也在这里包含。
</para>

  <table>
   <!-- 
   <title><literal>domain_udt_usage</literal> Columns</title> 
   -->
   <title><literal>domain_udt_usage</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
  -->
  <entry>该域数据类型定义所在的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that the domain data type is defined in</entry> 
  -->
  <entry>这个域数据类型定义所在的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain data type</entry> 
  -->
  <entry>域数据类型名</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the domain (always the current database)</entry> 
  -->
  <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the domain</entry> 
  -->
  <entry>包含该域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain</entry> 
  -->
  <entry>域名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <!--
<para>
   The view <literal>domains</literal> contains all domains defined in the
   current database.  Only those domains are shown that the current user has
   access to (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>domains</literal>包含定义在当前数据库中的所有域。
只有当前用户有权访问的域才显示（通过成为其所有者或有某些权限）。
</para>

  <table>
   <!-- 
   <title><literal>domains</literal> Columns</title> 
   -->
   <title><literal>domains</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the domain (always the current database)</entry>
  -->
  <entry>包含这个域的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the domain</entry> 
  -->
  <entry>包含这个域的模式名</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain</entry> 
  -->
  <entry>域的名字</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Data type of the domain, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
   -->
   如果这是一个内置类型，就是域的数据类型，如果他是某种数组（这时，
   参阅视图<literal>element_types</literal>），就是<literal>ARRAY</literal>。
   否则是<literal>USER-DEFINED</literal>（这个时候，类型在<literal>udt_name</literal>
   和相关的字段里面标识。） 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      <!-- 
  If the domain has a character or bit string type, the declared
       maximum length; null for all other data types or if no maximum
       length was declared. 
   -->
   如果域是一个字符或者位串类型，这是定义的最大长度，其它数据类型或者没有声明最大长度，则为空。 
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If the domain has a character type, the maximum possible length
       in octets (bytes) of a datum; null for all other data types.
       The maximum octet length depends on the declared character
       maximum length (see above) and the server encoding. 
   -->
   如果域有一个字符类型，这是最大可能的字节长度；其它所有的数据类型则为null。
   最大字节长度取决于所声明的字符最大长度（见上文）和服务器的编码。 
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>
       Name of the database containing the collation of the domain
       (always the current database), null if default or the data type
       of the domain is not collatable
      </entry> 
  -->
  <entry>包含域的排序规则的数据库的名字（总是当前数据库），如果缺省或域的数据类型不可排序则为null。</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>
       Name of the schema containing the collation of the domain, null
       if default or the data type of the domain is not collatable
      </entry> 
  -->
  <entry>包含域的排序规则的模式的名字，如果缺省或域的数据类型不可排序则为null。</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>
       Name of the collation of the domain, null if default or the
       data type of the domain is not collatable
      </entry> 
  -->
  <entry>域的排序规则的名字，如果缺省或者域的数据类型不可排序则为null。</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If the domain has a numeric type, this column contains the
       (declared or implicit) precision of the type for this domain.
       The precision indicates the number of significant digits.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      -->
  如果这个域有一个数值类型，那么这个字段包含（声明的或隐含的）用于这个字段的类型精度。
  精度表示有效数据位的个数。可以用十进制表示，也可以用二进制表示，就像在<literal>numeric_precision_radix</literal>
  字段里声明的那样。对于所有其它类型，这个字段是空。 
  </entry>   
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If the domain has a numeric type, this column indicates in
       which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null. 
   -->
   如果这个域有一个数值类型，那么这个字段标识<literal>numeric_precision</literal>和
   <literal>numeric_scale</literal>字段的数值的基数是多少。数值要么是 2 要么是 10。
   对于所有其它数据类型，这个字段是空。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      <!-- 
  If the domain has an exact numeric type, this column contains
       the (declared or implicit) scale of the type for this domain.
       The scale indicates the number of significant digits to the
       right of the decimal point.  It can be expressed in decimal
       (base 10) or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null. 
   -->
   如果这个域有一个准确的数值类型，那么这个字段包含（声明或者隐含的）本字段该类型的数值范围。
   数值范围标志着小数点右边的有效位数。它可以是用十进制表示，也可以用二进制表示，
   就像在<literal>numeric_precision_radix</literal>字段里声明的那样。对于所有其它数据类型，
   这个字段是空。
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       domain, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null. 
   -->
   如果<literal>data_type</literal>标识一个日期，时间，时间戳，或者间距类型，
   该字段（明确的或隐含地）包含部分的域类型秒精度，就是说，小数位数保持到小数点后面。
   对于所有其它的数据类型，该字段是null。 
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this domain, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null. 
   -->
   如果<literal>data_type</literal>标识间隔类型，这个字段包含这个领域包括的字段的时间间隔的声明，
   例如<literal>YEAR TO MONTH</literal>，<literal>DAY TO SECOND</literal>等等。
   如果没有声明字段限制（也就是，间隔接受所有字段），或是对于所有其他类型，这个字段为null。
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type domains) 
   -->
   适用于<productname>PostgreSQL</productname>里不可用的一个特性
   （参阅<literal>datetime_precision</literal>获取间隔类型域的小数秒精度）
      </entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Default expression of the domain</entry> 
  -->
  <entry>这个域的缺省表达式</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
  -->
  <entry>域数据类型定义所在的数据库名（总是当前数据库） </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that the domain data type is defined in</entry> 
  -->
  <entry>域数据类型定义所在的模式名</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the domain data type</entry> 
  -->
  <entry>域数据类型名</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
   <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
   <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry>
  -->
   <entry>总是为空，因为<productname>PostgreSQL</>的数组总是有无限的维数。</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   An identifier of the data type descriptor of the domain, unique
       among the data type descriptors pertaining to the domain (which
       is trivial, because a domain only contains one data type
       descriptor).  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.) 
   -->
   一个该域的数据类型描述符的标识符，在属于该域的所有数据类型描述符中是唯一的
   （这个是琐事，因为一个域只包含一种数据类型）。这个主要用于和其它这样的标识符实例连接。
   （这个标识符的具体格式没有定义，并且不保证在将来版本中保持一致。） 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  
<para>
<!--
   The view <literal>element_types</literal> contains the data type
   descriptors of the elements of arrays.  When a table column, composite-type attribute,
   domain, function parameter, or function return value is defined to
   be of an array type, the respective information schema view only
   contains <literal>ARRAY</literal> in the column
   <literal>data_type</literal>.  To obtain information on the element
   type of the array, you can join the respective view with this view.
   For example, to show the columns of a table with data types and
   array element types, if applicable, you could do:
-->
视图<literal>element_types</literal>包含数组元素的数据类型的描述符。在一个表字段，复合类型属性，域，
函数参数，或者函数返回值定义为一个数组类型的时候，对应的信息模式视图在字段<literal>data_type</literal>
里只包含<literal>ARRAY</literal>。要获取数组元素类型的信息，你可以将对应的视图和这个视图连接。
比如，要用数据类型和数组元素类型显示表的字段，（如果可能），你可以用：
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
<!-- 
   This view only includes objects that the current user has access
   to, by way of being the owner or having some privilege. 
-->
这个视图只包含当前用户具有权限访问的对象，通过成为其所有者或者有些权限。 
  </para>

  <table>
   <!-- 
   <title><literal>element_types</literal> Columns</title> 
   -->
   <title><literal>element_types</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that contains the object that uses the
       array being described (always the current database)
   -->
   使用了被描述的数组的对象所在的数据库名（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that contains the object that uses the array
       being described
   -->
   使用了被描述的数组的对象所在的模式名 
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the object that uses the array being described 
   -->
   使用了被描述的数组的对象的名字 
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The type of the object that uses the array being described: one
       of <literal>TABLE</literal> (the array is used by a column of
       that table), <literal>USER-DEFINED TYPE</literal> (the array is
       used by an attribute of that composite type),
       <literal>DOMAIN</literal> (the array is used by that domain),
       <literal>ROUTINE</literal> (the array is used by a parameter or
       the return data type of that function). 
   -->
   使用了被描述的数组的对象的类型：<literal>TABLE</literal>（数组被该表的一个字段使用），
   <literal>USER-DEFINED TYPE</literal>（数组被这个复合类型的属性使用），
   <literal>DOMAIN</literal>（数组被这个域使用），<literal>ROUTINE</literal>
   （数组被该函数的一个参数或者返回数据类型使用）之一。 
      </entry>
     </row>

     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The identifier of the data type descriptor of the array being
       described.  Use this to join with the
       <literal>dtd_identifier</literal> columns of other information
       schema views. 
   -->
   被描述的数组的数据类型描述符的标识符。使用它与其他信息模式视图的<literal>dtd_identifier</literal>
   字段连接。
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Data type of the array elements, if it is a built-in type, else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns). 
   -->
   如果这是一个内置的类型，数据元素的数据类型，否则就是<literal>USER-DEFINED</literal>
   （这种情况下，类型在<literal>udt_name</literal>和相关的字段中标出）。 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型。</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型。</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry> 
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry> 
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry> 
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database containing the collation of the element
       type (always the current database), null if default or the data
       type of the element is not collatable 
   -->
   包含元素类型的排序规则的数据库的名字（总是当前数据库），如果缺省或元素的数据类型不可排序则为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema containing the collation of the element
       type, null if default or the data type of the element is not
       collatable 
   -->
   包含元素类型的排序规则的模式的名字，如果缺省或元素的数据类型不可排序则为null。
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the collation of the element type, null if default or
       the data type of the element is not collatable
   -->
   元素类型的排序规则的名字，如果缺省或元素的数据类型不可排序则为null。
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Not yet implemented</entry> 
  -->
  <entry>未实现</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the data type of the elements is
       defined in (always the current database) 
   -->
   元素的数据类型定义所在的数据库名（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that the data type of the elements is
       defined in 
   -->
   元素的数据类型定义所在的模式名
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the data type of the elements 
   -->
   元素的数据类型名 
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>用于<productname>PostgreSQL</>里一个不可用的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空，因为这个信息并不适用于<productname>PostgreSQL</>里的数组元素数据类型</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   An identifier of the data type descriptor of the element.  This
       is currently not useful. 
   -->
   元素的数据类型描述符的标识符。目前没什么用处。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <!--
<para>
   The view <literal>enabled_roles</literal> identifies the currently
   <quote>enabled roles</quote>.  The enabled roles are recursively
   defined as the current user together with all roles that have been
   granted to the enabled roles with automatic inheritance.  In other
   words, these are all roles that the current user has direct or
   indirect, automatically inheriting membership in.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>
-->
<para>
视图<literal>enabled_roles</literal>标识当前 <quote>已授权角色</quote>。
授权的角色递归地被定义为当前用户和所有通过自动继承授权的角色。换句话说，
当前用户直接地或间接地，自动地继承成员权限。
<indexterm><primary>enabled role</primary></indexterm>
<indexterm><primary>role</primary><secondary>enabled</secondary></indexterm> 
</para>

  <!--
<para>
   For permission checking, the set of <quote>applicable roles</quote>
   is applied, which can be broader than the set of enabled roles.  So
   generally, it is better to use the view
   <literal>applicable_roles</literal> instead of this one; see also
   there.
  </para>
-->
<para>
对于权限的检查，<quote>可用角色</quote>的设置是比较实用的，可以比启用角色组更广泛。
所以通常，使用视图<literal>applicable_roles</literal>会更好一些。
</para>

  <table>
   <!-- 
   <title><literal>enabled_roles</literal> Columns</title>
   -->
   <title><literal>enabled_roles</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of a role</entry> 
  -->
  <entry>角色名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <!--
<para>
   The view <literal>foreign_data_wrapper_options</literal> contains
   all the options defined for foreign-data wrappers in the current
   database.  Only those foreign-data wrappers are shown that the
   current user has access to (by way of being the owner or having
   some privilege).
  </para>
-->
<para>
视图<literal>foreign_data_wrapper_options</literal>包含了当前数据库中为外部数据封装器定义的所有选项。
仅有那些当前用户有权访问的外部数据封装器才显示（通过成为所有者或者拥有一些权限来）。 
</para>

  <table>
   <!-- 
   <title><literal>foreign_data_wrapper_options</literal> Columns</title> 
   -->
   <title><literal>foreign_data_wrapper_options</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign-data wrapper is defined in (always the current database)</entry>
  -->
  <entry>定义外部数据封装器的数据库名称(总是在当前数据库)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the foreign-data wrapper</entry>
  -->
  <entry>外部数据封装器的名称</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of an option</entry> 
  -->
  <entry>选项名称</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Value of the option</entry>
  -->
  <entry>选项值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <!--
<para>
   The view <literal>foreign_data_wrappers</literal> contains all
   foreign-data wrappers defined in the current database.  Only those
   foreign-data wrappers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>foreign_data_wrappers</literal>包含所有定义在当前数据库中的外部数据封装器。
仅有那些当前用户有权访问外部数据封装器才显示（通过成为所有者或者拥有一些权限）。 
</para>

  <table>
   <!-- 
   <title><literal>foreign_data_wrappers</literal> Columns</title> 
   -->
   <title><literal>foreign_data_wrappers</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the foreign-data
      wrapper (always the current database)</entry>
  -->
  <entry>含有外部数据封装器的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign-data wrapper</entry> 
  -->
  <entry>外部数据封装器名称</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the owner of the foreign server</entry> 
  -->
  <entry>外部服务器所有者名称</entry>
     </row>

     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>File name of the library that implementing this foreign-data wrapper</entry> 
  -->
  <entry>执行外部数据封装器的库文件名</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Language used to implement this foreign-data wrapper</entry> 
  -->
  <entry>执行外部数据封装器所使用的语言</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <!--
<para>
   The view <literal>foreign_server_options</literal> contains all the
   options defined for foreign servers in the current database.  Only
   those foreign servers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>foreign_server_options</literal>包含了当前数据库中为外部服务器定义的所有选项。
仅有那些当前用户有权访问的外部服务器才显示（通过成为所有者或者拥有一些权限）。
</para>

  <table>
   <!-- 
   <title><literal>foreign_server_options</literal> Columns</title> 
   -->
   <title><literal>foreign_server_options</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
  -->
  <entry>定义外部服务器的数据库名称(总是当前数据库)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign server</entry>
  -->
  <entry>外部服务器名称</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of an option</entry> 
  -->
  <entry>选项名称</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Value of the option</entry> 
  -->
  <entry>选项值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <!--
<para>
   The view <literal>foreign_servers</literal> contains all foreign
   servers defined in the current database.  Only those foreign
   servers are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>foreign_servers</literal>包含了当前数据库中定义的所有外部服务器。
仅有那些当前用户有权访问的外部服务器才显示（通过成为所有者或者拥有一些权限）。 
</para>

  <table>
   <!-- 
   <title><literal>foreign_servers</literal> Columns</title> 
   -->
   <title><literal>foreign_servers</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
  -->
  <entry>定义外部服务器的数据库名称(总是当前数据库)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign server</entry> 
  -->
  <entry>外部服务器名称</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the foreign-data
      wrapper used by the foreign server (always the current database)</entry> 
  -->
  <entry>含有被外部服务器所使用的外部数据封装器的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign-data wrapper used by the foreign server</entry> 
  -->
  <entry>被外部服务器所使用的外部数据封装器名称</entry>
     </row>

     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Foreign server type information, if specified upon creation</entry> 
  -->
  <entry>外部服务器类型信息，如果在创建时指定</entry>
     </row>

     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Foreign server version information, if specified upon creation</entry> 
  -->
  <entry>外部服务器版本信息，如果在创建时指定</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the owner of the foreign server</entry> 
  -->
  <entry>外部服务器所有者名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
  <title><literal>foreign_table_options</literal></title>

  <!--
<para>
   The view <literal>foreign_table_options</literal> contains all the
   options defined for foreign tables in the current database.  Only
   those foreign tables are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>foreign_table_options</literal>包含所有在当前数据库中为外表定义的选项。
只有那些当前用户有权访问的外表才显示（通过成为所有者或有一些权限）。
</para>

  <table>
   <!-- 
   <title><literal>foreign_table_options</literal> Columns</title> 
   -->
   <title><literal>foreign_table_options</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the foreign table (always the current database)</entry> 
  -->
  <entry>包含该外表的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the foreign table</entry>
  -->
  <entry>包含该外表的模式的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign table</entry> 
  -->
  <entry>外表的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
  -->
  <entry>定义外部服务器的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign server</entry> 
  -->
  <entry>外部服务器的名字</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of an option</entry> 
  -->
  <entry>选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Value of the option</entry> 
  -->
  <entry>选项值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
  <title><literal>foreign_tables</literal></title>

  <!--
<para>
   The view <literal>foreign_tables</literal> contains all foreign
   tables defined in the current database.  Only those foreign
   tables are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>foreign_tables</literal>包含所有在当前数据库中定义的外表。
只有那些当前用户有权访问的外表才显示（通过成为所有者或有一些权限）。
</para>

  <table>
   <!-- 
   <title><literal>foreign_tables</literal> Columns</title> 
   -->
   <title><literal>foreign_tables</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that the foreign table is defined in (always the current database)</entry>
  -->
  <entry>定义外表的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the foreign table</entry> 
  -->
  <entry>包含外表的模式的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign table</entry> 
  -->
  <entry>外表的名字</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
  -->
  <entry>定义外部服务器的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
     <!-- 
 <entry>Name of the foreign server</entry>
 -->
  <entry>外部服务器的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <!--
<para>
   The view <literal>key_column_usage</literal> identifies all columns
   in the current database that are restricted by some unique, primary
   key, or foreign key constraint.  Check constraints are not included
   in this view.  Only those columns are shown that the current user
   has access to, by way of being the owner or having some privilege.
  </para>
-->
<para>
视图<literal>key_column_usage</literal>标出当前数据库中所有被某些唯一约束、
主键约束或者外键约束限制的字段。在这个视图里没有包含检查约束。
只有当前用户可以访问的那些字段才显示，通过成为所有者或有一些权限。
</para>

  <table>
   <!--
   <title><literal>key_column_usage</literal> Columns</title>
   -->
   <title><literal>key_column_usage</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the constraint (always the current database)</entry>
  -->
  <entry>包含这个约束的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the constraint</entry>
  -->
  <entry>包含这个约束的模式的名称</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the constraint</entry>
  -->
  <entry>约束的名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the database that contains the table that contains the
       column that is restricted by this constraint (always the
       current database)
   -->
   包含被这个约束限制着某个字段的表所在的数据库的名称（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the schema that contains the table that contains the
       column that is restricted by this constraint
   -->
   包含被这个约束限制着某个字段的表所在的模式的名称 
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the table that contains the column that is restricted
       by this constraint
   -->
   包含被这个约束限制着某个字段的表的名称 
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      <!-- 
  Name of the column that is restricted by this constraint
  -->
  被这个约束限制的字段的名称 
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!--
   Ordinal position of the column within the constraint key (count
       starts at 1)
   -->
   字段在约束键字里的位置序号（从 1 开始） 
      </entry>
     </row>

     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      <!-- 
  For a foreign-key constraint, ordinal position of the referenced
       column within its unique constraint (count starts at 1);
       otherwise null
   -->
   对于一个外键约束，唯一约束中引用行的顺序位置(从1开始)；否则为 null 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <!--
<para>
   The view <literal>parameters</literal> contains information about
   the parameters (arguments) of all functions in the current database.
   Only those functions are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>parameters</literal>包含有关当前数据库里所有函数的参数的信息。
只有当前用户有访问权限的函数才会在这里显示出来（用户要么是所有者，要么有些权限）。 
</para>

  <table>
   <title><literal>parameters</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the function (always the current database)</entry> 
  -->
  <entry>包含此函数的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含此函数的模式的名字</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information. 
   -->
   函数的<quote>specific name</quote>（具体名称）。
   参阅<xref linkend="infoschema-routines">获取更多信息。 
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   Ordinal position of the parameter in the argument list of the
       function (count starts at 1)
   -->
   参数在函数的参数列表里的位置序号（从 1 开始） 
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   <literal>IN</literal> for input parameter,
       <literal>OUT</literal> for output parameter,
       and <literal>INOUT</literal> for input/output parameter.
   -->
   <literal>IN</literal>用于输入的参数，<literal>OUT</literal>用于输出的参数，
   和<literal>INOUT</literal>用于输入输出的参数。 
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the parameter, or null if the parameter has no name</entry>
  -->
  <entry>参数名称，如果参数没有名称则为空</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      <!-- 
  Data type of the parameter, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns). 
   -->
   如果是内置类型，那么是参数的数据类型，如果它是某种数组就是<literal>ARRAY</literal>
   （这种情况下，参阅视图<literal>element_types</literal>），否则就是<literal>USER-DEFINED</literal>
   （这种情况下，该类型在<literal>udt_name</literal>和相关的字段中标出）。 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry> 
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
      -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
  </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the data type of the parameter is
       defined in (always the current database)
   -->
   该参数数据类型定义所在的数据库名称（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the schema that the data type of the parameter is
       defined in
   -->
   该参数数据类型定义所在的模式名称 
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the data type of the parameter
   -->
   参数的数据类型名称 
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry>
  -->
  <entry>总是空值，因为这个信息不适用于<productname>PostgreSQL</>里的参数数据类型</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   An identifier of the data type descriptor of the parameter,
       unique among the data type descriptors pertaining to the
       function.  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
   -->
   参数的数据类型描述符的标识符，在属于该函数的所有数据类型描述符中唯一。
   这个字段主要用于可以和这样的其它标识符实例进行连接。
   （这个标识符的具体格式没有在标准中定义，并且并不保证在将来的版本中保持一致。） 
      </entry>
     </row>
     <row>
      <entry><literal>parameter_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
<!--
       The default expression of the parameter, or null if none or if the
       function is not owned by a currently enabled role.
-->
该参数的缺省表达式，或者如果没有或该函数不被当前启用的角色所拥有则为null。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <!--
<para>
   The view <literal>referential_constraints</literal> contains all
   referential (foreign key) constraints in the current database.
   Only those constraints are shown for which the current user has
   write access to the referencing table (by way of being the
   owner or having some privilege other than <literal>SELECT</literal>).
  </para>
-->
<para>
视图<literal>referential_constraints</literal>包含当前数据库里的所有参考（外键）约束。 
只有当前用户有权访问的引用表里的约束才显示（通过成为所有者或有某些权限，而不是<literal>SELECT</literal>）。
</para>

  <table>
   <!-- 
   <title><literal>referential_constraints</literal> Columns</title>
   -->
   <title><literal>referential_constraints</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the database containing the constraint (always the current database)</entry>
  -->
  <entry>包含这个约束的数据库名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the schema containing the constraint</entry>
  -->
  <entry>包含这个约束的模式名字</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the constraint</entry>
  -->
  <entry>这个约束的名字</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!--
   Name of the database that contains the unique or primary key
       constraint that the foreign key constraint references (always
       the current database)
   -->
   包含该外键约束引用的唯一或者主键约束的数据库名称（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!-- 
   Name of the schema that contains the unique or primary key
       constraint that the foreign key constraint references
   -->
   该外键约束引用的唯一或者主键约束的模式的名称 
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!--
   Name of the unique or primary key constraint that the foreign
       key constraint references
   -->
   该外键约束引用的唯一或者主键约束的名称 
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       <!--
   Match option of the foreign key constraint:
       <literal>FULL</literal>, <literal>PARTIAL</literal>, or
       <literal>NONE</literal>.
   -->
   该外键约束的匹配选项：<literal>FULL</literal>,<literal>PARTIAL</literal>,或者<literal>NONE</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       <!--
   Update rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
   -->
   这个外键约束的更新规则：<literal>CASCADE</literal>, <literal>SET NULL</literal>,
   <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>或者<literal>NO ACTION</literal>。 
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       <!-- 
   Delete rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
   -->
   这个外键约束的删除规则<literal>CASCADE</literal>, <literal>SET NULL</literal>,
   <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>或者<literal>NO ACTION</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <!--
<para>
   The view <literal>role_column_grants</literal> identifies all
   privileges granted on columns where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>column_privileges</literal>.  The only effective
   difference between this view
   and <literal>column_privileges</literal> is that this view omits
   columns that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>
-->
<para>
视图<literal>role_column_grants</literal>标识那些在字段上赋予或被赋予为当前角色的所有权限。
更多信息可以在<literal>column_privileges</literal>中找到。这个视图和<literal>column_privileges</literal>
唯一有效的不同就是这个视图忽略了某些字段，这些字段是通过授予<literal>PUBLIC</literal>
使得当前用户可以访问的字段。
</para>

  <table>
   <!-- 
   <title><literal>role_column_grants</literal> Columns</title> 
   -->
   <title><literal>role_column_grants</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry> 
  -->
  <entry>被赋予这个权限的用户名称</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被赋予这个权限的角色名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
  -->
  <entry>包含此字段的表所在的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the table that contains the column</entry>
  -->
  <entry>包含该字段的表所在模式的名称</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table that contains the column</entry>
  -->
  <entry>包含该字段的表名称</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the column</entry>
  -->
  <entry>该字段的名称</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
   -->
   权限的类型：<literal>SELECT</literal>,<literal>INSERT</literal>, 
   <literal>UPDATE</literal>或者<literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限是可以赋予的，则为<literal>YES</literal>，否则，为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <!--
<para>
   The view <literal>role_routine_grants</literal> identifies all
   privileges granted on functions where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>routine_privileges</literal>.  The only effective
   difference between this view
   and <literal>routine_privileges</literal> is that this view omits
   functions that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>
-->
<para>
视图<literal>role_routine_grants</literal>标出所有在函数上赋予或被赋予当前角色的权限。
更多的信息可以在<literal>routine_privileges</literal>里找到。在该视图与<literal>routine_privileges</literal>
之间实际仅有的差异是该视图忽略那些通过赋权给<literal>PUBLIC</literal>使当前用户可以访问的函数。 
</para>

  <table>
   <!--
   <title><literal>role_routine_grants</literal> Columns</title>
   -->
   <title><literal>role_routine_grants</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>被赋予该权限的角色名称</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被赋予此权限的角色的名称</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含此函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含此函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information. 
   -->
   函数的<quote>specific name</quote>（具体的名称）。
   参阅<xref linkend="infoschema-routines">获取更多信息。
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含此函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含此函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the function (might be duplicated in case of overloading)</entry>
  -->
  <entry>函数的名称（可能重复，因为有重载）</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
  -->
  <entry>总是<literal>EXECUTE</literal>（函数的唯一的权限类型）</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可以赋予，那么是<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <!--
<para>
   The view <literal>role_table_grants</literal> identifies all
   privileges granted on tables or views where the grantor or grantee
   is a currently enabled role.  Further information can be found
   under <literal>table_privileges</literal>.  The only effective
   difference between this view
   and <literal>table_privileges</literal> is that this view omits
   tables that have been made accessible to the current user by way of
   a grant to <literal>PUBLIC</literal>.
  </para>
-->
<para>
视图<literal>role_table_grants</literal>标识在表或者视图上赋予或被赋予当前角色的全部权限。
更多信息可以在<literal>table_privileges</literal>找到。在该视图与<literal>table_privileges</literal>
之间实际仅有的差异是该视图忽略那些通过赋权给<literal>PUBLIC</literal>使当前用户可以访问的表。 
</para>

  <table>
   <!-- 
   <title><literal>role_table_grants</literal> Columns</title>
   -->
   <title><literal>role_table_grants</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>赋予权限的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被赋予权限的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the table (always the current database)</entry>
  -->
  <entry>包含此表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the table</entry>
  -->
  <entry>包含此表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table</entry>
  -->
  <entry>表名</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
   -->
   权限类型：<literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, 或 <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可以赋予则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
   -->
   在SQL标准里，<literal>WITH HIERARCHY OPTION</literal>
   是一个分开的（子）权限，允许在表继承层次结构上进行创建操作。
   在PostgreSQL中，这包含在了<literal>SELECT</literal>权限中，
   所以如果这个权限为<literal>SELECT</literal>则这个字段显示<literal>YES</literal>，
   否则为<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
  <title><literal>role_udt_grants</literal></title>

  <!--
<para>
   The view <literal>role_udt_grants</literal> is intended to identify
   <literal>USAGE</literal> privileges granted on user-defined types
   where the grantor or grantee is a currently enabled role.  Further
   information can be found under
   <literal>udt_privileges</literal>.  The only effective difference
   between this view and <literal>udt_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.  Since
   data types do not have real privileges in PostgreSQL, but only an
   implicit grant to <literal>PUBLIC</literal>, this view is empty.
  </para>
-->
<para>
视图<literal>role_udt_grants</literal>用于标出赋予或被赋予当前角色的用户定义类型上的
<literal>USAGE</literal>权限。更多的信息可以在<literal>udt_privileges</literal>里找到。
在该视图与<literal>udt_privileges</literal>
之间实际仅有的差异是该视图忽略那些通过赋权给<literal>PUBLIC</literal>使当前用户可以访问的对象。
因为数据类型在PostgreSQL中并没有真实的权力，但是只有一个隐式的赋权给<literal>PUBLIC</literal>，
所以这个视图是空的。
</para>

  <table>
   <!--
   <title><literal>role_udt_grants</literal> Columns</title>
   -->
   <title><literal>role_udt_grants</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>The name of the role that granted the privilege</entry>
  -->
  <entry>赋予该权限的角色的名字</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>The name of the role that the privilege was granted to</entry>
  -->
  <entry>被赋予该权限的角色的名字</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the type (always the current database)</entry>
  -->
  <entry>包含该类型的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the type</entry>
  -->
  <entry>包含该类型的模式的名字</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the type</entry>
  -->
  <entry>类型名</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always <literal>TYPE USAGE</literal></entry>
  -->
  <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限是可赋予的，那么就是<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <!--
<para>
   The view <literal>role_usage_grants</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects where the grantor or grantee is a currently enabled role.
   Further information can be found under
   <literal>usage_privileges</literal>.  The only effective difference
   between this view and <literal>usage_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.
  </para>
-->
<para>
视图<literal>role_usage_grants</literal>用于标出当前角色赋予或被赋予的各种对象的
<literal>USAGE</literal>权限。更多的信息可以在<literal>usage_privileges</literal>里找到。
在该视图与<literal>usage_privileges</literal>
之间实际仅有的差异是该视图忽略那些通过赋权给<literal>PUBLIC</literal>使当前用户可以访问的对象。 
</para>

  <table>
   <!-- 
   <title><literal>role_usage_grants</literal> Columns</title>
   -->
   <title><literal>role_usage_grants</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>The name of the role that granted the privilege</entry>
  -->
  <entry>赋予该权限的角色名称</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>The name of the role that the privilege was granted to</entry>
  -->
  <entry>被赋予该权限的角色的名称</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the object (always the current database)</entry>
  -->
  <entry>包含该对象的数据库的名字（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the object, if applicable,
      else an empty string</entry>
  -->
  <entry>如果适用，是包含该对象的模式的名字，否则是一个空字符串</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the object</entry>
  -->
  <entry>对象的名字</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry><literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal></entry>
  -->
  <entry><literal>COLLATION</literal> 或 <literal>DOMAIN</literal> 或
  <literal>FOREIGN DATA WRAPPER</literal> 或 <literal>FOREIGN SERVER</literal> 或
  <literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可以赋予，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <!--
<para>
   The view <literal>routine_privileges</literal> identifies all
   privileges granted on functions to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of function,
   grantor, and grantee.
  </para>
-->
<para>
视图<literal>routine_privileges</literal>标识在函数上所有赋予当前用户或者由当前用户赋予的权限。
每个函数，授权人，和权限接受人的组合都有一行。
</para>

  <table>
   <!--
   <title><literal>routine_privileges</literal> Columns</title>
   -->
   <title><literal>routine_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>赋予权限的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被授予权限的角色名</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含该函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含该函数的模式名</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information. 
   -->
   函数的<quote>specific name</quote>（具体的名字）。
   参阅<xref linkend="infoschema-routines">获取更多信息。
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含该函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含该函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the function (might be duplicated in case of overloading)</entry>
  -->
  <entry>函数名（可能会因重载而重复）</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
  -->
  <entry>总是<literal>EXECUTE</literal> (用于函数的唯一的权限类型)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
<!--
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
-->
      <entry>如果权限是可赋予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <!--
<para>
   The view <literal>routines</literal> contains all functions in the
   current database.  Only those functions are shown that the current
   user has access to (by way of being the owner or having some
   privilege).
  </para>
-->
<para>
视图<literal>routines</literal>包含当前数据库中的所有函数。
只有当前用户有访问权限（可能是所有者或者有特定权限）的函数才显示出来。 
</para>

  <table>
   <!-- 
   <title><literal>routines</literal> Columns</title>
   -->
   <title><literal>routines</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含该函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含该函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   The <quote>specific name</quote> of the function.  This is a
       name that uniquely identifies the function in the schema, even
       if the real name of the function is overloaded.  The format of
       the specific name is not defined, it should only be used to
       compare it to other instances of specific routine names.
   -->
   函数的<quote>specific name</quote>（具体名字）。这是一个在模式里唯一标识该函数的名字，
   即使函数的真是名字是重载的也如此。具体名字的格式没有定义，
   我们应该只是用它和其它具体过程名的实例进行比较。 
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含该函数的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含该函数的模式名称</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the function (might be duplicated in case of overloading)</entry>
  -->
  <entry>函数的名称（在重载的时候可能重复）</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Always <literal>FUNCTION</literal> (In the future there might
       be other types of routines.)
   -->
   总是<literal>FUNCTION</literal>（未来可能会有其它过程的类型。） 
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Return data type of the function, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>type_udt_name</literal> and associated
       columns).
   -->
   如果这是一个内置类型，则为函数的返回数据类型，或者如果是某种数组，
   则为<literal>ARRAY</literal>（这个时候，参阅视图<literal>element_types</literal>），
   否则就是<literal>USER-DEFINED</literal>（这种情况下，
   类型在<literal>type_udt_name</literal>和相关字段中标识）。 
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
     <!-- 
 <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
 -->
 <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为这个信息并不应用于<productname>PostgreSQL</>里的返回数据类型</entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that the return data type of the function
       is defined in (always the current database)
   -->
   函数的返回数据类型定义所在的数据库名称（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the schema that the return data type of the function is
       defined in
   -->
   函数的返回数据类型定义所在的模式名称 
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the return data type of the function
   -->
   该函数的返回数据类型的名称
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</></entry>
  -->
  <entry>总是为空，因为数组在<productname>PostgreSQL</>中总是有无限的最大维数</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   An identifier of the data type descriptor of the return data
       type of this function, unique among the data type descriptors
       pertaining to the function.  This is mainly useful for joining
       with other instances of such identifiers.  (The specific format
       of the identifier is not defined and not guaranteed to remain
       the same in future versions.)
   -->
   一个这个函数返回的数据类型的数据类型描述符的标识符，
   在所有属于这个函数的数据类型描述符中唯一。这个描述符主要用于和其它这样的标识符实例进行连接。
   （标识符具体的格式没有定义，并且不保证在将来的版本中保持相同。） 
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   If the function is an SQL function, then
       <literal>SQL</literal>, else <literal>EXTERNAL</literal>.
   -->
   如果函数是 SQL 函数，那么<literal>SQL</literal>，否则是<literal>EXTERNAL</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   The source text of the function (null if the function is not
       owned by a currently enabled role).  (According to the SQL
       standard, this column is only applicable if
       <literal>routine_body</literal> is <literal>SQL</literal>, but
       in <productname>PostgreSQL</productname> it will contain
       whatever source text was specified when the function was
       created.)
   -->
   函数的源代码文本（如果当前用户不是函数所有者，则为空）。（根据 SQL 标准，
   这个字段只又在<literal>routine_body</literal>是<literal>SQL</literal>的时候才使用，
   但是在<productname>PostgreSQL</productname>里，这个字段将包含创建函数的时候所声明的任何源文本。） 
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   If this function is a C function, then the external name (link
       symbol) of the function; else null.  (This works out to be the
       same value that is shown in
       <literal>routine_definition</literal>.)
   -->
   如果这个函数是一个 C 函数，那么是函数的外部名字（链接符号）；否则为空。
   （这个字段的数值和<literal>routine_definition</literal>里显示的数值相同。） 
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>The language the function is written in</entry>
  -->
  <entry>书写这个函数使用的语言</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Always <literal>GENERAL</literal> (The SQL standard defines
       other parameter styles, which are not available in <productname>PostgreSQL</>.)
   -->
   总是<literal>GENERAL</literal>（SQL标准定义了其它参数类型，
   那些类型不适用于<productname>PostgreSQL</>。） 
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   If the function is declared immutable (called deterministic in
       the SQL standard), then <literal>YES</literal>, else
       <literal>NO</literal>.  (You cannot query the other volatility
       levels available in <productname>PostgreSQL</> through the information schema.)
   -->
   如果这个函数声明为不变的(immutable)（在 SQL 标准里叫确定的(deterministic)），
   那么是<literal>YES</literal>，否则是<literal>NO</literal>。
   （在<productname>PostgreSQL</>里你无法通过信息模式查询其它可用的易失性级别。） 
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Always <literal>MODIFIES</literal>, meaning that the function
       possibly modifies SQL data.  This information is not useful for
       <productname>PostgreSQL</>.
   -->
   总是<literal>MODIFIES</literal>，意思是这个函数可能修改 SQL 数据。
   这个信息对<productname>PostgreSQL</>没啥作用。 
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   If the function automatically returns null if any of its
       arguments are null, then <literal>YES</literal>, else
       <literal>NO</literal>.
   -->
   如果当函数任意输入参数为空时函数自动返回空，则为<literal>YES</literal>，否则为<literal>NO</literal>。 
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   Always <literal>YES</literal> (The opposite would be a method
       of a user-defined type, which is a feature not available in
       <productname>PostgreSQL</>.)
   -->
   总是<literal>YES</literal>（相反的是一个用户定义类型的方法，
   这是一个<productname>PostgreSQL</>里没有的特性。） 
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   If the function runs with the privileges of the current user,
       then <literal>INVOKER</literal>, if the function runs with the
       privileges of the user who defined it, then
       <literal>DEFINER</literal>.
   -->
   如果这个函数以当前用户的权限运行，则为<literal>INVOKER</literal>，
   如果函数以定义它的用户的权限运行，则为<literal>DEFINER</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   Currently always <literal>NO</literal>.  The alternative
       <literal>YES</literal> applies to a feature not available in
       <productname>PostgreSQL</>.
   -->
   当前总是<literal>NO</literal>。<literal>YES</literal>适用于
   <productname>PostgreSQL</>里没有的一个特性。
      </entry>
     </row>

     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <!--
<para>
   The view <literal>schemata</literal> contains all schemas in the current
   database that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
-->
<para>
视图<literal>schemata</literal>包含当前数据库里当前用户有权访问的所有模式
（通过成为其所有者或者拥有一些权限）。 
</para>

  <table>
   <!-- 
   <title><literal>schemata</literal> Columns</title>
   -->
   <title><literal>schemata</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that the schema is contained in (always the current database)</entry>
  -->
  <entry>此模式所在的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema</entry>
  -->
  <entry>模式的名字 </entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the owner of the schema</entry>
  -->
  <entry>模式的所有者名称</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <!--
<para>
   The view <literal>sequences</literal> contains all sequences
   defined in the current database.  Only those sequences are shown
   that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
-->
<para>
视图<literal>sequences</literal>包含了所有定义在当前数据库中的序列。
只有那些当前用户可以访问的序列才显示（通过成为所有者或拥有一些权限）。 
</para>

  <table>
   <!--
   <title><literal>sequences</literal> Columns</title>
   -->
   <title><literal>sequences</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the sequence (always the current database)</entry>
  -->
  <entry>包含该序列的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the sequence</entry>
  -->
  <entry>包含序列的模式名称</entry>
     </row>

     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the sequence</entry>
  -->
  <entry>序列名称</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The data type of the sequence.  In
       <productname>PostgreSQL</productname>, this is currently always
       <literal>bigint</literal>.
   -->
   序列的数据类型。在<productname>PostgreSQL</productname>中，当前总是<literal>bigint</literal>。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   This column contains the (declared or implicit) precision of
       the sequence data type (see above).  The precision indicates
       the number of significant digits.  It can be expressed in
       decimal (base 10) or binary (base 2) terms, as specified in the
       column <literal>numeric_precision_radix</literal>.
   -->
   该字段（公开的或隐含的）包含序列数据类型的精度（见上述）。该精度表明了有效数字的位数。
   它可以用在十进制或者二进制中，在字段<literal>numeric_precision_radix</literal>中说明。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!--
   This column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.
   -->
   该字段表明该值在字段<literal>numeric_precision</literal>和
   <literal>numeric_scale</literal>中被表示。值为要么是2要么是10。 
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!--
   This column contains the (declared or implicit) scale of the
       sequence data type (see above).  The scale indicates the number
       of significant digits to the right of the decimal point.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.
   -->
   该字段（公开地或隐含地）包含序列数据类型的数值范围（见上文）。
   数值范围表明了小数点右边有效数字的位数。它可以用在十进制或二进制中，
   在字段<literal>numeric_precision_radix</literal>中说明。 
      </entry>
     </row>

     <row>
      <entry><literal>start_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>The start value of the sequence</entry>
  -->
  <entry>序列的起始值</entry>
     </row>

     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>The minimum value of the sequence</entry>
  -->
  <entry>序列的最小值</entry>
     </row>

     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>The maximum value of the sequence</entry>
  -->
  <entry>序列的最大值</entry>
     </row>

     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>The increment of the sequence</entry>
  -->
  <entry>序列的增量</entry>
     </row>

     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the sequence cycles, else <literal>NO</literal></entry>
  -->
  <entry>如果序列是周期的，那么是<literal>YES</literal> ，否则是<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Note that in accordance with the SQL standard, the start, minimum,
   maximum, and increment values are returned as character strings.
  </para>
-->
<para>
请注意，为了与SQL标准一致，起始值、最小值、最大值和增量值都作为字符串返回。
</para>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <!--
<para>
   The table <literal>sql_features</literal> contains information
   about which formal features defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  This is the
   same information that is presented in <xref linkend="features">.
   There you can also find some additional background information.
  </para>
-->
<para>
表<literal>sql_features</literal>包含有关<productname>PostgreSQL</productname>
支持的在 SQL 标准里定义的正式特性的信息。这些信息和在<xref linkend="features">
出现的信息相同。你也可以在那里找到一些额外的背景信息。 
</para>

  <table>
   <!-- 
   <title><literal>sql_features</literal> Columns</title>
   -->
   <title><literal>sql_features</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Identifier string of the feature</entry>
  -->
  <entry>这个特性的标识字串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Descriptive name of the feature</entry>
  -->
  <entry>这个特性的描述性名字</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Identifier string of the subfeature, or a zero-length string if not a subfeature</entry>
  -->
  <entry>子特性的标识符字串，如果不是子特性，那么就是一个零长的字串</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Descriptive name of the subfeature, or a zero-length string if not a subfeature</entry>
  -->
  <entry>子特性的描述性名字，如果不是子特性，那么就是一个零长的字串</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</literal> if the feature is fully supported by the
       current version of <productname>PostgreSQL</>, <literal>NO</literal> if not
   -->
   如果当前版本的<productname>PostgreSQL</>完全支持该特性，那么是<literal>YES</literal>，
   否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Always null, since the <productname>PostgreSQL</> development group does not
       perform formal testing of feature conformance
   -->
   总是为空，因为<productname>PostgreSQL</>开发组并不做特性核实的正式测试。 
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Possibly a comment about the supported status of the feature</entry>
  -->
  <entry>可能是一个有关特性支持状态的注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <!--
<para>
   The table <literal>sql_implementation_info</literal> contains
   information about various aspects that are left
   implementation-defined by the SQL standard.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual implementation
   information items are not described here; you will find them in the
   description of the ODBC interface.
  </para>
-->
<para>
表<literal>sql_implementation_info</literal>包含有关 SQL 标准里各种留给具体实现定义的特性的信息。
这些信息主要用在 ODBC 接口的环境里；其它接口的用户可能会觉得这些信息没有什么用处。
出于这个原因，独立的实现信息条目没有在这个描述；你会在 ODBC 接口的描述里找到它们。 
</para>

  <table>
   <!-- 
   <title><literal>sql_implementation_info</literal> Columns</title>
   -->
   <title><literal>sql_implementation_info</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Identifier string of the implementation information item</entry>
  -->
  <entry>实现信息条目的标识字串</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Descriptive name of the implementation information item</entry>
  -->
  <entry>实现信息条目的描述性名称</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!-- 
   Value of the implementation information item, or null if the
       value is contained in the column
       <literal>character_value</literal>
   -->
   实现信息条目的数值，或如果数值在<literal>character_value</literal>字段里包含了，则为空。
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Value of the implementation information item, or null if the
       value is contained in the column
       <literal>integer_value</literal>
   -->
   实现信息条目的数值，或如果该值已经在字段<literal>integer_value</literal>里包含，则为空。
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Possibly a comment pertaining to the implementation information item</entry>
  -->
  <entry>可能是一个描述此实现信息条目的注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <!--
<para>
   The table <literal>sql_languages</literal> contains one row for
   each SQL language binding that is supported by
   <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supports direct SQL and
   embedded SQL in C; that is all you will learn from this table.
  </para>
-->
<para>
表<literal>sql_languages</literal>为<productname>PostgreSQL</productname>
里支持的每个 SQL 语言绑定都包含一行。<productname>PostgreSQL</productname>
支持直接的 SQL 和在 C 里面嵌入 SQL； 这就是你从这个表里能看到的所有东西。
</para>

  <!--
<para>
   This table was removed from the SQL standard in SQL:2008, so there
   are no entries referring to standards later than SQL:2003.
  </para>
-->
<para>
这个表在SQL:2008中已经从SQL标准中移除了，所有SQL:2003以后的标准都没有可以参考的条目了。
</para>

  <table>
   <!--
   <title><literal>sql_languages</literal> Columns</title>
   -->
   <title><literal>sql_languages</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The name of the source of the language definition; always
       <literal>ISO 9075</literal>, that is, the SQL standard
   -->
   语言定义源的名称；总是<literal>ISO 9075</literal>，也就是SQL 标准 
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The year the standard referenced in
       <literal>sql_language_source</literal> was approved.
-->
<literal>sql_language_source</literal>里引用的标准通过的年代。
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   The standard conformance level for the language binding.  For
       ISO 9075:2003 this is always <literal>CORE</literal>.
   -->
   这种语言绑定的标准遵循级别。对于 ISO 9075:2003，这里总是<literal>CORE</literal>。
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Always null (This value is relevant to an earlier version of the SQL standard.)</entry>
  -->
  <entry>总是空（这个数值与早期的 SQL 标准相关。） </entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always null</entry>
  -->
  <entry>总是为空</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   The language binding style, either <literal>DIRECT</literal> or
       <literal>EMBEDDED</literal>
   -->
   语言绑定风格，要么是<literal>DIRECT</literal>，要么是<literal>EMBEDDED</literal>。 
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   The programming language, if the binding style is
       <literal>EMBEDDED</literal>, else null.  <productname>PostgreSQL</> only
       supports the language C.
   -->
   如果绑定风格是<literal>EMBEDDED</literal>，那么是编程语言，
   否则是空，<productname>PostgreSQL</>只支持 C 语言。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <!--
<para>
   The table <literal>sql_packages</literal> contains information
   about which feature packages defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  Refer to <xref
   linkend="features"> for background information on feature packages.
  </para>
-->
<para>
表<literal>sql_packages</literal>包含有关定义在 SQL 标准里的那个特性包是<productname>PostgreSQL</productname>
支持的信息。请参考<xref linkend="features">获取有关特性包的背景信息。 
</para>

  <table>
   <!--
   <title><literal>sql_packages</literal> Columns</title>
   -->
   <title><literal>sql_packages</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Identifier string of the package</entry>
  -->
  <entry>包的标识字串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Descriptive name of the package</entry>
  -->
  <entry>包的描述性名字</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</literal> if the package is fully supported by the
       current version of <productname>PostgreSQL</>, <literal>NO</literal> if not
   -->
   如果该包被当前版本的<productname>PostgreSQL</>完全支持，则为<literal>YES</literal>，
   否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Always null, since the <productname>PostgreSQL</> development group does not
       perform formal testing of feature conformance
   -->
   总是空，因为<productname>PostgreSQL</>开发组没有进行任何特性兼容性的正式测试
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Possibly a comment about the supported status of the package</entry>
  -->
  <entry>可能是一个有关该包支持状态的评注</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <!--
<para>
   The table <literal>sql_parts</literal> contains information about
   which of the several parts of the SQL standard are supported by
   <productname>PostgreSQL</productname>.
  </para>
-->
<para>
表<literal>sql_parts</literal>包含关于<productname>PostgreSQL</productname>支持的SQL标准的几部分信息。 
</para>

  <table>
   <!--
   <title><literal>sql_parts</literal> Columns</title>
   -->
   <title><literal>sql_parts</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>An identifier string containing the number of the part</entry>
  -->
  <entry>一个包含部分数量的标识字符串</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Descriptive name of the part</entry>
  -->
  <entry>部分描述名称</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</literal> if the part is fully supported by the
       current version of <productname>PostgreSQL</>,
       <literal>NO</literal> if not
   -->
   如果当前<productname>PostgreSQL</>版本完全支持该部分为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Always null, since the <productname>PostgreSQL</> development group does not
       perform formal testing of feature conformance
   -->
   总为空，因为<productname>PostgreSQL</>开发组不执行正规的特性一致性测试
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Possibly a comment about the supported status of the part</entry>
  -->
  <entry>可能的一个关于支持部分状态的意见</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <!--
<para>
   The table <literal>sql_sizing</literal> contains information about
   various size limits and maximum values in
   <productname>PostgreSQL</productname>.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual sizing items are
   not described here; you will find them in the description of the
   ODBC interface.
  </para>
-->
<para>
表<literal>sql_sizing</literal>包含有关<productname>PostgreSQL</productname>
里面各种大小限制和最大值的信息。这个信息特别用于在 ODBC 接口的环境下；
其它接口的用户很可能发现这个信息没什么用。处于这个原因，在这里没有描述独立的大小条目；
你将在 ODBC 接口的描述里找到它们。 
</para>

  <table>
   <!-- 
   <title><literal>sql_sizing</literal> Columns</title>
   -->
   <title><literal>sql_sizing</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Identifier of the sizing item</entry>
  -->
  <entry>尺寸项的标识符</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Descriptive name of the sizing item</entry>
  -->
  <entry>尺寸项的描述名称</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      <!--
  Value of the sizing item, or 0 if the size is unlimited or
       cannot be determined, or null if the features for which the
       sizing item is applicable are not supported
   -->
   尺寸项的数值，如果尺寸无限制或者无法确定，则为 0，如果不支持适用的尺寸项的特性，则为空。
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Possibly a comment pertaining to the sizing item</entry>
  -->
  <entry>可能是一个有关此尺寸项的评注</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <!--
<para>
   The table <literal>sql_sizing_profiles</literal> contains
   information about the <literal>sql_sizing</literal> values that are
   required by various profiles of the SQL standard.  <productname>PostgreSQL</> does
   not track any SQL profiles, so this table is empty.
  </para>
-->
<para>
表<literal>sql_sizing_profiles</literal>包含有关 SQL 标准要求的各种配置文件的
<literal>sql_sizing</literal>信息。<productname>PostgreSQL</>并不跟踪任何 SQL 配置文件，所以这个表是空的。 
</para>

  <table>
   <!--
   <title><literal>sql_sizing_profiles</literal> Columns</title>
   -->
   <title><literal>sql_sizing_profiles</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Identifier of the sizing item</entry>
  -->
  <entry>尺寸项的标识符</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Descriptive name of the sizing item</entry>
  -->
  <entry>尺寸项的描述性名称</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Identifier string of a profile</entry>
  -->
  <entry>一个配置文件的标识字串</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       <!--
   The value required by the SQL profile for the sizing item, or 0
       if the profile places no limit on the sizing item, or null if
       the profile does not require any of the features for which the
       sizing item is applicable
   -->
   SQL 配置文件对尺寸项要求的数值，如果配置文件对尺寸项没有限制，则为0，
   如果配置文件对尺寸项所适用的特性没有任何要求，那么就为空。
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Possibly a comment pertaining to the sizing item within the profile</entry>
  -->
  <entry>可能是一个有关该配置文件里面的尺寸项的注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <!--
<para>
   The view <literal>table_constraints</literal> contains all
   constraints belonging to tables that the current user owns or has
   some privilege other than <literal>SELECT</literal> on.
  </para>
-->
<para>
视图<literal>table_constraints</literal>包含所有属于当前用户的表里面的约束，
或有除了<literal>SELECT</literal>之外的某些权限。
</para>

  <table>
   <!--
   <title><literal>table_constraints</literal> Columns</title>
   -->
   <title><literal>table_constraints</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the constraint (always the current database)</entry>
  -->
  <entry>包含该约束地数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the constraint</entry>
  -->
  <entry>包含这个约束的模式名称</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the constraint</entry>
  -->
  <entry>约束名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the table (always the current database)</entry>
  -->
  <entry>包含该表的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the table</entry>
  -->
  <entry>包含此表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the table</entry>
  -->
  <entry>表名</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Type of the constraint: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>,
       or <literal>UNIQUE</literal>
   -->
   约束的类型：<literal>CHECK</literal>, <literal>FOREIGN KEY</literal>,
   <literal>PRIMARY KEY</literal>, 或者<literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果约束可以推迟，为<literal>YES</literal> ，否则为<literal>NO</literal>。 </entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
  -->
  <entry>如果约束是可以推迟的并且是首先推迟的，为<literal>YES</literal>，否则为<literal>NO</literal>。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <!--
<para>
   The view <literal>table_privileges</literal> identifies all
   privileges granted on tables or views to a currently enabled role
   or by a currently enabled role.  There is one row for each
   combination of table, grantor, and grantee.
  </para>
-->
<para>
视图<literal>table_privileges</literal>标识所有赋与当前用户或者由当前用户赋予的，
在表或者视图上的权限。每个表、赋权人、受权人的组合都有一行。 
</para>

  <table>
   <!-- 
   <title><literal>table_privileges</literal> Columns</title>
   -->
   <title><literal>table_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>授予该权限的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被授予该权限的角色名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the table (always the current database)</entry>
  -->
  <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the table</entry>
  -->
  <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the table</entry>
  -->
  <entry>表名</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
   -->
   权限的类型：<literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, 或 <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限是可赋予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
   -->
   在SQL标准中，<literal>WITH HIERARCHY OPTION</literal>是一个单独的（子）特权，
   允许在表继承层次结构上执行创建。在PostgreSQL中，这包含在<literal>SELECT</literal>
   特权中，所以如果特权是<literal>SELECT</literal>这个字段就显示<literal>YES</literal>，
   否则为<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <!--
<para>
   The view <literal>tables</literal> contains all tables and views
   defined in the current database.  Only those tables and views are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>
-->
<para>
视图<literal>tables</literal>包含所有在当前数据库里定义的表和视图。
只有那些当前用户有权限访问（要么是所有者，要么是有某些权限）的表和视图才显示出来。 
</para>

  <table>
   <!--
   <title><literal>tables</literal> Columns</title>
   -->
   <title><literal>tables</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the table (always the current database)</entry>
  -->
  <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the table</entry>
  -->
  <entry>包含该表的模式名</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the table</entry>
  -->
  <entry>表名</entry>
     </row>

     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Type of the table: <literal>BASE TABLE</literal> for a
       persistent base table (the normal table type),
       <literal>VIEW</literal> for a view, <literal>FOREIGN TABLE</literal>
       for a foreign table, or
       <literal>LOCAL TEMPORARY</literal> for a temporary table
   -->
   表的类型：永久基本表是<literal>BASE TABLE</literal>（普通的表类型），
   视图是<literal>VIEW</literal>，外表是<literal>FOREIGN TABLE</literal>，
   或者是<literal>LOCAL TEMPORARY</literal>表示临时表。 
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   If the table is a typed table, the name of the database that
       contains the underlying data type (always the current
       database), else null.
   -->
   如果该表是一个指定类型的表，那么就是包含基本的数据类型的数据库名称
   （总是当前数据库），否则为空。 
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   If the table is a typed table, the name of the schema that
       contains the underlying data type, else null.
   -->
   如果该表是一个指定类型的表，那么就是包含基本的数据类型的模式名称，否则为空。 
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   If the table is a typed table, the name of the underlying data
       type, else null.
   -->
   如果该表是一个指定类型的表，那么为基础数据类型的名称，否则为空。 
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the table is insertable into,
       <literal>NO</literal> if not (Base tables are always insertable
       into, views not necessarily.)
   -->
   如果该表可插入则为<literal>YES</literal>，否则为<literal>NO</literal>
   （基础表总是可插入的，视图不是必须的。） 
      </entry>
     </row>

     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the table is a typed table, <literal>NO</literal> if not</entry>
  -->
  <entry>如果该表是一个指定类型的表则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Not yet implemented</entry>
  -->
  <entry>目前未实现</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
  <title><literal>triggered_update_columns</literal></title>

  <!--
<para>
   For triggers in the current database that specify a column list
   (like <literal>UPDATE OF column1, column2</literal>), the
   view <literal>triggered_update_columns</literal> identifies these
   columns.  Triggers that do not specify a column list are not
   included in this view.  Only those columns are shown that the
   current user owns or has some privilege other than
   <literal>SELECT</literal> on.
  </para>
-->
<para>
对于当前数据库中的触发器来说指定一个字段列表（像<literal>UPDATE OF column1, column2</literal>），
视图<literal>triggered_update_columns</literal>识别这些字段。触发器不指定一个不包含在这个视图中的字段列表。
只有那些当前用户拥有或有除了<literal>SELECT</literal>之外的某些权限的字段才显示。
</para>

  <table>
   <!-- 
   <title><literal>triggered_update_columns</literal> Columns</title>
   -->
   <title><literal>triggered_update_columns</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the trigger (always the current database)</entry>
  -->
  <entry>包含该触发器的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the trigger</entry>
  -->
  <entry>包含该触发器的模式名称</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the trigger</entry>
  -->
  <entry>触发器的名称</entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the database that contains the table that the trigger
       is defined on (always the current database)
   -->
   包含定义了触发器的表的数据库名称（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the table that the trigger is defined on</entry>
  -->
  <entry>包含定义了触发器的表的模式名称</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the table that the trigger is defined on</entry>
  -->
  <entry>定义了触发器的表名</entry>
     </row>

     <row>
      <entry><literal>event_object_column</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the column that the trigger is defined on</entry>
  -->
  <entry>定义了触发器的字段的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <!--
<para>
   The view <literal>triggers</literal> contains all triggers defined
   in the current database on tables and views that the current user owns
   or has some privilege other than <literal>SELECT</literal> on.
  </para>
-->
<para>
视图<literal>triggers</literal>包含了所有在当前数据库中的表和视图上定义的，
并且当前用户是其所有者或有除了<literal>SELECT</literal>之外的某些权限的触发器。
</para>

  <table>
   <!--
   <title><literal>triggers</literal> Columns</title>
   -->
   <title><literal>triggers</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the trigger (always the current database)</entry>
  -->
  <entry>包含该触发器的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the trigger</entry>
  -->
  <entry>包含该触发器的模式名称</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the trigger</entry>
  -->
  <entry>触发器名称</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Event that fires the trigger (<literal>INSERT</literal>,
       <literal>UPDATE</literal>, or <literal>DELETE</literal>)
   -->
   激发触发器的事件（<literal>INSERT</literal>,<literal>UPDATE</literal>或者<literal>DELETE</literal>）
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the database that contains the table that the trigger
       is defined on (always the current database)
   -->
   包含触发器定义所在表的数据库名称（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the table that the trigger is defined on</entry>
  -->
  <entry>包含触发器定义所在表的模式名 </entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the table that the trigger is defined on</entry>
  -->
  <entry>触发器定义所在的表名</entry>
     </row>

     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Not yet implemented</entry>
  -->
  <entry>尚未实现</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   <literal>WHEN</literal> condition of the trigger, null if none
       (also null if the table is not owned by a currently enabled
       role)
   -->
   <literal>WHEN</literal>触发器条件，如果没有则为空
   （如果当前角色不是该表的所有者也为空） 
      </entry>
     </row>

     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Statement that is executed by the trigger (currently always
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>)
   -->
   触发器执行的语句（目前总是<literal>EXECUTE PROCEDURE <replaceable>function</replaceable>(...)</literal>） 
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Identifies whether the trigger fires once for each processed
       row or once for each statement (<literal>ROW</literal> or
       <literal>STATEMENT</literal>)
   -->
   标识触发器是对处理的每一行激发还是对每个语句激发
   （<literal>ROW</literal>或者<literal>STATEMENT</literal>） 
      </entry>
     </row>

     <row>
      <entry><literal>action_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Time at which the trigger fires (<literal>BEFORE</literal>,
       <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>)
   -->
   触发器触发的时间（<literal>BEFORE</literal>，<literal>AFTER</literal>或者<literal>INSTEAD OF</literal>） 
      </entry>
     </row>

     <row>
      <entry><literal>action_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>action_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Triggers in <productname>PostgreSQL</productname> have two
   incompatibilities with the SQL standard that affect the
   representation in the information schema.  First, trigger names are
   local to each table in <productname>PostgreSQL</productname>, rather
   than being independent schema objects.  Therefore there can be duplicate
   trigger names defined in one schema, so long as they belong to
   different tables.  (<literal>trigger_catalog</literal> and
   <literal>trigger_schema</literal> are really the values pertaining
   to the table that the trigger is defined on.)  Second, triggers can
   be defined to fire on multiple events in
   <productname>PostgreSQL</productname> (e.g., <literal>ON INSERT OR
   UPDATE</literal>), whereas the SQL standard only allows one.  If a
   trigger is defined to fire on multiple events, it is represented as
   multiple rows in the information schema, one for each type of
   event.  As a consequence of these two issues, the primary key of
   the view <literal>triggers</literal> is really
   <literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal> instead of
   <literal>(trigger_catalog, trigger_schema, trigger_name)</literal>,
   which is what the SQL standard specifies.  Nonetheless, if you
   define your triggers in a manner that conforms with the SQL
   standard (trigger names unique in the schema and only one event
   type per trigger), this will not affect you.
  </para>
-->
<para>
<productname>PostgreSQL</productname>里面的触发器在影响到信息模式的表现形式方面，
与 SQL 标准有两处不同。首先，在<productname>PostgreSQL</productname>里，触发器名字是表示本地的对象，
而不是独立的模式对象。因此，我们可以在一个模式里定义重复的触发器名字，只要他们属于不同的表。
（<literal>trigger_catalog</literal>和<literal>trigger_schema</literal>实际上是属于触发器定义所在表的值。）
第二，<productname>PostgreSQL</productname>里的触发器可以定义为在多个事件上触发
（比如<literal>ON INSERT OR UPDATE</literal>），而 SQL 标准只允许一个。
如果一个触发器定义为在多个事件上触发，那么在信息模式里它会表现为多行，事件的每个类型一行。因为这两个原因，
视图<literal>triggers</literal>的主键实际上是<literal>(trigger_catalog, trigger_schema, event_object_table,
 trigger_name, event_manipulation)</literal>，而不是<literal>(trigger_catalog, trigger_schema, trigger_name)</literal>，
后者是 SQL 标准声明的。当然，如果你定义一个遵循 SQL 标准的触发器（触发器名字在模式中唯一，
并且每个触发器只有一个事件类型），这些事情不会烦着你。 
</para>

  <note>
   <!--
<para>
    Prior to <productname>PostgreSQL</> 9.1, this view's columns
    <structfield>action_timing</structfield>,
    <structfield>action_reference_old_table</structfield>,
    <structfield>action_reference_new_table</structfield>,
    <structfield>action_reference_old_row</structfield>, and
    <structfield>action_reference_new_row</structfield>
    were named
    <structfield>condition_timing</structfield>,
    <structfield>condition_reference_old_table</structfield>,
    <structfield>condition_reference_new_table</structfield>,
    <structfield>condition_reference_old_row</structfield>, and
    <structfield>condition_reference_new_row</structfield>
    respectively.
    That was how they were named in the SQL:1999 standard.
    The new naming conforms to SQL:2003 and later.
   </para>
-->
<para>
在<productname>PostgreSQL</> 9.1之前，这个视图的字段
<structfield>action_timing</structfield>,
<structfield>action_reference_old_table</structfield>,
<structfield>action_reference_new_table</structfield>,
<structfield>action_reference_old_row</structfield>, 和
<structfield>action_reference_new_row</structfield>分别叫做
<structfield>condition_timing</structfield>,
<structfield>condition_reference_old_table</structfield>,
<structfield>condition_reference_new_table</structfield>,
<structfield>condition_reference_old_row</structfield>, 和
<structfield>condition_reference_new_row</structfield>。
这是它们在SQL:1999标准中的名字。新的名字符合SQL:2003和之后的标准。
</para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
  <title><literal>udt_privileges</literal></title>

  <!--
<para>
   The view <literal>udt_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on user-defined types to a
   currently enabled role or by a currently enabled role.  There is one row for
   each combination of column, grantor, and grantee.  This view shows only
   composite types (see under <xref linkend="infoschema-user-defined-types">
   for why); see
   <xref linkend="infoschema-usage-privileges"> for domain privileges.
  </para>
-->
<para>
视图<literal>udt_privileges</literal>标识授予当前用户或由当前用户授予用户定义类型的
<literal>USAGE</literal>权限。对于每个字段、授权者和受权者的组合都有一行。
这个视图只显示复合类型（参阅<xref linkend="infoschema-user-defined-types">获得原因）；
参阅<xref linkend="infoschema-usage-privileges">获取域的权限。
</para>

  <table>
   <!--
   <title><literal>udt_privileges</literal> Columns</title>
   -->
   <title><literal>udt_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>授予特权的角色名称</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被授予特权的角色名称</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the type (always the current database)</entry>
  -->
  <entry>包含该类型的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema containing the type</entry>
  -->
  <entry>包含该类型的模式名称</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the type</entry>
  -->
  <entry>类型名</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always <literal>TYPE USAGE</literal></entry>
  -->
  <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可授予，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <!--
<para>
   The view <literal>usage_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects to a currently enabled role or by a currently enabled role.
   In <productname>PostgreSQL</productname>, this currently applies to
   collations, domains, foreign-data wrappers, foreign servers, and sequences.  There is one
   row for each combination of object, grantor, and grantee.
  </para>
-->
<para>
视图<literal>usage_privileges</literal>用于标识在各种类型的对象上赋与当前用户或者当前用户赋与的
<literal>USAGE</literal>权限。在 <productname>PostgreSQL</productname>中，
当前适用于排序规则、域、外部数据封装、外部服务器和序列。每个对象、授权者和受权者的组合都有一行。
</para>

  <!--
<para>
   Since collations do not have real privileges
   in <productname>PostgreSQL</productname>, this view shows implicit
   non-grantable <literal>USAGE</literal> privileges granted by the
   owner to <literal>PUBLIC</literal> for all collations.  The other
   object types, however, show real privileges.
  </para>
-->
<para>
因为在<productname>PostgreSQL</productname>里，排序规则并没有真正的权限，
所以这个视图显示了隐含的由<literal>PUBLIC</literal>的所有者授予所有排序规则的非可授予的
<literal>USAGE</literal>权限。其他的对象类型显示了真正的权限。
</para>

  <!--
<para>
   In PostgreSQL, sequences also support <literal>SELECT</literal>
   and <literal>UPDATE</literal> privileges in addition to
   the <literal>USAGE</literal> privilege.  These are nonstandard and therefore
   not visible in the information schema.
  </para>
-->
<para>
在PostgreSQL中，序列也支持<literal>SELECT</literal>和<literal>UPDATE</literal>权限，
除了<literal>USAGE</literal>权限。这不是标准并且因此在信息模式中不可见。
</para>

  <table>
   <!--
   <title><literal>usage_privileges</literal> Columns</title>
   -->
   <title><literal>usage_privileges</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the role that granted the privilege</entry>
  -->
  <entry>授权的角色名</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the role that the privilege was granted to</entry>
  -->
  <entry>被授权的角色名</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database containing the object (always the current database)</entry>
  -->
  <entry>包含该对象的数据库名（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema containing the object, if applicable,
      else an empty string</entry>
  -->
  <entry>如果适用，是包含该对象的模式名，否则是空字符串</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the object</entry>
  -->
  <entry>对象名</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry><literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal></entry>
  -->
  <entry><literal>COLLATION</literal>或<literal>DOMAIN</literal>或
  <literal>FOREIGN DATA WRAPPER</literal>或<literal>FOREIGN SERVER</literal>
  或<literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Always <literal>USAGE</literal></entry>
  -->
  <entry>总是<literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
  -->
  <entry>如果权限可授予则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-defined-types">
  <title><literal>user_defined_types</literal></title>

  <!--
<para>
   The view <literal>user_defined_types</literal> currently contains
   all composite types defined in the current database.
   Only those types are shown that the current user has access to (by way
   of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>user_defined_types</literal>当前包含所有在当前数据库中定义的复合类型。
只有当前用户可以访问的类型才显示出来（通过成为其所有者或有某些权限）。
</para>

  <!--
<para>
   SQL knows about two kinds of user-defined types: structured types
   (also known as composite types
   in <productname>PostgreSQL</productname>) and distinct types (not
   implemented in <productname>PostgreSQL</productname>).  To be
   future-proof, use the
   column <literal>user_defined_type_category</literal> to
   differentiate between these.  Other user-defined types such as base
   types and enums, which are <productname>PostgreSQL</productname>
   extensions, are not shown here.  For domains,
   see <xref linkend="infoschema-domains"> instead.
  </para>
-->
<para>
SQL知道两种用户定义的类型：结构化类型（在<productname>PostgreSQL</productname>中也成为复合类型）
和不同类型（在<productname>PostgreSQL</productname>中没有实现）。为了永不过时，
使用字段<literal>user_defined_type_category</literal>来区分它们。其他用户定义类型，
例如基础类型和枚举类型，是<productname>PostgreSQL</productname>的扩展，不在这里展示。
对于域，参阅<xref linkend="infoschema-domains">。
</para>

  <table>
   <!--
   <title><literal>user_defined_types</literal> Columns</title>
   -->
   <title><literal>user_defined_types</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the type (always the current database)</entry>
  -->
  <entry>包含该类型的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the type</entry>
  -->
  <entry>包含该类型的模式名称</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the type</entry>
  -->
  <entry>类型名</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!-- 
   Currently always <literal>STRUCTURED</literal>
   -->
   当前总是<literal>STRUCTURED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_instantiable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>is_final</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_form</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_category</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ordering_routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>reference_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
     <!--
 <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
 -->
 <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>source_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>

     <row>
      <entry><literal>ref_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>适用于一个<productname>PostgreSQL</>中没有的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <!--
<para>
   The view <literal>user_mapping_options</literal> contains all the
   options defined for user mappings in the current database.  Only
   those user mappings are shown where the current user has access to
   the corresponding foreign server (by way of being the owner or
   having some privilege).
  </para>
-->
<para>
视图<literal>user_mapping_options</literal>包含在当前数据库中为用户映射定义的所有项。
只有那些当前用户可以访问相应外部服务器的用户映射才显示（通过成为其所有者或有某些权限）。 
</para>

  <table>
   <!--
   <title><literal>user_mapping_options</literal> Columns</title>
   -->
   <title><literal>user_mapping_options</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the user being mapped,
      or <literal>PUBLIC</literal> if the mapping is public</entry>
  -->
  <entry>被映射的用户名称，或如果映射是公共的为 <literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign server used by this
      mapping is defined in (always the current database)</entry>
  -->
  <entry>该映射使用的外部服务器定义所在的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the foreign server used by this mapping</entry>
  -->
  <entry>该映射使用的外部服务器的名称</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of an option</entry>
  -->
  <entry>选项名</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Value of the option.  This column will show as null
      unless the current user is the user being mapped, or the mapping
      is for <literal>PUBLIC</literal> and the current user is the
      server owner, or the current user is a superuser.  The intent is
      to protect password information stored as user mapping
      option.</entry>
  -->
  <entry>选项值。这个字段将显示null除非当前用户是被映射的用户，
  或映射是<literal>PUBLIC</literal>并且当前用户是服务器拥有者，
  或当前用户是超级用户。这样的目的是为了保护密码信息作为用户映射选项存储。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <!--
<para>
   The view <literal>user_mappings</literal> contains all user
   mappings defined in the current database.  Only those user mappings
   are shown where the current user has access to the corresponding
   foreign server (by way of being the owner or having some
   privilege).
  </para>
-->
<para>
视图<literal>user_mappings</literal>包含所有定义在当前数据库中的用户映射。
只有那些当前用户可以访问相应的外部服务器的用户映射才显示（通过成为所有者或拥有一些特权）。 
</para>

  <table>
   <!-- 
   <title><literal>user_mappings</literal> Columns</title>
   -->
   <title><literal>user_mappings</literal>字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the user being mapped,
      or <literal>PUBLIC</literal> if the mapping is public</entry>
  -->
  <entry>被映射的用户名称，或如果映射是公共的为<literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that the foreign server used by this
      mapping is defined in (always the current database)</entry>
  -->
  <entry>被该映射使用的外部服务器定义所在的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the foreign server used by this mapping</entry>
  -->
  <entry>被该映射使用的外部服务器的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <!--
<para>
   The view <literal>view_column_usage</literal> identifies all
   columns that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   column is only included if the table that contains the column is
   owned by a currently enabled role.
  </para>
-->
<para>
视图<literal>view_column_usage</literal>标识所有在一个视图的查询表达式
（定义视图的<command>SELECT</command>语句）中使用的字段。
只有在当前用户是包含该字段的表的所有者的时候才会列出这个字段。 
</para>

  <note>
   <!--
<para>
    Columns of system tables are not included.  This should be fixed
    sometime.
   </para>
-->
<para>
系统表的字段没有列出。以后应该修补这个问题。
</para>
  </note>

  <table>
   <!-- 
   <title><literal>view_column_usage</literal> Columns</title>
   -->
   <title><literal>view_column_usage</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the view (always the current database)</entry>
  -->
  <entry>包含这个视图的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the view</entry>
  -->
  <entry>包含这个视图的模式名称</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the view</entry>
  -->
  <entry>视图名称</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the database that contains the table that contains the
       column that is used by the view (always the current database)
   -->
   含被这个视图使用的字段的表所在的数据库的名字（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the schema that contains the table that contains the
       column that is used by the view
   -->
   含被这个视图使用的字段的表所在的数据库的名字（总是当前数据库） 
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the table that contains the column that is used by the
       view
   -->
   包含被这个视图使用的字段的表名 
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the column that is used by the view</entry>
  -->
  <entry>视图使用的字段名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <!--
<para>
   The view <literal>view_routine_usage</literal> identifies all
   routines (functions and procedures) that are used in the query
   expression of a view (the <command>SELECT</command> statement that
   defines the view).  A routine is only included if that routine is
   owned by a currently enabled role.
  </para>
-->
<para>
视图<literal>view_routine_usage</literal>识别所有被应用在视图
的查询表达式（定义该视图的<command>SELECT</command>语句）中的日常活动（函数和程序）。
只有当前用户是这个活动的所有者的时候才包含这个活动。
</para>

  <table>
   <!--
   <title><literal>view_routine_usage</literal> Columns</title>
   -->
   <title><literal>view_routine_usage</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!-- 
  <entry>Name of the database containing the view (always the current database)</entry>
  -->
  <entry>包含该视图的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the schema containing the view</entry>
  -->
  <entry>包含该视图的模式的名称</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the view</entry>
  -->
  <entry>视图名</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the database containing the function (always the current database)</entry>
  -->
  <entry>包含该函数的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <!--
  <entry>Name of the schema containing the function</entry>
  -->
  <entry>包含该函数的模式的名称</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       <!--
   The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information.
   -->
   函数的<quote>专用名</quote>。参阅<xref linkend="infoschema-routines">获取更多信息。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <!--
<para>
   The view <literal>view_table_usage</literal> identifies all tables
   that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   table is only included if that table is owned by a currently
   enabled role.
  </para>
-->
<para>
视图<literal>view_table_usage</literal>标识所有在一个视图的查询表达式中
（定义视图的<command>SELECT</command>语句）使用的表的名字。
只有在当前用户是这个表的所有者的时候才会包含这个表。
</para>

  <note>
   <!--
<para>
    System tables are not included.  This should be fixed sometime.
   </para>
-->
<para>
没有包括系统表。这个在将来应该修补。 
</para>
  </note>

  <table>
   <!--
   <title><literal>view_table_usage</literal> Columns</title>
   -->
   <title><literal>view_table_usage</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the database that contains the view (always the current database)</entry>
  -->
  <entry>包含该视图的数据库的名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the schema that contains the view</entry>
  -->
  <entry>包含该视图的模式的名称</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the view</entry>
  -->
  <entry>视图名</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the database that contains the table that is
       used by the view (always the current database)
   -->
   包含被视图使用的表的数据库的名称（总是当前数据库）
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!--
   Name of the schema that contains the table that is used by the
       view
   -->
   包含被视图使用的表的模式名称 
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       <!-- 
   Name of the table that is used by the view
   -->
   视图使用的表的名称 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <!--
<para>
   The view <literal>views</literal> contains all views defined in the
   current database.  Only those views are shown that the current user
   has access to (by way of being the owner or having some privilege).
  </para>
-->
<para>
视图<literal>views</literal>包含所有定义在当前数据库中的视图。
只有那些当前用户有权访问（要么是所有者要么是拥有某些权限）的视图才显示出来。 
</para>

  <table>
   <!-- 
   <title><literal>views</literal> Columns</title>
   -->
   <title><literal>views</literal> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the database that contains the view (always the current database)</entry>
  -->
  <entry>包含这个视图的数据库名称（总是当前数据库）</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!-- 
  <entry>Name of the schema that contains the view</entry>
  -->
  <entry>包含这个视图的模式名称</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <!--
  <entry>Name of the view</entry>
  -->
  <entry>视图名称</entry>
     </row>

     <row>
      <entry><literal>view_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <!--
   Query expression defining the view (null if the view is not
       owned by a currently enabled role)
   -->
   定义视图的查询表达式（如果当前用户不是视图所有者，则为空）
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <!--
  <entry>Applies to a feature not available in <productname>PostgreSQL</></entry>
  -->
  <entry>应用于一个<productname>PostgreSQL</>里没有的特性</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</literal> if the view is updatable (allows
       <command>UPDATE</command> and <command>DELETE</command>),
       <literal>NO</literal> if not 
   -->
   如果视图是可更新的则为<literal>YES</literal>（允许
   <command>UPDATE</command> 和 <command>DELETE</command>)），
   否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</literal> if the view is insertable into (allows
       <command>INSERT</command>), <literal>NO</literal> if not
   -->
   如果视图是可插入的则为<literal>YES</literal>（允许<command>INSERT</command>），
   否则为<literal>NO</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</> if the view has an <literal>INSTEAD OF</>
       <command>UPDATE</> trigger defined on it, <literal>NO</> if not
   -->
   如果在视图上定义了一个<literal>INSTEAD OF</> <command>UPDATE</>
   触发器则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_deletable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!--
   <literal>YES</> if the view has an <literal>INSTEAD OF</>
       <command>DELETE</> trigger defined on it, <literal>NO</> if not
   -->
   如果在视图上定义了一个<literal>INSTEAD OF</> <command>DELETE</>
   触发器则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <!-- 
   <literal>YES</> if the view has an <literal>INSTEAD OF</>
       <command>INSERT</> trigger defined on it, <literal>NO</> if not
   -->
   如果在视图上定义了一个<literal>INSTEAD OF</> <command>INSERT</>
   触发器则为<literal>YES</>，否则为<literal>NO</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
