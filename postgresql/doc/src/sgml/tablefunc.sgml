<!-- doc/src/sgml/tablefunc.sgml -->

<sect1 id="tablefunc" xreflabel="tablefunc">
<!-- pgdoc-cn_start sig_en=23495eb9403709277f5f2e0d946cb0af sig_cn_org=None source=14.1 
 <title>tablefunc</title>
________________________________________________________-->
 <title>tablefunc</title>
<!-- pgdoc-cn_end sig_en=23495eb9403709277f5f2e0d946cb0af -->

<!-- pgdoc-cn_start sig_en=847d1cbaaa3587c66e9e10ae38974a38 sig_cn_org=None source=14.1 
 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=847d1cbaaa3587c66e9e10ae38974a38 -->

<!-- pgdoc-cn_start sig_en=7f787fe366fd326e2da41277acb6ac5d sig_cn_org=None source=14.1 
 <para>
  The <filename>tablefunc</filename> module includes various functions that return
  tables (that is, multiple rows).  These functions are useful both in their
  own right and as examples of how to write C functions that return
  multiple rows.
 </para>
________________________________________________________-->
 <para>
  <filename>tablefunc</filename>模块包括多个返回表（也就是多行）的函数。这些函数都很有用，并且也可以作为如何编写返回多行的 C 函数的例子。
 </para>
<!-- pgdoc-cn_end sig_en=7f787fe366fd326e2da41277acb6ac5d -->

<!-- pgdoc-cn_start sig_en=73fd7076637bb21a0cce44734412cba6 sig_cn_org=None source=14.1 
 <para>
  This module is considered <quote>trusted</quote>, that is, it can be
  installed by non-superusers who have <literal>CREATE</literal> privilege
  on the current database.
 </para>
________________________________________________________-->
 <para>
  这个模块被认为是<quote>可信的</quote>，也就是说，它可以由对当前数据库具有<literal>CREATE</literal>权限的非超级用户安装。
 </para>
<!-- pgdoc-cn_end sig_en=73fd7076637bb21a0cce44734412cba6 -->

 <sect2>
<!-- pgdoc-cn_start sig_en=31e2435f7254af8fd39244fad363eb6a sig_cn_org=None source=14.1 
  <title>Functions Provided</title>
________________________________________________________-->
  <title>所提供的函数</title>
<!-- pgdoc-cn_end sig_en=31e2435f7254af8fd39244fad363eb6a -->

<!-- pgdoc-cn_start sig_en=cb9c2d12884ffbbbb300fbe550901e6c sig_cn_org=None source=14.1 
  <para>
   <xref linkend="tablefunc-functions"/> summarizes the functions provided
   by the <filename>tablefunc</filename> module.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="tablefunc-functions"/>总结了<filename>tablefunc</filename>模块提供的函数。
  </para>
<!-- pgdoc-cn_end sig_en=cb9c2d12884ffbbbb300fbe550901e6c -->

  <table id="tablefunc-functions">
<!-- pgdoc-cn_start sig_en=04da8233d31c606fd5d1ddb5d7167cae sig_cn_org=None source=14.1 
   <title><filename>tablefunc</filename> Functions</title>
________________________________________________________-->
   <title><filename>tablefunc</filename>函数</title>
<!-- pgdoc-cn_end sig_en=04da8233d31c606fd5d1ddb5d7167cae -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        简述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=1453b547b5f41c33bf83d9a0cef81fab sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>normal_rand</function> ( <parameter>numvals</parameter> <type>integer</type>, <parameter>mean</parameter> <type>float8</type>, <parameter>stddev</parameter> <type>float8</type> )
        <returnvalue>setof float8</returnvalue>
       </para>
       <para>
        Produces a set of normally distributed random values.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>normal_rand</function> ( <parameter>numvals</parameter> <type>integer</type>, <parameter>mean</parameter> <type>float8</type>, <parameter>stddev</parameter> <type>float8</type> )
        <returnvalue>浮点数集</returnvalue>
       </para>
       <para>
        产生一组正态分布的随机值。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1453b547b5f41c33bf83d9a0cef81fab -->

<!-- pgdoc-cn_start sig_en=e1e35005fe7d232b6b6e1fc629535e10 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>sql</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Produces a <quote>pivot table</quote> containing
        row names plus <replaceable>N</replaceable> value columns, where
        <replaceable>N</replaceable> is determined by the row type specified
        in the calling query.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>sql</parameter> <type>text</type> )
        <returnvalue>记录集</returnvalue>
       </para>
       <para>
        生成一个<quote>数据透视表</quote>，其中包含行名称和 <replaceable>N</replaceable> 列值，其中 <replaceable>N</replaceable> 由调用查询中指定的行类型决定。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e1e35005fe7d232b6b6e1fc629535e10 -->

<!-- pgdoc-cn_start sig_en=d2f53d483cca49a0a0003926ef129f55 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab<replaceable>N</replaceable></function> ( <parameter>sql</parameter> <type>text</type> )
        <returnvalue>setof table_crosstab_<replaceable>N</replaceable></returnvalue>
       </para>
       <para>
        Produces a <quote>pivot table</quote> containing
        row names plus <replaceable>N</replaceable> value columns.
        <function>crosstab2</function>, <function>crosstab3</function>, and
        <function>crosstab4</function> are predefined, but you can create additional
        <function>crosstab<replaceable>N</replaceable></function> functions as described below.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab<replaceable>N</replaceable></function> ( <parameter>sql</parameter> <type>text</type> )
        <returnvalue>table_crosstab_集<replaceable>N</replaceable></returnvalue>
       </para>
       <para>
        产生一个包含行名称外加<replaceable>N</replaceable>个值列的<quote>数据透视表</quote>。<function>crosstab2</function>、<function>crosstab3</function>和<function>crosstab4</function>是被预定义的，但你可以按照下文所述创建额外的<function>crosstab<replaceable>N</replaceable></function>函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d2f53d483cca49a0a0003926ef129f55 -->

<!-- pgdoc-cn_start sig_en=7dff05c89320d40a0826e6697eb5c29a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>source_sql</parameter> <type>text</type>, <parameter>category_sql</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Produces a <quote>pivot table</quote>
        with the value columns specified by a second query.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>source_sql</parameter> <type>text</type>, <parameter>category_sql</parameter> <type>text</type> )
        <returnvalue>记录集</returnvalue>
       </para>
       <para>
        产生一个<quote>数据透视表</quote>，其值列由第二个查询指定。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7dff05c89320d40a0826e6697eb5c29a -->

<!-- pgdoc-cn_start sig_en=804350598eb426d8188db5ce8f2dd59f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>sql</parameter> <type>text</type>, <parameter>N</parameter> <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Obsolete version of <function>crosstab(text)</function>.
        The parameter <parameter>N</parameter> is now ignored, since the
        number of value columns is always determined by the calling query.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>crosstab</function> ( <parameter>sql</parameter> <type>text</type>, <parameter>N</parameter> <type>integer</type> )
        <returnvalue>记录集</returnvalue>
       </para>
       <para>
        <function>crosstab(text)</function>的废弃版本。参数<replaceable>N</replaceable>现在被忽略，因为值列的数量总是由调用查询所决定。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=804350598eb426d8188db5ce8f2dd59f -->

<!-- pgdoc-cn_start sig_en=971a819f61fc60ebfce0bd72170dc97c sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>connectby</primary></indexterm>
        <function>connectby</function> ( <parameter>relname</parameter> <type>text</type>, <parameter>keyid_fld</parameter> <type>text</type>, <parameter>parent_keyid_fld</parameter> <type>text</type>
        <optional>, <parameter>orderby_fld</parameter> <type>text</type> </optional>, <parameter>start_with</parameter> <type>text</type>, <parameter>max_depth</parameter> <type>integer</type>
        <optional>, <parameter>branch_delim</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Produces a representation of a hierarchical tree structure.
        </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>connectby</primary></indexterm>
        <function>connectby</function> ( <parameter>relname</parameter> <type>text</type>, <parameter>keyid_fld</parameter> <type>text</type>, <parameter>parent_keyid_fld</parameter> <type>text</type>
        <optional>, <parameter>orderby_fld</parameter> <type>text</type> </optional>, <parameter>start_with</parameter> <type>text</type>, <parameter>max_depth</parameter> <type>integer</type>
        <optional>, <parameter>branch_delim</parameter> <type>text</type> </optional> )
        <returnvalue>记录集</returnvalue>
       </para>
       <para>
        产生一个层次树结构的表达。
        </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=971a819f61fc60ebfce0bd72170dc97c -->
     </tbody>
    </tgroup>
  </table>

  <sect3>
   <title><function>normal_rand</function></title>

<!-- pgdoc-cn_start sig_en=30d6de1009a9319791124dcffba8bb95 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>normal_rand</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>normal_rand</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=30d6de1009a9319791124dcffba8bb95 -->

<!-- pgdoc-cn_start sig_en=925cca0789f417f1c12f642b6fd8e174 sig_cn_org=None source=14.1 
<synopsis>
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
</synopsis>
________________________________________________________-->
<synopsis>
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
</synopsis>
<!-- pgdoc-cn_end sig_en=925cca0789f417f1c12f642b6fd8e174 -->

<!-- pgdoc-cn_start sig_en=9cba03dd79341d00cba1c04638babdab sig_cn_org=None source=14.1 
    <para>
     <function>normal_rand</function> produces a set of normally distributed random
     values (Gaussian distribution).
    </para>
________________________________________________________-->
    <para>
     <function>normal_rand</function>产生一个正态分布随机值（高斯分布）的集合。
    </para>
<!-- pgdoc-cn_end sig_en=9cba03dd79341d00cba1c04638babdab -->

<!-- pgdoc-cn_start sig_en=4c8f146b8d23680788745466873d9096 sig_cn_org=None source=14.1 
    <para>
     <parameter>numvals</parameter> is the number of values to be returned
     from the function. <parameter>mean</parameter> is the mean of the normal
     distribution of values and <parameter>stddev</parameter> is the standard
     deviation of the normal distribution of values.
    </para>
________________________________________________________-->
    <para>
     <parameter>numvals</parameter>是从该函数返回的值的数量。<parameter>mean</parameter>是值的正态分布的均值而<parameter>stddev</parameter>是值的正态分布的标准偏差。
    </para>
<!-- pgdoc-cn_end sig_en=4c8f146b8d23680788745466873d9096 -->

<!-- pgdoc-cn_start sig_en=b0f5e049eb8d6b2ea760aa25a4c73c82 sig_cn_org=None source=14.1 
    <para>
     For example, this call requests 1000 values with a mean of 5 and a
     standard deviation of 3:
    </para>
________________________________________________________-->
    <para>
     例如，这个调用请求 1000 个值，它们具有均值 5 和标准偏差 3：
    </para>
<!-- pgdoc-cn_end sig_en=b0f5e049eb8d6b2ea760aa25a4c73c82 -->

<!-- pgdoc-cn_start sig_en=b9a3a5fd398518767971b514a88ef801 sig_cn_org=None source=14.1 
<screen>
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
</screen>
________________________________________________________-->
<screen>
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
</screen>
<!-- pgdoc-cn_end sig_en=b9a3a5fd398518767971b514a88ef801 -->
  </sect3>

  <sect3>
   <title><function>crosstab(text)</function></title>

<!-- pgdoc-cn_start sig_en=3bcde51644b5e2e30bd6036dd59f2c5e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3bcde51644b5e2e30bd6036dd59f2c5e -->

<!-- pgdoc-cn_start sig_en=b3484ef17ab44f5edc4374101586b98d sig_cn_org=None source=14.1 
<synopsis>
crosstab(text sql)
crosstab(text sql, int N)
</synopsis>
________________________________________________________-->
<synopsis>
crosstab(text sql)
crosstab(text sql, int N)
</synopsis>
<!-- pgdoc-cn_end sig_en=b3484ef17ab44f5edc4374101586b98d -->

<!-- pgdoc-cn_start sig_en=8d33fa707763a9d2e541b7f6d7be8da9 sig_cn_org=None source=14.1 
   <para>
    The <function>crosstab</function> function is used to produce <quote>pivot</quote>
    displays, wherein data is listed across the page rather than down.
    For example, we might have data like
<programlisting>
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
</programlisting>
    which we wish to display like
<programlisting>
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
</programlisting>
    The <function>crosstab</function> function takes a text parameter that is an SQL
    query producing raw data formatted in the first way, and produces a table
    formatted in the second way.
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>函数被用来产生<quote>pivot</quote>显示，在其中数据被横布在页面上而不是直接向下列举。例如，我们可能有这样的数据
<programlisting>
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
</programlisting>
    而我们希望显示成这样
<programlisting>
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
</programlisting>
    <function>crosstab</function>函数会采用一个文本参数，该文本是一个 SQL 查询，它产生按照第一种方式格式化的原始数据，并且产生以第二种方式格式化的一个表。
   </para>
<!-- pgdoc-cn_end sig_en=8d33fa707763a9d2e541b7f6d7be8da9 -->

<!-- pgdoc-cn_start sig_en=4dd8258ba1fe03bab558f7983e10ba7d sig_cn_org=None source=14.1 
   <para>
    The <parameter>sql</parameter> parameter is an SQL statement that produces
    the source set of data. This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column.  <parameter>N</parameter> is an
    obsolete parameter, ignored if supplied (formerly this had to match the
    number of output value columns, but now that is determined by the
    calling query).
   </para>
________________________________________________________-->
   <para>
    <parameter>sql</parameter>参数是一个产生数据的源集合的 SQL 语句。这个语句必须返回一个<structfield>row_name</structfield>列、一个<structfield>category</structfield>列和一个<structfield>value</structfield>列。<parameter>N</parameter>是一个废弃参数，即使提供也会被忽略（之前这必须匹配输出值列的数目，但是现在这由调用查询决定了）。
   </para>
<!-- pgdoc-cn_end sig_en=4dd8258ba1fe03bab558f7983e10ba7d -->

<!-- pgdoc-cn_start sig_en=f53752f36cfaafcf6cf9d9e8caa476fd sig_cn_org=None source=14.1 
   <para>
    For example, the provided query might produce a set something like:
<programlisting>
 row_name    cat    value
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，所提供的查询可能会产生这样的一个集合：
<programlisting>
 row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=f53752f36cfaafcf6cf9d9e8caa476fd -->

<!-- pgdoc-cn_start sig_en=aa0db5acccedfbcc09df85a5b21d12d7 sig_cn_org=None source=14.1 
   <para>
    The <function>crosstab</function> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
    statement, for example:
<programlisting>
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
</programlisting>
    This example produces a set something like:
<programlisting>
           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
  row1        val1         val2
  row2        val5         val6
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>函数被声明为返回<type>setof record</type>，
    因此输出列的实际名称和类型必须定义在调用的<command>SELECT</command>语句的<literal>FROM</literal>子句中，例如：
<programlisting>
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
</programlisting>
    这个例子产生这样一个集合：
<programlisting>
           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
----------+------------+------------
  row1        val1         val2
  row2        val5         val6
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=aa0db5acccedfbcc09df85a5b21d12d7 -->

<!-- pgdoc-cn_start sig_en=a0591b3ccff35ff80a06d0bb5d63dba5 sig_cn_org=None source=14.1 
   <para>
    The <literal>FROM</literal> clause must define the output as one
    <structfield>row_name</structfield> column (of the same data type as the first result
    column of the SQL query) followed by N <structfield>value</structfield> columns
    (all of the same data type as the third result column of the SQL query).
    You can set up as many output value columns as you wish.  The names of the
    output columns are up to you.
   </para>
________________________________________________________-->
   <para>
    <literal>FROM</literal>子句必须把输出定义为一个<structfield>row_name</structfield>列
    （具有 SQL 查询的第一个结果列的相同数据类型），其后跟随着 N 个<structfield>value</structfield>列
    （都具有 SQL 查询的第三个结果列的相同数据类型）。你可以按照你的意愿设置任意多的输出值列。
    而输出列的名称取决于你。
   </para>
<!-- pgdoc-cn_end sig_en=a0591b3ccff35ff80a06d0bb5d63dba5 -->

<!-- pgdoc-cn_start sig_en=f724f58b4085e3cb26b8994fa361d473 sig_cn_org=None source=14.1 
   <para>
    The <function>crosstab</function> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  It fills the output
    <structfield>value</structfield> columns, left to right, with the
    <structfield>value</structfield> fields from these rows.  If there
    are fewer rows in a group than there are output <structfield>value</structfield>
    columns, the extra output columns are filled with nulls; if there are
    more rows, the extra input rows are skipped.
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>函数为具有相同<structfield>row_name</structfield>值的
    输入行的每一个连续分组产生一个输出行。它使用来自这些行的<structfield>值</structfield>域
    从左至右填充输出的<structfield>值</structfield>列。如果一个分组中的行比输出<structfield>值</structfield>列少，
    多余的输出列将被用空值填充。如果行更多，则多余的输入行会被跳过。
   </para>
<!-- pgdoc-cn_end sig_en=f724f58b4085e3cb26b8994fa361d473 -->

<!-- pgdoc-cn_start sig_en=020fd5a964e6170f8f77850b448b1a58 sig_cn_org=None source=14.1 
   <para>
    In practice the SQL query should always specify <literal>ORDER BY 1,2</literal>
    to ensure that the input rows are properly ordered, that is, values with
    the same <structfield>row_name</structfield> are brought together and
    correctly ordered within the row.  Notice that <function>crosstab</function>
    itself does not pay any attention to the second column of the query
    result; it's just there to be ordered by, to control the order in which
    the third-column values appear across the page.
   </para>
________________________________________________________-->
   <para>
    事实上，SQL 查询应该总是指定<literal>ORDER BY 1,2</literal>来保证输入行被正确地排序，
    也就是说具有相同<structfield>row_name</structfield>的值会被放在一起并且在行内
    被正确地排序。注意<function>crosstab</function>本身并不关注查询结果的第二列，它放在那里
    只是为了被排序，以便控制出现在页面上的第三列值的顺序。
   </para>
<!-- pgdoc-cn_end sig_en=020fd5a964e6170f8f77850b448b1a58 -->

<!-- pgdoc-cn_start sig_en=4d5adcb0d71e9a8a1e903b137c7551f1 sig_cn_org=None source=14.1 
   <para>
    Here is a complete example:
<programlisting>
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这是一个完整的例子：
<programlisting>
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4d5adcb0d71e9a8a1e903b137c7551f1 -->

<!-- pgdoc-cn_start sig_en=3fb1a1b1c96ad854b184cb23b8f04baa sig_cn_org=None source=14.1 
   <para>
    You can avoid always having to write out a <literal>FROM</literal> clause to
    define the output columns, by setting up a custom crosstab function that
    has the desired output row type wired into its definition.  This is
    described in the next section.  Another possibility is to embed the
    required <literal>FROM</literal> clause in a view definition.
   </para>
________________________________________________________-->
   <para>
    你可以避免总是要写出一个<literal>FROM</literal>子句来定义输出列，
    方法是设置一个在其定义中硬编码所期望的输出行类型的自定义 crosstab 函数。
    这会在下一节中描述。另一种可能性是在一个视图定义中嵌入所需的<literal>FROM</literal>子句。
   </para>
<!-- pgdoc-cn_end sig_en=3fb1a1b1c96ad854b184cb23b8f04baa -->

   <note>
<!-- pgdoc-cn_start sig_en=a31fdd469901efbaf4e8a8ac46e4fa67 sig_cn_org=None source=14.1 
    <para>
     See also the <command><link linkend="app-psql-meta-commands-crosstabview">\crosstabview</link></command>
     command in <application>psql</application>, which provides functionality similar
     to <function>crosstab()</function>.
    </para>
________________________________________________________-->
    <para>
     另见<application>psql</application>中的
     <command><link linkend="app-psql-meta-commands-crosstabview">\crosstabview</link></command>
     命令，它提供了和<function>crosstab()</function>类似的功能。
    </para>
<!-- pgdoc-cn_end sig_en=a31fdd469901efbaf4e8a8ac46e4fa67 -->
   </note>

  </sect3>

  <sect3>
   <title><function>crosstab<replaceable>N</replaceable>(text)</function></title>

<!-- pgdoc-cn_start sig_en=3bcde51644b5e2e30bd6036dd59f2c5e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3bcde51644b5e2e30bd6036dd59f2c5e -->

<!-- pgdoc-cn_start sig_en=de0f4e8437bc765cfc0c643421a37761 sig_cn_org=None source=14.1 
<synopsis>
crosstab<replaceable>N</replaceable>(text sql)
</synopsis>
________________________________________________________-->
<synopsis>
crosstab<replaceable>N</replaceable>(text sql)
</synopsis>
<!-- pgdoc-cn_end sig_en=de0f4e8437bc765cfc0c643421a37761 -->

<!-- pgdoc-cn_start sig_en=60f40065afed19e185c5e00050f8144b sig_cn_org=None source=14.1 
    <para>
     The <function>crosstab<replaceable>N</replaceable></function> functions are examples of how
     to set up custom wrappers for the general <function>crosstab</function> function,
     so that you need not write out column names and types in the calling
     <command>SELECT</command> query.  The <filename>tablefunc</filename> module includes
     <function>crosstab2</function>, <function>crosstab3</function>, and
     <function>crosstab4</function>, whose output row types are defined as
    </para>
________________________________________________________-->
    <para>
     <function>crosstab<replaceable>N</replaceable></function>系列函数是如何为普通<function>crosstab</function>
     函数设置自定义包装器的例子，这样你不需要在调用的<command>SELECT</command>查询中
     写出列名和类型。<filename>tablefunc</filename>模块包括<function>crosstab2</function>、
     <function>crosstab3</function>以及<function>crosstab4</function>，它们的输入行类型被定义为：
    </para>
<!-- pgdoc-cn_end sig_en=60f40065afed19e185c5e00050f8144b -->

<!-- pgdoc-cn_start sig_en=10fb23b9130deef8f542420f2612f673 sig_cn_org=None source=14.1 
<programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
</programlisting>
<!-- pgdoc-cn_end sig_en=10fb23b9130deef8f542420f2612f673 -->

<!-- pgdoc-cn_start sig_en=6879cd0951bfc6e31824af449aeba8a0 sig_cn_org=None source=14.1 
    <para>
     Thus, these functions can be used directly when the input query produces
     <structfield>row_name</structfield> and <structfield>value</structfield> columns of type
     <type>text</type>, and you want 2, 3, or 4 output values columns.
     In all other ways they behave exactly as described above for the
     general <function>crosstab</function> function.
    </para>
________________________________________________________-->
    <para>
     因此，当输入查询产生类型为<type>text</type>的列<structfield>row_name</structfield>和<structfield>value</structfield>
     并且想要 2、3 或 4 个输出值列时，这些函数可以被直接使用。在所有其他方法中，它们的行为都和上面的
     一般<function>crosstab</function>函数完全相同。
    </para>
<!-- pgdoc-cn_end sig_en=6879cd0951bfc6e31824af449aeba8a0 -->

<!-- pgdoc-cn_start sig_en=9b86e877b23907e7367552770be7d0fa sig_cn_org=None source=14.1 
    <para>
     For instance, the example given in the previous section would also
     work as
<programlisting>
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
</programlisting>
    </para>
________________________________________________________-->
    <para>
     例如，前一节给出的例子也可以这样来做
<programlisting>
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=9b86e877b23907e7367552770be7d0fa -->

<!-- pgdoc-cn_start sig_en=9134917a79605ed3d9b8b7fb71b8743f sig_cn_org=None source=14.1 
    <para>
     These functions are provided mostly for illustration purposes. You
     can create your own return types and functions based on the
     underlying <function>crosstab()</function> function.  There are two ways
     to do it:

    <itemizedlist>
     <listitem>
      <para>
       Create a composite type describing the desired output columns,
       similar to the examples in
       <filename>contrib/tablefunc/tablefunc-&minus;1.0.sql</filename>.
       Then define a
       unique function name accepting one <type>text</type> parameter and returning
       <type>setof your_type_name</type>, but linking to the same underlying
       <function>crosstab</function> C function.  For example, if your source data
       produces row names that are <type>text</type>, and values that are
       <type>float8</type>, and you want 5 value columns:
<programlisting>
CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       Use <literal>OUT</literal> parameters to define the return type implicitly.
       The same example could also be done this way:
<programlisting>
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     这些函数主要是出于举例的目的而提供。你可以基于底层的<function>crosstab()</function>函数
     创建你自己的返回类型和函数。有两种方法来做：

    <itemizedlist>
     <listitem>
      <para>
       与<filename>contrib/tablefunc/tablefunc--1.0.sql</filename>中相似，创建一个组合类型来描述所期望的输出列。
       然后定义一个唯一的函数名，它接受一个<type>text</type>参数并且返回<type>setof your_type_name</type>，但是链接到同样的
       底层<function>crosstab</function> C 函数。例如，如果你的源数据产生为<type>text</type>类型的行名称，并且值是<type>float8</type>，
       并且你想要 5 个值列：
<programlisting>
CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       使用<literal>OUT</literal>参数来隐式定义返回类型。同样的例子也可以这样来做：
<programlisting>
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=9134917a79605ed3d9b8b7fb71b8743f -->

  </sect3>

  <sect3>
   <title><function>crosstab(text, text)</function></title>

<!-- pgdoc-cn_start sig_en=3bcde51644b5e2e30bd6036dd59f2c5e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3bcde51644b5e2e30bd6036dd59f2c5e -->

<!-- pgdoc-cn_start sig_en=cbeffb1eed8682a9a7924eb296fcd772 sig_cn_org=None source=14.1 
<synopsis>
crosstab(text source_sql, text category_sql)
</synopsis>
________________________________________________________-->
<synopsis>
crosstab(text source_sql, text category_sql)
</synopsis>
<!-- pgdoc-cn_end sig_en=cbeffb1eed8682a9a7924eb296fcd772 -->

<!-- pgdoc-cn_start sig_en=7770fd4fbe1a6d1a75e1fcca91693ae3 sig_cn_org=None source=14.1 
   <para>
    The main limitation of the single-parameter form of <function>crosstab</function>
    is that it treats all values in a group alike, inserting each value into
    the first available column.  If you want the value
    columns to correspond to specific categories of data, and some groups
    might not have data for some of the categories, that doesn't work well.
    The two-parameter form of <function>crosstab</function> handles this case by
    providing an explicit list of the categories corresponding to the
    output columns.
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>的单一参数形式的主要限制是它把一个组中的所有值都视作相似，
    并且把每一个值插入到第一个可用的列中。如果你想要值列对应于特定的数据分类，并且
    某些分组可能没有关于某些分类的数据，这样的形式就无法工作。<function>crosstab</function>的双参数形式
    通过提供一个对应于输出列的显式分类列表来处理这种情况。
   </para>
<!-- pgdoc-cn_end sig_en=7770fd4fbe1a6d1a75e1fcca91693ae3 -->

<!-- pgdoc-cn_start sig_en=537b4ffa16ad7df1399e7b5126c2d011 sig_cn_org=None source=14.1 
   <para>
    <parameter>source_sql</parameter> is an SQL statement that produces the
    source set of data.  This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column. It may also have one or more
    <quote>extra</quote> columns.
    The <structfield>row_name</structfield> column must be first. The
    <structfield>category</structfield> and <structfield>value</structfield>
    columns must be the last two columns, in that order.  Any columns between
    <structfield>row_name</structfield> and
    <structfield>category</structfield> are treated as <quote>extra</quote>.
    The <quote>extra</quote> columns are expected to be the same for all rows
    with the same <structfield>row_name</structfield> value.
   </para>
________________________________________________________-->
   <para>
    <parameter>source_sql</parameter>是一个产生源数据集的 SQL 语句。这个语句必须返回一个
    <structfield>row_name</structfield>列、一个<structfield>category</structfield>列以及一个<structfield>value</structfield>列。
    也可以有一个或者多个<quote>extra</quote>列。<structfield>row_name</structfield>列必须是第一个。
    <structfield>category</structfield>和<structfield>value</structfield>列必须是按照这个顺序的最后两个列。
    <structfield>row_name</structfield>和<structfield>category</structfield>之间的任何列都被视作<quote>extra</quote>。
    对于具有相同<structfield>row_name</structfield>值的所有行，其<quote>extra</quote>列都应该相同。
   </para>
<!-- pgdoc-cn_end sig_en=537b4ffa16ad7df1399e7b5126c2d011 -->

<!-- pgdoc-cn_start sig_en=25ce13e229f19be23684667b7de9863b sig_cn_org=None source=14.1 
   <para>
    For example, <parameter>source_sql</parameter> might produce a set
    something like:
<programlisting>
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，<parameter>source_sql</parameter>可能产生一组这样的东西：
<programlisting>
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
----------+------------+-----+---------
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=25ce13e229f19be23684667b7de9863b -->

<!-- pgdoc-cn_start sig_en=beb66d39f14511c9a3d710cb291931f8 sig_cn_org=None source=14.1 
   <para>
    <parameter>category_sql</parameter> is an SQL statement that produces
    the set of categories. This statement must return only one column.
    It must produce at least one row, or an error will be generated.
    Also, it must not produce duplicate values, or an error will be
    generated.  <parameter>category_sql</parameter> might be something like:

<programlisting>
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -&minus;-&minus;-&minus;-
    cat1
    cat2
    cat3
    cat4
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <parameter>category_sql</parameter>是一个产生分类集合的 SQL 语句。这个语句必须只返回一列。
    它必须产生至少一行，否则会生成一个错误。还有，它不能产生重复值，否则会生成一个错误。<parameter>category_sql</parameter>可能是这样的：

<programlisting>
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=beb66d39f14511c9a3d710cb291931f8 -->

<!-- pgdoc-cn_start sig_en=076d87c9e711418b68c74a1ec3bf4def sig_cn_org=None source=14.1 
   <para>
    The <function>crosstab</function> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
    statement, for example:

<programlisting>
SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>函数被声明为返回<type>setof record</type>，这样输出列的实际名称和类型
    就必须在调用的<command>SELECT</command>语句的<literal>FROM</literal>子句中被定义，例如：

<programlisting>
SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=076d87c9e711418b68c74a1ec3bf4def -->

<!-- pgdoc-cn_start sig_en=4a154d6d8c441d4c46926b53dfa026ba sig_cn_org=None source=14.1 
   <para>
    This will produce a result something like:
<programlisting>
                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这将产生这样的结果：
<programlisting>
                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
---------+-------+------+------+------+------
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4a154d6d8c441d4c46926b53dfa026ba -->

<!-- pgdoc-cn_start sig_en=01fb527ccb291f28fb359de0e33852d1 sig_cn_org=None source=14.1 
   <para>
    The <literal>FROM</literal> clause must define the proper number of output
    columns of the proper data types.  If there are <replaceable>N</replaceable>
    columns in the <parameter>source_sql</parameter> query's result, the first
    <replaceable>N</replaceable>-2 of them must match up with the first
    <replaceable>N</replaceable>-2 output columns.  The remaining output columns
    must have the type of the last column of the <parameter>source_sql</parameter>
    query's result, and there must be exactly as many of them as there
    are rows in the <parameter>category_sql</parameter> query's result.
   </para>
________________________________________________________-->
   <para>
    <literal>FROM</literal>子句必须定义正确数量的输出列以及正确的数据类型。如果在<parameter>source_sql</parameter>
    查询的结果中有<replaceable>N</replaceable>列，其中的前<replaceable>N</replaceable>-2 列必须匹配前<replaceable>N</replaceable>-2
     个输出列。剩余的输出列必须具有<parameter>source_sql</parameter>查询结果的最后一列的类型，并且并且它们的数量
     必须正好和<parameter>source_sql</parameter>查询结果中的行数相同。
   </para>
<!-- pgdoc-cn_end sig_en=01fb527ccb291f28fb359de0e33852d1 -->

<!-- pgdoc-cn_start sig_en=27cc597d2e94f2cc66c4856b07608211 sig_cn_org=None source=14.1 
   <para>
    The <function>crosstab</function> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  The output
    <structfield>row_name</structfield> column, plus any <quote>extra</quote>
    columns, are copied from the first row of the group.  The output
    <structfield>value</structfield> columns are filled with the
    <structfield>value</structfield> fields from rows having matching
    <structfield>category</structfield> values.  If a row's <structfield>category</structfield>
    does not match any output of the <parameter>category_sql</parameter>
    query, its <structfield>value</structfield> is ignored.  Output
    columns whose matching category is not present in any input row
    of the group are filled with nulls.
   </para>
________________________________________________________-->
   <para>
    <function>crosstab</function>函数为具有相同<structfield>row_name</structfield>值的输入行形成的每一个连续分组
    产生一个输出行。输出的<structfield>row_name</structfield>列外加任意一个<quote>extra</quote>列都是从分组的
    第一行复制而来。输出的<structfield>value</structfield>列被使用具有匹配的<structfield>category</structfield>值的行中的
    <structfield>value</structfield>域填充。如果一个行的<structfield>category</structfield>不匹配<parameter>category_sql</parameter>
    查询的任何输出，它的<structfield>value</structfield>会被忽略。匹配的分类不出现于分组中任何输出行中的的
    输出列会被用空值填充。
   </para>
<!-- pgdoc-cn_end sig_en=27cc597d2e94f2cc66c4856b07608211 -->

<!-- pgdoc-cn_start sig_en=59b83d48fd3181022b3f29f73c44a2f0 sig_cn_org=None source=14.1 
   <para>
    In practice the <parameter>source_sql</parameter> query should always
    specify <literal>ORDER BY 1</literal> to ensure that values with the same
    <structfield>row_name</structfield> are brought together.  However,
    ordering of the categories within a group is not important.
    Also, it is essential to be sure that the order of the
    <parameter>category_sql</parameter> query's output matches the specified
    output column order.
   </para>
________________________________________________________-->
   <para>
    事实上，<parameter>source_sql</parameter>查询应该总是指定<literal>ORDER BY 1</literal>来保证
    具有相同<structfield>row_name</structfield>的值会被放在一起。但是，一个分组内分类的顺序并不重要。
    还有，确保<parameter>category_sql</parameter>查询的输出的顺序与指定的输出列顺序匹配是非常重要的。
   </para>
<!-- pgdoc-cn_end sig_en=59b83d48fd3181022b3f29f73c44a2f0 -->

<!-- pgdoc-cn_start sig_en=2670a414db2caaad916d330ada73309b sig_cn_org=None source=14.1 
   <para>
    Here are two complete examples:
<programlisting>
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
</programlisting>

<programlisting>
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这里有两个完整的例子：
<programlisting>
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
</programlisting>

<programlisting>
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=2670a414db2caaad916d330ada73309b -->

<!-- pgdoc-cn_start sig_en=d05335e739b2c509e042e9c72c39225a sig_cn_org=None source=14.1 
   <para>
    You can create predefined functions to avoid having to write out
    the result column names and types in each query.  See the examples
    in the previous section.  The underlying C function for this form
    of <function>crosstab</function> is named <literal>crosstab_hash</literal>.
   </para>
________________________________________________________-->
   <para>
    你可以创建预定义的函数来避免在每个查询中都必须写出结果列的名称和类型。请参考前一节中的例子。
    用于这种形式的<function>crosstab</function>的底层 C 函数被命名为<literal>crosstab_hash</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=d05335e739b2c509e042e9c72c39225a -->

  </sect3>

  <sect3>
   <title><function>connectby</function></title>

<!-- pgdoc-cn_start sig_en=a54820153a6228fd44bd37752ebe5ac7 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>connectby</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>connectby</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a54820153a6228fd44bd37752ebe5ac7 -->

<!-- pgdoc-cn_start sig_en=e184384d0969604c57034d61b1aab375 sig_cn_org=None source=14.1 
<synopsis>
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
</synopsis>
________________________________________________________-->
<synopsis>
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
</synopsis>
<!-- pgdoc-cn_end sig_en=e184384d0969604c57034d61b1aab375 -->

<!-- pgdoc-cn_start sig_en=43c468262c1be1e7acc9b384267437f2 sig_cn_org=None source=14.1 
   <para>
    The <function>connectby</function> function produces a display of hierarchical
    data that is stored in a table.  The table must have a key field that
    uniquely identifies rows, and a parent-key field that references the
    parent (if any) of each row.  <function>connectby</function> can display the
    sub-tree descending from any row.
   </para>
________________________________________________________-->
   <para>
    <function>connectby</function>函数产生存储在一个表中的层次数据的显示。该表必须具有一个用以
    唯一标识行的键域，以及一个父亲键域用来引用其父亲（如果有）。<function>connectby</function>能
    显示从任意行开始向下的子树。
   </para>
<!-- pgdoc-cn_end sig_en=43c468262c1be1e7acc9b384267437f2 -->

<!-- pgdoc-cn_start sig_en=bd007ff7feae636cb67b5dd5bc55d68a sig_cn_org=None source=14.1 
   <para>
    <xref linkend="tablefunc-connectby-parameters"/> explains the
    parameters.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="tablefunc-connectby-parameters"/>解释了参数。
   </para>
<!-- pgdoc-cn_end sig_en=bd007ff7feae636cb67b5dd5bc55d68a -->

   <table id="tablefunc-connectby-parameters">
<!-- pgdoc-cn_start sig_en=1d0839e3a58c9660e9ea1201624edb44 sig_cn_org=None source=14.1 
    <title><function>connectby</function> Parameters</title>
________________________________________________________-->
    <title><function>connectby</function> 参数</title>
<!-- pgdoc-cn_end sig_en=1d0839e3a58c9660e9ea1201624edb44 -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=f1c6896cac36ed9c10991ac1c63f10e7 sig_cn_org=None source=14.1 
      <row>
       <entry>Parameter</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>参数</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f1c6896cac36ed9c10991ac1c63f10e7 -->
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=dfdc28dc641d7d8fd0ae5698bb3f3e46 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>relname</parameter></entry>
       <entry>Name of the source relation</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>relname</parameter></entry>
       <entry>源关系的名称</entry>
      </row>
<!-- pgdoc-cn_end sig_en=dfdc28dc641d7d8fd0ae5698bb3f3e46 -->
<!-- pgdoc-cn_start sig_en=9f35098b89d5dd4c2ac22b8d999fd407 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>keyid_fld</parameter></entry>
       <entry>Name of the key field</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>keyid_fld</parameter></entry>
       <entry>键域的名称</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9f35098b89d5dd4c2ac22b8d999fd407 -->
<!-- pgdoc-cn_start sig_en=8424b0abadb8f0f3b9962bc09bcb6e88 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>parent_keyid_fld</parameter></entry>
       <entry>Name of the parent-key field</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>parent_keyid_fld</parameter></entry>
       <entry>父亲键域的名称</entry>
      </row>
<!-- pgdoc-cn_end sig_en=8424b0abadb8f0f3b9962bc09bcb6e88 -->
<!-- pgdoc-cn_start sig_en=730006f8b36c132e8b9fbb317960c3e0 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>orderby_fld</parameter></entry>
       <entry>Name of the field to order siblings by (optional)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>orderby_fld</parameter></entry>
       <entry>用于排序兄弟的域的名称（可选）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=730006f8b36c132e8b9fbb317960c3e0 -->
<!-- pgdoc-cn_start sig_en=9dc63e91606fec2de084a70936971ff3 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>start_with</parameter></entry>
       <entry>Key value of the row to start at</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>start_with</parameter></entry>
       <entry>起始行的键值</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9dc63e91606fec2de084a70936971ff3 -->
<!-- pgdoc-cn_start sig_en=b004639c2d10b909652c578ce1e51185 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>max_depth</parameter></entry>
       <entry>Maximum depth to descend to, or zero for unlimited depth</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>max_depth</parameter></entry>
       <entry>要向下的最大深度，零表示无限深度</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b004639c2d10b909652c578ce1e51185 -->
<!-- pgdoc-cn_start sig_en=56c861190f43f11adaf0369c3313a8e5 sig_cn_org=None source=14.1 
      <row>
       <entry><parameter>branch_delim</parameter></entry>
       <entry>String to separate keys with in branch output (optional)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><parameter>branch_delim</parameter></entry>
       <entry>在分支输出中用于分隔键值的字符串（可选）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=56c861190f43f11adaf0369c3313a8e5 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=1237f992aeb6a410d7d7244600727e13 sig_cn_org=None source=14.1 
    <para>
     The key and parent-key fields can be any data type, but they must be
     the same type.  Note that the <parameter>start_with</parameter> value must be
     entered as a text string, regardless of the type of the key field.
    </para>
________________________________________________________-->
    <para>
     键域和父亲键域可以是任意数据类型，但是它们必须是同一类型。
     注意<parameter>start_with</parameter>值必须作为一个文本串被输入，而不管键域的类型如何。
    </para>
<!-- pgdoc-cn_end sig_en=1237f992aeb6a410d7d7244600727e13 -->

<!-- pgdoc-cn_start sig_en=1574812b35bcbb24451af8de4b7df521 sig_cn_org=None source=14.1 
    <para>
     The <function>connectby</function> function is declared to return <type>setof
     record</type>, so the actual names and types of the output columns must be
     defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
     statement, for example:
    </para>
________________________________________________________-->
    <para>
     <function>connectby</function>函数被声明为返回<type>setof record</type>，因此输出列的实际名称和类型
    就必须在调用的<command>SELECT</command>语句的<literal>FROM</literal>子句中被定义，例如：
    </para>
<!-- pgdoc-cn_end sig_en=1574812b35bcbb24451af8de4b7df521 -->

<!-- pgdoc-cn_start sig_en=88ff12c713d13631216c314cf5514e9a sig_cn_org=None source=14.1 
<programlisting>
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);
</programlisting>
________________________________________________________-->
<programlisting>
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);
</programlisting>
<!-- pgdoc-cn_end sig_en=88ff12c713d13631216c314cf5514e9a -->

<!-- pgdoc-cn_start sig_en=8d4294e84f65eb65597d137d1c3b32ee sig_cn_org=None source=14.1 
    <para>
     The first two output columns are used for the current row's key and
     its parent row's key; they must match the type of the table's key field.
     The third output column is the depth in the tree and must be of type
     <type>integer</type>.  If a <parameter>branch_delim</parameter> parameter was
     given, the next output column is the branch display and must be of type
     <type>text</type>.  Finally, if an <parameter>orderby_fld</parameter>
     parameter was given, the last output column is a serial number, and must
     be of type <type>integer</type>.
    </para>
________________________________________________________-->
    <para>
     前两个输出列被用于当前行的键和其父亲行的键，它们必须匹配该表的键域的类型。第三个输出行是该树中的深度，
     并且必须是类型<type>integer</type>。如果给定了一个<parameter>branch_delim</parameter>参数，下一个输出列
     就是分支显示并且必须是类型<type>text</type>。最后，如果给出了一个<parameter>orderby_fld</parameter>参数，
     最后一个输出列是一个序号，并且必须是类型<type>integer</type>。
    </para>
<!-- pgdoc-cn_end sig_en=8d4294e84f65eb65597d137d1c3b32ee -->

<!-- pgdoc-cn_start sig_en=e139b151b6699e0a9341a46f2c345340 sig_cn_org=None source=14.1 
    <para>
     The <quote>branch</quote> output column shows the path of keys taken to
     reach the current row.  The keys are separated by the specified
     <parameter>branch_delim</parameter> string.  If no branch display is
     wanted, omit both the <parameter>branch_delim</parameter> parameter
     and the branch column in the output column list.
    </para>
________________________________________________________-->
    <para>
     <quote>branch</quote>输出列显示了用于到达当前行的由键构成的路径。其中的键用指定的<parameter>branch_delim</parameter>
     字符串分隔开。如果不需要分支显示，可以在输出列列表中忽略<parameter>branch_delim</parameter>参数和分支列。
    </para>
<!-- pgdoc-cn_end sig_en=e139b151b6699e0a9341a46f2c345340 -->

<!-- pgdoc-cn_start sig_en=3c9fadc2aba99c6ddc8a6959d29cbfa9 sig_cn_org=None source=14.1 
    <para>
     If the ordering of siblings of the same parent is important,
     include the <parameter>orderby_fld</parameter> parameter to
     specify which field to order siblings by.  This field can be of any
     sortable data type.  The output column list must include a final
     integer serial-number column, if and only if
     <parameter>orderby_fld</parameter> is specified.
    </para>
________________________________________________________-->
    <para>
     如果同一父亲的子女之间的顺序很重要，可以包括<parameter>orderby_fld</parameter>参数以指定用哪个域对兄弟排序。
     这个域可以是任何可排序数据类型。当且仅当<parameter>orderby_fld</parameter>被指定时，输出列列表必须包括一个
     最终的整数序号列。
    </para>
<!-- pgdoc-cn_end sig_en=3c9fadc2aba99c6ddc8a6959d29cbfa9 -->

<!-- pgdoc-cn_start sig_en=6adee9da8c268a6c063548d16afa0d12 sig_cn_org=None source=14.1 
    <para>
     The parameters representing table and field names are copied as-is
     into the SQL queries that <function>connectby</function> generates internally.
     Therefore, include double quotes if the names are mixed-case or contain
     special characters.  You may also need to schema-qualify the table name.
    </para>
________________________________________________________-->
    <para>
     表示表和列名的参数会被原样复制到<function>connectby</function>内部生成的 SQL 查询中。
     因此，如果名称是大小写混合或者包含特殊字符，应包括双引号。你也可能需要用模式限定表名。
    </para>
<!-- pgdoc-cn_end sig_en=6adee9da8c268a6c063548d16afa0d12 -->

<!-- pgdoc-cn_start sig_en=baa6b80985e350e60d83b335cca18c19 sig_cn_org=None source=14.1 
    <para>
     In large tables, performance will be poor unless there is an index on
     the parent-key field.
    </para>
________________________________________________________-->
    <para>
     在大型的表中，除非在父亲键域上有索引，否则性能会很差。
    </para>
<!-- pgdoc-cn_end sig_en=baa6b80985e350e60d83b335cca18c19 -->

<!-- pgdoc-cn_start sig_en=9fb7bdd514834da9c7ea12907fa0035a sig_cn_org=None source=14.1 
    <para>
     It is important that the <parameter>branch_delim</parameter> string
     not appear in any key values, else <function>connectby</function> may incorrectly
     report an infinite-recursion error.  Note that if
     <parameter>branch_delim</parameter> is not provided, a default value
     of <literal>~</literal> is used for recursion detection purposes.
     <!-&minus; That pretty well sucks.  FIXME -&minus;>
    </para>
________________________________________________________-->
    <para>
     <parameter>branch_delim</parameter>字符串不出现在任何键值中是很重要的，否则<function>connectby</function>可能会错误地
     报告一个无限递归错误。注意如果没有提供<parameter>branch_delim</parameter>，将用一个默认值<literal>~</literal>来进行递归检测。
     <!-- That pretty well sucks.  FIXME -->
    </para>
<!-- pgdoc-cn_end sig_en=9fb7bdd514834da9c7ea12907fa0035a -->

<!-- pgdoc-cn_start sig_en=b8b0e76f7ca7fc43c2e37881c1284c4f sig_cn_org=None source=14.1 
    <para>
     Here is an example:
<programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-&minus; with branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-&minus; without branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-&minus; with branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-&minus; without branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- 带有分支，但没有 orderby_fld （不保证结果的顺序）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- 没有分支，也没有 orderby_fld （不保证结果的顺序）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- 有分支，有 orderby_fld （注意 row5 在 row4 前面）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- 没有分支，有 orderby_fld （注意 row5 在 row4 前面）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=b8b0e76f7ca7fc43c2e37881c1284c4f -->
   </sect3>

 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=4cfae8ddf9b6dcc33177b633e0f1dcfc sig_cn_org=None source=14.1 
  <title>Author</title>
________________________________________________________-->
  <title>作者</title>
<!-- pgdoc-cn_end sig_en=4cfae8ddf9b6dcc33177b633e0f1dcfc -->

<!-- pgdoc-cn_start sig_en=b575e20c57df8a55681b14200d998bbb sig_cn_org=None source=14.1 
  <para>
   Joe Conway
  </para>
________________________________________________________-->
  <para>
   Joe Conway
  </para>
<!-- pgdoc-cn_end sig_en=b575e20c57df8a55681b14200d998bbb -->

 </sect2>

</sect1>
