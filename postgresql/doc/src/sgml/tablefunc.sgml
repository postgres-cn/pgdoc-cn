<!-- doc/src/sgml/tablefunc.sgml -->

<sect1 id="tablefunc" xreflabel="tablefunc">
<!--==========================orignal english content==========================
 <title>tablefunc</title>
____________________________________________________________________________-->
 <title>tablefunc</title>

<!--==========================orignal english content==========================
 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>tablefunc</> module includes various functions that return
  tables (that is, multiple rows).  These functions are useful both in their
  own right and as examples of how to write C functions that return
  multiple rows.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>tablefunc</>模块包括多个返回表（也就是多行）的函数。这些函数都很有用，并且也可以作为如何编写返回多行的 C 函数的例子。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>Functions Provided</title>
____________________________________________________________________________-->
  <title>所提供的函数</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="tablefunc-functions"> shows the functions provided
   by the <filename>tablefunc</filename> module.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="tablefunc-functions">显示了<filename>tablefunc</filename>模块提供的函数。
  </para>

  <table id="tablefunc-functions">
<!--==========================orignal english content==========================
   <title><filename>tablefunc</> Functions</title>
____________________________________________________________________________-->
   <title><filename>tablefunc</>函数</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Returns</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><function>normal_rand(int numvals, float8 mean, float8 stddev)</function></entry>
      <entry><type>setof float8</></entry>
      <entry>
       Produces a set of normally distributed random values
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>normal_rand(int numvals, float8 mean, float8 stddev)</function></entry>
      <entry><type>setof float8</></entry>
      <entry>
       产生一个正态分布的随机值集合
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><function>crosstab(text sql)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       Produces a <quote>pivot table</> containing
       row names plus <replaceable>N</> value columns, where
       <replaceable>N</> is determined by the row type specified in the calling
       query
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>crosstab(text sql)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       产生一个包含行名称外加<replaceable>N</>个值列的<quote>数据透视表</>，其中<replaceable>N</>由调用查询中指定的行类型决定
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><function>crosstab<replaceable>N</>(text sql)</function></entry>
      <entry><type>setof table_crosstab_<replaceable>N</></></entry>
      <entry>
       Produces a <quote>pivot table</> containing
       row names plus <replaceable>N</> value columns.
       <function>crosstab2</>, <function>crosstab3</>, and
       <function>crosstab4</> are predefined, but you can create additional
       <function>crosstab<replaceable>N</></> functions as described below
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>crosstab<replaceable>N</>(text sql)</function></entry>
      <entry><type>setof table_crosstab_<replaceable>N</></></entry>
      <entry>
       产生一个包含行名称外加<replaceable>N</>个值列的<quote>数据透视表</>。<function>crosstab2</>、<function>crosstab3</>和<function>crosstab4</>是被预定义的，但你可以按照下文所述创建额外的<function>crosstab<replaceable>N</></>函数
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><function>crosstab(text source_sql, text category_sql)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       Produces a <quote>pivot table</>
       with the value columns specified by a second query
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>crosstab(text source_sql, text category_sql)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       产生一个<quote>数据透视表</>，其值列由第二个查询指定
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><function>crosstab(text sql, int N)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       <para>Obsolete version of <function>crosstab(text)</>.
        The parameter <replaceable>N</> is now ignored, since the number of
        value columns is always determined by the calling query
       </para>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>crosstab(text sql, int N)</function></entry>
      <entry><type>setof record</></entry>
      <entry>
       <para><function>crosstab(text)</>的废弃版本。参数<replaceable>N</>现在被忽略，因为值列的数量总是由调用查询所决定
       </para>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>
       <function>
        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld ], text start_with, int max_depth
        [, text branch_delim ])
       </function>
       <indexterm><primary>connectby</primary></indexterm>
      </entry>
      <entry><type>setof record</></entry>
      <entry>
       Produces a representation of a hierarchical tree structure
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <function>
        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld ], text start_with, int max_depth
        [, text branch_delim ])
       </function>
       <indexterm><primary>connectby</primary></indexterm>
      </entry>
      <entry><type>setof record</></entry>
      <entry>
       产生一个层次树结构的表达
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>normal_rand</function></title>
____________________________________________________________________________-->
   <title><function>normal_rand</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>normal_rand</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>normal_rand</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
</synopsis>
____________________________________________________________________________-->
<synopsis>
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
</synopsis>

<!--==========================orignal english content==========================
    <para>
     <function>normal_rand</> produces a set of normally distributed random
     values (Gaussian distribution).
    </para>
____________________________________________________________________________-->
    <para>
     <function>normal_rand</>产生一个正态分布随机值（高斯分布）的集合。
    </para>

<!--==========================orignal english content==========================
    <para>
     <parameter>numvals</parameter> is the number of values to be returned
     from the function. <parameter>mean</parameter> is the mean of the normal
     distribution of values and <parameter>stddev</parameter> is the standard
     deviation of the normal distribution of values.
    </para>
____________________________________________________________________________-->
    <para>
     <parameter>numvals</parameter>是从该函数返回的值的数量。<parameter>mean</parameter>是值的正态分布的均值而<parameter>stddev</parameter>是值的正态分布的标准偏差。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example, this call requests 1000 values with a mean of 5 and a
     standard deviation of 3:
    </para>
____________________________________________________________________________-->
    <para>
     例如，这个调用请求 1000 个值，它们具有均值 5 和标准偏差 3：
    </para>

<!--==========================orignal english content==========================
<screen>
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
</screen>
____________________________________________________________________________-->
<screen>
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
</screen>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>crosstab(text)</function></title>
____________________________________________________________________________-->
   <title><function>crosstab(text)</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
crosstab(text sql)
crosstab(text sql, int N)
</synopsis>
____________________________________________________________________________-->
<synopsis>
crosstab(text sql)
crosstab(text sql, int N)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>crosstab</> function is used to produce <quote>pivot</>
    displays, wherein data is listed across the page rather than down.
    For example, we might have data like
<programlisting>
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
</programlisting>
    which we wish to display like
<programlisting>
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
</programlisting>
    The <function>crosstab</> function takes a text parameter that is a SQL
    query producing raw data formatted in the first way, and produces a table
    formatted in the second way.
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>函数被用来产生<quote>pivot</>显示，在其中数据被横布在页面上而不是直接向下列举。例如，我们可能有这样的数据
<programlisting>
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
</programlisting>
    而我们希望显示成这样
<programlisting>
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
</programlisting>
    <function>crosstab</>函数会采用一个文本参数，该文本是一个 SQL 查询，它产生按照第一种方式格式化的原始数据，并且产生以第二种方式格式化的一个表。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <parameter>sql</parameter> parameter is a SQL statement that produces
    the source set of data. This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column.  <parameter>N</parameter> is an
    obsolete parameter, ignored if supplied (formerly this had to match the
    number of output value columns, but now that is determined by the
    calling query).
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>sql</parameter>参数是一个产生数据的源集合的 SQL 语句。这个语句必须返回一个<structfield>row_name</structfield>列、一个<structfield>category</structfield>列和一个<structfield>value</structfield>列。<parameter>N</parameter>是一个废弃参数，即使提供也会被忽略（之前这必须匹配输出值列的数目，但是现在这由调用查询决定了）。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, the provided query might produce a set something like:
<programlisting>
 row_name    cat    value
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，所提供的查询可能会产生这样的一个集合：
<programlisting>
 row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>crosstab</> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</> clause of the calling <command>SELECT</>
    statement, for example:
<programlisting>
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
</programlisting>
    This example produces a set something like:
<programlisting>
           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
  row1        val1         val2
  row2        val5         val6
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>函数被声明为返回<type>setof record</type>，
    因此输出列的实际名称和类型必须定义在调用的<command>SELECT</>语句的<literal>FROM</>子句中，例如：
<programlisting>
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
</programlisting>
    这个例子产生这样一个集合：
<programlisting>
           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
----------+------------+------------
  row1        val1         val2
  row2        val5         val6
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>FROM</> clause must define the output as one
    <structfield>row_name</> column (of the same data type as the first result
    column of the SQL query) followed by N <structfield>value</> columns
    (all of the same data type as the third result column of the SQL query).
    You can set up as many output value columns as you wish.  The names of the
    output columns are up to you.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>FROM</>子句必须把输出定义为一个<structfield>row_name</>列
    （具有 SQL 查询的第一个结果列的相同数据类型），其后跟随着 N 个<structfield>value</>列
    （都具有 SQL 查询的第三个结果列的相同数据类型）。你可以按照你的意愿设置任意多的输出值列。
    而输出列的名称取决于你。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>crosstab</> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  It fills the output
    <structfield>value</> columns, left to right, with the
    <structfield>value</structfield> fields from these rows.  If there
    are fewer rows in a group than there are output <structfield>value</>
    columns, the extra output columns are filled with nulls; if there are
    more rows, the extra input rows are skipped.
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>函数为具有相同<structfield>row_name</structfield>值的
    输入行的每一个连续分组产生一个输出行。它使用来自这些行的<structfield>值</structfield>域
    从左至右填充输出的<structfield>值</>列。如果一个分组中的行比输出<structfield>值</structfield>列少，
    多余的输出列将被用空值填充。如果行更多，则多余的输入行会被跳过。
   </para>

<!--==========================orignal english content==========================
   <para>
    In practice the SQL query should always specify <literal>ORDER BY 1,2</>
    to ensure that the input rows are properly ordered, that is, values with
    the same <structfield>row_name</structfield> are brought together and
    correctly ordered within the row.  Notice that <function>crosstab</>
    itself does not pay any attention to the second column of the query
    result; it's just there to be ordered by, to control the order in which
    the third-column values appear across the page.
   </para>
____________________________________________________________________________-->
   <para>
    事实上，SQL 查询应该总是指定<literal>ORDER BY 1,2</>来保证输入行被正确地排序，
    也就是说具有相同<structfield>row_name</structfield>的值会被放在一起并且在行内
    被正确地排序。注意<function>crosstab</>本身并不关注查询结果的第二列，它放在那里
    只是为了被排序，以便控制出现在页面上的第三列值的顺序。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is a complete example:
<programlisting>
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这是一个完整的例子：
<programlisting>
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    You can avoid always having to write out a <literal>FROM</> clause to
    define the output columns, by setting up a custom crosstab function that
    has the desired output row type wired into its definition.  This is
    described in the next section.  Another possibility is to embed the
    required <literal>FROM</> clause in a view definition.
   </para>
____________________________________________________________________________-->
   <para>
    你可以避免总是要写出一个<literal>FROM</>子句来定义输出列，
    方法是设置一个在其定义中硬编码所期望的输出行类型的自定义 crosstab 函数。
    这会在下一节中描述。另一种可能性是在一个视图定义中嵌入所需的<literal>FROM</>子句。
   </para>
   
   <note>
<!--==========================orignal english content==========================
    <para>
     See also the <command><link linkend="APP-PSQL-meta-commands-crosstabview">\crosstabview</link></command>
     command in <application>psql</>, which provides functionality similar
     to <function>crosstab()</>.
    </para>
____________________________________________________________________________-->
    <para>
     另见<application>psql</>中的
     <command><link linkend="APP-PSQL-meta-commands-crosstabview">\crosstabview</link></command>
     命令，它提供了和<function>crosstab()</>类似的功能。
    </para>
   </note>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>crosstab<replaceable>N</>(text)</function></title>
____________________________________________________________________________-->
   <title><function>crosstab<replaceable>N</>(text)</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
crosstab<replaceable>N</>(text sql)
</synopsis>
____________________________________________________________________________-->
<synopsis>
crosstab<replaceable>N</>(text sql)
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>crosstab<replaceable>N</></> functions are examples of how
     to set up custom wrappers for the general <function>crosstab</> function,
     so that you need not write out column names and types in the calling
     <command>SELECT</> query.  The <filename>tablefunc</> module includes
     <function>crosstab2</>, <function>crosstab3</>, and
     <function>crosstab4</>, whose output row types are defined as
    </para>
____________________________________________________________________________-->
    <para>
     <function>crosstab<replaceable>N</></>系列函数是如何为普通<function>crosstab</>
     函数设置自定义包装器的例子，这样你不需要在调用的<command>SELECT</>查询中
     写出列名和类型。<filename>tablefunc</>模块包括<function>crosstab2</>、
     <function>crosstab3</>以及<function>crosstab4</>，它们的输入行类型被定义为：
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
</programlisting>

<!--==========================orignal english content==========================
    <para>
     Thus, these functions can be used directly when the input query produces
     <structfield>row_name</> and <structfield>value</> columns of type
     <type>text</>, and you want 2, 3, or 4 output values columns.
     In all other ways they behave exactly as described above for the
     general <function>crosstab</> function.
    </para>
____________________________________________________________________________-->
    <para>
     因此，当输入查询产生类型为<type>text</>的列<structfield>row_name</>和<structfield>value</>
     并且想要 2、3 或 4 个输出值列时，这些函数可以被直接使用。在所有其他方法中，它们的行为都和上面的
     一般<function>crosstab</>函数完全相同。
    </para>

<!--==========================orignal english content==========================
    <para>
     For instance, the example given in the previous section would also
     work as
<programlisting>
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     例如，前一节给出的例子也可以这样来做
<programlisting>
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     These functions are provided mostly for illustration purposes. You
     can create your own return types and functions based on the
     underlying <function>crosstab()</> function.  There are two ways
     to do it:

    <itemizedlist>
     <listitem>
      <para>
       Create a composite type describing the desired output columns,
       similar to the examples in
       <filename>contrib/tablefunc/tablefunc-&minus;1.0.sql</>.
       Then define a
       unique function name accepting one <type>text</> parameter and returning
       <type>setof your_type_name</>, but linking to the same underlying
       <function>crosstab</> C function.  For example, if your source data
       produces row names that are <type>text</>, and values that are
       <type>float8</>, and you want 5 value columns:
<programlisting>
CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       Use <literal>OUT</> parameters to define the return type implicitly.
       The same example could also be done this way:
<programlisting>
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     这些函数主要是出于举例的目的而提供。你可以基于底层的<function>crosstab()</>函数
     创建你自己的返回类型和函数。有两种方法来做：

    <itemizedlist>
     <listitem>
      <para>
       与<filename>contrib/tablefunc/tablefunc--1.0.sql</>中相似，创建一个组合类型来描述所期望的输出列。
       然后定义一个唯一的函数名，它接受一个<type>text</>参数并且返回<type>setof your_type_name</>，但是链接到同样的
       底层<function>crosstab</> C 函数。例如，如果你的源数据产生为<type>text</>类型的行名称，并且值是<type>float8</>，
       并且你想要 5 个值列：
<programlisting>
CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       使用<literal>OUT</>参数来隐式定义返回类型。同样的例子也可以这样来做：
<programlisting>
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
    </para>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>crosstab(text, text)</function></title>
____________________________________________________________________________-->
   <title><function>crosstab(text, text)</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>crosstab</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
crosstab(text source_sql, text category_sql)
</synopsis>
____________________________________________________________________________-->
<synopsis>
crosstab(text source_sql, text category_sql)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The main limitation of the single-parameter form of <function>crosstab</>
    is that it treats all values in a group alike, inserting each value into
    the first available column.  If you want the value
    columns to correspond to specific categories of data, and some groups
    might not have data for some of the categories, that doesn't work well.
    The two-parameter form of <function>crosstab</> handles this case by
    providing an explicit list of the categories corresponding to the
    output columns.
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>的单一参数形式的主要限制是它把一个组中的所有值都视作相似，
    并且把每一个值插入到第一个可用的列中。如果你想要值列对应于特定的数据分类，并且
    某些分组可能没有关于某些分类的数据，这样的形式就无法工作。<function>crosstab</>的双参数形式
    通过提供一个对应于输出列的显式分类列表来处理这种情况。
   </para>

<!--==========================orignal english content==========================
   <para>
    <parameter>source_sql</parameter> is a SQL statement that produces the
    source set of data.  This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column. It may also have one or more
    <quote>extra</quote> columns.
    The <structfield>row_name</structfield> column must be first. The
    <structfield>category</structfield> and <structfield>value</structfield>
    columns must be the last two columns, in that order.  Any columns between
    <structfield>row_name</structfield> and
    <structfield>category</structfield> are treated as <quote>extra</>.
    The <quote>extra</quote> columns are expected to be the same for all rows
    with the same <structfield>row_name</structfield> value.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>source_sql</parameter>是一个产生源数据集的 SQL 语句。这个语句必须返回一个
    <structfield>row_name</structfield>列、一个<structfield>category</structfield>列以及一个<structfield>value</structfield>列。
    也可以有一个或者多个<quote>extra</quote>列。<structfield>row_name</structfield>列必须是第一个。
    <structfield>category</structfield>和<structfield>value</structfield>列必须是按照这个顺序的最后两个列。
    <structfield>row_name</structfield>和<structfield>category</structfield>之间的任何列都被视作<quote>extra</>。
    对于具有相同<structfield>row_name</structfield>值的所有行，其<quote>extra</quote>列都应该相同。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, <parameter>source_sql</parameter> might produce a set
    something like:
<programlisting>
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，<parameter>source_sql</parameter>可能产生一组这样的东西：
<programlisting>
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
----------+------------+-----+---------
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <parameter>category_sql</parameter> is a SQL statement that produces
    the set of categories. This statement must return only one column.
    It must produce at least one row, or an error will be generated.
    Also, it must not produce duplicate values, or an error will be
    generated.  <parameter>category_sql</parameter> might be something like:

<programlisting>
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -&minus;-&minus;-&minus;-
    cat1
    cat2
    cat3
    cat4
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>category_sql</parameter>是一个产生分类集合的 SQL 语句。这个语句必须只返回一列。
    它必须产生至少一行，否则会生成一个错误。还有，它不能产生重复值，否则会生成一个错误。<parameter>category_sql</parameter>可能是这样的：

<programlisting>
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>crosstab</> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</> clause of the calling <command>SELECT</>
    statement, for example:

<programlisting>
SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>函数被声明为返回<type>setof record</type>，这样输出列的实际名称和类型
    就必须在调用的<command>SELECT</>语句的<literal>FROM</>子句中被定义，例如：

<programlisting>
SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    This will produce a result something like:
<programlisting>
                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这将产生这样的结果：
<programlisting>
                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
---------+-------+------+------+------+------
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>FROM</> clause must define the proper number of output
    columns of the proper data types.  If there are <replaceable>N</>
    columns in the <parameter>source_sql</> query's result, the first
    <replaceable>N</>-2 of them must match up with the first
    <replaceable>N</>-2 output columns.  The remaining output columns
    must have the type of the last column of the <parameter>source_sql</>
    query's result, and there must be exactly as many of them as there
    are rows in the <parameter>category_sql</parameter> query's result.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>FROM</>子句必须定义正确数量的输出列以及正确的数据类型。如果在<parameter>source_sql</>
    查询的结果中有<replaceable>N</>列，其中的前<replaceable>N</>-2 列必须匹配前<replaceable>N</>-2
     个输出列。剩余的输出列必须具有<parameter>source_sql</>查询结果的最后一列的类型，并且并且它们的数量
     必须正好和<parameter>source_sql</>查询结果中的行数相同。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>crosstab</> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  The output
    <structfield>row_name</structfield> column, plus any <quote>extra</>
    columns, are copied from the first row of the group.  The output
    <structfield>value</> columns are filled with the
    <structfield>value</structfield> fields from rows having matching
    <structfield>category</> values.  If a row's <structfield>category</>
    does not match any output of the <parameter>category_sql</parameter>
    query, its <structfield>value</structfield> is ignored.  Output
    columns whose matching category is not present in any input row
    of the group are filled with nulls.
   </para>
____________________________________________________________________________-->
   <para>
    <function>crosstab</>函数为具有相同<structfield>row_name</structfield>值的输入行形成的每一个连续分组
    产生一个输出行。输出的<structfield>row_name</structfield>列外加任意一个<quote>extra</>列都是从分组的
    第一行复制而来。输出的<structfield>value</>列被使用具有匹配的<structfield>category</>值的行中的
    <structfield>value</structfield>域填充。如果一个行的<structfield>category</>不匹配<parameter>category_sql</parameter>
    查询的任何输出，它的<structfield>value</structfield>会被忽略。匹配的分类不出现于分组中任何输出行中的的
    输出列会被用空值填充。
   </para>

<!--==========================orignal english content==========================
   <para>
    In practice the <parameter>source_sql</parameter> query should always
    specify <literal>ORDER BY 1</> to ensure that values with the same
    <structfield>row_name</structfield> are brought together.  However,
    ordering of the categories within a group is not important.
    Also, it is essential to be sure that the order of the
    <parameter>category_sql</parameter> query's output matches the specified
    output column order.
   </para>
____________________________________________________________________________-->
   <para>
    事实上，<parameter>source_sql</parameter>查询应该总是指定<literal>ORDER BY 1</>来保证
    具有相同<structfield>row_name</structfield>的值会被放在一起。但是，一个分组内分类的顺序并不重要。
    还有，确保<parameter>category_sql</parameter>查询的输出的顺序与指定的输出列顺序匹配是非常重要的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here are two complete examples:
<programlisting>
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
</programlisting>

<programlisting>
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这里有两个完整的例子：
<programlisting>
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
</programlisting>

<programlisting>
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    You can create predefined functions to avoid having to write out
    the result column names and types in each query.  See the examples
    in the previous section.  The underlying C function for this form
    of <function>crosstab</> is named <literal>crosstab_hash</>.
   </para>
____________________________________________________________________________-->
   <para>
    你可以创建预定义的函数来避免在每个查询中都必须写出结果列的名称和类型。请参考前一节中的例子。
    用于这种形式的<function>crosstab</>的底层 C 函数被命名为<literal>crosstab_hash</>。
   </para>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>connectby</function></title>
____________________________________________________________________________-->
   <title><function>connectby</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>connectby</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>connectby</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
</synopsis>
____________________________________________________________________________-->
<synopsis>
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>connectby</> function produces a display of hierarchical
    data that is stored in a table.  The table must have a key field that
    uniquely identifies rows, and a parent-key field that references the
    parent (if any) of each row.  <function>connectby</> can display the
    sub-tree descending from any row.
   </para>
____________________________________________________________________________-->
   <para>
    <function>connectby</>函数产生存储在一个表中的层次数据的显示。该表必须具有一个用以
    唯一标识行的键域，以及一个父亲键域用来引用其父亲（如果有）。<function>connectby</>能
    显示从任意行开始向下的子树。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="tablefunc-connectby-parameters"> explains the
    parameters.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="tablefunc-connectby-parameters">解释了参数。
   </para>

   <table id="tablefunc-connectby-parameters">
<!--==========================orignal english content==========================
    <title><function>connectby</function> Parameters</title>
____________________________________________________________________________-->
    <title><function>connectby</function> 参数</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Parameter</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>参数</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>relname</parameter></entry>
       <entry>Name of the source relation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>relname</parameter></entry>
       <entry>源关系的名称</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>keyid_fld</parameter></entry>
       <entry>Name of the key field</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>keyid_fld</parameter></entry>
       <entry>键域的名称</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>parent_keyid_fld</parameter></entry>
       <entry>Name of the parent-key field</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>parent_keyid_fld</parameter></entry>
       <entry>父亲键域的名称</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>orderby_fld</parameter></entry>
       <entry>Name of the field to order siblings by (optional)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>orderby_fld</parameter></entry>
       <entry>用于排序兄弟的域的名称（可选）</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>start_with</parameter></entry>
       <entry>Key value of the row to start at</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>start_with</parameter></entry>
       <entry>起始行的键值</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>max_depth</parameter></entry>
       <entry>Maximum depth to descend to, or zero for unlimited depth</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>max_depth</parameter></entry>
       <entry>要向下的最大深度，零表示无限深度</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><parameter>branch_delim</parameter></entry>
       <entry>String to separate keys with in branch output (optional)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><parameter>branch_delim</parameter></entry>
       <entry>在分支输出中用于分隔键值的字符串（可选）</entry>
      </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
    <para>
     The key and parent-key fields can be any data type, but they must be
     the same type.  Note that the <parameter>start_with</> value must be
     entered as a text string, regardless of the type of the key field.
    </para>
____________________________________________________________________________-->
    <para>
     键域和父亲键域可以是任意数据类型，但是它们必须是同一类型。
     注意<parameter>start_with</>值必须作为一个文本串被输入，而不管键域的类型如何。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <function>connectby</> function is declared to return <type>setof
     record</type>, so the actual names and types of the output columns must be
     defined in the <literal>FROM</> clause of the calling <command>SELECT</>
     statement, for example:
    </para>
____________________________________________________________________________-->
    <para>
     <function>connectby</>函数被声明为返回<type>setof record</type>，因此输出列的实际名称和类型
    就必须在调用的<command>SELECT</>语句的<literal>FROM</>子句中被定义，例如：
    </para>

<!--==========================orignal english content==========================
<programlisting>
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);
</programlisting>

<!--==========================orignal english content==========================
    <para>
     The first two output columns are used for the current row's key and
     its parent row's key; they must match the type of the table's key field.
     The third output column is the depth in the tree and must be of type
     <type>integer</>.  If a <parameter>branch_delim</parameter> parameter was
     given, the next output column is the branch display and must be of type
     <type>text</>.  Finally, if an <parameter>orderby_fld</parameter>
     parameter was given, the last output column is a serial number, and must
     be of type <type>integer</>.
    </para>
____________________________________________________________________________-->
    <para>
     前两个输出列被用于当前行的键和其父亲行的键，它们必须匹配该表的键域的类型。第三个输出行是该树中的深度，
     并且必须是类型<type>integer</>。如果给定了一个<parameter>branch_delim</parameter>参数，下一个输出列
     就是分支显示并且必须是类型<type>text</>。最后，如果给出了一个<parameter>orderby_fld</parameter>参数，
     最后一个输出列是一个序号，并且必须是类型<type>integer</>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <quote>branch</> output column shows the path of keys taken to
     reach the current row.  The keys are separated by the specified
     <parameter>branch_delim</parameter> string.  If no branch display is
     wanted, omit both the <parameter>branch_delim</parameter> parameter
     and the branch column in the output column list.
    </para>
____________________________________________________________________________-->
    <para>
     <quote>branch</>输出列显示了用于到达当前行的由键构成的路径。其中的键用指定的<parameter>branch_delim</parameter>
     字符串分隔开。如果不需要分支显示，可以在输出列列表中忽略<parameter>branch_delim</parameter>参数和分支列。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the ordering of siblings of the same parent is important,
     include the <parameter>orderby_fld</parameter> parameter to
     specify which field to order siblings by.  This field can be of any
     sortable data type.  The output column list must include a final
     integer serial-number column, if and only if
     <parameter>orderby_fld</parameter> is specified.
    </para>
____________________________________________________________________________-->
    <para>
     如果同一父亲的子女之间的顺序很重要，可以包括<parameter>orderby_fld</parameter>参数以指定用哪个域对兄弟排序。
     这个域可以是任何可排序数据类型。当且仅当<parameter>orderby_fld</parameter>被指定时，输出列列表必须包括一个
     最终的整数序号列。
    </para>

<!--==========================orignal english content==========================
    <para>
     The parameters representing table and field names are copied as-is
     into the SQL queries that <function>connectby</> generates internally.
     Therefore, include double quotes if the names are mixed-case or contain
     special characters.  You may also need to schema-qualify the table name.
    </para>
____________________________________________________________________________-->
    <para>
     表示表和列名的参数会被原样复制到<function>connectby</>内部生成的 SQL 查询中。
     因此，如果名称是大小写混合或者包含特殊字符，应包括双引号。你也可能需要用模式限定表名。
    </para>

<!--==========================orignal english content==========================
    <para>
     In large tables, performance will be poor unless there is an index on
     the parent-key field.
    </para>
____________________________________________________________________________-->
    <para>
     在大型的表中，除非在父亲键域上有索引，否则性能会很差。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is important that the <parameter>branch_delim</parameter> string
     not appear in any key values, else <function>connectby</> may incorrectly
     report an infinite-recursion error.  Note that if
     <parameter>branch_delim</parameter> is not provided, a default value
     of <literal>~</> is used for recursion detection purposes.
     <!-&minus; That pretty well sucks.  FIXME -&minus;>
    </para>
____________________________________________________________________________-->
    <para>
     <parameter>branch_delim</parameter>字符串不出现在任何键值中是很重要的，否则<function>connectby</>可能会错误地
     报告一个无限递归错误。注意如果没有提供<parameter>branch_delim</parameter>，将用一个默认值<literal>~</>来进行递归检测。
     <!-- That pretty well sucks.  FIXME -->
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example:
<programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-&minus; with branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-&minus; without branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-&minus; with branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-&minus; without branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- 带有分支，但没有 orderby_fld （不保证结果的顺序）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- 没有分支，也没有 orderby_fld （不保证结果的顺序）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- 有分支，有 orderby_fld （注意 row5 在 row4 前面）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- 没有分支，有 orderby_fld （注意 row5 在 row4 前面）
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
</programlisting>
    </para>
   </sect3>

 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Author</title>
____________________________________________________________________________-->
  <title>作者</title>

<!--==========================orignal english content==========================
  <para>
   Joe Conway
  </para>
____________________________________________________________________________-->
  <para>
   Joe Conway
  </para>

 </sect2>

</sect1>
