<!-- doc/src/sgml/plpgsql.sgml -->

<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym>过程语言</title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
  <title>综述</title>

 <para>
  <application>PL/pgSQL</application>是一种用于<productname>PostgreSQL</productname>数据库系统的可载入的过程语言。<application>PL/pgSQL</>的设计目标是创建一种这样的可载入过程语言

    <itemizedlist>
     <listitem>
      <para>
       可以被用来创建函数和触发器过程，
      </para>
     </listitem>
     <listitem>
      <para>
       对<acronym>SQL</acronym>语言增加控制结构，
      </para>
     </listitem>
     <listitem>
      <para>
       可以执行复杂计算，
      </para>
     </listitem>
     <listitem>
      <para>
       继承所有用户定义类型、函数和操作符，
      </para>
     </listitem>
     <listitem>
      <para>
       可以被定义为受服务器信任，
      </para>
     </listitem>
     <listitem>
      <para>
       便于使用。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    用<application>PL/pgSQL</application>创建的函数可以被用在任何可以使用内建函数的地方。例如，可以创建复杂条件的计算函数并且后面用它们来定义操作符或把它们用于索引表达式。
   </para>

   <para>
    在<productname>PostgreSQL</> 9.0 和以后的版本中，<application>PL/pgSQL</application>是默认被安装的。但是它仍然是一种可载入模块，因此特别关注安全性的管理员可以选择移除它。
   </para>

  <sect2 id="plpgsql-advantages">
   <title>使用<application>PL/pgSQL</application>的优点</title>

    <para>
     <acronym>SQL</acronym>被<productname>PostgreSQL</>和大多数其他关系数据库用作查询语言。它是可移植的并且容易学习。但是每一个<acronym>SQL</acronym>语句必须由数据库服务器单独执行。
    </para>

    <para>
     这意味着你的客户端应用必须发送每一个查询到数据库服务器、等待它被处理、接收并处理结果、做一些计算，然后发送更多查询给服务器。如果你的客户端和数据库服务器不在同一台机器上，所有这些会引起进程间通信并且将带来网络负担。
    </para>

    <para>
     通过<application>PL/pgSQL</application>，你可以将一整块计算和一系列查询分组在数据库服务器<emphasis>内部</emphasis>，这样就有了一种过程语言的能力并且使 SQL 更易用，但是节省了相当多的客户端/服务器通信开销。
    </para>
    <itemizedlist>

     <listitem><para> 客户端和服务器之间的额外往返通信被消除 </para></listitem>

     <listitem><para> 客户端不需要的中间结果不必被整理或者在服务器和客户端之间传送 </para></listitem>

     <listitem><para> 多轮的查询解析可以被避免 </para></listitem>

    </itemizedlist>
    <para> 与不使用存储函数的应用相比，这能够导致可观的性能提升。
    </para>

    <para>
     还有，通过<application>PL/pgSQL</application>你可以使用 SQL 中所有的数据类型、操作符和函数。
    </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
   <title>支持的参数和结果数据类型</title>

    <para>
     <application>PL/pgSQL</application>编写的函数可以接受服务器支持的任何标量或数组数据类型作为参数，并且它们能够返回任何这些类型的结果。它们也能接受或返回任何用名称指定的组合类型（行类型）。也可以声明一个<application>PL/pgSQL</application>函数为返回<type>记录</>，这意味着结果是一种行类型，其中的列由调用查询中的说明决定（如<xref linkend="queries-tablefunctions">中所讨论的）。
    </para>

    <para>
     <application>PL/pgSQL</>函数可以通过使用<literal>VARIADIC</>标记被声明为接受数量不定的参数。如<xref linkend="xfunc-sql-variadic-functions">中所讨论的，它的工作方式和 SQL 函数一样。
    </para>

    <para>
     <application>PL/pgSQL</>函数也可以被声明为接受并返回多态类型<type>anyelement</type>、<type>anyarray</type>、<type>anynonarray</type>、<type>anyenum</>以及<type>anyrange</type>。如<xref linkend="extend-types-polymorphic">中所讨论的，由一个多态函数处理的实际数据类型会随着调用改变。在<xref linkend="plpgsql-declaration-parameters">中展示了一个例子。
    </para>

    <para>
     <application>PL/pgSQL</>函数还能够被声明为返回一个任意（可作为一个单一实例返回的）数据类型的<quote>集合</>（或表）。这样的一个函数通过为结果集的每个期望元素执行<command>RETURN NEXT</>来产生输出，或者通过使用<command>RETURN QUERY</>来输出一个查询计算的结果。
    </para>

    <para>
     最后，如果一个<application>PL/pgSQL</>函数没有可用的返回值，它可以被声明为返回<type>void</>。
    </para>

    <para>
     <application>PL/pgSQL</>函数也能够被声明为用输出参数代替返回类型的一个显式说明。这没有为该语言增加任何基础功能，但是它常常很方便，特别是对于要返回多个值的情况。<literal>RETURNS TABLE</>符号也可以被用来替代<literal>RETURNS SETOF</>。
    </para>

    <para>
     在<xref linkend="plpgsql-declaration-parameters">和<xref linkend="plpgsql-statements-returning">中有详细的例子。
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
  <title><application>PL/pgSQL</application>的结构</title>

  <para>
   <application>PL/pgSQL</application>是一种块结构的语言。一个函数定义的完整文本必须是一个<firstterm>块</>。一个块被定义为：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
     在一个块中的每一个声明和每一个语句都由一个分号终止。如上所示，出现在另一个块中的块必须有一个分号在<literal>END</literal>之后。不过最后一个结束函数体的<literal>END</literal>不需要一个分号。
    </para>

    <tip>
     <para>
      一种常见的错误是直接在<literal>BEGIN</>之后写一个分号。这是不正确的并且将会导致一个语法错误。
     </para>
    </tip>

    <para>
     如果你想要标识一个块以便在一个<literal>EXIT</>语句中使用或者标识在该块中声明的变量名，那么<replaceable>label</replaceable>是你唯一需要的。如果一个标签在<literal>END</>之后被给定，它必须匹配在块开始处的标签。
    </para>

    <para>
     所有的关键词都是大小写无关的。除非被双引号引用，标识符会被隐式地转换为小写形式，就像它们在普通 SQL 命令中。
    </para>

    <para>
     <application>PL/pgSQL</>代码中的注释和普通 SQL 中的一样。一个双连字符（<literal>--</literal>）开始一段注释，它延伸到该行的末尾。一个<literal>/*</literal>开始一段块注释，它会延伸到匹配<literal>*/</literal>出现的位置。块注释可以嵌套。
    </para>

    <para>
     一个块的语句节中的任何语句可以是一个<firstterm>子块</>。子块可以被用来逻辑分组或者将变量局部化为语句的一个小组。在子块的持续期间，在一个子块中声明的变量会掩盖外层块中相同名称的变量。但是如果你用块的标签限定外层变量的名字，你仍然可以访问它们。例如：
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- 创建一个子块
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
     <para>
      在任何<application>PL/pgSQL</>函数体的外部确实有一个隐藏的<quote>外层块</>包围着。这个块提供了该函数参数（如果有）的声明，以及某些诸如<literal>FOUND</literal>之类特殊变量（见<xref linkend="plpgsql-statements-diagnostics">）。外层块被标上函数的名称，这意味着参数和特殊变量可以用该函数的名称限定。
     </para>
    </note>

    <para>
     重要的是不要把<application>PL/pgSQL</>中用来分组语句的<command>BEGIN</>/<command>END</>与用于事务控制的同名 SQL 命令弄混。<application>PL/pgSQL</>的<command>BEGIN</>/<command>END</>只用于分组，它们不会开始或结束一个事务。函数和触发器过程总是被执行在由一个外层查询建立的事务中 &mdash; 它们不能开始或提交那个事务，因为没有环境给它们执行。不过，一个包含<literal>EXCEPTION</>子句的块实际上会形成一个子事务，它可以被回滚而不影响外层事务。详见<xref linkend="plpgsql-error-trapping">。
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
    <title>声明</title>

    <para>
     在一个块中使用的所有变量必须在该块的声明小节中声明（唯一的例外是在一个整数范围上迭代的<literal>FOR</>循环变量会被自动声明为一个整数变量，并且相似地在一个游标结果上迭代的<literal>FOR</>循环变量会被自动地声明为一个记录变量）。
    </para>

    <para>
     <application>PL/pgSQL</>变量可以是任意 SQL 数据类型，例如<type>integer</type>、<type>varchar</type>和<type>char</type>。
    </para>

    <para>
     这里是变量声明的一些例子：
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
     一个变量声明的一般语法是：
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      如果给定<literal>DEFAULT</>子句，它会指定进入该块时分
      配给该变量的初始值。如果没有给出<literal>DEFAULT</>子句，
      则该变量被初始化为<acronym>SQL</acronym>空值。
      <literal>CONSTANT</>选项阻止该变量在初始化之后被赋值，
      这样它的值在块的持续期内保持不变。<literal>COLLATE</>
      选项指定用于该变量的一个排序规则（见
      <xref linkend="plpgsql-declaration-collation">）。如果指
      定了<literal>NOT NULL</>，对该变量赋值为空值会导致一个
      运行时错误。所有被声明为<literal>NOT NULL</>的变量必须
      被指定一个非空默认值。
      等号（<literal>=</>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</>。
     </para>

     <para>
      一个变量的默认值会在每次进入该块时被计算并且赋值给该变量（不是每次函数调用只计算一次）。因此，例如将<literal>now()</literal>赋值给类型为<type>timestamp</type>的一个变量将会导致该变量具有当前函数调用的时间，而不是该函数被预编译的时间。
     </para>

     <para>
      例子：
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
     <title>声明函数参数</title>

     <para>
      传递给函数的参数被命名为标识符<literal>$1</literal>、<literal>$2</literal>等等。可选地，能够为<literal>$<replaceable>n</replaceable></literal>参数名声明别名来增加可读性。不管是别名还是数字标识符都能用来引用参数值。
     </para>

     <para>
      有两种方式来创建一个别名。比较好的方式是在<command>CREATE FUNCTION</command>命令中为参数给定一个名称。例如：
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      另一种方式是显式地使用声明语法声明一个别名。

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      使用这种风格的同一个例子看起来是：
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <para>
      这两个例子并非完全等效。在第一种情况中，<literal>subtotal</>可以被引用为<literal>sales_tax.subtotal</>，但在第二种情况中它不能这样引用（如果我们为内层块附加了一个标签，<literal>subtotal</>则可以用那个标签限定）。
     </para>
    </note>

     <para>
      更多一些例子：
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- 这里是一些使用 v_string 和 index 的计算
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
      当一个<application>PL/pgSQL</application>函数被声明为带有输出参数，输出参数可以用普通输入参数相同的方式被给定<literal>$<replaceable>n</replaceable></literal>名称以及可选的别名。一个输出参数实际上是一个最初为 NULL 的变量，它应当在函数的执行期间被赋值。该参数的最终值就是要被返回的东西。例如，sales-tax 例子也可以用这种方式来做：

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      注意我们忽略了<literal>RETURNS real</> &mdash; 我们也可以包括它，但是那将是冗余。
     </para>

     <para>
      当返回多个值时，输出参数最有用。一个小例子是：

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      如<xref linkend="xfunc-output-parameters">中所讨论的，这实际上为该函数的结果创建了一个匿名记录类型。如果给定了一个<literal>RETURNS</>子句，它必须<literal>RETURNS record</>。
     </para>

     <para>
      声明一个<application>PL/pgSQL</application>函数的另一种方式是用<literal>RETURNS TABLE</>，例如：

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      这和声明一个或多个<literal>OUT</>参数并且指定<literal>RETURNS SETOF <replaceable>sometype</></literal>完全等效。
     </para>

     <para>
      当一个<application>PL/pgSQL</application>函数的返回类型被声明为一个多态类型（<type>anyelement</type>、<type>anyarray</type>、<type>anynonarray</type>、<type>anyenum</type>或<type>anyrange</type>），一个特殊参数<literal>$0</literal>会被创建。它的数据类型是该函数的实际返回类型，这是从实际输入类型（<xref linkend="extend-types-polymorphic">）推演得来。<literal>$0</literal>被初始化为空并且不能被该函数修改，因此它能够被用来保持可能需要的返回值，不过这不是必须的。<literal>$0</literal>也可以被给定一个别名。例如，这个函数工作在任何具有一个<literal>+</>操作符的数据类型上： 

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
      通过声明一个或多个输出参数为多态类型可以得到同样的效果。在这种情况下，不使用特殊的<literal>$0</literal>参数，输出参数本身就用作相同的目的。例如：

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</></title>

<synopsis>
<replaceable>newname</> ALIAS FOR <replaceable>oldname</>;
</synopsis>

   <para>
    <literal>ALIAS</>语法比前一节中建议的更一般化：你可以为任意变量声明一个别名，而不只是函数参数。其主要实际用途是为预先决定了名称的变量分配一个不同的名称，例如在一个触发器过程中的<varname>NEW</varname>或<varname>OLD</varname>。
   </para>

   <para>
    例子：
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

   <para>
    因为<literal>ALIAS</>创造了两种不同的方式来命名相同的对象，如果对其使用不加限制就会导致混淆。最好只把它用来覆盖预先决定的名称。
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
   <title>复制类型</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
    <literal>%TYPE</literal>提供了一个变量或表列的数据类型。你可以用它来声明将保持数据库值的变量。例如，如果你在<literal>users</literal>中有一个名为<literal>user_id</literal>的列。要定义一个与<literal>users.user_id</>具有相同数据类型的变量：
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
    通过使用<literal>%TYPE</literal>，你不需要知道你要引用的结构的实际数据类型，而且最重要地，如果被引用项的数据类型在未来被改变（例如你把<literal>user_id</>的类型从<type>integer</type>改为<type>real</type>），你不需要改变你的函数定义。
   </para>

   <para>
    <literal>%TYPE</literal>在多态函数中特别有价值，因为内部变量所需的数据类型能在两次调用时改变。可以把<literal>%TYPE</literal>应用在函数的参数或结果占位符上来创建合适的变量。
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
     <title>行类型</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <para>
    一个组合类型的变量被称为一个<firstterm>行</>变量（或<firstterm>行类型</>变量）。这样一个变量可以保持一个<command>SELECT</>或<command>FOR</>查询结果的一整行，前提是查询的列集合匹配该变量被声明的类型。该行值的各个域可以使用通常的点号标记访问，例如<literal>rowvar.field</literal>。
   </para>

   <para>
    通过使用<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>标记，一个行变量可以被声明为具有和一个现有表或视图的行相同的类型。它也可以通过给定一个组合类型名称来声明（因为每一个表都有一个相关联的具有相同名称的组合类型，所以在<productname>PostgreSQL</>中实际上写不写<literal>%ROWTYPE</literal>都没有关系。但是带有<literal>%ROWTYPE</literal>的形式可移植性更好）。
   </para>

   <para>
    一个函数的参数可以是组合类型（完整的表行）。在这种情况下，相应的标识符<literal>$<replaceable>n</replaceable></>将是一个行变量，并且可以从中选择域，例如<literal>$1.user_id</literal>。
   </para>

   <para>
    一个表行中只有用户定义的列是通过行类型变量可以访问的，OID 列或其他系统列是不能通过行类型变量访问的（因为行可能来自于一个视图）。行类型的域继承了表的域尺寸或数据类型的精度，如<type>char(<replaceable>n</>)</type>。
   </para>

   <para>
    这里是一个使用组合类型的例子。<structname>table1</>和<structname>table2</>是已有的表，它们至少有以下提到的域：

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
   <title>记录类型</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
    记录变量和行类型变量类似，但是它们没有预定义的结构。它们采用在一个<command>SELECT</>或<command>FOR</>命令期间为其赋值的行的真实行结构。一个记录变量的子结构能在每次它被赋值时改变。这样的结果是直到一个记录变量第一次被赋值之前，它都没有子结构，并且任何尝试访问其中一个域都会导致一个运行时错误。
   </para>

   <para>
    注意<literal>RECORD</>并非一个真正的数据类型，只是一个占位符。我们也应该认识到当一个<application>PL/pgSQL</application>函数被声明为返回类型<type>record</>，这与一个记录变量并不是完全相同的概念，即便这样一个函数可能会用一个记录变量来保持其结果。在两种情况下，编写函数时都不知道真实的行结构，但是对于一个返回<type>record</>的函数，当调用查询被解析时就已经决定了真正的结构，而一个行变量能够随时改变它的行结构。
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
   <title><application>PL/pgSQL</application>变量的排序规则</title>

   <indexterm>
    <primary>collation</>
    <secondary>in PL/pgSQL</>
   </indexterm>

   <para>
    当一个<application>PL/pgSQL</application>函数有一个或多个可排序数据类型的参数时，为每一次函数调用都会基于赋值给实参的排序规则来确定出一个排序规则，如<xref linkend="collation">中所述。如果一个排序规则被成功地确定（即在参数之间隐式排序规则没有冲突），那么所有的可排序参数会被当做隐式具有那个排序规则。这将在函数中影响行为受到排序规则影响的操作。例如，考虑

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    <function>less_than</>的第一次使用将会采用<structfield>text_field_1</>和<structfield>text_field_2</>共同的排序规则进行比较，而第二次使用将采用<literal>C</>排序规则。
   </para>

   <para>
    此外，被确定的排序规则也被假定为任何可排序数据类型本地变量的排序规则。因此，当这个函数被写为以下形式时，它工作将不会有什么不同

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    如果没有可排序数据类型的参数，或者不能为它们确定共同的排序规则，那么参数和本地变量会使用它们数据类型的默认排序规则（通常是数据库的默认排序规则，但是可能不同于域类型的变量）。
   </para>

   <para>
    通过在一个可排序数据类型的本地变量的声明中包括<literal>COLLATE</>选项，可以为它指定一个不同的排序规则，例如

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    这个选项会覆盖根据上述规则被给予该变量的排序规则。
   </para>

   <para>
    还有，如果一个函数想要强制在一个特定操作中使用一个特定排序规则，当然可以在该函数内部写一个显式的<literal>COLLATE</>子句。例如：

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    这会覆盖表达式中使用的表列、参数或本地变量相关的排序规则，就像在纯 SQL 命令中发生的一样。
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
  <title>表达式</title>

    <para>
     <application>PL/pgSQL</application>语句中用到的所有表达式会被服务器的主<acronym>SQL</acronym>执行器处理。例如，当你写一个这样的<application>PL/pgSQL</application>语句时
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application>将通过给主 SQL 引擎发送一个查询
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     来计算该表达式。如<xref linkend="plpgsql-var-subst">中所详细讨论的，在构造该<command>SELECT</>命令时，<application>PL/pgSQL</application>变量名的每一次出现会被参数所替换。这允许<command>SELECT</command>的查询计划仅被准备一次并且被重用于之后的对于该变量不同值的计算。因此，在一个表达式第一次被使用时实际发生的本质上是一个<command>PREPARE</>命令。例如，如果我们已经声明了两个整数变量<literal>x</>和<literal>y</>，并且我们写了
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     在现象之后发生的等效于
<programlisting>
PREPARE <replaceable>statement_name</>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     并且然后为每一次<command>IF</>语句的执行，这个预备语句都会被<command>EXECUTE</>，执行时使用变量的当前值作为参数值。通常这些细节对于一个<application>PL/pgSQL</application>用户并不重要，但是在尝试诊断一个问题时了解它们很有用。更多信息可见<xref linkend="plpgsql-plan-caching">。
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
  <title>基本语句</title>

   <para>
    在这一节和接下来的小节中，我们会描述<application>PL/pgSQL</application>能明确理解的所有语句类型。任何不被识别为这些语句类型之一的被假定为是一个 SQL 命令，并且会被发送给主数据库引擎执行，具体如<xref linkend="plpgsql-statements-sql-noresult">和<xref linkend="plpgsql-statements-sql-onerow">中所述。
   </para>

   <sect2 id="plpgsql-statements-assignment">
    <title>赋值</title>

    <para>
     为一个<application>PL/pgSQL</application>变量赋一个值可以被写为：
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     正如以前所解释的，这样一个语句中的表达式被以一个 SQL
      <command>SELECT</>命令被发送到主数据库引擎的方式计算。
      该表达式必须得到一个单一值（如果该变量是一个行或记录变量，
      它可能是一个行值）。该目标变量可以是一个简单变量（
      可以选择用一个块名限定）、一个行或记录变量的域或是一个简单
      变量或域的数组元素。
     等号（<literal>=</>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</>。
    </para>

    <para>
     如果该表达式的结果数据类型不匹配变量的数据类型，或者该变量有一个特定的尺寸/精度（像<type>char(20)</type>），结果值将被<application>PL/pgSQL</application>解释器使用该结果类型的输出函数及变量类型的输入函数进行隐式转换。注意如果该输入函数不接受结果值的字符串形式，这可能潜在地导致由输入函数产生的运行时错误。
    </para>

    <para>
     例子：
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
    <title>执行一个没有结果的命令</title>

    <para>
     对于任何不返回行的 SQL 命令（例如没有一个<literal>RETURNING</>子句的<command>INSERT</>），你可以通过把该命令直接写在一个 <application>PL/pgSQL</application> 函数中执行它。
    </para>

    <para>
     任何出现在该命令文本中的<application>PL/pgSQL</application>变量名被当作一个参数，并且接着该变量的当前值被提供为运行时该参数的值。这与早前描述的对表达式的处理完全相似，详见<xref linkend="plpgsql-var-subst">。
    </para>

    <para>
     当以这种方式执行一个 SQL 命令时，如<xref linkend="plpgsql-plan-caching">中讨论的，<application>PL/pgSQL</application>会为该命令缓存并重用执行计划。
    </para>

    <para>
     有时候计算一个表达式或<command>SELECT</>查询但抛弃其结果是有用的，例如调用一个有副作用但是没有有用的结果值的函数。在<application>PL/pgSQL</application>中要这样做，可使用<command>PERFORM</command>语句：

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     这会执行<replaceable>query</replaceable>并且丢弃掉结果。以写一个SQL <command>SELECT</>命令相同的方式写该<replaceable>query</replaceable>，并且将初始的关键词<command>SELECT</>替换为<command>PERFORM</command>。对于<command>WITH</>查询，使用<command>PERFORM</>并且接着把该查询放在圆括号中（在这种情况中，该查询只能返回一行）。<application>PL/pgSQL</application>变量将被替换到该查询中，正像对不返回结果的命令所作的那样，并且计划被以相同的方式被缓存。还有，如果该查询产生至少一行，特殊变量<literal>FOUND</literal>会被设置为真，而如果它不产生行则设置为假（见<xref linkend="plpgsql-statements-diagnostics">）。
    </para>

    <note>
     <para>
      我们可能期望直接写<command>SELECT</command>能实现这个结果，但是当前唯一被接受的方式是<command>PERFORM</command>。一个能返回行的 SQL 命令（例如<command>SELECT</command>）将被当成一个错误拒绝，除非它像下一节中讨论的有一个<literal>INTO</>子句。
     </para>
    </note>

    <para>
     一个例子：
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
    <title>执行一个有单一行结果的查询</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
     一个产生单一行（可能有多个列）的 SQL 命令的结果可以被赋值给一个记录变量、行类型变量或标量变量列表。这通过书写基础 SQL 命令并增加一个<literal>INTO</>子句来达成。例如：

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     其中<replaceable>target</replaceable>可以是一个记录变量、一个行变量或一个有逗号分隔的简单变量和记录/行域列表。<application>PL/pgSQL</application>变量将被替换到该查询的剩余部分中，并且计划会被缓存，正如之前描述的对不返回行的命令所做的。这对<command>SELECT</>、带有<literal>RETURNING</>的<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>以及返回行集结果的工具命令（例如<command>EXPLAIN</>）。除了<literal>INTO</>子句，SQL 命令和它在<application>PL/pgSQL</application>之外的写法一样。
    </para>

   <tip>
    <para>
     注意带<literal>INTO</>的<command>SELECT</>的这种解释和<productname>PostgreSQL</>常规的<command>SELECT INTO</command>命令有很大的不同，后者的<literal>INTO</>目标是一个新创建的表。如果你想要在一个<application>PL/pgSQL</application>函数中从一个<command>SELECT</>的结果创建一个表，请使用语法<command>CREATE TABLE ... AS SELECT</command>。
    </para>
   </tip>

    <para>
     如果一行或一个变量列表被用作目标，该查询的结果列必须完全匹配该结果的结构，包括数量和数据类型，否则会发生一个运行时错误。当一个记录变量是目标时，它会自动地把自身配置成查询结果列组成的行类型。
    </para>

    <para>
     <literal>INTO</>子句几乎可以出现在 SQL 命令中的任何位置。通常它被写成刚好在<command>SELECT</>命令中的<replaceable>select_expressions</replaceable>列表之前或之后，或者在其他命令类型的命令最后。我们推荐你遵循这种惯例，以防<application>PL/pgSQL</application>的解析器在未来的版本中变得更严格。
    </para>

    <para>
     如果<literal>STRICT</literal>没有在<literal>INTO</>子句中被指定，那么<replaceable>target</replaceable>将被设置为该查询返回的第一个行，或者在该查询不返回行时设置为空（注意除非使用了<literal>ORDER BY</>，否则<quote>第一行</>的界定并不清楚）。第一行之后的任何结果行都会被抛弃。你可以检查特殊的<literal>FOUND</literal>变量（见<xref linkend="plpgsql-statements-diagnostics">）来确定是否返回了一行：

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

     如果指定了<literal>STRICT</literal>选项，该查询必须刚好返回一行或者将会报告一个运行时错误，该错误可能是<literal>NO_DATA_FOUND</>（没有行）或<literal>TOO_MANY_ROWS</>（多于一行）。如果你希望捕捉该错误，可以使用一个异常块，例如：

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     成功执行一个带<literal>STRICT</>的命令总是会将<literal>FOUND</literal>置为真。
    </para>

    <para>
     对于带有<literal>RETURNING</>的<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>，即使没有指定<literal>STRICT</literal>，<application>PL/pgSQL</application>也会针对多于一个返回行的情况报告一个错误。这是因为没有类似于<literal>ORDER BY</>的选项可以用来决定应该返回哪个被影响的行。
    </para>
    
    <para>
     如果为该函数启用了If <literal>print_strict_params</>，那么当因为
     <literal>STRICT</>的要求没有被满足而抛出一个错误时，该错误消息
     的<literal>DETAIL</>将包括传递给该查询的参数信息。可以通过设置
     <varname>plpgsql.print_strict_params</>为所有函数更改
     <literal>print_strict_params</>设置，但是只有修改后被编译的函数
     才会生效。也可以使用一个编译器选项来为一个函数启用它，例如：
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;
</programlisting>
     失败时，这个函数会产生一个这样的错误消息
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>

    <note>
     <para>
      <literal>STRICT</>选项匹配 Oracle PL/SQL 的<command>SELECT INTO</command>和相关语句的行为。
     </para>
    </note>

    <para>
     对于要处理来自于一个 SQL 查询的结果行的情况，请见<xref linkend="plpgsql-records-iterating">。
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
    <title>执行动态命令</title>

    <para>
     很多时候你将想要在<application>PL/pgSQL</application>函数中产生动态命令，也就是每次执行中会涉及到不同表或不同数据类型的命令。<application>PL/pgSQL</application>通常对于命令所做的缓存计划尝试（如<xref linkend="plpgsql-plan-caching">中讨论）在这种情境下无法工作。要处理这一类问题，需要提供<command>EXECUTE</command>语句：

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     其中<replaceable>command-string</replaceable>是一个能得到一个包含要被执行命令字符串（类型<type>text</type>）的表达式。可选的<replaceable>target</replaceable>是一个记录变量、一个行变量或者一个逗号分隔的简单变量以及记录/行域的列表，该命令的结果将存储在其中。可选的<literal>USING</>表达式提供要被插入到该命令中的值。
    </para>

    <para>
     在计算得到的命令字符串中，不会做<application>PL/pgSQL</>变量的替换。任何所需的变量值必须在命令字符串被构造时被插入其中，或者你可以使用下面描述的参数。
    </para>

    <para>
     还有，对于通过<command>EXECUTE</command>执行的命令不会有计划被缓存。该命令反而在每次运行时都会被做计划。因此，该命令字符串可以在执行不同表和列上动作的函数中被动态创建。
    </para>

    <para>
     <literal>INTO</literal>子句指定一个返回行的 SQL 命令的结果应该被赋值到哪里。如果提供了一个行或变量列表，它必须完全匹配查询结果的结构（当使用一个记录变量时，它会自动把它自己配置为匹配结果结构）。如果返回多个行，只有第一个行会被赋值给<literal>INTO</literal>变量。如果没有返回行，NULL 会被赋值给<literal>INTO</literal>变量。如果没有指定<literal>INTO</literal>变量，该查询结果会被抛弃。
    </para>

    <para>
     如果给出了<literal>STRICT</>选项，除非该查询刚好产生一行，否则将会报告一个错误。
    </para>

    <para>
     命令字符串可以使用参数值，它们在命令中用<literal>$1</>、<literal>$2</>等引用。这些符号引用在<literal>USING</>子句中提供的值。这种方法常常更适合于把数据值作为文本插入到命令字符串中：它避免了将该值转换为文本以及转换回来的运行时负荷，并且它更不容易被 SQL 注入攻击，因为不需要引用或转义。一个例子是：
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
     需要注意的是，参数符号只能用于数据值 &mdash; 如果想要使用动态决定的表名或列名，你必须将它们以文本形式插入到命令字符串中。例如，如果前面的那个查询需要在一个动态选择的表上执行，你可以这么做：
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     另一个关于参数符号的限制是，它们只能在<command>SELECT</>、<command>INSERT</>、<command>UPDATE</>和<command>DELETE</>命令中工作。在另一种语句类型（通常被称为实用语句）中，即使值是数据值，你也必须将它们以文本形式插入。
    </para>

    <para>
     在上面第一个例子中，带有一个简单的常量命令字符串和一些<literal>USING</>参数的<command>EXECUTE</>命令在功能上等效于直接用<application>PL/pgSQL</application>写的命令，并且允许自动发生<application>PL/pgSQL</application>变量替换。重要的不同之处在于，<command>EXECUTE</>会在每一次执行时根据当前的参数值重新规划该命令，而<application>PL/pgSQL</application>则是创建一个通用计划并且将其缓存以便重用。在最佳计划强依赖于参数值的情况中，使用<command>EXECUTE</>来明确地保证不会选择一个通用计划是很有帮助的。
    </para>

    <para>
     <command>EXECUTE</command>目前不支持<command>SELECT INTO</command>。但是可以执行一个纯的<command>SELECT</>命令并且指定<literal>INTO</>作为<command>EXECUTE</>本身的一部分。
    </para>

   <note>
    <para>
     <application>PL/pgSQL</application>中的<command>EXECUTE</command>语句与<xref linkend="sql-execute"> <productname>PostgreSQL</productname>服务器支持的 SQL 语句无关。服务器的<command>EXECUTE</command>语句不能直接在<application>PL/pgSQL</>函数中使用（并且也没有必要）。
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
   <title>在动态查询中引用值</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

    <indexterm>
     <primary>format</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

    <para>
     在使用动态命令时经常不得不处理单引号的转义。我们推荐在函数体中使用美元符号引用来引用固定的文本（如果你有没有使用美元符界定的老代码，请参考<xref linkend="plpgsql-quote-tips">中的概述，这样在把上述代码转换成更合理的模式时会省力些）。
    </para>

    <para>
     要被插入到构造出来的查询中的动态数值需要被小心地处理，因为它们本身就可能包含引号字符。一个例子（这里假定你对函数整体使用了美元符号引用，因此引号不需要被双写）：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <para>
     这个例子展示了<function>quote_ident</function>和<function>quote_literal</function>函数的使用（见<xref linkend="functions-string">）。为了安全，在进行一个动态查询中的插入之前，包含列或表标识符的表达式应该通过<function>quote_ident</function>被传递。如果表达式包含在被构造出的命令中应该是字符串的值时，它应该通过<function>quote_literal</>被传递。这些函数采取适当的步骤来分别返回被封闭在双引号或单引号中的文本，其中任何嵌入的特殊字符都会被正确地转义。
    </para>

    <para>
     因为<function>quote_literal</function>被标记为<literal>STRICT</literal>，当用一个空参数调用时，它总是会返回空。在上面的例子中，如果<literal>newvalue</>或<literal>keyvalue</>为空，整个动态查询字符串会变成空，导致从<command>EXECUTE</command>得到一个错误。可以通过使用<function>quote_nullable</>函数来避免这种问题，它工作起来和<function>quote_literal</>相同，除了用空参数调用时会返回一个字符串<literal>NULL</>。例如：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     如果正在处理的参数值可能为空，那么通常应该用<function>quote_nullable</>来代替<function>quote_literal</>。
    </para>

    <para>
     通常，必须小心地确保查询中的空值不会递送意料之外的结果。例如如果<literal>keyvalue</>为空，下面的<literal>WHERE</>子句
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     永远不会成功，因为在<literal>=</>操作符中使用空操作数得到的结果总是为空。如果想让空和一个普通键值一样工作，你应该将上面的命令重写成
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     （目前，<literal>IS NOT DISTINCT FROM</>的处理效率不如<literal>=</>，因此只有在非常必要时才这样做。关于空和<literal>IS DISTINCT</>的详细信息请见<xref linkend="functions-comparison">）。
    </para>

    <para>
     请注意美元符号引用只对引用固定文本有用。尝试写出下面这个例子是一个非常糟糕的主意：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     因为如果<literal>newvalue</>的内容碰巧含有<literal>$$</>，那么这段代码就会出问题。同样的缺点可能适用于你选择的任何其他美元符号引用定界符。因此，要想安全地引用事先不知道的文本，<emphasis>必须</>恰当地使用<function>quote_literal</>、<function>quote_nullable</>或<function>quote_ident</>。
    </para>

    <para>
     动态 SQL 语句也可以使用<function>format</function>（见<xref linkend="functions-string">）函数来安全地构造。例如：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     <function>format</function>函数可以和<literal>USING</literal>子句联合使用：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     这种形式更高效，因为参数<literal>newvalue</literal>和<literal>keyvalue</literal>不会被转换成文本。
    </para>
   </example>

    <para>
     动态命令和<command>EXECUTE</command>的一个更大的例子可以在<xref linkend="plpgsql-porting-ex2">中找到，它会构建并且执行一个<command>CREATE FUNCTION</>命令来定义一个新的函数。
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
    <title>获得结果状态</title>

    <para>
     有好几种方法可以判断一条命令的效果。第一种方法是使用<command>GET DIAGNOSTICS</command>命令，其形式如下：

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     这条命令允许检索系统状态指示符。每个<replaceable>item</replaceable>
     是一个关键字， 它标识一个要被赋予给指定变量的状态值（变量应具有要接收的值相同的类型）。
     当前可用的状态项有<varname>ROW_COUNT</>（最后一个发送给
     <acronym>SQL</acronym>引擎的<acronym>SQL</acronym>
     命令处理的行数）以及<varname>RESULT_OID</>（最后一条
     <acronym>SQL</acronym>命令插入的最后一行的 OID ）。请注意只有在一
     个向包含 OID 的表中<command>INSERT</command>之后使用
     <varname>RESULT_OID</>才有用。对于<command>GET DIAGNOSTICS</>，
     冒号-等号（<literal>:=</>）可以被用来代替 SQL-标准的
     <literal>=</>。
    </para>

    <para>
     例如：
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

    <para>
     第二种判断命令效果的方法是检查一个名为<literal>FOUND</literal>的<type>boolean</type>类型的特殊变量。在每一次<application>PL/pgSQL</application>函数调用时，<literal>FOUND</literal>开始都为假。它的值会被下面的每一种类型的语句设置：

         <itemizedlist>
          <listitem>
           <para>
            如果一个<command>SELECT INTO</command>语句赋值了一行，它将把<literal>FOUND</literal>设置为真，如果没有返回行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>PERFORM</>语句生成（并且抛弃）一行或多行，它将把<literal>FOUND</literal>设置为真，如果没有产生行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果<command>UPDATE</>、<command>INSERT</>以及<command>DELETE</>语句影响了至少一行，它们会把<literal>FOUND</literal>设置为真，如果没有影响行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>FETCH</>语句返回了一行，它将把<literal>FOUND</literal>设置为真，如果没有返回行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>MOVE</>语句成功地重定位了游标，它将会把<literal>FOUND</literal>设置为真，否则设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>FOR</>或<command>FOREACH</>语句迭代了一次或多次，它将会把<literal>FOUND</literal>设置为真，否则设置为假。当循环退出时，<literal>FOUND</literal>用这种方式设置；在循环执行中，尽管<literal>FOUND</literal>可能被循环体中的其他语句的执行所改变，但它不会被循环语句修改。
           </para>
          </listitem>
          <listitem>
           <para>
            如果查询返回至少一行，<command>RETURN QUERY</command>和<command>RETURN QUERY EXECUTE</command>语句会把<literal>FOUND</literal>设为真， 如果没有返回行则设置为假。
           </para>
          </listitem>
         </itemizedlist>

     其他的<application>PL/pgSQL</application>语句不会改变<literal>FOUND</literal>的状态。尤其需要注意的一点是：<command>EXECUTE</command>会修改<command>GET DIAGNOSTICS</command>的输出，但不会修改<literal>FOUND</literal>的输出。
    </para>

    <para>
     <literal>FOUND</literal>是每个<application>PL/pgSQL</application>函数的局部变量；任何对它的修改只影响当前的函数。
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
    <title>什么也不做</title>

    <para>
     有时一个什么也不做的占位语句也很有用。例如，它能够指示 if/then/else 链中故意留出的空分支。可以使用<command>NULL</command>语句达到这个目的：

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
     例如，下面的两段代码是等价的：
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- 忽略错误
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- 忽略错误
END;
</programlisting>
     究竟使用哪一种取决于各人的喜好。
    </para>

    <note>
     <para>
      在 Oracle 的 PL/SQL 中，不允许出现空语句列表，并且因此在这种情况下<emphasis>必须</>使用<command>NULL</>语句。而<application>PL/pgSQL</application>允许你什么也不写。
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
   <title>控制结构</title>

   <para>
    控制结构可能是<application>PL/pgSQL</>中最有用的（以及最重要）的部分了。利用<application>PL/pgSQL</>的控制结构，你可以以非常灵活而且强大的方法操纵<productname>PostgreSQL</>的数据。
   </para>

   <sect2 id="plpgsql-statements-returning">
    <title>从一个函数返回</title>

    <para>
     有两个命令让我们能够从函数中返回数据：<command>RETURN</command>和<command>RETURN NEXT</command>。
    </para>

    <sect3>
     <title><command>RETURN</></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
      带有一个表达式的<command>RETURN</command>用于终止函数并把<replaceable>expression</replaceable>的值返回给调用者。这种形式被用于不返回集合的<application>PL/pgSQL</>函数。
     </para>

     <para>
      如果一个函数返回一个标量类型，表达式的结果将被自动转换成函数的返回类型。但是要返回一个复合（行）值，你必须写一个正好产生所需列集合的表达式。这可能需要使用显式造型。
     </para>

     <para>
      如果你声明带输出参数的函数，那么就只需要写不带表达式的<command>RETURN</command>。输出参数变量的当前值将被返回。
     </para>

     <para>
      如果你声明函数返回<type>void</type>，一个<command>RETURN</command>语句可以被用来提前退出函数；但是不要在<command>RETURN</command>后面写一个表达式。
     </para>

     <para>
      一个函数的返回值不能是未定义。如果控制到达了函数最顶层的块而没有碰到一个<command>RETURN</command>语句，那么会发生一个运行时错误。不过，这个限制不适用于带输出参数的函数以及返回<type>void</type>的函数。在这些情况中，如果顶层的块结束，将自动执行一个<command>RETURN</command>语句。
     </para>

     <para>
      一些例子：

<programlisting>
-- 返回一个标量类型的函数
RETURN 1 + 2;
RETURN scalar_var;

-- 返回一个组合类型的函数
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- 必须把列造型成正确的类型
</programlisting>
     </para>
    </sect3>

    <sect3>
     <title><command>RETURN NEXT</>以及<command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <para>
      当一个<application>PL/pgSQL</>函数被声明为返回<literal>SETOF <replaceable>sometype</></literal>，那么遵循的过程则略有不同。在这种情况下，要返回的个体项被用一个<command>RETURN NEXT</command>或者<command>RETURN QUERY</command>命令的序列指定，并且接着会用一个不带参数的最终<command>RETURN</command>命令来指示这个函数已经完成执行。<command>RETURN NEXT</command>可以被用于标量和复合数据类型；对于复合类型，将返回一个完整的结果<quote>表</quote>。<command>RETURN QUERY</command>将执行一个查询的结果追加到一个函数的结果集中。在一个单一的返回集合的函数中，<command>RETURN NEXT</command>和<command>RETURN QUERY</command>可以被随意地混合，这样它们的结果将被串接起来。
     </para>

     <para>
      <command>RETURN NEXT</command>和<command>RETURN QUERY</command>实际上不会从函数中返回 &mdash; 它们简单地向函数的结果集中追加零或多行。然后会继续执行<application>PL/pgSQL</>函数中的下一条语句。随着后继的<command>RETURN NEXT</command>和<command>RETURN QUERY</command>命令的执行，结果集就建立起来了。最后一个<command>RETURN</command>（应该没有参数）会导致控制退出该函数（或者你可以让控制到达函数的结尾）。
     </para>

     <para>
      <command>RETURN QUERY</command>有一种变体<command>RETURN QUERY EXECUTE</command>，它可以动态指定要被执行的查询。可以通过<literal>USING</>向计算出的查询字符串插入参数表达式，这和在<command>EXECUTE</>命令中的方式相同。
     </para>

     <para>
      如果你声明函数带有输出参数，只需要写不带表达式的<command>RETURN NEXT</command>。在每一次执行时，输出参数变量的当前值将被保存下来用于最终返回为结果的一行。注意为了创建一个带有输出参数的集合返回函数，在有多个输出参数时，你必须声明函数为返回<literal>SETOF record</literal>；或者如果只有一个类型为<replaceable>sometype</>的输出参数时，声明函数为<literal>SETOF <replaceable>sometype</></literal>。
     </para>

     <para>
      下面是一个使用<command>RETURN NEXT</command>的函数例子：

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- 这里可以做一些处理
        RETURN NEXT r; -- 返回 SELECT 的当前行
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>

     <para>
      这里是一个使用<command>RETURN QUERY</command>的函数的例子：

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate >= $1
                    AND flightdate < ($1 + 1);

    -- 因为执行还未结束，我们可以检查是否有行被返回
    -- 如果没有就抛出异常。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- 返回可用的航班或者在没有可用航班时抛出异常。
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>

     <note>
      <para>
       如上所述，目前<command>RETURN NEXT</command>和<command>RETURN QUERY</command>的实现在从函数返回之前会把整个结果集都保存起来。这意味着如果一个<application>PL/pgSQL</>函数生成一个非常大的结果集，性能可能会很差：数据将被写到磁盘上以避免内存耗尽，但是函数本身在整个结果集都生成之前不会退出。将来的<application>PL/pgSQL</>版本可能会允许用户定义没有这种限制的集合返回函数。目前，数据开始被写入到磁盘的时机由配置变量<xref linkend="guc-work-mem">控制。拥有足够内存来存储大型结果集的管理员可以考虑增大这个参数。
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
    <title>条件</title>

    <para>
     <command>IF</>和<command>CASE</>语句让你可以根据某种条件执行二选其一的命令。<application>PL/pgSQL</>有三种形式的<command>IF</>：
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</></>
     </listitem>
    </itemizedlist>

    以及两种形式的<command>CASE</>：
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN</literal>语句是<command>IF</>的最简单形式。 如果条件为真，在<literal>THEN</literal>和<literal>END IF</literal>之间的语句将被执行。否则，将忽略它们。
       </para>

       <para>
        例子：
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN-ELSE</literal>语句对<literal>IF-THEN</literal>进行了增加，它让你能够指定一组在条件不为真时应该被执行的语句（注意这也包括条件为 NULL 的情况）。
       </para>

       <para>
        例子：
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
        有时会有多于两种选择。<literal>IF-THEN-ELSIF</>则提供了一个简便的方法来检查多个条件。<literal>IF</>条件会被一个接一个测试，直到找到第一个为真的。然后执行相关语句，然后控制会被交给<literal>END IF</>之后的下一个语句（后续的任何<literal>IF</>条件<emphasis>不会</>被测试）。如果没有一个<literal>IF</>条件为真，那么<literal>ELSE</>块（如果有）将被执行。
       </para>

       <para>
        这里有一个例子：

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- 嗯，唯一的其他可能性是数字为空
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
        关键词<literal>ELSIF</>也可以被拼写成<literal>ELSEIF</>。
       </para>

       <para>
        另一个可以完成相同任务的方法是嵌套<literal>IF-THEN-ELSE</literal>语句，如下例：

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
        不过，这种方法需要为每个<literal>IF</>都写一个匹配的<literal>END IF</>，因此当有很多选择时，这种方法比使用<literal>ELSIF</>要麻烦得多。
       </para>
     </sect3>

     <sect3>
      <title>简单<literal>CASE</></title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       <command>CASE</>的简单形式提供了基于操作数等值判断的有条件执行。<replaceable>search-expression</>会被计算（一次）并且一个接一个地与<literal>WHEN</>子句中的每个<replaceable>expression</>比较。如果找到一个匹配，那么相应的<replaceable>statements</replaceable>会被执行，并且接着控制会被交给<literal>END CASE</>之后的下一个语句（后续的<literal>WHEN</>表达式不会被计算）。如果没有找到匹配，<literal>ELSE</> <replaceable>语句</replaceable>会被执行。但是如果<literal>ELSE</>不存在，将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>

      <para>
       这里是一个简单的例子：

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
      <title>搜索<literal>CASE</></title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       <command>CASE</>的搜索形式基于布尔表达式真假的有条件执行。每一个<literal>WHEN</>子句的<replaceable>boolean-expression</replaceable>会被依次计算，直到找到一个得到<literal>真</>的。然后相应的<replaceable>statements</replaceable>会被执行，并且接下来控制会被传递给<literal>END CASE</>之后的下一个语句（后续的<literal>WHEN</>表达式不会被计算）。如果没有找到为真的结果，<literal>ELSE</> <replaceable>statements</replaceable>会被执行。但是如果<literal>ELSE</>不存在，那么将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>

      <para>
       这里是一个例子：

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <para>
       这种形式的<command>CASE</>整体上等价于<literal>IF-THEN-ELSIF</>，不同之处在于<command>CASE</>到达一个被忽略的<literal>ELSE</>子句时会导致一个错误而不是什么也不做。
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
    <title>简单循环</title>

    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>在 PL/pgSQL 中</secondary>
    </indexterm>

    <para>
     使用<literal>LOOP</>、<literal>EXIT</>、<literal>CONTINUE</>、<literal>WHILE</>、<literal>FOR</>和<literal>FOREACH</>语句，你可以安排<application>PL/pgSQL</>重复一系列命令。
    </para>

    <sect3>
     <title><literal>LOOP</></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
      <literal>LOOP</>定义一个无条件的循环，它会无限重复直到被<literal>EXIT</>或<command>RETURN</command>语句终止。可选的<replaceable>label</replaceable>可以被<literal>EXIT</>和<literal>CONTINUE</literal>语句用在嵌套循环中指定这些语句引用的是哪一层循环。
     </para>
    </sect3>

     <sect3>
      <title><literal>EXIT</></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        如果没有给出<replaceable>label</replaceable>，那么最内层的循环会被终止，然后跟在<literal>END LOOP</>后面的语句会被执行。如果给出了<replaceable>label</replaceable>，那么它必须是当前或者更高层的嵌套循环或者语句块的标签。然后该命名循环或块就会被终止，并且控制会转移到该循环/块相应的<literal>END</>之后的语句上。
       </para>

       <para>
        如果指定了<literal>WHEN</>，只有<replaceable>boolean-expression</>为真时才会发生循环退出。否则，控制会转移到<literal>EXIT</>之后的语句。
       </para>

       <para>
        <literal>EXIT</>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>

       <para>
        在和<literal>BEGIN</literal>块一起使用时，<literal>EXIT</literal>会把控制交给块结束后的下一个语句。需要注意的是，一个标签必须被用于这个目的；一个没有被标记的<literal>EXIT</literal>永远无法被认为与一个<literal>BEGIN</literal>块匹配（这种状况从<productname>PostgreSQL</productname> 8.4 之前的发布就已经开始改变。这可能允许一个未被标记的<literal>EXIT</literal>匹配一个<literal>BEGIN</literal>块）。
       </para>

       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    IF count &gt; 0 THEN
        EXIT;  -- 退出循环
    END IF;
END LOOP;

LOOP
    -- 一些计算
    EXIT WHEN count &gt; 0;  -- 和前一个例子相同的结果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- 一些计算
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- 导致从 BEGIN 块中退出
    END IF;
    -- 当stocks &gt; 100000时，这里的计算将被跳过
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        如果没有给出<replaceable>label</>，最内层循环的下一次迭代会开始。也就是，循环体中剩余的所有语句将被跳过，并且控制会返回到循环控制表达式（如果有）来决定是否需要另一次循环迭代。如果<replaceable>label</>存在，它指定应该继续执行的循环的标签。
       </para>

       <para>
        如果指定了<literal>WHEN</>，该循环的下一次迭代只有在<replaceable>boolean-expression</>为真时才会开始。否则，控制会传递给<literal>CONTINUE</>后面的语句。
       </para>

       <para>
        <literal>CONTINUE</>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>

       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- 一些用于 count IN [50 .. 100] 的计算
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
      <title><literal>WHILE</></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        只要<replaceable>boolean-expression</replaceable>被计算为真，<literal>WHILE</>语句就会重复一个语句序列。在每次进入到循环体之前都会检查该表达式。
       </para>

       <para>
        例如：
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- 这里是一些计算
END LOOP;

WHILE NOT done LOOP
    -- 这里是一些计算
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
      <title><literal>FOR</>（整型变体）</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        这种形式的<literal>FOR</>会创建一个在一个整数范围上迭代的循环。变量<replaceable>name</replaceable>会自动定义为类型<type>integer</>并且只在循环内存在（任何该变量名的现有定义在此循环内都将被忽略）。给出范围上下界的两个表达式在进入循环的时候计算一次。如果没有指定<literal>BY</>子句，迭代步长为 1，否则步长是<literal>BY</>中指定的值，该值也只在循环进入时计算一次。如果指定了<literal>REVERSE</>，那么在每次迭代后步长值会被减除而不是增加。
       </para>

       <para>
        整数<literal>FOR</>循环的一些例子：
<programlisting>
FOR i IN 1..10 LOOP
    -- 我在循环中将取值 1,2,3,4,5,6,7,8,9,10 
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- 我在循环中将取值 10,9,8,7,6,5,4,3,2,1 
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- 我在循环中将取值 10,8,6,4,2 
END LOOP;
</programlisting>
       </para>

       <para>
        如果下界大于上界（或者在<literal>REVERSE</>情况下是小于），循环体根本不会被执行。而且不会抛出任何错误。
       </para>

       <para>
        如果一个<replaceable>label</replaceable>被附加到<literal>FOR</>循环，那么整数循环变量可以用一个使用那个<replaceable>label</replaceable>的限定名引用。
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
    <title>通过查询结果循环</title>

    <para>
     使用一种不同类型的<literal>FOR</>循环，你可以通过一个查询的结果进行迭代并且操纵相应的数据。语法是：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <replaceable>target</replaceable>是一个记录变量、行变量或者逗号分隔的标量变量列表。<replaceable>target</replaceable>被连续不断被赋予来自<replaceable>query</replaceable>的每一行，并且循环体将为每一行执行一次。下面是一个例子：
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- 现在 "mviews" 有来自 cs_materialized_views 的一个记录

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);
        EXECUTE 'INSERT INTO '
                   || quote_ident(mviews.mv_name) || ' '
                   || mviews.mv_query;
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     如果循环被一个<literal>EXIT</>语句终止，那么在循环之后你仍然可以访问最后被赋予的行值。
    </para>

    <para>
     在这类<literal>FOR</>语句中使用的<replaceable>query</replaceable>可以是任何返回行给调用者的 SQL 命令：最常见的是<command>SELECT</>，但你也可以使用带有<literal>RETURNING</>子句的<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>。一些<command>EXPLAIN</>之类的功能性命令也可以用在这里。
    </para>

    <para>
     <application>PL/pgSQL</>变量会被替换到查询文本中，并且如<xref linkend="plpgsql-var-subst">和<xref linkend="plpgsql-plan-caching">中详细讨论的，查询计划会被缓存以用于可能的重用。
    </para>

    <para>
     <literal>FOR-IN-EXECUTE</>语句是在行上迭代的另一种方式：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     这个例子类似前面的形式，只不过源查询被指定为一个字符串表达式，在每次进入<literal>FOR</>循环时都会计算它并且重新规划。这允许程序员在一个预先规划好了的命令的速度和一个动态命令的灵活性之间进行选择，就像一个纯<command>EXECUTE</command>语句那样。在使用<command>EXECUTE</command>时，可以通过<literal>USING</>将参数值插入到动态命令中。
    </para>

    <para>
     另一种指定要对其结果迭代的查询的方式是将它声明为一个游标。这会在<xref linkend="plpgsql-cursor-for-loop">中描述。
    </para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
    <title>通过数组循环</title>

    <para>
     <literal>FOREACH</>循环很像一个<literal>FOR</>循环，但不是通过一个 SQL 查询返回的行进行迭代，它通过一个数组值的元素来迭代（通常，<literal>FOREACH</>意味着通过一个组合值表达式的部件迭代；用于通过除数组之外组合类型进行循环的变体可能会在未来被加入）。在一个数组上循环的<literal>FOREACH</>语句是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
     如果没有<literal>SLICE</>，或者如果没有指定<literal>SLICE 0</>，循环会通过计算<replaceable>expression</replaceable>得到的数组的个体元素进行迭代。<replaceable>target</replaceable>变量被逐一赋予每一个元素值，并且循环体会为每一个元素执行。这里是一个通过整数数组的元素循环的例子：

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     元素会被按照存储顺序访问，而不管数组的维度数。尽管<replaceable>target</replaceable>通常只是一个单一变量，当通过一个组合值（记录）的数组循环时，它可以是一个变量列表。在那种情况下，对每一个数组元素，变量会被从组合值的连续列赋值。
    </para>

    <para>
     通过一个正<literal>SLICE</>值，<literal>FOREACH</>通过数组的切片而不是单一元素迭代。<literal>SLICE</>值必须是一个不大于数组维度数的整数常量。<replaceable>target</replaceable>变量必须是一个数组，并且它接收数组值的连续切片，其中每一个切片都有<literal>SLICE</>指定的维度数。这里是一个通过一维切片迭代的例子：

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
    <title>俘获错误</title>

    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
     默认情况下，任何在<application>PL/pgSQL</>函数中发生的错误会中止该函数的执行，而且实际上会中止其周围的事务。你可以使用一个带有<literal>EXCEPTION</>子句的<command>BEGIN</>块俘获错误并且从中恢复。其语法是<command>BEGIN</>块通常的语法的一个扩展：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

    <para>
     如果没有发生错误，这种形式的块只是简单地执行所有<replaceable>statements</replaceable>， 并且接着控制转到<literal>END</>之后的下一个语句。但是如果在<replaceable>statements</replaceable>内发生了一个错误，则会放弃对<replaceable>statements</replaceable>的进一步处理，然后控制会转到<literal>EXCEPTION</>列表。系统会在列表中寻找匹配所发生错误的第一个<replaceable>condition</replaceable>。如果找到一个匹配，则执行对应的<replaceable>handler_statements</replaceable>，并且接着把控制转到<literal>END</>之后的下一个语句。如果没有找到匹配，该错误就会传播出去，就好像根本没有<literal>EXCEPTION</>一样：错误可以被一个带有<literal>EXCEPTION</>的闭合块捕捉，如果没有<literal>EXCEPTION</>则中止该函数的处理。
    </para>

    <para>
     <replaceable>condition</replaceable>的名字可以是<xref linkend="errcodes-appendix">中显示的任何名字。一个分类名匹配其中所有的错误。特殊的条件名<literal>OTHERS</>匹配除了<literal>QUERY_CANCELED</>之外的所有错误类型（虽然通常并不明智，还是可以用名字捕获<literal>QUERY_CANCELED</>）。条件名是大小写无关的。一个错误条件也可以通过<literal>SQLSTATE</>代码指定，例如以下是等价的：
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <para>
     如果在选中的<replaceable>handler_statements</replaceable>内发生了新的错误，那么它不能被这个<literal>EXCEPTION</>子句捕获，而是被传播出去。一个外层的<literal>EXCEPTION</>子句可以捕获它。
    </para>

    <para>
     当一个错误被<literal>EXCEPTION</>捕获时，<application>PL/pgSQL</>函数的局部变量会保持错误发生时的值，但是该块中所有对持久数据库状态的改变都会被回滚。例如，考虑这个片段：

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

     当控制到达对<literal>y</>赋值的地方时，它会带着一个<literal>division_by_zero</>错误失败。这个错误将被<literal>EXCEPTION</>子句捕获。而在<command>RETURN</>语句中返回的值将是<literal>x</>增加过后的值。但是<command>UPDATE</>命令的效果将已经被回滚。不过，在该块之前的<command>INSERT</>将不会被回滚，因此最终的结果是数据库包含<literal>Tom Jones</>但不包含<literal>Joe Jones</>。
    </para>

    <tip>
     <para>
      进入和退出一个包含<literal>EXCEPTION</>子句的块要比不包含<literal>EXCEPTION</>的块开销大的多。因此，只在必要的时候使用<literal>EXCEPTION</>。
     </para>
    </tip>

    <example id="plpgsql-upsert-example">
    <title><command>UPDATE</>/<command>INSERT</>的异常</title>
    <para>

    这个例子使用异常处理来酌情执行<command>UPDATE</>或<command>INSERT</>：

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- 首先尝试更新见
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- 不在这里，那么尝试插入该键
        -- 如果其他某人并发地插入同一个键，
        -- 我们可能得到一个唯一键失败
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- 什么也不做，并且循环再次尝试 UPDATE
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     这段代码假定<literal>unique_violation</>错误是<command>INSERT</>造成，并且不是由该表上一个触发器函数中的<command>INSERT</>导致。如果在该表上有多于一个唯一索引，也可能会发生不正确的行为，因为不管哪个索引导致该错误它都将重试该操作。通过接下来要讨论的特性来检查被捕获的错误是否为所预期的会更安全。
    </para>
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
    <title>得到有关一个错误的信息</title>

    <para>
     异常处理器经常被用来标识发生的特定错误。有两种方法来得到<application>PL/pgSQL</>中当前异常的信息：特殊变量和<command>GET STACKED DIAGNOSTICS</command>命令。
    </para>

    <para>
     在一个异常处理器内，特殊变量<varname>SQLSTATE</varname>包含了对应于被抛出异常的错误代码（可能的错误代码列表见<xref linkend="errcodes-table">）。特殊变量<varname>SQLERRM</varname>包含与该异常相关的错误消息。这些变量在异常处理器外是未定义的。
    </para>

    <para>
     在一个异常处理器内，我们也可以用<command>GET STACKED DIAGNOSTICS</command>命令检索有关当前异常的信息，该命令的形式为：

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     每个<replaceable>item</replaceable>是一个关键词，它标识一个被赋予给指定变量（应该具有接收该值的正确数据类型）的状态值。<xref linkend="plpgsql-exception-diagnostics-values">中显示了当前可用的状态项。
    </para>

     <table id="plpgsql-exception-diagnostics-values">
      <title>错误诊断值</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>名称</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry>text</entry>
         <entry>该异常的 SQLSTATE 错误代码</entry>
        </row>
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry>text</entry>
         <entry>与异常相关的列名</entry>
        </row>
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry>text</entry>
         <entry>与异常相关的约束名</entry>
        </row>
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry>text</entry>
         <entry>与异常相关的数据类型名</entry>
        </row>
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry>text</entry>
         <entry>该异常的主要消息的文本</entry>
        </row>
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry>text</entry>
         <entry>与异常相关的表名</entry>
        </row>
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry>text</entry>
         <entry>与异常相关的模式名</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry>text</entry>
         <entry>该异常的详细消息文本（如果有）</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry>text</entry>
         <entry>该异常的提示消息文本（如果有）</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry>text</entry>
         <entry>描述调用栈的文本行</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     如果异常没有为一个项设置值，将返回一个空字符串。
    </para>

    <para>
     这里是一个例子：
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- 某些可能导致异常的处理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
   </sect3>
  </sect2>
  
  <sect2 id="plpgsql-get-diagnostics-context">
   <title>获得当前执行信息</title>

   <para>
    <command>GET <optional> CURRENT </optional> DIAGNOSTICS</command>
    命令检索有关当前执行状态的信息（反之上文讨论的
    <command>GET STACKED DIAGNOSTICS</command>命令会把有关
    执行状态的信息报告成一个以前的错误）。这个命令的形式：
   </para>

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

   <para>
    当前只支持一个信息项。状态项<literal>PG_CONTEXT</>将返回一个
    文本字符串，其中有描述该调用栈的多行文本。第一行会指向当前函数
    以及当前正在执行<command>GET DIAGNOSTICS</command>的
    命令。第二行及其后的行表示调用栈中更上层的调用函数。例如：

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)
</programlisting>

   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
   <title>游标</title>

   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>

   <para>
    和一次执行整个查询不同，可以建立一个<firstterm>游标</>来封装该查询，并且接着一次读取该查询结果的一些行。这样做的原因之一是在结果中包含大量行时避免内存不足（不过，<application>PL/pgSQL</>用户通常不需要担心这些，因为<literal>FOR</>循环在内部会自动使用一个游标来避免内存问题）。一种更有趣的用法是返回一个函数已经创建的游标的引用，允许调用者读取行。这提供了一种有效的方法从函数中返回大型行集。
   </para>

   <sect2 id="plpgsql-cursor-declarations">
    <title>声明游标变量</title>

    <para>
     所有在<application>PL/pgSQL</>中对游标的访问都会通过游标变量，它总是特殊的数据类型<type>refcursor</>。创建游标变量的一种方法是把它声明为一个类型为<type>refcursor</>的变量。另外一种方法是使用游标声明语法，通常是：
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     （为了对<productname>Oracle</productname>的兼容性，可以用<literal>IS</>替代<literal>FOR</>）。如果指定了<literal>SCROLL</>，那么游标可以反向滚动；如果指定了<literal>NO SCROLL</>，那么反向取的动作会被拒绝；如果二者都没有被指定，那么能否进行反向取就取决于查询。如果指定了<replaceable>arguments</replaceable>， 那么它是一个逗号分隔的<literal><replaceable>name</replaceable> <replaceable>datatype</replaceable></literal>对的列表， 它们定义在给定查询中要被参数值替换的名称。实际用于替换这些名字的值将在游标被打开之后指定。
    </para>
    <para>
     一些例子：
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     所有这三个变量都是<type>refcursor</>类型，但是第一个可以用于任何查询，而第二个已经被<firstterm>绑定</>了一个完全指定的查询，并且最后一个被绑定了一个参数化查询。（游标被打开时，<literal>key</>将被一个整数参数值替换）。变量<literal>curs1</>被称为<firstterm>未绑定</>，因为它没有被绑定到任何特定查询。
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
    <title>打开游标</title>

    <para>
     在一个游标可以被用来检索行之前，它必需先被<firstterm>打开</>（这是和 SQL 命令<command>DECLARE CURSOR</>等效的操作）。<application>PL/pgSQL</>有三种形式的<command>OPEN</>命令，其中两种用于未绑定游标变量，另外一种用于已绑定的游标变量。
    </para>

    <note>
     <para>
      可以通过<xref linkend="plpgsql-cursor-for-loop">中描述的<command>FOR</>语句在不显式打开游标的情况下使用已绑定的游标变量。
     </para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <para>
        该游标变量被打开并且被给定要执行的查询。游标不能是已经打开的，并且它必需已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</>变量）。该查询必须是一条<command>SELECT</command>或者其它返回行的东西（例如<command>EXPLAIN</>）。该查询会按照其它<application>PL/pgSQL</>中的 SQL 命令同等的方式对待：先代换<application>PL/pgSQL</>变量名，并且执行计划会被缓存用于可能的重用。当一个<application>PL/pgSQL</>变量被替换到游标查询中时，替换的值是在<command>OPEN</>时它所具有的值。对该变量后续的改变不会影响游标的行为。对于一个已经绑定的游标，<literal>SCROLL</>和<literal>NO SCROLL</>选项具有相同的含义。
       </para>

       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <para>
          打开游标变量并且执行指定的查询。该游标不能是已打开的，并且必须已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</>变量）。该查询以和<command>EXECUTE</command>中相同的方式被指定为一个字符串表达式。照例，这提供了灵活性，因此查询计划可以在两次运行之间变化（见<xref linkend="plpgsql-plan-caching">），并且它也意味着在该命令字符串上还没有完成变量替换。正如<command>EXECUTE</command>，可以通过<literal>USING</>将参数值插入到动态命令中。<literal>SCROLL</>和<literal>NO SCROLL</>选项具有和已绑定游标相同的含义。
         </para>

       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;
</programlisting>
        在这个例子中，表名被以文本形式插入到该查询中，因此我们推荐使用<function>quote_ident()</>来防止 SQL 注入。<literal>col1</>的比较值被通过一个<literal>USING</>参数被插入，因此它不需要引用。
       </para>
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
     <title>打开一个已绑定的游标</title>

<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>

         <para>
          这种形式的<command>OPEN</command>被用于打开一个游标变量，它的查询是在声明时绑定的。该游标不能是已经打开的。当且仅当该游标被声明为接收参数时，才必需出现一个实际参数值表达式的列表。这些值将被替换到命令中。
         </para>

         <para>
          一个已绑定游标的查询计划总是被认为是可缓存的，在这种情况中没有<command>EXECUTE</command>的等效形式。注意<literal>SCROLL</>和<literal>NO SCROLL</>不能在<command>OPEN</>中指定，因为游标的滚动行为已经被确定。
         </para>

         <para>
          使用<firstterm>位置</firstterm>或<firstterm>命名</firstterm>记号可以传递参数值。在位置记号中，所有参数都必须按照顺序指定。在命名记号中，每一个参数的名字被使用<literal>:=</literal>指定以将它和参数表达式分隔开。类似于<xref linkend="sql-syntax-calling-funcs">中描述的调用函数，也允许混合位置和命名记号。
         </para>

         <para>
          例子（这些例子使用上面例子中的游标声明）：
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>

         <para>
          因为在一个已绑定游标的查询上已经完成了变量替换，实际有两种方式将值传到游标中：给<command>OPEN</>一个显式参数，或者在查询中隐式引用一个<application>PL/pgSQL</>变量。不过，只有在已绑定游标之前声明的变量才将会被替换到游标中。在两种情况下，要被传递的值都是在<command>OPEN</>时确定的。例如，得到上例中<literal>curs3</>相同效果的另一种方式是
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
    <title>使用游标</title>

    <para>
     一旦一个游标已经被打开，那么就可以用这里描述的语句操作它。
    </para>

    <para>
     这些操作不需要发生在打开该游标开始操作的同一个函数中。你可以从一个函数返回一个<type>refcursor</>值，并且让调用者在该游标上操作（在内部，<type>refcursor</>值只是一个包含该游标活动查询的所谓入口的字符串名称。这个名字可以被传递、赋予给其它<type>refcursor</>变量等等，而不用担心扰乱入口）。
    </para>

    <para>
     所有入口会在事务的结尾被隐式地关闭。因此一个<type>refcursor</>值只能在该事务结束前用于引用一个打开的游标。
    </para>

    <sect3>
     <title><literal>FETCH</></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <para>
     就像<command>SELECT INTO</command>一样，<command>FETCH</command>从游标中检索下一行到目标中，目标可以是一个行变量、记录变量或者逗号分隔的简单变量列表。如果没有下一行，目标会被设置为 NULL。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看一行是否被获得。
    </para>

    <para>
     <replaceable>direction</replaceable>子句可以是 SQL <xref linkend="sql-fetch">命令中允许的任何变体，除了那些能够取得多于一行的。即它可以是
     <literal>NEXT</>、
     <literal>PRIOR</>、
     <literal>FIRST</>、
     <literal>LAST</>、
     <literal>ABSOLUTE</> <replaceable>count</replaceable>、
     <literal>RELATIVE</> <replaceable>count</replaceable>、
     <literal>FORWARD</>或者
     <literal>BACKWARD</>。
     省略<replaceable>direction</replaceable>和指定<literal>NEXT</>是一样的。除非游标被使用<literal>SCROLL</>选项声明或打开，否则要求反向移动的<replaceable>direction</replaceable>值很可能会失败。
    </para>

    <para>
     <replaceable>cursor</replaceable>必须是一个引用已打开游标入口的<type>refcursor</>变量名。
    </para>

    <para>
     例子：
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>MOVE</></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <para>
     <command>MOVE</command>重新定位一个游标而不检索任何数据。<command>MOVE</command>的工作方式与<command>FETCH</command>命令很相似，但是<command>MOVE</command>只是重新定位游标并且不返回至移动到的行。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看要移动到的行是否存在。
    </para>

    <para>
     <replaceable>direction</replaceable>子句可以是 SQL <xref linkend="sql-fetch">命令中允许的任何变体，即
     <literal>NEXT</>、
     <literal>PRIOR</>、
     <literal>FIRST</>、
     <literal>LAST</>、
     <literal>ABSOLUTE</> <replaceable>count</replaceable>、
     <literal>RELATIVE</> <replaceable>count</replaceable>、
     <literal>ALL</>、
     <literal>FORWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>或者
     <literal>BACKWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>。
     省略<replaceable>direction</replaceable>和指定<literal>NEXT</>是一样的。除非游标被使用<literal>SCROLL</>选项声明或打开，否则要求反向移动的<replaceable>direction</replaceable>值很可能会失败。
    </para>

    <para>
     例子：
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <para>
        当一个游标被定位到一个表行上时，使用该游标标识该行就可以对它进行更新或删除。对于游标的查询可以是什么是有限制的（尤其是不能有分组），并且最好在游标中使用<literal>FOR UPDATE</>。详见<xref linkend="sql-declare">参考页。
       </para>

       <para>
        一个例子：
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <para>
        <command>CLOSE</command>关闭一个已打开游标的底层入口。这样就可以在事务结束之前释放资源，或者释放掉该游标变量以便再次打开。
       </para>

       <para>
        一个例子：
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title>返回游标</title>

       <para>
        <application>PL/pgSQL</>函数可以向调用者返回游标。这对于返回多行或多列（特别是巨大的结果集）很有用。要想这么做，该函数打开游标并且把该游标的名字返回给调用者（或者简单的使用调用者指定的或已知的入口名打开游标）。调用者接着可以从游标中取得行。游标可以由调用者关闭，或者是在事务关闭时自行关闭。
       </para>

       <para>
        用于一个游标的入口名可以由编程者指定或者自动生成。要指定一个入口名，只需要在打开<type>refcursor</>变量之前简单地为它赋予一个字符串。<command>OPEN</>将把<type>refcursor</>变量的字符串值用作底层入口的名字。不过，如果<type>refcursor</>变量为空，<command>OPEN</>会自动生成一个与任何现有入口不冲突的名称，并且将它赋予给<type>refcursor</>变量。
       </para>

       <note>
        <para>
         一个已绑定的游标变量被初始化为表示其名称的字符串值，因此入口的名字和游标变量名相同，除非程序员在打开游标之前通过赋值覆盖了这个名字。但是一个未绑定的游标变量最初默认为空值，因此它会收到一个自动生成的唯一名字，除非被覆盖。
        </para>
       </note>

       <para>
        下面的例子显示了一个调用者提供游标名字的方法：

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       <para>
        下面的例子使用了自动游标名生成：

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

       <para>
        下面的例子展示了从一个函数中返回多个游标的一种方法：

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
    <title>通过一个游标的结果循环</title>

    <para>
     有一种<command>FOR</>语句的变体，它允许通过游标返回的行进行迭代。语法是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     该游标变量必须在声明时已经被绑定到某个查询，并且它<emphasis>不能</>已经被打开。<command>FOR</>语句会自动打开游标，并且在退出循环时自动关闭游标。当且仅当游标被声明要使用参数时，才必须出现一个实际参数值表达式的列表。这些值会被替换到查询中，采用<command>OPEN</>期间的方式（见<xref linkend="plpgsql-open-bound-cursor">）。
   </para>

   <para>
     变量<replaceable>recordvar</replaceable>会被自动定义为<type>record</>类型，并且只存在于循环内部（循环中该变量名任何已有定义都会被忽略）。每一个由游标返回的行都会被陆续地赋值给这个记录变量并且执行循环体。
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
   <title>错误和消息</title>

   <indexterm>
    <primary>RAISE</primary>
   </indexterm>

   <indexterm>
    <primary>报告错误</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>

   <para>
    使用<command>RAISE</command>语句报告消息以及抛出错误。

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    <replaceable class="parameter">level</replaceable>选项指定了错误的严重性。允许的级别有<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>, <literal>WARNING</literal>以及<literal>EXCEPTION</literal>，默认级别是<literal>EXCEPTION</literal>。<literal>EXCEPTION</literal>会抛出一个错误（通常会中止当前事务）。其他级别仅仅是产生不同优先级的消息。不管一个特定优先级的消息是被报告给客户端、还是写到服务器日志、亦或是二者同时都做，这都由<xref linkend="guc-log-min-messages">和<xref linkend="guc-client-min-messages">配置变量控制。详见<xref linkend="runtime-config">。
   </para>

   <para>
    如果有<replaceable class="parameter">level</replaceable>，在它后面可以写一个<replaceable class="parameter">format</replaceable>（它必须是一个简单字符串而不是表达式）。该格式字符串指定要被报告的错误消息文本。在格式字符串后面可以跟上可选的要被插入到该消息的参数表达式。在格式字符串中，<literal>%</literal>会被下一个可选参数的值所替换。写<literal>%%</literal>可以发出一个字面的<literal>%</literal>。
   </para>

   <para>
    在这个例子中，<literal>v_job_id</>的值将替换字符串中的<literal>%</literal>：
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   <para>
    通过写一个后面跟着<replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable>项的<literal>USING</>，可以为错误报告附加一些额外信息。每一个<replaceable class="parameter">expression</replaceable>可以是任意字符串值的表达式。允许的<replaceable class="parameter">option</replaceable>关键词是：

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>设置错误消息文本。这个选项可以被用于在<literal>USING</>之前包括一个格式字符串的<command>RAISE</>形式。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>提供一个错误的细节消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>提供一个提示消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>指定要报告的错误代码（SQLSTATE），可以用<xref linkend="errcodes-appendix">中所示的条件名，或者直接作为一个五字符的 SQLSTATE 代码。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>提供一个相关对象的名称。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    这个例子将用给定的错误消息和提示中止事务：
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>

   <para>
    这两个例子展示了设置 SQLSTATE 的两种等价的方法：
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   <para>
    还有第二种<command>RAISE</>语法，在其中主要参数是要被报告的条件名或 SQLSTATE，例如：
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    在这种语法中，<literal>USING</>能被用来提供一个自定义的错误消息、细节或提示。另一种做前面的例子的方法是
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

   <para>
    仍有另一种变体是写<literal>RAISE USING</>或者<literal>RAISE <replaceable class="parameter">level</replaceable> USING</>并且把所有其他东西都放在<literal>USING</>列表中。
   </para>

   <para>
    <command>RAISE</>的最后一种变体根本没有参数。这种形式只能被用在一个<literal>BEGIN</>块的<literal>EXCEPTION</>子句中，它导致当前正在被处理的错误被重新抛出。
   </para>

   <note>
    <para>
     在<productname>PostgreSQL</> 9.1 之前，没有参数的<command>RAISE</>被解释为重新抛出来自包含活动异常处理器的块的错误。因此一个嵌套在那个处理器中的<literal>EXCEPTION</>子句无法捕捉它，即使<command>RAISE</>位于嵌套<literal>EXCEPTION</>子句的块中也是这样。这种行为很奇怪，也并不兼容 Oracle 的 PL/SQL。
    </para>
   </note>

   <para>
    如果在一个<command>RAISE EXCEPTION</command>命令中没有指定条件名以及 SQLSTATE，默认是使用<literal>RAISE_EXCEPTION</> (<literal>P0001</>)。如果没有指定消息文本，默认是使用条件名或 SQLSTATE 作为消息文本。
   </para>

   <note>
    <para>
     当用 SQLSTATE 代码指定一个错误代码时，你不会受到预定义错误代码的限制，而是可以选择任何由五位以及大写 ASCII 字母构成的错误代码，只有<literal>00000</>不能使用。我们推荐尽量避免抛出以三个零结尾的错误代码，因为这些是分类代码并且只能用来捕获整个类别。
    </para>
   </note>

 </sect1>

 <sect1 id="plpgsql-trigger">
  <title>触发器过程</title>

  <indexterm zone="plpgsql-trigger">
   <primary>触发器</primary>
   <secondary>在 PL/pgSQL 中</secondary>
  </indexterm>

  <sect2 id="plpgsql-dml-trigger">
   <title>数据改变的触发器</title>

   <para>
    <application>PL/pgSQL</application>可以被用来定义触发器过程。触发器过程用<command>CREATE FUNCTION</>命令创建，将它声明为一个不带参数并且返回类型为<type>trigger</type>的函数。注意该函数必须被声明为不带参数，即使它希望接收在<command>CREATE TRIGGER</>中指定的参数 &mdash; 如下所述，触发器参数会通过<varname>TG_ARGV</>传递。
  </para>

  <para>
   当一个<application>PL/pgSQL</application>函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>INSERT</>/<command>UPDATE</>操作保持新数据行。在语句级别的触发器以及<command>DELETE</command>操作，这个变量未被赋值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>UPDATE</>/<command>DELETE</>操作保持新数据行。在语句级别的触发器以及<command>INSERT</command>操作，这个变量未被赋值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；该变量包含实际触发的触发器名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>BEFORE</literal>、<literal>AFTER</literal>或<literal>INSTEAD OF</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>ROW</literal>或<literal>STATEMENT</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或<literal>TRUNCATE</>的一个字符串，它说明触发器是为哪个操作引发。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       数据类型是<type>oid</type>；是导致触发器调用的表的对象 ID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用<literal>TG_TABLE_NAME</>替代。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表所在的模式名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       数据类型是<type>integer</type>；在<command>CREATE TRIGGER</command>语句中给触发器过程的参数数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>数组；来自<command>CREATE TRIGGER</command>语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于<varname>tg_nargs</>）会导致返回一个空值。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
    一个触发器函数必须返回<symbol>NULL</symbol>或者是一个与触发器为之引发的表结构完全相同的记录/行值。
   </para>

   <para>
    <literal>BEFORE</>引发的行级触发器可以返回一个空来告诉触发器管理器跳过对该行剩下的操作（即后续的触发器将不再被引发，并且不会对该行发生<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>)。如果返回了一个非空值，那么对该行值会继续操作。返回不同于原始<varname>NEW</>的行值将修改将要被插入或更新的行。因此，如果该触发器函数想要触发动作正常成功而不修改行值，<varname>NEW</>（或者另一个相等的值）必须被返回。要修改将被存储的行，可以直接在<varname>NEW</>中替换单一值并且返回修改后的<varname>NEW</>，或者构建一个全新的记录/行来返回。在一个<command>DELETE</command>上的前触发器情况下，返回值没有直接效果，但是它必须为非空以允许触发器动作继续下去。注意<varname>NEW</varname>在<command>DELETE</command>触发器中是空值，因此返回它通常没有意义。在<command>DELETE</command>中的常用方法是返回<varname>OLD</varname>.
   </para>

   <para>
    <literal>INSTEAD OF</>触发器（总是行级触发器，并且可能只被用于视图）能够返回空来表示它们没有执行任何更新，并且对该行剩余的操作可以被跳过（即后续的触发器不会被引发，并且该行不会被计入外围<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>的行影响状态中）。否则一个非空值应该被返回用以表示该触发器执行了所请求的操作。对于<command>INSERT</> 和<command>UPDATE</>操作，返回值应该是<varname>NEW</>，触发器函数可能对它进行了修改来支持<command>INSERT RETURNING</>和<command>UPDATE RETURNING</>（这也将影响被传递给任何后续触发器的行值）。对于<command>DELETE</>操作，返回值应该是<varname>OLD</>。
   </para>

   <para>
    一个<literal>AFTER</literal>行级触发器或一个<literal>BEFORE</>或<literal>AFTER</>语句级触发器的返回值总是会被忽略，它可能也是空。不过，任何这些类型的触发器可能仍会通过抛出一个错误来中止整个操作。
   </para>

   <para>
    <xref linkend="plpgsql-trigger-example">展示了<application>PL/pgSQL</application>中一个触发器过程的例子。
   </para>

   <example id="plpgsql-trigger-example">
    <title>一个 <application>PL/pgSQL</application> 触发器过程</title>

    <para>
     这个例子触发器保证：任何时候一个行在表中被插入或更新时，当前用户名和时间也会被标记在该行中。并且它会检查给出了一个雇员的姓名以及薪水是一个正值。
    </para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- 检查给出了 empname 以及 salary
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- 谁会倒贴钱为我们工作？
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- 记住谁在什么时候改变了工资单
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
</programlisting>
   </example>

   <para>
    另一种记录对表的改变的方法涉及到创建一个新表来为每一个发生的插入、更新或删除保持一行。这种方法可以被认为是对一个表的改变的审计。<xref linkend="plpgsql-trigger-audit-example">展示了<application>PL/pgSQL</application>中一个审计触发器过程的例子。
   </para>

   <example id="plpgsql-trigger-audit-example">
    <title>一个用于审计的 <application>PL/pgSQL</application> 触发器过程</title>

    <para>
     这个例子触发器保证了在<literal>emp</literal>表上的任何插入、更新或删除一行的动作都被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被记录到行中，还有在其上执行的操作类型。
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- 在 emp_audit 中创建一行来反映 emp 上执行的动作，
        -- 使用特殊变量 TG_OP 来得到操作。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- 因为这是一个 AFTER 触发器，结果被忽略
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();
</programlisting>
   </example>

   <para>
    前一个例子的一种变体使用一个视图将主表连接到审计表来展示每一项最后被修改是什么时间。这种方法还是记录了对于表修改的完整审查跟踪，但是也提供了审查跟踪的一个简化视图，只为每一个项显示从审查跟踪生成的最后修改时间戳。<xref linkend="plpgsql-view-trigger-audit-example">展示了在<application>PL/pgSQL</application>中一个视图上审计触发器的例子。
   </para>

   <example id="plpgsql-view-trigger-audit-example">
    <title>一个用于审计的 <application>PL/pgSQL</application> 视图触发器过程</title>

    <para>
     这个例子在视图上使用了一个触发器让它变得可更新，并且确保视图中一行的任何插入、更新或删除被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被与执行的操作类型一起记录，并且该视图会显示每一行的最后修改时间。
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- 执行 emp 上所要求的操作，并且在 emp_audit 中创建一行来反映对 emp 的改变。
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();
</programlisting>
   </example>

   <para>
    触发器的一种用法是维护一个表的另一个汇总表。作为结果的汇总表可以用来在特定查询中替代原始表 &mdash; 通常会大量减少运行时间。这种技术常用于数据仓库中，在其中被度量或被观察数据的表（称为事实表）可能会极度大。<xref linkend="plpgsql-trigger-summary-example">展示了<application>PL/pgSQL</application>中一个为数据仓库事实表维护汇总表的触发器过程的例子。
   </para>


   <example id="plpgsql-trigger-summary-example">
    <title>一个 <application>PL/pgSQL</application> 用于维护汇总表的触发器过程</title>

    <para>
     这里详述的模式有一部分是基于 Ralph Kimball 所作的<emphasis>The Data Warehouse Toolkit</emphasis>中的<emphasis>Grocery Store</emphasis>例子。
    </para>

<programlisting>
--
-- 主表 - 时间维度和销售事实。
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- 汇总表 - 按时间汇总销售
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- 在 UPDATE、INSERT、DELETE 时修改汇总列的函数和触发器。
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- 算出增量/减量数。
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- 禁止更改 the time_key 的更新-
            -- （可能不会太麻烦，因为大部分的更改是用 DELETE + INSERT 完成的）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- 插入或更新带有新值的汇总行。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- 什么也不做
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>
</sect2>

  <sect2 id="plpgsql-event-trigger">
   <title>事件触发器</title>

   <para>
    <application>PL/pgSQL</application>可以被用来定义事件触发器。<productname>PostgreSQL</>要求一个可以作为事件触发器调用的过程必须被声明为一个没有参数并且返回类型为<literal>event_trigger</>的函数。
   </para>

   <para>
    当一个<application>PL/pgSQL</application>函数被作为一个事件触发器调用，在顶层块中会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个表示引发触发器的事件的字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个变量，包含了该触发器为之引发的命令标签。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
    <xref linkend="plpgsql-event-trigger-example">展示了<application>PL/pgSQL</application>中一个事件触发器过程的例子。
   </para>

   <example id="plpgsql-event-trigger-example">
    <title>一个 <application>PL/pgSQL</application> 事件触发器过程</title>

    <para>
     这个例子触发器在受支持命令每一次被执行时会简单地抛出一个<literal>NOTICE</literal>消息。
    </para>

<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();
</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
   <title><application>PL/pgSQL</>的内部</title>

   <para>
    这一节讨论了一些<application>PL/pgSQL</>用户应该知道的一些重要的实现细节。
   </para>

  <sect2 id="plpgsql-var-subst">
   <title>变量替换</title>

   <para>
    一个<application>PL/pgSQL</>函数中的 SQL 语句和表达式能够引用该函数的变量和参数。在现象背后，<application>PL/pgSQL</>会为这些引用替换查询参数。只有在语法上允许一个参数或列引用的地方才会替换参数。作为一种极端情况，考虑这个编程风格糟糕的例子：
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    <literal>foo</>的第一次出现在语法上必须是一个表名， 因此它将不会被替换，即使该函数有一个名为<literal>foo</>的变量。第二次出现必须是该表的一列的名称，因此它也将不会被替换。只有第三次出现是对该函数变量引用的候选。
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> 9.0 之前的版本将尝试替换所有三种情况的变量，这会导致语法错误。
    </para>
   </note>

   <para>
    因为变量名在语法上与表列的名字没什么区别，在也引用表的语句中会有歧义：一个给定的名字意味着一个表列或一个变量？让我们把前一个例子改成：
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    这里，<literal>dest</>和<literal>src</>必须是表名，并且<literal>col</>必须是<literal>dest</>的一列，但是<literal>foo</>和<literal>bar</>可能该函数的变量或者<literal>src</>的列。
   </para>

   <para>
    默认情况下，如果一个 SQL 语句中的名称可能引用一个变量或者一个表列，<application>PL/pgSQL</>将报告一个错误。修复这种问题的方法很多：你可以重命名变量或列来，或者对有歧义的引用加以限定，或者告诉<application>PL/pgSQL</>要引用哪种解释。
   </para>

   <para>
    最简单的解决方案是重命名变量或列。一种常用的编码规则是为<application>PL/pgSQL</application>变量使用一种不同于列名的命名习惯。例如，如果你将函数变量统一地命名为<literal>v_<replaceable>something</></literal>，而你的列名不会开始于<literal>v_</>，就不会发生冲突。
   </para>

   <para>
    另外你可以限定有歧义的引用让它们变清晰。在上面的例子中，<literal>src.foo</>将是对表列的一种无歧义的引用。要创建对一个变量的无歧义引用，在一个被标记的块中声明它并且使用块的标签（见<xref linkend="plpgsql-structure">）。例如
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    这里<literal>block.foo</>表示变量，即使在<literal>src</>中有一个列<literal>foo</>。函数参数以及诸如<literal>FOUND</>的特殊变量，都能通过函数的名称被限定，因为它们被隐式地声明在一个带有该函数名称的外层块中。
   </para>

   <para>
    有时候在一个大型的<application>PL/pgSQL</>代码体中修复所有的有歧义引用是不现实的。在这种情况下，你可以指定<application>PL/pgSQL</>应该将有歧义的引用作为变量（这与<application>PL/pgSQL</>在 <productname>PostgreSQL</productname> 9.0 之前的行为兼容）或表列（这与某些其他系统兼容，例如<productname>Oracle</productname>）解决。
   </para>

   <indexterm>
     <primary><varname>plpgsql.variable_conflict</>配置参数</primary>
   </indexterm>

   <para>
    要在系统范围内改变这种行为，将配置参数<literal>plpgsql.variable_conflict</>设置为<literal>error</>、<literal>use_variable</>或者<literal>use_column</>（这里<literal>error</>是出厂设置）之一。这个参数会影响<application>PL/pgSQL</>函数中语句的后续编译，但是不会影响在当前会话中已经编译过的语句。因为改变这个设置能够导致<application>PL/pgSQL</>函数中行为的意想不到的改变，所以只能由一个超级用户来更改它。
   </para>

   <para>
    你也可以对逐个函数设置该行为，做法是在函数文本的开始插入这些特殊命令之一：
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    这些命令只影响它们所属的函数，并且会覆盖<literal>plpgsql.variable_conflict</>的设置。一个例子是：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    在<literal>UPDATE</>命令中，<literal>curtime</>、<literal>comment</>以及<literal>id</>将引用该函数的变量和参数，不管<literal>users</>有没有这些名称的列。注意，我们不得不在<literal>WHERE</>子句中对<literal>users.id</>的引用加以限定，以便让它引用表列。但是我们不需要在<literal>UPDATE</>列表中把对<literal>comment</>的引用限定为一个目标，因为语法上那必须是<literal>users</>的一列。我们可以用下面的方式写一个相同的不依赖于<literal>variable_conflict</>设置的函数：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    被交给<command>EXECUTE</>或其变体的命令字符串中不会发生变量替换。如果你需要插入一个变化值到这样一个命令中，在构建该字符串值时就这样做，或者使用<literal>USING</>，如<xref linkend="plpgsql-statements-executing-dyn">中所阐明的。
   </para>

   <para>
    当前变量替换只能在<command>SELECT</>、<command>INSERT</>、<command>UPDATE</>和<command>DELETE</>命令中工作，因为主 SQL 引擎只允许查询参数在这些命令中。要在其他语句类型（通常被称为实用语句）中使用一个非常量名称或值，你必须将实用语句构建为一个字符串并且<command>EXECUTE</>它。
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
   <title>计划缓存</title>

   <para>
    在函数被第一次调用时（在每个会话中），<application>PL/pgSQL</>解释器解析函数的源文本并且产生一个内部的二进制指令树。该指令树完全翻译了<application>PL/pgSQL</>语句结构，但是该函数中使用的<acronym>SQL</acronym>表达式以及<acronym>SQL</acronym>命令并没有被立即翻译。
   </para>

   <para>
    <indexterm>
     <primary>准备一个查询</>
     <secondary>在 PL/pgSQL 中</>
    </indexterm>
    作为该函数中每一个表达式和第一次被执行的<acronym>SQL</acronym>命令，<application>PL/pgSQL</>解释器使用<acronym>SPI</acronym>管理器的<function>SPI_prepare</function>函数解析并且分析该命令来创建一个预备语句。对于那个表达式或命令的后续访问将会重用该预备语句。因此，一个带有很少被访问的条件性代码路径的函数将永远不会发生分析那些在当前会话中永远不被执行的命令的开销。一个缺点是在一个特定表达式或命令中的错误将不能被检测到，直到函数的该部分在执行时被到达（不重要的语法错误在初始的解析中就会被检测到，但是任何更深层次的东西将只有在执行时才能检测到）。
   </para>

   <para>
    <application>PL/pgSQL</>（或者更准确地说是 SPI 管理器）能进一步尝试缓冲与任何特定预备语句相关的执行计划。如果没有使用一个已缓存的计划，那么每次访问该语句时都会生成一个新的执行计划，并且当前的参数值（也就是<application>PL/pgSQL</>的变量值）可以被用来优化被选中的计划。如果该语句没有参数，或者要被执行很多次，SPI 管理器将考虑创建一个不依赖特定参数值的<firstterm>一般</>计划并且将其缓存用于重用。通常只有在执行计划对其中引用的<application>PL/pgSQL</>变量值不那么敏感时，才会这样做。如果这样做，每一次生成的计划就是纯利。关于预备语句的行为请详见<xref linkend="sql-prepare">。
   </para>

   <para>
    由于<application>PL/pgSQL</application>保存预备语句并且有时候以这种方式保存执行计划，直接出现在一个<application>PL/pgSQL</application>函数中的 SQL 命令必须在每次执行时引用相同的表和列。也就是说，你不能在一个 SQL 命令中把一个参数用作表或列的名字。要绕过这种限制，你可以构建<application>PL/pgSQL</application> <command>EXECUTE</command>使用的动态命令，但是会付出在每次执行时需要执行新解析分析以及构建新执行计划的代价。
   </para>

    <para>
     记录变量的易变天性在这个关系中带来了另一个问题。当一个记录变量的域被用在表达式或语句中时，域的数据类型不能在该函数的调用之间改变，因为每一个表达式被分析时都将使用第一次到达该表达式时存在的数据类型。必要时，可以用<command>EXECUTE</command>来绕过这个问题。
    </para>

    <para>
     如果同一个函数被用作一个服务于多个表的触发器，<application>PL/pgSQL</application>会为每一个这样的表独立地准备并缓存语句 &mdash; 也就是对每一种触发器函数和表的组合都会有一个缓存，而不是每个函数一个缓存。这减轻了数据类型变化带来的问题。例如，一个触发器函数将能够成功地使用一个名为<literal>key</>的列工作，即使该列正好在不同的表中有不同的类型。
    </para>

    <para>
     同样，具有多态参数类型的函数也会为它们已经被调用的每一种实参类型组合都保留一个独立的缓存，这样数据类型差异不会导致意想不到的失败。
    </para>

   <para>
    语句缓存有时可能在解释时间敏感的值时产生令人惊讶的效果。例如这两个函数做的事情就有区别：

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     以及：

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <para>
     在<function>logfunc1</function>中，<productname>PostgreSQL</productname>的主解析器在分析<command>INSERT</command>时就知道字符串<literal>'now'</literal>应该被解释为<type>timestamp</type>，因为<classname>logtable</classname>的目标列是这种类型。因此，在<command>INSERT</command>被分析时<literal>'now'</literal>将被转换为一个<type>timestamp</type>常量，并且在该会话的生命周期内被用于所有对<function>logfunc1</function>的调用。不用说，这不是程序员想要的。一个更好的主意是使用<literal>now()</>或<literal>current_timestamp</>函数。
    </para>

    <para>
     在<function>logfunc2</function>中，<productname>PostgreSQL</productname>的主解析器不知道<literal>'now'</literal>应该变成什么类型并且因此返回一个<type>text</type>类型的包含字符串<literal>now</literal>的数据值。在确定对本地变量<varname>curtime</varname>的赋值期间，<application>PL/pgSQL</application>解释器通过调用用于转换的<function>text_out</function>以及<function>timestamp_in</function>函数将这个字符串造型为<type>timestamp</type>类型。因此，计算出来的时间戳会按照程序员的期待在每次执行时更新。虽然这正好符合预期，但是它的效率很糟糕，因此使用<literal>now()</>函数仍然是一种更好的方案。
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
  <title><application>PL/pgSQL</application>开发提示</title>

   <para>
    在<application>PL/pgSQL</>中进行开发的一种好方法是使用你自己选择的文本编辑器来创建函数，并且在另一个窗口中使用<application>psql</application>来载入并且测试那些函数。如果你正在这样做，使用<command>CREATE OR REPLACE FUNCTION</>来编写函数是一个好主意。用那种方式你只需要重载该文件来更新函数的定义。例如：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    在运行<application>psql</application>期间，你可以用下面的命令载入或者重载这样一个函数定义文件：
<programlisting>
\i filename.sql
</programlisting>
    并且接着立即发出 SQL 命令来测试该函数。
   </para>

   <para>
    另一种在<application>PL/pgSQL</>中开发的方式是用一个 GUI 数据库访问工具，它能方便对过程语言的开发。这种工具的一个例子是<application>pgAdmin</>。这些工具通常提供方便的特性，例如转义单引号以及便于重新创建和调试函数。
   </para>

  <sect2 id="plpgsql-quote-tips">
   <title>处理引号</title>

   <para>
    一个<application>PL/pgSQL</>函数的代码在一个<command>CREATE FUNCTION</command>中被指定为一个字符串。如果你用通常的方式把该字符串写在单引号中间，那么该函数体中的任何单引号都必须被双写；同样任何反斜线也必须被双写（假定使用了转义字符串语法）。双写引号最多有点冗长，并且在更复杂的情况中代码会变得完全无法理解，因为你很容易发现你需要半打或者更多相邻的引号。我们推荐你转而把函数体写成一个<quote>美元引用</>的字符串（见<xref linkend="sql-syntax-dollar-quoting">）。在美元引用方法中，你从不需要双写任何引号。但是要注意为你需要的每一层嵌套选择一个不同的美元引用定界符。例如，你可能把<command>CREATE FUNCTION</command>命令写成：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    在这里面，你可以在 SQL 命令中为简单字符串使用引号并且用<literal>$$</>来界定被你组装成字符串的 SQL 命令片段。如果你需要引用包括<literal>$$</>的文本，你可以使用<literal>$Q$</>等等。
   </para>

   <para>
    下列图表展示了在写没有美元引用的引号时需要做什么。在将之前用美元引用的代码翻译成更容易理解的代码时，它们会有所帮助。
  </para>

  <variablelist>
   <varlistentry>
    <term>1 个引号</term>
    <listitem>
     <para>
      用来开始和结束函数体，例如：
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      在一个单引号引用的函数体中的任何位置，引号<emphasis>必须</>成对出现。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>2 个引号</term>
    <listitem>
     <para>
      用于函数体内的字符串，例如：
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      在美元引用方法中，你只需要写：
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      这恰好就是<application>PL/pgSQL</>在两种情况中会看到的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>4 个引号</term>
    <listitem>
     <para>
      当你在函数内的一个字符串常量中需要一个单引号时，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      实际会被追加到<literal>a_output</literal>的值将是：<literal> AND name LIKE 'foobar' AND xyz</literal>。
     </para>
     <para>
      在美元引用方法中，你可以写：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      要小心在这周围的任何美元引用定界符不只是<literal>$$</>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>6 个引号</term>
    <listitem>
     <para>
      当在函数体内的一个字符串中的一个单引号与该字符串常量末尾相邻，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      被追加到<literal>a_output</literal>的值则将是：<literal> AND name LIKE 'foobar'</literal>。
     </para>
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>10 个引号</term>
    <listitem>
     <para>
      当你想在一个字符串常量（占 8 个引号）中有两个单引号时并且这会挨着该字符串常量的末尾（另外 2 个）。如果你正在写一个产生其他函数的函数（如<xref linkend="plpgsql-porting-ex2">中），你将很可能只需要这种。例如：
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      <literal>a_output</literal>的值将是：
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      这里我们假定我们只需要把单引号放在<literal>a_output</literal>中，因为在使用前它将被再引用。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
  
  <sect2 id="plpgsql-extra-checks">
   <title>额外的编译时检查</title>

   <para>
    为了辅助用户在一些简单但常见的问题产生危害之前找到它们，
    <application>PL/PgSQL</>提供了额外的<replaceable>检查</>。当被启用时，
    根据配置，它们可以在一个函数的编译期间被用来发出
    <literal>WARNING</>或者<literal>ERROR</>。一个已经收到了
    <literal>WARNING</>的函数可以被继续执行而不会产生进一步的消息，
    因此建议你在一个单独的开发环境中进行测试。
   </para>

 <para>
  这些额外的检查通过配置变量<varname>plpgsql.extra_warnings</>
  和<varname>plpgsql.extra_errors</>启用，其中前者用于警告而后者用
  于错误。两者都可以被设置为一个用逗号分隔的检查列表、
  <literal>"none"</>或者<literal>"all"</>。默认值是<literal>"none"</>。
  当前列表中可用的检查只有一种：
  <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>
      检查一个声明是否遮盖了另一个之前定义的变量。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  下面的例子展示了将<varname>plpgsql.extra_warnings</>
  设置为<varname>shadowed_variables</>的效果：
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
 </para>
 </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
  <title>从<productname>Oracle</productname> PL/SQL 移植</title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>从 PL/SQL 移植到 PL/pgSQL</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>移植到 PL/pgSQL</secondary>
  </indexterm>

  <para>
   这一节解释了<productname>PostgreSQL</>的<application>PL/pgSQL</application>语言和 Oracle 的<application>PL/SQL</application>语言之间的差别，用以帮助那些从<trademark class="registered">Oracle</>向<productname>PostgreSQL</>移植应用的人。
  </para>

  <para>
   <application>PL/pgSQL</application>与 PL/SQL 在许多方面都非常类似。它是一种块结构的、命令式的语言并且所有变量必须先被声明。赋值、循环、条件则很类似。在从<application>PL/SQL</>向<application>PL/pgSQL</application>移植时必须记住一些事情：

    <itemizedlist>
     <listitem>
      <para>
       如果一个 SQL 命令中使用的名字可能是一个表的列名或者是对一个函数中变量的引用，那么<application>PL/SQL</>会将它当作一个列名。如<xref linkend="plpgsql-var-subst">中所述，这对应的是<application>PL/pgSQL</>的 <literal>plpgsql.variable_conflict</> = <literal>use_column</>行为（不是默认行为）。通常最好是首先避免这种歧义，但如果不得不移植依赖于该行为的大量代码，那么设置<literal>variable_conflict</>将是最好的方案。
      </para>
     </listitem>

     <listitem>
      <para>
       在<productname>PostgreSQL</>中，函数体必须写成字符串文本。因此你需要使用美元符引用或者转义函数体中的单引号（见<xref linkend="plpgsql-quote-tips">）。
      </para>
     </listitem>

     <listitem>
      <para>
       应该用模式把函数组织成不同的分组，而不是用包。
      </para>
     </listitem>

     <listitem>
      <para>
       因为没有包，所以也没有包级别的变量。这一点有时候挺讨厌。你可以在临时表里保存会话级别的状态。
      </para>
     </listitem>

     <listitem>
      <para>
       带有<literal>REVERSE</>的整数<command>FOR</>循环的工作方式不同：<application>PL/SQL</>中是从第二个数向第一个数倒数，而<application>PL/pgSQL</>是从第一个数向第二个数倒数，因此在移植时需要交换循环边界。不幸的是这种不兼容性是不太可能改变的（见<xref linkend="plpgsql-integer-for">）。
      </para>
     </listitem>

     <listitem>
      <para>
       查询上的<command>FOR</>循环（不是游标）的工作方式同样不同：目标变量必须已经被声明，而<application>PL/SQL</>总是会隐式地声明它们。但是这样做的优点是在退出循环后，变量值仍然可以访问。
      </para>
     </listitem>

     <listitem>
      <para>
       在使用游标变量方面，存在一些记法差异。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
   <title>移植示例</title>

   <para>
    <xref linkend="pgsql-porting-ex1">展示了如何从<application>PL/SQL</>移植一个简单的函数到<application>PL/pgSQL</>中。
   </para>

   <example id="pgsql-porting-ex1">
    <title>从<application>PL/SQL</>移植一个简单的函数到<application>PL/pgSQL</></title>

    <para>
     这里有一个<productname>Oracle</productname> <application>PL/SQL</>函数：
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     让我们过一遍这个函数并且看看与<application>PL/pgSQL</>相比有什么样的不同：

     <itemizedlist>
      <listitem>
       <para>
        在函数原型中（不是函数体中）的<literal>RETURN</literal>关键字在<productname>PostgreSQL</productname>中变成了<literal>RETURNS</literal>。还有，<literal>IS</>变成了<literal>AS</>，并且你还需要增加一个<literal>LANGUAGE</>子句，因为<application>PL/pgSQL</>并非唯一可用的函数语言。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</>中，函数体被认为是一个字符串，所以你需要使用引号或者美元符号包围它。这代替了Oracle 方法中的用于终止的<literal>/</>。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</>中没有<literal>show errors</literal>命令, 并且也不需要这个命令，因为错误是自动报告的。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     这个函数被移植到<productname>PostgreSQL</>后看起来会是这样：

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex2">展示了如何移植一个会创建另一个函数的函数，以及如何处理引号问题。
   </para>

   <example id="plpgsql-porting-ex2">
    <title>从<application>PL/SQL</>移植一个创建另一个函数的函数到<application>PL/pgSQL</></title>

    <para>
     下面的过程从一个<command>SELECT</command>语句抓取行，并且为了效率而构建一个带有<literal>IF</literal>语句中结果的大型函数。
    </para>

    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     这里是<productname>PostgreSQL</>的版本：
<programlisting>
CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     请注意函数体是如何被单独构建并且通过<literal>quote_literal</>被传递以双写其中的任何引号。需要这个技术是因为无法安全地使用美元引用定义新函数：我们不确定从<structfield>referrer_key.key_string</>域中来的什么字符串会被插入（我们这里假定<structfield>referrer_key.kind</>可以确信总是为<literal>host</>、<literal>domain</>或者<literal>url</>，但是<structfield>referrer_key.key_string</>可能是任何东西，特别是它可能包含美元符号）。这个函数实际上是在 Oracle 的原版上的改进，因为当<structfield>referrer_key.key_string</>或者<structfield>referrer_key.referrer_type</>包含引号时，它将不会生成坏掉的代码。
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex3">展示了如何移植一个带有<literal>OUT</>参数和字符串处理的函数。<productname>PostgreSQL</>没有内建的<function>instr</function>函数，但是你可以用其它函数的组合来创建一个。<indexterm><primary>instr</></indexterm>在<xref linkend="plpgsql-porting-appendix">中有一个<function>instr</function>的<application>PL/pgSQL</application>实现，你可以用它让你的移植变得更容易。
   </para>

   <example id="plpgsql-porting-ex3">
    <title>从<application>PL/SQL</>移植一个带有字符串操作以及<literal>OUT</>参数的过程到<application>PL/pgSQL</></title>

    <para>
     下面的<productname>Oracle</productname> PL/SQL 过程被用来解析一个 URL 并且返回一些元素（主机、路径和查询）。
    </para>

    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- 这将被传回去
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 还有这个
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    <para>
     这里是一种到<application>PL/pgSQL</>的可能翻译：
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- 这将被传递回去
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 以及这个
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     这个函数可以这样使用：
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex4">展示了如何移植一个使用了多种 Oracle 特性的过程。
   </para>

   <example id="plpgsql-porting-ex4">
    <title>从<application>PL/SQL</>移植一个过程到<application>PL/pgSQL</></title>

    <para>
     Oracle 版本：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma">
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable">

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- 释放锁<co id="co.plpgsql-porting-commit">
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- 如果已经存在也不用担心
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

   <para>
    这样的过程可以被很容易地转换为返回<type>void</type>的<productname>PostgreSQL</>函数。这个过程特别有趣，因为它可以教会我们一些东西：

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>
       在<productname>PostgreSQL</>中没有<literal>PRAGMA</literal>语句。
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <para>
       如果你在<application>PL/pgSQL</>中做一次<command>LOCK TABLE</command>，直到调用事务结束该锁都不会被释放。
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <para>
       你不能在一个<application>PL/pgSQL</>函数中发出<command>COMMIT</>。该函数是运行在某个外层事务中的，并且因此<command>COMMIT</>就意味着终止函数的执行。不过，在这种特殊的情况中它并不是必须的，因为<command>LOCK TABLE</command>得到的锁在我们抛出一个错误时将会被释放。
      </para>
     </callout>
    </calloutlist>
   </para>

   <para>
    这是我们如何将这个过程移植到<application>PL/pgSQL</>：

<programlisting>
CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id="co.plpgsql-porting-raise">
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception">
            -- 如果已经存在不要担心
    END;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       <literal>RAISE</>的语法与 Oracle 的语句相当不同，尽管基本的形式<literal>RAISE</> <replaceable class="parameter">exception_name</replaceable>工作起来是相似的。
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       <application>PL/pgSQL</>所支持的异常名称不同于 Oracle。内建的异常名称集合要更大（见<xref linkend="errcodes-appendix">）。目前没有办法声明用户定义的异常名称，尽管你能够抛出用户选择的 SQLSTATE 值。
      </para>
     </callout>
    </calloutlist>

    这个过程和等效的 Oracle 过程之间的主要功能性区别是<literal>cs_jobs</>表上的排他锁将一直被保持到调用事务完成。还有，如果调用者后来中止（例如由于一个错误中止），这个过程的效果将被回滚。
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
   <title>其他要关注的事项</title>

   <para>
    这一节解释了在移植 Oracle <application>PL/SQL</>函数到<productname>PostgreSQL</productname>中时要关注的一些其他问题。
   </para>

   <sect3 id="plpgsql-porting-exceptions">
    <title>异常后隐式回滚</title>

    <para>
     在<application>PL/pgSQL</>，当一个异常被<literal>EXCEPTION</>子句捕获之后，从该块的<literal>BEGIN</>以来的所有数据库改变都会被自动回滚。也就是，该行为等效于你在 Oracle 中用下面的代码得到的效果：

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... 代码 ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
END;
</programlisting>

     如果你正在翻译一个使用这种风格的<command>SAVEPOINT</>以及<command>ROLLBACK TO</>的 Oracle 过程，你的工作比较简单：只要忽略掉<command>SAVEPOINT</>以及<command>ROLLBACK TO</>。如果你的 Oracle 过程是以不同的方法使用<command>SAVEPOINT</>以及<command>ROLLBACK TO</>，那么就要真正地动一番脑筋了。
    </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
     <application>PL/pgSQL</>的<command>EXECUTE</command>与<application>PL/SQL</>中的工作相似，但是必须要记住按照<xref linkend="plpgsql-statements-executing-dyn">中所述地使用<function>quote_literal</function>以及<function>quote_ident</function>。<literal>EXECUTE 'SELECT * FROM $1';</literal>类型的结构将无法可靠地工作除非你使用这些函数。
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
    <title>优化 <application>PL/pgSQL</application> 函数</title>

    <para>
     <productname>PostgreSQL</>提供了两种函数创建修饰符来优化执行：<quote>volatility</>（对于给定的相同参数，函数是否总是返回相同的结果）以及<quote>strictness</quote> （如果任何参数为空，函数是否返回空）。详见<xref linkend="sql-createfunction">参考页。
    </para>

    <para>
     在利用这些优化属性时，你的<command>CREATE FUNCTION</command>语句应该看起来像这样：

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
   <title>附录</title>

   <para>
    这一节包含了一组 Oracle 兼容的<function>instr</function>函数代码，你可以用它来简化你的移植工作。
   </para>

<programlisting>
--
-- instr 函数模仿 Oracle 的对应函数
-- 语法: instr(string1, string2, [n], [m]) 其中 [] 表示可选参数。
--
-- 从第 n 个字符开始搜索 string2 在 string1 中的第 m 次出现。如果 n 是负的，反向搜索。
-- 如果 m 没有被传递，假定为 1（从第一个字符开始搜索）。
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
  </sect2>

 </sect1>

</chapter>
