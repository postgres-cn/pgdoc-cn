<!-- doc/src/sgml/trigger.sgml -->

 <chapter id="triggers">
<!-- pgdoc-cn_start sig_en=8a437b3ac9eb9acb9e1bf01770734560 sig_cn_org=None source=14.1 
  <title>Triggers</title>
________________________________________________________-->
  <title>触发器</title>
<!-- pgdoc-cn_end sig_en=8a437b3ac9eb9acb9e1bf01770734560 -->

<!-- pgdoc-cn_start sig_en=5d1425c8288d5348c20f8adfd43d897f sig_cn_org=None source=14.1 
  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5d1425c8288d5348c20f8adfd43d897f -->

<!-- pgdoc-cn_start sig_en=36d535b3a78241bd515f2363b915a0dc sig_cn_org=None source=14.1 
  <para>
   This chapter provides general information about writing trigger functions.
   Trigger functions can be written in most of the available procedural
   languages, including
   <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
   <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
   <application>PL/Perl</application> (<xref linkend="plperl"/>), and
   <application>PL/Python</application> (<xref linkend="plpython"/>).
   After reading this chapter, you should consult the chapter for
   your favorite procedural language to find out the language-specific
   details of writing a trigger in it.
  </para>
________________________________________________________-->
  <para>
   本章提供了编写触发器函数的一般信息。触发器函数可以使用大部分可用过程性语言，包括
   <application>PL/pgSQL</application>（<xref linkend="plpgsql"/>）、
   <application>PL/Tcl</application>（<xref linkend="pltcl"/>）、
   <application>PL/Perl</application>（<xref linkend="plperl"/>）和
   <application>PL/Python</application>（<xref linkend="plpython"/>)。阅读本章后，你应该查阅你喜欢的过程性语言来找到用其编写触发器的相关细节。
  </para>
<!-- pgdoc-cn_end sig_en=36d535b3a78241bd515f2363b915a0dc -->

<!-- pgdoc-cn_start sig_en=c1c3d0db2f7f064ca7c60a4a93dde379 sig_cn_org=None source=14.1 
  <para>
   It is also possible to write a trigger function in C, although
   most people find it easier to use one of the procedural languages.
   It is not currently possible to write a trigger function in the
   plain SQL function language.
  </para>
________________________________________________________-->
  <para>
   也可以使用C编写一个触发器函数，尽管大部分人觉得使用一种过程性语言更简单。当前不能用纯SQL函数语言来编写触发器函数。
  </para>
<!-- pgdoc-cn_end sig_en=c1c3d0db2f7f064ca7c60a4a93dde379 -->

  <sect1 id="trigger-definition">
<!-- pgdoc-cn_start sig_en=266aebdd68ac43704c6e4a5f7aa82e31 sig_cn_org=None source=14.1 
   <title>Overview of Trigger Behavior</title>
________________________________________________________-->
   <title>触发器行为概述</title>
<!-- pgdoc-cn_end sig_en=266aebdd68ac43704c6e4a5f7aa82e31 -->

<!-- pgdoc-cn_start sig_en=6c9f381f2630ec3ddb33ce1ff749c976 sig_cn_org=None source=14.1 
   <para>
    A trigger is a specification that the database should automatically
    execute a particular function whenever a certain type of operation is
    performed.  Triggers can be attached to tables (partitioned or not),
    views, and foreign tables.
  </para>
________________________________________________________-->
   <para>
    一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区的或者不分区的）、视图和外部表。
  </para>
<!-- pgdoc-cn_end sig_en=6c9f381f2630ec3ddb33ce1ff749c976 -->

<!-- pgdoc-cn_start sig_en=cf9bc983a4df5ab7d932fe09e0482880 sig_cn_org=None source=14.1 
  <para>
    On tables and foreign tables, triggers can be defined to execute either
    before or after any <command>INSERT</command>, <command>UPDATE</command>,
    or <command>DELETE</command> operation, either once per modified row,
    or once per <acronym>SQL</acronym> statement.
    <command>UPDATE</command> triggers can moreover be set to fire only if
    certain columns are mentioned in the <literal>SET</literal> clause of
    the <command>UPDATE</command> statement.  Triggers can also fire
    for <command>TRUNCATE</command> statements.  If a trigger event occurs,
    the trigger's function is called at the appropriate time to handle the
    event.
   </para>
________________________________________________________-->
  <para>
    在表和外部表上，触发器可以被定义为在
    <command>INSERT</command>、<command>UPDATE</command>或
   <command>DELETE</command>操作之前或之后被执行，
   可以为每个<acronym>SQL</acronym>语句被执行一次或者为每个修改的行
   被执行一次。<command>UPDATE</command>
    触发器可以进一步地设置为只针对<command>UPDATE</command>
    语句的<literal>SET</literal>子句的特定列出发。触发器也可以被
    <command>TRUNCATE</command>语句触发。如果一个触发器事件发生，
    触发器函数会在适当的事件被调用来处理该事件。
   </para>
<!-- pgdoc-cn_end sig_en=cf9bc983a4df5ab7d932fe09e0482880 -->

<!-- pgdoc-cn_start sig_en=28504a65ef41e32f7ce40e4c5ca7b01b sig_cn_org=None source=14.1 
   <para>
    On views, triggers can be defined to execute instead of
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
    Such <literal>INSTEAD OF</literal> triggers
    are fired once for each row that needs to be modified in the view.
    It is the responsibility of the
    trigger's function to perform the necessary modifications to the view's
    underlying base table(s) and, where appropriate, return the modified
    row as it will appear in the view.  Triggers on views can also be defined
    to execute once per <acronym>SQL</acronym> statement, before or after
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
    However, such triggers are fired only if there is also
    an <literal>INSTEAD OF</literal> trigger on the view.  Otherwise,
    any statement targeting the view must be rewritten into a statement
    affecting its underlying base table(s), and then the triggers
    that will be fired are the ones attached to the base table(s).
   </para>
________________________________________________________-->
   <para>
    在视图上，触发器可以被定义来取代<command>INSERT</command>、<command>UPDATE</command>或
    <command>DELETE</command>操作的执行。这种<literal>INSTEAD OF</literal>触发器对视图中需要被修改的每一行触发一次。触发器函数的职责是对视图的底层基本表执行必要的修改，并且在合适的时候返回被修改的行以便显示在视图中。视图上的触发器也可以被定义为对每个<acronym>SQL</acronym>语句执行一次，在<command>INSERT</command>\<command>UPDATE</command>或<command>DELETE</command>操作之前或之后。不过，只有在该视图上还有一个<literal>INSTEAD OF</literal>触发器时，上述那些触发器才会被触发。否则，以该视图为目标的任何语句都必须被重写成一个影响其底层基表的语句，然后附着在那些基表上的触发器将会被引发。
   </para>
<!-- pgdoc-cn_end sig_en=28504a65ef41e32f7ce40e4c5ca7b01b -->

<!-- pgdoc-cn_start sig_en=ab2b6e54fa1922b14a664c7c50461030 sig_cn_org=None source=14.1 
   <para>
    The trigger function must be defined before the trigger itself can be
    created.  The trigger function must be declared as a
    function taking no arguments and returning type <literal>trigger</literal>.
    (The trigger function receives its input through a specially-passed
    <structname>TriggerData</structname> structure, not in the form of ordinary function
    arguments.)
   </para>
________________________________________________________-->
   <para>
    触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为<literal>trigger</literal>（触发器函数通过一个特殊传递的<structname>TriggerData</structname>结构作为其输入，而不是以普通函数参数的形式）。
   </para>
<!-- pgdoc-cn_end sig_en=ab2b6e54fa1922b14a664c7c50461030 -->

<!-- pgdoc-cn_start sig_en=5e6dc7351ff90dfbbc84924850fe86af sig_cn_org=None source=14.1 
   <para>
    Once a suitable trigger function has been created, the trigger is
    established with
    <xref linkend="sql-createtrigger"/>.
    The same trigger function can be used for multiple triggers.
   </para>
________________________________________________________-->
   <para>
    一旦一个合适的触发器函数被创建，就可以使用<xref linkend="sql-createtrigger"/>建立触发器。同一个触发器函数可以被用于多个触发器。
   </para>
<!-- pgdoc-cn_end sig_en=5e6dc7351ff90dfbbc84924850fe86af -->

<!-- pgdoc-cn_start sig_en=a6ed312335910cc42dc37fd9fa46fdd6 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> offers both <firstterm>per-row</firstterm>
    triggers and <firstterm>per-statement</firstterm> triggers.  With a per-row
    trigger, the trigger function
    is invoked once for each row that is affected by the statement
    that fired the trigger. In contrast, a per-statement trigger is
    invoked only once when an appropriate statement is executed,
    regardless of the number of rows affected by that statement. In
    particular, a statement that affects zero rows will still result
    in the execution of any applicable per-statement triggers. These
    two types of triggers are sometimes called <firstterm>row-level</firstterm>
    triggers and <firstterm>statement-level</firstterm> triggers,
    respectively. Triggers on <command>TRUNCATE</command> may only be
    defined at statement level, not per-row.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>同时提供<firstterm>每行的</firstterm>触发器和<firstterm>每语句的</firstterm>触发器。对于一个每行的触发器，对于触发触发器的语句所修改的每一行都会调用一次触发器函数。相反，一个每语句的触发器对于其触发语句只被调用一次，而不管该语句影响了多少行。特别地，一个不影响任何行的语句仍然会导致任何可用每语句的触发器的执行。这两类触发器有时也分别被称作<firstterm>行级</firstterm>触发器和<firstterm>语句级</firstterm>触发器。<command>TRUNCATE</command>上的触发器只能被定义在语句级。
   </para>
<!-- pgdoc-cn_end sig_en=a6ed312335910cc42dc37fd9fa46fdd6 -->

<!-- pgdoc-cn_start sig_en=51cdaaea4194cfb109a6ff54bd1fd993 sig_cn_org=None source=14.1 
   <para>
    Triggers are also classified according to whether they fire
    <firstterm>before</firstterm>, <firstterm>after</firstterm>, or
    <firstterm>instead of</firstterm> the operation. These are referred to
    as <literal>BEFORE</literal> triggers, <literal>AFTER</literal> triggers, and
    <literal>INSTEAD OF</literal> triggers respectively.
    Statement-level <literal>BEFORE</literal> triggers naturally fire before the
    statement starts to do anything, while statement-level <literal>AFTER</literal>
    triggers fire at the very end of the statement.  These types of
    triggers may be defined on tables, views, or foreign tables.  Row-level
    <literal>BEFORE</literal> triggers fire immediately before a particular row is
    operated on, while row-level <literal>AFTER</literal> triggers fire at the end of
    the statement (but before any statement-level <literal>AFTER</literal> triggers).
    These types of triggers may only be defined on tables and
    foreign tables, not views.
    <literal>INSTEAD OF</literal> triggers may only be
    defined on views, and only at row level; they fire immediately as each
    row in the view is identified as needing to be operated on.
   </para>
________________________________________________________-->
   <para>
    触发器也可以根据它们是否在操作<firstterm>之前</firstterm>、<firstterm>之后</firstterm>触发，或者被触发来<firstterm>取代</firstterm>操作来分类。它们分别指<literal>BEFORE</literal>触发器、<literal>AFTER</literal> 触发器以及<literal>INSTEAD OF</literal>触发器。语句级<literal>BEFORE</literal>触发器在语句开始做任何事情之前被触发，而语句级<literal>AFTER</literal>触发器则在语句做完所有事情之后被触发。这些触发器类型可以被定义在表、视图或外部表上。行级<literal>BEFORE</literal>触发器在每一个行被操作之前被触发，而行级<literal>AFTER</literal>触发器在语句结束之后被触发（但在任何语句级<literal>AFTER</literal>触发器之前）。这些触发器类型只能被定义在表和外部表上，但不能定义在视图上。<literal>INSTEAD OF</literal>触发器只能被定义在视图上，并且只能定义在行级，当视图中的每一行被标识为需要被操作时，它们会立即触发。
   </para>
<!-- pgdoc-cn_end sig_en=51cdaaea4194cfb109a6ff54bd1fd993 -->

<!-- pgdoc-cn_start sig_en=a6abbacbabcf93c64326f37f20688471 sig_cn_org=None source=14.1 
   <para>
    The execution of an <literal>AFTER</literal> trigger can be deferred
    to the end of the transaction, rather than the end of the statement,
    if it was defined as a <firstterm>constraint trigger</firstterm>.
    In all cases, a trigger is executed as part of the same transaction as
    the statement that triggered it, so if either the statement or the
    trigger causes an error, the effects of both will be rolled back.
   </para>
________________________________________________________-->
   <para>
    一个<literal>AFTER</literal>触发器的执行可以推迟到事务的最后，而不是语句的最后，如果它被定义为<firstterm>constraint trigger</firstterm>。
    在所有情况下，触发器作为触发它的语句的同一个事务的一部分来执行，所以无论语句或触发器导致错误，两者的后果都将会回滚。
   </para>
<!-- pgdoc-cn_end sig_en=a6abbacbabcf93c64326f37f20688471 -->

<!-- pgdoc-cn_start sig_en=2f38e9e205b7eb745c9b83356232783d sig_cn_org=None source=14.1 
   <para>
    A statement that targets a parent table in an inheritance or partitioning
    hierarchy does not cause the statement-level triggers of affected child
    tables to be fired; only the parent table's statement-level triggers are
    fired.  However, row-level triggers of any affected child tables will be
    fired.
   </para>
________________________________________________________-->
   <para>
    一个以继承或者分区层次中父表为目标的语句不会导致受影响的子表的语句级触发器被引发，只有父表的语句级触发器会被引发。不过，受影响的子表的行级触发器将被引发。
   </para>
<!-- pgdoc-cn_end sig_en=2f38e9e205b7eb745c9b83356232783d -->

<!-- pgdoc-cn_start sig_en=c9d0522c2bd1dfb94693dd64065e14ce sig_cn_org=None source=14.1 
   <para>
    If an <command>INSERT</command> contains an <literal>ON CONFLICT
    DO UPDATE</literal> clause, it is possible that the effects of
    row-level <literal>BEFORE</literal> <command>INSERT</command> triggers and
    row-level <literal>BEFORE</literal> <command>UPDATE</command> triggers can
    both be applied in a way that is apparent from the final state of
    the updated row, if an <varname>EXCLUDED</varname> column is referenced.
    There need not be an <varname>EXCLUDED</varname> column reference for
    both sets of row-level <literal>BEFORE</literal> triggers to execute,
    though.  The
    possibility of surprising outcomes should be considered when there
    are both <literal>BEFORE</literal> <command>INSERT</command> and
    <literal>BEFORE</literal> <command>UPDATE</command> row-level triggers
    that change a row being inserted/updated (this can be
    problematic even if the modifications are more or less equivalent, if
    they're not also idempotent).  Note that statement-level
    <command>UPDATE</command> triggers are executed when <literal>ON
    CONFLICT DO UPDATE</literal> is specified, regardless of whether or not
    any rows were affected by the <command>UPDATE</command> (and
    regardless of whether the alternative <command>UPDATE</command>
    path was ever taken).  An <command>INSERT</command> with an
    <literal>ON CONFLICT DO UPDATE</literal> clause will execute
    statement-level <literal>BEFORE</literal> <command>INSERT</command>
    triggers first, then statement-level <literal>BEFORE</literal>
    <command>UPDATE</command> triggers, followed by statement-level
    <literal>AFTER</literal> <command>UPDATE</command> triggers and finally
    statement-level <literal>AFTER</literal> <command>INSERT</command>
    triggers.
   </para>
________________________________________________________-->
   <para>
    如果一个<command>INSERT</command>包含<literal>ON CONFLICT
    DO UPDATE</literal>子句并且引用了<varname>EXCLUDED</varname>列，有可能所有行级
    <literal>BEFORE</literal> <command>INSERT</command>触发器和所有行级
    <literal>BEFORE</literal> <command>UPDATE</command>触发器的效果可能会以一种对于
    被更新行最终状态透明的方式被应用。不过，对于要执行的两种集合的行级
    <literal>BEFORE</literal>触发器都不需要有<varname>EXCLUDED</varname>列引用。当同时有行级
    <literal>BEFORE</literal> <command>INSERT</command>和
    <literal>BEFORE</literal> <command>UPDATE</command>触发器影响被插入/
    更新的行时（如果在两者不幂等时修改或多或少地等价，这仍可能是有问题的），
    应该考虑可能出现的意料之外的结果。注意在指定了
    <literal>ON CONFLICT DO UPDATE</literal>时，不管有没有行被
    <command>UPDATE</command>影响（并且不管是否采用了其他
    <command>UPDATE</command>路径），语句级
    <command>UPDATE</command>都将被执行。一个带有
    <literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>
    将首先执行语句级<literal>BEFORE</literal> <command>INSERT</command>，
    然后执行语句级<literal>BEFORE</literal>
    <command>UPDATE</command>触发器，
    接着是语句级<literal>AFTER</literal> <command>UPDATE</command>触发器，
    最后是语句级<literal>AFTER</literal> <command>INSERT</command>触发器。
   </para>
<!-- pgdoc-cn_end sig_en=c9d0522c2bd1dfb94693dd64065e14ce -->

<!-- pgdoc-cn_start sig_en=3823001054c0e4bc49a48f846173688f sig_cn_org=None source=14.1 
   <para>
    If an <command>UPDATE</command> on a partitioned table causes a row to move
    to another partition, it will be performed as a <command>DELETE</command>
    from the original partition followed by an <command>INSERT</command> into
    the new partition. In this case, all row-level <literal>BEFORE</literal>
    <command>UPDATE</command> triggers and all row-level
    <literal>BEFORE</literal> <command>DELETE</command> triggers are fired on
    the original partition. Then all row-level <literal>BEFORE</literal>
    <command>INSERT</command> triggers are fired on the destination partition.
    The possibility of surprising outcomes should be considered when all these
    triggers affect the row being moved. As far as <literal>AFTER ROW</literal>
    triggers are concerned, <literal>AFTER</literal> <command>DELETE</command>
    and <literal>AFTER</literal> <command>INSERT</command> triggers are
    applied; but <literal>AFTER</literal> <command>UPDATE</command> triggers
    are not applied because the <command>UPDATE</command> has been converted to
    a <command>DELETE</command> and an <command>INSERT</command>. As far as
    statement-level triggers are concerned, none of the
    <command>DELETE</command> or <command>INSERT</command> triggers are fired,
    even if row movement occurs; only the <command>UPDATE</command> triggers
    defined on the target table used in the <command>UPDATE</command> statement
    will be fired.
   </para>
________________________________________________________-->
   <para>
    如果一个分区表上的<command>UPDATE</command>导致一行移动到另一个分区，它将被从原始分区<command>DELETE</command>掉然后再<command>INSERT</command>到新分区中。在这种情况下，原始分区上所有的行级<literal>BEFORE</literal> <command>UPDATE</command>触发器和所有行级<literal>BEFORE</literal> <command>DELETE</command>触发器会被引发。然后目标分区上所有的行级<literal>BEFORE</literal> <command>INSERT</command>触发器会被引发。当所有这些触发器都影响被移动的行时，应该对令人惊讶的结果有心理准备。至于<literal>AFTER ROW</literal>触发器，<literal>AFTER</literal> <command>DELETE</command>和<literal>AFTER</literal> <command>INSERT</command>触发器会被应用，但<literal>AFTER</literal> <command>UPDATE</command>触发器不会被应用，因为<command>UPDATE</command>已经被转换成了一个<command>DELETE</command>和一个<command>INSERT</command>。对于语句级触发器，即便发生行移动，<command>DELETE</command>和<command>INSERT</command>触发器也都不会被引发，只有<command>UPDATE</command>语句中用到的目标表上的<command>UPDATE</command>触发器将被引发。
   </para>
<!-- pgdoc-cn_end sig_en=3823001054c0e4bc49a48f846173688f -->

<!-- pgdoc-cn_start sig_en=43fc8d161c82c10e62af68a231c6464a sig_cn_org=bee135314424fa204a1405f07a96180e source=15.7 
   <para>
    No separate triggers are defined for <command>MERGE</command>. Instead,
    statement-level or row-level <command>UPDATE</command>,
    <command>DELETE</command>, and <command>INSERT</command> triggers are fired
    depending on (for statement-level triggers) what actions are specified in
    the <command>MERGE</command> query and (for row-level triggers) what
    actions are performed.
   </para>
________________________________________________________-->
   <para>
    不为<command>MERGE</command>定义单独的触发器。相反，基于语句或基于行的<command>UPDATE</command>，
    <command>DELETE</command>和<command>INSERT</command>触发器会根据（对于基于语句的触发器）在
    <command>MERGE</command>查询中指定的操作以及（对于基于行的触发器）执行的操作而触发。
   </para>
<!-- pgdoc-cn_end sig_en=43fc8d161c82c10e62af68a231c6464a -->

<!-- pgdoc-cn_start sig_en=9e74547fb8ca4aaec3b7cf346b0ec15f sig_cn_org=c5d8840601c3ea3721a5f540880642c7 source=15.7 
   <para>
    While running a <command>MERGE</command> command, statement-level
    <literal>BEFORE</literal> and <literal>AFTER</literal> triggers are
    fired for events specified in the actions of the <command>MERGE</command>
    command, irrespective of whether or not the action is ultimately performed.
    This is the same as an <command>UPDATE</command> statement that updates
    no rows, yet statement-level triggers are fired.
    The row-level triggers are fired only when a row is actually updated,
    inserted or deleted. So it's perfectly legal that while statement-level
    triggers are fired for certain types of action, no row-level triggers
    are fired for the same kind of action.
   </para>
________________________________________________________-->
   <para>
    在运行<command>MERGE</command>命令时，无论操作是否最终执行，语句级别的
    <literal>BEFORE</literal>和<literal>AFTER</literal>触发器都会针对<command>MERGE</command>
    命令中的操作指定的事件触发。这与更新零行的<command>UPDATE</command>语句相同，
    但语句级别的触发器会被触发。
    只有在实际更新、插入或删除行时才会触发行级别触发器。因此，对于某些类型的操作，
    虽然会触发语句级别触发器，但对于相同类型的操作可能不会触发行级别触发器。
   </para>
<!-- pgdoc-cn_end sig_en=9e74547fb8ca4aaec3b7cf346b0ec15f -->

<!-- pgdoc-cn_start sig_en=92fa1d7a579ca0d7b67b4b6e19010965 sig_cn_org=None source=14.1 
   <para>
    Trigger functions invoked by per-statement triggers should always
    return <symbol>NULL</symbol>. Trigger functions invoked by per-row
    triggers can return a table row (a value of
    type <structname>HeapTuple</structname>) to the calling executor,
    if they choose.  A row-level trigger fired before an operation has
    the following choices:

    <itemizedlist>
     <listitem>
      <para>
       It can return <symbol>NULL</symbol> to skip the operation for the
       current row. This instructs the executor to not perform the
       row-level operation that invoked the trigger (the insertion,
       modification, or deletion of a particular table row).
      </para>
     </listitem>

     <listitem>
      <para>
       For row-level <command>INSERT</command>
       and <command>UPDATE</command> triggers only, the returned row
       becomes the row that will be inserted or will replace the row
       being updated.  This allows the trigger function to modify the
       row being inserted or updated.
      </para>
     </listitem>
    </itemizedlist>

    A row-level <literal>BEFORE</literal> trigger that does not intend to cause
    either of these behaviors must be careful to return as its result the same
    row that was passed in (that is, the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    triggers, the <varname>OLD</varname> row for
    <command>DELETE</command> triggers).
   </para>
________________________________________________________-->
   <para>
    被语句级触发器调用的触发器函数应该总是返回<symbol>NULL</symbol>。根据行级触发器的选择，被其调用的触发器函数可以返回一个表行（类型<structname>HeapTuple</structname>的一个值）给执行器。在一个操作前触发的行级触发器有下列选择：

    <itemizedlist>
     <listitem>
      <para>
       它可以返回<symbol>NULL</symbol>来跳过对当前行的操作。这指示执行器不要执行调用触发器的行级操作（对一个特定表行的插入、修改或删除）。
      </para>
     </listitem>

     <listitem>
      <para>
       仅对行级<command>INSERT</command>和<command>UPDATE</command>触发器来说，被返回的行称为将要被插入的行或者替代将被更新的行。这允许触发器函数修改将要被插入或更新的行。
      </para>
     </listitem>
    </itemizedlist>

    一个无意导致任何这些行为的行级<literal>BEFORE</literal>触发器必须小心地它的结果，使之和被传入的行一样（即，<command>INSERT</command>和<command>UPDATE</command>触发器的<varname>NEW</varname>行，<command>DELETE</command>触发器的<varname>OLD</varname>行）。
   </para>
<!-- pgdoc-cn_end sig_en=92fa1d7a579ca0d7b67b4b6e19010965 -->

<!-- pgdoc-cn_start sig_en=dbe58dae114063e11ca9472305e1677f sig_cn_org=None source=14.1 
   <para>
    A row-level <literal>INSTEAD OF</literal> trigger should either return
    <symbol>NULL</symbol> to indicate that it did not modify any data from
    the view's underlying base tables, or it should return the view
    row that was passed in (the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    operations, or the <varname>OLD</varname> row for
    <command>DELETE</command> operations). A nonnull return value is
    used to signal that the trigger performed the necessary data
    modifications in the view.  This will cause the count of the number
    of rows affected by the command to be incremented. For
    <command>INSERT</command> and <command>UPDATE</command> operations only, the trigger
    may modify the <varname>NEW</varname> row before returning it.  This will
    change the data returned by
    <command>INSERT RETURNING</command> or <command>UPDATE RETURNING</command>,
    and is useful when the view will not show exactly the same data
    that was provided.
   </para>
________________________________________________________-->
   <para>
    一个行级<literal>INSTEAD OF</literal>触发器可以返回<symbol>NULL</symbol>来指示它没有修改任何来自于视图底层基表的数据，也可以返回被传入的视图行（<command>INSERT</command>和<command>UPDATE</command>操作的<varname>NEW</varname>行，或者<command>DELETE</command>操作的<varname>OLD</varname>行）。一个非空返回值被用于标志触发器在视图中执行了必须的数据修改。这将会导致被命令修改的行计数被增加。仅对于<command>INSERT</command>和<command>UPDATE</command>操作，触发器可能会在返回<varname>NEW</varname>行之前对其进行修改。这将会改变<command>INSERT RETURNING</command>或<command>UPDATE RETURNING</command>返回的数据，并在视图无法正确地显示提供给它的相同数据时有用。
   </para>
<!-- pgdoc-cn_end sig_en=dbe58dae114063e11ca9472305e1677f -->

<!-- pgdoc-cn_start sig_en=2962969d878075ec8c0df2b5d1c9c352 sig_cn_org=None source=14.1 
   <para>
    The return value is ignored for row-level triggers fired after an
    operation, and so they can return <symbol>NULL</symbol>.
   </para>
________________________________________________________-->
   <para>
    对于在一个操作之后触发的行级触发器，返回值会被忽略，因此它们可以返回<symbol>NULL</symbol>。
   </para>
<!-- pgdoc-cn_end sig_en=2962969d878075ec8c0df2b5d1c9c352 -->

<!-- pgdoc-cn_start sig_en=9fcb5a8cfbe35328565176b380775dd0 sig_cn_org=None source=14.1 
   <para>
    Some considerations apply for generated
    columns.<indexterm><primary>generated column</primary><secondary>in
    triggers</secondary></indexterm>  Stored generated columns are computed after
    <literal>BEFORE</literal> triggers and before <literal>AFTER</literal>
    triggers.  Therefore, the generated value can be inspected in
    <literal>AFTER</literal> triggers.  In <literal>BEFORE</literal> triggers,
    the <literal>OLD</literal> row contains the old generated value, as one
    would expect, but the <literal>NEW</literal> row does not yet contain the
    new generated value and should not be accessed.  In the C language
    interface, the content of the column is undefined at this point; a
    higher-level programming language should prevent access to a stored
    generated column in the <literal>NEW</literal> row in a
    <literal>BEFORE</literal> trigger.  Changes to the value of a generated
    column in a <literal>BEFORE</literal> trigger are ignored and will be
    overwritten.
   </para>
________________________________________________________-->
   <para>
    一些情况适用于生成的列。
    <indexterm><primary>generated column</primary><secondary>in triggers</secondary></indexterm> 存储生成的列在<literal>BEFORE</literal> 触发器之后和 <literal>AFTER</literal> 触发器之前计算.
    因此，生成的值可以在<literal>AFTER</literal>触发器中检查。
    在<literal>BEFORE</literal>触发器中，<literal>OLD</literal>行包含旧的生成的值，正如人们所期待的，但 <literal>NEW</literal> 行尚未包含新的生成值并且不应访问。
    在C语言界面中，此时列的内容还没有被定义；在<literal>BEFORE</literal>触发器中，高级别编程语言应阻止访问<literal>NEW</literal>行中存储生成的列，。
    在<literal>BEFORE</literal>触发器中更改到生成列的值将被忽略并覆盖。
   </para>
<!-- pgdoc-cn_end sig_en=9fcb5a8cfbe35328565176b380775dd0 -->

<!-- pgdoc-cn_start sig_en=a78ca8a7e443026fe40fbe173bb2c99a sig_cn_org=None source=14.1 
   <para>
    If more than one trigger is defined for the same event on the same
    relation, the triggers will be fired in alphabetical order by
    trigger name.  In the case of <literal>BEFORE</literal> and
    <literal>INSTEAD OF</literal> triggers, the possibly-modified row returned by
    each trigger becomes the input to the next trigger.  If any
    <literal>BEFORE</literal> or <literal>INSTEAD OF</literal> trigger returns
    <symbol>NULL</symbol>, the operation is abandoned for that row and subsequent
    triggers are not fired (for that row).
   </para>
________________________________________________________-->
   <para>
    如果为同一个关系上的同一事件定义了超过一个触发器，它们将按照其名称的字母表顺序被触发。在<literal>BEFORE</literal>和<literal>INSTEAD OF</literal>触发器的情况下，每一个触发器返回的可能被修改的行将成为下一个触发器的输入。如果任何一个<literal>BEFORE</literal>或<literal>INSTEAD OF</literal>触发器返回<symbol>NULL</symbol>，该操作将在该行上被禁用并且对于该行不会触发后续的触发器。
   </para>
<!-- pgdoc-cn_end sig_en=a78ca8a7e443026fe40fbe173bb2c99a -->

<!-- pgdoc-cn_start sig_en=07de909f50213dc660e5968d3a55f45a sig_cn_org=None source=14.1 
   <para>
    A trigger definition can also specify a Boolean <literal>WHEN</literal>
    condition, which will be tested to see whether the trigger should
    be fired.  In row-level triggers the <literal>WHEN</literal> condition can
    examine the old and/or new values of columns of the row.  (Statement-level
    triggers can also have <literal>WHEN</literal> conditions, although the feature
    is not so useful for them.)  In a <literal>BEFORE</literal> trigger, the
    <literal>WHEN</literal>
    condition is evaluated just before the function is or would be executed,
    so using <literal>WHEN</literal> is not materially different from testing the
    same condition at the beginning of the trigger function.  However, in
    an <literal>AFTER</literal> trigger, the <literal>WHEN</literal> condition is evaluated
    just after the row update occurs, and it determines whether an event is
    queued to fire the trigger at the end of statement.  So when an
    <literal>AFTER</literal> trigger's
    <literal>WHEN</literal> condition does not return true, it is not necessary
    to queue an event nor to re-fetch the row at end of statement.  This
    can result in significant speedups in statements that modify many
    rows, if the trigger only needs to be fired for a few of the rows.
    <literal>INSTEAD OF</literal> triggers do not support
    <literal>WHEN</literal> conditions.
   </para>
________________________________________________________-->
   <para>
    一个触发器定义也能指定一个布尔的<literal>WHEN</literal>条件，它将被测试来看该触发器是否应该被触发。在行级触发器中，<literal>WHEN</literal>条件可以检查该行的旧列值和/或新列值（语句级触发器也能有<literal>WHEN</literal>条件，但是该特性对它们不太有用）。在一个<literal>BEFORE</literal>触发器中，<literal>WHEN</literal>条件只是在该函数被或者将被执行前计算，因此使用<literal>WHEN</literal>条件与在该触发器函数的开始测试相同的条件没有本质区别。不过，在一个<literal>AFTER</literal>触发器中，<literal>WHEN</literal>条件只是在行更新发生之后被计算，并且它决定在语句的末尾一个事件是否被排队来触发该触发器。因此当一个<literal>AFTER</literal>触发器的<literal>WHEN</literal>不返回真时，在语句的末尾没有必要将一个事件进行排队，也没有必要重新取出该行。如果触发器只对少数行触发，这可以使得修改很多行的语句明显加快。<literal>INSTEAD OF</literal>触发器不支持<literal>WHEN</literal>条件。
   </para>
<!-- pgdoc-cn_end sig_en=07de909f50213dc660e5968d3a55f45a -->

<!-- pgdoc-cn_start sig_en=8a4c5c8ddfa54d370e515286ffc0f360 sig_cn_org=None source=14.1 
   <para>
    Typically, row-level <literal>BEFORE</literal> triggers are used for checking or
    modifying the data that will be inserted or updated.  For example,
    a <literal>BEFORE</literal> trigger might be used to insert the current time into a
    <type>timestamp</type> column, or to check that two elements of the row are
    consistent. Row-level <literal>AFTER</literal> triggers are most sensibly
    used to propagate the updates to other tables, or make consistency
    checks against other tables.  The reason for this division of labor is
    that an <literal>AFTER</literal> trigger can be certain it is seeing the final
    value of the row, while a <literal>BEFORE</literal> trigger cannot; there might
    be other <literal>BEFORE</literal> triggers firing after it.  If you have no
    specific reason to make a trigger <literal>BEFORE</literal> or
    <literal>AFTER</literal>, the <literal>BEFORE</literal> case is more efficient, since
    the information about
    the operation doesn't have to be saved until end of statement.
   </para>
________________________________________________________-->
   <para>
    通常，行级<literal>BEFORE</literal>被用来检查或修改即将被插入或更新的数据。例如，一个<literal>BEFORE</literal>触发器可以被用来把当前时间插入到一个<type>timestamp</type>列中，或者检查该行的两个元素之间是否一致。行级<literal>AFTER</literal>触发器大多数被用来将更新传播到其他表，或者针对其他表进行一致性检查。进行这种工作分工的原因是，一个<literal>AFTER</literal>触发器可以肯定它看到的是该行的最终值，而一个<literal>BEFORE</literal>触发器则不能，因为还可能有其他<literal>BEFORE</literal>触发器在它之后触发。如果你不知道让一个触发器是<literal>BEFORE</literal>或<literal>AFTER</literal>，则<literal>BEFORE</literal>形式更加有效，因为关于该操作的信息直到语句的末尾都不需要被保存。
   </para>
<!-- pgdoc-cn_end sig_en=8a4c5c8ddfa54d370e515286ffc0f360 -->

<!-- pgdoc-cn_start sig_en=b1796960995cd2cb69a05892c024396f sig_cn_org=None source=14.1 
   <para>
    If a trigger function executes SQL commands then these
    commands might fire triggers again. This is known as cascading
    triggers.  There is no direct limitation on the number of cascade
    levels.  It is possible for cascades to cause a recursive invocation
    of the same trigger; for example, an <command>INSERT</command>
    trigger might execute a command that inserts an additional row
    into the same table, causing the <command>INSERT</command> trigger
    to be fired again.  It is the trigger programmer's responsibility
    to avoid infinite recursion in such scenarios.
   </para>
________________________________________________________-->
   <para>
    如果一个触发器函数执行 SQL 命令，则这些命令可能会再次引发触发器。这就是所谓的级联触发器。对于级联的层数没有直接的限制。级联有可能会导致对同一个触发器的递归调用。例如，一个<command>INSERT</command>触发器可能执行一个向同一个表插入一个额外行的命令，这就导致该<command>INSERT</command>触发器被再次引发。所以在这种情形下，触发器程序员应该负责避免无限递归。
   </para>
<!-- pgdoc-cn_end sig_en=b1796960995cd2cb69a05892c024396f -->

<!-- pgdoc-cn_start sig_en=4e03866a319c493d703938c0e46ba427 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>trigger</primary>
     <secondary>arguments for trigger functions</secondary>
    </indexterm>
    When a trigger is being defined, arguments can be specified for
    it. The purpose of including arguments in the
    trigger definition is to allow different triggers with similar
    requirements to call the same function.  As an example, there
    could be a generalized trigger function that takes as its
    arguments two column names and puts the current user in one and
    the current time stamp in the other.  Properly written, this
    trigger function would be independent of the specific table it is
    triggering on.  So the same function could be used for
    <command>INSERT</command> events on any table with suitable
    columns, to automatically track creation of records in a
    transaction table for example. It could also be used to track
    last-update events if defined as an <command>UPDATE</command>
    trigger.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>触发器</primary>
     <secondary>触发器函数的参数</secondary>
    </indexterm>
    在定义一个触发器时，可以为它指定参数。在触发器定义中包括参数的目的是允许具有相似需求的不同触发器调用同一个函数。例如，可能有一个一般性的触发器函数，它需要两个列名作为参数，一个放当前用户而另一个放当前时间戳。在正确编写的情况下，这个触发器函数应该独立于它所触发的表。因此同一个函数可以被用于具有适当列的任意表上的<command>INSERT</command>事件，这样做的用途之一是可以自动追踪一个交易表中记录的创建。如果被定义成一个<command>UPDATE</command>触发器，它也可以被用来追踪最新的更新事件。
   </para>
<!-- pgdoc-cn_end sig_en=4e03866a319c493d703938c0e46ba427 -->

<!-- pgdoc-cn_start sig_en=087a9d6476234af242822f2d70b4454e sig_cn_org=None source=14.1 
   <para>
    Each programming language that supports triggers has its own method
    for making the trigger input data available to the trigger function.
    This input data includes the type of trigger event (e.g.,
    <command>INSERT</command> or <command>UPDATE</command>) as well as any
    arguments that were listed in <command>CREATE TRIGGER</command>.
    For a row-level trigger, the input data also includes the
    <varname>NEW</varname> row for <command>INSERT</command> and
    <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> row
    for <command>UPDATE</command> and <command>DELETE</command> triggers.
   </para>
________________________________________________________-->
   <para>
    每一种支持触发器的编程语言都有自己的方法来让触发器输入数据对触发器函数可用。这种输入数据包括触发器事件的类型（如<command>INSERT</command>或<command>UPDATE</command>）以及被列在<command>CREATE TRIGGER</command>中的任何参数。对于一个行级触发器，输入数据还包括用于<command>INSERT</command>和<command>UPDATE</command>触发器的<varname>NEW</varname>行，和/或用于<command>UPDATE</command>和<command>DELETE</command>触发器的<varname>OLD</varname>行。语句级触发器当前没有任何方法检查被语句修改的单个行。
   </para>
<!-- pgdoc-cn_end sig_en=087a9d6476234af242822f2d70b4454e -->

<!-- pgdoc-cn_start sig_en=63b479595729fe9ff43e46b149207194 sig_cn_org=None source=14.1 
   <para>
    By default, statement-level triggers do not have any way to examine the
    individual row(s) modified by the statement.  But an <literal>AFTER
    STATEMENT</literal> trigger can request that <firstterm>transition tables</firstterm>
    be created to make the sets of affected rows available to the trigger.
    <literal>AFTER ROW</literal> triggers can also request transition tables, so
    that they can see the total changes in the table as well as the change in
    the individual row they are currently being fired for.  The method for
    examining the transition tables again depends on the programming language
    that is being used, but the typical approach is to make the transition
    tables act like read-only temporary tables that can be accessed by SQL
    commands issued within the trigger function.
   </para>
________________________________________________________-->
   <para>
    默认情况下，语句级触发器没有办法检查该语句修改的行。但是<literal>AFTER STATEMENT</literal>触发器可以请求创建<firstterm>传递表</firstterm>，这样可以让受影响的行集合对该触发器可用。<literal>AFTER ROW</literal>触发器也可以请求传递表，这样它们可以看到表中的整个变化，同时也能看到当前引发它们的个体行中的变化。检查传递表的方法仍是取决于使用的编程语言，但是通常的方法让传递表变得像触发器函数内部发出的SQL命令能够访问的只读临时表一样。
   </para>
<!-- pgdoc-cn_end sig_en=63b479595729fe9ff43e46b149207194 -->

  </sect1>

  <sect1 id="trigger-datachanges">
<!-- pgdoc-cn_start sig_en=e88f22d13f2f5c2d0ea075e514e467bc sig_cn_org=None source=14.1 
   <title>Visibility of Data Changes</title>
________________________________________________________-->
   <title>数据改变的可见性</title>
<!-- pgdoc-cn_end sig_en=e88f22d13f2f5c2d0ea075e514e467bc -->

<!-- pgdoc-cn_start sig_en=3af1e6a0bf88b8a174da691aa028a786 sig_cn_org=None source=14.1 
   <para>
    If you execute SQL commands in your trigger function, and these
    commands access the table that the trigger is for, then
    you need to be aware of the data visibility rules, because they determine
    whether these SQL commands will see the data change that the trigger
    is fired for.  Briefly:

    <itemizedlist>

     <listitem>
      <para>
       Statement-level triggers follow simple visibility rules: none of
       the changes made by a statement are visible to statement-level
       <literal>BEFORE</literal> triggers, whereas all
       modifications are visible to statement-level <literal>AFTER</literal>
       triggers.
      </para>
     </listitem>

     <listitem>
      <para>
       The data change (insertion, update, or deletion) causing the
       trigger to fire is naturally <emphasis>not</emphasis> visible
       to SQL commands executed in a row-level <literal>BEFORE</literal> trigger,
       because it hasn't happened yet.
      </para>
     </listitem>

     <listitem>
      <para>
       However, SQL commands executed in a row-level <literal>BEFORE</literal>
       trigger <emphasis>will</emphasis> see the effects of data
       changes for rows previously processed in the same outer
       command.  This requires caution, since the ordering of these
       change events is not in general predictable; an SQL command that
       affects multiple rows can visit the rows in any order.
      </para>
     </listitem>

     <listitem>
      <para>
       Similarly, a row-level <literal>INSTEAD OF</literal> trigger will see the
       effects of data changes made by previous firings of <literal>INSTEAD
       OF</literal> triggers in the same outer command.
      </para>
     </listitem>

     <listitem>
      <para>
       When a row-level <literal>AFTER</literal> trigger is fired, all data
       changes made
       by the outer command are already complete, and are visible to
       the invoked trigger function.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    如果你在你的触发器函数中执行 SQL 命令，并且这些命令会访问触发器所在的表，那么你需要注意数据可见性规则。因为这些规则决定了这些 SQL 命令是否将能看见引发触发器的数据改变。简单地：

    <itemizedlist>

     <listitem>
      <para>
       语句级触发器遵循简单的可见性规则：一个语句所作的改变对于语句级
       <literal>BEFORE</literal>触发器都不可见，而所有修改对于语句级
       <literal>AFTER</literal>触发器都是可见的。
      </para>
     </listitem>

     <listitem>
      <para>
       导致触发器被引发的数据更改（插入、更新或删除）自然对于在一个行级<literal>BEFORE</literal>触发器中执行的 SQL 命令<emphasis>不</emphasis>可见，因为它还没有发生。
      </para>
     </listitem>

     <listitem>
      <para>
       但是，在一个行级<literal>BEFORE</literal>触发器中执行的 SQL 命令<emphasis>将会</emphasis>看见之前在同一个外层命令中所作的数据更改的效果。这里需要小心，因为这些更改时间的顺序通常是不可预测的，一个影响多行的 SQL 命令可能以任何顺序访问这些行。
      </para>
     </listitem>

     <listitem>
      <para>
       类似地，一个行级<literal>INSTEAD OF</literal>触发器将会看见之前在同一个外层命令中<literal>INSTEAD OF</literal>触发器引发所作的数据更改。
      </para>
     </listitem>

     <listitem>
      <para>
       当一个行级<literal>AFTER</literal>触发器被引发时，所有由外层命令所作的数据更改已经完成，并且对于该被调用的触发器函数是可见的。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=3af1e6a0bf88b8a174da691aa028a786 -->

<!-- pgdoc-cn_start sig_en=a2068566b82bb893ea52333114a5a610 sig_cn_org=None source=14.1 
   <para>
    If your trigger function is written in any of the standard procedural
    languages, then the above statements apply only if the function is
    declared <literal>VOLATILE</literal>.  Functions that are declared
    <literal>STABLE</literal> or <literal>IMMUTABLE</literal> will not see changes made by
    the calling command in any case.
   </para>
________________________________________________________-->
   <para>
    如果你的触发器函数使用任何一种标准过程语言编写的，那么只有在该函数被声明为<literal>VOLATILE</literal>时上述陈述才适用。被声明为<literal>STABLE</literal>或<literal>IMMUTABLE</literal>的函数在任何情况下将不能看到由调用命令所作出的更改。
   </para>
<!-- pgdoc-cn_end sig_en=a2068566b82bb893ea52333114a5a610 -->

<!-- pgdoc-cn_start sig_en=9b88df09ced0822952657563fe50f543 sig_cn_org=None source=14.1 
   <para>
    Further information about data visibility rules can be found in
    <xref linkend="spi-visibility"/>.  The example in <xref
    linkend="trigger-example"/> contains a demonstration of these rules.
   </para>
________________________________________________________-->
   <para>
    有关数据可见性规则的更多信息可见<xref linkend="spi-visibility"/>。<xref linkend="trigger-example"/>中的例子包含了对这些规则的示范。
   </para>
<!-- pgdoc-cn_end sig_en=9b88df09ced0822952657563fe50f543 -->
  </sect1>

  <sect1 id="trigger-interface">
<!-- pgdoc-cn_start sig_en=831571eef5fb917a05875fa103bbe529 sig_cn_org=None source=14.1 
   <title>Writing Trigger Functions in C</title>
________________________________________________________-->
   <title>用 C 编写触发器函数</title>
<!-- pgdoc-cn_end sig_en=831571eef5fb917a05875fa103bbe529 -->

<!-- pgdoc-cn_start sig_en=7084e569c7d61a6e7d47c6915a6c2f96 sig_cn_org=None source=14.1 
   <indexterm zone="trigger-interface">
    <primary>trigger</primary>
    <secondary>in C</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="trigger-interface">
    <primary>trigger</primary>
    <secondary>in C</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7084e569c7d61a6e7d47c6915a6c2f96 -->

<!-- pgdoc-cn_start sig_en=35f679f41eb595db77c343d893a5c009 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>transition tables</primary>
    <secondary>referencing from C trigger</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>transition tables</primary>
    <secondary>referencing from C trigger</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=35f679f41eb595db77c343d893a5c009 -->

<!-- pgdoc-cn_start sig_en=b7b23726641dd886ae08c02bdcc651a7 sig_cn_org=None source=14.1 
   <para>
    This section describes the low-level details of the interface to a
    trigger function.  This information is only needed when writing
    trigger functions in C.  If you are using a higher-level language then
    these details are handled for you.  In most cases you should consider
    using a procedural language before writing your triggers in C.  The
    documentation of each procedural language explains how to write a
    trigger in that language.
   </para>
________________________________________________________-->
   <para>
    这一节描述了一个触发器函数的接口的低层细节。只有用 C 编写触发器函数时才需要这些信息。如果你使用一种更高层的语言，那么这些细节就不需要你来处理。在大部分情况下，你应该优先考虑使用一种过程语言。每一种过程语言的文档阐述了如何使用那种语言编写一个触发器。
   </para>
<!-- pgdoc-cn_end sig_en=b7b23726641dd886ae08c02bdcc651a7 -->

<!-- pgdoc-cn_start sig_en=b642ec09655675f44a08157263b083fc sig_cn_org=None source=14.1 
   <para>
    Trigger functions must use the <quote>version 1</quote> function manager
    interface.
   </para>
________________________________________________________-->
   <para>
    触发器函数必须使用<quote>版本 1</quote>函数管理器接口。
   </para>
<!-- pgdoc-cn_end sig_en=b642ec09655675f44a08157263b083fc -->

<!-- pgdoc-cn_start sig_en=66d0ba398fc9c71ae9c894a29383db64 sig_cn_org=None source=14.1 
   <para>
    When a function is called by the trigger manager, it is not passed
    any normal arguments, but it is passed a <quote>context</quote>
    pointer pointing to a <structname>TriggerData</structname> structure.  C
    functions can check whether they were called from the trigger
    manager or not by executing the macro:
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    which expands to:
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    If this returns true, then it is safe to cast
    <literal>fcinfo-&gt;context</literal> to type <literal>TriggerData
    *</literal> and make use of the pointed-to
    <structname>TriggerData</structname> structure.  The function must
    <emphasis>not</emphasis> alter the <structname>TriggerData</structname>
    structure or any of the data it points to.
   </para>
________________________________________________________-->
   <para>
    当一个函数被触发器管理器调用时，不会给它传递任何常规的参数，但是会有一个<quote>context</quote>指针传递给它，该指针指向一个<structname>TriggerData</structname>结构。C 函数可以通过执行一个宏来检查它们是否是从触发器管理器被调用：
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    它会展开成为：
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    如果这返回真，那么将<literal>fcinfo-&gt;context</literal>造型成类型<literal>TriggerData *</literal>并且利用所指向的<structname>TriggerData</structname>结构就是安全的。该函数<emphasis>不能</emphasis>修改该<structname>TriggerData</structname>结构或者它指向的任何数据。
   </para>
<!-- pgdoc-cn_end sig_en=66d0ba398fc9c71ae9c894a29383db64 -->

<!-- pgdoc-cn_start sig_en=461d7e17dbcd28022eaa1508aed90e3d sig_cn_org=a98e45e9688c61e3b4a949d9357bc5a5 source=15.7 
   <para>
    <structname>struct TriggerData</structname> is defined in
    <filename>commands/trigger.h</filename>:
________________________________________________________-->
   <para>
    <structname>结构体 TriggerData</structname> 在
    <filename>commands/trigger.h</filename> 中定义：
<!-- pgdoc-cn_end sig_en=461d7e17dbcd28022eaa1508aed90e3d -->

<!-- pgdoc-cn_start sig_en=7e13a5ce282a0b869e438a72bff1f54d sig_cn_org=7e13a5ce282a0b869e438a72bff1f54d source=15.7 
<programlisting>
typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    TupleTableSlot  *tg_trigslot;
    TupleTableSlot  *tg_newslot;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
    const Bitmapset *tg_updatedcols;
} TriggerData;
</programlisting>
________________________________________________________-->
<programlisting>
typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    TupleTableSlot  *tg_trigslot;
    TupleTableSlot  *tg_newslot;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
    const Bitmapset *tg_updatedcols;
} TriggerData;
</programlisting>
<!-- pgdoc-cn_end sig_en=7e13a5ce282a0b869e438a72bff1f54d -->

<!-- pgdoc-cn_start sig_en=6443d2599244bffcd16a9d1327baeb6f sig_cn_org=6e084d38b0c69f5dd5853b8bd95792d0 source=15.7 
    where the members are defined as follows:

    <variablelist>
     <varlistentry>
________________________________________________________-->
    成员定义如下：

    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_end sig_en=6443d2599244bffcd16a9d1327baeb6f -->
<!-- pgdoc-cn_start sig_en=7531f254b49c5b522f5a3d6e83a62244 sig_cn_org=a9d05b3f18e1034093b3d05dd4347bdc source=15.7 
      <term><structfield>type</structfield></term>
________________________________________________________-->
      <term><structfield>type</structfield></term>
<!-- pgdoc-cn_end sig_en=7531f254b49c5b522f5a3d6e83a62244 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=b1079e773bcf488680af5f945f930b01 sig_cn_org=68c02d36223f27629ddfebc49598f7ec source=15.7 
       <para>
        Always <literal>T_TriggerData</literal>.
       </para>
________________________________________________________-->
       <para>
        始终是<literal>T_TriggerData</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=b1079e773bcf488680af5f945f930b01 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=a6b17d09684c4cd43a2e1fe8c0a6675b sig_cn_org=a6b17d09684c4cd43a2e1fe8c0a6675b source=15.7 
      <term><structfield>tg_event</structfield></term>
________________________________________________________-->
      <term><structfield>tg_event</structfield></term>
<!-- pgdoc-cn_end sig_en=a6b17d09684c4cd43a2e1fe8c0a6675b -->
      <listitem>
<!-- pgdoc-cn_start sig_en=2fef437329d129e9b06f92066c70e8ce sig_cn_org=0b60775c035212986eeb96ef17112f47 source=15.7 
       <para>
        Describes the event for which the function is called. You can use the
        following macros to examine <literal>tg_event</literal>:

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired before the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired after the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired instead of the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired for a row-level event.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired for a statement-level event.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by an <command>INSERT</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by an <command>UPDATE</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by a <command>DELETE</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by a <command>TRUNCATE</command> command.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
________________________________________________________-->
       <para>
        描述调用函数的事件。您可以使用以下宏来检查<literal>tg_event</literal>：

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器在操作之前触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器在操作之后触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器代替操作触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器为行级事件触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器为语句级事件触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器由<command>INSERT</command>命令触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器由<command>UPDATE</command>命令触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器由<command>DELETE</command>命令触发，则返回true。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            如果触发器由<command>TRUNCATE</command>命令触发，则返回true。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
<!-- pgdoc-cn_end sig_en=2fef437329d129e9b06f92066c70e8ce -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=edc4fe5ed34ff6f566e3b2696cf410d7 sig_cn_org=edc4fe5ed34ff6f566e3b2696cf410d7 source=15.7 
      <term><structfield>tg_relation</structfield></term>
________________________________________________________-->
      <term><structfield>tg_relation</structfield></term>
<!-- pgdoc-cn_end sig_en=edc4fe5ed34ff6f566e3b2696cf410d7 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=f022594fec9bd4330cb3541d9555f420 sig_cn_org=8da5611fead41047c01abac57797992a source=15.7 
       <para>
        A pointer to a structure describing the relation that the trigger fired for.
        Look at <filename>utils/rel.h</filename> for details about
        this structure.  The most interesting things are
        <literal>tg_relation-&gt;rd_att</literal> (descriptor of the relation
        tuples) and <literal>tg_relation-&gt;rd_rel-&gt;relname</literal>
        (relation name; the type is not <type>char*</type> but
        <type>NameData</type>; use
        <literal>SPI_getrelname(tg_relation)</literal> to get a <type>char*</type> if you
        need a copy of the name).
       </para>
________________________________________________________-->
       <para>
        指向描述触发器触发的关系的结构的指针。
        查看<filename>utils/rel.h</filename>以获取有关此结构的详细信息。
        最有趣的是<literal>tg_relation-&gt;rd_att</literal>（关系元组的描述符）
        和<literal>tg_relation-&gt;rd_rel-&gt;relname</literal>（关系名称；
        类型不是<type>char*</type>，而是<type>NameData</type>；
        如果需要名称的副本，请使用<literal>SPI_getrelname(tg_relation)</literal>获取<type>char*</type>）。
       </para>
<!-- pgdoc-cn_end sig_en=f022594fec9bd4330cb3541d9555f420 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=1ffd70599f7a59b2e2a13f84e389c66c sig_cn_org=1ffd70599f7a59b2e2a13f84e389c66c source=15.7 
      <term><structfield>tg_trigtuple</structfield></term>
________________________________________________________-->
      <term><structfield>tg_trigtuple</structfield></term>
<!-- pgdoc-cn_end sig_en=1ffd70599f7a59b2e2a13f84e389c66c -->
      <listitem>
<!-- pgdoc-cn_start sig_en=1199e4dd2088d1af4465a9a26eaa03d4 sig_cn_org=acc3c9a7d666173111404ef39ab1a29d source=15.7 
       <para>
        A pointer to the row for which the trigger was fired. This is
        the row being inserted, updated, or deleted.  If this trigger
        was fired for an <command>INSERT</command> or
        <command>DELETE</command> then this is what you should return
        from the function if you don't want to replace the row with
        a different one (in the case of <command>INSERT</command>) or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
       </para>
________________________________________________________-->
       <para>
        触发器触发的行的指针。这是被插入、更新或删除的行。如果这个触发器是为<command>INSERT</command>或
        <command>DELETE</command>而触发的，那么如果您不想用不同的行替换该行（在<command>INSERT</command>的情况下）或跳过操作，则应该从函数中返回这个值。
        对于外部表的触发器，这里的系统列的值是未指定的。
       </para>
<!-- pgdoc-cn_end sig_en=1199e4dd2088d1af4465a9a26eaa03d4 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=2638c8744afa9fa8751c2e97b50432f0 sig_cn_org=2638c8744afa9fa8751c2e97b50432f0 source=15.7 
      <term><structfield>tg_newtuple</structfield></term>
________________________________________________________-->
      <term><structfield>tg_newtuple</structfield></term>
<!-- pgdoc-cn_end sig_en=2638c8744afa9fa8751c2e97b50432f0 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=0dd75f6f5a24d99586c5db89e92a5b02 sig_cn_org=d3c6a98f997a857eff8f28a779c62656 source=15.7 
       <para>
        A pointer to the new version of the row, if the trigger was
        fired for an <command>UPDATE</command>, and <symbol>NULL</symbol> if
        it is for an <command>INSERT</command> or a
        <command>DELETE</command>. This is what you have to return
        from the function if the event is an <command>UPDATE</command>
        and you don't want to replace this row by a different one or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
       </para>
________________________________________________________-->
       <para>
        如果触发器是为<command>UPDATE</command>而触发的，则指向行的新版本；如果是为<command>INSERT</command>或<command>DELETE</command>而触发的，则为<symbol>NULL</symbol>。
        如果事件是<command>UPDATE</command>，并且您不想用不同的行替换此行或跳过操作，则必须从函数中返回此值。对于外部表的触发器，此处的系统列值是未指定的。
       </para>
<!-- pgdoc-cn_end sig_en=0dd75f6f5a24d99586c5db89e92a5b02 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=022e26e25b5c493094829f81f89a425e sig_cn_org=022e26e25b5c493094829f81f89a425e source=15.7 
      <term><structfield>tg_trigger</structfield></term>
________________________________________________________-->
      <term><structfield>tg_trigger</structfield></term>
<!-- pgdoc-cn_end sig_en=022e26e25b5c493094829f81f89a425e -->
      <listitem>
<!-- pgdoc-cn_start sig_en=6c17a6a9c9197a8ef3b291b0c3974acf sig_cn_org=f997f69bcfffb2b55321c6c7bdf0d824 source=15.7 
       <para>
        A pointer to a structure of type <structname>Trigger</structname>,
        defined in <filename>utils/reltrigger.h</filename>:

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    bool        tgisclone;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
</programlisting>

       where <structfield>tgname</structfield> is the trigger's name,
       <structfield>tgnargs</structfield> is the number of arguments in
       <structfield>tgargs</structfield>, and <structfield>tgargs</structfield> is an array of
       pointers to the arguments specified in the <command>CREATE
       TRIGGER</command> statement. The other members are for internal use
       only.
       </para>
________________________________________________________-->
       <para>
        指向在<filename>utils/reltrigger.h</filename>中定义的<structname>Trigger</structname>类型的结构体指针：

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    bool        tgisclone;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
</programlisting>

       其中<structfield>tgname</structfield>是触发器的名称，
       <structfield>tgnargs</structfield>是<structfield>tgargs</structfield>中参数的数量，
       <structfield>tgargs</structfield>是指向<command>CREATE
       TRIGGER</command>语句中指定参数的指针数组。其他成员仅供内部使用。
       </para>
<!-- pgdoc-cn_end sig_en=6c17a6a9c9197a8ef3b291b0c3974acf -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=59572fa6fa75c8049b5027969d425c7c sig_cn_org=59572fa6fa75c8049b5027969d425c7c source=15.7 
      <term><structfield>tg_trigslot</structfield></term>
________________________________________________________-->
      <term><structfield>tg_trigslot</structfield></term>
<!-- pgdoc-cn_end sig_en=59572fa6fa75c8049b5027969d425c7c -->
      <listitem>
<!-- pgdoc-cn_start sig_en=78dbe07ec339bcecfecf8f718d85317c sig_cn_org=bc5e1af666dd3c43e09f842c8e87c078 source=15.7 
       <para>
        The slot containing <structfield>tg_trigtuple</structfield>,
        or a <symbol>NULL</symbol> pointer if there is no such tuple.
       </para>
________________________________________________________-->
       <para>
        包含<structfield>tg_trigtuple</structfield>的槽，
        或者如果没有这样的元组，则为<symbol>NULL</symbol>指针。
       </para>
<!-- pgdoc-cn_end sig_en=78dbe07ec339bcecfecf8f718d85317c -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=3c9fbd1e4c8cc6b215d33d9b43f91caa sig_cn_org=3c9fbd1e4c8cc6b215d33d9b43f91caa source=15.7 
      <term><structfield>tg_newslot</structfield></term>
________________________________________________________-->
      <term><structfield>tg_newslot</structfield></term>
<!-- pgdoc-cn_end sig_en=3c9fbd1e4c8cc6b215d33d9b43f91caa -->
      <listitem>
<!-- pgdoc-cn_start sig_en=7d657d7e1f91e01afc2f180852df6b60 sig_cn_org=d54e6c456c8476315284d2f2d005cc24 source=15.7 
       <para>
        The slot containing <structfield>tg_newtuple</structfield>,
        or a <symbol>NULL</symbol> pointer if there is no such tuple.
       </para>
________________________________________________________-->
       <para>
        包含<structfield>tg_newtuple</structfield>的槽，
        或者如果没有这样的元组，则为<symbol>NULL</symbol>指针。
       </para>
<!-- pgdoc-cn_end sig_en=7d657d7e1f91e01afc2f180852df6b60 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=89b6459260745f6c80b00a33ba04094c sig_cn_org=89b6459260745f6c80b00a33ba04094c source=15.7 
      <term><structfield>tg_oldtable</structfield></term>
________________________________________________________-->
      <term><structfield>tg_oldtable</structfield></term>
<!-- pgdoc-cn_end sig_en=89b6459260745f6c80b00a33ba04094c -->
      <listitem>
<!-- pgdoc-cn_start sig_en=f47456ab0ff7d1ef36f9a393210fda4a sig_cn_org=5e4451453c897da65f7331a19e5e496e source=15.7 
       <para>
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer
        if there is no <literal>OLD TABLE</literal> transition relation.
       </para>
________________________________________________________-->
       <para>
        指向一个类型为<structname>Tuplestorestate</structname>的结构体，
        包含零个或多个以<structfield>tg_relation</structfield>指定格式的行，
        或者一个<symbol>NULL</symbol>指针，如果没有<literal>OLD TABLE</literal>过渡关系。
       </para>
<!-- pgdoc-cn_end sig_en=f47456ab0ff7d1ef36f9a393210fda4a -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=fd3e57c09e6b95e2ede2dbf4dcad175f sig_cn_org=fd3e57c09e6b95e2ede2dbf4dcad175f source=15.7 
      <term><structfield>tg_newtable</structfield></term>
________________________________________________________-->
      <term><structfield>tg_newtable</structfield></term>
<!-- pgdoc-cn_end sig_en=fd3e57c09e6b95e2ede2dbf4dcad175f -->
      <listitem>
<!-- pgdoc-cn_start sig_en=fce94ca284fab9d2a2b03832ea791cf7 sig_cn_org=ef02ef37f1ec71fcc073f938adad9697 source=15.7 
       <para>
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer
        if there is no <literal>NEW TABLE</literal> transition relation.
       </para>
________________________________________________________-->
       <para>
        指向一个类型为<structname>Tuplestorestate</structname>的结构体，
        其中包含零个或多个以<structfield>tg_relation</structfield>指定格式的行，
        或者一个<symbol>NULL</symbol>指针，如果没有<literal>NEW TABLE</literal>过渡关系。
       </para>
<!-- pgdoc-cn_end sig_en=fce94ca284fab9d2a2b03832ea791cf7 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=ccca600f6e9be2de1eac80a4dde7d869 sig_cn_org=ccca600f6e9be2de1eac80a4dde7d869 source=15.7 
      <term><structfield>tg_updatedcols</structfield></term>
________________________________________________________-->
      <term><structfield>tg_updatedcols</structfield></term>
<!-- pgdoc-cn_end sig_en=ccca600f6e9be2de1eac80a4dde7d869 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=eb812111684c6cdb186ee83fac0c5e9f sig_cn_org=75d014113bb2cdf8d89b6b22080c459f source=15.7 
       <para>
        For <literal>UPDATE</literal> triggers, a bitmap set indicating the
        columns that were updated by the triggering command.  Generic trigger
        functions can use this to optimize actions by not having to deal with
        columns that were not changed.
       </para>
________________________________________________________-->
       <para>
        对于<literal>UPDATE</literal>触发器，一个位图集，指示被触发命令更新的列。
        通用触发器函数可以使用它来优化操作，因为它不必处理未更改的列。
</para>
<!-- pgdoc-cn_end sig_en=eb812111684c6cdb186ee83fac0c5e9f -->

<!-- pgdoc-cn_start sig_en=348888565e554b10b8e805f2fe157b14 sig_cn_org=a1e891cd6059cbeb2cfe9f46d070cd37 source=15.7 
       <para>
        As an example, to determine whether a column with attribute number
        <varname>attnum</varname> (1-based) is a member of this bitmap set,
        call <literal>bms_is_member(attnum -
        FirstLowInvalidHeapAttributeNumber,
        trigdata->tg_updatedcols))</literal>.
       </para>
________________________________________________________-->
       <para>
        例如，要确定具有属性编号为<varname>attnum</varname>（从1开始）的列是否是此位图集合的成员，
        调用<literal>bms_is_member(attnum -
        FirstLowInvalidHeapAttributeNumber,
        trigdata->tg_updatedcols))</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=348888565e554b10b8e805f2fe157b14 -->

<!-- pgdoc-cn_start sig_en=7d48895cc25afbdcbbc7d27f9cd18fca sig_cn_org=994d692a6c582d37f8e4b09b3ce52a4f source=15.7 
       <para>
        For triggers other than <literal>UPDATE</literal> triggers, this will
        be <symbol>NULL</symbol>.
       </para>
________________________________________________________-->
       <para>
        对于<literal>UPDATE</literal>触发器之外的触发器，这将是<symbol>NULL</symbol>。
       </para>
<!-- pgdoc-cn_end sig_en=7d48895cc25afbdcbbc7d27f9cd18fca -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!-- pgdoc-cn_start sig_en=f9465f9081e3fef451e97e127f7dfd5c sig_cn_org=None source=14.1 
   <para>
    To allow queries issued through SPI to reference transition tables, see
    <xref linkend="spi-spi-register-trigger-data"/>.
   </para>
________________________________________________________-->
   <para>
    为了允许通过SPI发出的查询引用传递表，请参考<xref linkend="spi-spi-register-trigger-data"/>。
   </para>
<!-- pgdoc-cn_end sig_en=f9465f9081e3fef451e97e127f7dfd5c -->

<!-- pgdoc-cn_start sig_en=6400e63506e0bc10cc9626eb0fe38fef sig_cn_org=None source=14.1 
   <para>
    A trigger function must return either a
    <structname>HeapTuple</structname> pointer or a <symbol>NULL</symbol> pointer
    (<emphasis>not</emphasis> an SQL null value, that is, do not set <parameter>isNull</parameter> true).
    Be careful to return either
    <structfield>tg_trigtuple</structfield> or <structfield>tg_newtuple</structfield>,
    as appropriate, if you don't want to modify the row being operated on.
   </para>
________________________________________________________-->
   <para>
    一个触发器函数必须返回一个<structname>HeapTuple</structname>指针或一个<symbol>NULL</symbol>指针（<emphasis>不是</emphasis>一个 SQL 空值，也就是不会设置<parameter>isNull</parameter>为真）。如果你不希望修改正在被操作的行，要小心地根据情况返回<structfield>tg_trigtuple</structfield>或<structfield>tg_newtuple</structfield>。
   </para>
<!-- pgdoc-cn_end sig_en=6400e63506e0bc10cc9626eb0fe38fef -->
  </sect1>

  <sect1 id="trigger-example">
<!-- pgdoc-cn_start sig_en=bdd7d574a3015237815d7bf87d55bd5e sig_cn_org=None source=14.1 
   <title>A Complete Trigger Example</title>
________________________________________________________-->
   <title>一个完整的触发器实例</title>
<!-- pgdoc-cn_end sig_en=bdd7d574a3015237815d7bf87d55bd5e -->

<!-- pgdoc-cn_start sig_en=58ce427fa38d709bc4d62600a8a93a17 sig_cn_org=None source=14.1 
   <para>
    Here is a very simple example of a trigger function written in C.
    (Examples of triggers written in procedural languages can be found
    in the documentation of the procedural languages.)
   </para>
________________________________________________________-->
   <para>
    这里有一个用 C 编写的触发器函数的非常简单的例子（用过程语言编写的触发器的例子可以在过程语言的文档中找到）。
   </para>
<!-- pgdoc-cn_end sig_en=58ce427fa38d709bc4d62600a8a93a17 -->

<!-- pgdoc-cn_start sig_en=3b47a212401a89f8e843786b9087d76a sig_cn_org=None source=14.1 
   <para>
    The function <function>trigf</function> reports the number of rows in the
    table <structname>ttest</structname> and skips the actual operation if the
    command attempts to insert a null value into the column
    <structfield>x</structfield>. (So the trigger acts as a not-null constraint but
    doesn't abort the transaction.)
   </para>
________________________________________________________-->
   <para>
    如果该命令试图向列<structfield>x</structfield>中插入一个空值，函数<function>trigf</function>报告表<structname>ttest</structname>中的行数并且跳过实际的操作（这样该触发器会作为一个非空约束但不会中止事务）。
   </para>
<!-- pgdoc-cn_end sig_en=3b47a212401a89f8e843786b9087d76a -->

<!-- pgdoc-cn_start sig_en=d9aea0cd6b7cb6291337fb4a6b077895 sig_cn_org=None source=14.1 
   <para>
    First, the table definition:
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    首先，表定义：
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d9aea0cd6b7cb6291337fb4a6b077895 -->

<!-- pgdoc-cn_start sig_en=99ef000b92317f7ac31535e75f416889 sig_cn_org=None source=14.1 
   <para>
    This is the source code of the trigger function:
<programlisting><![CDATA[
#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

    /* make sure it's called as a trigger at all */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* tuple to return to executor */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* check for null values */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connect to SPI manager */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* get number of rows in table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) returns int8, so be careful to convert */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这是该触发器函数的源代码：
<programlisting><![CDATA[
#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

    /* make sure it's called as a trigger at all */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* tuple to return to executor */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* check for null values */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connect to SPI manager */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* get number of rows in table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) returns int8, so be careful to convert */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=99ef000b92317f7ac31535e75f416889 -->

<!-- pgdoc-cn_start sig_en=5830a9a02f0f855d27bc2534d530fba7 sig_cn_org=None source=14.1 
   <para>
    After you have compiled the source code (see <xref
    linkend="dfunc"/>), declare the function and the triggers:
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在你编译了该源代码（见<xref linkend="dfunc"/>）之后，声明该函数和触发器：
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=5830a9a02f0f855d27bc2534d530fba7 -->

<!-- pgdoc-cn_start sig_en=81cd2c73ce4f4eb2a4b00c743ac39a8e sig_cn_org=None source=14.1 
   <para>
    Now you can test the operation of the trigger:
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-&minus; Insertion skipped and AFTER trigger is not fired

=&gt; SELECT * FROM ttest;
 x
-&minus;-
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                             remember what we said about visibility.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
-&minus;-
(0 rows)
</screen>

   </para>
________________________________________________________-->
   <para>
    现在你可以测试该触发器的操作：
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion skipped and AFTER trigger is not fired

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                             remember what we said about visibility.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>
<!-- pgdoc-cn_end sig_en=81cd2c73ce4f4eb2a4b00c743ac39a8e -->

<!-- pgdoc-cn_start sig_en=071fce94d3ba7c864aa483ca88b8a37c sig_cn_org=None source=14.1 
   <para>
    There are more complex examples in
    <filename>src/test/regress/regress.c</filename> and
    in <xref linkend="contrib-spi"/>.
   </para>
________________________________________________________-->
   <para>
    在<filename>src/test/regress/regress.c</filename>和<xref linkend="contrib-spi"/>中有更多复杂的例子。
   </para>
<!-- pgdoc-cn_end sig_en=071fce94d3ba7c864aa483ca88b8a37c -->
  </sect1>
 </chapter>
