<!-- doc/src/sgml/datetime.sgml -->

 <appendix id="datetime-appendix">
<!--==========================orignal english content==========================
  <title>Date/Time Support</title>
____________________________________________________________________________-->
  <title>日期/时间支持</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> uses an internal heuristic
   parser for all date/time input support. Dates and times are input as
   strings, and are broken up into distinct fields with a preliminary
   determination of what kind of information can be in the
   field. Each field is interpreted and either assigned a numeric
   value, ignored, or rejected.
   The parser contains internal lookup tables for all textual fields,
   including months, days of the week, and time zones.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>使用一个内部的启发式解析器来进行所有日期/时间输入的支持。日期和时间被作为字符串输入，并且被分解为不同的域，这些域都已经预定义好了要存放哪一类信息。每个域会被解释并且被分配一个数字值或者被忽略、拒绝。该解析器为所有的文本形式的域都包含了内部查找表，包括月份、一周中的日和时区。
  </para>

<!--==========================orignal english content==========================
  <para>
   This appendix includes information on the content of these
   lookup tables and describes the steps used by the parser to decode
   dates and times.
  </para>
____________________________________________________________________________-->
  <para>
   这个附录包括这些查找表内容的信息并且描述了解析器解码日期和时间所用的步骤。
  </para>

  <sect1 id="datetime-input-rules">
<!--==========================orignal english content==========================
   <title>Date/Time Input Interpretation</title>
____________________________________________________________________________-->
   <title>日期/时间输入解释</title>

<!--==========================orignal english content==========================
   <para>
    Date/time input strings are decoded using the following procedure.
   </para>
____________________________________________________________________________-->
   <para>
    日期/时间类型输入使用下面的过程解码。
   </para>

   <procedure>
    <step>
<!--==========================orignal english content==========================
     <para>
      Break the input string into tokens and categorize each token as
      a string, time, time zone, or number.
     </para>
____________________________________________________________________________-->
     <para>
      将输入字符串打断成记号并且把每一个记号分类为一个字符串、时间、时区或数字。
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        If the numeric token contains a colon (<literal>:</literal>), this is
        a time string. Include all subsequent digits and colons.
       </para>
____________________________________________________________________________-->
       <para>
        如果数字记号包含一个分号（<literal>:</literal>），那么这是一个时间字符串。包括所有后续数位和分号。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the numeric token contains a dash (<literal>-</literal>), slash
        (<literal>/</literal>), or two or more dots (<literal>.</literal>), this is
        a date string which might have a text month.  If a date token has
        already been seen, it is instead interpreted as a time zone
        name (e.g., <literal>America/New_York</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果数字记号包含一个连字符（<literal>-</literal>）、斜线（<literal>/</literal>）或两个以上的句点（<literal>.</literal>），那么这是一个日期字符串，它可能含有一个文本形式的月份。如果一个日期记号已经被看到，它会转而被解释为一个时区名（例如<literal>America/New_York</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token is numeric only, then it is either a single field
        or an ISO 8601 concatenated date (e.g.,
        <literal>19990113</literal> for January 13, 1999) or time
        (e.g., <literal>141516</literal> for 14:15:16).
       </para>
____________________________________________________________________________-->
       <para>
        如果记号只是数字，那么它要么是一个单一域，要么是一个 ISO 8601 串连日期（例如 1999年1月13日是<literal>19990113</literal>）或时间（例如 14:15:16 是<literal>141516</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token starts with a plus (<literal>+</literal>) or minus
        (<literal>-</literal>), then it is either a numeric time zone or a special
        field.
       </para>
____________________________________________________________________________-->
       <para>
        如果记号以一个加号（<literal>+</literal>）或减号（<literal>-</literal>）开始，那么它要么是一个数字的时区，要么是一个特殊域。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If the token is an alphabetic string, match up with possible strings:
     </para>
____________________________________________________________________________-->
     <para>
      如果记号是一个字母字符串，使之匹配可能的串：
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        See if the token matches any known time zone abbreviation.
        These abbreviations are supplied by the configuration file
        described in <xref linkend="datetime-config-files"/>.
       </para>
____________________________________________________________________________-->
       <para>
        查看记号是否与任何已知的时区缩写匹配。
       这些缩写由在<xref linkend ="datetime-config-files"/>中描述的配置文件提供。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If not found, search an internal table to match
        the token as either a special string (e.g., <literal>today</literal>),
        day (e.g., <literal>Thursday</literal>),
        month (e.g., <literal>January</literal>),
        or noise word (e.g., <literal>at</literal>, <literal>on</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果没有找到，搜索一个内部表来查找将该记号是否匹配为一个特殊串（例如<literal>today</literal>）、日（例如<literal>Thursday</literal>）、月（例如<literal>January</literal>）或噪音词（例如<literal>at</literal>、<literal>on</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If still not found, throw an error.
       </para>
____________________________________________________________________________-->
       <para>
        如果仍然没有找到，则抛出一个错误。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      When the token is a number or number field:
     </para>
____________________________________________________________________________-->
     <para>
      当记号是一个数字或数字域时：
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        If there are eight or six digits,
        and if no other date fields have been previously read, then interpret
        as a <quote>concatenated date</quote> (e.g.,
        <literal>19990118</literal> or <literal>990118</literal>).
        The interpretation is <literal>YYYYMMDD</literal> or <literal>YYMMDD</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果有 8 位或 6 位，并且之前没有读到其他日期域，那么解释为一个<quote>串连日期</quote>（例如<literal>19990118</literal>或<literal>990118</literal>）。翻译是<literal>YYYYMMDD</literal>或<literal>YYMMDD</literal>。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token is three digits
        and a year has already been read, then interpret as day of year.
       </para>
____________________________________________________________________________-->
       <para>
        如果记号是 3 位并且已经读到了一个年域，那么解释为一年中的第几日。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If four or six digits and a year has already been read, then
        interpret as a time (<literal>HHMM</literal> or <literal>HHMMSS</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果是 4 位或 6 位并且已经读到了一个年域，那么解释为一个时间域（<literal>HHMM</literal>或<literal>HHMMSS</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If three or more digits and no date fields have yet been found,
        interpret as a year (this forces yy-mm-dd ordering of the remaining
        date fields).
       </para>
____________________________________________________________________________-->
       <para>
        如果是 3 位或更多位并且还没有读到日期域，解释为一个年域（这会强制剩余日期域的 yy-mm-dd 顺序）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        Otherwise the date field ordering is assumed to follow the
        <varname>DateStyle</varname> setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd.
        Throw an error if a month or day field is found to be out of range.
       </para>
____________________________________________________________________________-->
       <para>
        否则日期域顺序被假定为遵循<varname>DateStyle</varname>设置：mm-dd-yy、dd-mm-yy 或 yy-mm-dd。如果一个月或日域被发现超过范围，则抛出一个错误。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If BC has been specified, negate the year and add one for
      internal storage.  (There is no year zero in the Gregorian
      calendar, so numerically 1 BC becomes year zero.)
     </para>
____________________________________________________________________________-->
     <para>
      如果已经指定了 BC ，对年求反并且加一用于内部存储（在格里高利历中没有 0 年，因此数字的 1 BC 就是 0 年）。
     </para>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If BC was not specified, and if the year field was two digits in length,
      then adjust the year to four digits. If the field is less than 70, then
      add 2000, otherwise add 1900.

      <tip>
       <para>
        Gregorian years AD 1&ndash;99 can be entered by using 4 digits with leading
        zeros (e.g., <literal>0099</literal> is AD 99).
       </para>
      </tip>
     </para>
____________________________________________________________________________-->
     <para>
      如果没有指定 BC ，并且如果该年域长度为两位，那么把该年域调整为四位。如果该域小于 70，则增加 2000，否则增加 1900。

      <tip>
       <para>
        公历年 AD 1&ndash;99 可以使用带有前导零的 4 位形式录入（例如<literal>0099</literal>是 AD 99）。
       </para>
      </tip>
     </para>
    </step>
   </procedure>
  </sect1>

  <sect1 id="datetime-invalid-input">
<!--==========================orignal english content==========================
   <title>Handling of Invalid or Ambiguous Timestamps</title>
____________________________________________________________________________-->
   <title>处理无效或不明确的时间戳</title>

<!--==========================orignal english content==========================
   <para>
    Ordinarily, if a date/time string is syntactically valid but contains
    out-of-range field values, an error will be thrown.  For example, input
    specifying the 31st of February will be rejected.
   </para>
____________________________________________________________________________-->
   <para>
     通常，如果日期/时间字符串在语法上有效但包含
     超出范围的字段值，将引发错误。 例如，输入2月31日将被拒绝。
   </para>

<!--==========================orignal english content==========================
   <para>
    During a daylight-savings-time transition, it is possible for a
    seemingly valid timestamp string to represent a nonexistent or ambiguous
    timestamp.  Such cases are not rejected; the ambiguity is resolved by
    determining which UTC offset to apply.  For example, supposing that the
    <xref linkend="guc-timezone"/> parameter is set
    to <literal>America/New_York</literal>, consider
<programlisting>
=&gt; SELECT '2018-03-11 02:30'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-03-11 03:30:00-04
(1 row)
</programlisting>
    Because that day was a spring-forward transition date in that time zone,
    there was no civil time instant 2:30AM; clocks jumped forward from 2AM
    EST to 3AM EDT.  <productname>PostgreSQL</productname> interprets the
    given time as if it were standard time (UTC-5), which then renders as
    3:30AM EDT (UTC-4).
   </para>
____________________________________________________________________________-->
   <para>
   在夏令时转换期间，看似有效的时间戳字符串可能表示不存在或不明确的时间戳。
   这样的输入不会被拒绝;不确定性可以通过要应用哪个UTC偏移来解决。 
   例如，假设<xref linkend="guc-timezone"/>参数设置为<literal>America/New_York</literal>，请考虑
<programlisting>
=&gt; SELECT '2018-03-11 02:30'::timestamptz;
      timestamptz
------------------------
 2018-03-11 03:30:00-04
(1 row)
</programlisting>
    因为那天是那个时区的春天过渡日期，所以没有民用时间凌晨2:30; 时钟从2AM EST跳转到3AM EDT。
    <productname>PostgreSQL</productname>将给定时间解释为标准时间（UTC-5），然后呈现为3:30AM EDT（UTC-4）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Conversely, consider the behavior during a fall-back transition:
<programlisting>
=&gt; SELECT '2018-11-04 02:30'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-11-04 02:30:00-05
(1 row)
</programlisting>
    On that date, there were two possible interpretations of 2:30AM; there
    was 2:30AM EDT, and then an hour later after the reversion to standard
    time, there was 2:30AM EST.
    Again, <productname>PostgreSQL</productname> interprets the given time
    as if it were standard time (UTC-5).  We can force the matter by
    specifying daylight-savings time:
<programlisting>
=&gt; SELECT '2018-11-04 02:30 EDT'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-11-04 01:30:00-05
(1 row)
</programlisting>
    This timestamp could validly be rendered as either 2:30 UTC-4 or
    1:30 UTC-5; the timestamp output code chooses the latter.
   </para>
____________________________________________________________________________-->
   <para>
    相反，请考虑后向过渡期间的行为:
<programlisting>
=&gt; SELECT '2018-11-04 02:30'::timestamptz;
      timestamptz
------------------------
 2018-11-04 02:30:00-05
(1 row)
</programlisting>
    在那一天，上午2:30有两种可能的解释; 2:30AM EDT，以及一小时以后，如果转换到标准时间，即2:30AM EST。
    同样，<productname>PostgreSQL</productname>将给定时间解释为标准时间（UTC-5）。
    我们可以通过指定夏令时来强行控制:
<programlisting>
=&gt; SELECT '2018-11-04 02:30 EDT'::timestamptz;
      timestamptz
------------------------
 2018-11-04 01:30:00-05
(1 row)
</programlisting>

     此时间戳可以有效地呈现为2:30 UTC-4或1:30 UTC-5; 时间戳输出代码选择后者。
   </para>

<!--==========================orignal english content==========================
   <para>
    The precise rule that is applied in such cases is that an invalid
    timestamp that appears to fall within a jump-forward daylight savings
    transition is assigned the UTC offset that prevailed in the time zone
    just before the transition, while an ambiguous timestamp that could fall
    on either side of a jump-back transition is assigned the UTC offset that
    prevailed just after the transition.  In most time zones this is
    equivalent to saying that <quote>the standard-time interpretation is
    preferred when in doubt</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    在这些情况下应用的精确规则是，出现在前向跳转的夏令时转换中的无效时间戳被分配了转换之前的时区对应的UTC偏移；
    可能落在后向跳转的两边的不确定的时间戳被分配了转换之后的时区对应的UTC偏移。
    在大多数时区，这相当于说<quote>在有疑问时，标准时间解释是首选</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    In all cases, the UTC offset associated with a timestamp can be
    specified explicitly, using either a numeric UTC offset or a time zone
    abbreviation that corresponds to a fixed UTC offset.  The rule just
    given applies only when it is necessary to infer a UTC offset for a time
    zone in which the offset varies.
   </para>
____________________________________________________________________________-->
   <para>
    在所有情况下，可以显式使用数字UTC偏移或对应于固定UTC偏移的时区缩写明确指定与时间戳关联的UTC偏移。 
    刚刚给出的规则仅在需要推断偏移量变化的时区的UTC偏移时才适用。
   </para>
  </sect1>

  <sect1 id="datetime-keywords">
<!--==========================orignal english content==========================
   <title>Date/Time Key Words</title>
____________________________________________________________________________-->
   <title>日期/时间关键词</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datetime-month-table"/> shows the tokens that are
    recognized as names of months.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datetime-month-table"/>展示了被识别为月份名称的记号。
   </para>

    <table id="datetime-month-table">
<!--==========================orignal english content==========================
     <title>Month Names</title>
____________________________________________________________________________-->
     <title>月份名称</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Month</entry>
        <entry>Abbreviations</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>月份</entry>
        <entry>简写</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry>January</entry>
        <entry>Jan</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>一月</entry>
        <entry>Jan</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>February</entry>
        <entry>Feb</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>二月</entry>
        <entry>Feb</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>March</entry>
        <entry>Mar</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>三月</entry>
        <entry>Mar</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>April</entry>
        <entry>Apr</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>四月</entry>
        <entry>Apr</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>May</entry>
        <entry></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>五月</entry>
        <entry></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>June</entry>
        <entry>Jun</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>六月</entry>
        <entry>Jun</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>July</entry>
        <entry>Jul</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>七月</entry>
        <entry>Jul</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>August</entry>
        <entry>Aug</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>八月</entry>
        <entry>Aug</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>September</entry>
        <entry>Sep, Sept</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>九月</entry>
        <entry>Sep, Sept</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>October</entry>
        <entry>Oct</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十月</entry>
        <entry>Oct</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>November</entry>
        <entry>Nov</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十一月</entry>
        <entry>Nov</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>December</entry>
        <entry>Dec</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十二月</entry>
        <entry>Dec</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="datetime-dow-table"/> shows the tokens that are
     recognized as names of days of the week.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="datetime-dow-table"/>展示了被识别为一周内每一天的名称的记号。
    </para>

     <table id="datetime-dow-table">
<!--==========================orignal english content==========================
      <title>Day of the Week Names</title>
____________________________________________________________________________-->
      <title>一周内每一天的名称</title>
      <tgroup cols="2">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Day</entry>
         <entry>Abbreviations</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>天</entry>
         <entry>简写</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>Sunday</entry>
         <entry>Sun</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周日</entry>
         <entry>Sun</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Monday</entry>
         <entry>Mon</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周一</entry>
         <entry>Mon</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Tuesday</entry>
         <entry>Tue, Tues</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周二</entry>
         <entry>Tue, Tues</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Wednesday</entry>
         <entry>Wed, Weds</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周三</entry>
         <entry>Wed, Weds</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Thursday</entry>
         <entry>Thu, Thur, Thurs</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周四</entry>
         <entry>Thu, Thur, Thurs</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Friday</entry>
         <entry>Fri</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周五</entry>
         <entry>Fri</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Saturday</entry>
         <entry>Sat</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周六</entry>
         <entry>Sat</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datetime-mod-table"/> shows the tokens that serve
    various modifier purposes.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datetime-mod-table"/>展示了服务于多种修饰目的的记号。
   </para>

    <table id="datetime-mod-table">
<!--==========================orignal english content==========================
     <title>Date/Time Field Modifiers</title>
____________________________________________________________________________-->
     <title>日期/时间域修饰语</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Identifier</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>标识符</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AM</literal></entry>
        <entry>Time is before 12:00</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AM</literal></entry>
        <entry>12:00 之前的时间</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AT</literal></entry>
        <entry>Ignored</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AT</literal></entry>
        <entry>被忽略</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>JULIAN</literal>, <literal>JD</literal>, <literal>J</literal></entry>
        <entry>Next field is Julian Date</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>JULIAN</literal>, <literal>JD</literal>, <literal>J</literal></entry>
        <entry>下一个域是儒略日期</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>ON</literal></entry>
        <entry>Ignored</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>ON</literal></entry>
        <entry>被忽略</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PM</literal></entry>
        <entry>Time is on or after 12:00</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PM</literal></entry>
        <entry>12:00 之后的时间</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>T</literal></entry>
        <entry>Next field is time</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>T</literal></entry>
        <entry>下一个域是时间</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>

  <sect1 id="datetime-config-files">
<!--==========================orignal english content==========================
  <title>Date/Time Configuration Files</title>
____________________________________________________________________________-->
  <title>日期/时间配置文件</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time zone</primary>
    <secondary>input abbreviations</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time zone</primary>
    <secondary>input abbreviations</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Since timezone abbreviations are not well standardized,
    <productname>PostgreSQL</productname> provides a means to customize
    the set of abbreviations accepted by the server.  The
    <xref linkend="guc-timezone-abbreviations"/> run-time parameter
    determines the active set of abbreviations.  While this parameter
    can be altered by any database user, the possible values for it
    are under the control of the database administrator &mdash; they
    are in fact names of configuration files stored in
    <filename>.../share/timezonesets/</filename> of the installation directory.
    By adding or altering files in that directory, the administrator
    can set local policy for timezone abbreviations.
   </para>
____________________________________________________________________________-->
   <para>
    因为时区缩写并未被很好地标准化，<productname>PostgreSQL</productname>提供了一种方法来自定义服务器所接受的缩写集合。<xref linkend="guc-timezone-abbreviations"/>运行时参数决定活动的缩写集合。虽然这个参数可以被任何数据库用户修改，但它的可能值是受到数据库管理员的控制的 &mdash; 它们实际上是存储在安装目录的<filename>.../share/timezonesets/</filename>子目录中的一些配置文件。通过在那个目录中增加或修改文件，管理员可以为时区缩写设定本地策略。
   </para>

<!--==========================orignal english content==========================
   <para>
    <varname>timezone_abbreviations</varname> can be set to any file name
    found in <filename>.../share/timezonesets/</filename>, if the file's name
    is entirely alphabetic.  (The prohibition against non-alphabetic
    characters in <varname>timezone_abbreviations</varname> prevents reading
    files outside the intended directory, as well as reading editor
    backup files and other extraneous files.)
   </para>
____________________________________________________________________________-->
   <para>
    <varname>timezone_abbreviations</varname>可以被设置为任何在<filename>.../share/timezonesets/</filename>中可以找到的文件名，前提该文件的名字完全是字母的（<varname>timezone_abbreviations</varname>中禁止非字母字符防止从预期目录的外面读取文件以及读取编辑器的备份文件和其他外部文件）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A timezone abbreviation file can contain blank lines and comments
    beginning with <literal>#</literal>.  Non-comment lines must have one of
    these formats:

<synopsis>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable> D
<replaceable>zone_abbreviation</replaceable> <replaceable>time_zone_name</replaceable>
@INCLUDE <replaceable>file_name</replaceable>
@OVERRIDE
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个时区缩写文件可以包含空行和以<literal>#</literal>开始的注释。非注释行必须具有下列格式之一：

<synopsis>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable> D
<replaceable>zone_abbreviation</replaceable> <replaceable>time_zone_name</replaceable>
@INCLUDE <replaceable>file_name</replaceable>
@OVERRIDE
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    A <replaceable>zone_abbreviation</replaceable> is just the abbreviation
    being defined.  An <replaceable>offset</replaceable> is an integer giving
    the equivalent offset in seconds from UTC, positive being east from
    Greenwich and negative being west.  For example, -18000 would be five
    hours west of Greenwich, or North American east coast standard time.
    <literal>D</literal> indicates that the zone name represents local
    daylight-savings time rather than standard time.
   </para>
____________________________________________________________________________-->
   <para>
    一个<replaceable>zone_abbreviation</replaceable>就是被定义的缩写。<replaceable>offset</replaceable>是一个整数，它给出以秒计的到 UTC 的等效偏移量，为正表示东起格林威治，为负表示西起格林威治。例如， -18000 表示格林威治西边的五个小时，或者北美东海岸标准时间。<literal>D</literal>指示该区域名表示本地夏令时而非标准时间。另外，还可以给出一个<replaceable>time_zone_name</replaceable>，在这种情况下会查阅该时区定义，并且会使用该时区中的缩写含义。这种替代方案只用于那些含义在历史上有变化的缩写，因为比起使用一个固定的整数值，查找该含义开销要大得多。
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively, a <replaceable>time_zone_name</replaceable> can be given, referencing
    a zone name defined in the IANA timezone database.  The zone's definition
    is consulted to see whether the abbreviation is or has been in use in
    that zone, and if so, the appropriate meaning is used &mdash; that is,
    the meaning that was currently in use at the timestamp whose value is
    being determined, or the meaning in use immediately before that if it
    wasn't current at that time, or the oldest meaning if it was used only
    after that time.  This behavior is essential for dealing with
    abbreviations whose meaning has historically varied.  It is also allowed
    to define an abbreviation in terms of a zone name in which that
    abbreviation does not appear; then using the abbreviation is just
    equivalent to writing out the zone name.
   </para>
____________________________________________________________________________-->
   <para>
    另外，还可以给出一个<replaceable>time_zone_name</replaceable>，它引用 IANA 时区数据库中定义的时区名。这时会参考该时区的定义来判断在时区中是否有或者使用了该缩写。如果是，会使用适当的含义 &mdash; 也就是正在判断其值的时间戳中当前使用的含义，或者之前刚刚使用的含义（如果当时不是当前），或者最老的含义（如果只在那时之后用过）。这种行为对于处理其含义在历史上变化过的缩写是至关重要的。也允许按照缩写没有出现在其中的时区名来定义缩写，这样使用该缩写就等效于直接写出该时区名。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Using a simple integer <replaceable>offset</replaceable> is preferred
     when defining an abbreviation whose offset from UTC has never changed,
     as such abbreviations are much cheaper to process than those that
     require consulting a time zone definition.
    </para>
____________________________________________________________________________-->
    <para>
     在定义其 UTC 偏移没有改变过的缩写时，使用简单的整数<replaceable>offset</replaceable>更好，这样的缩写在处理时代价比那些需要查阅时区定义的缩写更低。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    The <literal>@INCLUDE</literal> syntax allows inclusion of another file in the
    <filename>.../share/timezonesets/</filename> directory.  Inclusion can be nested,
    to a limited depth.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>@INCLUDE</literal>语法允许包括<filename>.../share/timezonesets/</filename>目录中
    的其它文件。允许进行嵌套包括，但是嵌套深度有限制。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>@OVERRIDE</literal> syntax indicates that subsequent entries in the
    file can override previous entries (typically, entries obtained from
    included files).  Without this, conflicting definitions of the same
    timezone abbreviation are considered an error.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>@OVERRIDE</literal>语法表示文件中后续项可以覆盖前面的项（典型的：从被包括的文件中
    得到的项）。如果没有它，同一个时区缩写的相互冲突的定义会被认为是一种错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    In an unmodified installation, the file <filename>Default</filename> contains
    all the non-conflicting time zone abbreviations for most of the world.
    Additional files <filename>Australia</filename> and <filename>India</filename> are
    provided for those regions: these files first include the
    <literal>Default</literal> file and then add or modify abbreviations as needed.
   </para>
____________________________________________________________________________-->
   <para>
    在一个未被修改的安装中，文件<filename>Default</filename>包含用于世界大部分地区的非冲突时区缩
    写。附加文件<filename>Australia</filename>和<filename>India</filename>被提供给那些地区：这些文件
    首先会包括<literal>Default</literal>文件，并且接着根据需要增加或修改缩写。
   </para>

<!--==========================orignal english content==========================
   <para>
    For reference purposes, a standard installation also contains files
    <filename>Africa.txt</filename>, <filename>America.txt</filename>, etc, containing
    information about every time zone abbreviation known to be in use
    according to the IANA timezone database.  The zone name
    definitions found in these files can be copied and pasted into a custom
    configuration file as needed.  Note that these files cannot be directly
    referenced as <varname>timezone_abbreviations</varname> settings, because of
    the dot embedded in their names.
   </para>
____________________________________________________________________________-->
   <para>
    为了便于参考，标准安装也包含了<filename>Africa.txt</filename>、<filename>America.txt</filename>
    等文件，它们包含了所有根据IANA 时区数据库中已知正在使用的时区缩写信息。 如果需要，这些文件中的时区名定义可以复制并粘贴到自定义的配置文件中。注意这些文件名
    不能直接被<varname>timezone_abbreviations</varname>设置引用，因为它们的名称中嵌有句点。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If an error occurs while reading the time zone abbreviation set, no new
     value is applied and the old set is kept. If the error occurs while
     starting the database, startup fails.
    </para>
____________________________________________________________________________-->
    <para>
     如果在读取时区缩写集时发生错误，将不会应用任何新值并且保留旧的集合。如果该错误是在数据库
     启动时发生，那么启动将失败。
    </para>
   </note>

   <caution>
<!--==========================orignal english content==========================
    <para>
     Time zone abbreviations defined in the configuration file override
     non-timezone meanings built into <productname>PostgreSQL</productname>.
     For example, the <filename>Australia</filename> configuration file defines
     <literal>SAT</literal> (for South Australian Standard Time).  When this
     file is active, <literal>SAT</literal> will not be recognized as an abbreviation
     for Saturday.
    </para>
____________________________________________________________________________-->
    <para>
     配置文件中定义的时区缩写将会覆盖<productname>PostgreSQL</productname>中内建的非
     时区含义。例如<filename>Australia</filename>配置文件定义了<literal>SAT</literal>（南澳洲标准时
     间）。当该文件为活动时，<literal>SAT</literal>将不会被识别为周六的缩写。
    </para>
   </caution>

   <caution>
<!--==========================orignal english content==========================
    <para>
     If you modify files in <filename>.../share/timezonesets/</filename>,
     it is up to you to make backups &mdash; a normal database dump
     will not include this directory.
    </para>
____________________________________________________________________________-->
    <para>
     如果你修改<filename>.../share/timezonesets/</filename>中的文件， 那么你必须自己创建备份 &mdash; 因为通常的数据库转储不会包括这个目录。
    </para>
   </caution>

  </sect1>

  <sect1 id="datetime-posix-timezone-specs">
<!--==========================orignal english content==========================
  <title><acronym>POSIX</acronym> Time Zone Specifications</title>
____________________________________________________________________________-->
  <title><acronym>POSIX</acronym> 时区规范</title>

<!--==========================orignal english content==========================
  <indexterm zone="datetime-posix-timezone-specs">
   <primary>time zone</primary>
   <secondary><acronym>POSIX</acronym>-style specification</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datetime-posix-timezone-specs">
   <primary>时区</primary>
   <secondary><acronym>POSIX</acronym>样式规范</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> can accept time zone specifications
   that are written according to the <acronym>POSIX</acronym> standard's rules
   for the <varname>TZ</varname> environment
   variable.  <acronym>POSIX</acronym> time zone specifications are
   inadequate to deal with the complexity of real-world time zone history,
   but there are sometimes reasons to use them.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>可以接受根据<acronym>POSIX</acronym>标准的针对<varname>TZ</varname>环境变量的规则编写的时区规范。 
   <acronym>POSIX</acronym>时区规范不足以处理真实世界时区历史的复杂性，但有时使用它们是有原因的。
  </para>

<!--==========================orignal english content==========================
  <para>
   A POSIX time zone specification has the form
<synopsis>
<replaceable>STD</replaceable> <replaceable>offset</replaceable> <optional> <replaceable>DST</replaceable> <optional> <replaceable>dstoffset</replaceable> </optional> <optional> , <replaceable>rule</replaceable> </optional> </optional>
</synopsis>
   (For readability, we show spaces between the fields, but spaces should
   not be used in practice.)  The fields are:
   <itemizedlist>
    <listitem>
     <para>
      <replaceable>STD</replaceable> is the zone abbreviation to be used
      for standard time.
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>offset</replaceable> is the zone's standard-time offset
      from UTC.
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>DST</replaceable> is the zone abbreviation to be used
      for daylight-savings time.  If this field and the following ones are
      omitted, the zone uses a fixed UTC offset with no daylight-savings
      rule.
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>dstoffset</replaceable> is the daylight-savings offset
      from UTC.  This field is typically omitted, since it defaults to one
      hour less than the standard-time <replaceable>offset</replaceable>,
      which is usually the right thing.
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>rule</replaceable> defines the rule for when daylight
      savings is in effect, as described below.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   POSIX时区规范具有形式
<synopsis>
<replaceable>STD</replaceable> <replaceable>offset</replaceable> <optional> <replaceable>DST</replaceable> <optional> <replaceable>dstoffset</replaceable> </optional> <optional> , <replaceable>rule</replaceable> </optional> </optional>
</synopsis>
   (为了可读性，我们在字段之间显示空格，但在实践中不应使用空格.)  这些区域包括:
   <itemizedlist>
    <listitem>
     <para>
      <replaceable>STD</replaceable> 是用于标准时间的区域缩写。
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>offset</replaceable> 是区域相对UTC的标准时间偏移量。
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>DST</replaceable>是用于夏令时的区域缩写。如果省略此字段和以下字段，则该区域使用没有夏令时规则的固定 UTC 偏移量。
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>dstoffset</replaceable>是相对UTC 的夏令时偏移。
      此字段通常会被省略，因为它默认会比标准时间<replaceable>offset</replaceable>少一个小时，这通常是正确的。
     </para>
    </listitem>
    <listitem>
     <para>
      <replaceable>rule</replaceable>定义夏令时生效的规则，如下所述。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   In this syntax, a zone abbreviation can be a string of letters, such
   as <literal>EST</literal>, or an arbitrary string surrounded by angle
   brackets, such as <literal>&lt;UTC-05&gt;</literal>.
   Note that the zone abbreviations given here are only used for output,
   and even then only in some timestamp output formats.  The zone
   abbreviations recognized in timestamp input are determined as explained
   in <xref linkend="datetime-config-files"/>.
  </para>
____________________________________________________________________________-->
  <para>
   在此语法中，区域缩写可以是字母字符串，如 <literal>EST</literal>，或者是被尖括号包围的任意字符串，如 <literal>&lt;UTC-05&gt;</literal>。
   请注意，此处给出的区域缩写仅用于输出，即使这样也仅用于某些时间戳输出格式。 
   时间戳输入中识别的区域缩写按照<xref linkend="datetime-config-files"/>解释的那样来确定。
  </para>

<!--==========================orignal english content==========================
  <para>
   The offset fields specify the hours, and optionally minutes and seconds,
   difference from UTC.  They have the format
   <replaceable>hh</replaceable><optional><literal>:</literal><replaceable>mm</replaceable><optional><literal>:</literal><replaceable>ss</replaceable></optional></optional>
   optionally with a leading sign (<literal>+</literal>
   or <literal>-</literal>).  The positive sign is used for
   zones <emphasis>west</emphasis> of Greenwich.  (Note that this is the
   opposite of the ISO-8601 sign convention used elsewhere in
   <productname>PostgreSQL</productname>.)  <replaceable>hh</replaceable>
   can have one or two digits; <replaceable>mm</replaceable>
   and <replaceable>ss</replaceable> (if used) must have two.
  </para>
____________________________________________________________________________-->
  <para>
   偏移字段指定为小时（可选为分钟和秒），与 UTC 的差异。  
   它们包括格式<replaceable>hh</replaceable><optional><literal>:</literal><replaceable>mm</replaceable><optional><literal>:</literal><replaceable>ss</replaceable></optional></optional>
   可选带有前导符号 (<literal>+</literal> 或 <literal>-</literal>).  
   正符号用于格林威治<emphasis>west</emphasis>区域。（请注意，这与在<productname>PostgreSQL</productname>中其他地方使用的ISO-8601符号约定相反。）
   <replaceable>hh</replaceable>可以有1或2位数字； <replaceable>mm</replaceable> 和 <replaceable>ss</replaceable> (如果使用)必须包含两位数字。
  </para>

<!--==========================orignal english content==========================
  <para>
   The daylight-savings transition <replaceable>rule</replaceable> has the
   format
<synopsis>
<replaceable>dstdate</replaceable> <optional> <literal>/</literal> <replaceable>dsttime</replaceable> </optional> <literal>,</literal> <replaceable>stddate</replaceable> <optional> <literal>/</literal> <replaceable>stdtime</replaceable> </optional>
</synopsis>
   (As before, spaces should not be included in practice.)
   The <replaceable>dstdate</replaceable>
   and <replaceable>dsttime</replaceable> fields define when daylight-savings
   time starts, while <replaceable>stddate</replaceable>
   and <replaceable>stdtime</replaceable> define when standard time
   starts.  (In some cases, notably in zones south of the equator, the
   former might be later in the year than the latter.)  The date fields
   have one of these formats:
   <variablelist>
    <varlistentry>
     <term><replaceable>n</replaceable></term>
     <listitem>
      <para>
       A plain integer denotes a day of the year, counting from zero to
       364, or to 365 in leap years.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>J</literal><replaceable>n</replaceable></term>
     <listitem>
      <para>
       In this form, <replaceable>n</replaceable> counts from 1 to 365,
       and February 29 is not counted even if it is present.  (Thus, a
       transition occurring on February 29 could not be specified this
       way.  However, days after February have the same numbers whether
       it's a leap year or not, so that this form is usually more useful
       than the plain-integer form for transitions on fixed dates.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>M</literal><replaceable>m</replaceable><literal>.</literal><replaceable>n</replaceable><literal>.</literal><replaceable>d</replaceable></term>
     <listitem>
      <para>
       This form specifies a transition that always happens during the same
       month and on the same day of the week.  <replaceable>m</replaceable>
       identifies the month, from 1 to 12.  <replaceable>n</replaceable>
       specifies the <replaceable>n</replaceable>'th occurrence of the
       weekday identified by <replaceable>d</replaceable>.
       <replaceable>n</replaceable> is a number between 1 and 4, or 5
       meaning the last occurrence of that weekday in the month (which
       could be the fourth or the fifth).  <replaceable>d</replaceable> is
       a number between 0 and 6, with 0 indicating Sunday.
       For example, <literal>M3.2.0</literal> means <quote>the second
       Sunday in March</quote>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   夏令时转换<replaceable>rule</replaceable>的格式为
<synopsis>
<replaceable>dstdate</replaceable> <optional> <literal>/</literal> <replaceable>dsttime</replaceable> </optional> <literal>,</literal> <replaceable>stddate</replaceable> <optional> <literal>/</literal> <replaceable>stdtime</replaceable> </optional>
</synopsis>
   (像前面一样，在实际使用中不应该包含空格.)
   在夏令时开始时定义<replaceable>dstdate</replaceable>和 <replaceable>dsttime</replaceable> 字段，
   在标准时间开始时定义<replaceable>stddate</replaceable>和 <replaceable>stdtime</replaceable> 定义。
   (在某些情况下，特别是在赤道以南地区，前者可能比后者在一年内更晚。)  日期字段具有如下格式之一:
   <variablelist>
    <varlistentry>
     <term><replaceable>n</replaceable></term>
     <listitem>
      <para>
       普通整数表示一年中的哪一天，从0到364，或者在闰年到365。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>J</literal><replaceable>n</replaceable></term>
     <listitem>
      <para>
       在这种格式下，<replaceable>n</replaceable>计数从1到365，即使2月29日存在，也不被计算。
       (因此，不能以这种方式指定发生在2月29日的转换。然而，无论是否是闰年，2月之后的天数都是相同的，所以对于固定日期的转换，这种形式通常比纯整数形式更有用。)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>M</literal><replaceable>m</replaceable><literal>.</literal><replaceable>n</replaceable><literal>.</literal><replaceable>d</replaceable></term>
     <listitem>
      <para>  
       此格式指定始终在同一月和一周的同一天发生的转换。 
       <replaceable>m</replaceable>表示月，从1到12。 
       <replaceable>n</replaceable>指定第<replaceable>n</replaceable>个按<replaceable>d</replaceable>标识的星期日期(weekday)。
       <replaceable>n</replaceable>为 1 和 4 之间的数字，或 5 表示该月中此星期日期(weekday)的最后一次出现（可能是第四或第五个）。
       <replaceable>d</replaceable>为 0 和 6 之间的数字，0 表示星期日。
       例如，<literal>M3.2.0</literal>意味着<quote>3月的第二个星期日</quote>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <literal>M</literal> format is sufficient to describe many common
    daylight-savings transition laws.  But note that none of these variants
    can deal with daylight-savings law changes, so in practice the
    historical data stored for named time zones (in the IANA time zone
    database) is necessary to interpret past time stamps correctly.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>M</literal>格式足以描述许多常见的夏令时转换定律。 
    但请注意，这些变体都无法处理夏令时法律的更改，因此在实践中，为命名时区（IANA 时区数据库中）存储的历史数据对于正确解释过去的时间戳是必要的。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The time fields in a transition rule have the same format as the offset
   fields described previously, except that they cannot contain signs.
   They define the current local time at which the change to the other
   time occurs.  If omitted, they default to <literal>02:00:00</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   转换规则中的时间字段的格式与前面描述的偏移字段相同，除了它们不能包含符号。
   它们定义对另一个时间发生更改的当前本地时间。如果省略，则默认为 <literal>02:00:00</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a daylight-savings abbreviation is given but the
   transition <replaceable>rule</replaceable> field is omitted,
   the fallback behavior is to use the
   rule <literal>M3.2.0,M11.1.0</literal>, which corresponds to USA
   practice as of 2020 (that is, spring forward on the second Sunday of
   March, fall back on the first Sunday of November, both transitions
   occurring at 2AM prevailing time).  Note that this rule does not
   give correct USA transition dates for years before 2007.
  </para>
____________________________________________________________________________-->
  <para>
   如果给定了夏令时缩写，但省略了转换<replaceable>rule</replaceable>字段，
   回退的行为是使用规则 <literal>M3.2.0,M11.1.0</literal>，这对应于美国截至 2020 年的做法。
   （也就是说， 春天在3 月的第二个星期日向前，秋天在11 月的第一个星期日向后， 两个转换都发生在凌晨 2 点）。
   请注意，此规则没有给出 2007 年之前的正确的美国转换日期。
  </para>

<!--==========================orignal english content==========================
  <para>
   As an example, <literal>CET-1CEST,M3.5.0,M10.5.0/3</literal> describes
   current (as of 2020) timekeeping practice in Paris.  This specification
   says that standard time has the abbreviation <literal>CET</literal> and
   is one hour ahead (east) of UTC; daylight savings time has the
   abbreviation <literal>CEST</literal> and is implicitly two hours ahead
   of UTC; daylight savings time begins on the last Sunday in March at 2AM
   CET and ends on the last Sunday in October at 3AM CEST.
  </para>
____________________________________________________________________________-->
  <para>
   例如，<literal>CET-1CEST,M3.5.0,M10.5.0/3</literal>描述了巴黎的当前（截至2020年）的计时做法。
   该规范说明标准时间缩写为 <literal>CET</literal>，并且比 UTC 的早(东)一小时;
   夏令时缩写为<literal>CEST</literal>，并且隐式比 UTC 早两个小时;
   夏令时从 CET 3 月的最后一个星期日开始，到CEST 10 月的最后一个星期日凌晨 3 点结束。
  </para>

<!--==========================orignal english content==========================
  <para>
   The four timezone names <literal>EST5EDT</literal>,
   <literal>CST6CDT</literal>, <literal>MST7MDT</literal>,
   and <literal>PST8PDT</literal> look like they are POSIX zone
   specifications.  However, they actually are treated as named time zones
   because (for historical reasons) there are files by those names in the
   IANA time zone database.  The practical implication of this is that
   these zone names will produce valid historical USA daylight-savings
   transitions, even when a plain POSIX specification would not.
  </para>
____________________________________________________________________________-->
  <para>
   四个时区名称 <literal>EST5EDT</literal>，<literal>CST6CDT</literal>、<literal>MST7MDT</literal>和<literal>PST8PDT</literal>看起来像是POSIX区域规范。
   但是，它们实际上被用来命名时区，因为（出于历史原因）IANA 时区数据库中存在这些名称的文件。 
   这样做的实际含义是，这些区域名称将产生有效的历史上的美国夏令时转换，即使普通POSIX规范不会产生。
  </para>

<!--==========================orignal english content==========================
  <para>
   One should be wary that it is easy to misspell a POSIX-style time zone
   specification, since there is no check on the reasonableness of the
   zone abbreviation(s).  For example, <literal>SET TIMEZONE TO
   FOOBAR0</literal> will work, leaving the system effectively using a
   rather peculiar abbreviation for UTC.
  </para>
____________________________________________________________________________-->
  <para>
   需要警惕的是很容易拼错 POSIX 样式的时区规范，因为没有检查区域缩写的合理性。
   例如，<literal>SET TIMEZONE TO FOOBAR0</literal>将工作，让系统有效地使用UTC的一个相当奇特的缩写。
  </para>

  </sect1>

  <sect1 id="datetime-units-history">
<!--==========================orignal english content==========================
  <title>History of Units</title>
____________________________________________________________________________-->
  <title>单位的历史</title>

<!--==========================orignal english content==========================
  <indexterm zone="datetime-units-history">
   <primary>Gregorian calendar</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datetime-units-history">
   <primary>格里高利历</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The SQL standard states that <quote>Within the definition of a
   <quote>datetime literal</quote>, the <quote>datetime
   values</quote> are constrained by the natural rules for dates and
   times according to the Gregorian calendar</quote>.
   <productname>PostgreSQL</productname> follows the SQL
   standard's lead by counting dates exclusively in the Gregorian
   calendar, even for years before that calendar was in use.
   This rule is known as the <firstterm>proleptic Gregorian calendar</firstterm>.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 标准说到<quote>在一个<quote>日期时间文字</quote>的定义中，<quote>日期时间值</quote>根据格里高利历被日期和时间的自然规则所约束</quote>。<productname>PostgreSQL</productname>遵循 SQL 标准，导致只在格里高利历内计算日期，即使对于该历法开始使用之前的日期也是如此。这个规则被称作<firstterm>外推格里高利历</firstterm>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The Julian calendar was introduced by Julius Caesar in 45 BC.
   It was in common use in the Western world
   until the year 1582, when countries started changing to the Gregorian
   calendar.  In the Julian calendar, the tropical year is
   approximated as 365 1/4 days = 365.25 days. This gives an error of
   about 1 day in 128 years.
  </para>
____________________________________________________________________________-->
  <para>
   儒略日期是由 Julius Caesar 在公元前 45 年引入的。直到 1582 年开始转为使用公历之前，西方世界一直使用儒略日期。 在儒略日期中，一回归年近似等于 365 又 1/4 天 = 365.25 天。它大约在128年中会出现 1 天的误差。
  </para>

<!--==========================orignal english content==========================
  <para>
   The accumulating calendar error prompted
   Pope Gregory XIII to reform the calendar in accordance with
   instructions from the Council of Trent.
   In the Gregorian calendar, the tropical year is approximated as
   365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300
   years for the tropical year to shift one day with respect to the
   Gregorian calendar.
  </para>
____________________________________________________________________________-->
  <para>
   不断积累的历法错误促使教皇格里高利十三世按照特伦托会议的指示改革了历法。在格里高利历中，一回归年近似为 365 + 97/400 天 = 365.2425 天。因此对于格里高利历，大约要 3300 年一回归年才会积累一天的误差。
  </para>

<!--==========================orignal english content==========================
  <para>
   The approximation 365+97/400 is achieved by having 97 leap years
   every 400 years, using the following rules:

   <simplelist>
    <member>
     Every year divisible by 4 is a leap year.
    </member>
    <member>
     However, every year divisible by 100 is not a leap year.
    </member>
    <member>
     However, every year divisible by 400 is a leap year after all.
    </member>
   </simplelist>

   So, 1700, 1800, 1900, 2100, and 2200 are not leap years. But 1600,
   2000, and 2400 are leap years.

   By contrast, in the older Julian calendar all years divisible by 4 are leap
   years.
  </para>
____________________________________________________________________________-->
  <para>
   近似值 365+97/400 是通过利用下面的规则，并规定每 400 年有 97 个闰年实现的：

   <simplelist>
    <member>
     每个可被 4 整除的年是一个闰年。
    </member>
    <member>
     不过，可被 100 整除的年不是闰年。
    </member>
    <member>
     但是，可以被 400 整除的年还是闰年。
    </member>
   </simplelist>

   因此，1700、1800、1900、2100 和 2200 都不是闰年。而 1600、2000、2400 是闰年。相比而言，旧式的儒略历法里面只有能被4整除的年是闰年。

   相反，在旧的儒略历法中所有能被 4 整除的年都是闰年。
  </para>

<!--==========================orignal english content==========================
  <para>
   The papal bull of February 1582 decreed that 10 days should be dropped
   from October 1582 so that 15 October should follow immediately after
   4 October.
   This was observed in Italy, Poland, Portugal, and Spain. Other Catholic
   countries followed shortly after, but Protestant countries were
   reluctant to change, and the Greek Orthodox countries didn't change
   until the start of the 20th century.

   The reform was observed by Great Britain and its dominions (including what
   is now the USA) in 1752.
   Thus 2 September 1752 was followed by 14 September 1752.

   This is why Unix systems that have the <command>cal</command> program
   produce the following:

<screen>
$ <userinput>cal 9 1752</userinput>
   September 1752
 S  M Tu  W Th  F  S
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
</screen>

   But, of course, this calendar is only valid for Great Britain and
   dominions, not other places.
   Since it would be difficult and confusing to try to track the actual
   calendars that were in use in various places at various times,
   <productname>PostgreSQL</productname> does not try, but rather follows the Gregorian
   calendar rules for all dates, even though this method is not historically
   accurate.
  </para>
____________________________________________________________________________-->
  <para>
   罗马教皇在 1582 年 2 月宣布从 1582 年的 10 月中减除 10 天，这样 10 月 15 日就紧跟在 10 月 4 日的后面。意大利、波兰、葡萄牙和西班牙遵守了这个要求。其他天主教的国家也紧跟它们的步伐。但新教国家拒绝改变，而希腊东正教国家却一直拖延到 20 世纪开始时才逐渐遵守这个规定。

   大英帝国及其殖民地（包含今天的美国）在 1752 年开始遵守这项改革。因此 1752 年 9 月 2 日之后紧跟着 14 日。

   这就是为什么 Unix 系统上的<command>cal</command>程序 会产生如下输出的原因：

<screen>
$ <userinput>cal 9 1752</userinput>
   September 1752
 S  M Tu  W Th  F  S
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
</screen>

   不过，这种历法只对大英帝国及其殖民地有效，对其他地方无效。因为尝试在多个地方多个时刻使用的实际历法很难并且也很让人困惑，<productname>PostgreSQL</productname>并没有做这种尝试，而是对所有日期遵循格里高利历规则，即使该方法在历史上是不精确的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Different calendars have been developed in various parts of the
   world, many predating the Gregorian system.

   For example,
   the beginnings of the Chinese calendar can be traced back to the 14th
   century BC. Legend has it that the Emperor Huangdi invented that
   calendar in 2637 BC.

   The People's Republic of China uses the Gregorian calendar
   for civil purposes. The Chinese calendar is used for determining
   festivals.
  </para>
____________________________________________________________________________-->
  <para>
   在世界的多个地方，发展了不同的历法，很多比格里高利系统还早。

   例如，中国历法的开端可以追溯到公元前 14 世纪。传说黄帝在公元前 2637 年就发明了这个历法。

   中华人民共和国把格里高利历作为民用。中国历法则被用于决定节日/节气。
  </para>

  </sect1>

<!--==========================orignal english content==========================
  <sect1 id="datetime-julian-dates">
  <title>Julian Dates</title>

  <indexterm zone="datetime-julian-dates">
   <primary>Julian date</primary>
  </indexterm>
____________________________________________________________________________-->
  <sect1 id="datetime-julian-dates">
  <title>儒略日期</title>

  <indexterm zone="datetime-julian-dates">
   <primary>儒略日期</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <firstterm>Julian Date</firstterm> system is a method for
   numbering days.  It is unrelated to the Julian calendar though it is confusingly
   named similarly to that calendar.
   The Julian Date system was invented by the French scholar
   Joseph Justus Scaliger (1540&ndash;1609)
   and probably takes its name from Scaliger's father,
   the Italian scholar Julius Caesar Scaliger (1484&ndash;1558).
  </para> 
____________________________________________________________________________-->
  <para>
   <firstterm>儒略日期</firstterm>系统是一种计算天数的方法。它虽然在命名上很相似，但是它和儒略历法无关。儒略日期系统是法国学者 Joseph Justus Scaliger(1540&ndash;1609)（可能是取自其父亲的名字，即意大利学者 Julius Caesar Scaliger(1484&ndash;1558)发明的。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the Julian Date system, each day has a sequential number, starting
   from JD 0 (which is sometimes called <emphasis>the</emphasis> Julian Date).
   JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or
   24 November 4714 BC in the Gregorian calendar.  Julian Date counting
   is most often used by astronomers for labeling their nightly observations,
   and therefore a date runs from noon UTC to the next noon UTC, rather than
   from midnight to midnight: JD 0 designates the 24 hours from noon UTC on
   24 November 4714 BC to noon UTC on 25 November 4714 BC.
  </para>
____________________________________________________________________________-->
  <para>
   在儒略日期系统中，每天都有一个序数，从 JD 0 开始（有时被叫做<emphasis>那个</emphasis>儒略日期）。 JD 0 在儒略历法中对应公元前 4713 年 1 月 1 日，或者在格里高利历中对应公元前 4714 年 12 月 24 日。儒略日期计数经常被天文学家用来标注夜间观测，并且因此一个日期就是从一个正午 UTC 到下一个正午 UTC，而不是从午夜到另一个午夜：JD 0 设计的 24 小时是从公元前 4714 年 12 月 24 日的正午 UTC 到公元前 4714 年 12 月 25 日的正午 UTC。
  </para>

<!--==========================orignal english content==========================
  <para>
   Although <productname>PostgreSQL</productname> supports Julian Date notation for
   input and output of dates (and also uses Julian dates for some internal
   datetime calculations), it does not observe the nicety of having dates
   run from noon to noon.  <productname>PostgreSQL</productname> treats a Julian Date as running from local midnight to local midnight, the same as a normal
   date.
  </para>
____________________________________________________________________________-->
  <para>
   尽管<productname>PostgreSQL</productname>在输入输出日期时支持儒略日期符号（并且也用在一些内部的日期时间计算上使用儒略日期），它不遵守从正午到正午。<productname>PostgreSQL</productname>把儒略日期当作是从当地午夜到当地午夜，如同一个普通日期。
  </para>

<!--==========================orignal english content==========================
  <para>
   This definition does, however, provide a way to obtain the astronomical
   definition when you need it: do the arithmetic in time
   zone <literal>UTC+12</literal>.  For example,
<programlisting>
=&gt; SELECT extract(julian from '2021-06-23 7:00:00-04'::timestamptz at time zone 'UTC+12');
           extract
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2459388.95833333333333333333
(1 row)
=&gt; SELECT extract(julian from '2021-06-23 8:00:00-04'::timestamptz at time zone 'UTC+12');
               extract
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2459389.0000000000000000000000000000
(1 row)
=&gt; SELECT extract(julian from date '2021-06-23');
 extract
-&minus;-&minus;-&minus;-&minus;-
 2459389
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   然而，这个定义确实提供了一种在需要时获得天文定义的方法：在时区<literal>UTC+12</literal>里运算。例如，
<programlisting>
=&gt; SELECT extract(julian from '2021-06-23 7:00:00-04'::timestamptz at time zone 'UTC+12');
           extract
------------------------------
 2459388.95833333333333333333
(1 row)
=&gt; SELECT extract(julian from '2021-06-23 8:00:00-04'::timestamptz at time zone 'UTC+12');
               extract
--------------------------------------
 2459389.0000000000000000000000000000
(1 row)
=&gt; SELECT extract(julian from date '2021-06-23');
 extract
---------
 2459389
(1 row)
</programlisting>
  </para>

 </sect1>
</appendix>
