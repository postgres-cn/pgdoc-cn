<!-- doc/src/sgml/installation.sgml -->
<!--

Use </link> not just </> so INSTALL.html can be created without links
to the main documentation.  Don't use <xref>; or if you must, wrap it
in a standalone-ignore clause.

-->

<chapter id="installation">
<!--
 <title><![%standalone-include[<productname>PostgreSQL</>]]>
  Installation from Source Code</title>
  -->
  <title><![%standalone-include[<productname>PostgreSQL</>]]>
  源码安装</title>

 <indexterm zone="installation">
  <primary>installation</primary>
 </indexterm>

 <!--
<para>
  This <![%standalone-include;[document]]>
  <![%standalone-ignore;[chapter]]> describes the installation of
  <productname>PostgreSQL</productname> using the source code
  distribution.  (If you are installing a pre-packaged distribution,
  such as an RPM or Debian package, ignore this
  <![%standalone-include;[document]]>
  <![%standalone-ignore;[chapter]]>
  and read the packager's instructions instead.)
 </para>
-->
<para>
   本<![%standalone-include;[document]]><![%standalone-ignore;[章]]>讲述了如何从源代码安装<productname>PostgreSQL</productname>。
   如果你安装的是预打包的版本，比如RPM或者Debian包，
   那么略过这一<![%standalone-include;[document]]><![%standalone-ignore;[章]]>并阅读打包的开发人员的指导。
</para>

 <sect1 id="install-short">
 <!--
  <title>Short Version</title>
  -->
   <title>简版</title>

 
<para>
<synopsis>
./configure
make
su
make install
adduser postgres
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;
/usr/local/pgsql/bin/createdb test
/usr/local/pgsql/bin/psql test
</synopsis>
   <!--
   The long version is the rest of this
   <![%standalone-include;[document.]]>
   <![%standalone-ignore;[chapter.]]>
   -->
   全版是本<![%standalone-include;[document.]]><![%standalone-ignore;[章]]>剩余的部分。
  </para>

 </sect1>


 <sect1 id="install-requirements">
 <!--
  <title>Requirements</title>
  -->
   <title>要求</title>

  <!--
<para>
   In general, a modern Unix-compatible platform should be able to run
   <productname>PostgreSQL</>.
   The platforms that had received specific testing at the
   time of release are listed in <xref linkend="supported-platforms">
   below. In the <filename>doc</> subdirectory of the distribution
   there are several platform-specific <acronym>FAQ</> documents you
   might wish to consult if you are having trouble.
  </para>
-->
<para>
一般说来，一个现代的与 Unix 兼容的平台应该就能运行<productname>PostgreSQL</>。
<xref linkend="supported-platforms">列出了到发布为止已经明确测试过的平台。
在发布的<filename>doc</>子目录里面有许多平台相关的<acronym>FAQ</>，
如果你碰到问题你可能会需要参考它们。
</para>


<para>
  <!--
   The following software packages are required for building
   <productname>PostgreSQL</>:
   -->

   编译<productname>PostgreSQL</>需要下面的软件包：


   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary>make</primary>
      </indexterm>
       <!--
      <acronym>GNU</> <application>make</> version 3.80 or newer is required; other
      <application>make</> programs or older <acronym>GNU</> <application>make</> versions will <emphasis>not</> work.
      (<acronym>GNU</> <application>make</> is sometimes installed under
      the name <filename>gmake</filename>.)  To test for <acronym>GNU</acronym>
      <application>make</application> enter:
  -->
  需要<acronym>GNU</> <application>make</>的3.80版本或者更新版本；
  <emphasis>不能</>使用其它<application>make</> 程序或者老版本的<acronym>GNU</><application>make</>。
  <acronym>GNU</> <application>make</>有时被安装为<filename>gmake</filename>的名字。
  要想测试<acronym>GNU</acronym><application>make</application>，敲入：
  
<screen>
<userinput>make --version</userinput>
</screen>
     </para>

    </listitem>

    <listitem>
     <!--
<para>
      You need an <acronym>ISO</>/<acronym>ANSI</> C compiler (at least
      C89-compliant). Recent
      versions of <productname>GCC</> are recommended, but
      <productname>PostgreSQL</> is known to build using a wide variety
      of compilers from different vendors.
     </para>
-->
<para>
    你需要一个<acronym>ISO</>/<acronym>ANSI</> C编译器（至少C89-标准）。
我们推荐使用最近版本的<productname>GCC</>。不过，
众所周知的是<productname>PostgreSQL</>可以利用许多不同厂商的不同编译器进行编译。
</para>
    </listitem>

    <listitem>
     
<para>
     <!--
      <application>tar</> is required to unpack the source
      distribution, in addition to either
      <application>gzip</> or <application>bzip2</>.
  -->
  除了<application>gzip</>或者<application>bzip2</>之外，还需要<application>tar</>来解开发布。
     </para>
    </listitem>

    <listitem>
  
<para>
      <indexterm>
       <primary>readline</primary>
      </indexterm>
      <indexterm>
       <primary>libedit</primary>
      </indexterm>
  <!--

      The <acronym>GNU</> <productname>Readline</> library is used by
      default.  It allows <application>psql</application> (the
      PostgreSQL command line SQL interpreter) to remember each
      command you type, and allows you to use arrow keys to recall and
      edit previous commands.  This is very helpful and is strongly
      recommended.  If you don't want to use it then you must specify
      the <option>&#045;-without-readline</option> option to
      <filename>configure</>. As an alternative, you can often use the
      BSD-licensed <filename>libedit</filename> library, originally
      developed on <productname>NetBSD</productname>. The
      <filename>libedit</filename> library is
      GNU <productname>Readline</productname>-compatible and is used if
      <filename>libreadline</filename> is not found, or if
      <option>&#045;-with-libedit-preferred</option> is used as an
      option to <filename>configure</>. If you are using a package-based
      Linux distribution, be aware that you need both the
      <literal>readline</> and <literal>readline-devel</> packages, if
      those are separate in your distribution.
  -->
  缺省时将自动使用<acronym>GNU</> <productname>Readline</>库
  它允许<application>psql</application>（PostgreSQL命令行SQL解释器）记住每个键入的命令，
      并允许你使用箭头键来调用和编辑以前的命令。这是非常有帮助的，强烈推荐。
  如果你不想用它，那么你必需给<filename>configure</>声明<option>&#045;-without-readline</option>选项。  
  作为替代，你可以经常使用BSD许可的<filename>libedit</filename>库，最初 
      在<productname>NetBSD</productname>上开发的。
  如果没有发现<filename>libreadline</filename>，或者如果为<filename>configure</>指定<option>&#045;-with-libedit-preferred</option>，
  可以使用与GNU <productname>Readline</productname>兼容的<filename>libedit</filename>库。  
  如果你使用的是一个基于包的 Linux 发布，那么要注意你需要<literal>readline</>和<literal>readline-devel</>两个包，
  特别是如果这两个包在你的版本里是分开的时候。
     </para>

    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary>zlib</primary>
      </indexterm>
     <!--
      The <productname>zlib</productname> compression library is
      used by default. If you don't want to use it then you must
      specify the <option>&#045;-without-zlib</option> option to
      <filename>configure</filename>. Using this option disables
      support for compressed archives in <application>pg_dump</> and
      <application>pg_restore</>.
  -->
  缺省的时候将使用<productname>zlib</productname>压缩库。如果你不想使用它，
  那么你必须给<filename>configure</filename>声明<option>&#045;-without-zlib</option>选项。
  使用这个选项关闭了在<application>pg_dump</>和
      <application>pg_restore</>里面压缩归档的支持。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  
<para>
  <!--
   The following packages are optional.  They are not required in the
   default configuration, but they are needed when certain build
   options are enabled, as explained below:
   -->
   
   下列包是可选的。在缺省配置的时候并不要求它们，
   但是如果打开了一些编译选项之后就需要它们了，如下面解释的:

   <itemizedlist>
    <listitem>
     <para>
  <!--
      To build the server programming language
      <application>PL/Perl</application> you need a full
      <productname>Perl</productname> installation, including the
      <filename>libperl</filename> library and the header files.
      Since <application>PL/Perl</application> will be a shared
      library, the <indexterm><primary>libperl</primary></indexterm>
      <filename>libperl</filename> library must be a shared library
      also on most platforms.  This appears to be the default in
      recent <productname>Perl</productname> versions, but it was not
      in earlier versions, and in any case it is the choice of whomever
      installed Perl at your site.
      If you intend to make more than incidental use of
      <application>PL/Perl</application>, you should ensure that the
      <productname>Perl</productname> installation was built with the
      <literal>usemultiplicity</> option enabled (<literal>perl -V</>
      will show whether this is the case).
  -->  
  要编译<application>PL/Perl</application>服务器端编程语言，你需要一个完整的<productname>Perl</productname>安装，
  包括<filename>libperl</filename>库和头文件。因为<application>PL/Perl</application>是一个共享库，
  <indexterm><primary>libperl</primary></indexterm>
      <filename>libperl</filename>库在大多数平台上也必须是一个共享库。
  最新版本的<productname>Perl</productname>好像已经是缺省这么做了，但是早先的版本可不是这样的，
  而且在任何安装了Perl的地方总是可选的。 
  如果你打算不是偶尔使用<application>PL/Perl</application>的话，
  你应确保编译带有<literal>usemultiplicity</>启用选项的<productname>Perl</productname>安装
  （<literal>perl -V</>将显示是否是这种情况）。  
     </para>

     
<para>
      <!--
      If you don't have the shared library but you need one, a message
      like this will appear during the <productname>PostgreSQL</>
      build to point out this fact:
  -->
  
  如果没有共享库，但却需要它，那么在<productname>PostgreSQL</>编译过程中将看到下面的信息，指出这个问题：


<screen>
*** Cannot build PL/Perl because libperl is not a shared library.
*** You might have to rebuild your Perl installation.  Refer to
*** the documentation for details.
</screen>
    
 <!--
      (If you don't follow the on-screen output you will merely notice
      that the <application>PL/Perl</application> library object,
      <filename>plperl.so</filename> or similar, will not be
      installed.)  If you see this, you will have to rebuild and
      install <productname>Perl</productname> manually to be able to
      build <application>PL/Perl</application>.  During the
      configuration process for <productname>Perl</productname>,
      request a shared library.
  -->
  如果你不按照屏幕输出的指示去做，那么你只会注意到<application>PL/Perl</application>库对象<filename>plperl.so</filename>或者类似的什么东西，
  不会安装到系统里。如果你看到这些东西，那么你就必须重新手工编译并安装<productname>Perl</productname>，
  这样才能编译<application>PL/Perl</application>。在配置<productname>Perl</productname>的过程中，要求一个共享库。
     </para>

    </listitem>

    <listitem>
     <!--
<para>
      To build the <application>PL/Python</> server programming
      language, you need a <productname>Python</productname>
      installation with the header files and
      the <application>distutils</application> module.  The minimum
      required version is <productname>Python</productname> 2.3.
      (To work with function arguments of type <type>numeric</>, a 2.3.x
      installation must include the separately-available <filename>cdecimal</>
      module; note the <application>PL/Python</> regression tests
      will not pass if that is missing.)
      <productname>Python 3</productname> is supported if it's
      version 3.1 or later; but see
      <![%standalone-include[the <application>PL/Python</> documentation]]>
      <![%standalone-ignore[<xref linkend="plpython-python23">]]>
      when using Python 3.
     </para>
-->
<para>
     要编译<application>PL/Python</>服务器端编程语言，你需要一个<productname>Python</productname>的安装，
 包括头文件和<application>distutils</application>模块。
 最小所需版本是<productname>Python</productname>2.3。
 （要与类型<type>numeric</>的函数参数一起工作，2.3.X的安装必须包括单独可用的
 <filename>cdecimal</>模块；请注意，如果缺少这个，<application>PL/Python</>
 的回归测试将不会通过。）
 如果版本是3.1或者更高版本，则支持<productname>Python 3</productname>；但是当使用Python 3的时候，
 则参阅<![%standalone-include[the <application>PL/Python</> documentation]]>
     <![%standalone-ignore[<xref linkend="plpython-python23">]]>。
</para>

     
<para>
      <!--
      Since <application>PL/Python</application> will be a shared
      library, the <indexterm><primary>libpython</primary></indexterm>
      <filename>libpython</filename> library must be a shared library
      also on most platforms.  This is not the case in a default
      <productname>Python</productname> installation.  If after
      building and installing <productname>PostgreSQL</> you have a file called
      <filename>plpython.so</filename> (possibly a different
      extension), then everything went well.  Otherwise you should
      have seen a notice like this flying by:
  -->  
  因为<application>PL/Python</application>将以共享库的方式编译，
  <indexterm><primary>libpython</primary></indexterm>
      <filename>libpython</filename>库在大多数平台上也必须是一个共享库。
  在缺省的<productname>Python</productname>安装时不是这样的。如果在编译和安装<productname>PostgreSQL</>之后，
  你有一个叫做<filename>plpython.so</filename>的文件(可能扩展名会有所不同)，那么一切都好说，
  否则你应该会看到类似下面的信息飘过:
  
<screen>
*** Cannot build PL/Python because libpython is not a shared library.
*** You might have to rebuild your Python installation.  Refer to
*** the documentation for details.
</screen>
      <!--
      That means you have to rebuild (part of) your
      <productname>Python</productname> installation to create this
      shared library.
  -->
  这意味着你必须重新编译(一部分)<productname>Python</productname>安装，以创建这个共享库。
     </para>


     <!--
<para>
      If you have problems, run <productname>Python</> 2.3 or later's
      configure using the <literal>&#045;-enable-shared</> flag.  On some
      operating systems you don't have to build a shared library, but
      you will have to convince the <productname>PostgreSQL</> build
      system of this.  Consult the <filename>Makefile</filename> in
      the <filename>src/pl/plpython</filename> directory for details.
     </para>
-->
<para>
     如果有问题，用<literal>&#045;-enable-shared</>标志运行<productname>Python</> 2.3或更高版本的configure 脚本。
 在有些操作系统上，你不必非要编译一个共享库，不过你需要让<productname>PostgreSQL</>的编译系统知道这些。
 参考<filename>src/pl/plpython</filename>目录中的<filename>Makefile</filename>获取细节。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      To build the <application>PL/Tcl</application>
      procedural language, you of course need a <productname>Tcl</>
      installation.  If you are using a pre-8.4 release of
      <productname>Tcl</>, ensure that it was built without multithreading
      support.
     </para>
-->
<para>
     如果想编译<application>PL/Tcl</application>过程语言，那么当然需要安装<productname>Tcl</>了。
 如果你使用<productname>Tcl</>先前的8.4版本，应该确保它编译时没有多线程支持。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      To enable Native Language Support (<acronym>NLS</acronym>), that
      is, the ability to display a program's messages in a language
      other than English, you need an implementation of the
      <application>Gettext</> <acronym>API</acronym>.  Some operating
      systems have this built-in (e.g., <systemitem
      class="osname">Linux</>, <systemitem class="osname">NetBSD</>,
      <systemitem class="osname">Solaris</>), for other systems you
      can download an add-on package from <ulink
      url="http://www.gnu.org/software/gettext/"></ulink>.
      If you are using the <application>Gettext</> implementation in
      the <acronym>GNU</acronym> C library then you will additionally
      need the <productname>GNU Gettext</productname> package for some
      utility programs.  For any of the other implementations you will
      not need it.
     </para>
-->
<para>
    要打开本地语言支持(<acronym>NLS</acronym>)，也就是说，用英语之外的语言显示程序的信息，
你需要一个<application>Gettext</> <acronym>API</acronym>的实现。
有些操作系统内置了这些(比如<systemitem
      class="osname">Linux</>, <systemitem class="osname">NetBSD</>,
      <systemitem class="osname">Solaris</>)，
对于其它系统，你可以从 <ulink url="http://www.gnu.org/software/gettext/"></ulink>下载一个额外的包。
如果你在<acronym>GNU</acronym> C库里面使用<application>Gettext</>实现，
那么你就额外需要<productname>GNU Gettext</productname>包，
因为我们需要里面的几个工具程序。对于任何其它的实现，你应该不需要它。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      You need <application>Kerberos</>, <productname>OpenSSL</>,
      <productname>OpenLDAP</>, and/or
      <application>PAM</>, if you want to support authentication or
      encryption using those services.
     </para>
-->
<para>
     <application>Kerberos</>, <productname>OpenSSL</>,
     <productname>OpenLDAP</>,和/或者<application>PAM</>，
 如果你想支持使用这些服务的认证或者加密，那你需要这些包。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      To build the <productname>PostgreSQL</productname> documentation,
      there is a separate set of requirements; see
      <![%standalone-ignore;[<xref linkend="docguide-toolsets">.]]>
      <![%standalone-include;[the main documentation's appendix on
      documentation.]]>
     </para>
-->
<para>
     为了编译<productname>PostgreSQL</productname>文档，有一套独立要求；参阅
  <![%standalone-ignore;[<xref linkend="docguide-toolsets">.]]>
      <![%standalone-include;[主文档附录.]]>
</para>
    </listitem>
   </itemizedlist>
  </para>

  
<para>
   <!--
   If you are building from a <productname>Git</productname> tree instead of
   using a released source package, or if you want to do server development,
   you also need the following packages:
    -->
如果你从<productname>Git</productname>树中编译，而不是使用发布的源代码包，
或者你想做一些服务器端的开发，
那么你还需要下面的包：

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary>flex</primary>
      </indexterm>
      <indexterm>
       <primary>lex</primary>
      </indexterm>
      <indexterm>
       <primary>bison</primary>
      </indexterm>
      <indexterm>
       <primary>yacc</primary>
      </indexterm>
     <!--
      GNU <application>Flex</> and <application>Bison</>
      are needed to build from a Git checkout, or if you changed the actual
      scanner and parser definition files. If you need them, be sure
      to get <application>Flex</> 2.5.31 or later and
      <application>Bison</> 1.875 or later. Other <application>lex</>
      and <application>yacc</> programs cannot be used.
  -->
  如果你需要从Git检出中编译，或者你修改了扫描器和分析器的定义文件，
  那么你需要<application>Flex</>和<application>Bison</>。如果你需要它们，
  那么确保自己拿到的是<application>Flex</> 2.5.31或更新的版本，以及<application>Bison</> 1.875或者更新的版本。
  其它的<application>lex</>和<application>yacc</>程序肯定是不行的。
  
     </para>
    </listitem>
    <listitem>
     
<para>
      
      <indexterm>
       <primary>perl</primary>
      </indexterm>
      <!--
      <application>Perl</> 5.8 or later is needed to build from a Git checkout,
      or if you changed the input files for any of the build steps that
      use Perl scripts.  If building on Windows you will need
      <application>Perl</> in any case.  <application>Perl</application> is
      also required to run some test suites.
  -->
  如果需要从Git检出中编译或者如果需要改变使用Perl脚本的任何编译步骤的输入文件，那么
  需要<application>Perl</> 5.8或者更新版本。如果在Windows上编译，那么你在任何情况下都需要
     <application>Perl</>。要运行某些测试套件，也需要<application>Perl</application>。
 
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <!--
<para>
   If you need to get a <acronym>GNU</acronym> package, you can find
   it at your local <acronym>GNU</acronym> mirror site (see <ulink
   url="http://www.gnu.org/order/ftp.html"></>
   for a list) or at <ulink
   url="ftp://ftp.gnu.org/gnu/"></ulink>.
  </para>
-->
<para>
  如果你需要获取<acronym>GNU</acronym>包，你可以在<acronym>GNU</acronym>镜像站点
  <ulink url="http://www.gnu.org/order/ftp.html"></>或者<ulink url="ftp://ftp.gnu.org/gnu/"></ulink>
  找到它们。
</para>

  <!--
<para>
   Also check that you have sufficient disk space. You will need about
   100 MB for the source tree during compilation and about 20 MB for
   the installation directory. An empty database cluster takes about
   35 MB; databases take about five times the amount of space that a
   flat text file with the same data would take. If you are going to
   run the regression tests you will temporarily need up to an extra
   150 MB. Use the <command>df</command> command to check free disk
   space.
  </para>
-->
<para>
   请检查一下，看看你是否有足够的磁盘空间。
   你将大概需要近100MB 用于存放安装过程中的源码树和大约20MB用于安装目录。
   一个空数据库大概需要35MB。
   在存放相同的数据时，数据库大概需要文本文件五倍的存储空间。
   如果你要运行回归测试，还临时需要额外的150MB 。
   请用<command>df</command>命令检查剩余磁盘空间。
</para>
 </sect1>

<![%standalone-ignore;[
 <sect1 id="install-getsource">
  <!--
  <title>Getting The Source</title>
  -->
  <title>获取源码</title>
  
<para>
   <!--
   The <productname>PostgreSQL</> &version; sources can be obtained from the
   download section of our
   website: <ulink url="http://www.postgresql.org/download/"></ulink>.  You
   should get a file named <filename>postgresql-&version;.tar.gz</filename>
   or <filename>postgresql-&version;.tar.bz2</filename>. After
   you have obtained the file, unpack it:
   -->
   <productname>PostgreSQL</> &version，源码可以从我们的网站: <ulink url="http://www.postgresql.org/download/"></ulink>
   进行下载。你可以获得文件命名 <filename>postgresql-&version;.tar.gz</filename>
   或者<filename>postgresql-&version;.tar.bz2</filename>。在你获取文件之后，解压缩：
<screen>
<userinput>gunzip postgresql-&version;.tar.gz</userinput>
<userinput>tar xf postgresql-&version;.tar</userinput>
</screen>
  <!--
   (Use <command>bunzip2</command> instead of <command>gunzip</command> if you
   have the <filename>.bz2</filename> file.)
   This will create a directory
   <filename>postgresql-&version;</filename> under the current directory
   with the <productname>PostgreSQL</> sources.
   Change into that directory for the rest
   of the installation procedure.
   -->
   如果你有<filename>.bz2</filename>文件，可以使用<command>bunzip2</command>代替<command>gunzip</command>。
   这样将在当前目录创建一个目录<filename>postgresql-&version;</filename>，
   里面是<productname>PostgreSQL</>源代码。进入这个目录完成安装过程的其它步骤。
  </para>

  <!--
<para>
   You can also get the source directly from the version control repository, see
   <xref linkend="sourcerepo">.
  </para>
-->
<para>
   你也可以直接从版本控制库中获取源码，参阅<xref linkend="sourcerepo">。
</para>
 </sect1>
]]>

 <sect1 id="install-procedure">
  <!--
  <title>Installation Procedure</title>
  -->
  <title>安装过程</title>
  <procedure>

  <step id="configure">
  <!--
   <title>Configuration</title>
   -->
   <title>配置</title>

   <indexterm zone="configure">
    <primary>configure</primary>
   </indexterm>

   
<para>
    <!--
    The first step of the installation procedure is to configure the
    source tree for your system and choose the options you would like.
    This is done by running the <filename>configure</> script. For a
    default installation simply enter:
-->
安装过程的第一步就是配置源代码树并选择你喜欢的选项。这个工作是通过运行<filename>configure</>脚本实现的，
对于缺省安装，你只需要简单地敲入:

<screen>
<userinput>./configure</userinput>
</screen>
    <!--
    This script will run a number of tests to determine values for various
    system dependent variables and detect any quirks of your
    operating system, and finally will create several files in the
    build tree to record what it found.  You can also run
    <filename>configure</filename> in a directory outside the source
    tree, if you want to keep the build directory separate.  This
    procedure is also called a
    <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>
    build.  Here's how:
-->
该脚本将运行一些测试来决定一些系统相关的变量，并检测操作系统的设置，
最后将在编译树中创建一些文件以记录它找到了什么。
如果你想保持编译目录的独立，
那么你也可以在源代码树之外的其它目录里运行<filename>configure</filename>。
这个过程也被称为<indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>
编译。这里是方法：
<screen>
<userinput>mkdir build_dir</userinput>
<userinput>cd build_dir</userinput>
<userinput>/path/to/source/tree/configure [options go here]</userinput>
<userinput>make</userinput>
</screen>
   </para>


   <!--
<para>
    The default configuration will build the server and utilities, as
    well as all client applications and interfaces that require only a
    C compiler. All files will be installed under
    <filename>/usr/local/pgsql</> by default.
   </para>
-->
<para>
    缺省设置将编译服务器和应用程序，还有所有只需要C编译器的客户端程序和接口。
缺省时所有文件都将安装到<filename>/usr/local/pgsql</>目录。
</para>

   
<para>
    <!--
    You can customize the build and installation process by supplying one
    or more of the following command line options to
    <filename>configure</filename>:
    -->
你可以通过给出下面的一个或多个<filename>configure</filename>命令
行选项来自定义编译和安装过程：


     <variablelist>
      <varlistentry>
       <term><option>--prefix=<replaceable>PREFIX</></option></term>
       <listitem>
        <para>
 <!--
         Install all files under the directory <replaceable>PREFIX</>
         instead of <filename>/usr/local/pgsql</filename>. The actual
         files will be installed into various subdirectories; no files
         will ever be installed directly into the
         <replaceable>PREFIX</> directory.
 -->
 把所有文件安装到<replaceable>PREFIX</>目录下而不是<filename>/usr/local/pgsql</filename>里。
 实际的文件会安装到不同的子目录里；
 甚至没有一个文件会直接安装到<replaceable>PREFIX</>目录里。
        </para>
        <!--
<para>
         If you have special needs, you can also customize the
         individual subdirectories with the following options. However,
         if you leave these with their defaults, the installation will be
         relocatable, meaning you can move the directory after
         installation. (The <literal>man</> and <literal>doc</>
         locations are not affected by this.)
        </para>
-->
<para>
      如果你有特殊需要，你还可以用下面的选项自定义不同子目录的位置。
  不过，即使你保持缺省设置，安装也是可以再定位的，意味着在安装之后可以移动目录(<literal>man</>和<literal>doc</>的位置不受影响)。
</para>

        <!--
<para>
         For relocatable installs, you might want to use
         <filename>configure</filename>'s <literal>&#045;-disable-rpath</>
         option.  Also, you will need to tell the operating system how
         to find the shared libraries.
        </para>
-->
<para>
      为了可以再定位安装，你可能需要使用<filename>configure</filename>的<literal>&#045;-disable-rpath</>选项。
  还有，你需要告诉操作系统如何找到共享库。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--exec-prefix=<replaceable>EXEC-PREFIX</></option></term>
       <listitem>
        <!--
<para>
         You can install architecture-dependent files under a
         different prefix, <replaceable>EXEC-PREFIX</>, than what
         <replaceable>PREFIX</> was set to. This can be useful to
         share architecture-independent files between hosts. If you
         omit this, then <replaceable>EXEC-PREFIX</> is set equal to
         <replaceable>PREFIX</> and both architecture-dependent and
         independent files will be installed under the same tree,
         which is probably what you want.
        </para>
-->
<para>
     把系统结构相关的文件安装到<replaceable>EXEC-PREFIX</>，
 而不是<replaceable>PREFIX</>设置的地方。
 这样做可以比较方便地在不同主机之间共享系统结构相关的文件。如果你省略它，
 那么<replaceable>EXEC-PREFIX</>就会被设置为等于<replaceable>PREFIX</>并且不论与系统结构相关与否的文件
 都会被安装到同一目录树下，这也可能是你想要的。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--bindir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Specifies the directory for executable programs. The default
         is <filename><replaceable>EXEC-PREFIX</>/bin</>, which
         normally means <filename>/usr/local/pgsql/bin</>.
        </para>
-->
<para>
       声明可执行程序的目录，缺省是<filename><replaceable>EXEC-PREFIX</>/bin</>，
   通常也就是<filename>/usr/local/pgsql/bin</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--sysconfdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the directory for various configuration files,
         <filename><replaceable>PREFIX</>/etc</> by default.
        </para>
-->
<para>
      设置各种配置文件的目录。缺省是<filename><replaceable>PREFIX</>/etc</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--libdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the location to install libraries and dynamically loadable
         modules. The default is
         <filename><replaceable>EXEC-PREFIX</>/lib</>.
        </para>
-->
<para>
       设置库文件和可动态装载模块的目录。缺省是<filename><replaceable>EXEC-PREFIX</>/lib</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--includedir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the directory for installing C and C++ header files. The
         default is <filename><replaceable>PREFIX</>/include</>.
        </para>
-->
<para>
         设置C和C++头文件的目录。缺省是<filename><replaceable>PREFIX</>/include</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--datarootdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the root directory for various types of read-only data
         files.  This only sets the default for some of the following
         options.  The default is
         <filename><replaceable>PREFIX</>/share</>.
        </para>
-->
<para>
       设置各种类型只读数据文件的根目录。这只设置了一些下面的缺省选项。缺省是
   <filename><replaceable>PREFIX</>/share</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--datadir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the directory for read-only data files used by the
         installed programs. The default is
         <filename><replaceable>DATAROOTDIR</></>. Note that this has
         nothing to do with where your database files will be placed.
        </para>
-->
<para>
       设置使用安装程序的只读数据文件的目录，缺省是<filename><replaceable>DATAROOTDIR</></>。
   请注意这与你的数据库文件放在哪里无关。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--localedir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the directory for installing locale data, in particular
         message translation catalog files.  The default is
         <filename><replaceable>DATAROOTDIR</>/locale</>.
        </para>
-->
<para>
       设置安装区域数据的目录，特别是消息转变目录文件。缺省是
   <filename><replaceable>DATAROOTDIR</>/locale</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--mandir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         The man pages that come with <productname>PostgreSQL</> will be installed under
         this directory, in their respective
         <filename>man<replaceable>x</></> subdirectories.
         The default is <filename><replaceable>DATAROOTDIR</>/man</>.
        </para>
-->
<para>
       随着<productname>PostgreSQL</>一起的手册页将安装到这个目录的<filename>man<replaceable>x</></>子目录里。
   缺省是<filename><replaceable>DATAROOTDIR</>/man</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--docdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         Sets the root directory for installing documentation files,
         except <quote>man</> pages.  This only sets the default for
         the following options.  The default value for this option is
         <filename><replaceable>DATAROOTDIR</>/doc/postgresql</>.
        </para>
-->
<para>
      设置除<quote>man</>以外的文档文件的根目录。这只设置下面选项的缺省，
  这个选项的缺省值是<filename><replaceable>DATAROOTDIR</>/doc/postgresql</>。 
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--htmldir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <!--
<para>
         The HTML-formatted documentation for
         <productname>PostgreSQL</productname> will be installed under
         this directory.  The default is
         <filename><replaceable>DATAROOTDIR</></>.
        </para>
-->
<para>
       <productname>PostgreSQL</productname>的HTML-格式文档将安装在这个目录。
   缺省是<filename><replaceable>DATAROOTDIR</></>。
</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
      <!--
<para>
       Care has been taken to make it possible to install
       <productname>PostgreSQL</> into shared installation locations
       (such as <filename>/usr/local/include</filename>) without
       interfering with the namespace of the rest of the system. First,
       the string <quote><literal>/postgresql</literal></quote> is
       automatically appended to <varname>datadir</varname>,
       <varname>sysconfdir</varname>, and <varname>docdir</varname>,
       unless the fully expanded directory name already contains the
       string <quote><literal>postgres</></quote> or
       <quote><literal>pgsql</></quote>. For example, if you choose
       <filename>/usr/local</filename> as prefix, the documentation will
       be installed in <filename>/usr/local/doc/postgresql</filename>,
       but if the prefix is <filename>/opt/postgres</filename>, then it
       will be in <filename>/opt/postgres/doc</filename>. The public C
       header files of the client interfaces are installed into
       <varname>includedir</varname> and are namespace-clean. The
       internal header files and the server header files are installed
       into private directories under <varname>includedir</varname>. See
       the documentation of each interface for information about how to
       access its header files. Finally, a private subdirectory will
       also be created, if appropriate, under <varname>libdir</varname>
       for dynamically loadable modules.
      </para>
-->
<para>
      为了让<productname>PostgreSQL</>能够安装在一些共享的安装位置(比如<filename>/usr/local/include</filename>)，
  同时又不至于和系统其它部分产生名字空间干扰，我们采取了一些措施。
  首先，安装脚本会自动给<varname>datadir</varname>,
       <varname>sysconfdir</varname>和<varname>docdir</varname>后面附加上<quote><literal>/postgresql</literal></quote>字符串，
  除非展开的完整路径名已经包含字符串<quote><literal>postgres</></quote>或者
       <quote><literal>pgsql</></quote>。
  比如，如果你选择<filename>/usr/local</filename>作为prefix，
  那么文档将安装在<filename>/usr/local/doc/postgresql</filename>，
  但如果prefix是<filename>/opt/postgres</filename>，那么它将被放到<filename>/opt/postgres/doc</filename>。
  客户端接口的公共C头文件安装到了<varname>includedir</varname>，并且是名字空间无关的。
  内部的头文件和服务器端的头文件都安装到<varname>includedir</varname>下的私有目录中去了。
  参考每种接口的文档获取关于如何访问头文件的信息。最后，如果合适，
  那么也会在<varname>libdir</varname>下创建一个私有的子目录，用于安装动态装载模块。
</para>
     </note>
    </para>

    
<para>
     <variablelist>
      <varlistentry>
       <term><option>--with-extra-version=<replaceable>STRING</></option></term>
       <listitem>
<!-- 
        <para>
         Append <replaceable>STRING</> to the PostgreSQL version number.  You
         can use this, for example, to mark binaries built from unreleased Git
         snapshots or containing custom patches with an extra version string
         such as a <command>git describe</command> identifier or a
         distribution package release number.
        </para> 
-->
        <para>
         附加<replaceable>STRING</>到PostgreSQL版本号。你可以使用这个，例如，
         让来自未发布的Git快照或包含自定义补丁的二进制建立带有一个额外的版本字符串，
         比如一个<command>git describe</command>标识符或一个发布包版本号。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-includes=<replaceable>DIRECTORIES</></option></term>
       <listitem>
        <para>
<!--
         <replaceable>DIRECTORIES</> is a colon-separated list of
         directories that will be added to the list the compiler
         searches for header files. If you have optional packages
         (such as GNU <application>Readline</>) installed in a non-standard
         location,
         you have to use this option and probably also the corresponding
         <option>&#045;-with-libraries</> option.
 -->
 <replaceable>DIRECTORIES</>是一系列冒号分隔的目录，
 这些目录将被加入编译器的头文件搜索列表中。
 如果你有一些可选的包(比如GNU <application>Readline</>)安装在非标准位置，
 你就必须使用这个选项，
 以及可能还有相应的<option>--with-libraries</>选项。
        </para>
        <!--
<para>
         Example: <literal>&#045;-with-includes=/opt/gnu/include:/usr/sup/include</>.
        </para>
-->
<para>
        例子： <literal>--with-includes=/opt/gnu/include:/usr/sup/include</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libraries=<replaceable>DIRECTORIES</></option></term>
       <listitem>
        <!--
<para>
         <replaceable>DIRECTORIES</> is a colon-separated list of
         directories to search for libraries. You will probably have
         to use this option (and the corresponding
         <option>&#045;-with-includes</> option) if you have packages
         installed in non-standard locations.
        </para>
-->
<para>
       <replaceable>DIRECTORIES</>是一系列冒号分隔的目录，这些目录是用于查找库文件的。
   如果你有一些包安装在非标准位置，
   你可能就需要使用这个选项(以及对应的<option>--with-includes</>选项)。
</para>
        <!--
<para>
         Example: <literal>&#045;-with-libraries=/opt/gnu/lib:/usr/sup/lib</>.
        </para>
-->
<para>
        例子：<literal>--with-libraries=/opt/gnu/lib:/usr/sup/lib</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-nls<optional>=<replaceable>LANGUAGES</replaceable></optional></option></term>
       <listitem>
        <!--
<para>
         Enables Native Language Support (<acronym>NLS</acronym>),
         that is, the ability to display a program's messages in a
         language other than English.
         <replaceable>LANGUAGES</replaceable> is an optional space-separated
         list of codes of the languages that you want supported, for
         example <literal>&#045;-enable-nls='de fr'</>.  (The intersection
         between your list and the set of actually provided
         translations will be computed automatically.)  If you do not
         specify a list, then all available translations are
         installed.
        </para>
-->
<para>
        打开本地语言支持(<acronym>NLS</acronym>)，也就是以非英文显示程序的消息的能力。
<replaceable>LANGUAGES</replaceable>是一个可选的空格分隔的语言代码列表，标识你想支持的语言。
比如<literal>--enable-nls='de fr'</>。(你提供的列表和实际支持的列表之间的交集会自动计算出来。)
如果你没有声明一个列表，那么就安装所有可用的翻译。
</para>

        <!--
<para>
         To use this option, you will need an implementation of the
         <application>Gettext</> API; see above.
        </para>
-->
<para>
       要使用这个选项，你需要一个<application>Gettext</>的实现。见上文。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-pgport=<replaceable>NUMBER</></option></term>
       <listitem>
        <!--
<para>
         Set <replaceable>NUMBER</> as the default port number for
         server and clients. The default is 5432. The port can always
         be changed later on, but if you specify it here then both
         server and clients will have the same default compiled in,
         which can be very convenient.  Usually the only good reason
         to select a non-default value is if you intend to run multiple
         <productname>PostgreSQL</> servers on the same machine.
        </para>
-->
<para>
       <replaceable>NUMBER</>为服务器和客户端的缺省端口(缺省是 5432)。这个端口可以在以后设置，
   不过如果你在这里声明，那么服务器和客户端将有相同的编译好了的缺省值。这样会方便些。
   通常选取一个非缺省值的好理由是你企图在同一台机器上运行多个<productname>PostgreSQL</>服务。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-perl</option></term>
       <listitem>
        <!--
<para>
         Build the <application>PL/Perl</> server-side language.
        </para>
-->
<para>
      编译<application>PL/Perl</>服务器端编程语言。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-python</option></term>
       <listitem>
        <!--
<para>
         Build the <application>PL/Python</> server-side language.
        </para>
-->
<para>
     编译<application>PL/Python</>服务器端编程语言。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-tcl</option></term>
       <listitem>
        <!--
<para>
         Build the <application>PL/Tcl</> server-side language.
        </para>
-->
<para>
      编译<application>PL/Tcl</>服务器端编程语言。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-tclconfig=<replaceable>DIRECTORY</replaceable></option></term>
       <listitem>
        <!--
<para>
         Tcl installs the file <filename>tclConfig.sh</filename>, which
         contains configuration information needed to build modules
         interfacing to Tcl. This file is normally found automatically
         at a well-known location, but if you want to use a different
         version of Tcl you can specify the directory in which to look
         for it.
        </para>
-->
<para>
       Tcl安装的<filename>tclConfig.sh</filename>文件所在目录，它里面包含编译 Tcl 模块的配置信息。
   这个文件通常会自动在约定俗成的位置找到这些文件，但是如果你需要一个不同版本的Tcl，
   你也可以指定能找到它的目录。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-gssapi</option></term>
       <listitem>
        <!--
<para>
         Build with support for GSSAPI authentication. On many
         systems, the GSSAPI (usually a part of the Kerberos installation)
         system is not installed in a location
         that is searched by default (e.g., <filename>/usr/include</>,
         <filename>/usr/lib</>), so you must use the options
         <option>&#045;-with-includes</> and <option>&#045;-with-libraries</> in
         addition to this option.  <filename>configure</> will check
         for the required header files and libraries to make sure that
         your GSSAPI installation is sufficient before proceeding.
        </para>
-->
<para>
       编译支持GSSAPI认证的东西。在许多系统上，GSSAPI（通常Kerberos安装部分）系统没有安装在缺省的搜索目录下
   (比如 <filename>/usr/include</>,<filename>/usr/lib</>)，
   所以你必须使用附加的<option>--with-includes</>和<option>--with-libraries</>选项。
   <filename>configure</>在继续配置之前将检查所需要的头文件和库，
   以确保GSSAPI是充分可用的。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-krb-srvnam=<replaceable>NAME</></option></term>
       <listitem>
        <!--
<para>
         The default name of the Kerberos service principal used
         by GSSAPI.
         <literal>postgres</literal> is the default. There's usually no
         reason to change this unless you have a Windows environment,
         in which case it must be set to upper case
         <literal>POSTGRES</literal>.
        </para>
-->
<para>
       GSSAPI使用的缺省的Kerberos服务主的名称。缺省是<literal>postgres</literal>。
   通常没有理由改变这个值。除非你在Windows环境下，在这种情况下必须设置大写<literal>POSTGRES</literal>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-openssl</option>
       <indexterm>
        <primary>OpenSSL</primary>
        <seealso>SSL</seealso>
       </indexterm>


       </term>
       <listitem>
        <!--
<para>
         Build with support for <acronym>SSL</> (encrypted)
         connections. This requires the <productname>OpenSSL</>
         package to be installed.  <filename>configure</> will check
         for the required header files and libraries to make sure that
         your <productname>OpenSSL</> installation is sufficient
         before proceeding.
        </para>
-->
<para>
       编译支持<acronym>SSL</>(加密的)连接。这个选项需要安装<productname>OpenSSL</>包。
   <filename>configure</>将在安装之前检查所需要的头文件和库文件以确信<productname>OpenSSL</>安装是充分可用的。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-pam</option></term>
       <listitem>
        <!--
<para>
         Build with <acronym>PAM</><indexterm><primary>PAM</></>
         (Pluggable Authentication Modules) support.
        </para>
-->
<para>
       编译<acronym>PAM</><indexterm><primary>PAM</></>(可插拔认证模块)支持。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-ldap</option></term>
       <listitem>
        <!--
<para>
         Build with <acronym>LDAP</><indexterm><primary>LDAP</></>
         support for authentication and connection parameter lookup (see
         <![%standalone-include[the documentation about client authentication
         and libpq]]><![%standalone-ignore[<xref linkend="libpq-ldap"> and
         <xref linkend="auth-ldap">]]> for more information). On Unix,
         this requires the <productname>OpenLDAP</> package to be
         installed. On Windows, the default <productname>WinLDAP</>
         library is used.  <filename>configure</> will check for the required
         header files and libraries to make sure that your
         <productname>OpenLDAP</> installation is sufficient before
         proceeding.
        </para>
-->
<para>
      编译<acronym>LDAP</><indexterm><primary>LDAP</></>支持。
  用于认证和查找连接参数(参见<![%standalone-include[the documentation about client authentication
      and libpq]]><![%standalone-ignore[<xref linkend="libpq-ldap">和<xref linkend="auth-ldap">]]>以获取更多信息)。
  在 Unix 上，这需要<productname>OpenLDAP</>包的支持。
  在Windows上，缺省使用<productname>WinLDAP</>库。
  <filename>configure</>将会检查所需的头文件和库以确保<productname>OpenLDAP</>的安装是充分可用的。  
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--without-readline</option></term>
       <listitem>
        <!--
<para>
         Prevents use of the <application>Readline</> library
         (and <application>libedit</> as well).  This option disables
         command-line editing and history in
         <application>psql</application>, so it is not recommended.
        </para>
-->
<para>
       避免使用<application>Readline</>与<application>libedit</>库。
   这样就关闭了<application>psql</application>里的命令行编辑和历史，因此我们不建议这么做。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libedit-preferred</option></term>
       <listitem>
        <!--
<para>
         Favors the use of the BSD-licensed <application>libedit</> library
         rather than GPL-licensed <application>Readline</>.  This option
         is significant only if you have both libraries installed; the
         default in that case is to use <application>Readline</>.
        </para>
-->
<para>
       优先使用BSD-认证的<application>libedit</>库而不是GPL认证的<application>Readline</>库。
   该选项仅在同时安装了这两个库的情况下才有意义。
   缺省使用<application>Readline</>库。

</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-bonjour</option></term>
       <listitem>
        <!--
<para>
         Build with Bonjour support.  This requires Bonjour support
         in your operating system.  Recommended on OS X.
        </para>
-->
<para>
      编译Bonjour支持。这要求操作系统支持Bonjour。在OS X上建议使用。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-uuid=<replaceable>LIBRARY</replaceable></option></term>
       <listitem>
<!-- 
        <para>
         Build the <![%standalone-include[uuid-ossp]]>
         <![%standalone-ignore[<xref linkend="uuid-ossp">]]> module
         (which provides functions to generate UUIDs), using the specified
         UUID library.<indexterm><primary>UUID</primary></indexterm>
         <replaceable>LIBRARY</replaceable> must be one of:
        </para> 
-->
        <para>
         建立<![%standalone-include[uuid-ossp]]>
         <![%standalone-ignore[<xref linkend="uuid-ossp">]]>模块
         (它提供生成UUID的函数)，使用指定的UUID库。
         <indexterm><primary>UUID</primary></indexterm>
         <replaceable>LIBRARY</replaceable>必须是下列之一：
        </para>
        <itemizedlist>
         <listitem>
<!-- 
          <para>
           <option>bsd</> to use the UUID functions found in FreeBSD, NetBSD,
           and some other BSD-derived systems
          </para> 
-->
          <para>
           <option>bsd</>使用在FreeBSD、NetBSD和一些其他BSD驱动的系统中找到的
           UUID函数
          </para>
         </listitem>
         <listitem>
<!-- 
          <para>
           <option>e2fs</> to use the UUID library created by
           the <literal>e2fsprogs</> project; this library is present in most
           Linux systems and in OS X, and can be obtained for other
           platforms as well
          </para> 
-->
          <para>
           <option>e2fs</>使用<literal>e2fsprogs</>项目创建的UUID库；
           这个库在大多数Linux系统和OS X上存在，并且其他平台也可以获取
          </para>
         </listitem>
         <listitem>
<!-- 
          <para>
           <option>ossp</> to use the <ulink
           url="http://www.ossp.org/pkg/lib/uuid/">OSSP UUID library</ulink>
          </para> 
-->
          <para>
           <option>ossp</>使用<ulink
           url="http://www.ossp.org/pkg/lib/uuid/">OSSP UUID库</ulink>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-ossp-uuid</option></term>
       <listitem>
        <!--
        <para>
         Obsolete equivalent of <literal>&#045;-with-uuid=ossp</literal>.
        </para>
-->
<para>
与<literal>--with-uuid=ossp</literal>完全相同。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libxml</option></term>
       <listitem>
        <!--
<para>
         Build with libxml (enables SQL/XML support).  Libxml version 2.6.23 or
         later is required for this feature.
        </para>
-->
<para>
      编译libxml (开启SQL/XML支持)。需要Libxml 2.6.23或者更高版本支持这一特性。
</para>

        <!--
<para>
         Libxml installs a program <command>xml2-config</command> that
         can be used to detect the required compiler and linker
         options.  PostgreSQL will use it automatically if found.  To
         specify a libxml installation at an unusual location, you can
         either set the environment variable
         <envar>XML2_CONFIG</envar> to point to the
         <command>xml2-config</command> program belonging to the
         installation, or use the options
         <option>&#045;-with-includes</option> and
         <option>&#045;-with-libraries</option>.
        </para>
-->
<para>
Libxml安装程序<command>xml2-config</command>可用于检测所需的编译器和链接器选项。 
如果发现，PostgreSQL将自动使用它。
在一个不寻常的位置来指定libxml安装，
您可以要么设置环境变量<envar>XML2_CONFIG</envar>以指向 
<command>xml2-config</command>附属于安装的程序 
或者使用选项<option>--with-includes</option>和<option>--with-libraries</option>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libxslt</option></term>
       <listitem>
        <!--
<para>
         Use libxslt when building the
         <![%standalone-include[xml2]]>
         <![%standalone-ignore[<xref linkend="xml2">]]>
         module.  <application>xml2</> relies on this library
         to perform XSL transformations of XML.
        </para>
-->
<para>
    当编译<![%standalone-include[xml2]]>
    <![%standalone-ignore[<xref linkend="xml2">]]>模块时，使用libxslt。
<application>xml2</>依赖于这个库执行XML的XSL转变。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-integer-datetimes</option></term>
       <listitem>
        <!--
<para>
         Disable support for 64-bit integer storage for timestamps and
         intervals, and store datetime values as floating-point
         numbers instead. Floating-point datetime storage was the
         default in <productname>PostgreSQL</productname> releases
         prior to 8.4, but it is now deprecated, because it does not
         support microsecond precision for the full range of
         <type>timestamp</type> values. However, integer-based
         datetime storage requires a 64-bit integer type. Therefore,
         this option can be used when no such type is available, or
         for compatibility with applications written for prior
         versions of <productname>PostgreSQL</productname>. See
         <![%standalone-include[the documentation about datetime datatypes]]>
         <![%standalone-ignore[<xref linkend="datatype-datetime">]]>
         for more information.
        </para>
-->
<para>
      禁用64 位的时间戳整数存储和时间间隔支持。并且作为浮点数存储日期时间值。
  在<productname>PostgreSQL</productname>8.4版本发布之前缺省浮点日期时间存储。
  但它现在已经过时，因为它没有支持<type>timestamp</type>值的全范围的微秒精度。
  然而，基于整数的日期时间存储需要一个64位的整数类型。
  因此，当没有这样的类型可用时，或适用于<productname>PostgreSQL</productname>先前版本的应用程序时，
  可以使用此选项。
  参阅<![%standalone-include[the documentation about datetime datatypes]]>
      <![%standalone-ignore[<xref linkend="datatype-datetime">]]>获取更多的信息。  
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-float4-byval</option></term>
       <listitem>
        <!--
<para>
         Disable passing float4 values <quote>by value</>, causing them
         to be passed <quote>by reference</> instead.  This option costs
         performance, but may be needed for compatibility with old
         user-defined functions that are written in C and use the
         <quote>version 0</> calling convention.  A better long-term
         solution is to update any such functions to use the
         <quote>version 1</> calling convention.
        </para>
-->
<para>
  禁用<quote>按值传递</>float4值，使它们<quote>通过引用</>传递。
  此选项消耗性能，但可能需要与用C语言编写的旧的用户定义的函数兼容，并且使用  
  <quote>版本 0</>调用约定。一个更好的长期的解决办法是使用<quote>版本 1</>调用约定更新任何此类函数。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-float8-byval</option></term>
       <listitem>
        <!--
<para>
         Disable passing float8 values <quote>by value</>, causing them
         to be passed <quote>by reference</> instead.  This option costs
         performance, but may be needed for compatibility with old
         user-defined functions that are written in C and use the
         <quote>version 0</> calling convention.  A better long-term
         solution is to update any such functions to use the
         <quote>version 1</> calling convention.
         Note that this option affects not only float8, but also int8 and some
         related types such as timestamp.
         On 32-bit platforms, <option>&#045;-disable-float8-byval</> is the default
         and it is not allowed to select <option>&#045;-enable-float8-byval</>.
        </para>
-->
<para>
  禁用<quote>按值传递</>传递float8值，使它们<quote>通过引用</>传递。
  此选项消耗性能，但可能需要与用C语言编写的旧的用户定义的函数兼容，并且使用  
  <quote>版本 0</>调用约定。一个更好的长期的解决办法是使用<quote>版本 1</>调用约定更新任何此类函数
  请注意，此选项不仅影响float8，而且也影响int8以及一些相关类型（如时间戳）。 
  在32位平台上，缺省是<option>--disable-float8-byval</>。
  并且它不允许选择<option>--enable-float8-byval</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-segsize=<replaceable>SEGSIZE</replaceable></option></term>
       <listitem>
        <!--
<para>
         Set the <firstterm>segment size</>, in gigabytes.  Large tables are
         divided into multiple operating-system files, each of size equal
         to the segment size.  This avoids problems with file size limits
         that exist on many platforms.  The default segment size, 1 gigabyte,
         is safe on all supported platforms.  If your operating system has
         <quote>largefile</> support (which most do, nowadays), you can use
         a larger segment size.  This can be helpful to reduce the number of
         file descriptors consumed when working with very large tables.
         But be careful not to select a value larger than is supported
         by your platform and the file systems you intend to use.  Other
         tools you might wish to use, such as <application>tar</>, could
         also set limits on the usable file size.
         It is recommended, though not absolutely required, that this value
         be a power of 2.
         Note that changing this value requires an initdb.
        </para>
-->
<para>
设置<firstterm>段大小</> ，以GB为单位。
大表被分成多个操作系统文件，每个文件的大小等同于段大小。
这避免了存在许多平台上的文件大小限制。
默认段大小，1GB，在所有支持的平台上是安全的。
如果你的操作系统支持<quote>largefile</>（现在大多数支持），
你可以使用更大的段大小。
这可以帮助减少当大表工作时消耗掉的文件描述符数量。
但要小心，不要选择一个大于您的平台和您打算使用的文件系统支持的值，
你可能希望使用其他工具，比如<application>tar</>，
也可以设置可用文件大小的限制。
因此建议，虽然不是绝对必要的，但该值是2的幂。
请注意，改变这个值需要初始化数据库。 
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-blocksize=<replaceable>BLOCKSIZE</replaceable></option></term>
       <listitem>
        <!--
<para>
         Set the <firstterm>block size</>, in kilobytes.  This is the unit
         of storage and I/O within tables.  The default, 8 kilobytes,
         is suitable for most situations; but other values may be useful
         in special cases.
         The value must be a power of 2 between 1 and 32 (kilobytes).
         Note that changing this value requires an initdb.
        </para>
-->
<para>
设置<firstterm>块大小</>，以KB为单位。这是表中存储和I/O单元。
默认情况下，8KB，适用于大多数情况；
但是其它的值可能在特殊情况下是有用的。 
该值必须是1和32之间（KB）2的幂。 
请注意，改变这个值需要初始化数据库。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-wal-segsize=<replaceable>SEGSIZE</replaceable></option></term>
       <listitem>
        <!--
<para>
         Set the <firstterm>WAL segment size</>, in megabytes.  This is
         the size of each individual file in the WAL log.  It may be useful
         to adjust this size to control the granularity of WAL log shipping.
         The default size is 16 megabytes.
         The value must be a power of 2 between 1 and 64 (megabytes).
         Note that changing this value requires an initdb.
        </para>
-->
<para>
设置<firstterm>WAL段大小</>，以MB为单位。
这是WAL日志中每个单独的文件的大小。它可能有助于调整这个大小来控制WAL日志传送的粒度。 
缺省大小为16MB。 
该值必须是1和64之间（MB）2的幂。 
请注意，改变这个值需要初始化数据库。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-wal-blocksize=<replaceable>BLOCKSIZE</replaceable></option></term>
       <listitem>
        <!--
<para>
         Set the <firstterm>WAL block size</>, in kilobytes.  This is the unit
         of storage and I/O within the WAL log.  The default, 8 kilobytes,
         is suitable for most situations; but other values may be useful
         in special cases.
         The value must be a power of 2 between 1 and 64 (kilobytes).
         Note that changing this value requires an initdb.
        </para>
-->
<para>
设置<firstterm>WAL块大小</>，以KB为单位。
这是WAL日志中存储和I/O单元。
默认情况下，8KB，适用于大多数情况；
但是其它的值可能在特殊情况下是有用的。 
该值必须是1和64之间（KB）2的幂。 
请注意，改变这个值需要初始化数据库。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-spinlocks</option></term>
       <listitem>
        <!--
<para>
         Allow the build to succeed even if <productname>PostgreSQL</>
         has no CPU spinlock support for the platform.  The lack of
         spinlock support will result in poor performance; therefore,
         this option should only be used if the build aborts and
         informs you that the platform lacks spinlock support. If this
         option is required to build <productname>PostgreSQL</> on
         your platform, please report the problem to the
         <productname>PostgreSQL</> developers.
        </para>
-->
<para>
       允许在<productname>PostgreSQL</>没有该平台的CPU自旋锁支持的情况下编译成功。
   缺乏自旋锁的支持将导致性能恶化；
   因此，只有在编译过程退出，并且告诉你说该平台缺乏自旋锁支持的时候才使用这个选项。
   如果在你的平台上需要这个选项才能编译<productname>PostgreSQL</>，
   请向<productname>PostgreSQL</>开发者报告这个问题。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-thread-safety</option></term>
       <listitem>
        <!--
<para>
         Disable the thread-safety of client libraries.  This prevents
         concurrent threads in <application>libpq</application> and
         <application>ECPG</application> programs from safely controlling
         their private connection handles.
        </para>
-->
<para>
       禁用客户端库是线程安全的。
   这样就允许在<application>libpq</application>和
       <application>ECPG</application>程序里的并发线程安全地控制他们私有的连接句柄。   
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-system-tzdata=<replaceable>DIRECTORY</replaceable></option>
       <indexterm>
        <primary>time zone data</primary>
       </indexterm>
       </term>
       <listitem>
        <!--
<para>
         <productname>PostgreSQL</> includes its own time zone database,
         which it requires for date and time operations.  This time zone
         database is in fact compatible with the IANA time zone
         database provided by many operating systems such as FreeBSD,
         Linux, and Solaris, so it would be redundant to install it again.
         When this option is used, the system-supplied time zone database
         in <replaceable>DIRECTORY</replaceable> is used instead of the one
         included in the PostgreSQL source distribution.
         <replaceable>DIRECTORY</replaceable> must be specified as an
         absolute path.  <filename>/usr/share/zoneinfo</filename> is a
         likely directory on some operating systems.  Note that the
         installation routine will not detect mismatching or erroneous time
         zone data.  If you use this option, you are advised to run the
         regression tests to verify that the time zone data you have
         pointed to works correctly with <productname>PostgreSQL</>.
        </para>
-->
<para>
      <productname>PostgreSQL</>包括它自己的时区数据库，
它要求对日期和时间操作。此时区数据库实际上是与许多操作系统比如FreeBSD,Linux, and Solaris提供的IANA时区数据库兼容。
所以重新安装将是多余的。当这个选项被使用时，将使用系统在<replaceable>DIRECTORY</replaceable>中提供的时区数据库来代替PostgreSQL源代码发布中的时区数据库。
<replaceable>DIRECTORY</replaceable>必须作为绝对路径被指定。 
<filename>/usr/share/zoneinfo</filename>是某些操作系统上的可能目录。
请注意，这个安装程序将不检测不匹配的或者错误的时间区域数据。
如果您使用此选项，建议您运行回归测试，以验证你指定的时区数据，
在<productname>PostgreSQL</>中能够很好的工作。
</para>

        <indexterm><primary>cross compilation</primary></indexterm>

        <!--
<para>
         This option is mainly aimed at binary package distributors
         who know their target operating system well.  The main
         advantage of using this option is that the PostgreSQL package
         won't need to be upgraded whenever any of the many local
         daylight-saving time rules change.  Another advantage is that
         PostgreSQL can be cross-compiled more straightforwardly if the
         time zone database files do not need to be built during the
         installation.
        </para>
-->
<para>
      该选项主要是针对那些对他们要使用的操作系统了如指掌的二进制软件包的分发者。
      使用此选项的主要优势是，当许多当地白昼节约时间规则变化的任何时候，PostgreSQL包不需要升级。
      另一个优点是，如果时区数据库文件在安装期间不需要被编译，PostgreSQL可以进行交叉编译更直截了当。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--without-zlib</option></term>
       <listitem>
        <!--
<para>
         <indexterm>
          <primary>zlib</primary>
         </indexterm>
         Prevents use of the <application>Zlib</> library.  This disables
         support for compressed archives in <application>pg_dump</application>
         and <application>pg_restore</application>.
         This option is only intended for those rare systems where this
         library is not available.
        </para>
-->
<para>
     避免使用<application>Zlib</>库。这样就关闭了<application>pg_dump</application>
     和<application>pg_restore</application>里面的压缩支持。
 这个选项只适用于那些没有这个库的罕见的系统。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-debug</option></term>
       <listitem>
        <!--
<para>
         Compiles all programs and libraries with debugging symbols.
         This means that you can run the programs in a debugger
         to analyze problems. This enlarges the size of the installed
         executables considerably, and on non-GCC compilers it usually
         also disables compiler optimization, causing slowdowns. However,
         having the symbols available is extremely helpful for dealing
         with any problems that might arise.  Currently, this option is
         recommended for production installations only if you use GCC.
         But you should always have it on if you are doing development work
         or running a beta version.
        </para>
-->
<para>
     把所有程序和库以带有调试符号的方式编译。这意味着你可以通过一个调试器运行程序来分析问题。
 这样做显著增大了最后安装的可执行文件的大小，并且在非GCC的编译器上，
 这么做通常还要关闭编译器优化，导致速度的下降。但是，如果有这些符号的话，
 就可以非常有效地帮助解决可能发生的问题。目前，
 我们只是在你使用GCC的情况下才建议在产品的安装中使用这个选项。
 但是如果你正在进行开发工作，或者正在使用beta版本，
 那么你就总应该打开它。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-coverage</option></term>
       <listitem>
        <!--
<para>
         If using GCC, all programs and libraries are compiled with
         code coverage testing instrumentation.  When run, they
         generate files in the build directory with code coverage
         metrics.
         <![%standalone-ignore[See <xref linkend="regress-coverage">
         for more information.]]> This option is for use only with GCC
         and when doing development work.
        </para>
-->
<para>
      如果使用GCC，所有的程序和库连同代码覆盖测试设置一起被编译。
  在运行时，它们与代码覆盖率度量在编译目录下生成文件。 
      <![%standalone-ignore[参阅<xref linkend="regress-coverage">
         获取更多信息]]>该选项只在使用GCC进行开发工作时使用。。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-profiling</option></term>
       <listitem>
        <!--
<para>
         If using GCC, all programs and libraries are compiled so they
         can be profiled.  On backend exit, a subdirectory will be created
         that contains the <filename>gmon.out</> file for use in profiling.
         This option is for use only with GCC and when doing development work.
        </para>
-->
<para>
如果使用GCC，则编译所有程序和库，使他们可以配置。在后台退出，创建子目录， 
包含配置用的<filename>gmon.out</>文件。 
该选项只在使用GCC进行开发工作时使用。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-cassert</option></term>
       <listitem>
        <!--
<para>
         Enables <firstterm>assertion</> checks in the server, which test for
         many <quote>cannot happen</> conditions.  This is invaluable for
         code development purposes, but the tests can slow down the
         server significantly.
         Also, having the tests turned on won't necessarily enhance the
         stability of your server!  The assertion checks are not categorized
         for severity, and so what might be a relatively harmless bug will
         still lead to server restarts if it triggers an assertion
         failure.  This option is not recommended for production use, but
         you should have it on for development work or when running a beta
         version.
        </para>
-->
<para>
  打开服务器中的<firstterm>assertion</>检查，它会检查许多<quote>不可能发生</>的条件。
  它对于代码开发的用途而言是无价之宝，不过这些测试可以显著减缓服务器。
  并且，打开这个测试不会提高系统的稳定性！这些断言检查并不是按照错误的严重性分类的，
  因此一些相对无害的小问题也可能导致服务器重启 (只要它触发了一次断言失败)。目前，
  我们不推荐在产品环境中使用这个选项，但是如果你在做开发或者在使用beta版本的时候应该打开它。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-depend</option></term>
       <listitem>
        <!--
<para>
         Enables automatic dependency tracking.  With this option, the
         makefiles are set up so that all affected object files will
         be rebuilt when any header file is changed.  This is useful
         if you are doing development work, but is just wasted overhead
         if you intend only to compile once and install.  At present,
         this option only works with GCC.
        </para>
-->
<para>
     打开自动依赖性跟踪。如果打开这个选项，
 那么 makefile 文件将设置为在任何头文件被修改的时候都将重新编译所有受影响的目标文件。
 如果你在做开发的工作，那么这个选项很有用，但是如果你只是想编译一次并且安装，
 那么这就是浪费时间。目前，这个选项只有在你使用GCC的时候才管用。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-dtrace</option></term>
       <listitem>
        
<para>
         <indexterm>
          <primary>DTrace</primary>
         </indexterm>
 <!--
         Compiles <productname>PostgreSQL</productname> with support for the
         dynamic tracing tool DTrace.
         <![%standalone-ignore[See <xref linkend="dynamic-trace">
         for more information.]]>
 -->
 编译<productname>PostgreSQL</productname>支持动态跟踪工具DTrace。
    <![%standalone-ignore[参阅<xref linkend="dynamic-trace">获取更多信息]]>。  
        </para>

        <!--
<para>
         To point to the <command>dtrace</command> program, the
         environment variable <envar>DTRACE</envar> can be set.  This
         will often be necessary because <command>dtrace</command> is
         typically installed under <filename>/usr/sbin</filename>,
         which might not be in the path.
        </para>
-->
<para>
     指向<command>dtrace</command>程序，设置环境变量<envar>DTRACE</envar>。
 这往往是必须的，因为<command>dtrace</command>
 通常安装在<filename>/usr/sbin</filename>中且该目录一般不在搜索路经中。
</para>

        
<para>
        <!--
         Extra command-line options for the <command>dtrace</command> program
         can be specified in the environment variable
         <envar>DTRACEFLAGS</envar>.  On Solaris,
         to include DTrace support in a 64-bit binary, you must specify
         <literal>DTRACEFLAGS="-64"</> to configure.  For example,
         using the GCC compiler:
 -->
 
在环境变量<envar>DTRACEFLAGS</envar>中为<command>dtrace</command>程序指定
额外命令行选项。在Solaris上，
        要包含64位二进制的DTrace支持，需要为configure指定<literal>DTRACEFLAGS="-64"</>，比如，
在使用GCC编译的时候:
 
<screen>
./configure CC='gcc -m64' --enable-dtrace DTRACEFLAGS='-64' ...
</screen>
        <!--
         Using Sun's compiler:
 -->
 在使用Sun编译器的时候：
<screen>
./configure CC='/opt/SUNWspro/bin/cc -xtarget=native64' --enable-dtrace DTRACEFLAGS='-64' ...
</screen>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-tap-tests</option></term>
       <listitem>
<!-- 
        <para>
         Enable tests using the Perl TAP tools.  This requires a Perl
         installation and the Perl module <literal>IPC::Run</literal>.
         <![%standalone-ignore;[See <xref linkend="regress-tap"> for more information.]]>
        </para> 
-->
        <para>
         启用使用Perl TAP工具的测试。这需要安装Perl和Perl模块<literal>IPC::Run</literal>。
         <![%standalone-ignore;[参阅<xref linkend="regress-tap">获取更多信息。]]>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <!--
<para>
     If you prefer a C compiler different from the one
     <filename>configure</filename> picks, you can set the
     environment variable <envar>CC</> to the program of your choice.
     By default, <filename>configure</filename> will pick
     <filename>gcc</filename> if available, else the platform's
     default (usually <filename>cc</>).  Similarly, you can override the
     default compiler flags if needed with the <envar>CFLAGS</envar> variable.
    </para>
-->
<para>
   如果你喜欢使用不同于<filename>configure</filename>找出来的 C 编译器，
   可以将环境变量<envar>CC</>设置为你选择的程序。缺省时，
   <filename>configure</filename>将选择<filename>gcc</filename>(只要可用)，
   或者是该平台的缺省(通常是<filename>cc</>)。类似地，
   你可以用<envar>CFLAGS</envar>覆盖缺省编译器标志。
</para>
    
<para>
   <!--
     You can specify environment variables on the
     <filename>configure</filename> command line, for example:
 -->
 你可以在<filename>configure</filename>命令行上声明环境变量，比如：
<screen>
<userinput>./configure CC=/opt/bin/gcc CFLAGS='-O2 -pipe'</>
</screen>
    </para>

    
<para>
    <!--
     Here is a list of the significant variables that can be set in
     this manner:
    -->
    下面是可用的环境变量列表：

     <variablelist>
      <varlistentry>
       <term><envar>BISON</envar></term>
       <listitem>
        <para>
 <!--
         Bison program
 -->
 Bison程序
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CC</envar></term>
       <listitem>
        <!--
<para>
         C compiler
        </para>
-->
<para>
 C编译器
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CFLAGS</envar></term>
       <listitem>
        <!--
<para>
         options to pass to the C compiler
        </para>
-->
<para>
   传递给C编译器的选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CPP</envar></term>
       <listitem>
        <!--
<para>
         C preprocessor
        </para>
-->
<para>
  C预处理器
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CPPFLAGS</envar></term>
       <listitem>
        <!--
<para>
         options to pass to the C preprocessor
        </para>
-->
<para>
   传递给C预处理器的选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>DTRACE</envar></term>
       <listitem>
        <!--
<para>
         location of the <command>dtrace</command> program
        </para>
-->
<para>
    <command>dtrace</command>程序位置
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>DTRACEFLAGS</envar></term>
       <listitem>
        <!--
<para>
         options to pass to the <command>dtrace</command> program
        </para>
-->
<para>
 传递给<command>dtrace</command>程序的选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>FLEX</envar></term>
       <listitem>
        <!--
<para>
         Flex program
        </para>
-->
<para>
   Flex程序
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS</envar></term>
       <listitem>
        <!--
<para>
         options to use when linking either executables or shared libraries
        </para>
-->
<para>
    当连接可执行文件或共享库时使用的选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS_EX</envar></term>
       <listitem>
        <!--
<para>
         additional options for linking executables only
        </para>
-->
<para>
    只连接可执行文件时的额外选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS_SL</envar></term>
       <listitem>
        <!--
<para>
         additional options for linking shared libraries only
        </para>
-->
<para>
      只连接共享库时的额外选项
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>MSGFMT</envar></term>
       <listitem>
        <!--
<para>
         <command>msgfmt</command> program for native language support
        </para>
-->
<para>
      本地语言支持的<command>msgfmt</command>程序
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>PERL</envar></term>
       <listitem>
        <!--
<para>
         Full path to the Perl interpreter.  This will be used to
         determine the dependencies for building PL/Perl.
        </para>
-->
<para>
       Perl解释器的完整路径。用于确定编译PL/Perl的依赖关系。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>PYTHON</envar></term>
       <listitem>
        <!--
<para>
         Full path to the Python interpreter.  This will be used to
         determine the dependencies for building PL/Python.  Also,
         whether Python 2 or 3 is specified here (or otherwise
         implicitly chosen) determines which variant of the PL/Python
         language becomes available.  See
         <![%standalone-include[the <application>PL/Python</>
         documentation]]>
         <![%standalone-ignore[<xref linkend="plpython-python23">]]>
         for more information.
        </para>
-->
<para>
     Python解释器的完整路径。用于确定编译PL/Python的依赖关系。
 另外，Python 2或3是否在这声明（或另有隐式选择）决定了PL/Python
 的哪种语言是可用的。
 参阅<![%standalone-include[the <application>PL/Python</>
         documentation]]><![%standalone-ignore[<xref linkend="plpython-python23">]]>
获取更多详情。
 
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>TCLSH</envar></term>
       <listitem>
        <!--
<para>
         Full path to the Tcl interpreter.  This will be used to
         determine the dependencies for building PL/Tcl, and it will
         be substituted into Tcl scripts.
        </para>
-->
<para>
        Tcl解释器的完整路径。用于确定编译PL/Tcl的依赖关系。并且它将替代Tcl脚本。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>XML2_CONFIG</envar></term>
       <listitem>
        <!--
<para>
         <command>xml2-config</command> program used to locate the
         libxml installation.
        </para>
-->
<para>
      <command>xml2-config</command>程序用于定位libxml安装。
</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <note>
     <!--
<para>
      When developing code inside the server, it is recommended to
      use the configure options <option>&#045;-enable-cassert</> (which
      turns on many run-time error checks) and <option>&#045;-enable-debug</>
      (which improves the usefulness of debugging tools).
     </para>
-->
<para>
   当开发服务器端的内部代码时，建议使用配置选项<option>--enable-cassert</>（其中 
   打开许多运行时错误检查）和<option>&#045;-enable-debug</>
  （可以改进调试工具的有效性）。
</para>

     <!--
<para>
      If using GCC, it is best to build with an optimization level of
      at least <option>-O1</>, because using no optimization
      (<option>-O0</>) disables some important compiler warnings (such
      as the use of uninitialized variables).  However, non-zero
      optimization levels can complicate debugging because stepping
      through compiled code will usually not match up one-to-one with
      source code lines.  If you get confused while trying to debug
      optimized code, recompile the specific files of interest with
      <option>-O0</>.  An easy way to do this is by passing an option
      to <application>make</>: <command>make PROFILE=-O0 file.o</>.
     </para>
-->
<para>
    如果使用GCC，最好是进行至少<option>-O1</>的优化级别的编译。
    因为不使用优化(<option>-O0</>)会禁止一些重要的编译器警告（例如，使用未初始化变量）。
然而，非零优化级别可以进行复杂调试，
   因为通过编译代码步进调试往往与源代码的行无法一对一的匹配。
   如果你在试图调试优化后的代码时感到困惑，可以重新编译特定文件指定<option>-O0</>。
   一个简单方法来做到这一点是通过传递选项到<application>make</>: <command>make PROFILE=-O0 file.o</>。
</para>
    </note>
   </step>

  <step id="build">
  <!--
   <title>Build</title>
   -->
   <title>编译</title>

   
<para>
    <!--
    To start the build, type:
-->
开始编译，键入：
<screen>
<userinput>make</userinput>
</screen>
    <!--
    (Remember to use <acronym>GNU</> <application>make</>.) The build
    will take a few minutes depending on your
    hardware. The last line displayed should be:
-->
（记住使用<acronym>GNU</> <application>make</>）。
 依硬件不同，编译过程可能需要一些时间。显示的最后一行应该是：

<screen>
All of PostgreSQL is successfully made. Ready to install.
</screen>
   </para>


  
<para>
  <!--
   If you want to build everything that can be built, including the
   documentation (HTML and man pages), and the additional modules
   (<filename>contrib</filename>), type instead:
  -->
    如果你想要编译一切可以编译的东西，包含文档（HTML和手册页），以及额外模块（<filename>contrib</filename>）
键入：
<screen>
<userinput>make world</userinput>
</screen>
   <!--
   The last line displayed should be:
   -->
   显示的最后一行应该是：
<screen>
PostgreSQL, contrib and HTML documentation successfully made. Ready to install.
</screen>
   </para>

  </step>

  <step>
  <!--
   <title>Regression Tests</title>
   -->
   <title>回归测试</title>

   <indexterm>
    <primary>regression test</primary>
   </indexterm>

  
<para>
    <!--
    If you want to test the newly built server before you install it,
    you can run the regression tests at this point. The regression
    tests are a test suite to verify that <productname>PostgreSQL</>
    runs on your machine in the way the developers expected it
    to. Type:
-->
   如果你想在安装前测试新编译出的服务器，
   那么你可以在这个时候运行回归测试。
   回归测试是一个用于验证<productname>PostgreSQL</>在你的系统上是否按照开发人员设想的那样运行的测试套件。
   敲入：

<screen>
<userinput>make check</userinput>
</screen>
    <!--
    (This won't work as root; do it as an unprivileged user.)
    <![%standalone-include[The file
    <filename>src/test/regress/README</> and the
    documentation contain]]>
    <![%standalone-ignore[<xref linkend="regress"> contains]]>
    detailed information about interpreting the test results. You can
    repeat this test at any later time by issuing the same command.
-->
这条命令在root用户下无法执行；请在非特权用户下运行该命令。
<![%standalone-include[The file
    <filename>src/test/regress/README</> and the
    documentation contain]]>
    <![%standalone-ignore[<xref linkend="regress"> 包含]]>
关于如何解释测试结果的详细信息。
你可以在以后的任何时间通过执行这条命令来运行这个测试。
   </para>

  </step>

  <step id="install">
  <!--
   <title>Installing the Files</title>
   -->
    <title>安装</title>

   <note>
    <!--
<para>
     If you are upgrading an existing system be sure to read
     <![%standalone-include[the documentation,]]>
     <![%standalone-ignore[<xref linkend="upgrading">]]>
     which has instructions about upgrading a
     cluster.
    </para>
-->
<para>
    如果你正在升级一套现有的系统一定要读<![%standalone-include[the documentation,]]>
     <![%standalone-ignore[<xref linkend="upgrading">]]>
 中关于升级集群的说明。 
</para>
   </note>

   
<para>
   <!--
    To install <productname>PostgreSQL</> enter:
   -->
   安装<productname>PostgreSQL</>，键入：
<screen>
<userinput>make install</userinput>
</screen>
    <!--
    This will install files into the directories that were specified
    in <xref linkend="configure">. Make sure that you have appropriate
    permissions to write into that area. Normally you need to do this
    step as root. Alternatively, you can create the target
    directories in advance and arrange for appropriate permissions to
    be granted.
-->
这条命令将把文件安装到在<xref linkend="configure">声明的目录里面去。
确保你对那个目录有足够的权限。通常你需要用 root 权限做这一步。
或者你也可以事先创建目标目录并且分派合适的权限。
   </para>



   
<para>
    <!--
    To install the documentation (HTML and man pages), enter:
-->
安装文档（HTML和手册页），键入：
<screen>
<userinput>make install-docs</userinput>
</screen>
   </para>


   
<para>
    <!--
    If you built the world above, type instead:
-->
如果上面编译了world,键入：
<screen>
<userinput>make install-world</userinput>
</screen>
    <!--
    This also installs the documentation.
-->
这也会安装文档。
   </para> 

 
   <!--
<para>
    You can use <literal>make install-strip</literal> instead of
    <literal>make install</literal> to strip the executable files and
    libraries as they are installed.  This will save some space.  If
    you built with debugging support, stripping will effectively
    remove the debugging support, so it should only be done if
    debugging is no longer needed.  <literal>install-strip</literal>
    tries to do a reasonable job saving space, but it does not have
    perfect knowledge of how to strip every unneeded byte from an
    executable file, so if you want to save all the disk space you
    possibly can, you will have to do manual work.
   </para>
-->
<para>
   你可以使用<literal>make install-strip</literal>代替<literal>make install</literal>在安装可执行文件和库文件时把它们的调试信息抽取掉。
   这样将节约一些空间。如果你编译时带着调试支持，那么抽取将有效地删除调试支持，
   因此我们应该只是在不再需要调试的时候做这些事情。
   <literal>install-strip</literal>力图做一些合理的事情来节约空间，
   但是它并不知道如何从可执行文件中抽取每个不需要的字节，
   因此，如果你希望节约所有可能节约的磁盘空间，那么你可能需要手工做些处理。
</para>

   <!--
<para>
    The standard installation provides all the header files needed for client
    application development as well as for server-side program
    development, such as custom functions or data types written in C.
    (Prior to <productname>PostgreSQL</> 8.0, a separate <literal>make
    install-all-headers</> command was needed for the latter, but this
    step has been folded into the standard install.)
   </para>
-->
<para>
    标准的安装只提供所有开发客户端应用的头文件和服务器端的程序开发，
比如用 C 写客户函数或者数据类型的头文件。
（<productname>PostgreSQL</> 8.0之前，后者需要单独的执行<literal>make install-all-headers</>命令，但是这一步现在已经被包含在标准安装中了）。
</para>

   <formalpara>
    <!--
    <title>Client-only installation:</title>
-->
 <title>只装客户端:</title>
    
<para>
     <!--
     If you want to install only the client applications and
     interface libraries, then you can use these commands:
 -->
 如果你只想装客户应用和接口，那么你可以用下面的命令:
<screen>
<userinput>make -C src/bin install</>
<userinput>make -C src/include install</>
<userinput>make -C src/interfaces install</>
<userinput>make -C doc install</>
</screen>
    <!--
    <filename>src/bin</> has a few binaries for server-only use,
    but they are small.
-->
<filename>src/bin</>中有一些仅供服务器使用的二进制文件，但是它们都很小。
    </para>
   </formalpara>
  </step>
  </procedure>

  <formalpara>
   <!--
   <title>Uninstallation:</title>
   -->
   <title>卸载:</title>
   <!--
<para>
    To undo the installation use the command <command>make
    uninstall</>. However, this will not remove any created directories.
   </para>
-->
<para>
    可以使用<command>make uninstall</>命令卸载。
不过这样不会删除任何创建出来的目录。
</para>
  </formalpara>

  <formalpara>
   <!--
   <title>Cleaning:</title>
   -->
   <title>清理:</title>

   <!--
<para>
    After the installation you can free disk space by removing the built
    files from the source tree with the command <command>make
    clean</>. This will preserve the files made by the <command>configure</command>
    program, so that you can rebuild everything with <command>make</>
    later on. To reset the source tree to the state in which it was
    distributed, use <command>make distclean</>. If you are going to
    build for several platforms within the same source tree you must do
    this and re-configure for each platform.  (Alternatively, use
    a separate build tree for each platform, so that the source tree
    remains unmodified.)
   </para>
-->
<para>
   在安装完成以后，你可以通过在源码树里面用命令<command>make clean</>删除编译过程文件释放磁盘空间。
   这样会保留<command>configure</command>程序生成的文件，这样以后你就可以用<command>make</>命令重新编译所有东西。
   要把源码树恢复为发布时的状态，用<command>make distclean</>命令。
   如果你想从同一棵源码树上为多个不同平台编译，
   你就一定要运行这条命令并且为每个平台重新配置。
   另外，在每种系统上使用一套独立的编译树，这样源代码树就可以保留不被更改。
</para>
  </formalpara>

  <!--
<para>
   If you perform a build and then discover that your <command>configure</>
   options were wrong, or if you change anything that <command>configure</>
   investigates (for example, software upgrades), then it's a good
   idea to do <command>make distclean</> before reconfiguring and
   rebuilding.  Without this, your changes in configuration choices
   might not propagate everywhere they need to.
  </para>
-->
<para>
   如果你执行了一次编译，然后发现你的<command>配置</>选项是错误的，
   或者你修改了任何<command>配置</>所探测的东西(比如升级了软件)，
   那么在重新配置和编译之前运行一下<command>make distclean</>是个好习惯。如果不做这个事情，
   你修改的配置选项可能无法传播到所有需要变化的地方。
</para>
 </sect1>

 <sect1 id="install-post">
  <!--
  <title>Post-Installation Setup</title>
  -->
  <title>安装后设置</title>

  <sect2>
  <!--
   <title>Shared Libraries</title>
   -->
    <title>共享库</title>

   <indexterm>
    <primary>shared library</primary>
   </indexterm>

   <!--
<para>
    On some systems with shared libraries
    you need to tell the system how to find the newly installed
    shared libraries.  The systems on which this is
    <emphasis>not</emphasis> necessary include
    <systemitem class="osname">FreeBSD</>,
    <systemitem class="osname">HP-UX</>, 
    <systemitem class="osname">Linux</>,
    <systemitem class="osname">NetBSD</>, <systemitem
    class="osname">OpenBSD</>, <systemitem class="osname">Tru64
    UNIX</> (formerly <systemitem class="osname">Digital UNIX</>), and
    <systemitem class="osname">Solaris</>.
   </para>
-->
<para>
    在一些有共享库的系统里，
你需要告诉系统如何找到新安装的共享库。
那些并<emphasis>不是</emphasis>必须做这个工作的系统包括 
<systemitem class="osname">FreeBSD</>,
    <systemitem class="osname">HP-UX</>,
    <systemitem class="osname">Linux</>,
    <systemitem class="osname">NetBSD</>, <systemitem
    class="osname">OpenBSD</>, <systemitem class="osname">Tru64
    UNIX</> (以前的 <systemitem class="osname">Digital UNIX</>)和
    <systemitem class="osname">Solaris</>。
</para>

   
<para>
    <!--
    The method to set the shared library search path varies between
    platforms, but the most widely-used method is to set the
    environment variable <envar>LD_LIBRARY_PATH</> like so: In Bourne
    shells (<command>sh</>, <command>ksh</>, <command>bash</>, <command>zsh</>):
-->
设置共享库的搜索路径的方法因平台而异，
但是最广泛使用的方法是设置<envar>LD_LIBRARY_PATH</>环境变量，
比如在Bourne shell(<command>sh</>, <command>ksh</>, <command>bash</>, <command>zsh</>)中：

<programlisting>
LD_LIBRARY_PATH=/usr/local/pgsql/lib
export LD_LIBRARY_PATH
</programlisting>
    <!--
    or in <command>csh</> or <command>tcsh</>:
-->
在<command>csh</>或者<command>tcsh</>中：

<programlisting>
setenv LD_LIBRARY_PATH /usr/local/pgsql/lib
</programlisting>
   <!--
    Replace <literal>/usr/local/pgsql/lib</> with whatever you set
    <option><literal>&#045;-libdir</></> to in <xref linkend="configure">.
    You should put these commands into a shell start-up file such as
    <filename>/etc/profile</> or <filename>~/.bash_profile</>.  Some
    good information about the caveats associated with this method can
    be found at <ulink
    url="http://xahlee.org/UnixResource_dir/_/ldpath.html"></ulink>.
-->
把 <literal>/usr/local/pgsql/lib</>换成你在<xref linkend="configure">设置的<option><literal>--libdir</></>。
你应该把这些命令放到启动文件，如<filename>/etc/profile</>或者<filename>~/.bash_profile</>里面。
和这个方法相关的一些注意事项和很好的信息可以在<ulink url="http://xahlee.org/UnixResource_dir/_/ldpath.html"></ulink>找到。
   </para>

   <!--
<para>
    On some systems it might be preferable to set the environment
    variable <envar>LD_RUN_PATH</envar> <emphasis>before</emphasis>
    building.
   </para>
-->
<para>
    在有些系统上，更好的方法可能是在编译<emphasis>之前</emphasis>设置<envar>LD_RUN_PATH</envar>环境变量。
</para>

   <!--
<para>
    On <systemitem class="osname">Cygwin</systemitem>, put the library
    directory in the <envar>PATH</envar> or move the
    <filename>.dll</filename> files into the <filename>bin</filename>
    directory.
   </para>
-->
<para>
   在<systemitem class="osname">Cygwin</systemitem>里，
   把库目录放在<envar>PATH</envar>或者把<filename>.dll</filename>文件移动到<filename>bin</filename>目录。
</para>

   
<para>
    <!--
    If in doubt, refer to the manual pages of your system (perhaps
    <command>ld.so</command> or <command>rld</command>). If you later
    get a message like:
-->
如果有疑问，请参考系统的手册页(可能是 ld.so 或 rld)。如果稍后你收到下面这样的信息：
<screen>
psql: error in loading shared libraries
libpq.so.2.1: cannot open shared object file: No such file or directory
</screen>
    <!--
    then this step was necessary.  Simply take care of it then.
-->
那么这一步就是必须的了。只需关注一下就是了。
   </para>
  
<para>
    <indexterm>
     <primary>ldconfig</primary>
    </indexterm>
 <!--
    If you are on <systemitem class="osname">Linux</> and you have root
    access, you can run:
-->
如果你的系统是<systemitem class="osname">Linux</>并且你还有root权限，
那么你可以运行：

<programlisting>
/sbin/ldconfig /usr/local/pgsql/lib
</programlisting>
    <!--
    (or equivalent directory) after installation to enable the
    run-time linker to find the shared libraries faster.  Refer to the
    manual page of <command>ldconfig</> for more information.  On
    <systemitem class="osname">FreeBSD</>, <systemitem
    class="osname">NetBSD</>, and <systemitem
    class="osname">OpenBSD</> the command is:
-->
(或者相应的目录)以便让运行时链接器更快地找到共享库。
请参考<command>ldconfig</>的手册页获取更多信息。
在<systemitem class="osname">FreeBSD</>, <systemitem
    class="osname">NetBSD</>和<systemitem class="osname">OpenBSD</>上，命令是：

<programlisting>
/sbin/ldconfig -m /usr/local/pgsql/lib
</programlisting>
     <!--
    instead.  Other systems are not known to have an equivalent
    command.
-->
我们不知道其它系统有什么等效命令。
   </para>


  </sect2>

  <sect2>
  <!--
   <title>Environment Variables</title>
   -->
    <title>环境变量</title>

   <indexterm>
    <primary><envar>PATH</envar></primary>
   </indexterm>

   <!--
<para>
    If you installed into <filename>/usr/local/pgsql</> or some other
    location that is not searched for programs by default, you should
    add <filename>/usr/local/pgsql/bin</> (or whatever you set
    <option><literal>&#045;-bindir</></> to in <xref linkend="configure">)
    into your <envar>PATH</>.  Strictly speaking, this is not
    necessary, but it will make the use of <productname>PostgreSQL</>
    much more convenient.
   </para>
-->
<para>
   如果你安装到<filename>/usr/local/pgsql</>或者其它什么缺省时不搜索程序的地方，
   那你应该增加一个<filename>/usr/local/pgsql/bin</>
   (或者是你在<xref linkend="configure">中给你的<envar>PATH</>设置<option><literal>--bindir</></>的值)。
   严格说，这些都不是必须的，
   但这么做可以让你使用<productname>PostgreSQL</>更方便。
</para>

 
<para>
   <!--
    To do this, add the following to your shell start-up file, such as
    <filename>~/.bash_profile</> (or <filename>/etc/profile</>, if you
    want it to affect all users):
-->
要做这些事情，把下面几行加到shell启动文件，
如<filename>~/.bash_profile</>或者<filename>/etc/profile</>(如果你想影响所有用户)：

<programlisting>
PATH=/usr/local/pgsql/bin:$PATH
export PATH
</programlisting>
    <!--
    If you are using <command>csh</> or <command>tcsh</>, then use this command:
-->
如果你用的是<command>csh</>或者<command>tcsh</>，那么用这条命令：
<programlisting>
set path = ( /usr/local/pgsql/bin $path )
</programlisting>
   </para>
   
<para>
    <indexterm>
     <primary><envar>MANPATH</envar></primary>
    </indexterm>
<!--
    To enable your system to find the <application>man</>
    documentation, you need to add lines like the following to a
    shell start-up file unless you installed into a location that is
    searched by default:
-->
为了让系统找得到<application>man</>文档，
你需要加类似下面的一行到一个shell启动文件里(除非你安装到了缺省时搜索的位置)：

<programlisting>
MANPATH=/usr/local/pgsql/man:$MANPATH
export MANPATH
</programlisting>
   </para>

   <!--
<para>
    The environment variables <envar>PGHOST</> and <envar>PGPORT</>
    specify to client applications the host and port of the database
    server, overriding the compiled-in defaults. If you are going to
    run client applications remotely then it is convenient if every
    user that plans to use the database sets <envar>PGHOST</>.  This
    is not required, however; the settings can be communicated via command
    line options to most client programs.
   </para>
-->
<para>
    环境变量<envar>PGHOST</>和<envar>PGPORT</>为客户端应用声明了数据库服务器的主机和端口，
覆盖了那些编译时的缺省项。如果你想从远端运行客户端应用，
那么每个准备使用该数据库的用户都设置<envar>PGHOST</>将会非常方便。
但这不是必须的，而且大部分客户端程序也可以通过命令行选项替换这些设置。
</para>
  </sect2>
 </sect1>


<![%standalone-include;[
 <sect1 id="install-getting-started">
 <!--
  <title>Getting Started</title>
  -->
  <title>入门</title>

  <!--
<para>
   The following is a quick summary of how to get <productname>PostgreSQL</> up and
   running once installed. The main documentation contains more information.
  </para>
-->
<para>
   以下是<productname>PostgreSQL</>在安装后，如何使用的快速总结。主文档包含更多信息。
</para>

  <procedure>
   <step>
    
<para>
     <!--
     Create a user account for the <productname>PostgreSQL</>
     server. This is the user the server will run as. For production
     use you should create a separate, unprivileged account
     (<quote>postgres</> is commonly used). If you do not have root
     access or just want to play around, your own user account is
     enough, but running the server as root is a security risk and
     will not work.
 -->
 为<productname>PostgreSQL</>服务器创建用户帐户。 
    使服务器在该用户下执行。对于产品的使用你应该创建一个单独的，非特权帐户（常用<quote>postgres</>）。
    如果你没有root权限或者只是想玩玩，你自己的帐户就足够了，
    但使用root权限运行服务器存在安全风险，并且将无法正常工作。
<screen>
<userinput>adduser postgres</>
</screen>
    </para>

   </step>

   <step>
   
<para>
     <!--
     Create a database installation with the <command>initdb</>
     command. To run <command>initdb</> you must be logged in to your
     <productname>PostgreSQL</> server account. It will not work as
     root.
 -->
 使用<command>initdb</>命令创建数据库。为了运行<command>initdb</>，你必须登录到您的 
     <productname>PostgreSQL</>服务器帐户。作为root将无法正常工作。
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</>
root# <userinput>chown postgres /usr/local/pgsql/data</>
root# <userinput>su - postgres</>
postgres$ <userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
</screen>
    </para>
    <!--
<para>
     The <option>-D</> option specifies the location where the data
     will be stored. You can use any path you want, it does not have
     to be under the installation directory. Just make sure that the
     server account can write to the directory (or create it, if it
     doesn't already exist) before starting <command>initdb</>, as
     illustrated here.
    </para>
-->
<para>
   该<option>-D</>选项指定数据的存储位置。
   你可以使用任何你想要的路径，但不应在安装目录下。
   只要确保在执行<command>initdb</>之前，服务器帐户可以写入目录（如果它不存在，创建它），
   正如这里说明的：
</para>
   </step>

   <step>
    <!--
<para>
     At this point, if you did not use the <command>initdb</> <literal>-A</>
     option, you might want to modify <filename>pg_hba.conf</> to control
     local access to the server before you start it.  The default is to
     trust all local users.
    </para>
-->
<para>
    在这一点上，如果你没有使用<command>initdb</> <literal>-A</>选项，
在开始服务之前，你可能要修改<filename>pg_hba.conf</>来控制对本地服务器的访问。
缺省值是trust所有本地用户。
</para>
   </step>

   <step>
  
<para>
      <!--
     The previous <command>initdb</> step should have told you how to
     start up the database server. Do so now. The command should look
     something like:
 -->
 前面的<command>initdb</>应该已经告诉你如何 
     启动数据库服务器了。现在开始做。该命令看起来像：

<programlisting>
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
</programlisting>
     <!--
     This will start the server in the foreground. To put the server
     in the background use something like:
 -->
 这将在前端启动服务器。把服务器放在后台使用是这样的：
<programlisting>
nohup /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data \
    &lt;/dev/null &gt;&gt;server.log 2&gt;&amp;1 &lt;/dev/null &amp;
</programlisting>
    </para>
    
<para>
    <!--
     To stop a server running in the background you can type:
 --> 
 要停止后台运行的服务器，您可以输入：
<programlisting>
kill `cat /usr/local/pgsql/data/postmaster.pid`
</programlisting>
    </para>

   </step>

   <step>
    
<para>
    <!--
     Create a database:
 -->
 创建数据库：
<screen>
<userinput>createdb testdb</>
</screen>
     <!--
     Then enter:
 -->
 然后键入：
<screen>
<userinput>psql testdb</>
</screen>
    <!--
     to connect to that database. At the prompt you can enter SQL
     commands and start experimenting.
 --> 
 连接到该数据库。在提示符下你可以输入SQL命令，并且开始试验。
    </para>

   </step>
  </procedure>
 </sect1>

 <sect1 id="install-whatnow">
  <!--
  <title>What Now?</title>
  -->
  <title>现在做什么?</title>

 
<para>
   <itemizedlist>
    <listitem>
     <para>
  <!--
      The <productname>PostgreSQL</> distribution contains a
      comprehensive documentation set, which you should read sometime.
      After installation, the documentation can be accessed by
      pointing your browser to
      <filename>/usr/local/pgsql/doc/html/index.html</>, unless you
      changed the installation directories.
  -->
  该<productname>PostgreSQL</>发行版包含全面的文档集，
  某个时候你应该阅读下。安装完成后，文档可以通过将浏览器指向 
      <filename>/usr/local/pgsql/doc/html/index.html</>进行访问，除非你更改了安装目录。
     </para>
     <!--
<para>
      The first few chapters of the main documentation are the Tutorial,
      which should be your first reading if you are completely new to
      <acronym>SQL</> databases.  If you are familiar with database
      concepts then you want to proceed with part on server
      administration, which contains information about how to set up
      the database server, database users, and authentication.
     </para>
-->
<para>
   主文档的前几章都是教程，
   如果你是刚刚接触<acronym>SQL</>数据库的话，你应该首先阅读这些章节。
   如果你已非常熟悉数据库的概念了，那么你可以继续掌握服务器管理相关的内容，
   包含如何设置数据库服务器，数据库用户和身份验证的信息。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Usually, you will want to modify your computer so that it will
      automatically start the database server whenever it boots. Some
      suggestions for this are in the documentation.
     </para>
-->
<para>
   通常情况下，你想通过修改您的电脑，使得在它启动时，能够自动启动数据库服务器。
   在文档中有一些相关的建议。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Run the regression tests against the installed server (using
      <command>make installcheck</command>). If you didn't run the
      tests before installation, you should definitely do it now. This
      is also explained in the documentation.
     </para>
-->
<para>
    在安装的服务器中进行回归测试（使用<command>make installcheck</command>）。
如果你没有在安装前运行测试，你一定要现在就做。
这在文档中也进行了解释。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      By default, <productname>PostgreSQL</> is configured to run on
      minimal hardware.  This allows it to start up with almost any
      hardware configuration. The default configuration is, however,
      not designed for optimum performance. To achieve optimum
      performance, several server parameters must be adjusted, the two
      most common being <varname>shared_buffers</varname> and
      <varname>work_mem</varname>.
      Other parameters mentioned in the documentation also affect
      performance.
     </para>
-->
<para>
    默认情况下，<productname>PostgreSQL</>被配置为运行在最小硬件上。
这使得它几乎可以在任何硬件配置下启动。然而，默认的配置没有为优化性能而设计。
 为了优化性能，很多服务器端的配置参数需要调整，
两个最常见的是<varname>shared_buffers</varname>和<varname>work_mem</varname>。 
    文档中提及的其他参数也会影响性能。
</para>
    </listitem>
   </itemizedlist>
  </para>
 </sect1>
]]>


 <sect1 id="supported-platforms">
  <!--
  <title>Supported Platforms</title>
  -->
  <title>支持的平台</title>

  <!--
<para>
   A platform (that is, a CPU architecture and operating system combination)
   is considered supported by the <productname>PostgreSQL</> development
   community if the code contains provisions to work on that platform and
   it has recently been verified to build and pass its regression tests
   on that platform.  Currently, most testing of platform compatibility
   is done automatically by test machines in the
   <ulink url="http://buildfarm.postgresql.org/">PostgreSQL Build Farm</ulink>.
   If you are interested in using <productname>PostgreSQL</> on a platform
   that is not represented in the build farm, but on which the code works
   or can be made to work, you are strongly encouraged to set up a build
   farm member machine so that continued compatibility can be assured.
  </para>
-->
<para>
   如果代码包含工作平台的规定，且最近通过回归测试在该平台上进行了验证，
   那么该平台被认为是由<productname>PostgreSQL</>开发社区支持的。
  目前，大部分的平台兼容性的测试在<ulink url="http://buildfarm.postgresql.org/">PostgreSQL Build Farm</ulink>上的测试机中自动完成。 
  如果您有兴趣在一个bulid farm中未出现的平台上使用<productname>PostgreSQL</>，
  且在该平台上代码能够工作或者通过其他手段使它能够工作时，我们强烈建议你建立一个bulid farm成员机器，
  这样可以保证持续兼容性。
</para>

  <!--
<para>
   In general, <productname>PostgreSQL</> can be expected to work on
   these CPU architectures: x86, x86_64, IA64, PowerPC,
   PowerPC 64, S/390, S/390x, Sparc, Sparc 64, Alpha, ARM, MIPS, MIPSEL, M68K,
   and PA-RISC.  Code support exists for M32R and VAX, but these
   architectures are not known to have been tested recently.  It is often
   possible to build on an unsupported CPU type by configuring with
   <option>&#045;-disable-spinlocks</option>, but performance will be poor.
  </para>
-->
<para>
   在一般情况下，可以期待<productname>PostgreSQL</>工作在这些架构的CPU上：x86, x86_64, IA64, PowerPC,
   PowerPC 64, S/390, S/390x, Sparc, Sparc 64, Alpha, ARM, MIPS, MIPSEL, M68K,
   和PA-RISC。存在M32R和VAX代码的支持，
   但这些架构上尚未测试过。
   往往可以通过配置<option>--disable-spinlocks</option>编译不支持的CPU类型， 
   但性能会很差。
</para>

  <!--
<para>
   <productname>PostgreSQL</> can be expected to work on these operating
   systems: Linux (all recent distributions), Windows (Win2000 SP4 and later),
   FreeBSD, OpenBSD, NetBSD, OS X, AIX, HP/UX, Solaris, Tru64 Unix,
   and UnixWare.  Other Unix-like systems may also work but are not currently
   being tested.  In most cases, all CPU architectures supported by
   a given operating system will work.  Look in
   the <xref linkend="installation-platform-notes"> below to see if
   there is information
   specific to your operating system, particularly if using an older system.
  </para>
-->
<para>
   可以期待<productname>PostgreSQL</>工作在这些操作系统上：
   Linux（所有近期发行的），Windows（Win2000 SP4和更高版本）， 
   FreeBSD, OpenBSD, NetBSD, OS X, AIX, HP/UX, Solaris, Tru64 Unix,
   和UnixWare。其它类Unix系统上也可以工作，但目前尚未被测试。
   在大多数情况下，一个特定的操作系统支持的所有的CPU架构都能够工作。
   查看<xref linkend="installation-platform-notes">，看是否 
   有声明您的操作系统的信息，特别是如果使用的是旧系统。
</para>

  <!--
<para>
   If you have installation problems on a platform that is known
   to be supported according to recent build farm results, please report
   it to <email>pgsql-bugs@postgresql.org</email>.  If you are interested
   in porting <productname>PostgreSQL</> to a new platform,
   <email>pgsql-hackers@postgresql.org</email> is the appropriate place
   to discuss that.
  </para>
-->
<para>
   如果你在某个平台上遇到了安装问题，且根据近期的build farm验证结果，该平台被验证为支持的情况下，
   请向<email>pgsql-bugs@postgresql.org</email>报告问题。
   如果你有兴趣移植<productname>PostgreSQL</>到一个新的平台， 
   <email>pgsql-hackers@postgresql.org</email>是讨论这类问题的合适地方。
</para>
 </sect1>

 <sect1 id="installation-platform-notes">
 <!--
  <title>Platform-specific Notes</title>
  -->
  <title>特定平台注意事项</title>

  <!--
<para>
   This section documents additional platform-specific issues
   regarding the installation and setup of PostgreSQL.  Be sure to
   read the installation instructions, and in
   particular <xref linkend="install-requirements"> as well.  Also,
   check <![%standalone-include[the
   file <filename>src/test/regress/README</> and the documentation]]>
   <![%standalone-ignore[<xref linkend="regress">]]> regarding the
   interpretation of regression test results.
  </para>
-->
<para>
   这部分提供额外的关于PostgreSQL的安装和设置的特定平台的问题。 
   一定要阅读安装说明，尤其是<xref linkend="install-requirements">。 
   另外，检查<![%standalone-include[the
   file <filename>src/test/regress/README</> and the documentation]]>
   <![%standalone-ignore[<xref linkend="regress">]]>有关回归测试结果的说明。
</para>

  <!--
<para>
   Platforms that are not covered here have no known platform-specific
   installation issues.
  </para>
-->
<para>
    此处未覆盖的平台没有已知的特定平台安装问题。
</para>

  <sect2 id="installation-notes-aix">
   <title>AIX</title>

   <indexterm zone="installation-notes-aix">
    <primary>AIX</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL works on AIX, but getting it installed properly can be
    challenging.  AIX versions from 4.3.3 to 6.1 are considered supported.
    You can use GCC or the native IBM compiler <command>xlc</command>.  In
    general, using recent versions of AIX and PostgreSQL helps.  Check
    the build farm for up to date information about which versions of
    AIX are known to work.
   </para>
-->
<para>
   PostgreSQL工作在AIX上，但正确安装它具有挑战性。 
   支持AIX 4.3.3到6.1版本。
   您可以使用GCC或本机的IBM编译器<command>xlc</command>。
   一般情况下，采用近期版本的AIX和PostgreSQL会有所帮助。
   检查bulid farm获得最新的支持的AIX版本信息。
</para>

   <!--
<para>
    The minimum recommended fix levels for supported AIX versions are:
   </para>
-->
<para>
    为支持的AIX版本推荐的最低修复级别是：
</para>

   <variablelist>
    <varlistentry>
     <term>AIX 4.3.3</term>
     <listitem><para>Maintenance Level 11 + post ML11 bundle</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.1</term>
     <listitem><para>Maintenance Level 9 + post ML9 bundle</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.2</term>
     <listitem><para>Technology Level 10 Service Pack 3</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.3</term>
     <listitem><para>Technology Level 7</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 6.1</term>
     <listitem><para>Base Level</para></listitem>
    </varlistentry>
   </variablelist>

   <!--
<para>
    To check your current fix level, use
    <command>oslevel -r</command> in AIX 4.3.3 to AIX 5.2 ML 7, or
    <command>oslevel -s</command> in later versions.
   </para>
-->
<para>
   查看当前修复级别，使用AIX 4.3.3到AIX 5.2 ML7中的 
   <command>oslevel -r</command>，或者更高版本的
   <command>oslevel -s</command>。
</para>

   <!--
<para>
    Use the following <command>configure</command> flags in addition
    to your own if you have installed Readline or libz in
    <literal>/usr/local</>:
    <literal>&#045;-with-includes=/usr/local/include
    &#045;-with-libraries=/usr/local/lib</literal>.
   </para>
-->
<para>
    如果你在<literal>/usr/local</>中已经安装了Readline或者libz，
    在你自己的选项外，请使用以下的<command>configure</command>选项： 
    <literal>--with-includes=/usr/local/include
    --with-libraries=/usr/local/lib</literal>。
</para>

   <sect3>
   <!--
    <title>GCC Issues</title>
-->
<title>GCC问题</title>

    <!--
<para>
     On AIX 5.3, there have been some problems getting PostgreSQL to
     compile and run using GCC.
    </para>
-->
<para>
    在AIX 5.3上，使用GCC时PostgreSQL的编译以及运行存在一些问题。
</para>

    <!--
<para>
     You will want to use a version of GCC subsequent to 3.3.2,
     particularly if you use a prepackaged version.  We had good
     success with 4.0.1.  Problems with earlier versions seem to have
     more to do with the way IBM packaged GCC than with actual issues
     with GCC, so that if you compile GCC yourself, you might well
     have success with an earlier version of GCC.
    </para>
-->
<para>
     您想要使用之后的GCC 3.3.2的版本，特别是如果你使用一个预先打包的版本。
     我们在使用4.0.1时很成功。比起GCC的实际问题来说，早期版本问题似乎与IBM包装GCC有更大关系，
     因此，如果你自己编译GCC，使用GCC早期版本你也可能成功。
</para>
   </sect3>

   <sect3>
   <!--
    <title>Unix-Domain Sockets Broken</title>
-->
<title>Unix-域套接字中断</title>

    <!--
<para>
     AIX 5.3 has a problem
     where <structname>sockaddr_storage</structname> is not defined to
     be large enough.  In version 5.3, IBM increased the size of
     <structname>sockaddr_un</structname>, the address structure for
     Unix-domain sockets, but did not correspondingly increase the
     size of <structname>sockaddr_storage</structname>.  The result of
     this is that attempts to use Unix-domain sockets with PostgreSQL
     lead to libpq overflowing the data structure.  TCP/IP connections
     work OK, but not Unix-domain sockets, which prevents the
     regression tests from working.
    </para>
-->
<para>
    AIX 5.3有一个问题，其中<structname>sockaddr_storage</structname>没有被定义为足够大。
在5.3版本中，IBM增加了<structname>sockaddr_un</structname>（Unix域套接字的地址结构）的大小，
但并没有相应地增加<structname>sockaddr_storage</structname>的大小。
这样的结果是试图使用Unix域套接字与PostgreSQL时，导致libpq溢出的数据结构。
TCP/IP连接工作正常，但不是Unix域套接字，以防止回归测试工作。
</para>

    <!--
<para>
     The problem was reported to IBM, and is recorded as bug report
     PMR29657.  If you upgrade to maintenance level 5300-03 or later,
     that will include this fix.  A quick workaround
     is to alter <symbol>_SS_MAXSIZE</symbol> to 1025 in
     <filename>/usr/include/sys/socket.h</filename>.  In either case,
     recompile PostgreSQL once you have the corrected header file.
    </para>
-->
<para>
     这个问题已经报道给IBM，并且作为bug报告PMR29657进行记录。
 如果您升级到维护级别5300-03或更高版本，将包括此修复。
 一个快速解决方法是改变<filename>/usr/include/sys/socket.h</filename>中的
 <symbol>_SS_MAXSIZE</symbol>到1025。在这两种情况下， 
     一旦你修改了头文件，则要重新编译PostgreSQL。
</para>
   </sect3>

   <sect3>
   <!--
    <title>Internet Address Issues</title>
-->
<title>网络地址问题</title>

    <!--
<para>
     PostgreSQL relies on the system's <function>getaddrinfo</> function
     to parse IP addresses in <varname>listen_addresses</>,
     <filename>pg_hba.conf</>, etc.  Older versions of AIX have assorted
     bugs in this function.  If you have problems related to these settings,
     updating to the appropriate AIX fix level shown above
     should take care of it.
    </para>
-->
<para>
    PostgreSQL依赖于系统的<function>getaddrinfo</>函数解析<varname>listen_addresses</>，<filename>pg_hba.conf</>等中的IP地址， 
较旧版本的AIX已经划分出这个函数中的bug。
如果您有关于这些设置的问题，
更新到上面显示的相应的AIX修复级别应特别注意。
</para>

    <!-- http://archives.postgresql.org/message-id/6064jt6cfm.fsf_-_@dba2.int.libertyrms.com -->

    <!--
<para>
     One user reports:
    </para>
-->
<para>
    一个用户报告：
</para>

    <!--
<para>
     When implementing PostgreSQL version 8.1 on AIX 5.3, we
     periodically ran into problems where the statistics collector
     would <quote>mysteriously</quote> not come up successfully.  This
     appears to be the result of unexpected behavior in the IPv6
     implementation.  It looks like PostgreSQL and IPv6 do not play
     very well together on AIX 5.3.
    </para>
-->
<para>
    当在AIX 5.3上使用PostgreSQL版本8.1的时候，
我们周期性地遇到了问题，
其中统计收集器可能<quote>莫名其妙</quote>的失败。 
这似乎是IPv6实行中意外行为的结果。
它看起来像PostgreSQL和IPv6在AIX 5.3中不能很好地兼容。
</para>

    
<para>
    <!--
     Any of the following actions <quote>fix</quote> the problem.
 -->
 下面的任意一个操作可以<quote>修复</quote>这个问题。
     <itemizedlist>
      <listitem>
       <para>
   <!--
        Delete the IPv6 address for localhost:
-->
删除本地主机的IPv6地址：
<screen>
(as root)
# ifconfig lo0 inet6 ::1/0 delete
</screen>
       </para>

      </listitem>

      <listitem>
      
<para>
        <!--
        Remove IPv6 from net services.  The
        file <filename>/etc/netsvc.conf</filename> on AIX is roughly
        equivalent to <filename>/etc/nsswitch.conf</filename> on
        Solaris/Linux.  The default, on AIX, is thus:
-->
从网络服务中删除IPv6。在AIX上的文件<filename>/etc/netsvc.conf</filename>大致 
        等同于Solaris/Linux上的<filename>/etc/nsswitch.conf</filename>。
        默认情况下，AIX上是这样的:
<programlisting>
hosts=local,bind
</programlisting>
        <!--
        Replace this with:
-->
替换为：
<programlisting>
hosts=local4,bind4
</programlisting>
        <!--
        to deactivate searching for IPv6 addresses.
-->
解除搜索IPv6地址。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <warning>
    <!--
<para>
     This is really a workaround for problems relating
     to immaturity of IPv6 support, which improved visibly during the
     course of AIX 5.3 releases.  It has worked with AIX version 5.3,
     but does not represent an elegant solution to the problem.  It has
     been reported that this workaround is not only unnecessary, but
     causes problems on AIX 6.1, where IPv6 support has become more mature.
    </para>
-->
<para>
    这的确是IPv6支持的不成熟问题的解决方法，
这在AIX 5.3版本中有明显改善。
该方法在AIX 5.3版本中被实施，但并不是一个优雅的解决问题的办法。
报道称这种解决方法不仅是不必要的，而且会在AIX 6.1上导致问题，
其中IPv6的支持日渐成熟。
</para>
    </warning>

   </sect3>

   <sect3>
   <!--
    <title>Memory Management</title>
-->
 <title>内存管理</title>
    <!-- http://archives.postgresql.org/message-id/603bgqmpl9.fsf@dba2.int.libertyrms.com -->

    
<para>
     <!--
     AIX can be somewhat peculiar with regards to the way it does
     memory management.  You can have a server with many multiples of
     gigabytes of RAM free, but still get out of memory or address
     space errors when running applications.  One example
     is <command>createlang</command> failing with unusual errors.
     For example, running as the owner of the PostgreSQL installation:
 -->
 AIX关于内存管理方式上有些特别。
 你可以有很多倍MB的RAM空闲的服务器，
 但是当运行应用程序时，仍然有内存或地址空间不足的错误。
 一个例子是<command>createlang</command>发生不寻常错误的例子。 
 比如，作为PostgreSQL安装的所有者运行：
<screen>
-bash-3.00$ createlang plperl template1
createlang: language installation failed: ERROR:  could not load library "/opt/dbs/pgsql748/lib/plperl.so": A memory address is not in the address space for the process.
</screen>
   <!--
    Running as a non-owner in the group possessing the PostgreSQL
    installation:
-->
作为PostgreSQL安装的非拥有者进行运行：
<screen>
-bash-3.00$ createlang plperl template1
createlang: language installation failed: ERROR:  could not load library "/opt/dbs/pgsql748/lib/plperl.so": Bad address
</screen>
     <!--
     Another example is out of memory errors in the PostgreSQL server
     logs, with every memory allocation near or greater than 256 MB
     failing.
 --> 
 另一个例子是在PostgreSQL服务器日志中内存不足的错误，
 每个内存分配接近或者大于256 MB时失败。
    </para>

    <!--
<para>
     The overall cause of all these problems is the default bittedness
     and memory model used by the server process.  By default, all
     binaries built on AIX are 32-bit.  This does not depend upon
     hardware type or kernel in use.  These 32-bit processes are
     limited to 4 GB of memory laid out in 256 MB segments using one
     of a few models.  The default allows for less than 256 MB in the
     heap as it shares a single segment with the stack.
    </para>
-->
<para>
    所有这些问题的总体原因是默认bittedness以及使用的服务器进程的内存模型。
默认情况下，所有的在AIX上编译的二进制文件是32位。
这不依赖于使用的硬件类型或内核。
这些32位进程被限制了4GB的内存消耗在段大小为256MB时使用一些模型中的一个。
默认允许少于256 MB在堆与栈共享一个段。
</para>

    <!--
<para>
     In the case of the <command>createlang</command> example, above,
     check your umask and the permissions of the binaries in your
     PostgreSQL installation.  The binaries involved in that example
     were 32-bit and installed as mode 750 instead of 755.  Due to the
     permissions being set in this fashion, only the owner or a member
     of the possessing group can load the library.  Since it isn't
     world-readable, the loader places the object into the process'
     heap instead of the shared library segments where it would
     otherwise be placed.
    </para>
-->
<para>
    在上面的<command>createlang</command>的例子中，
检查你的PostgreSQL安装中的umask和二进制文件的权限。
该示例中的二进制文件是32位的并且以权限750而不是755的模式安装。
因为权限被设置成这种模式，
只有进程组中的所有者或成员才可以加载库。
因为它不是所有人可读的，
加载器将对象放入进程堆中而不是它应该放置的共享库段中。
</para>

    <!--
<para>
     The <quote>ideal</quote> solution for this is to use a 64-bit
     build of PostgreSQL, but that is not always practical, because
     systems with 32-bit processors can build, but not run, 64-bit
     binaries.
    </para>
-->
<para>
   此问题的<quote>理想</quote>解决方案是使用64位的PostgreSQL编译，
   但事实并非总是可行的，因为32位处理器系统可以编译，
   但不能运行64位的二进制文件。
</para>

    <!--
<para>
     If a 32-bit binary is desired, set <symbol>LDR_CNTRL</symbol> to
     <literal>MAXDATA=0x<replaceable>n</replaceable>0000000</literal>,
     where 1 &lt;= n &lt;= 8, before starting the PostgreSQL server,
     and try different values and <filename>postgresql.conf</filename>
     settings to find a configuration that works satisfactorily.  This
     use of <symbol>LDR_CNTRL</symbol> tells AIX that you want the
     server to have <symbol>MAXDATA</symbol> bytes set aside for the
     heap, allocated in 256 MB segments.  When you find a workable
     configuration,
     <command>ldedit</command> can be used to modify the binaries so
     that they default to using the desired heap size.  PostgreSQL can
     also be rebuilt, passing <literal>configure
     LDFLAGS="-Wl,-bmaxdata:0x<replaceable>n</replaceable>0000000"</literal>
     to achieve the same effect.
    </para>
-->
<para>
   如果需要32位二进制文件，在启动PostgreSQL服务器之前
   设置<symbol>LDR_CNTRL</symbol>为<literal>MAXDATA=0x<replaceable>n</replaceable>0000000</literal>， 
   其中1 &lt;= n &lt;= 8，并尝试不同的值。同时设置<filename>postgresql.conf</filename>以找到合理运行的配置。
   <symbol>LDR_CNTRL</symbol>的使用告诉AIX你想要服务器给堆分配<symbol>MAXDATA</symbol>字节，分配256 MB的段。
   当你找到一个可行的配置，<command>ldedit</command>可以用来修改二进制文件， 
   这样他们会默认使用所需的堆大小。 PostgreSQL可以也被重新编译，  
   通过配置<literal>configure LDFLAGS="-Wl,-bmaxdata:0x<replaceable>n</replaceable>0000000"</literal>达到同样的效果。
</para>

    <!--
<para>
     For a 64-bit build, set <envar>OBJECT_MODE</envar> to 64 and
     pass <literal>CC="gcc -maix64"</literal>
     and <literal>LDFLAGS="-Wl,-bbigtoc"</literal>
     to <command>configure</command>.  (Options for
    <command>xlc</command> might differ.)  If you omit the export of
    <envar>OBJECT_MODE</envar>, your build may fail with linker errors.  When
    <envar>OBJECT_MODE</envar> is set, it tells AIX's build utilities
    such as <command>ar</>, <command>as</>, and <command>ld</> what
    type of objects to default to handling.
    </para>
-->
<para>
   对于64位的编译，设置<envar>OBJECT_MODE</envar>为64
   并且传递<literal>CC="gcc -maix64"</literal>和<literal>LDFLAGS="-Wl,-bbigtoc"</literal>到<command>configure</command>。 
  （<command>xlc</command>选项可能有所不同。） 
   如果你省略<envar>OBJECT_MODE</envar>的设置，
   可能产生链接错误。当<envar>OBJECT_MODE</envar>被设置的时候，
   它告诉AIX编译工具如<command>ar</>, <command>as</>和<command>ld</>
   默认处理对象的类型。
</para>

    <!--
<para>
     By default, overcommit of paging space can happen.  While we have
     not seen this occur, AIX will kill processes when it runs out of
     memory and the overcommit is accessed.  The closest to this that
     we have seen is fork failing because the system decided that
     there was not enough memory for another process.  Like many other
     parts of AIX, the paging space allocation method and
     out-of-memory kill is configurable on a system- or process-wide
     basis if this becomes a problem.
    </para>
-->
<para>
    默认情况下，可能发生分页空间过量使用。
虽然我们还没有看到这种情况发生，当进程用完内存并且产生过量访问时，AIX将杀死该进程。
最接近这一点的是我们所看到的交叉失败，因为系统认为没有足够的内存用于另一个进程。
像许多其他的AIX部分，如果产生这样的问题，那么
分页空间分配方法及内存不足杀进程在系统或进程范围基础上是可配置的。
</para>

    <bibliography>
 <!--
     <title>References and Resources</title>
 -->
  <title>参考文献和资源</title>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/lrg_prg_support.htm">Large Program Support</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/address_space.htm">Program Address Space Overview</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/resmgmt2.htm">Performance Overview of the Virtual Memory Manager (VMM)</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf7.htm">Page Space Allocation</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf6.htm">Paging-space thresholds tuning</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
       <title><ulink url="http://www.redbooks.ibm.com/abstracts/sg245674.html?Open">Developing and Porting C and C++ Applications on AIX</ulink></title>
       <publisher>
        <publishername>IBM Redbook</publishername>
       </publisher>
     </biblioentry>
    </bibliography>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-cygwin">
   <title>Cygwin</title>

   <indexterm zone="installation-notes-cygwin">
    <primary>Cygwin</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL can be built using Cygwin, a Linux-like environment for
    Windows, but that method is inferior to the native Windows build
    <![%standalone-ignore[(see <xref linkend="install-windows">)]]> and
    running a server under Cygwin is no longer recommended.
   </para>
-->
<para>
   PostgreSQL可以使用Cygwin（Windows的类Linux环境）进行编译，
   但该方法不如本地Windows编译<![%standalone-ignore[(参阅<xref linkend="install-windows">)]]>，
   并且不再推荐在Cygwin下运行服务器。
</para>

   
<para>
   <!--
    When building from source, proceed according to the normal
    installation procedure (i.e., <literal>./configure;
    make</literal>; etc.), noting the following-Cygwin specific
    differences:
    -->
当从源码进行编译时，按照正常的安装程序进行（也就是<literal>./configure;make</literal>），
注意下面的Cygwin的特殊差异：

    <itemizedlist>
     <listitem>
      <para>
  <!--
       Set your path to use the Cygwin bin directory before the
       Windows utilities.  This will help prevent problems with
       compilation.
   -->
   设定你的环境变量path，将Cygwin的bin目录设置在Windows应用之前。这有助于避免编译问题。
   
      </para>

     </listitem>



     <listitem>
      <!--
<para>
       The <command>adduser</command> command is not supported; use
       the appropriate user management application on Windows NT,
       2000, or XP.  Otherwise, skip this step.
      </para>
-->
<para>
     不支持<command>adduser</command>命令；在Windows NT,2000或者XP上使用适当的用户管理应用。否则，忽略这一步。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The <command>su</command> command is not supported; use ssh to
       simulate su on Windows NT, 2000, or XP. Otherwise, skip this
       step.
      </para>
-->
<para>
     不支持<command>su</command>命令；在Windows NT,2000或者XP上使用ssh模拟su。否则，忽略这一步。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       OpenSSL is not supported.
      </para>
-->
<para>
       不支持OpenSSL。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Start <command>cygserver</command> for shared memory support.
       To do this, enter the command <literal>/usr/sbin/cygserver
       &amp;</literal>.  This program needs to be running anytime you
       start the PostgreSQL server or initialize a database cluster
       (<command>initdb</command>).  The
       default <command>cygserver</command> configuration may need to
       be changed (e.g., increase <symbol>SEMMNS</symbol>) to prevent
       PostgreSQL from failing due to a lack of system resources.
      </para>
-->
<para>
     为了支持共享内存开启<command>cygserver</command>。 
    要做到这一点，输入命令<literal>/usr/sbin/cygserver&amp;</literal>。
    确保这个程序运行在任何当你启动PostgreSQL服务器或初始化一个数据库集群（<command>initdb</command>）的时候。
    可能需要改变默认的<command>cygserver</command>配置（例如，增加<symbol>SEMMNS</symbol>）以避免 
    由于缺乏系统资源而导致的PostgreSQL失败。
</para>
     </listitem>

     <listitem>
      <!--
<para>
        Building might fail on some systems where a locale other than
        C is in use. To fix this, set the locale to C by doing
        <command>export LANG=C.utf8</command> before building, and then
        setting it back to the previous setting, after you have installed
        PostgreSQL.
      </para>
-->
<para>
      在某些locale不是C的系统上编译可能会失败。
  为了解决这个问题，在编译之前通过执行<command>export LANG=C.utf8</command>设置locale到C，
      然后，在你安装完PostgreSQL之后，再将它设置回之前的内容。
</para>
     </listitem>

     <listitem>
      
<para>
      <!--
       The parallel regression tests (<literal>make check</literal>)
       can generate spurious regression test failures due to
       overflowing the <function>listen()</function> backlog queue
       which causes connection refused errors or hangs.  You can limit
       the number of connections using the make
       variable <varname>MAX_CONNECTIONS</varname> thus:
   -->
   由于<function>listen()</function>积压队列溢出，
   平行回归测试（<literal>make check</literal>）会产生伪回归测试失败，
   导致连接拒绝错误或挂起。
   你可以使用make变量<varname>MAX_CONNECTIONS</varname>限制连接数，因此：
   
<programlisting>
make MAX_CONNECTIONS=5 check
</programlisting>
      <!--
       (On some systems you can have up to about 10 simultaneous
       connections).
   -->
   在某些系统上你最多可以有10个并发连接。
      </para>


     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    It is possible to install <command>cygserver</command> and the
    PostgreSQL server as Windows NT services.  For information on how
    to do this, please refer to the <filename>README</filename>
    document included with the PostgreSQL binary package on Cygwin.
    It is installed in the
    directory <filename>/usr/share/doc/Cygwin</filename>.
   </para>
-->
<para>
    可以将<command>cygserver</command>和PostgreSQL服务安装成Windows NT的服务。
关于如何做的信息，请参阅包含在Cygwin上的PostgreSQL二进制包中的<filename>README</filename>文档。
    它被安装在目录<filename>/usr/share/doc/Cygwin</filename>中。
</para>
  </sect2>

  <sect2 id="installation-notes-hpux">
   <title>HP-UX</title>

   <indexterm zone="installation-notes-hpux">
    <primary>HP-UX</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL 7.3+ should work on Series 700/800 PA-RISC machines
    running HP-UX 10.X or 11.X, given appropriate system patch levels
    and build tools.  At least one developer routinely tests on HP-UX
    10.20, and we have reports of successful installations on HP-UX
    11.00 and 11.11.
   </para>
-->
<para>
   PostgreSQL 7.3+应该在运行HP-UX 10.X或者11.X的系列700/800 PA-RISC机器上工作，
   给予相应的系统补丁级别和编译工具。  
   至少有一个开发者经常在HP-UX 10.20上测试。
   并且，我们在HP-UX 11.00和11.11上有成功安装的报道。
</para>

   
<para>
   <!--
    Aside from the PostgreSQL source distribution, you will need GNU
    make (HP's make will not do), and either GCC or HP's full ANSI C
    compiler.  If you intend to build from Git sources rather than a
    distribution tarball, you will also need Flex (GNU lex) and Bison
    (GNU yacc).  We also recommend making sure you are fairly
    up-to-date on HP patches.  At a minimum, if you are building 64
    bit binaries on HP-UX 11.11 you may need PHSS_30966 (11.11) or a
    successor patch otherwise <command>initdb</command> may hang:
-->
除了PostgreSQL源代码发布外，您将需要GNU make（HP make不能执行），
以及GCC或HP的完整ANSI C 编译器。
如果你打算从Git 源代码而不是发布包编译，你还需要Flex（GNU lex）和Bison
    (GNU yacc)。我们建议你确保已经打了最新的HP补丁。至少，如果你正在HP-UX 11.11上编译64位二进制文件，您可能需要PHSS_30966 (11.11)或 
者后继补丁，否则<command>initdb</command>可能会挂起：

<literallayout>
PHSS_30966  s700_800 ld(1) and linker tools cumulative patch
</literallayout>
   <!--
    On general principles you should be current on libc and ld/dld
    patches, as well as compiler patches if you are using HP's C
    compiler.  See HP's support sites such
    as <ulink url="http://itrc.hp.com"></ulink> and
    <ulink url="ftp://us-ffs.external.hp.com/"></ulink> for free
    copies of their latest patches.
-->
一般原则，你应该经常为libc和ld/dld打补丁，正如当你使用HP C编译器时，
为其编译器打补丁一样。
请参阅HP支持网站，比如<ulink url="http://itrc.hp.com"></ulink>和
    <ulink url="ftp://us-ffs.external.hp.com/"></ulink>，免费的最新补丁副本。
   </para>

   <!--
<para>
    If you are building on a PA-RISC 2.0 machine and want to have
    64-bit binaries using GCC, you must use GCC 64-bit version. GCC
    binaries for HP-UX PA-RISC and Itanium are available from
    <ulink url="http://www.hp.com/go/gcc"></ulink>.  Don't forget to
    get and install binutils at the same time.
   </para>
-->
<para>
  如果你正在PA-RISC 2.0的机器上编译，并希望
  使用GCC获得64位的二进制文件，你必须使用GCC的64位版本。支持HP-UX PA-RISC和Itanium的GCC二进制可以从
  <ulink url="http://www.hp.com/go/gcc"></ulink>获得。不要忘了在同一时间获取并安装binutils。
</para>

   <!--
<para>
    If you are building on a PA-RISC 2.0 machine and want the compiled
    binaries to run on PA-RISC 1.1 machines you will need to specify
    <option>+DAportable</option> in <envar>CFLAGS</envar>.
   </para>
-->
<para>
    如果你在PA-RISC 2.0机器上编译，并且想让编译出的二进制文件在PA-RISC 1.1机器上运行，
    你需要在<envar>CFLAGS</envar>中指定<option>+DAportable</option>。 
</para>

  
<para>
    <!--
    If you are building on a HP-UX Itanium machine, you will need the
    latest HP ANSI C compiler with its dependent patch or successor
    patches:
-->
如果你在HP-UX Itanium机器上进行编译，你将需要带有依赖包或者继承补丁的最新HP ANSI C编译器。

<literallayout>
PHSS_30848  s700_800 HP C Compiler (A.05.57)
PHSS_30849  s700_800 u2comp/be/plugin library Patch
</literallayout>
   </para>



   
<para>
    <!--
    If you have both HP's C compiler and GCC's, then you might want to
    explicitly select the compiler to use when you
    run <command>configure</command>:
-->
如果你同时有HP和GCC的C编译器，那么当你运行<command>configure</command>时，可能想要明确选择使用的编译器。
<programlisting>
./configure CC=cc
</programlisting>
    <!--
    for HP's C compiler, or
-->
使用HP的C编译器，或者
<programlisting>
./configure CC=gcc
</programlisting>
   <!--   
    for GCC.  If you omit this setting, then configure will
    pick <command>gcc</command> if it has a choice.
-->
使用GCC的。如果你忽略这些设置，那么如果可选的话，configure将选择<command>gcc</command>。
   </para>



   <!--
<para>
    The default install target location
    is <filename>/usr/local/pgsql</filename>, which you might want to
    change to something under <filename>/opt</filename>.  If so, use
    the
    <option>&#045;-prefix</option> switch to <command>configure</command>.
   </para>
-->
<para>
    缺省的安装目录是<filename>/usr/local/pgsql</filename>，你可能想要把<filename>/opt</filename>下的一些内容换到那里去。
如果这样，使用<option>--prefix</option>切换<command>configure</command>。
</para>

   <!--
<para>
    In the regression tests, there might be some low-order-digit
    differences in the geometry tests, which vary depending on which
    compiler and math library versions you use.  Any other error is
    cause for suspicion.
   </para>
-->
<para>
    在回归测试中，可能有一些几何测试中的低位数有差异，这取决于您使用的编译器和数学库的版本。
任何其他的错误都值得怀疑。
</para>
  </sect2>


  <sect2 id="installation-notes-mingw">
   <title>MinGW/Native Windows</title>

   <indexterm zone="installation-notes-mingw">
    <primary>MinGW</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL for Windows can be built using MinGW, a Unix-like build
    environment for Microsoft operating systems, or using
    Microsoft's <productname>Visual C++</productname> compiler suite.
    The MinGW build variant uses the normal build system described in
    this chapter; the Visual C++ build works completely differently
    and is described in <![%standalone-include[the
    documentation]]><![%standalone-ignore[<xref linkend="install-windows">]]>.
    It is a fully native build and uses no additional software like
    MinGW.  A ready-made installer is available on the main
    PostgreSQL web site.
   </para>
-->
<para>
    Windows下的PostgreSQL可以使用MinGW编译（微软操作系统上的类Unix编译环境），或者使用
    微软的<productname>Visual C++</productname>编译器套件编译。
    MinGW的编译采用本章中描述的通常的编译系统; 
    Visual C++编译工作完全不同，在<![%standalone-include[the
    documentation]]><![%standalone-ignore[<xref linkend="install-windows">]]>中描述。
它完全是一种本地编译，并且没有使用像MinGW的额外软件。
现成的安装程序可以从PostgreSQL的网站上获得。
</para>

   <!--
<para>
    The native Windows port requires a 32 or 64-bit version of Windows
    2000 or later. Earlier operating systems do
    not have sufficient infrastructure (but Cygwin may be used on
    those).  MinGW, the Unix-like build tools, and MSYS, a collection
    of Unix tools required to run shell scripts
    like <command>configure</command>, can be downloaded
    from <ulink url="http://www.mingw.org/"></ulink>.  Neither is
    required to run the resulting binaries; they are needed only for
    creating the binaries.
   </para>
-->
<para>
    本地Windows端口需要32或64位版本的Windows 2000或更高版本。早期操作系统 
    没有足够的基础设施（但Cygwin可能被使用）。
MinGW，类Unix编译工具，以及MSYS，这些Unix工具集合 
    在运行像<command>configure</command>这样的shell脚本时是需要的，
可以从<ulink url="http://www.mingw.org/"></ulink>下载。
两者在运行生成的二进制文件时不需要;
他们只在创建二进制文件时需要。
</para>

   <!--
<para>
     To build 64 bit binaries using MinGW, install the 64 bit tool set
     from <ulink url="http://mingw-w64.sourceforge.net/"></ulink>, put its bin
     directory in the <envar>PATH</envar>, and run
     <command>configure</command> with the
     <command>&#045;-host=x86_64-w64-mingw</command> option.
   </para>
-->
<para>
    使用MinGW编译64位的二进制文件时，安装来自<ulink url="http://mingw-w64.sourceforge.net/"></ulink>的64位工具集，
将其bin目录放在<envar>PATH</envar>中，
并在运行<command>configure</command>命令时，指定<command>--host=x86_64-w64-mingw</command>选项。
</para>

   <!--
<para>
    After you have everything installed, it is suggested that you
    run <application>psql</application>
    under <command>CMD.EXE</command>, as the MSYS console has
    buffering issues.
   </para>
-->
<para>
   您已经安装了一切之后，建议您在<command>CMD.EXE</command>下运行<application>psql</application>，
   MSYS控制台有缓冲问题。
</para>

   <sect3 id="windows-crash-dumps">
   <!--
    <title>Collecting Crash Dumps on Windows</title>
-->
<title>Windows上崩溃Dump的搜集</title>

    <!--
<para>
     If PostgreSQL on Windows crashes, it has the ability to generate
     <productname>minidumps</> that can be used to track down the cause
     for the crash, similar to core dumps on Unix. These dumps can be
     read using the <productname>Windows Debugger Tools</> or using
     <productname>Visual Studio</>. To enable the generation of dumps
     on Windows, create a subdirectory named <filename>crashdumps</filename>
     inside the cluster data directory. The dumps will then be written
     into this directory with a unique name based on the identifier of
     the crashing process and the current time of the crash.
    </para>
-->
<para>
    如果PostgreSQL在Windows上崩溃，有可能产生<productname>minidumps</>可用于跟踪崩溃的原因，
类似于在Unix上的core dump。这些dump可以使用<productname>Windows调试器工具</>或者<productname>Visual Studio</>读取。
 为了让Windows上Dump生成功能有效，
 需要在集群数据目录里创建名为<filename>crashdumps</filename>的子目录。
 Dump文件之后将被写入到该目录，基于崩溃进程的识别符和崩溃的当前时间保证dump文件名称的唯一。 
</para>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-sco">
  <!--
   <title>SCO OpenServer and SCO UnixWare</title>
   -->
   <title>SCO OpenServer和SCO UnixWare</title>

   <indexterm zone="installation-notes-sco">
    <primary>SCO</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <indexterm zone="installation-notes-sco">
    <primary>UnixWare</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL can be built on SCO UnixWare 7 and SCO OpenServer 5.
    On OpenServer, you can use either the OpenServer Development Kit
    or the Universal Development Kit.  However, some tweaking may be
    needed, as described below.
   </para>
-->
<para>
    PostgreSQL可以在SCO UnixWare 7和SCO OpenServer 5上编译。在OpenServer上，
你可以使用OpenServer Development Kit或者Universal Development Kit。
然而，可能需要一些调整，正如下面描述的。
</para>

   <sect3>
    <title>Skunkware</title>

    <!--
<para>
     You should locate your copy of the SCO Skunkware CD.  The
     Skunkware CD is included with UnixWare 7 and current versions of
     OpenServer 5.  Skunkware includes ready-to-install versions of
     many popular programs that are available on the Internet.  For
     example, gzip, gunzip, GNU Make, Flex, and Bison are all
     included.  For UnixWare 7.1, this CD is now labeled "Open License
     Software Supplement".  If you do not have this CD, the software
     on it is available
     from <ulink url="http://www.sco.com/skunkware/"></ulink>.
    </para>
-->
<para>
    你应该找到你的SCO Skunkware CD的副本。
Skunkware CD附带UnixWare 7和OpenServer 5当前版本。
Skunkware包括可从互联网获得的许多流行程序的准备安装版本。 
例如，包含gzip, gunzip, GNU Make, Flex和Bison。
对于UnixWare 7.1，这个光盘现在标有"开放式许可软件补充"，如果你没有这个光盘， 
可以从<ulink url="http://www.sco.com/skunkware/"></ulink>获得。
</para>

    <!--
<para>
     Skunkware has different versions for UnixWare and OpenServer.
     Make sure you install the correct version for your operating
     system, except as noted below.
    </para>
-->
<para>
   Skunkware有UnixWare和OpenServer的不同版本。 
   请确保您为您的操作系统安装了的正确版本，除非有如下说明。
</para>

    <!--
<para>
     On UnixWare 7.1.3 and beyond, the GCC compiler is included on the
     UDK CD as is GNU Make.
    </para>
-->
<para>
    在UnixWare 7.1.3及以上，包含在UDK CD上的GCC编译器作为GNU Make。
</para>
   </sect3>

   <sect3>
    <title>GNU Make</title>

    <!--
<para>
     You need to use the GNU Make program, which is on the Skunkware
     CD.  By default, it installs
     as <filename>/usr/local/bin/make</filename>.
    </para>
-->
<para>
    您需要使用GNU make程序，位于Skunkware
    CD上。默认情况下，它被安装成<filename>/usr/local/bin/make</filename>。
</para>

    <!--
<para>
     As of UnixWare 7.1.3 and above, the GNU Make program is the
     OSTK portion of the UDK CD, and is
     in <filename>/usr/gnu/bin/gmake</filename>.
    </para>
-->
<para>
     由于UnixWare 7.1.3及以上，GNU Make程序是UDK CD的OSTK部分，
 并且位于<filename>/usr/gnu/bin/gmake</filename>。
</para>
   </sect3>

   <sect3>
    <title>Readline</title>

    <!--
<para>
     The Readline library is on the Skunkware CD.  But it is not
     included on the UnixWare 7.1 Skunkware CD.  If you have the
     UnixWare 7.0.0 or 7.0.1 Skunkware CDs, you can install it from
     there.  Otherwise,
     try <ulink url="http://www.sco.com/skunkware/"></ulink>.
    </para>
-->
<para>
    Readline库在Skunkware CD上。但它不包括在UnixWare 7.1 Skunkware CD上。如果你有UnixWare 7.0.0或者7.0.1 Skunkware CD，您可以从那里安装。
    否则，尝试<ulink url="http://www.sco.com/skunkware/"></ulink>。
</para>

    
<para>
    <!--
     By default, Readline installs into <filename>/usr/local/lib</> and
     <filename>/usr/local/include</>.  However, the
     PostgreSQL <command>configure</command> program will not find it
     there without help.  If you installed Readline, then use the
     following options to <command>configure</command>:
 -->
 缺省情况下，Readline安装在<filename>/usr/local/lib</>和
     <filename>/usr/local/include</>。
 然而，没有帮助的情况下PostgreSQL <command>configure</command>程序找不到它。
 如果你安装了Readline,那么使用<command>configure</command>的下列选项：
 
<programlisting>
./configure --with-libraries=/usr/local/lib --with-includes=/usr/local/include
</programlisting>
    </para>


   </sect3>

   <sect3>
   <!--
    <title>Using the UDK on OpenServer</title>
-->
<title>在OpenServer上使用UDK</title>

    
<para>
    <!--
     If you are using the new Universal Development Kit (UDK) compiler
     on OpenServer, you need to specify the locations of the UDK
     libraries:
 -->
 如果你正在OpenServer上使用新的通用开发Kit (UDK)编译器，你需要声明UDK库的位置：
<programlisting>
./configure --with-libraries=/udk/usr/lib --with-includes=/udk/usr/include
</programlisting>
     <!--
     Putting these together with the Readline options from above:
 -->
 将上面这些与Readline选项放在一起：
<programlisting>
./configure --with-libraries="/udk/usr/lib /usr/local/lib" --with-includes="/udk/usr/include /usr/local/include"
</programlisting>
    </para>


   </sect3>

   <sect3>
    <!--
    <title>Reading the PostgreSQL Man Pages</title>
-->
<title>阅读PostgreSQL手册页</title>

    
<para>
     <!--
     By default, the PostgreSQL man pages are installed into
     <filename>/usr/local/pgsql/man</filename>.  By default, UnixWare
     does not look there for man pages.  To be able to read them you
     need to modify the
     <varname>MANPATH</varname> variable
     in <filename>/etc/default/man</filename>, for example:
 -->
 缺省情况下，PostgreSQL手册页安装在<filename>/usr/local/pgsql/man</filename>。
 但是缺省时，UnixWare不会到那里查阅手册页。为了能够查看，你需要修改<filename>/etc/default/man</filename>中的<varname>MANPATH</varname>
 变量，比如：
 
<programlisting>
MANPATH=/usr/lib/scohelp/%L/man:/usr/dt/man:/usr/man:/usr/share/man:scohelp:/usr/local/man:/usr/local/pgsql/man
</programlisting>
    </para>

    <!--
<para>
     On OpenServer, some extra research needs to be invested to make
     the man pages usable, because the man system is a bit different
     from other platforms.  Currently, PostgreSQL will not install
     them at all.
    </para>
-->
<para>
    在OpenServer上，需要投入一些额外调查使手册页可用，因为帮助系统和其他的平台有一点差异。
目前，PostgreSQL根本不安装它们。
</para>
   </sect3>

   <sect3>
   <!--
    <title>C99 Issues with the 7.1.1b Feature Supplement</title>
-->
<title>7.1.1b功能补充的C99问题</title>

    <!--
<para>
     For compilers earlier than the one released with OpenUNIX 8.0.0
     (UnixWare 7.1.2), including the 7.1.1b Feature Supplement, you
     may need to specify <option>-Xb</option>
     in <varname>CFLAGS</varname> or the <varname>CC</varname>
     environment variable.  The indication of this is an error in
     compiling <filename>tuplesort.c</filename> referencing inline
     functions.  Apparently there was a change in the 7.1.2(8.0.0)
     compiler and beyond.
    </para>
-->
<para>
    对于先于OpenUnix 8.0.0（UnixWare 7.1.2)发布的编译器，包括7.1.1b功能补充，
你可能需要在<varname>CFLAGS</varname>或者<varname>CC</varname>环境变量中指定<option>-Xb</option>。
这么做是因为编译<filename>tuplesort.c</filename>中引用的内联函数时有一个错误。
    显然，在7.1.2（8.0.0）及以上版本的编译器中已被变更。
</para>
   </sect3>

   <sect3>
   <!--
    <title>Threading on UnixWare</title>
-->
<title>UnixWare上的线程</title>

    <!--
<para>
     For threading, you<emphasis>must</emphasis> use <option>-Kpthread</option>
     on <emphasis>all</emphasis> libpq-using programs.  libpq
     uses <function>pthread_*</function> calls, which are only
     available with the
     <option>-Kpthread</>/<option>-Kthread</> flag.
    </para>
-->
<para>
    对于线程，你<emphasis>必须</emphasis>在<emphasis>所有</emphasis>使用libpq的程序上使用<option>-Kpthread</option>。 
libpq使用的<function>pthread_*</function>调用，
只有在指定<option>-Kpthread</>/<option>-Kthread</>标志时可用。
</para>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-solaris">
   <title>Solaris</title>

   <indexterm zone="installation-notes-solaris">
    <primary>Solaris</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <!--
<para>
    PostgreSQL is well-supported on Solaris.  The more up to date your
    operating system, the fewer issues you will experience; details
    below.
   </para>
-->
<para>
    PostgreSQL在Solaris上有很好的支持。版本越新的操作系统，遇到的问题越少;
详细信息请参见下面。
</para>

   <sect3>
   <!--
    <title>Required Tools</title>
-->
<title>所需工具</title>

    <!--
<para>
     You can build with either GCC or Sun's compiler suite.  For
     better code optimization, Sun's compiler is strongly recommended
     on the SPARC architecture.  We have heard reports of problems
     when using GCC 2.95.1; GCC 2.95.3 or later is recommended.  If
     you are using Sun's compiler, be careful not to select
     <filename>/usr/ucb/cc</filename>;
     use <filename>/opt/SUNWspro/bin/cc</filename>.
    </para>
-->
<para>
    您可以使用GCC或Sun的编译器套件进行编译。为更好的代码优化，
在SPARC架构上强烈推荐Sun的编译器。我们已经听到使用GCC 2.95.1时的问题报告; 推荐GCC 2.95.3或更高的版本。
如果您正在使用Sun的编译器，请注意不要选择<filename>/usr/ucb/cc</filename>;而使用 
    <filename>/opt/SUNWspro/bin/cc</filename>。
</para>

    <!--
<para>
     You can download Sun Studio
     from <ulink url="http://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/"></ulink>.
     Many of GNU tools are integrated into Solaris 10, or they are
     present on the Solaris companion CD.  If you like packages for
     older version of Solaris, you can find these tools
     at <ulink url="http://www.sunfreeware.com"></ulink>.
     If you prefer
     sources, look
     at <ulink url="http://www.gnu.org/order/ftp.html"></ulink>.
    </para>
-->
<para>
    您可以从<ulink url="http://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/"></ulink>下载Sun Studio。 
    许多GNU工具都被集成到Solaris 10中，或者它们目前在Solaris companion CD上被提供。
如果你喜欢适用于Solaris旧版本的包，你可以从<ulink url="http://www.sunfreeware.com"></ulink>中找到这些工具。 
    如果你喜欢源码，可以参阅<ulink url="http://www.gnu.org/order/ftp.html"></ulink>。
</para>
   </sect3>

   <sect3>
    <!--
    <title>Problems with OpenSSL</title>
-->
<title>OpenSSL问题</title>

    
<para>
     <!--
     When you build PostgreSQL with OpenSSL support you might get
     compilation errors in the following files:
 -->
 
 当您编译PostgreSQL支持OpenSSL的时候，你可能会得到以下文件中的编译错误：
 
     <itemizedlist>
      <listitem><para><filename>src/backend/libpq/crypt.c</filename></para></listitem>
      <listitem><para><filename>src/backend/libpq/password.c</filename></para></listitem>
      <listitem><para><filename>src/interfaces/libpq/fe-auth.c</filename></para></listitem>
      <listitem><para><filename>src/interfaces/libpq/fe-connect.c</filename></para></listitem>
     </itemizedlist>
     <!--
     This is because of a namespace conflict between the standard
     <filename>/usr/include/crypt.h</filename> header and the header
     files provided by OpenSSL.
 -->
 这是因为标准的头文件<filename>/usr/include/crypt.h</filename>与OpenSSL所提供的头文件之间有命名空间冲突。
    </para>

    <!--
<para>
     Upgrading your OpenSSL installation to version 0.9.6a fixes this
     problem.  Solaris 9 and above has a newer version of OpenSSL.
    </para>
-->
<para>
   升级您的OpenSSL到版本0.9.6a修复这个问题。Solaris 9及以上版本中有OpenSSL的较新版本。
</para>
   </sect3>

   <sect3>
    <!--
    <title>configure Complains About a Failed Test Program</title>
-->
 <title>configure提示失败的测试程序</title>

  
<para>
    <!--
     If <command>configure</command> complains about a failed test
     program, this is probably a case of the run-time linker being
     unable to find some library, probably libz, libreadline or some
     other non-standard library such as libssl.  To point it to the
     right location, set the <envar>LDFLAGS</envar> environment
     variable on the <command>configure</command> command line, e.g.,
 -->
 如果<command>configure</command>提示失败的测试程序，
 这可能是运行时链接程序无法找到一些库的情况，
 可能是libz, libreadline或一些其他非标准库，如libssl。
 为了让它指向正确的位置，在<command>configure</command>命令行上设置<envar>LDFLAGS</envar>环境变量。
 比如：
 
<programlisting>
configure ... LDFLAGS="-R /usr/sfw/lib:/opt/sfw/lib:/usr/local/lib"
</programlisting>
     <!--
     See
     the <citerefentry><refentrytitle>ld</><manvolnum>1</></citerefentry>
     man page for more information.
 -->
 参阅<citerefentry><refentrytitle>ld</><manvolnum>1</></citerefentry>手册页获取更多详情。
    </para>

   </sect3>

   <sect3>
    <!--
    <title>64-bit Build Sometimes Crashes</title>
-->
<title>64位编译有时崩溃</title>
 
<para>
<!--
     On Solaris 7 and older, the 64-bit version of libc has a buggy
     <function>vsnprintf</function> routine, which leads to erratic
     core dumps in PostgreSQL.  The simplest known workaround is to
     force PostgreSQL to use its own version of <function>vsnprintf</function> rather than
     the library copy.  To do this, after you
     run <command>configure</command> edit a file produced by
     <command>configure</command>:
     In <filename>src/Makefile.global</filename>, change the line
 -->
 在Solaris 7以及更早版本中，64位版本的libc中的<function>vsnprintf</function>有问题，
 从而导致PostgreSQL不稳定的core dump。
 最简单的已知的解决方法是强制PostgreSQL使用它自己的<function>vsnprintf</function>，而不是库的副本。
 要做到这一点，运行<command>configure</command>之后
 编辑<command>configure</command>产生的文件：
 在<filename>src/Makefile.global</filename>中，
 更改行 
<programlisting>
LIBOBJS =
</programlisting>
<!--
     to read
 -->
 读取
<programlisting>
LIBOBJS = snprintf.o
</programlisting>
<!--
     (There might be other files already listed in this variable.
     Order does not matter.)  Then build as usual.
 -->
（可能还有其他在这个变量中已经列出的文件。顺序无关紧要。）然后照常编译。
    </para>


   </sect3>

   <sect3>
   <!--
    <title>Compiling for Optimal Performance</title>
-->
     <title>编译以获得最佳性能</title>
 
    <!--
<para>
     On the SPARC architecture, Sun Studio is strongly recommended for
     compilation.  Try using the <option>-xO5</option> optimization
     flag to generate significantly faster binaries.  Do not use any
     flags that modify behavior of floating-point operations
     and <varname>errno</varname> processing (e.g.,
     <option>-fast</option>).  These flags could raise some
     nonstandard PostgreSQL behavior for example in the date/time
     computing.
    </para>
-->
<para>
     SPARC架构上，强烈推荐Sun Studio编译。尝试使用<option>-xO5</option>优化 
 标志产生显著快速的二进制文件。不要使用
 任何的标志修改浮点运算的行为以及<varname>errno</varname>处理（例如， 
 <option>-fast</option>）。这些标志可以加速PostgreSQL的一些非标准的行为，例如日期/时间的计算。
</para>

    <!--
<para>
     If you do not have a reason to use 64-bit binaries on SPARC,
     prefer the 32-bit version.  The 64-bit operations are slower and
     64-bit binaries are slower than the 32-bit variants.  And on
     other hand, 32-bit code on the AMD64 CPU family is not native,
     and that is why 32-bit code is significant slower on this CPU
     family.
    </para>
-->
<para>
    如果您没有理由在SPARC上使用64位二进制文件，请选择32位版本。64位运算速度较慢， 
    并且64位二进制比32位更慢。另一方面，在AMD64 CPU族中的32位代码不是本地的， 
这就是为什么32位代码在这个CPU族中显著慢的原因。
</para>
   </sect3>

   <sect3>
    <!--
    <title>Using DTrace for Tracing PostgreSQL</title>
-->
<title>使用DTrace追踪PostgreSQL</title>

    <!--
<para>
     Yes, using DTrace is possible.  See <![%standalone-include[the
     documentation]]>
     <![%standalone-ignore[<xref linkend="dynamic-trace">]]> for further
     information.  You can also find more information in this
     article: <ulink url="https://blogs.oracle.com/robertlor/entry/user_level_dtrace_probes_in"></ulink>.
    </para>
-->
<para>
      是的，有可能使用DTrace。参阅<![%standalone-include[the
     documentation]]>
     <![%standalone-ignore[<xref linkend="dynamic-trace">]]>获取更多信息。
 你也可以通过文章<ulink url="https://blogs.oracle.com/robertlor/entry/user_level_dtrace_probes_in"></ulink>
 查找更多的信息。
</para>

    
<para>
    <!--
     If you see the linking of the <command>postgres</command> executable abort with an
     error message like:
 -->
 如果您看到链接的<command>postgres</command>执行中断的错误消息如：
<screen>
Undefined                       first referenced
 symbol                             in file
AbortTransaction                    utils/probes.o
CommitTransaction                   utils/probes.o
ld: fatal: Symbol referencing errors. No output written to postgres
collect2: ld returned 1 exit status
make: *** [postgres] Error 1
</screen>
<!--
     your DTrace installation is too old to handle probes in static
     functions.  You need Solaris 10u4 or newer.
--> 
 您的DTrace安装太旧而不能处理静态函数的探测。你需要Solaris 10u4或更高版本。
    </para>
   </sect3>
  </sect2>
 </sect1>

</chapter>
