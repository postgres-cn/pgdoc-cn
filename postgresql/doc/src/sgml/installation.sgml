<!-- doc/src/sgml/installation.sgml -->
<!--

Use </link> not just </> so INSTALL.html can be created without links
to the main documentation.  Don't use <xref>; or if you must, wrap it
in a standalone-ignore clause.

-->

<chapter id="installation">
 <title><![%standalone-include[<productname>PostgreSQL</>]]>
  从源代码安装</title>

 <indexterm zone="installation">
  <primary>installation</primary>
 </indexterm>

 <para>
  本章的内容描述从源代码发布安装<productname>PostgreSQL</productname>（如果你安装的是打包好的版本如RPM或Debian包，那么请略过这一章并且阅读打包者的指导）。
 </para>

 <sect1 id="install-short">
  <title>简单版</title>

  <para>
<synopsis>
./configure
make
su
make install
adduser postgres
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;
/usr/local/pgsql/bin/createdb test
/usr/local/pgsql/bin/psql test
</synopsis>
   本章剩余部分都是完全版。
  </para>
 </sect1>


 <sect1 id="install-requirements">
  <title>要求</title>

  <para>
   一般说来，一个现代的与 Unix 兼容的平台应该就能运行<productname>PostgreSQL</>。 到发布为止已经明确测试过的平台的列表在 <xref linkend="supported-platforms">中列出。在发布的<filename>doc</>子目录里面有许多平台相关的 <acronym>FAQ</>文档，如果你碰到问题你可能会需要参考它们。
  </para>

  <para>
   编译<productname>PostgreSQL</>需要下列软件包：

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary>make</primary>
      </indexterm>

      要求<acronym>GNU</> <application>make</>版本3.80或以上；其他的<application>make</>程序或更老的<acronym>GNU</> <application>make</>版本将<emphasis>不会</>工作（<acronym>GNU</> <application>make</>有时以名字<filename>gmake</filename>安装）。要测试<acronym>GNU</acronym> <application>make</application>可以输入：
<screen>
<userinput>make --version</userinput>
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      你需要一个<acronym>ISO</>/<acronym>ANSI</> C 编译器（至少是 C89兼容的）。我们推荐使用最近版本的<productname>GCC</>，不过，众所周知的是<productname>PostgreSQL</>可以利用许多不同厂商的不同编译器进行编译。
     </para>
    </listitem>

    <listitem>
     <para>
      除了<application>gzip</>和<application>bzip2</>之外，我们还需要<application>tar</>来解包源代码发布。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary>readline</primary>
      </indexterm>
      <indexterm>
       <primary>libedit</primary>
      </indexterm>

      默认时将自动使用<acronym>GNU</> <productname>Readline</>库。它允许<application>psql</application>（PostgreSQL的命令行 SQL 解释器）记住你输入的每一个命令并且允许你使用箭头键来找回和编辑之前的命令。如果你不想用它，那么你必需给<filename>configure</>声明<option>--without-readline</option>选项。作为一种可选方案，你常常可以使用 BSD许可证的<filename>libedit</filename>库，它最初是在<productname>NetBSD</productname>上开发的。<filename>libedit</filename>库是GNU <productname>Readline</productname>兼容的， 如果没有发现<filename>libreadline</filename>或者<filename>configure</>使用了<option>--with-libedit-preferred</option>选项，都会使用这个库。如果你使用的是一个基于包的 Linux 发布，那么要注意你需要<literal>readline</>和<literal>readline-devel</>两个包，特别是如果这两个包在你的版本里是分开的时候。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary>zlib</primary>
      </indexterm>

      默认的时候将使用<productname>zlib</productname>压缩库。 如果你不想使用它，那么你必须给<filename>configure</filename>声明<option>--without-zlib</option>选项。使用这个选项关闭了在<application>pg_dump</>和<application>pg_restore</>中对压缩归档的支持。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   下列包是可选的。在默认配置的时候并不要求它们，但是如果打开了一些编译选项之后就需要它们了，如下文所解释的：

   <itemizedlist>
    <listitem>
     <!-- 
     <para>
      To build the server programming language
      <application>PL/Perl</application> you need a full
      <productname>Perl</productname> installation, including the
      <filename>libperl</filename> library and the header files.
      Since <application>PL/Perl</application> will be a shared
      library, the <indexterm><primary>libperl</primary></indexterm>
      <filename>libperl</filename> library must be a shared library
      also on most platforms.  This appears to be the default in
      recent <productname>Perl</productname> versions, but it was not
      in earlier versions, and in any case it is the choice of whomever
      installed Perl at your site.  <filename>configure</filename> will fail
      if building <application>PL/Perl</application> is selected but it cannot
      find a shared <filename>libperl</filename>.  In that case, you will have
      to rebuild and install <productname>Perl</productname> manually to be
      able to build <application>PL/Perl</application>.  During the
      configuration process for <productname>Perl</productname>, request a
      shared library.
     </para>
     -->
    <para>
      要编译服务器端编程语言<application>PL/Perl</application>，
      你需要一个完整的<productname>Perl</productname>安装，包括
      <filename>libperl</filename>库和头文件。因为<application>PL/Perl</application>
      是一个共享库，<indexterm><primary>libperl</primary></indexterm>
      <filename>libperl</filename>库在大多数平台上也必须是一个共享库。
      最近的版本的<productname>Perl</productname>好像已经默认这样做了，
      但是早先的版本可不是这样的，而且这总是一种在站点上安装 Perl 的选择。
      如果选择了构建<application>PL/Perl</application>但是无法找到共享的
      <filename>libperl</filename>，则<filename>configure</filename>将会失败。
      在这种情况下，您必须手动重新构建并安装<productname>Perl</productname>，
      才能构建<application>PL/Perl</application>。在<productname>Perl</productname>
      的配置过程中，请求一个共享库。
     </para>

     <!-- 
     <para>
      If you intend to make more than incidental use of
      <application>PL/Perl</application>, you should ensure that the
      <productname>Perl</productname> installation was built with the
      <literal>usemultiplicity</> option enabled (<literal>perl -V</>
      will show whether this is the case).
     </para>
     -->
     <para>
      如果你想更多地使用<application>PL/Perl</application>，你应当保证
      <productname>Perl</productname>安装在编译时启用了<literal>usemultiplicity</>
      选项（<literal>perl -V</>将会显示是否是这样）。
     </para>
    </listitem>

    <listitem>
     <para>
      要编译<application>PL/Python</>服务器端编程语言， 你需要一个<productname>Python</productname>的安装，包括头文件和<application>distutils</application>模块。最低的版本要求是<productname>Python</productname> 2.3（要和类型<type>numeric</>的函数参数一起工作，2.3.x 安装必须包括独立可用的<filename>cdecimal</>模块，注意如果缺少它<application>PL/Python</>回归测试就无法通过）。如果是版本3.1或更高版本，则支持<productname>Python 3</productname>，如果使用 Python 3 请参考<![%standalone-include[the <application>PL/Python</> documentation]]>。
      <![%standalone-ignore[<xref linkend="plpython-python23">]]>
     </para>

<!-- 
     <para>
      Since <application>PL/Python</application> will be a shared
      library, the <indexterm><primary>libpython</primary></indexterm>
      <filename>libpython</filename> library must be a shared library
      also on most platforms.  This is not the case in a default
      <productname>Python</productname> installation built from source, but a
      shared library is available in many operating system
      distributions.  <filename>configure</filename> will fail if
      building <application>PL/Python</application> is selected but it cannot
      find a shared <filename>libpython</filename>.  That might mean that you
      either have to install additional packages or rebuild (part of) your
      <productname>Python</productname> installation to provide this shared
      library.  When building from source, run <productname>Python</>'s
      configure with the <literal>-&#045;enable-shared</> flag.
     </para>
-->
     <para>
      因为<application>PL/Python</application>将以共享库的方式编译，
      <indexterm><primary>libpython</primary></indexterm><filename>libpython</filename>
      库在大多数平台上也必须是一个共享库。在从源代码构建的默认
      <productname>Python</productname>安装中不是这样的，
      但是在许多操作系统发行版中提供了共享库。如果选择了构建
      <application>PL/Python</application>但是无法找到共享的
      <filename>libpython</filename>，则<filename>configure</filename>将会失败。
      这可能意味着你必须安装额外的包或者必须重新编译（一部分）你的
      <productname>Python</productname>安装以提供这个共享库。
      当从源码构建时，用<literal>--enable-shared</>标志运行
      <productname>Python</>的 configure。
     </para>
    </listitem>

    <listitem>
     <para>
      如果你想编译<application>PL/Tcl</application>过程语言， 你当然需要安装<productname>Tcl</>了。如果你正在使用8.4之前的<productname>Tcl</>发布，确保它编译时没有用多线程支持。
     </para>
    </listitem>

    <listitem>
     <para>
      要打开本地语言支持（<acronym>NLS</acronym>），也就是说， 用英语之外的语言显示程序的消息，你需要一个<application>Gettext</> <acronym>API</acronym>的实现。有些操作系统内置了这些（例如<systemitem class="osname">Linux</>、<systemitem class="osname">NetBSD</>、<systemitem class="osname">Solaris</>）， 对于其它系统，你可以从<ulink url="http://www.gnu.org/software/gettext/"></ulink>下载一个额外的包。如果你在使用<acronym>GNU</acronym> C 库里面的<application>Gettext</>实现， 那么你就额外需要<productname>GNU Gettext</productname>包，因为我们需要里面的几个工具程序。对于任何其它的实现，你应该不需要它。
     </para>
    </listitem>

    <listitem>
     <para>
      如果你想支持使用<application>Kerberos</>、<productname>OpenSSL</>、<productname>OpenLDAP</>和/或<application>PAM</>的认证或者加密，那你需要相应的包。
     </para>
    </listitem>

    <listitem>
     <para>
      要编译<productname>PostgreSQL</productname>文档，有一些独立的要求集，请见<![%standalone-ignore;[<xref linkend="docguide-toolsets">.]]>
      <![%standalone-include;[the main documentation's appendix on
      documentation.]]>。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   如果你正从<productname>Git</productname>树而不是使用发布的源代码包进行编译，或者你想做服务器端开发， 那么你还需要下面的包：

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary>flex</primary>
      </indexterm>
      <indexterm>
       <primary>lex</primary>
      </indexterm>
      <indexterm>
       <primary>bison</primary>
      </indexterm>
      <indexterm>
       <primary>yacc</primary>
      </indexterm>

      如果你需要从 Git 检出中编译，或者你修改了实际的扫描器和分析器的定义文件， 那么你需要 GNU <application>Flex</>和<application>Bison</>。 如果你需要它们，那么确保自己拿到的是<application>Flex</> 2.5.31 或更新的版本， 以及<application>Bison</> 1.875 或者更新的版本。不能使用其他<application>lex</>和<application>yacc</>程序。
     </para>
    </listitem>
    <listitem>
     <para>
      <indexterm>
       <primary>perl</primary>
      </indexterm>

      如果需要从 Git 检出中编译，或者你修改了任何使用 Perl 脚本的编译步骤的输入文件，那么你需要<application>Perl</> 5.8或以后的版本。如果你在 Windows 上编译，你在任何情况下都需要<application>Perl</>。运行一些测试套件时也需要<application>Perl</application>。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   如果你需要获取<acronym>GNU</acronym>包，你可以在你的本地<acronym>GNU</acronym>镜像站点 （看看 <ulink url="http://www.gnu.org/order/ftp.html"></>或<ulink url="ftp://ftp.gnu.org/gnu/"></ulink>找到它们。
  </para>

  <para>
   还要检查一下你是否有足够的磁盘空间。你将大概需要近 100MB 用于存放编译过程中的源码树和大约 20 MB 用于安装目录。 一个空数据库集簇大概需要 35 MB。一个数据库所占的空间大约是存储同样数据的平面文件所占空间的五倍。如果你要运行回归测试，还临时需要额外的 150MB。请用<command>df</command>命令检查剩余磁盘空间。
  </para>
 </sect1>

<![%standalone-ignore;[
 <sect1 id="install-getsource">
  <title>获取源码</title>

  <para>
   <productname>PostgreSQL</> &version; 源代码可以从我们的官方网站 <ulink url="http://www.postgresql.org/download/"></ulink>的下载区中获得。你将得到一个名为<filename>postgresql-&version;.tar.gz</filename>或<filename>postgresql-&version;.tar.bz2</filename>的文件。在你获取文件之后，解压缩它：
<screen>
<userinput>gunzip postgresql-&version;.tar.gz</userinput>
<userinput>tar xf postgresql-&version;.tar</userinput>
</screen>
   （如果你得到的是<filename>.bz2</filename>文件，请用<command>bunzip2</command>代替<command>gunzip</command>）。这样将在当前目录创建一个目录<filename>postgresql-&version;</filename>， 里面是<productname>PostgreSQL</>源代码。 进入这个目录完成安装过程的其他步骤。
  </para>

  <para>
   你也可以直接从版本控制库中获得源代码，参见<xref linkend="sourcerepo">。
  </para>
 </sect1>
]]>

 <sect1 id="install-procedure">
  <title>安装过程</title>

  <procedure>

  <step id="configure">
   <title>配置</title>

   <indexterm zone="configure">
    <primary>configure</primary>
   </indexterm>

   <para>
    安装过程的第一步就是为你的系统配置源代码树并选择你喜欢的选项。这个工作是通过运行<filename>configure</>脚本实现的，对于默认安装，你只需要简单地输入：
<screen>
<userinput>./configure</userinput>
</screen>
    该脚本将运行一些测试来决定一些系统相关的变量， 并检测你的操作系统的特殊设置，并且最后将在编译树中创建一些文件以记录它找到了什么。如果你想保持编译目录的独立，你也可以在一个源码树之外的目录中运行<filename>configure</filename> 。这个过程也被称为一个<indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>编译。做法如下：
<screen>
<userinput>mkdir build_dir</userinput>
<userinput>cd build_dir</userinput>
<userinput>/path/to/source/tree/configure [options go here]</userinput>
<userinput>make</userinput>
</screen>
   </para>

   <para>
    默认设置将编译服务器和辅助程序，还有只需要 C 编译器的所有客户端程序和接口。默认时所有文件都将安装到<filename>/usr/local/pgsql</>。
   </para>

   <para>
    你可以通过给出下面的<filename>configure</filename>命令行选项中的一个或更多的选项来自定义编译和安装过程：

     <variablelist>
      <varlistentry>
       <term><option>--prefix=<replaceable>PREFIX</></option></term>
       <listitem>
        <para>
         把所有文件装在目录<replaceable>PREFIX</>中而不是<filename>/usr/local/pgsql</filename>中。 实际的文件会安装到数个子目录中；没有一个文件会直接安装到<replaceable>PREFIX</>目录里。
        </para>

        <para>
         如果你有特殊需要，你还可以用下面的选项自定义不同的子目录的位置。 不过，如果你把这些设置保留默认，那么安装将是可重定位的，意思是你可以在安装过后移动目录（<literal>man</>和<literal>doc</>位置不受此影响）。
        </para>

        <para>
         对于可重定位的安装，你可能需要使用<filename>configure</filename>的<literal>--disable-rpath</>选项。 还有，你需要告诉操作系统如何找到共享库。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--exec-prefix=<replaceable>EXEC-PREFIX</></option></term>
       <listitem>
        <para>
         你可以把体系相关的文件安装到一个不同的前缀下（<replaceable>EXEC-PREFIX</>），而不是<replaceable>PREFIX</>中设置的地方。 这样做可以比较方便地在不同主机之间共享体系相关的文件。 如果你省略这些，那么<replaceable>EXEC-PREFIX</>就会被设置为等于 <replaceable>PREFIX</>并且体系相关和体系无关的文件都会安装到同一棵目录树下，这也可能是你想要的。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--bindir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         为可执行程序指定目录。默认是<filename><replaceable>EXEC-PREFIX</>/bin</>， 通常也就是<filename>/usr/local/pgsql/bin</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--sysconfdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         用于各种各样配置文件的目录，默认为<filename><replaceable>PREFIX</>/etc</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--libdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         设置安装库和动态装载模块的目录。默认是<filename><replaceable>EXEC-PREFIX</>/lib</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--includedir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         C 和 C++ 头文件的目录。默认是<filename><replaceable>PREFIX</>/include</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--datarootdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         设置多种只读数据文件的根目录。这只为后面的某些选项设置默认值。默认值为<filename><replaceable>PREFIX</>/share</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--datadir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         设置被安装的程序使用的只读数据文件的目录。默认值为<filename><replaceable>DATAROOTDIR</></>。注意这不会对你的数据库文件被放置的位置产生任何影响。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--localedir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         设置安装区域数据的目录，特别是消息翻译目录文件。默认值为<filename><replaceable>DATAROOTDIR</>/locale</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--mandir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         <productname>PostgreSQL</>自带的手册页将安装到这个目录，它们被安装在相应的<filename>man<replaceable>x</></>子目录里。 默认是<filename><replaceable>DATAROOTDIR</>/man</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--docdir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         设置安装文档文件的根目录，<quote>man</>页不包含在内。这只为后续选项设置默认值。这个选项的默认值为<filename><replaceable>DATAROOTDIR</>/doc/postgresql</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--htmldir=<replaceable>DIRECTORY</></option></term>
       <listitem>
        <para>
         <productname>PostgreSQL</productname>的HTML格式的文档将被安装在这个目录中。默认值为<filename><replaceable>DATAROOTDIR</></>。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
      <para>
       为了让<productname>PostgreSQL</>能够安装在一些共享的安装位置（例如<filename>/usr/local/include</filename>）， 同时又不至于和系统其它部分产生名字空间干扰，我们特别做了一些处理。 首先，安装脚本会自动给<varname>datadir</varname>、<varname>sysconfdir</varname>和<varname>docdir</varname>后面附加上<quote><literal>/postgresql</literal></quote>字符串， 除非展开的完整路径名已经包含字符串<quote><literal>postgres</></quote>或者<quote><literal>pgsql</></quote>。 例如，如果你选择<filename>/usr/local</filename>作为前缀， 那么文档将安装在<filename>/usr/local/doc/postgresql</filename>，但如果前缀是<filename>/opt/postgres</filename>， 那么它将被放到<filename>/opt/postgres/doc</filename>。客户接口的公共 C 头文件安装到了<varname>includedir</varname>，并且是名字空间无关的。内部的头文件和服务器头文件都安装在<varname>includedir</varname>下的私有目录中。参考每种接口的文档获取关于如何访问头文件的信息。最后，如果合适，那么也会在<varname>libdir</varname>下创建一个私有的子目录用于动态可装载的模块。
      </para>
     </note>
    </para>

    <para>
     <variablelist>
      <varlistentry>
       <term><option>--with-extra-version=<replaceable>STRING</></option></term>
       <listitem>
        <para>
         把<replaceable>STRING</>追加到 PostgreSQL 版本号。例如，你可以使用它来标记从未发布的 Git 快照或者包含定制补丁（带有一个如<command>git describe</command>标识符之类的额外版本号或者一个分发包发行号）创建的二进制文件。
        </para>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term><option>--with-includes=<replaceable>DIRECTORIES</></option></term>
       <listitem>
        <para>
         <replaceable>DIRECTORIES</>是一个冒号分隔的目录列表，这些目录将被加入编译器的头文件搜索列表中。 如果你有一些可选的包（例如 GNU <application>Readline</>）安装在非标准位置， 你就必须使用这个选项，以及可能还有相应的 <option>--with-libraries</>选项。
        </para>
        <para>
         例子：<literal>--with-includes=/opt/gnu/include:/usr/sup/include</>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libraries=<replaceable>DIRECTORIES</></option></term>
       <listitem>
        <para>
         <replaceable>DIRECTORIES</>是一个冒号分隔的目录列表，这些目录是用于查找库文件的。 如果你有一些包安装在非标准位置，你可能就需要使用这个选项（以及对应的<option>--with-includes</>选项）。
        </para>
        <para>
         例子：<literal>--with-libraries=/opt/gnu/lib:/usr/sup/lib</>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-nls<optional>=<replaceable>LANGUAGES</replaceable></optional></option></term>
       <listitem>
        <para>
         打开本地语言支持（<acronym>NLS</acronym>），也就是以非英文显示程序消息的能力。<replaceable>LANGUAGES</replaceable>是一个空格分隔的语言代码列表， 表示你想支持的语言。例如<literal>--enable-nls='de fr'</> （你提供的列表和实际支持的列表之间的交集将会自动计算出来）。如果你没有声明一个列表，那么就会安装所有可用的翻译。
        </para>

        <para>
         要使用这个选项，你需要一个<application>Gettext</> API 的实现。见上文。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-pgport=<replaceable>NUMBER</></option></term>
       <listitem>
        <para>
         把<replaceable>NUMBER</>设置为服务器和客户端的默认端口。默认是 5432。 这个端口可以在以后修改，不过如果你在这里声明，那么服务器和客户端将有相同的编译好了的默认值。这样会非常方便些。 通常选取一个非默认值的理由是你企图在同一台机器上运行多个<productname>PostgreSQL</>服务器。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-perl</option></term>
       <listitem>
        <para>
         制作<application>PL/Perl</>服务器端编程语言。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-python</option></term>
       <listitem>
        <para>
         制作<application>PL/Python</>服务器端编程语言。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-tcl</option></term>
       <listitem>
        <para>
         制作<application>PL/Tcl</>服务器编程语言。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-tclconfig=<replaceable>DIRECTORY</replaceable></option></term>
       <listitem>
        <para>
         Tcl 安装文件<filename>tclConfig.sh</filename>，其中里面包含编译与 Tcl 接口的模块的配置信息。该文件通常可以自动地在一个众所周知的位置找到，但是如果你需要一个不同版本的 Tcl，你也可以指定可以找到它的目录。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-gssapi</option></term>
       <listitem>
        <para>
         编译 GSSAPI 认证支持。在很多系统上，GSSAPI（通常是 Kerberos 安装的一部分）系统不会被安装在默认搜索位置（例如<filename>/usr/include</>、<filename>/usr/lib</>），因此你必须使用选项<option>--with-includes</>和<option>--with-libraries</>来配合该选项。<filename>configure</>将会检查所需的头文件和库以确保你的 GSSAPI 安装足以让配置继续下去。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-krb-srvnam=<replaceable>NAME</></option></term>
       <listitem>
        <para>
         默认的 Kerberos 服务主的名称（也被 GSSAPI 使用）。默认是<literal>postgres</literal>。通常没有理由改变这个值，除非你是一个 Windows 环境，这种情况下该名称必须被设置为大写形式<literal>POSTGRES</literal>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-openssl</option>
       <indexterm>
        <primary>OpenSSL</primary>
        <seealso>SSL</seealso>
       </indexterm>

       </term>
       <listitem>
        <para>
         编译<acronym>SSL</>（加密）连接支持。这个选项需要安装<productname>OpenSSL</>包。<filename>configure</>将会检查所需的头文件和库以确保你的 <productname>OpenSSL</>安装足以让配置继续下去。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-pam</option></term>
       <listitem>
        <para>
         编译<acronym>PAM</><indexterm><primary>PAM</></>（可插拔认证模块）支持。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-ldap</option></term>
       <listitem>
        <para>
         为认证和连接参数查找编译<acronym>LDAP</><indexterm><primary>LDAP</></>支持（详见<![%standalone-include[the documentation about client authentication and libpq]]><![%standalone-ignore[<xref linkend="libpq-ldap">和<xref linkend="auth-ldap">]]>）。在 Unix 上，这需要安装<productname>OpenLDAP</>包。在 Windows 上将使用默认的<productname>WinLDAP</>库。<filename>configure</>将会检查所需的头文件和库以确保你的 <productname>OpenLDAP</>安装足以让配置继续下去。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--without-readline</option></term>
       <listitem>
        <para>
         避免使用<application>Readline</>库（以及<application>libedit</>）。这个选项禁用了<application>psql</application>中的命令行编辑和历史， 因此我们不建议这么做。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libedit-preferred</option></term>
       <listitem>
        <para>
         更倾向于使用BSD许可证的<application>libedit</>库而不是GPL许可证的<application>Readline</>。这个选项只有在你同时安装了两个库时才有意义，在那种情况下默认会使用<application>Readline</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-bonjour</option></term>
       <listitem>
        <para>
         编译 Bonjour 支持。这要求你的操作系统支持 Bonjour。在 OS X 上建议使用。
        </para>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term><option>--with-uuid=<replaceable>LIBRARY</replaceable></option></term>
       <listitem>
        <para>
         使用指定的 UUID 库编译<![%standalone-include[uuid-ossp]]>
         <![%standalone-ignore[<xref linkend="uuid-ossp">]]>模块（提供生成 UUID 的函数）。
         <indexterm><primary>UUID</primary></indexterm>
         <replaceable>LIBRARY</replaceable>必须是下列之一：
        </para>
        <itemizedlist>
         <listitem>
          <para>
           <option>bsd</>，用来使用 FreeBSD、NetBSD 和一些其他 BSD 衍生系统
           中的 UUID 函数
          </para>
         </listitem>
         <listitem>
          <para>
           <option>e2fs</>，用来使用<literal>e2fsprogs</>项目创建的 UUID 库，
           这个库出现在大部分的 Linux 系统和 OS X 中，并且也能找到用于其他平台的
           版本
          </para>
         </listitem>
         <listitem>
          <para>
           <option>ossp</>，用来使用<ulink
           url="http://www.ossp.org/pkg/lib/uuid/">OSSP UUID library</ulink>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-ossp-uuid</option></term>
       <listitem>
        <para>
         <literal>--with-uuid=ossp</literal>的已废弃的等效选项。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libxml</option></term>
       <listitem>
        <para>
         编译 libxml （启用 SQL/XML 支持）。这个特性需要 Libxml 版本 2.6.23 及以上。
        </para>

        <para>
         Libxml 会安装一个程序<command>xml2-config</command>，它可以被用来检测所需的编译器和链接器选项。如果能找到，PostgreSQL 将自动使用它。要制定一个非常用的 libxml 安装位置，你可以设置环境变量<envar>XML2_CONFIG</envar>指向<command>xml2-config</command>程序所属的安装，或者使用选项<option>--with-includes</option>和<option>--with-libraries</option>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-libxslt</option></term>
       <listitem>
        <para>
         编译<![%standalone-include[xml2]]>
         <![%standalone-ignore[<xref linkend="xml2">]]>模块时使用 libxslt。<application>xml2</>依赖这个库来执行XML的XSL转换。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-integer-datetimes</option></term>
       <listitem>
        <para>
         禁用对时间戳和间隔的64位存储支持，并且将 datetime 值存储为浮点数。浮点 datetime 存储在<productname>PostgreSQL</productname> 8.4之前是默认方式，但是现在已经被废弃，因为它对于<type>timestamp</type>值的全范围不支持毫秒精度。但是，基于整数的 datetime 存储要求64位整数类型。因此，当没有64位整数类型时，可以使用这个选项，或者在兼容为<productname>PostgreSQL</productname>之前版本开发的应用时使用。详见<![%standalone-include[the documentation about datetime datatypes]]>
         <![%standalone-ignore[<xref linkend="datatype-datetime">]]>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-float4-byval</option></term>
       <listitem>
        <para>
         禁用 float4 值的<quote>传值</>，导致它们只能被<quote>传引用</>。这个选项会损失性能，但是在需要兼容使用 C 编写并使用<quote>version 0</>调用习惯的老用户定义函数时可能需要这个选项。更好的长久解决方案是将任何这样的函数更新成使用<quote>version 1</>调用习惯。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-float8-byval</option></term>
       <listitem>
        <para>
         禁用 float8 值的<quote>传值</>，导致它们只能被<quote>传引用</>。这个选项会损失性能，但是在需要兼容使用 C 编写并使用<quote>version 0</>调用习惯的老用户定义函数时可能需要这个选项。更好的长久解决方案是将任何这样的函数更新成使用<quote>version 1</>调用习惯。注意这个选项并非只影响 float8，它还影响 int8 和某些相关类型如时间戳。在32位平台上，<option>--disable-float8-byval</>是默认选项并且不允许选择<option>--enable-float8-byval</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-segsize=<replaceable>SEGSIZE</replaceable></option></term>
       <listitem>
        <para>
         设置<firstterm>段尺寸</>，以 G 字节计。大型的表会被分解成多个操作系统文件，每一个的尺寸等于段尺寸。这避免了与操作系统对文件大小限制相关的问题。默认的段尺寸（1G字节）在所有支持的平台上都是安全的。如果你的操作系统有<quote>largefile</>支持（如今大部分都支持），你可以使用一个更大的段尺寸。这可以有助于在使用非常大的表时消耗的文件描述符数目。但是要当心不能选择一个超过你将使用的平台和文件系统所支持尺寸的值。你可能希望使用的其他工具（如<application>tar</>）也可以对可用文件尺寸设限。如非绝对必要，我们推荐这个值应为2的幂。注意改变这个值需要一次 initdb。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-blocksize=<replaceable>BLOCKSIZE</replaceable></option></term>
       <listitem>
        <para>
         设置<firstterm>块尺寸</>，以 K 字节计。这是表内存储和I/O的单位。默认值（8K字节）适合于大多数情况，但是在特殊情况下可能其他值更有用。这个值必须是2的幂并且在 1 和 32 （K字节）之间。注意修改这个值需要一次 initdb。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-wal-segsize=<replaceable>SEGSIZE</replaceable></option></term>
       <listitem>
        <para>
         设置<firstterm>WAL 段尺寸</>，以 M 字节计。这是 WAL 日志中每一个独立文件的尺寸。调整这个值来控制传送 WAL 日志的粒度非常有用。默认尺寸为 16 M字节。这个值必须是2的幂并且在 1 到 64 （M字节）之间。注意修改这个值需要一次 initdb。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-wal-blocksize=<replaceable>BLOCKSIZE</replaceable></option></term>
       <listitem>
        <para>
         设置<firstterm>WAL 块尺寸</>，以 K 字节计。这是 WAL 日志存储和I/O的单位。默认值（8K 字节）适合于大多数情况，但是在特殊情况下其他值更好有用。这个值必须是2的幂并且在 1 到 64（K字节）之间。注意修改这个值需要一次 initdb。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-spinlocks</option></term>
       <listitem>
        <para>
         即便<productname>PostgreSQL</>对于该平台没有 CPU 自旋锁支持，也允许编译成功。自旋锁支持的缺乏会导致较差的性能，因此这个选项只有当编译终端或者通知你该平台缺乏自旋锁支持时才应被使用。如果在你的平台上要求使用该选项来编译<productname>PostgreSQL</>，请将此问题报告给<productname>PostgreSQL</>的开发者。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--disable-thread-safety</option></term>
       <listitem>
        <para>
         禁用客户端库的线程安全性。这会阻止<application>libpq</application>和<application>ECPG</application>程序中的并发线程安全地控制它们私有的连接句柄。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--with-system-tzdata=<replaceable>DIRECTORY</replaceable></option>
       <indexterm>
        <primary>time zone data</primary>
       </indexterm>
       </term>
       <listitem>
        <para>
         <productname>PostgreSQL</>包含它自己的时区数据库，它被用于日期和时间操作。这个时区数据库实际上是和 IANA 时区数据库相兼容的，后者在很多操作系统如 FreeBSD、Linux和Solaris上都有提供，因此再次安装它可能是冗余的。当这个选项被使用时，将不会使用<replaceable>DIRECTORY</replaceable>中系统提供的时区数据库，而是使用包括在 PostgreSQL 源码发布中的时区数据库。<replaceable>DIRECTORY</replaceable>必须被指定为一个绝对路径。<filename>/usr/share/zoneinfo</filename>在某些操作系统上是一个很有可能的路径。注意安装例程将不会检测不匹配或错误的时区数据。如果你使用这个选项，建议你运行回归测试来验证你指定的时区数据能正常地工作在<productname>PostgreSQL</>中。
        </para>

        <indexterm><primary>交叉编译</primary></indexterm>

        <para>
         这个选项主要针对那些很了解他们的目标操作系统的二进制包发布者。使用这个选项主要优点是不管何时当众多本地夏令时规则之一改变时， PostgreSQL 包不需要被升级。另一个优点是如果时区数据库文件在安装时不需要被编译， PostgreSQL 可以被更直接地交叉编译。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--without-zlib</option></term>
       <listitem>
        <para>
         <indexterm>
          <primary>zlib</primary>
         </indexterm>
         避免使用<application>Zlib</>库。这样就禁用了<application>pg_dump</application>和 <application>pg_restore</application>中对压缩归档的支持。这个选项只适用于那些没有这个库的少见的系统。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-debug</option></term>
       <listitem>
        <para>
         把所有程序和库以带有调试符号的方式编译。这意味着你可以通过一个调试器运行程序来分析问题。 这样做显著增大了最后安装的可执行文件的大小，并且在非 GCC 的编译器上，这么做通常还要关闭编译器优化， 这些都导致速度的下降。但是，如果有这些符号的话，就可以非常有效地帮助定位可能发生问题的位置。目前，我们只是在你使用 GCC 的情况下才建议在生产安装中使用这个选项。但是如果你正在进行开发工作，或者正在使用 beta 版本，那么你就应该总是打开它。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-coverage</option></term>
       <listitem>
        <para>
         如果在使用 GCC，所有程序和库都会用代码覆盖率测试工具编译。在运行时，它们会在编译目录中生成代码覆盖率度量的文件。<![%standalone-ignore[详见<xref linkend="regress-coverage">。]]>这个选项只用于 GCC 以及做开发工作时。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-profiling</option></term>
       <listitem>
        <para>
         如果在使用 GCC，所有程序和库都被编译成可以进行性能分析。在后端退出时，将会创建一个子目录，其中包含用于性能分析的<filename>gmon.out</>文件。这个选项只用于 GCC 和做开发工作时。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-cassert</option></term>
       <listitem>
        <para>
         打开在服务器中的<firstterm>assertion</>检查， 它会检查许多<quote>不可能发生</>的条件。它对于代码开发的用途而言是无价之宝， 不过这些测试可能会显著地降低服务器的速度。并且，打开这个测试不会提高你的系统的稳定性！ 这些断言检查并不是按照严重性分类的，因此一些相对无害的小故障也可能导致服务器重启 &mdash; 只要它触发了一次断言失败。 目前，我们不推荐在生产环境中使用这个选项，但是如果你在做开发或者在使用 beta 版本的时候应该打开它。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-depend</option></term>
       <listitem>
        <para>
         打开自动倚赖性跟踪。如果打开这个选项，那么制作文件（makefile）将设置为在任何头文件被修改的时候都将重新编译所有受影响的目标文件。 如果你在做开发的工作，那么这个选项很有用，但是如果你只是想编译一次并且安装，那么这就是浪费时间。 目前，这个选项只对 GCC 有用。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>--enable-dtrace</option></term>
       <listitem>
        <para>
         <indexterm>
          <primary>DTrace</primary>
         </indexterm>
         为<productname>PostgreSQL</productname>编译对动态跟踪工具 DTrace 的支持。
         <![%standalone-ignore[详见<xref linkend="dynamic-trace">。]]>
        </para>

        <para>
         要指向<command>dtrace</command>程序，必须设置环境变量<envar>DTRACE</envar>。这通常是必需的，因为<command>dtrace</command>通常被安装在<filename>/usr/sbin</filename>中，该路径可能不在搜索路径中。
        </para>

        <para>
         <command>dtrace</command>程序的附加命令行选项可以在环境变量<envar>DTRACEFLAGS</envar>中指定。在 Solaris 上，要在一个64位二进制中包括 DTrace，你必须为 configure 指定<literal>DTRACEFLAGS="-64"</>。例如，使用 GCC 编译器：
<screen>
./configure CC='gcc -m64' --enable-dtrace DTRACEFLAGS='-64' ...
</screen>
         使用 Sun 的编译器：
<screen>
./configure CC='/opt/SUNWspro/bin/cc -xtarget=native64' --enable-dtrace DTRACEFLAGS='-64' ...
</screen>
        </para>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term><option>--enable-tap-tests</option></term>
       <listitem>
        <para>
         启用 Perl TAP 工具进行测试。这要求安装了 Perl 以及 Perl 模块<literal>IPC::Run</literal>。
         <![%standalone-ignore;[详见<xref linkend="regress-tap">。]]>
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>

    <para>
     如果你喜欢用那些和<filename>configure</filename>选取的不同的 C 编译器，那么你可以你的环境变量<envar>CC</>设置为你选择的程序。默认时，只要<filename>gcc</filename>可以使用，<filename>configure</filename>将选择它， 或者是该平台的默认（通常是<filename>cc</>）。类似地，你可以用<envar>CFLAGS</envar>变量覆盖默认编译器标志。
    </para>

    <para>
     你可以在<filename>configure</filename>命令行上指定环境变量， 例如：
<screen>
<userinput>./configure CC=/opt/bin/gcc CFLAGS='-O2 -pipe'</>
</screen>
    </para>

    <para>
     下面是可以以这种方式设置的有效变量的列表：

     <variablelist>
      <varlistentry>
       <term><envar>BISON</envar></term>
       <listitem>
        <para>
         Bison程序
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CC</envar></term>
       <listitem>
        <para>
         C编译器
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CFLAGS</envar></term>
       <listitem>
        <para>
         传递给 C 编译器的选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CPP</envar></term>
       <listitem>
        <para>
         C 预处理器
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>CPPFLAGS</envar></term>
       <listitem>
        <para>
         传递给 C 预处理器的选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>DTRACE</envar></term>
       <listitem>
        <para>
         <command>dtrace</command>程序的位置
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>DTRACEFLAGS</envar></term>
       <listitem>
        <para>
         传递给<command>dtrace</command>程序的选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>FLEX</envar></term>
       <listitem>
        <para>
         Flex程序
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS</envar></term>
       <listitem>
        <para>
         链接可执行程序或共享库时使用的选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS_EX</envar></term>
       <listitem>
        <para>
         只用于链接可执行程序的附加选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>LDFLAGS_SL</envar></term>
       <listitem>
        <para>
         只用于链接共享库的附加选项
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>MSGFMT</envar></term>
       <listitem>
        <para>
         用于本地语言支持的<command>msgfmt</command>程序
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>PERL</envar></term>
       <listitem>
        <para>
         Perl 解释器的全路径。这将被用来决定编译 PL/Perl 时的依赖性。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>PYTHON</envar></term>
       <listitem>
        <para>
         Python 解释器的全路径。这将被用来决定编译 PL/Python 时的依赖性。另外这里指定的是 Python 2 还是 Python 3 （或者是隐式选择）决定了 PL/Python 语言的哪一种变种将成为可用的。详见<![%standalone-include[<application>PL/Python</>文档]]>
         <![%standalone-ignore[<xref linkend="plpython-python23">]]>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>TCLSH</envar></term>
       <listitem>
        <para>
         Tcl 解释器的全路径。这将被用来决定编译 PL/Tcl 时的依赖性，并且它将被替换到 Tcl 脚本中。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><envar>XML2_CONFIG</envar></term>
       <listitem>
        <para>
         用于定位 libxml 安装的<command>xml2-config</command>程序。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <note>
     <para>
      在开发服务器内部代码时，我们推荐使用配置选项<option>--enable-cassert</>（它会打开很多运行时错误检查）和<option>--enable-debug</>（它会提高调试工具的有用性）。
     </para>

     <para>
      如果在使用 GCC，最好使用至少<option>-O1</>的优化级别来编译，因为不使用优化（<option>-O0</>）会禁用某些重要的编译器警告（例如使用未经初始化的变量）。但是，非零的优化级别会使调试更复杂，因为在编译好的代码中步进通常将不能和源代码行一一对应。如果你在尝试调试优化过的代码时觉得困惑，将感兴趣的特定文件使用<option>-O0</>编译。一种简单的方式是传递一个选项给<application>make</>：<command>make PROFILE=-O0 file.o</>。
     </para>
    </note>
   </step>

  <step id="build">
   <title>编译</title>

   <para>
    要开始编译，键入：
<screen>
<userinput>make</userinput>
</screen>
    （一定要记得用<acronym>GNU</> <application>make</>）。依你的硬件而异，编译过程可能需要 5 分钟到半小时。显示的最后一行应该是：
<screen>
All of PostgreSQL is successfully made. Ready to install.
</screen>
   </para>

  <para>
   如果你希望编译所有能编译的东西，包括文档（HTML和手册页）以及附加模块（<filename>contrib</filename>），这样键入：
<screen>
<userinput>make world</userinput>
</screen>
   显示的最后一行应该是：
<screen>
PostgreSQL, contrib and HTML documentation successfully made. Ready to install.
</screen>
   </para>
  </step>

  <step>
   <title>回归测试</title>

   <indexterm>
    <primary>回归测试</primary>
   </indexterm>

   <para>
    如果你想在安装文件前测试新编译的服务器， 那么你可以在这个时候运行回归测试。 回归测试是一个用于验证<productname>PostgreSQL</>在你的系统上是否按照开发人员设想的那样运行的测试套件。键入：
<screen>
<userinput>make check</userinput>
</screen>
    （这条命令不能以 root 运行；请在非特权用户下运行该命令）。
    (This won't work as root; do it as an unprivileged user.)
    <![%standalone-include[文件
    <filename>src/test/regress/README</>和文档包含]]>
    <![%standalone-ignore[<xref linkend="regress">包含]]>关于如何解释测试结果的详细信息。你可以在以后的任何时间通过执行这条命令来运行这个测试。
   </para>
  </step>

  <step id="install">
   <title>安装文件</title>

   <note>
    <para>
     如果你正在升级一套现有的系统，请阅读<![%standalone-include[文档，]]>
     <![%standalone-ignore[<xref linkend="upgrading">]]>
     其中有关于升级一个集簇的指导。
    </para>
   </note>

   <para>
    要安装<productname>PostgreSQL</>，输入：
<screen>
<userinput>make install</userinput>
</screen>
    这条命令将把文件安装到在<xref linkend="configure">中指定的目录。确保你有足够的权限向该区域写入。通常你需要用 root 权限做这一步。或者你也可以事先创建目标目录并且分派合适的权限。
   </para>

   <para>
    要安装文档（HTML和手册页），输入：
<screen>
<userinput>make install-docs</userinput>
</screen>
   </para>

   <para>
    如果你按照上面的方法编译了所有东西，输入：
<screen>
<userinput>make install-world</userinput>
</screen>
    这也会安装文档。
   </para>

   <para>
    你可以使用<literal>make install-strip</literal>代替<literal>make install</literal>， 在安装可执行文件和库文件时把它们剥离。 这样将节约一些空间。如果你编译时带着调试支持，那么抽取将有效地删除调试支持， 因此我们应该只是在不再需要调试的时候做这些事情。 <literal>install-strip</literal>力图做一些合理的工作来节约空间， 但是它并不了解如何从可执行文件中抽取每个不需要的字节， 因此，如果你希望节约所有可能节约的磁盘空间，那么你可能需要手工做些处理。
   </para>

   <para>
    标准的安装只提供客户端应用开发和服务器端程序开发所需的所有头文件，例如用 C 写的定制函数或者数据类型（在<productname>PostgreSQL</> 8.0 之前，后者需要独立地执行一次<literal>make  install-all-headers</>命令，不过现在这个步骤已经融合到标准的安装步骤中）。
   </para>

   <formalpara>
    <title>只安装客户端：</title>
    <para>
     如果你只想装客户应用和接口，那么你可以用下面的命令：
<screen>
<userinput>make -C src/bin install</>
<userinput>make -C src/include install</>
<userinput>make -C src/interfaces install</>
<userinput>make -C doc install</>
</screen>
    <filename>src/bin</>中有一些服务器专用的二进制文件，但是它们很小。
    </para>
   </formalpara>
  </step>
  </procedure>

  <formalpara>
   <title>卸载：</title>
   <para>
    要撤销安装可以使用命令<command>make uninstall</>。不过这样不会删除任何创建出来的目录。
   </para>
  </formalpara>

  <formalpara>
   <title>清理：</title>

   <para>
    在安装完成以后，你可以通过在源码树里面用命令<command>make clean</>删除编译文件。 这样会保留<command>configure</command>程序生成的文件，这样以后你就可以用<command>make</>命令重新编译所有东西。 要把源码树恢复为发布时的状态，可用<command>make distclean</>命令。 如果你想从同一棵源码树上为多个不同平台制作，你就一定要运行这条命令并且为每个编译重新配置（另外一种方法是在每种平台上使用一套独立的编译树，这样源代码树就可以保留不被更改）。
   </para>
  </formalpara>

  <para>
   如果你执行了一次制作，然后发现你的<command>configure</>选项是错误的， 或者你修改了任何<command>configure</>所探测的东西（例如，升级了软件）， 那么在重新配置和编译之前运行一下<command>make distclean</>是个好习惯。如果不这样做， 你修改的配置选项可能无法传播到所有需要变化的地方。
  </para>
 </sect1>

 <sect1 id="install-post">
  <title>安装后设置</title>

  <sect2>
   <title>共享库</title>

   <indexterm>
    <primary>共享库</primary>
   </indexterm>

   <!-- 
   <para>
    On some systems with shared libraries
    you need to tell the system how to find the newly installed
    shared libraries.  The systems on which this is
    <emphasis>not</emphasis> necessary include
    <systemitem class="osname">FreeBSD</>,
    <systemitem class="osname">HP-UX</>,
    <systemitem class="osname">Linux</>,
    <systemitem class="osname">NetBSD</>, <systemitem
    class="osname">OpenBSD</>, and
    <systemitem class="osname">Solaris</>.
   </para>
   -->
   <para>
    在一些有共享库的系统里，你需要告诉你的系统如何找到新安装的共享库。
    那些并<emphasis>不</emphasis>是必须做这个工作的系统包括
    <systemitem class="osname">FreeBSD</>、
    <systemitem class="osname">HP-UX</>、
    <systemitem class="osname">Linux</>、
    <systemitem class="osname">NetBSD</>、
    <systemitem class="osname">OpenBSD</>、
    和<systemitem class="osname">Solaris</>。
   </para>

   <para>
    设置共享库的搜索路径的方法因平台而异， 但是最广泛使用的方法是设置环境变量<envar>LD_LIBRARY_PATH</>，例如在 Bourne shells （<command>sh</>、<command>ksh</>、<command>bash</>、<command>zsh</>）中：
<programlisting>
LD_LIBRARY_PATH=/usr/local/pgsql/lib
export LD_LIBRARY_PATH
</programlisting>
    或者在<command>csh</>或<command>tcsh</>中：
<programlisting>
setenv LD_LIBRARY_PATH /usr/local/pgsql/lib
</programlisting>
    把<literal>/usr/local/pgsql/lib</>换成你在<xref linkend="configure">时设置的<option><literal>--libdir</></>。 你应该把这些命令放到 shell 启动文件，如<filename>/etc/profile</>或<filename>~/.bash_profile</>中。 和这个方法相关的一些注意事项和很好的信息可以在<ulink url="http://xahlee.org/UnixResource_dir/_/ldpath.html"></ulink>找到。
   </para>

   <para>
    在有些系统上，更好的方法可能是在编译<emphasis>之前</emphasis>设置环境变量<envar>LD_RUN_PATH</envar>。
   </para>

   <para>
    在<systemitem class="osname">Cygwin</systemitem>上，把库目录放在<envar>PATH</envar>中或者把<filename>.dll</filename>文件移动到<filename>bin</filename>目录。
   </para>

   <para>
    如果有疑问，请参考你的系统的手册页（可能是<command>ld.so</command>或<command>rld</command>）。 如果稍后你收到下面这样的消息：
<screen>
psql: error in loading shared libraries
libpq.so.2.1: cannot open shared object file: No such file or directory
</screen>
    那么这一步就是必须的了。这个只需关注一下就是了。
   </para>

   <para>
    <indexterm>
     <primary>ldconfig</primary>
    </indexterm>
    如果你用的系统是<systemitem class="osname">Linux</>，并且你还有 root 权限，那么你可以在安装之后运行：
<programlisting>
/sbin/ldconfig /usr/local/pgsql/lib
</programlisting>
    （或者等效的目录）以便让运行时链接器更快地找到共享库。请参考<command>ldconfig</>的手册页获取更多信息。在<systemitem class="osname">FreeBSD</>、<systemitem class="osname">NetBSD</>和<systemitem class="osname">OpenBSD</>上，命令是：
<programlisting>
/sbin/ldconfig -m /usr/local/pgsql/lib
</programlisting>
    我们不知道其它的系统有等效的命令。
   </para>
  </sect2>

  <sect2>
   <title>环境变量</title>

   <indexterm>
    <primary><envar>PATH</envar></primary>
   </indexterm>

   <para>
    如果你安装到<filename>/usr/local/pgsql</>或者其他默认不在搜索路径中的地方， 那你应该在你的<envar>PATH</>环境变量里面增加一个 <filename>/usr/local/pgsql/bin</>（或者是你在<xref linkend="configure">时给选项<option><literal>--bindir</></>设置的任何值） 。严格来说，这些都不是必须的，但这么做可以让你使用<productname>PostgreSQL</>更方便。
   </para>

   <para>
    要做这些事情，把下面几行加到你的 shell 启动文件，如<filename>~/.bash_profile</>（如果想影响所有用户就放在<filename>/etc/profile</>）：
<programlisting>
PATH=/usr/local/pgsql/bin:$PATH
export PATH
</programlisting>
    如果你用的是<command>csh</>或者<command>tcsh</>，那么用这条命令：
<programlisting>
set path = ( /usr/local/pgsql/bin $path )
</programlisting>
   </para>

   <para>
    <indexterm>
     <primary><envar>MANPATH</envar></primary>
    </indexterm>
    为了让你的系统找得到<application>man</>文档，你需要加类似下面的一行到一个shell启动文件里 （除非你安装到了默认搜索的位置）：
<programlisting>
MANPATH=/usr/local/pgsql/share/man:$MANPATH
export MANPATH
</programlisting>
   </para>

   <para>
    环境变量<envar>PGHOST</>和<envar>PGPORT</>为客户端应用指定了数据库服务器的主机和端口， 它们会覆盖编译时的默认项。如果你想从远程运行客户端应用， 那么为每个准备使用该数据库的用户都设置<envar>PGHOST</>将会非常方便。但这不是必须的，而且大部分客户端程序也可以通过命令行选项替换这些设置。
   </para>
  </sect2>
 </sect1>


<![%standalone-include;[
 <sect1 id="install-getting-started">
  <title>从头开始</title>

  <para>
   下面是关于如何让<productname>PostgreSQL</>在安装后启动和运行的快速总结。主文档包含更多信息。
  </para>

  <procedure>
   <step>
    <para>
     为<productname>PostgreSQL</>服务器创建一个用户账号。这是服务器将会以其身份运行的账号。对于生产环境，你应该创建一个独立的、非特权的账号（通常会用<quote>postgres</> is commonly used）。如果你确实没有 root 访问或者只是想玩玩，你自己的用户账号就足够了。将服务器作为 root 身份运行是一个安全风险并且不会工作。
<screen>
<userinput>adduser postgres</>
</screen>
    </para>
   </step>

   <step>
    <para>
     使用<command>initdb</>命令创建一个数据库安装。要运行<command>initdb</>，你必须登录到你的<productname>PostgreSQL</>服务器账号。在 root 下不能做这件事。
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</>
root# <userinput>chown postgres /usr/local/pgsql/data</>
root# <userinput>su - postgres</>
postgres$ <userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
</screen>
    </para>

    <para>
     <option>-D</>选项指定了数据将被存储的位置。你可以使用你想用的任何路径，它不一定需要位于安装目录下。在开始<command>initdb</>之前要确保所使用的服务器账号能够写入到该目录（或者创建它，如果它还不存在），如上所示。
    </para>
   </step>

   <step>
    <para>
     到这里，如果你没有使用<command>initdb</> <literal>-A</>选项，你可能想要修改<filename>pg_hba.conf</>以便在启动服务器之前控制到服务器的本地访问。默认值是信任所有本地用户。
    </para>
   </step>

   <step>
    <para>
     之前的<command>initdb</>步骤应该已经告诉你如何启动数据库服务器。那现在就照做。命令可能像这样：
<programlisting>
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
</programlisting>
     这将在前台启动服务器。要将服务器放在后台运行，请使用：
<programlisting>
nohup /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data \
    &lt;/dev/null &gt;&gt;server.log 2&gt;&amp;1 &lt;/dev/null &amp;
</programlisting>
    </para>

    <para>
     要停止一个运行在后台的服务器，你可以输入：
<programlisting>
kill `cat /usr/local/pgsql/data/postmaster.pid`
</programlisting>
    </para>
   </step>

   <step>
    <para>
     创建一个数据库：
<screen>
<userinput>createdb testdb</>
</screen>
     然后输入：
<screen>
<userinput>psql testdb</>
</screen>
     来连接到那个数据库。在提示符下你可以输入 SQL 命令并开始实验。
    </para>
   </step>
  </procedure>
 </sect1>

 <sect1 id="install-whatnow">
  <title>现在该干什么？</title>

  <para>
   <itemizedlist>
    <listitem>
     <para>
      <productname>PostgreSQL</>发布包含一份详尽的文档集，你应当时常阅读它们。在安装之后，文档可以通过你的浏览器访问，只要将浏览器指向<filename>/usr/local/pgsql/doc/html/index.html</>，除非你修改了安装目录。
     </para>

     <para>
      主文档的前几章是教程，如果你对于<acronym>SQL</>数据库一无所知，它们应该是你首先要阅读的内容。如果你熟悉数据库概念，那么你希望前进到服务器管理的部分，其中包含了如何设置数据库服务器、数据库用户和认证等信息。
     </para>
    </listitem>

    <listitem>
     <para>
      通常，你将希望修改你的计算机这样它将在启动时自动开始数据库服务器。文档中有关于此的建议。
     </para>
    </listitem>

    <listitem>
     <para>
      对安装好的服务器运行回归测试（使用<command>make installcheck</command>）。如果你没有在安装之前运行测试，你绝对应该现在做一次。这也在文档中有解释。
     </para>
    </listitem>

    <listitem>
     <para>
      默认情况下，<productname>PostgreSQL</>被配置为在最小硬件需求环境下运行。这使得它可以在几乎任何硬件配置下启动。但是，默认的配置不是为最优性能设计的。要达到最优性能，需要调整一些服务器参数，两个最常用的是<varname>shared_buffers</varname>和<varname>work_mem</varname>。其他文档中提到的参数也会影响性能。
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </sect1>
]]>


 <sect1 id="supported-platforms">
  <title>平台支持</title>

  <para>
   如果代码包含规定要工作在一个平台（即一种 CPU 架构和操作系统的结合）上并且它最近已经被验证能在该平台上编译并通过其回归测试，<productname>PostgreSQL</>开发社区才会认为该平台是被支持的。目前，大部分平台兼容性的测试都是由<ulink url="http://buildfarm.postgresql.org/">PostgreSQL 编译农场</ulink>的测试机器自动完成的。如果你对在一个并没有出现在编译农场中的平台上运行<productname>PostgreSQL</>感兴趣，但是代码确实能够工作或者能被修改得工作，我们强烈鼓励你建立一个编译农场成员机器，这样进一步的兼容性可以被确认。
  </para>

  <!-- 
  <para>
   In general, <productname>PostgreSQL</> can be expected to work on
   these CPU architectures: x86, x86_64, IA64, PowerPC,
   PowerPC 64, S/390, S/390x, Sparc, Sparc 64, ARM, MIPS, MIPSEL, M68K,
   and PA-RISC.  Code support exists for M32R and VAX, but these
   architectures are not known to have been tested recently.  It is often
   possible to build on an unsupported CPU type by configuring with
   <option>-&#045;disable-spinlocks</option>, but performance will be poor.
  </para>
  -->
  <para>
   通常，<productname>PostgreSQL</>被期望能在这些 CPU 架构上工作：
   x86、x86_64、IA64、PowerPC、PowerPC 64、S/390、S/390x、Sparc、Sparc 64、
   ARM、MIPS、MIPSEL、M68K和PA-RISC。存在对 M32R 和 VAX 的代码支持，
   但是这些架构上并没有近期测试的报告。
   通常也可以在一个为支持的 CPU 类型上通过使用<option>--disable-spinlocks</option>
   配置来进行编译，但是性能将会比较差。
  </para>

  <!-- 
  <para>
   <productname>PostgreSQL</> can be expected to work on these operating
   systems: Linux (all recent distributions), Windows (Win2000 SP4 and later),
   FreeBSD, OpenBSD, NetBSD, OS X, AIX, HP/UX, Solaris,
   and UnixWare.  Other Unix-like systems may also work but are not currently
   being tested.  In most cases, all CPU architectures supported by
   a given operating system will work.  Look in
   the <xref linkend="installation-platform-notes"> below to see if
   there is information
   specific to your operating system, particularly if using an older system.
  </para>
  -->
  <para>
   <productname>PostgreSQL</>被期望能在这些操作系统上工作： Linux
   （所有最近的发布）、Windows（Win2000 SP4及以上）、
   FreeBSD、OpenBSD、NetBSD、OS X、AIX、HP/UX、Solaris 和 UnixWare。
   其他类 Unix 系统可能也可以工作，但是目前没有被测试。在大部分情况下，
   一个给定操作系统所支持的所有 CPU 架构都能工作。
   查找下文的<xref linkend="installation-platform-notes">
   来看是否有与你的操作系统相关的信息，特别是使用一个老的系统时更应该这样做。
  </para>

  <para>
   如果你在一个平台上有安装问题，并且该平台根据最近的编译农场结果已经可以被支持，请将问题报告给<email>pgsql-bugs@postgresql.org</email>。如果你有兴趣将<productname>PostgreSQL</>移植到一个新的平台，<email>pgsql-hackers@postgresql.org</email>是一个合适的讨论它的地方。
  </para>
 </sect1>

 <sect1 id="installation-platform-notes">
  <title>平台相关的说明</title>

  <para>
   这一节提供了考虑 PostgreSQL 安装和设置的附加平台相关的话题。确保阅读安装知道，特别是<xref linkend="install-requirements">。同样，检查关于回归测试结果解释的<![%standalone-include[文件<filename>src/test/regress/README</>和文档]]>
   <![%standalone-ignore[<xref linkend="regress">]]>。
  </para>

  <para>
   这里没有覆盖的平台不存在平台相关的安装问题。
  </para>

  <sect2 id="installation-notes-aix">
   <title>AIX</title>

   <indexterm zone="installation-notes-aix">
    <primary>AIX</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    PostgreSQL 能在 AIX 上工作，但是正确地安装它却富有挑战性。从4.3.3到6.1的 AIX 被认为是可支持的。你可以使用 GCC 或本地 IBM 编译器<command>xlc</command>。通常，使用最新版本的 AIX 和 PostgreSQL 能有所帮助。在编译农场中检查有关已知能工作的 AIX 版本的最新信息。
   </para>

   <para>
    被支持的 AIX 版本的最小推荐修理级别是：
   </para>

   <variablelist>
    <varlistentry>
     <term>AIX 4.3.3</term>
     <listitem><para>Maintenance Level 11 + post ML11 bundle</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.1</term>
     <listitem><para>Maintenance Level 9 + post ML9 bundle</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.2</term>
     <listitem><para>Technology Level 10 Service Pack 3</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 5.3</term>
     <listitem><para>Technology Level 7</para></listitem>
    </varlistentry>

    <varlistentry>
     <term>AIX 6.1</term>
     <listitem><para>Base Level</para></listitem>
    </varlistentry>
   </variablelist>

   <para>
    要检查你当前的修理级别，在AIX 4.3.3 至 AIX 5.2 ML 7中使用
    <command>oslevel -r</command>，或者在后面的版本中使用
    <command>oslevel -s</command>。
   </para>

   <para>
    如果你已经在<literal>/usr/local</>中安装了 Readline 或 libz，在你自己的选项之外使用下列<command>configure</command>标志：
    <literal>--with-includes=/usr/local/include
    --with-libraries=/usr/local/lib</literal>.
   </para>

   <sect3>
    <title>GCC问题</title>

    <para>
     在 AIX 5.3 上，使用 GCC 编译和运行 PostgreSQL 有一些问题。
    </para>

    <para>
     你将要使用 GCC 继 3.3.2 之后的一个版本，特别是如果你在使用一个打包好的版本。我们在 4.0.1 上获得了成功。早期版本的问题看起来更多地与 IBM 打包的 GCC 有关，而非 GCC 真正的问题，因此如果你自己编译 GCC， 你更有可能使用早期版本的 GCC 取得成功。
    </para>
   </sect3>

   <sect3>
    <title>Unix域套接字崩溃</title>

    <para>
     AIX 5.3 有一个问题是<structname>sockaddr_storage</structname>定义得不够大。在版本 5.3 中，IBM 增加了<structname>sockaddr_un</structname>（Unix域套接字的地址结构）的尺寸，但是没有相应地增加<structname>sockaddr_storage</structname>的尺寸。这样做的结果是在 PostgreSQL 中尝试使用 Unix域套接字会导致 libpq 让该数据结构溢出。 TCP/IP 连接工作正常，但是 Unix域套接字不行，这将使回归测试不能工作。
    </para>

    <para>
     该问题已经被报告给了 IBM，并且已被记录为缺陷报告 PMR29657。如果你升级到 maintenance level 5300-03 或更新，将会包括这个修复。一种快速的解决方法是把<filename>/usr/include/sys/socket.h</filename>中的<symbol>_SS_MAXSIZE</symbol>改成 1025。在两种情况中，一旦你得到了修正过的头文件，你都需要重编译 PostgreSQL。
    </para>
   </sect3>

   <sect3>
    <title>Internet地址问题</title>

    <para>
     PostgreSQL 依赖系统的<function>getaddrinfo</>函数来解析<varname>listen_addresses</>、<filename>pg_hba.conf</>等中的 IP 地址。旧版本的 AIX 在这个函数中有各种各样的缺陷。如果你存在与此有关的问题，更新到上文所示的合适的 AIX fix level 将会解决它。
    </para>

    <!-- http://archives.postgresql.org/message-id/6064jt6cfm.fsf_-_@dba2.int.libertyrms.com -->

    <para>
     一个用户报告：
    </para>

    <para>
     当在 AIX 5.3 上实现 PostgreSQL 版本 8.1 时，我们会周期性地碰到问题，在其中统计收集器会<quote>神秘地</quote>无法成功启动。这似乎是在 IPv6 实现中意外行为的结果。看起来 PostgreSQL 和 IPv6 无法和 AIX 5.3 一起很好地工作。
    </para>

    <para>
     下面任意一种动作都可以<quote>修复</quote>该问题。
     <itemizedlist>
      <listitem>
       <para>
        删除 localhost 的 IPv6 地址：
<screen>
(as root)
# ifconfig lo0 inet6 ::1/0 delete
</screen>
       </para>
      </listitem>

      <listitem>
       <para>
        从网络服务删除 IPv6。AIX 上的<filename>/etc/netsvc.conf</filename>大概等价于 Solaris/Linux 上的<filename>/etc/nsswitch.conf</filename>。在 AIX 上的默认值因此是：
<programlisting>
hosts=local,bind
</programlisting>
        将其换成：
<programlisting>
hosts=local4,bind4
</programlisting>
        来使 IPv6 地址的搜索无效。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <warning>
    <para>
     这实际上是对有关 IPv6 支持不成熟性的问题的一种变通方案，这在 AIX 5.3 发布的过程中有了显著地改进。它可以和 AIX 5.3 一起工作，但是不代表对此问题的一种华丽的解决方案。有报告称该变通方案不仅仅是多余的，还会在 AIX 6.1 上导致问题，在 AIX 6.1 中 IPv6 支持已变得更加成熟。
    </para>
    </warning>

   </sect3>

   <sect3>
    <title>内存管理</title>
    <!-- http://archives.postgresql.org/message-id/603bgqmpl9.fsf@dba2.int.libertyrms.com -->

    <para>
     AIX 的特别之处在于它的内存管理。你可能有一个装备有好多个吉字节空闲 RAM 的服务器，但是在运行应用时仍然会得到内存不足或者地址空间错误。一个例子是<command>createlang</command>会因为罕见的错误失败。例如，作为 PostgreSQL 安装的拥有者运行：
<screen>
-bash-3.00$ createlang plperl template1
createlang: language installation failed: ERROR:  could not load library "/opt/dbs/pgsql748/lib/plperl.so": A memory address is not in the address space for the process.
</screen>
    作为拥有 PostgreSQL 安装的组中的非拥有者运行：
<screen>
-bash-3.00$ createlang plperl template1
createlang: language installation failed: ERROR:  could not load library "/opt/dbs/pgsql748/lib/plperl.so": Bad address
</screen>
     另一个例子是 PostgreSQL 服务器日志中的内存不足错误，每次内存分配接近或者超过 256 MB 时都会失败。
    </para>

    <para>
     所有这些问题的总体成因是服务器进程所用的寻址空间和内存模型。默认情况下，所有在 AIX 上编译的二进制都是32位。这并不依赖于硬件类型或使用的内核。这些32位进程被限制在 4GB 的内存中，并被使用几种模型之一安排成 256 MB 的段。该默认值允许在堆中低于 256 MB，因为它和栈共享一个单独的段。
    </para>

    <para>
     在<command>createlang</command>的例子中，检查你的 umask 和你的 PostgreSQL 安装中的二进制的权限。这个例子中涉及的二进制是32位的并且被用模式 750 而不是 755 安装。由于这种方式的权限设置，只有所有者或拥有组的成员可以载入该库。因为它不是所有人可读的，载入器将该对象放在进程的堆中而不是它应该被放入的共享库段中。
    </para>

    <para>
     这个问题的<quote>理想的</quote>解决方案是使用 PostgreSQL 的64位编译，但是这不是总是实用的，因为有32位处理器的系统可以编译64位二进制但是却不能运行它。
    </para>

    <para>
     如果想要一个 32 位二进制，在开始 PostgreSQL 服务器之前将<symbol>LDR_CNTRL</symbol>设置为<literal>MAXDATA=0x<replaceable>n</replaceable>0000000</literal>，其中 1 &lt;= n &lt;= 8，并且尝试不同的值以及<filename>postgresql.conf</filename>设置来找一个能让你满意的配置。这种<symbol>LDR_CNTRL</symbol>的使用告诉 AIX 你希望服务器留出<symbol>MAXDATA</symbol>字节给堆，以 256 MB 的段分配。当你找到了一个可工作的配置时，<command>ldedit</command>可以被用来修改二进制，这样它们默认使用想要的堆尺寸。PostgreSQL 也可以被重新编译，传递<literal>configure  LDFLAGS="-Wl,-bmaxdata:0x<replaceable>n</replaceable>0000000"</literal>来达到相同的效果。
    </para>

    <para>
     对于一个 64 位编译，设置<envar>OBJECT_MODE</envar>为 64 并且传递<literal>CC="gcc -maix64"</literal>和<literal>LDFLAGS="-Wl,-bbigtoc"</literal>给<command>configure</command>（给<command>xlc</command>的选项可能不同）。如果你省略<envar>OBJECT_MODE</envar>的输出，你的编译可能会因为链接器错误而失败。当<envar>OBJECT_MODE</envar>被设置时，它告诉 AIX 的编译工具（如<command>ar</>、<command>as</>和<command>ld</>）默认要处理哪些对象类型。
    </para>

    <para>
     默认情况下，过量使用页面空间的情况可能会发生。不过我们还没有看到过，当进程用尽内存并且出现了过量使用时 AIX 会杀死进程。我们见到过的最接近于此的是 fork 失败，其原因是系统觉得已经没有足够的内存给另一个进程。和 AIX 的很多其他部分一样，如果这成为了一个问题，页面空间分配方法和耗尽内存导致的杀死在系统范围或进程范围是可以配置的。
    </para>

    <bibliography>
     <title>参考和资源</title>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/lrg_prg_support.htm">Large Program Support</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/address_space.htm">Program Address Space Overview</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/resmgmt2.htm">Performance Overview of the Virtual Memory Manager (VMM)</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf7.htm">Page Space Allocation</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
      <biblioset relation="article">
       <title><ulink url="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf6.htm">Paging-space thresholds tuning</ulink></title>
      </biblioset>
      <biblioset relation="book">
       <title>AIX Documentation: Performance Management Guide</title>
      </biblioset>
     </biblioentry>

     <biblioentry>
       <title><ulink url="http://www.redbooks.ibm.com/abstracts/sg245674.html?Open">Developing and Porting C and C++ Applications on AIX</ulink></title>
       <publisher>
        <publishername>IBM Redbook</publishername>
       </publisher>
     </biblioentry>
    </bibliography>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-cygwin">
   <title>Cygwin</title>

   <indexterm zone="installation-notes-cygwin">
    <primary>Cygwin</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    PostgreSQL 可以使用 Cygwin 来编译，它是用于 Windows 的一个类 Linux 环境，但是这种方法不如原生 Windows 编译<![%standalone-ignore[（见<xref linkend="install-windows">）]]>并且我们已经不再推荐在 Cygwin 下运行一个服务器。
   </para>

   <para>
    在从源代码编译时，按照正常安装过程进行（即<literal>./configure;
    make</literal>; 等；只要注意下列 Cygwin 相关的区别：

    <itemizedlist>
     <listitem>
      <para>
       将你的路径设置为使用 Cygwin 的 bin 目录并且把它放在 Windows 工具的前面。这将帮助避免很多编译的问题。
      </para>
     </listitem>

     <listitem>
      <para>
       不支持<command>adduser</command>命令；使用 Windows NT、2000 或 XP 上的用户管理应用来替代。否则，跳过这一步。
      </para>
     </listitem>

     <listitem>
      <para>
       不支持<command>su</command>命令；在 Windows NT、2000 或 XP 上使用 ssh 来模拟 su。否则，跳过这一步。
      </para>
     </listitem>

     <listitem>
      <para>
       不支持 OpenSSL。
      </para>
     </listitem>

     <listitem>
      <para>
       为共享内存支持启动<command>cygserver</command>。要这样做，输入命令<literal>/usr/sbin/cygserver &amp;</literal>。这个程序在你启动 PostgreSQL 服务器或初始化一个数据集簇（<command>initdb</command>）时的任何时刻都需要被运行。默认的<command>cygserver</command>配置可能需要被更改（例如增加<symbol>SEMMNS</symbol>）来防止 PostgreSQL 因为缺少系统资源而失败。
      </para>
     </listitem>

     <listitem>
      <para>
        在某些不使用 C 区域的系统上编译可能会失败。要修复这个问题，通过在边以前<command>export LANG=C.utf8</command>把区域设置为 C，并且在安装完 PostgreSQL 之后把区域恢复成之前的设置。
      </para>
     </listitem>

     <listitem>
      <para>
       并行回归测试（<literal>make check</literal>）可能产生虚假的回归测试错误，这是由于溢出的<function>listen()</function>连接缓冲区，它会导致连接拒绝错误或挂起。你可以使用<varname>MAX_CONNECTIONS</varname>来限制连接数：
<programlisting>
make MAX_CONNECTIONS=5 check
</programlisting>
       （在某些系统上你可以有大约 10 个同时连接）。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    可以把<command>cygserver</command> PostgreSQL 服务器安装为 Windows NT 服务。关于如何这样做的信息，请参考包含在 Cygwin 上 PostgreSQL 二进制包中的<filename>README</filename>文档。它被安装在目录<filename>/usr/share/doc/Cygwin</filename>中。
   </para>
  </sect2>

  <sect2 id="installation-notes-hpux">
   <title>HP-UX</title>

   <indexterm zone="installation-notes-hpux">
    <primary>HP-UX</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    给定合适的系统补丁级别和编译工具，PostgreSQL 7.3+ 应该可以工作在运行 HP-UX 10.X 或 11.X 的 Series 700/800 PA-RISC 机器上。至少一个开发者例行地在 HP-UX 10.20 上测试过，并且我们有在 HP-UX 11.00 和 11.11 上成功安装的报告。
   </para>

   <para>
    除了 PostgreSQL 源代码发布，你将需要 GNU make（HP 的 make 不行），并且需要 GCC 或 HP 的 ANSI C 编译器。如果你想从 Git 源编译而不是一个发布包，你还将需要 Flex（GNU lex）和 Bison（GNU yacc）。我们还推荐确认你真的在使用最新的 HP 补丁。最低限度下，如果你在 HP-UX 11.11 上编译 64 位二进制，你可能需要 PHSS_30966 (11.11) 或一个后继补丁，否则<command>initdb</command>可能中止：
<literallayout>
PHSS_30966  s700_800 ld(1) and linker tools cumulative patch
</literallayout>

    在一般原则上，你应该使用 libc 和 ld/dld 的当前补丁，如果你在使用 HP 的 C 编译器也一样要用当前的编译器补丁。它们最新补丁的免费拷贝请见 HP 的支持站点如<ulink url="http://itrc.hp.com"></ulink>和<ulink url="ftp://us-ffs.external.hp.com/"></ulink>。
   </para>

   <para>
    如果你正在一台 PA-RISC 2.0 机器上编译并且项使用 GCC 得到 64 位二进制，你必须使用 GCC 的 64 位版本。HP-UX PA-RISC 和 Itanium 的 GCC 二进制可以从<ulink url="http://www.hp.com/go/gcc"></ulink>得到。别忘了在同时获取并安装 binutils。
   </para>

   <para>
    如果你正在一台 PA-RISC 2.0 机器上编译并且想让编译好的二进制运行在 PA-RISC 1.1 机器上，你将需要在<envar>CFLAGS</envar>中指定<option>+DAportable</option>。
   </para>

   <para>
    如果你正在一台 HP-UX Itanium 机器上编译，你将需要最新的 HP ANSI C 编译器，以及它的依赖补丁或后继补丁：
<literallayout>
PHSS_30848  s700_800 HP C Compiler (A.05.57)
PHSS_30849  s700_800 u2comp/be/plugin library Patch
</literallayout>
   </para>

   <para>
    如果你同时有 HP 的 C 编译器和 GCC 的编译器，那么在运行<command>configure</command>时你可能希望显式地选择要使用的编译器：
<programlisting>
./configure CC=cc
</programlisting>
    用于 HP 的 C 编译器，或者
<programlisting>
./configure CC=gcc
</programlisting>
    用于 GCC。如果你忽略这个设置，configure 在可以选择时会使用<command>gcc</command>。
   </para>

   <para>
    默认的安装目标位置是<filename>/usr/local/pgsql</filename>，你可能希望修改它为<filename>/opt</filename>之下的某个地方。如果是这样，使用<command>configure</command>的<option>--prefix</option>开关。
   </para>

   <para>
    在回归测试中，在几何测试中可能会有某些低序位差别，这会根据你使用的编译器和数学库版本而变化。任何其他错误都需要怀疑。
   </para>
  </sect2>

  <sect2 id="installation-notes-mingw">
   <title>MinGW/原生 Windows</title>

   <indexterm zone="installation-notes-mingw">
    <primary>MinGW</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    用于 Windows 的 PostgreSQL 可以使用 MinGW 编译，它是一个用于微软操作系统的类 Unix 的编译环境。也可以使用微软的<productname>Visual C++</productname>编译器套件来编译。MinGW 编译使用本章中描述的正常编译系统；而  Visual C++ 编译的工作完全不同并且在<![%standalone-include[the
    documentation]]><![%standalone-ignore[<xref linkend="install-windows">]]>中描述。后者是一种完全原生的编译并且没有像 MinGW 那样使用额外软件。在 PostgreSQL 的主网站上有一个现成的安装器可用。
   </para>

   <para>
    原生 Windows 移植要求一个 Windows 2000 或更高的 32 或 64 位版本。早期的操作系统没有足够的基础设施（但 Cygwin可以用在它们之上）。类 Unix 的编译工具 MinGW 和 MSYS（一个 Unix 工具集合，用于运行如<command>configure</command>之类的 shell 脚本）可以从<ulink url="http://www.mingw.org/"></ulink>下载。运行结果二进制两者都需要，它们只在创建二进制时需要。
   </para>

   <!-- 
   <para>
     To build 64 bit binaries using MinGW, install the 64 bit tool set
     from <ulink url="http://mingw-w64.sourceforge.net/"></ulink>, put its bin
     directory in the <envar>PATH</envar>, and run
     <command>configure</command> with the
     <command>-&#045;host=x86_64-w64-mingw32</command> option.
   </para>
   -->
   <para>
     要使用 MinGW 编译 64 位二进制，安装来自
     <ulink url="http://mingw-w64.sourceforge.net/"></ulink>的 64 位工具。
     把它的 bin 目录放在<envar>PATH</envar>中，并且使用
     <command>--host=x86_64-w64-mingw32</command>选项运行<command>configure</command>.
   </para>

   <para>
    在你安装完所有的东西之后，我们建议你在<command>CMD.EXE</command>下运行<application>psql</application>，因为 MSYS 控制台有缓冲问题。
   </para>

   <sect3 id="windows-crash-dumps">
    <title>在 Windows 上收集崩溃转储</title>

    <para>
     如果 PostgreSQL 在 Windows 上崩溃，它有能力产生<productname>minidumps</>，这可以被用来追踪崩溃发生的原因，这与 Unix 上的核心转储相似。这些转储可以被使用<productname>Windows Debugger Tools</>或<productname>Visual Studio</>读取。要启用在 Windows 上的转储生成，可在集簇数据目录下创建一个名为<filename>crashdumps</filename>的子目录。转储将被写入到这个目录，转储的名字基于崩溃进程的标识符和崩溃的当前时间来确定。
    </para>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-sco">
   <title>SCO OpenServer 和 SCO UnixWare</title>

   <indexterm zone="installation-notes-sco">
    <primary>SCO</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <indexterm zone="installation-notes-sco">
    <primary>UnixWare</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    PostgreSQL 可以在 SCO UnixWare 7 和 SCO OpenServer 5 上编译。在 OpenServer 上，你可以使用 OpenServer Development Kit 或 Universal Development Kit。但是可能需要一些调整，如下所述。
   </para>

   <sect3>
    <title>Skunkware</title>

    <para>
     你应该找到你的 SCO Skunkware CD 的拷贝。Skunkware CD 被包括在 UnixWare 7 和当前版本的 OpenServer 5。Skunkware 包括很多在互联网上可以得到的流行程序的待安装版本。例如，gzip、gunzip、GNU Make、Flex 和 Bison 都被包括在内。对于 UnixWare 7.1，这个 CD 现在被标为 "Open License Software Supplement"。如果你没有这个 CD，其中的软件可以从<ulink url="http://www.sco.com/skunkware/"></ulink>得到。
    </para>

    <para>
     对于 UnixWare 和 OpenServer，Skunkware有不同的版本。请确保你为你的操作系统安装了正确的版本，除了以下需要注意的。
    </para>

    <para>
     在 UnixWare 7.1.3 及其以后，GCC 被包括在 UDK CD 上作为 GNU Make。
    </para>
   </sect3>

   <sect3>
    <title>GNU Make</title>

    <para>
     你需要使用 GNU Make 程序，它位于 Skunkware CD 上。默认情况下，它作为<filename>/usr/local/bin/make</filename>安装。
    </para>

    <para>
     对于 UnixWare 7.1.3 及以上，GNU Make 程序是 UDK CD 的 OSTK 部分，并且在<filename>/usr/gnu/bin/gmake</filename>中。
    </para>
   </sect3>

   <sect3>
    <title>Readline</title>

    <para>
     Readline 库在 Skunkware CD 上。但是它不被包括在 UnixWare 7.1 Skunkware CD 上。如果你有 UnixWare 7.0.0 或 7.0.1 Skunkware CD，你可以从那里安装 Readline 库。否则，试试<ulink url="http://www.sco.com/skunkware/"></ulink>。
    </para>

    <para>
     默认情况下，Readline 安装到<filename>/usr/local/lib</>和<filename>/usr/local/include</>。但是，PostgreSQL <command>configure</command> 程序在没有得到帮助的情况下将不能找到它。如果你安装了 Readline，那么对<command>configure</command>使用下列选项：
<programlisting>
./configure --with-libraries=/usr/local/lib --with-includes=/usr/local/include
</programlisting>
    </para>
   </sect3>

   <sect3>
    <title>在 OpenServer 上使用 UDK</title>

    <para>
     如果你正在 OpenServer 上使用新的 Universal Development Kit (UDK) 编译器，你需要指定 UDK 库的位置：
<programlisting>
./configure --with-libraries=/udk/usr/lib --with-includes=/udk/usr/include
</programlisting>
     把这些和 Readline 选项放在一起：
<programlisting>
./configure --with-libraries="/udk/usr/lib /usr/local/lib" --with-includes="/udk/usr/include /usr/local/include"
</programlisting>
    </para>
   </sect3>

   <sect3>
    <title>阅读 PostgreSQL 手册页</title>

    <!-- 
    <para>
     By default, the PostgreSQL man pages are installed into
     <filename>/usr/local/pgsql/share/man</filename>.  By default, UnixWare
     does not look there for man pages.  To be able to read them you
     need to modify the
     <varname>MANPATH</varname> variable
     in <filename>/etc/default/man</filename>, for example:
<programlisting>
MANPATH=/usr/lib/scohelp/%L/man:/usr/dt/man:/usr/man:/usr/share/man:scohelp:/usr/local/man:/usr/local/pgsql/share/man
</programlisting>
    </para>
    -->
    <para>
     默认情况下，PostgreSQL 手册页被安装到<filename>/usr/local/pgsql/man</filename>。
     默认情况下，UnixWare 不会在那里查看手册页。要能够阅读它们你需要修改
     <filename>/etc/default/man</filename>中的<varname>MANPATH</varname>变量，例如：
<programlisting>
MANPATH=/usr/lib/scohelp/%L/man:/usr/dt/man:/usr/man:/usr/share/man:scohelp:/usr/local/man:/usr/local/pgsql/share/man
</programlisting>
    </para>

    <para>
     在 OpenServer 上，某些额外的研究需要被覆盖来使得手册页可用，因为其手册系统与其他平台有点不同。当前，PostgreSQL 将根本不会安装它们。
    </para>
   </sect3>

   <sect3>
    <title>带 7.1.1b 特性补充的 C99 问题</title>

    <para>
     对于那些早于随 OpenUNIX 8.0.0（UnixWare 7.1.2）一起发布的编译器版本的编译器，它们包括 7.1.1b 特性补充，你可能需要在<varname>CFLAGS</varname>或<varname>CC</varname>环境变量中指定<option>-Xb</option>。这种问题的迹象是在编译引用内联函数的<filename>tuplesort.c</filename>时的一个错误。显然在 7.1.2（8.0.0）及以后的编译器中已有修改。
    </para>
   </sect3>

   <sect3>
    <title>UnixWare 上的线程</title>

    <para>
     对于线程，你<emphasis>必须</emphasis>在<emphasis>所有</emphasis>使用libpq的程序上使用<option>-Kpthread</option>。libpq使用<function>pthread_*</function>调用，这些只能在有<option>-Kpthread</>/<option>-Kthread</>标志的情况下可用。
    </para>
   </sect3>
  </sect2>

  <sect2 id="installation-notes-solaris">
   <title>Solaris</title>

   <indexterm zone="installation-notes-solaris">
    <primary>Solaris</primary>
    <secondary>installation on</secondary>
   </indexterm>

   <para>
    PostgreSQL 在 Solaris 上得到了很好的支持。你的操作系统越新，你将会碰到更少的问题；细节如下。
   </para>

   <sect3>
    <title>要求的工具</title>

    <para>
     你可以使用 GCC 或 Sun 的编译器套件进行编译。为了更好的代码优化，我们强烈推荐在 SPARC 架构下使用 Sun 的编译器。我们已经得到一些使用 GCC 2.95.1 时的问题报告；我们推荐 GCC 2.95.3 或之后的版本。如果你正在使用 Sun 的编译器，注意不要选择<filename>/usr/ucb/cc</filename>；而是使用<filename>/opt/SUNWspro/bin/cc</filename>。
    </para>

    <para>
     你可以从<ulink url="http://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/"></ulink>下载 Sun Studio。很多 GNU 工具都被整合到了 Solaris 10，或者它们在 Solaris companion CD 中。如果你喜欢用于老版本 Solaris 的包，你可以在<ulink url="http://www.sunfreeware.com"></ulink>找到这些工具。如果你想要源码，在<ulink url="http://www.gnu.org/order/ftp.html"></ulink>上找找。
    </para>
   </sect3>

   <sect3>
    <title>OpenSSL 的问题</title>

    <para>
     当你编译 PostgreSQL 带有 OpenSSL 支持时，你可能在下列文件中得到编译错误：
     <itemizedlist>
      <listitem><para><filename>src/backend/libpq/crypt.c</filename></para></listitem>
      <listitem><para><filename>src/backend/libpq/password.c</filename></para></listitem>
      <listitem><para><filename>src/interfaces/libpq/fe-auth.c</filename></para></listitem>
      <listitem><para><filename>src/interfaces/libpq/fe-connect.c</filename></para></listitem>
     </itemizedlist>

     这是由于标准<filename>/usr/include/crypt.h</filename>头部和 OpenSSL 提供的头文件之间的一个名字空间冲突导致的。
    </para>

    <para>
     升级你的 OpenSSL 安装到版本 0.9.6a 来修复这个问题。 Solaris 9 及以上有一个更新版本的 OpenSSL。
    </para>
   </sect3>

   <sect3>
    <title>configure 抱怨一个失败的测试程序</title>

    <para>
     如果<command>configure</command>抱怨一个失败的测试程序，可能的情况是运行时链接器无法找到某些库，可能是libz、libreadline或某些其他非标准库如 libssl。要向它指出正确的位置，在<command>configure</command>命令行上设置<envar>LDFLAGS</envar>环境变量，例如：
<programlisting>
configure ... LDFLAGS="-R /usr/sfw/lib:/opt/sfw/lib:/usr/local/lib"
</programlisting>
     更多信息可见<citerefentry><refentrytitle>ld</><manvolnum>1</></citerefentry>手册页。
    </para>
   </sect3>

   <sect3>
    <title>64-位编译有时会崩溃</title>

    <para>
     在 Solaris 7 和更老的版本上，64-位版本的 libc 有一个有缺陷的<function>vsnprintf</function>例程，这导致 PostgreSQL 中不稳定的核心转储。最简单的已知解决方案是强制 PostgreSQL 使用它自己的<function>vsnprintf</function>版本而不是库中的拷贝。要这样做，运行<command>configure</command>之后编辑一个由<command>configure</command>产生的文件：
     在文件<filename>src/Makefile.global</filename>中将行
<programlisting>
LIBOBJS =
</programlisting>
     改成
<programlisting>
LIBOBJS = snprintf.o
</programlisting>
     （可能有其他文件已经被列在这个变量中。顺序无影响）。然后正常编译。
    </para>
   </sect3>

   <sect3>
    <title>为最优性能编译</title>

    <para>
     在 SPARC 架构上，我们强烈推荐使用 Sun Studio来编译。尝试使用<option>-xO5</option>优化标志来生成显著加快的二进制。不要使用任何修改浮点操作和<varname>errno</varname>处理（例如<option>-fast</option>）行为的标志。这些标志可能会做出某些非标准 PostgreSQL 行为，例如在日期/时间计算中。
    </para>

    <para>
     如果你没有理由要使用 SPARC 上的 64 位二进制，最好用 32 位版本。64 位操作较慢并且 64 位二进制比其 32 位变体要慢。并且在另一方面，AMD64 CPU 家族上的32 位代码不是原生的，并且这也是问什么在这个 CPU 族中 32 位代码要明显地更慢。
    </para>
   </sect3>

   <sect3>
    <title>用 DTrace 来跟踪 PostgreSQL</title>

    <para>
     是的，可以使用 DTrace。详见<![%standalone-include[the
     documentation]]>
     <![%standalone-ignore[<xref linkend="dynamic-trace">]]>。你还可以在这篇文章<ulink url="https://blogs.oracle.com/robertlor/entry/user_level_dtrace_probes_in"></ulink>中找到更多信息。
    </para>

    <para>
     如果你看到<command>postgres</command>可执行程序的链接中断并且报出下面的错误消息：
<screen>
Undefined                       first referenced
 symbol                             in file
AbortTransaction                    utils/probes.o
CommitTransaction                   utils/probes.o
ld: fatal: Symbol referencing errors. No output written to postgres
collect2: ld returned 1 exit status
make: *** [postgres] Error 1
</screen>
     说明你的 DTrace 安装太旧，无法处理静态函数中的探测。你需要 Solaris 10u4 或更新的版本。
    </para>
   </sect3>
  </sect2>
 </sect1>

</chapter>
