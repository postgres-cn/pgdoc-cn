<!-- doc/src/sgml/sepgsql.sgml -->

<sect1 id="sepgsql" xreflabel="sepgsql">
<!--==========================orignal english content==========================
 <title>sepgsql</title>
____________________________________________________________________________-->
 <title>sepgsql</title>

<!--==========================orignal english content==========================
 <indexterm zone="sepgsql">
  <primary>sepgsql</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sepgsql">
  <primary>sepgsql</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  <filename>sepgsql</> is a loadable module that supports label-based
  mandatory access control (MAC) based on <productname>SELinux</> security
  policy.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>sepgsql</>是一个基于<productname>SELinux</>安全策略的
  支持基于标签的强制访问控制（MAC）模块。
 </para>

 <warning>
<!--==========================orignal english content==========================
   <para>
     The current implementation has significant limitations, and does not
     enforce mandatory access control for all actions.  See
     <xref linkend="sepgsql-limitations">.
   </para>
____________________________________________________________________________-->
   <para>
     当前的实现具有明显的限制，并且不支持对所有动作的强制访问控制。详见
     <xref linkend="sepgsql-limitations">。
   </para>
 </warning>

 <sect2 id="sepgsql-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>概述</title>

<!--==========================orignal english content==========================
  <para>
   This module integrates with <productname>SELinux</> to provide an
   additional layer of security checking above and beyond what is normally
   provided by <productname>PostgreSQL</productname>.  From the perspective of
   <productname>SELinux</>, this module allows
   <productname>PostgreSQL</productname> to function as a user-space object
   manager.  Each table or function access initiated by a DML query will be
   checked against the system security policy.  This check is in addition to
   the usual SQL permissions checking performed by
   <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   这个模块和<productname>SELinux</>集成在一起在
   <productname>PostgreSQL</productname>提供的安全检查之上提供了一个
   额外的安全检查层。从<productname>SELinux</>的角度来看，这个模块允许
   <productname>PostgreSQL</productname>作为一个用户空间对象管理器。
   对每一次由 DML 查询发起的表或者函数访问将根据系统安全策略进行检查。这种
   检查是在<productname>PostgreSQL</productname>执行的常规 SQL 权限
   检查之外进行的。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>SELinux</productname> access control decisions are made using
   security labels, which are represented by strings such as
   <literal>system_u:object_r:sepgsql_table_t:s0</>.  Each access control
   decision involves two labels: the label of the subject attempting to
   perform the action, and the label of the object on which the operation is
   to be performed.  Since these labels can be applied to any sort of object,
   access control decisions for objects stored within the database can be
   (and, with this module, are) subjected to the same general criteria used
   for objects of any other type, such as files.  This design is intended to
   allow a centralized security policy to protect information assets
   independent of the particulars of how those assets are stored.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>SELinux</productname>访问控制决定是通过使用安全标签
   来做出的，安全标签使用<literal>system_u:object_r:sepgsql_table_t:s0</>
   这样的字符串表示。每个访问控制决定涉及两个标签：尝试执行该动作的主体的
   标签以及要在其上执行该动作的客体的标签。由于这些标签可以被应用于任何种
   类的对象，对于存储在数据库中的对象的（用这个模块做出的）访问控制决定服
   从于用于任意其他类型对象（例如文件）的同一种一般准则。这种设计是为了允
   许一种中央安全策略来保护信息资产，而不依赖于这些资产是如何存储的。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <xref linkend="sql-security-label"> statement allows assignment of
   a security label to a database object.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="sql-security-label">语句允许为一个数据库对象分配安全标签。
  </para>

 </sect2>
 <sect2 id="sepgsql-installation">
<!--==========================orignal english content==========================
  <title>Installation</title>
____________________________________________________________________________-->
  <title>安装</title>

<!--==========================orignal english content==========================
  <para>
    <filename>sepgsql</> can only be used on <productname>Linux</productname>
    2.6.28 or higher with <productname>SELinux</productname> enabled.
    It is not available on any other platform.  You will also need
    <productname>libselinux</> 2.1.10 or higher and
    <productname>selinux-policy</> 3.9.13 or higher (although some
    distributions may backport the necessary rules into older policy
    versions).
  </para>
____________________________________________________________________________-->
  <para>
    <filename>sepgsql</>只能在启用了
    <productname>SELinux</productname>的
    <productname>Linux</productname> 2.6.28 或者更高版本上使用。在任何
    其他平台上都无法使用这个模块。你将还需要
    <productname>libselinux</> 2.1.10 或者更高版本以及
    <productname>selinux-policy</> 3.9.13 或者更高版本（尽管某些发行中可能
    把必要的规则逆向移植到较老的策略版本中）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <command>sestatus</> command allows you to check the status of
   <productname>SELinux</productname>.  A typical display is:
<screen>
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</screen>
   If <productname>SELinux</> is disabled or not installed, you must set
   that product up first before installing this module.
  </para>
____________________________________________________________________________-->
  <para>
   你可以使用<command>sestatus</>命令检查
   <productname>SELinux</productname>的状态。一种典型的显示是：
<screen>
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</screen>
   如果没有安装或者启用<productname>SELinux</>，你就必须在安装这个模块
   之前先安装或者启用它。
  </para>

<!--==========================orignal english content==========================
  <para>
   To build this module, include the option <literal>-&minus;with-selinux</> in
   your PostgreSQL <literal>configure</> command.  Be sure that the
   <filename>libselinux-devel</> RPM is installed at build time.
  </para>
____________________________________________________________________________-->
  <para>
   要编译这个模块，应该在你的 PostgreSQL <literal>configure</> 命令中包括
   选项<literal>--with-selinux</>。还要确定编译时安装了
   <filename>libselinux-devel</> RPM 包。
  </para>

<!--==========================orignal english content==========================
  <para>
   To use this module, you must include <literal>sepgsql</>
   in the <xref linkend="guc-shared-preload-libraries"> parameter in
   <filename>postgresql.conf</>.  The module will not function correctly
   if loaded in any other manner.  Once the module is loaded, you
   should execute <filename>sepgsql.sql</filename> in each database.
   This will install functions needed for security label management, and
   assign initial security labels.
  </para>
____________________________________________________________________________-->
  <para>
   要使用这个模块，你必须在<filename>postgresql.conf</>文件中的
   <xref linkend="guc-shared-preload-libraries">参数里包括
   <literal>sepgsql</>。如果以其他任何方式载入该模块，它将无法正确地工作。
   一旦该模块被载入，你应该在每一个数据库中执行
   <filename>sepgsql.sql</filename>。这将会安装安全标签管理所需的函数
   并且分配初始的安全标签。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example showing how to initialize a fresh database cluster
   with <filename>sepgsql</> functions and security labels installed.
   Adjust the paths shown as appropriate for your installation:
  </para>
____________________________________________________________________________-->
  <para>
   这里有一个展示如何用<filename>sepgsql</>函数和安全标签初始化一个新
   数据库集簇的例子（根据你的安装调整其中的路径）：
  </para>

<!--==========================orignal english content==========================
<screen>
$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
  change
    #shared_preload_libraries = ''                # (change requires restart)
  to
    shared_preload_libraries = 'sepgsql'          # (change requires restart)
$ for DBNAME in template0 template1 postgres; do
    postgres -&minus;single -F -c exit_on_error=true $DBNAME \
      &lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
  done
</screen>
____________________________________________________________________________-->
<screen>
$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
  change
    #shared_preload_libraries = ''                # (change requires restart)
  to
    shared_preload_libraries = 'sepgsql'          # (change requires restart)
$ for DBNAME in template0 template1 postgres; do
    postgres --single -F -c exit_on_error=true $DBNAME \
      &lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
  done
</screen>

<!--==========================orignal english content==========================
  <para>
   Please note that you may see some or all of the following notifications
   depending on the particular versions you have of
   <productname>libselinux</> and <productname>selinux-policy</>:
<screen>
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 36 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 37 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 38 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 39 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 40 has invalid object type db_language
</screen>
   These messages are harmless and should be ignored.
  </para>
____________________________________________________________________________-->
  <para>
   请注意，如果你具有特定版本的<productname>libselinux</>和
   <productname>selinux-policy</>，你可能会看到下列提示中的一些或者全部：
<screen>
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 36 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 37 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 38 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 39 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 40 has invalid object type db_language
</screen>
   这些消息是无害的并且应该被忽略。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the installation process completes without error, you can now start the
   server normally.
  </para>
____________________________________________________________________________-->
  <para>
   如果该安装过程完成时没有出现错误，就可以正常启动服务器了。
  </para>
 </sect2>

 <sect2 id="sepgsql-regression">
<!--==========================orignal english content==========================
  <title>Regression Tests</title>
____________________________________________________________________________-->
  <title>回归测试</title>

<!--==========================orignal english content==========================
  <para>
   Due to the nature of <productname>SELinux</productname>, running the
   regression tests for <filename>sepgsql</> requires several extra
   configuration steps, some of which must be done as root.
   The regression tests will not be run by an ordinary
   <literal>make check</> or <literal>make installcheck</> command; you must
   set up the configuration and then invoke the test script manually.
   The tests must be run in the <filename>contrib/sepgsql</> directory
   of a configured PostgreSQL build tree.  Although they require a build tree,
   the tests are designed to be executed against an installed server,
   that is they are comparable to <literal>make installcheck</> not
   <literal>make check</>.
  </para>
____________________________________________________________________________-->
  <para>
   由于<productname>SELinux</productname>的本质，为<filename>sepgsql</>
   运行回归测试要求一些额外的配置步骤，某些步骤还需要由 root 来完成。该回归测试
   无法通过普通的<literal>make check</>或者<literal>make installcheck</>命令运行，
   你必须建立配置并且接着手工调用测试脚本。这些测试必须在一个已配置 PostgreSQL 
   编译树的<filename>contrib/sepgsql</>目录中运行。尽管它们要求一个编译树，但是
   这些测试被设计成在一个已安装服务器上执行，也就是说它们可以比得上
   <literal>make installcheck</>（而不是<literal>make check</>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   First, set up <filename>sepgsql</filename> in a working database
   according to the instructions in <xref linkend="sepgsql-installation">.
   Note that the current operating system user must be able to connect to the
   database as superuser without password authentication.
  </para>
____________________________________________________________________________-->
  <para>
   首先，根据<xref linkend="sepgsql-installation">中的指导在一个工作数据库中设置
   <filename>sepgsql</filename>。注意当前操作系统用户必须能够不使用口令认证作
   为超级用户连接到该数据库。
  </para>

<!--==========================orignal english content==========================
  <para>
   Second, build and install the policy package for the regression test.
   The <filename>sepgsql-regtest</> policy is a special purpose policy package
   which provides a set of rules to be allowed during the regression tests.
   It should be built from the policy source file
   <filename>sepgsql-regtest.te</>, which is done using
   <command>make</command> with a Makefile supplied by SELinux.
   You will need to locate the appropriate
   Makefile on your system; the path shown below is only an example.
   Once built, install this policy package using the
   <command>semodule</> command, which loads supplied policy packages
   into the kernel.  If the package is correctly installed,
   <literal><command>semodule</> -l</> should list <literal>sepgsql-regtest</literal> as an
   available policy package:
  </para>
____________________________________________________________________________-->
  <para>
   第二，为该回归测试编译和安装策略包。<filename>sepgsql-regtest</>策略是一个
   特殊的策略包，它提供一组在回归测试浅见要被允许的规则。它应该从策略源文件
   <filename>sepgsql-regtest.te</>编译，这需要通过使用
   <command>make</command>和一个 SELinux 提供的 Makefile 完成。你将需要
   在你自己的系统上找到合适的 Makefile，下面展示的路径只是一个例子。一旦编译好，
   使用<command>semodule</>命令安装这个策略包，它会把所提供的策略包载入到
   内核中。如果该包被正确地安装，<literal><command>semodule</> -l</>应该把
   <literal>sepgsql-regtest</literal>列成一个可用的策略包：
  </para>

<!--==========================orignal english content==========================
<screen>
$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07
</screen>
____________________________________________________________________________-->
<screen>
$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07
</screen>

<!--==========================orignal english content==========================
  <para>
   Third, turn on <literal>sepgsql_regression_test_mode</>.
   For security reasons, the rules in <filename>sepgsql-regtest</>
   are not enabled by default;
   the <literal>sepgsql_regression_test_mode</literal> parameter enables
   the rules needed to launch the regression tests.
   It can be turned on using the <command>setsebool</> command:
  </para>
____________________________________________________________________________-->
  <para>
   第三，打开<literal>sepgsql_regression_test_mode</>。由于安全性的原因，
   <filename>sepgsql-regtest</>中的规则默认没有被启用。
   the <literal>sepgsql_regression_test_mode</literal>参数会启用启动该回归
   测试所需的规则。它可以使用<command>setsebool</>命令来启用：
  </para>

<!--==========================orignal english content==========================
<screen>
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode -&minus;> on
</screen>
____________________________________________________________________________-->
<screen>
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode --> on
</screen>

<!--==========================orignal english content==========================
  <para>
   Fourth, verify your shell is operating in the <literal>unconfined_t</>
   domain:
  </para>
____________________________________________________________________________-->
  <para>
   第四，验证你的 shell 在<literal>unconfined_t</>域中操作：
  </para>
<!--==========================orignal english content==========================
<screen>
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</screen>
____________________________________________________________________________-->
<screen>
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</screen>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="sepgsql-resources"> for details on adjusting your
   working domain, if necessary.
  </para>
____________________________________________________________________________-->
  <para>
   如果有必要，可以参考<xref linkend="sepgsql-resources">来调整你的工作域。
  </para>

<!--==========================orignal english content==========================
  <para>
   Finally, run the regression test script:
  </para>
____________________________________________________________________________-->
  <para>
   最后，运行该回归测试脚本：
  </para>
<!--==========================orignal english content==========================
<screen>
$ ./test_sepgsql
</screen>
____________________________________________________________________________-->
<screen>
$ ./test_sepgsql
</screen>

<!--==========================orignal english content==========================
  <para>
   This script will attempt to verify that you have done all the configuration
   steps correctly, and then it will run the regression tests for the
   <filename>sepgsql</> module.
  </para>
____________________________________________________________________________-->
  <para>
   这个脚本将尝试验证你已经正确地完成了所有的配置步骤，接下来它将运行
   <filename>sepgsql</>模块的回归测试。
  </para>

<!--==========================orignal english content==========================
  <para>
   After completing the tests, it's recommended you disable
   the <literal>sepgsql_regression_test_mode</literal> parameter:
  </para>
____________________________________________________________________________-->
  <para>
   完成测试后，推荐你禁用
   <literal>sepgsql_regression_test_mode</literal>参数：
  </para>

<!--==========================orignal english content==========================
<screen>
$ sudo setsebool sepgsql_regression_test_mode off
</screen>
____________________________________________________________________________-->
<screen>
$ sudo setsebool sepgsql_regression_test_mode off
</screen>

<!--==========================orignal english content==========================
  <para>
   You might prefer to remove the <filename>sepgsql-regtest</> policy
   entirely:
  </para>
____________________________________________________________________________-->
  <para>
   你可能想要完全移除<filename>sepgsql-regtest</>策略：
  </para>

<!--==========================orignal english content==========================
<screen>
$ sudo semodule -r sepgsql-regtest
</screen>
____________________________________________________________________________-->
<screen>
$ sudo semodule -r sepgsql-regtest
</screen>
 </sect2>

 <sect2 id="sepgsql-parameters">
<!--==========================orignal english content==========================
  <title>GUC Parameters</title>
____________________________________________________________________________-->
  <title>GUC 参数</title>

  <variablelist>
   <varlistentry id="guc-sepgsql-permissive" xreflabel="sepgsql.permissive">
<!--==========================orignal english content==========================
    <term>
     <varname>sepgsql.permissive</> (<type>boolean</type>)
     <indexterm>
      <primary><varname>sepgsql.permissive</> configuration parameter</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <varname>sepgsql.permissive</> (<type>boolean</type>)
     <indexterm>
      <primary><varname>sepgsql.permissive</> 配置参数</primary>
     </indexterm>
    </term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This parameter enables <filename>sepgsql</> to function
      in permissive mode, regardless of the system setting.
      The default is off.
      This parameter can only be set in the <filename>postgresql.conf</>
      file or on the server command line.
     </para>
____________________________________________________________________________-->
     <para>
      不管系统设置如何，这个参数让<filename>sepgsql</>在自由模式中运行。
      默认值为关闭。这个参数只能在<filename>postgresql.conf</>文件中或者
      服务器命令行上被设置。
     </para>

<!--==========================orignal english content==========================
     <para>
      When this parameter is on, <filename>sepgsql</> functions
      in permissive mode, even if SELinux in general is working in enforcing
      mode.  This parameter is primarily useful for testing purposes.
     </para>
____________________________________________________________________________-->
     <para>
      当这个参数为打开时，<filename>sepgsql</>在自由模式中运行，即便
      SELinux 运行在强制模式中也是如此。这个参数主要用于测试目的。
     </para>
    </listitem>

   </varlistentry>
   <varlistentry id="guc-sepgsql-debug-audit" xreflabel="sepgsql.debug_audit">
<!--==========================orignal english content==========================
    <term>
     <varname>sepgsql.debug_audit</> (<type>boolean</>)
     <indexterm>
      <primary><varname>sepgsql.debug_audit</> configuration parameter</>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <varname>sepgsql.debug_audit</> (<type>boolean</>)
     <indexterm>
      <primary><varname>sepgsql.debug_audit</> 配置参数</>
     </indexterm>
    </term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This parameter enables the printing of audit messages regardless of
      the system policy settings.
      The default is off, which means that messages will be printed according
      to the system settings.
     </para>
____________________________________________________________________________-->
     <para>
      不管系统策略设置如何，这个参数启用打印审计消息。默认值为关闭，表示将
      根据系统设置打印消息。
     </para>

<!--==========================orignal english content==========================
     <para>
      The security policy of <productname>SELinux</> also has rules to
      control whether or not particular accesses are logged.
      By default, access violations are logged, but allowed
      accesses are not.
     </para>
____________________________________________________________________________-->
     <para>
      <productname>SELinux</>的安全性策略也具有控制是否记录特定访问的
      规则。默认情况下，违法访问将会被记录，但是被允许的访问则不会被记录。
     </para>

<!--==========================orignal english content==========================
     <para>
      This parameter forces all possible logging to be turned on, regardless
      of the system policy.
     </para>
____________________________________________________________________________-->
     <para>
      这个参数强制打开所有可能的记录而不管该系统策略。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-features">
<!--==========================orignal english content==========================
  <title>Features</title>
____________________________________________________________________________-->
  <title>特性</title>
  <sect3>
<!--==========================orignal english content==========================
   <title>Controlled Object Classes</title>
____________________________________________________________________________-->
   <title>控制对象类</title>
<!--==========================orignal english content==========================
   <para>
    The security model of <productname>SELinux</> describes all the access
    control rules as relationships between a subject entity (typically,
    a client of the database) and an object entity (such as a database
    object), each of which is
    identified by a security label.  If access to an unlabeled object is
    attempted, the object is treated as if it were assigned the label
    <literal>unlabeled_t</>.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>SELinux</>的安全模型把所有访问控制规则描述为一个
    主体（典型的是一个数据库客户端）和一个客体（例如一个数据库对象）之
    间的关系， 每一个这样的关系被一个安全标签标识。如果尝试访问一个未加
    标签的客体，会认为该客体被分配了标签<literal>unlabeled_t</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Currently, <filename>sepgsql</filename> allows security labels to be
    assigned to schemas, tables, columns, sequences, views, and functions.
    When <filename>sepgsql</filename> is in use, security labels are
    automatically assigned to supported database objects at creation time.
    This label is called a default security label, and is decided according
    to the system security policy, which takes as input the creator's label,
    the label assigned to the new object's parent object and optionally name
    of the constructed object.
   </para>
____________________________________________________________________________-->
   <para>
    当前，<filename>sepgsql</filename>允许把安全标签分配给模式、表、列、
    序列、视图和函数。在使用<filename>sepgsql</filename>时，安全标签会
    在所支持的数据库对象创建时自动分配给它们。这种标签被称为默认安全标签
    并且根据系统安全性策略决定，默认安全标签被用来输入创建者标签、分配给
    新对象父对象的标签以及所构造对象的可选名称。
   </para>

<!--==========================orignal english content==========================
   <para>
    A new database object basically inherits the security label of the parent
    object, except when the security policy has special rules known as
    type-transition rules, in which case a different label may be applied.
    For schemas, the parent object is the current database; for tables,
    sequences, views, and functions, it is the containing schema; for columns,
    it is the containing table.
   </para>
____________________________________________________________________________-->
   <para>
    一个新数据库对象基本上会继承父对象的安全标签，不过当安全策略具有特殊的
    类型转换规则时，将会应用一个不同的标签。对于模式，其父对象是当前数据库。
    对于表、序列、视图和函数，父对象是包含它的模式。对于列，其父对象是包含
    它的表。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>DML Permissions</title>
____________________________________________________________________________-->
   <title>DML 权限</title>

<!--==========================orignal english content==========================
   <para>
    For tables, <literal>db_table:select</>, <literal>db_table:insert</>,
    <literal>db_table:update</> or <literal>db_table:delete</> are
    checked for all the referenced target tables depending on the kind of
    statement; in addition, <literal>db_table:select</> is also checked for
    all the tables that contain columns referenced in the
    <literal>WHERE</> or <literal>RETURNING</> clause, as a data source
    for <literal>UPDATE</>, and so on.
   </para>
____________________________________________________________________________-->
   <para>
    对于表，根据语句的种类会对所有被引用的目标表检查
    <literal>db_table:select</>、<literal>db_table:insert</>、
    <literal>db_table:update</>或者<literal>db_table:delete</>。此外，对于
    所有其列被<literal>WHERE</>或<literal>RETURNING</>子句引用、作为
    <literal>UPDATE</>的数据源（以及其他情况）的表，
    都要检查<literal>db_table:select</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Column-level permissions will also be checked for each referenced column.
    <literal>db_column:select</> is checked on not only the columns being
    read using <literal>SELECT</>, but those being referenced in other DML
    statements; <literal>db_column:update</> or <literal>db_column:insert</>
    will also be checked for columns being modified by <literal>UPDATE</> or
    <literal>INSERT</>.
   </para>
____________________________________________________________________________-->
   <para>
    对每一个被引用的列也将检查列级权限。不仅在使用<literal>SELECT</>读取列
    时会检查<literal>db_column:select</>，在其他 DML 语句中引用列时也要检查。
    对于被<literal>UPDATE</>或者<literal>INSERT</>修改的列也将检查
    <literal>db_column:update</>或者<literal>db_column:insert</>。
   </para>

<!--==========================orignal english content==========================
   <para>
   For example, consider:
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>

    Here, <literal>db_column:update</> will be checked for
    <literal>t1.x</>, since it is being updated,
    <literal>db_column:{select update}</> will be checked for
    <literal>t1.y</>, since it is both updated and referenced, and
    <literal>db_column:select</> will be checked for <literal>t1.z</>, since
    it is only referenced.
    <literal>db_table:{select update}</> will also be checked
    at the table level.
   </para>
____________________________________________________________________________-->
   <para>
   例如，考虑：
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>

    这里，将对<literal>t1.x</>检查<literal>db_column:update</>，因为它
    被更新。对<literal>t1.y</>将检查<literal>db_column:{select update}</>，
    因为它既被更新也被引用。并且会对<literal>t1.z</>检查
    <literal>db_column:select</>，因为它只被更新。还将在表层面上检查
    <literal>db_table:{select update}</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    For sequences, <literal>db_sequence:get_value</> is checked when we
    reference a sequence object using <literal>SELECT</>; however, note that we
    do not currently check permissions on execution of corresponding functions
    such as <literal>lastval()</>.
   </para>
____________________________________________________________________________-->
   <para>
    对于序列，当我们使用<literal>SELECT</>引用一个序列对象时会检查
    <literal>db_sequence:get_value</>。不过，我们当前不会检查执行相应
    函数（例如<literal>lastval()</>）的权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    For views, <literal>db_view:expand</> will be checked, then any other
    required permissions will be checked on the objects being
    expanded from the view, individually.
   </para>
____________________________________________________________________________-->
   <para>
    对于视图，将检查<literal>db_view:expand</>，然后对从视图展开来的任何
    对象都会分别检查所需的权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    For functions, <literal>db_procedure:{execute}</> will be checked when
    user tries to execute a function as a part of query, or using fast-path
    invocation. If this function is a trusted procedure, it also checks
    <literal>db_procedure:{entrypoint}</> permission to check whether it
    can perform as entry point of trusted procedure.
   </para>
____________________________________________________________________________-->
   <para>
    对于函数，当用户尝试在一个查询中或者使用快路径调用执行一个函数时会检查
    <literal>db_procedure:{execute}</>。如果该函数是一个可信过程，也会检查
    <literal>db_procedure:{entrypoint}</>权限来看看它能否作为一个可信程序
    的入口点来执行。
   </para>

<!--==========================orignal english content==========================
   <para>
    In order to access any schema object, <literal>db_schema:search</>
    permission is required on the containing schema.  When an object is
    referenced without schema qualification, schemas on which this
    permission is not present will not be searched (just as if the user did
    not have <literal>USAGE</> privilege on the schema).  If an explicit schema
    qualification is present, an error will occur if the user does not have
    the requisite permission on the named schema.
   </para>
____________________________________________________________________________-->
   <para>
    为了访问任何模式对象，在其所在的模式上需要<literal>db_schema:search</>
    权限。当不用模式限定引用一个对象时，其上没有该权限的模式不会被搜索（就好
    像该用户在该模式上没有<literal>USAGE</>特权）。如果出现一个显式的模式
    限定，当该用户在提及的模式上没有要求的权限时将会发生一个错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    The client must be allowed to access all referenced tables and
    columns, even if they originated from views which were then expanded,
    so that we apply consistent access control rules independent of the manner
    in which the table contents are referenced.
   </para>
____________________________________________________________________________-->
   <para>
    客户端必须被允许访问所有引用到的表和列，即便它们是由视图扩展得来的。这样
    我们可以应用一致的访问控制规则而不管表内容被引用的方式。
   </para>

<!--==========================orignal english content==========================
   <para>
    The default database privilege system allows database superusers to
    modify system catalogs using DML commands, and reference or modify
    toast tables.  These operations are prohibited when
    <filename>sepgsql</> is enabled.
   </para>
____________________________________________________________________________-->
   <para>
    默认的数据库特权系统允许数据库超级用户使用 DML 命令修改系统目录并且引用
    或者修改 TOAST 表。当<filename>sepgsql</>被启用时，这些操作会被禁止。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>DDL Permissions</title>
____________________________________________________________________________-->
   <title>DDL 权限</title>
<!--==========================orignal english content==========================
   <para>
    <productname>SELinux</> defines several permissions to control common
    operations for each object type; such as creation, alter, drop and
    relabel of security label. In addition, several object types have
    special permissions to control their characteristic operations; such as
    addition or deletion of name entries within a particular schema.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>SELinux</>为每一种对象类型定义了数个权限来控制
    常用操作，例如创建、修改、删除以及重新标记安全标签。此外，数种
    对象类型具有特殊的权限来控制它们的特性化操作，例如在一个特定模式
    中增加或者删除名字项。
   </para>
<!--==========================orignal english content==========================
   <para>
    Creating a new database object requires <literal>create</> permission.
    <productname>SELinux</> will grant or deny this permission based on the
    client's security label and the proposed security label for the new
    object.  In some cases, additional privileges are required:
   </para>
____________________________________________________________________________-->
   <para>
    创建一个新的数据库对象要求<literal>create</>权限。
    <productname>SELinux</>将基于客户端的安全标签来授予或者否决
    这个权限并且为新对象提出安全标签。在某些情况下，还需要额外的特权：
   </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <xref linkend="sql-createdatabase"> additionally requires
      <literal>getattr</> permission for the source or template database.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="sql-createdatabase">额外要求源数据库或者模板数
      据库的<literal>getattr</>权限。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creating a schema object additionally requires <literal>add_name</>
      permission on the parent schema.
     </para>
____________________________________________________________________________-->
     <para>
      创建一个模式对象额外地要求父模式上的<literal>add_name</>权限。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creating a table additionally requires permission to create each
      individual table column, just as if each table column were a
      separate top-level object.
     </para>
____________________________________________________________________________-->
     <para>
      创建一个表额外要求创建单个表列的权限，就好像每一个表列都是一个
      单独的顶层对象。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creating a function marked as <literal>LEAKPROOF</> additionally
      requires <literal>install</> permission.  (This permission is also
      checked when <literal>LEAKPROOF</> is set for an existing function.)
     </para>
____________________________________________________________________________-->
     <para>
      创建一个被标记为<literal>LEAKPROOF</>的函数额外要求
      <literal>install</>权限（当为一个现有函数设置
      <literal>LEAKPROOF</>时也要检查这个权限）。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
   <para>
    When <literal>DROP</> command is executed, <literal>drop</> will be
    checked on the object being removed.  Permissions will be also checked for
    objects dropped indirectly via <literal>CASCADE</>.  Deletion of objects
    contained within a particular schema (tables, views, sequences and
    procedures) additionally requires <literal>remove_name</> on the schema.
   </para>
____________________________________________________________________________-->
   <para>
    当执行<literal>DROP</>命令时，在要移除的对象上会检查<literal>drop</>。
    对于通过<literal>CASCADE</>间接被删除的对象也会检查权限。删除包含在
    一个特定模式内的对象（表、视图、序列以及过程）额外地要求该模式上的
    <literal>remove_name</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    When <literal>ALTER</> command is executed, <literal>setattr</> will be
    checked on the object being modified for each object types, except for
    subsidiary objects such as the indexes or triggers of a table, where
    permissions are instead checked on the parent object.  In some cases,
    additional permissions are required:
   </para>
____________________________________________________________________________-->
   <para>
    在执行<literal>ALTER</>命令时，会在被修改的对象上为每一种对象类型检查
    <literal>setattr</>。附属对象（例如一个表的索引或者触发器）除外， 这种
    情况下权限是在父对象上检查的。在某些情况下，还需要额外的权限：
   </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Moving an object to a new schema additionally requires
      <literal>remove_name</> permission on the old schema and
      <literal>add_name</> permission on the new one.
     </para>
____________________________________________________________________________-->
     <para>
      将一个对象移动到一个新的模式要求旧模式上的<literal>remove_name</>
      权限以及新模式上的<literal>add_name</>权限。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Setting the <literal>LEAKPROOF</> attribute on a function requires
      <literal>install</> permission.
     </para>
____________________________________________________________________________-->
     <para>
      设置一个函数上的<literal>LEAKPROOF</>属性要求<literal>install</>权限。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Using <xref linkend="sql-security-label"> on an object additionally
      requires <literal>relabelfrom</> permission for the object in
      conjunction with its old security label and <literal>relabelto</>
      permission for the object in conjunction with its new security label.
      (In cases where multiple label providers are installed and the user
      tries to set a security label, but it is not managed by
      <productname>SELinux</>, only <literal>setattr</> should be checked here.
      This is currently not done due to implementation restrictions.)
     </para>
____________________________________________________________________________-->
     <para>
      在一个对象上使用<xref linkend="sql-security-label">会额外对该对象要求
      <literal>relabelfrom</>权限连同它的旧安全标签以及<literal>relabelto</>
      权限连同它的新安全标签（在安装了多个标签提供者并且用户尝试设置一个不由
      <productname>SELinux</>管理的安全标签的情况中，这里只应该检查
      <literal>setattr</>。当前由于实现限制没有这样做。）。
     </para>
    </listitem>
   </itemizedlist>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Trusted Procedures</title>
____________________________________________________________________________-->
   <title>可信过程</title>
<!--==========================orignal english content==========================
   <para>
    Trusted procedures are similar to security definer functions or setuid
    commands. <productname>SELinux</> provides a feature to allow trusted
    code to run using a security label different from that of the client,
    generally for the purpose of providing highly controlled access to
    sensitive data (e.g. rows might be omitted, or the precision of stored
    values might be reduced).  Whether or not a function acts as a trusted
    procedure is controlled by its security label and the operating system
    security policy.  For example:
   </para>
____________________________________________________________________________-->
   <para>
    可信过程类似于 SECURITY DEFINER 函数或者 setuid 命令。
    <productname>SELinux</>提供了一个特性来允许可信代码使用一个不同
    于客户端的安全标签运行，通常这是为了提供对敏感数据的高度控制的访问（
    例如行可能会被忽略或者存储值的精度可能会被降低）。一个函数是否可以
    作为可信过程受到其安全标签和操作系统安全性策略的控制。例如：
   </para>

<!--==========================orignal english content==========================
<screen>
postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
</screen>
____________________________________________________________________________-->
<screen>
postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
</screen>

<!--==========================orignal english content==========================
   <para>
    The above operations should be performed by an administrative user.
   </para>
____________________________________________________________________________-->
   <para>
    上述的操作应该由一个管理员用户执行。
   </para>

<!--==========================orignal english content==========================
<screen>
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)
</screen>
____________________________________________________________________________-->
<screen>
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-----+--------+---------------------
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)
</screen>

<!--==========================orignal english content==========================
   <para>
    In this case, a regular user cannot reference <literal>customer.credit</>
    directly, but a trusted procedure <literal>show_credit</> allows the user
    to print the credit card numbers of customers with some of the digits
    masked out.
   </para>
____________________________________________________________________________-->
   <para>
    在这种情况下，一个常规用户无法直接引用<literal>customer.credit</>，
    但是一个可信过程<literal>show_credit</>允许用户在打印客户的信用卡号时
    把一些数字掩盖掉。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Dynamic Domain Transitions</title>
____________________________________________________________________________-->
   <title>动态域转换</title>
<!--==========================orignal english content==========================
   <para>
    It is possible to use SELinux's dynamic domain transition feature
    to switch the security label of the client process, the client domain,
    to a new context, if that is allowed by the security policy.
    The client domain needs the <literal>setcurrent</> permission and also
    <literal>dyntransition</> from the old to the new domain.
   </para>
____________________________________________________________________________-->
   <para>
    如果安全性策略允许，可以使用 SELinux 的动态域转换特性来切换客户端
    进程（客户端域）的安全性标签到一个新的上下文。该客户端域需要
    <literal>setcurrent</>权限还有从旧的域到新的域的
    <literal>dyntransition</>权限。
   </para>
<!--==========================orignal english content==========================
   <para>
    Dynamic domain transitions should be considered carefully, because they
    allow users to switch their label, and therefore their privileges,
    at their option, rather than (as in the case of a trusted procedure)
    as mandated by the system.
    Thus, the <literal>dyntransition</literal> permission is only considered
    safe when used to switch to a domain with a smaller set of privileges than
    the original one. For example:
   </para>
____________________________________________________________________________-->
   <para>
    动态域转换需要被仔细考虑，因为在用户看来，它们允许用户切换其标签，
    并且因而切换特权，而不是（像可信过程的情况那样）受系统的强制性管理。
    因此，只有当被用来切换到一个比原来的域具有更少特权的域时，
    <literal>dyntransition</literal>才被认为是安全的。例如：
   </para>
<!--==========================orignal english content==========================
<screen>
regression=# select sepgsql_getcon();
                    sepgsql_getcon
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c4');
 sepgsql_setcon 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c1023');
ERROR:  SELinux: security policy violation
</screen>
____________________________________________________________________________-->
<screen>
regression=# select sepgsql_getcon();
                    sepgsql_getcon
-------------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c4');
 sepgsql_setcon 
----------------
 t
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c1023');
ERROR:  SELinux: security policy violation
</screen>
<!--==========================orignal english content==========================
   <para>
    In this example above we were allowed to switch from the larger MCS
    range <literal>c1.c1023</> to the smaller range <literal>c1.c4</>, but
    switching back was denied.
   </para>
____________________________________________________________________________-->
   <para>
    在上面的这个例子中，我们被允许从较大范围的<literal>c1.c1023</>切换到
    较小范围的<literal>c1.c4</>，但却禁止切换回去。
   </para>
<!--==========================orignal english content==========================
   <para>
    A combination of dynamic domain transition and trusted procedure
    enables an interesting use case that fits the typical process life-cycle
    of connection pooling software.
    Even if your connection pooling software is not allowed to run most
    of SQL commands, you can allow it to switch the security label
    of the client using the <literal>sepgsql_setcon()</literal> function
    from within a trusted procedure; that should take some
    credential to authorize the request to switch the client label.
    After that, this session will have the privileges of the target user,
    rather than the connection pooler.
    The connection pooler can later revert the security label change by
    again using <literal>sepgsql_setcon()</literal> with
    <literal>NULL</literal> argument, again invoked from within a trusted
    procedure with appropriate permissions checks.
    The point here is that only the trusted procedure actually has permission
    to change the effective security label, and only does so when given proper
    credentials.  Of course, for secure operation, the credential store
    (table, procedure definition, or whatever) must be protected from
    unauthorized access.
   </para>
____________________________________________________________________________-->
   <para>
    动态域转换和可信过程的组合开启了一种有趣的使用案例，它适合典型的
    连接池软件的处理生命周期。即便你的连接池软件不被允许运行大部分的
    SQL 命令，你可以从一个可信过程中使用
    <literal>sepgsql_setcon()</literal>函数允许它切换该客户端的安全标签，
    这个过程应该采用一些证据来授权该请求切换该客户端标签。之后，这个
    会话将会具有目标用户而不是连接池的特权。该连接池之后可以用
    <literal>NULL</literal>参数再次调用<literal>sepgsql_setcon()</literal>
    逆转这次安全标签改变，当然再次的调用也要在一个可信过程中配合适当
    的权限检查进行。这里的要点是只有可信过程实际具有权限来更改有效的安全
    标签，并且只有在得到适当的证据后才这样做。当然，对于安全操作，必须
    保护证据存储（表、过程定义或者其他什么）不会受到未经授权的访问。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Miscellaneous</title>
____________________________________________________________________________-->
   <title>杂项</title>
<!--==========================orignal english content==========================
   <para>
    We reject the <xref linkend="sql-load"> command across the board, because
    any module loaded could easily circumvent security policy enforcement.
   </para>
____________________________________________________________________________-->
   <para>
    我们全面拒绝<xref linkend="sql-load">命令，因为任何模块的装载都
    可能很轻易地绕过安全策略的强制保护。
   </para>

  </sect3>
</sect2>

 <sect2 id="sepgsql-functions">
<!--==========================orignal english content==========================
  <title>Sepgsql Functions</title>
____________________________________________________________________________-->
  <title>Sepgsql 函数</title>
<!--==========================orignal english content==========================
  <para>
   <xref linkend="sepgsql-functions-table"> shows the available functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="sepgsql-functions-table">展示了可用的函数。
  </para>

  <table id="sepgsql-functions-table">
<!--==========================orignal english content==========================
   <title>Sepgsql Functions</title>
____________________________________________________________________________-->
   <title>Sepgsql 函数</title>
   <tgroup cols="2">
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sepgsql_getcon() returns text</literal></entry>
      <entry>
       Returns the client domain, the current security label of the client.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sepgsql_getcon() returns text</literal></entry>
      <entry>
       返回该客户端域，也就是该客户端当前的安全标签。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sepgsql_setcon(text) returns bool</literal></entry>
      <entry>
       Switches the client domain of the current session to the new domain,
       if allowed by the security policy.
       It also accepts <literal>NULL</literal> input as a request to transition
       to the client's original domain.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sepgsql_setcon(text) returns bool</literal></entry>
      <entry>
       如果安全性策略允许，把当前会话的客户端域切换到一个新的域。它也接受
       <literal>NULL</literal>输入，并且把它当做是切换到该客户端原始域的请求。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sepgsql_mcstrans_in(text) returns text</literal></entry>
      <entry>Translates the given qualified MLS/MCS range into raw format if
      the mcstrans daemon is running.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sepgsql_mcstrans_in(text) returns text</literal></entry>
      <entry>如果 mcstrans 守护进程在运行中，把给定的限定 MLS/MCS 范围
      翻译成原始格式。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sepgsql_mcstrans_out(text) returns text</literal></entry>
      <entry>Translates the given raw MLS/MCS range into qualified format if
      the mcstrans daemon is running.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sepgsql_mcstrans_out(text) returns text</literal></entry>
      <entry>如果 mcstrans 守护进程在运行中，把给定的原始 MLS/MCS 范围
      翻译成限定格式。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sepgsql_restorecon(text) returns bool</literal></entry>
      <entry>
       Sets up initial security labels for all objects within the
       current database. The argument may be NULL, or the name of a specfile
       to be used as alternative of the system default.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sepgsql_restorecon(text) returns bool</literal></entry>
      <entry>
       在当前数据库中为所有对象设置初始安全标签。参数可能是 NULL，或者是
       一个被用作系统默认 specfile 替代品的 specfile 名称。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="sepgsql-limitations">
<!--==========================orignal english content==========================
  <title>Limitations</title>
____________________________________________________________________________-->
  <title>限制</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term>Data Definition Language (DDL) Permissions</term>
____________________________________________________________________________-->
    <term>数据定义语言（DDL）权限</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Due to implementation restrictions, some DDL operations do not
      check permissions.
     </para>
____________________________________________________________________________-->
     <para>
      收到实现的限制，一些 DDL 操作无法检查权限。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>Data Control Language (DCL) Permissions</term>
____________________________________________________________________________-->
    <term>数据控制语言（DCL）权限</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Due to implementation restrictions, DCL operations do not check
      permissions.
     </para>
____________________________________________________________________________-->
     <para>
      由于实现限制，DCL 操作不检查权限。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>Row-level access control</term>
____________________________________________________________________________-->
    <term>行级访问控制</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <productname>PostgreSQL</> supports row-level access, but
      <filename>sepgsql</filename> does not.
     </para>
____________________________________________________________________________-->
     <para>
      <productname>PostgreSQL</>支持行级访问，但是
      <filename>sepgsql</filename>不支持行级访问。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>Covert channels</term>
____________________________________________________________________________-->
    <term>隐蔽通道</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <filename>sepgsql</> does not try to hide the existence of
      a certain object, even if the user is not allowed to reference it.
      For example, we can infer the existence of an invisible object as
      a result of primary key conflicts, foreign key violations, and so on,
      even if we cannot obtain the contents of the object.  The existence
      of a top secret table cannot be hidden; we only hope to conceal its
      contents.
     </para>
____________________________________________________________________________-->
     <para>
      <filename>sepgsql</>不会尝试隐藏一个特定对象的存在，即便是
      用户不被允许引用该对象。例如，即便我们无法得到一个不可见对象
      的内容，我们也可以通过主键冲突、外键违背等等结果来推知该对象
      的存在。一个绝密表的存在无法被隐藏，我们只希望能够隐藏其内容。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-resources">
<!--==========================orignal english content==========================
  <title>External Resources</title>
____________________________________________________________________________-->
  <title>外部资源</title>
  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><ulink url="https://wiki.postgresql.org/wiki/SEPostgreSQL">SE-PostgreSQL Introduction</ulink></term>
____________________________________________________________________________-->
    <term><ulink url="https://wiki.postgresql.org/wiki/SEPostgreSQL">SE-PostgreSQL 介绍</ulink></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This wiki page provides a brief overview, security design, architecture,
      administration and upcoming features.
     </para>
____________________________________________________________________________-->
     <para>
      这个 wiki 页面提供了一个简单的综述、安全性设计、架构、
      管理和即将到来的特性。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><ulink url="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SELinux_Users_and_Administrators_Guide/">SELinux User's and Administrator's Guide</ulink></term>
____________________________________________________________________________-->
    <term><ulink url="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SELinux_Users_and_Administrators_Guide/">SELinux用户和管理员指南</ulink></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This document provides a wide spectrum of knowledge to administer
      <productname>SELinux</> on your systems.
      It focuses primarily on Red Hat operating systems, but is not limited to them.
     </para>
____________________________________________________________________________-->
     <para>
      这个文档提供了广泛的知识来管理系统上的
      <productname>SELinux</>。它主要关注 Red Hat 操作系统，但是并不仅限于此。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><ulink url="https://fedoraproject.org/wiki/SELinux_FAQ">Fedora SELinux FAQ</ulink></term>
____________________________________________________________________________-->
    <term><ulink url="https://fedoraproject.org/wiki/SELinux_FAQ">Fedora SELinux FAQ</ulink></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This document answers frequently asked questions about
      <productname>SELinux</productname>.
      It focuses primarily on Fedora, but is not limited to Fedora.
     </para>
____________________________________________________________________________-->
     <para>
      这个文档回答了很多<productname>SELinux</productname>
      的常见问题。它主要关注 Fedora，但是并不仅限于此。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-author">
<!--==========================orignal english content==========================
  <title>Author</title>
____________________________________________________________________________-->
  <title>作者</title>
<!--==========================orignal english content==========================
  <para>
   KaiGai Kohei <email>kaigai@ak.jp.nec.com</email>
  </para>
____________________________________________________________________________-->
  <para>
   KaiGai Kohei <email>kaigai@ak.jp.nec.com</email>
  </para>
 </sect2>
</sect1>
