<!-- doc/src/sgml/xfunc.sgml -->

 <sect1 id="xfunc">
<!--==========================orignal english content==========================
  <title>User-Defined Functions</title>
____________________________________________________________________________-->
  <title>用户定义的函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="xfunc">
   <primary>function</primary>
   <secondary>user-defined</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="xfunc">
   <primary>function</primary>
   <secondary>user-defined</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides four kinds of
   functions:

   <itemizedlist>
    <listitem>
     <para>
      query language functions (functions written in
      <acronym>SQL</acronym>) (<xref linkend="xfunc-sql"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      procedural language functions (functions written in, for
      example, <application>PL/pgSQL</application> or <application>PL/Tcl</application>)
      (<xref linkend="xfunc-pl"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      internal functions (<xref linkend="xfunc-internal"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      C-language functions (<xref linkend="xfunc-c"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供四种函数：

   <itemizedlist>
    <listitem>
     <para>
      查询语言函数（用<acronym>SQL</acronym>编写的函数）（<xref linkend="xfunc-sql"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      过程语言函数（例如，用<application>PL/pgSQL</application>或<application>PL/Tcl</application>编写的函数）（<xref linkend="xfunc-pl"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      内部函数（<xref linkend="xfunc-internal"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      C 语言函数（<xref linkend="xfunc-c"/>）
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Every kind
   of  function  can take base types, composite types, or
   combinations of these as arguments (parameters). In addition,
   every kind of function can return a base type or
   a composite type.  Functions can also be defined to return
   sets of base or composite values.
  </para>
____________________________________________________________________________-->
  <para>
   每一类函数可以采用基本类型、组合类型或者它们的组合作为参数。此外，每一类函数可以返回一个基本类型或一个组合类型。函数也能被定义成返回基本类型或组合类型值的集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   Many kinds of functions can take or return certain pseudo-types
   (such as polymorphic types), but the available facilities vary.
   Consult the description of each kind of function for more details.
  </para>
____________________________________________________________________________-->
  <para>
   很多类函数可以接受或者返回特定的伪类型（例如，多态类型），但是可用的功能会变化。详情可以参考每一种函数的描述。
  </para>

<!--==========================orignal english content==========================
  <para>
   It's easiest to define <acronym>SQL</acronym>
   functions, so we'll start by discussing those.
   Most of the concepts presented for <acronym>SQL</acronym> functions
   will carry over to the other types of functions.
  </para>
____________________________________________________________________________-->
  <para>
   定义<acronym>SQL</acronym>函数最容易，因此我们将从讨论<acronym>SQL</acronym>函数开始。大部分<acronym>SQL</acronym>函数的概念也能用到其他类型的函数上。
  </para>

<!--==========================orignal english content==========================
  <para>
   Throughout this chapter, it can be useful to look at the reference
   page of the <xref linkend="sql-createfunction"/> command to
   understand the examples better.  Some examples from this chapter
   can be found in <filename>funcs.sql</filename> and
   <filename>funcs.c</filename> in the <filename>src/tutorial</filename>
   directory in the <productname>PostgreSQL</productname> source
   distribution.
  </para>
____________________________________________________________________________-->
  <para>
   在这一章中，查看<xref linkend="sql-createfunction"/>命令的参考页有助于更好地理解例子。这章中的一些例子可以在<productname>PostgreSQL</productname>源代码发布的<filename>src/tutorial</filename>目录中的<filename>funcs.sql</filename>和<filename>funcs.c</filename>中找到。
  </para>
  </sect1>

  <sect1 id="xproc">
<!--==========================orignal english content==========================
   <title>User-Defined Procedures</title>
____________________________________________________________________________-->
   <title>用户定义的过程</title>

<!--==========================orignal english content==========================
  <indexterm zone="xproc">
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="xproc">
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    A procedure is a database object similar to a function.  The difference is
    that a procedure does not return a value, so there is no return type
    declaration.  While a function is called as part of a query or DML
    command, a procedure is called in isolation using
    the <xref linkend="sql-call"/> command.  If the CALL command is not
    part of an explicit transaction, a procedure in many server-side
    languages can commit, rollback, and begin new transactions during
    its execution, which is not possible in functions.
   </para>
____________________________________________________________________________-->
   <para>
    过程是一种类似于函数的数据库对象。两者的区别在于过程不返回值，因此没有返回类型声明。
    虽然函数作为查询或 DML 命令的一部分被调用，但过程是使用<xref linkend="sql-call"/>命令单独调用的。
    如果 CALL 命令不是显式事务的一部分，则许多服务器端语言中的过程可以在其执行期间提交、回滚和开始新事务，这在函数中是不可能的。
   </para>

<!--==========================orignal english content==========================
   <para>
    The explanations on how to define user-defined functions in the rest of
    this chapter apply to procedures as well, except that
    the <xref linkend="sql-createprocedure"/> command is used instead, there is
    no return type, and some other features such as strictness don't apply.
   </para>
____________________________________________________________________________-->
   <para>
    本章剩余部分中对如何定义用户定义的函数的解释同样适用于过程，不同的地方有：需要使用<xref linkend="sql-createprocedure"/>命令定义、没有返回类型、一些如严格性这样的其他特性不适用。
   </para>

<!--==========================orignal english content==========================
   <para>
    Collectively, functions and procedures are also known
    as <firstterm>routines</firstterm><indexterm><primary>routine</primary></indexterm>.
    There are commands such as <xref linkend="sql-alterroutine"/>
    and <xref linkend="sql-droproutine"/> that can operate on functions and
    procedures without having to know which kind it is.  Note, however, that
    there is no <literal>CREATE ROUTINE</literal> command.
   </para>
____________________________________________________________________________-->
   <para>
    函数和过程一起构成了<firstterm>例程</firstterm><indexterm><primary>routine</primary></indexterm>。有<xref linkend="sql-alterroutine"/>以及<xref linkend="sql-droproutine"/>这样的命令可以操作函数和过程而不需要知道它们是哪一种。不过，要注意没有<literal>CREATE ROUTINE</literal>命令。
   </para>
  </sect1>

  <sect1 id="xfunc-sql">
<!--==========================orignal english content==========================
   <title>Query Language (<acronym>SQL</acronym>) Functions</title>
____________________________________________________________________________-->
   <title>查询语言（<acronym>SQL</acronym>）函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-sql">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in SQL</tertiary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-sql">
    <primary>函数</primary>
    <secondary>用户定义的</secondary>
    <tertiary>in SQL</tertiary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    SQL functions execute an arbitrary list of SQL statements, returning
    the result of the last query in the list.
    In the simple (non-set)
    case, the first row of the last query's result will be returned.
    (Bear in mind that <quote>the first row</quote> of a multirow
    result is not well-defined unless you use <literal>ORDER BY</literal>.)
    If the last query happens
    to return no rows at all, the null value will be returned.
   </para>
____________________________________________________________________________-->
   <para>
    SQL 函数执行一个由任意 SQL 语句构成的列表，返回列表中最后一个查询的结果。在简单（非集合）的情况中，最后一个查询的结果的第一行将被返回（记住一个多行结果的<quote>第一行</quote>不是良定义的，除非你使用<literal>ORDER BY</literal>）。如果最后一个查询正好根本不返回行，将会返回空值。
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively, an SQL function can be declared to return a set (that is,
    multiple rows) by specifying the function's return type as <literal>SETOF
    <replaceable>sometype</replaceable></literal>, or equivalently by declaring it as
    <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.  In this case
    all rows of the last query's result are returned.  Further details appear
    below.
   </para>
____________________________________________________________________________-->
   <para>
    或者，一个 SQL 函数可以通过指定函数的返回类型为<literal>SETOF <replaceable>sometype</replaceable></literal>被声明为返回一个集合（也就是多个行），或者等效地声明它为<literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>。在这种情况下，最后一个查询的结果的所有行会被返回。下文将给出进一步的细节。
   </para>

<!--==========================orignal english content==========================
   <para>
    The body of an SQL function must be a list of SQL
    statements separated by semicolons.  A semicolon after the last
    statement is optional.  Unless the function is declared to return
    <type>void</type>, the last statement must be a <command>SELECT</command>,
    or an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>
    that has a <literal>RETURNING</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    一个 SQL 函数的主体必须是一个由分号分隔的 SQL 语句的列表。最后一个语句之后的分号是可选的。除非函数被声明为返回<type>void</type>，最后一个语句必须是一个<command>SELECT</command>或者一个带有<literal>RETURNING</literal>子句的<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>。
   </para>

<!--==========================orignal english content==========================
    <para>
     Any collection of commands in the  <acronym>SQL</acronym>
     language can be packaged together and defined as a function.
     Besides <command>SELECT</command> queries, the commands can include data
     modification queries (<command>INSERT</command>,
     <command>UPDATE</command>, and <command>DELETE</command>), as well as
     other SQL commands. (You cannot use transaction control commands, e.g.,
     <command>COMMIT</command>, <command>SAVEPOINT</command>, and some utility
     commands, e.g.,  <literal>VACUUM</literal>, in <acronym>SQL</acronym> functions.)
     However, the final command
     must be a <command>SELECT</command> or have a <literal>RETURNING</literal>
     clause that returns whatever is
     specified as the function's return type.  Alternatively, if you
     want to define a SQL function that performs actions but has no
     useful value to return, you can define it as returning <type>void</type>.
     For example, this function removes rows with negative salaries from
     the <literal>emp</literal> table:

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-&minus;-&minus;-&minus;-&minus;-&minus;-

(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>语言中的任何命令集合都能被打包在一起并且被定义成一个函数。除了<command>SELECT</command>查询，命令可以包括数据修改查询（<command>INSERT</command>、<command>UPDATE</command>以及<command>DELETE</command>）和其他 SQL 命令（你不能在<acronym>SQL</acronym>函数中使用事务控制命令，例如<command>COMMIT</command>、<command>SAVEPOINT</command>，以及一些工具命令，例如<literal>VACUUM</literal>）。不过，最后一个命令必须是一个<command>SELECT</command>或者带有一个<literal>RETURNING</literal>子句，该命令必须返回符合函数返回类型的数据。或者，如果你想要定义一个执行动作但是不返回有用的值的函数，你可以把它定义为返回<type>void</type>。例如，这个函数从<literal>emp</literal>表中移除具有负值薪水的行：

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)
</screen>
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The entire body of a SQL function is parsed before any of it is
      executed.  While a SQL function can contain commands that alter
      the system catalogs (e.g., <command>CREATE TABLE</command>), the effects
      of such commands will not be visible during parse analysis of
      later commands in the function.  Thus, for example,
      <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>
      will not work as desired if packaged up into a single SQL function,
      since <structname>foo</structname> won't exist yet when the <command>INSERT</command>
      command is parsed.  It's recommended to use <application>PL/pgSQL</application>
      instead of a SQL function in this type of situation.
     </para>
____________________________________________________________________________-->
     <para>
      在被执行前，SQL 函数的整个主体都要被解析。虽然 SQL 函数可以包含修改系统目录的命令（如<command>CREATE TABLE</command>），但这类命令的效果对于该函数中后续命令的解析分析不可见。例如，如果把<literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>打包到一个 SQL 函数中是得不到预期效果的，因为在解析<command>INSERT</command>命令时<structname>foo</structname>还不存在。在这类情况下，推荐使用<application>PL/pgSQL</application>而不是 SQL 函数。
     </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The syntax of the <command>CREATE FUNCTION</command> command requires
    the function body to be written as a string constant.  It is usually
    most convenient to use dollar quoting (see <xref
    linkend="sql-syntax-dollar-quoting"/>) for the string constant.
    If you choose to use regular single-quoted string constant syntax,
    you must double single quote marks (<literal>'</literal>) and backslashes
    (<literal>\</literal>) (assuming escape string syntax) in the body of
    the function (see <xref linkend="sql-syntax-strings"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <command>CREATE FUNCTION</command>命令的语法要求函数体被写作一个字符串常量。使用用于字符串常量的美元引用通常最方便（见<xref linkend="sql-syntax-dollar-quoting"/>）。你过你选择使用常规的单引号引用的字符串常量语法，你必须在函数体中双写单引号（<literal>'</literal>）和反斜线（<literal>\</literal>）（假定转义字符串语法）（见<xref linkend="sql-syntax-strings"/>）。
   </para>

   <sect2 id="xfunc-sql-function-arguments">
<!--==========================orignal english content==========================
    <title>Arguments for <acronym>SQL</acronym> Functions</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym>函数的参数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>function</primary>
    <secondary>named argument</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>命名参数</secondary>
   </indexterm>

<!--==========================orignal english content==========================
    <para>
     Arguments of a SQL function can be referenced in the function
     body using either names or numbers.  Examples of both methods appear
     below.
    </para>
____________________________________________________________________________-->
    <para>
     一个 SQL 函数的参数可以在函数体中用名称或编号引用。下面会有两种方法的例子。
    </para>

<!--==========================orignal english content==========================
    <para>
     To use a name, declare the function argument as having a name, and
     then just write that name in the function body.  If the argument name
     is the same as any column name in the current SQL command within the
     function, the column name will take precedence.  To override this,
     qualify the argument name with the name of the function itself, that is
     <literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>.
     (If this would conflict with a qualified column name, again the column
     name wins.  You can avoid the ambiguity by choosing a different alias for
     the table within the SQL command.)
    </para>
____________________________________________________________________________-->
    <para>
     要使用一个名称，将函数参数声明为带有一个名称，然后在函数体中只写该名称。如果参数名称与函数内当前 SQL 命令中的任意列名相同，列名将优先。如果不想这样，可以用函数本身的名称来限定参数名，也就是<literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>（如果这会与一个被限定的列名冲突，照例还是列名赢得优先。你可以通过为 SQL 命令中的表选择一个不同的别名来避免这种混淆）。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the older numeric approach, arguments are referenced using the syntax
     <literal>$<replaceable>n</replaceable></literal>: <literal>$1</literal> refers to the first input
     argument, <literal>$2</literal> to the second, and so on.  This will work
     whether or not the particular argument was declared with a name.
    </para>
____________________________________________________________________________-->
    <para>
     在更旧的数字方法中，参数可以用语法<literal>$<replaceable>n</replaceable></literal>引用：<literal>$1</literal>指的是第一个输入参数，<literal>$2</literal>指的是第二个，以此类推。不管特定的参数是否使用名称声明，这种方法都有效。
    </para>

<!--==========================orignal english content==========================
    <para>
     If an argument is of a composite type, then the dot notation,
     e.g., <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal> or
     <literal>$1.<replaceable>fieldname</replaceable></literal>, can be used to access attributes of the
     argument.  Again, you might need to qualify the argument's name with the
     function name to make the form with an argument name unambiguous.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个参数是一种组合类型，那么点号记法（如
     <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal>
     或<literal>$1.<replaceable>fieldname</replaceable></literal>）也可以被用来
     访问该参数的属性。同样，你可能需要用函数的名称来限定参数的名称以避免歧义。
    </para>

<!--==========================orignal english content==========================
    <para>
     SQL function arguments can only be used as data values,
     not as identifiers.  Thus for example this is reasonable:
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
but this will not work:
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     SQL 函数参数只能被用做数据值而不能作为标识符。例如这是合理的：
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
但这样就不行：
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The ability to use names to reference SQL function arguments was added
      in <productname>PostgreSQL</productname> 9.2.  Functions to be used in
      older servers must use the <literal>$<replaceable>n</replaceable></literal> notation.
     </para>
____________________________________________________________________________-->
     <para>
      使用名称来引用 SQL 函数参数的能力是在<productname>PostgreSQL</productname> 9.2 中加入的。要在老的服务器中使用的函数必须使用<literal>$<replaceable>n</replaceable></literal>记法。
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-base-functions">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions on Base Types</title>
____________________________________________________________________________-->
    <title>基本类型上的<acronym>SQL</acronym></title>

<!--==========================orignal english content==========================
    <para>
     The simplest possible <acronym>SQL</acronym> function has no arguments and
     simply returns a base type, such as <type>integer</type>:

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-&minus; Alternative syntax for string literal:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-&minus;-&minus;-
   1
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     最简单的<acronym>SQL</acronym>函数没有参数并且简单地返回一个基本类型，例如<type>integer</type>：

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- Alternative syntax for string literal:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Notice that we defined a column alias within the function body for the result of the function
     (with  the  name <literal>result</literal>),  but this column alias is not visible
     outside the function.  Hence,  the  result  is labeled <literal>one</literal>
     instead of <literal>result</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     注意我们为该函数的结果在函数体内定义了一个列别名（名为<literal>result</literal>），但是这个列别名在函数以外是不可见的。因此，结果被标记为<literal>one</literal>而不是<literal>result</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is almost as easy to define <acronym>SQL</acronym> functions
     that take base types as arguments:

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
-&minus;-&minus;-&minus;-&minus;
      3
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     定义用基本类型作为参数的<acronym>SQL</acronym>函数也很容易：

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Alternatively, we could dispense with names for the arguments and
     use numbers:

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
-&minus;-&minus;-&minus;-&minus;
      3
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     我们也能省掉参数的名称而使用数字：

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is a more useful function, which might be used to debit a
     bank account:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

     A user could execute this function to debit account 17 by $100.00 as
     follows:

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个更有用的函数，它可以被用来借记一个银行账号：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

     一个用户可以这样执行这个函数来从账户 17 中借记 $100.00：

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     In this example, we chose the name <literal>accountno</literal> for the first
     argument, but this is the same as the name of a column in the
     <literal>bank</literal> table.  Within the <command>UPDATE</command> command,
     <literal>accountno</literal> refers to the column <literal>bank.accountno</literal>,
     so <literal>tf1.accountno</literal> must be used to refer to the argument.
     We could of course avoid this by using a different name for the argument.
    </para>
____________________________________________________________________________-->
    <para>
     在这个例子中，我们为第一个参数选择了名称<literal>accountno</literal>，但是这和表<literal>bank</literal>中的一个列名相同。
     在<command>UPDATE</command>命令中，
     <literal>accountno</literal>引用列<literal>bank.accountno</literal>，因此
     <literal>tf1.accountno</literal>必须被用来引用该参数。
     我们当然可以通过为该参数使用一个不同的名称来避免这样的问题。
    </para>

<!--==========================orignal english content==========================
    <para>
     In practice one would probably like a more useful result from the
     function than a constant 1, so a more likely definition
     is:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

     which adjusts the balance and returns the new balance.
     The same thing could be done in one command using <literal>RETURNING</literal>:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     实际上我们可能喜欢从该函数得到一个更有用的结果而不是一个常数 1，因此一个更可能的定义是：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

     它会调整余额并且返回新的余额。
     同样的事情也可以用一个使用<literal>RETURNING</literal>的命令实现：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     If the final <literal>SELECT</literal> or <literal>RETURNING</literal>
     clause in a <acronym>SQL</acronym> function does not return exactly
     the function's declared result
     type, <productname>PostgreSQL</productname> will automatically cast
     the value to the required type, if that is possible with an implicit
     or assignment cast.  Otherwise, you must write an explicit cast.
     For example, suppose we wanted the
     previous <function>add_em</function> function to return
     type <type>float8</type> instead.  It's sufficient to write

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     since the <type>integer</type> sum can be implicitly cast
     to <type>float8</type>.
     (See <xref linkend="typeconv"/> or <xref linkend="sql-createcast"/>
     for more about casts.)
    </para>
____________________________________________________________________________-->
    <para>
     如果<acronym>SQL</acronym>函数中的最后一个<literal>SELECT</literal>或<literal>RETURNING</literal>
     子句没有准确返回函数声明的结果类型，<productname>PostgreSQL</productname>将自动将值转换为所需的类型，
     如果可以使用隐式或赋值转换。否则，您必须编写显式强制转换。
     例如，假设我们想要之前的<function>add_em</function>函数返回类型<type>float8</type>。
     写就足够了

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     因为<type>integer</type>总和可以隐式转换为<type>float8</type>。（有关强制转换的更多信息，请参阅<xref linkend="typeconv"/>或<xref linkend="sql-createcast"/>。）

    </para>
   </sect2>

   <sect2 id="xfunc-sql-composite-functions">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions on Composite Types</title>
____________________________________________________________________________-->
    <title>组合类型上的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <para>
     When writing functions with arguments of composite types, we must not
     only specify which argument we want but also the desired attribute
     (field) of that argument.  For example, suppose that
     <type>emp</type> is a table containing employee data, and therefore
     also the name of the composite type of each row of the table.  Here
     is a function <function>double_salary</function> that computes what someone's
     salary would be if it were doubled:

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Bill |  8400
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在编写使用组合类型参数的函数时，我们必须不仅指定我们想要哪些参数，还要指定参数的期望属性（域）。例如，假定
     <type>emp</type>是一个包含雇员数据的表，并且因此它也是该表每一行的组合类型的名称。
     这里是一个函数<function>double_salary</function>，它计算某个人的双倍薪水：

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Notice the use of the syntax <literal>$1.salary</literal>
     to select one field of the argument row value.  Also notice
     how the calling <command>SELECT</command> command
     uses <replaceable>table_name</replaceable><literal>.*</literal> to select
     the entire current row of a table as a composite value.  The table
     row can alternatively be referenced using just the table name,
     like this:
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     but this usage is deprecated since it's easy to get confused.
     (See <xref linkend="rowtypes-usage"/> for details about these
     two notations for the composite value of a table row.)
    </para>
____________________________________________________________________________-->
    <para>
     注意语法<literal>$1.salary</literal>的使用是要选择参数行值的一个域。
     还要注意调用的<command>SELECT</command>命令是如何使用<replaceable>table_name</replaceable><literal>.*</literal>来选择一个表的整个当前行作为一个组合值的。该表行也可以只用表名来引用：
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     但这种用法已被废弃因为它很容易让人搞混（关于表行的组合值的这两种记法的详细情况请见<xref linkend="rowtypes-usage"/>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Sometimes it is handy to construct a composite argument value
     on-the-fly.  This can be done with the <literal>ROW</literal> construct.
     For example, we could adjust the data being passed to the function:
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     有时候实时构建一个组合参数很方便。这可以用<literal>ROW</literal>结构完成。
     例如，我们可以调整被传递给函数的数据：
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     It is also possible to build a function that returns a composite type.
     This is an example of a function
     that returns a single <type>emp</type> row:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

     In this example we have specified each of  the  attributes
     with  a  constant value, but any computation
     could have been substituted for these constants.
    </para>
____________________________________________________________________________-->
    <para>
     也可以构建一个返回组合类型的函数。这是一个返回单一<type>emp</type>行的函数例子：

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

     在这个例子中，我们为每一个属性指定了一个常量值，但是可以用任何计算来替换这些常量。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note two important things about defining the function:

     <itemizedlist>
      <listitem>
       <para>
        The select list order in the query must be exactly the same as
        that in which the columns appear in the composite type.
        (Naming the columns, as we did above,
        is irrelevant to the system.)
       </para>
      </listitem>
      <listitem>
       <para>
        We must ensure each expression's type can be cast to that of
        the corresponding column of the composite type.
        Otherwise we'll get errors like this:
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
        As with the base-type case, the system will not insert explicit
        casts automatically, only implicit or assignment casts.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     有关定义函数有两件重要的事情：

     <itemizedlist>
      <listitem>
       <para>
        查询中的选择列表顺序必须与列在复合类型中出现的顺序完全相同。（正如我们上面所做的那样，命名列与系统无关。）
       </para>
      </listitem>
      <listitem>
       <para>
        我们必须确保每个表达式的类型都可以转换为复合类型的相应列的类型。 否则我们会得到这样的错误：
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
        与基本类型的情况一样，系统不会自动插入显式转换，只会插入隐式或赋值转换。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     A different way to define the same function is:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

     Here we wrote a <command>SELECT</command> that returns just a single
     column of the correct composite type.  This isn't really better
     in this situation, but it is a handy alternative in some cases
     &mdash; for example, if we need to compute the result by calling
     another function that returns the desired composite value.
     Another example is that if we are trying to write a function that
     returns a domain over composite, rather than a plain composite type,
     it is always necessary to write it as returning a single column,
     since there is no way to cause a coercion of the whole row result.
    </para>
____________________________________________________________________________-->
    <para>
     定义同样的函数的一种不同的方法是：

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

     这里我们写了一个只返回正确组合类型的单一列的<command>SELECT</command>。
     在这种情况下这种写法实际并非更好，但是它在一些情况下比较方便
     &mdash; 例如，我们需要通过调用另一个返回所期望的组合值的函数来计算结果。
     另一个例子是，如果我们试图编写一个函数，它返回一个复合类型的域，而不是一个普通的复合类型，
     总是有必要把它写成返回单个列，因为没有办法导致整行结果。
    </para>

<!--==========================orignal english content==========================
    <para>
     We could call this function directly either by using it in
     a value expression:

<screen>
SELECT new_emp();

         new_emp
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 (None,1000.0,25,"(2,2)")
</screen>

     or by calling it as a table function:

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 None | 1000.0 |  25 | (2,2)
</screen>

     The second way is described more fully in <xref
     linkend="xfunc-sql-table-functions"/>.
    </para>
____________________________________________________________________________-->
    <para>
     我们可以直接调用这个函数或者在一个值表达式中使用它：

<screen>
SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</screen>

     或者把它当做一个表函数调用：

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
</screen>

     第二种方式在<xref linkend="xfunc-sql-table-functions"/>中有更完全的描述。
    </para>

<!--==========================orignal english content==========================
    <para>
     When you use a function that returns a composite type,
     you might want only one field (attribute) from its result.
     You can do that with syntax like this:

<screen>
SELECT (new_emp()).name;

 name
-&minus;-&minus;-&minus;
 None
</screen>

     The extra parentheses are needed to keep the parser from getting
     confused.  If you try to do it without them, you get something like this:

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     当你使用一个返回组合类型的函数时，你可能只想要其结果中的一个域（属性）。
     你可以这样做：

<screen>
SELECT (new_emp()).name;

 name
------
 None
</screen>

     额外的圆括号是必须的，它用于避免解析器被搞混。如果你不写这些括号，会这样：

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Another option is to use functional notation for extracting an attribute:

<screen>
SELECT name(new_emp());

 name
-&minus;-&minus;-&minus;
 None
</screen>

     As explained in <xref linkend="rowtypes-usage"/>, the field notation and
     functional notation are equivalent.
    </para>
____________________________________________________________________________-->
    <para>
     另一个选项是使用函数记号来抽取一个属性：

<screen>
SELECT name(new_emp());

 name
------
 None
</screen>

     如<xref linkend="rowtypes-usage"/>中所说，字段记法和函数记法是等效的。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another way to use a function returning a composite type is to pass the
     result to another function that accepts the correct row type as input:

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
-&minus;-&minus;-&minus;-&minus;-
 None
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     另一种使用返回组合类型的函数的方法是把结果传递给另一个接收正确行类型作为输入的函数：

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)
</screen>
    </para>
   </sect2>

   <sect2 id="xfunc-output-parameters">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions with Output Parameters</title>
____________________________________________________________________________-->
    <title>带有输出参数的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>function</primary>
    <secondary>output parameter</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>输出参数</secondary>
   </indexterm>

<!--==========================orignal english content==========================
    <para>
     An alternative way of describing a function's results is to define it
     with <firstterm>output parameters</firstterm>, as in this example:

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
-&minus;-&minus;-&minus;-&minus;
     10
(1 row)
</screen>

     This is not essentially different from the version of <literal>add_em</literal>
     shown in <xref linkend="xfunc-sql-base-functions"/>.  The real value of
     output parameters is that they provide a convenient way of defining
     functions that return several columns.  For example,

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  53 |     462
(1 row)
</screen>

     What has essentially happened here is that we have created an anonymous
     composite type for the result of the function.  The above example has
     the same end result as

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>

     but not having to bother with the separate composite type definition
     is often handy.  Notice that the names attached to the output parameters
     are not just decoration, but determine the column names of the anonymous
     composite type.  (If you omit a name for an output parameter, the
     system will choose a name on its own.)
    </para>
____________________________________________________________________________-->
    <para>
     一种描述一个函数的结果的替代方法是定义它的<firstterm>输出参数</firstterm>，例如：

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)
</screen>

     这和<xref linkend="xfunc-sql-base-functions"/>中展示的<literal>add_em</literal>版本没有本质上的不同。输出参数的真正价值是它们提供了一种方便的方法来定义返回多个列的函数。例如，

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
</screen>

     这里实际发生的是我们为该函数的结果创建了一个匿名的组合类型。上述例子具有与下面相同的最终结果

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>

     但是不必单独定义组合类型常常很方便。注意输出参数的名称并非只是装饰，而且决定了匿名组合类型的列名（如果你为一个输出参数忽略了名称，系统将自行选择一个名称）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Notice that output parameters are not included in the calling argument
     list when invoking such a function from SQL.  This is because
     <productname>PostgreSQL</productname> considers only the input
     parameters to define the function's calling signature.  That means
     also that only the input parameters matter when referencing the function
     for purposes such as dropping it.  We could drop the above function
     with either of

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在从 SQL 调用这样一个函数时，输出参数不会被包括在调用参数列表中。这是因为<productname>PostgreSQL</productname>只考虑输入参数来定义函数的调用签名。这也意味着在为诸如删除函数等目的引用该函数时只有输入参数有关系。我们可以用下面的命令之一删除上述函数

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Parameters can be marked as <literal>IN</literal> (the default),
     <literal>OUT</literal>, <literal>INOUT</literal>, or <literal>VARIADIC</literal>.
     An <literal>INOUT</literal>
     parameter serves as both an input parameter (part of the calling
     argument list) and an output parameter (part of the result record type).
     <literal>VARIADIC</literal> parameters are input parameters, but are treated
     specially as described next.
    </para>
____________________________________________________________________________-->
    <para>
     参数可以被标记为<literal>IN</literal>（默认）、<literal>OUT</literal>、<literal>INOUT</literal>或者<literal>VARIADIC</literal>。一个<literal>INOUT</literal>参数既作为一个输入参数（调用参数列表的一部分）又作为一个输出参数（结果记录类型的一部分）。<literal>VARIADIC</literal>参数是输入参数，但被按照后文所述特殊对待。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-variadic-functions">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions with Variable Numbers of Arguments</title>
____________________________________________________________________________-->
    <title>带有可变数量参数的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>variadic</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>variadic</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>variadic function</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>variadic function</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     <acronym>SQL</acronym> functions can be declared to accept
     variable numbers of arguments, so long as all the <quote>optional</quote>
     arguments are of the same data type.  The optional arguments will be
     passed to the function as an array.  The function is declared by
     marking the last parameter as <literal>VARIADIC</literal>; this parameter
     must be declared as being of an array type.  For example:

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
-&minus;-&minus;-&minus;-&minus;
     -1
(1 row)
</screen>

     Effectively, all the actual arguments at or beyond the
     <literal>VARIADIC</literal> position are gathered up into a one-dimensional
     array, as if you had written

<screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -&minus; doesn't work
</screen>

     You can't actually write that, though &mdash; or at least, it will
     not match this function definition.  A parameter marked
     <literal>VARIADIC</literal> matches one or more occurrences of its element
     type, not of its own type.
    </para>
____________________________________________________________________________-->
    <para>
     只要<quote>可选的</quote>参数都是相同的数据类型，<acronym>SQL</acronym>函数可以被声明为接受可变数量的参数。可选的参数将被作为一个数组传递给该函数。声明该函数时要把最后一个参数标记为<literal>VARIADIC</literal>，这个参数必须被声明为一个数组类型，例如：

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)
</screen>

     实际上，所有位于或者超过<literal>VARIADIC</literal>位置的实参会被收集成一个一位数组，就好像你写了：

<screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- 不起作用
</screen>

     但是你实际无法这样写 &mdash; 或者说至少它将无法匹配这个函数定义。一个被标记为<literal>VARIADIC</literal>的参数匹配其元素类型的一次或者多次出现，而不是它自身类型的出现。
    </para>

<!--==========================orignal english content==========================
    <para>
     Sometimes it is useful to be able to pass an already-constructed array
     to a variadic function; this is particularly handy when one variadic
     function wants to pass on its array parameter to another one.  Also,
     this is the only secure way to call a variadic function found in a schema
     that permits untrusted users to create objects; see
     <xref linkend="typeconv-func"/>.  You can do this by
     specifying <literal>VARIADIC</literal> in the call:

<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

     This prevents expansion of the function's variadic parameter into its
     element type, thereby allowing the array argument value to match
     normally.  <literal>VARIADIC</literal> can only be attached to the last
     actual argument of a function call.
    </para>
____________________________________________________________________________-->
    <para>
     有时候能够传递一个已经构造好的数组给 variadic 函数是有用的，特别是当
     一个 variadic 函数想要把它的数组参数传递给另一个函数时这会特别方便。此外，这是在一个允许不可信用户创建对象的方案中调用一个variadic函数的唯一安全的方式，见<xref linkend="typeconv-func"/>。你可以通过在调用中指定<literal>VARIADIC</literal>来做到这一点：

<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

     这会阻止该函数的 variadic 参数扩展成它的元素结构，从而允许数组参
     数值正常匹配。<literal>VARIADIC</literal>只能被附着在函数调用的最后一
     个实参上。
    </para>

<!--==========================orignal english content==========================
    <para>
     Specifying <literal>VARIADIC</literal> in the call is also the only way to
     pass an empty array to a variadic function, for example:

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

     Simply writing <literal>SELECT mleast()</literal> does not work because a
     variadic parameter must match at least one actual argument.
     (You could define a second function also named <literal>mleast</literal>,
     with no parameters, if you wanted to allow such calls.)
    </para>
____________________________________________________________________________-->
    <para>
     在调用中指定<literal>VARIADIC</literal>也是将空数组传递给 variadic 函数
     的唯一方式，例如：

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

     简单地写成<literal>SELECT mleast()</literal>是没有作用的，因为一个 variadic
     参数必须匹配至少一个实参（如果想允许这类调用，你可以定义第二个没有
     参数且也叫<literal>mleast</literal>的函数）。
    </para>

<!--==========================orignal english content==========================
    <para>
     The array element parameters generated from a variadic parameter are
     treated as not having any names of their own.  This means it is not
     possible to call a variadic function using named arguments (<xref
     linkend="sql-syntax-calling-funcs"/>), except when you specify
     <literal>VARIADIC</literal>.  For example, this will work:

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

     but not these:

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     从一个 variadic 参数产生的数组元素参数会被当做自己不具有名称。这
     意味着不能使用命名参数调用 variadic 函数（<xref
     linkend="sql-syntax-calling-funcs"/>），除非你指定了
     <literal>VARIADIC</literal>。例如下面的调用是可以工作的：

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

     但这些就不行：

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
    </para>
   </sect2>

   <sect2 id="xfunc-sql-parameter-defaults">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions with Default Values for Arguments</title>
____________________________________________________________________________-->
    <title>带有参数默认值的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>default values for arguments</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>default values for arguments</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Functions can be declared with default values for some or all input
     arguments.  The default values are inserted whenever the function is
     called with insufficiently many actual arguments.  Since arguments
     can only be omitted from the end of the actual argument list, all
     parameters after a parameter with a default value have to have
     default values as well.  (Although the use of named argument notation
     could allow this restriction to be relaxed, it's still enforced so that
     positional argument notation works sensibly.)  Whether or not you use it,
     this capability creates a need for precautions when calling functions in
     databases where some users mistrust other users; see
     <xref linkend="typeconv-func"/>.
    </para>
____________________________________________________________________________-->
    <para>
     函数可以被声明为对一些或者所有输入参数具有默认值。只要调用函数时
     没有给出足够多的实参，就会插入默认值来弥补缺失的实参。由于参数只
     能从实参列表的尾部开始被省略，在一个有默认值的参数之后的所有参数
     都不得不也具有默认值（尽管使用命名参数记法可以允许放松这种限制，
     这种限制仍然会被强制以便位置参数记法能工作）。不管你是否使用它，这种能力都要求在某些用户不信任其他用户的数据中调用函数时做一些预防措施，见<xref linkend="typeconv-func"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example:
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-&minus;-&minus;-
  60
(1 row)

SELECT foo(10, 20);
 foo 
-&minus;-&minus;-
  33
(1 row)

SELECT foo(10);
 foo 
-&minus;-&minus;-
  15
(1 row)

SELECT foo();  -&minus; fails since there is no default for the first argument
ERROR:  function foo() does not exist
</screen>
     The <literal>=</literal> sign can also be used in place of the
     key word <literal>DEFAULT</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     例如：
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

SELECT foo();  -- 因为第一个参数没有默认值，所以会失败
ERROR:  function foo() does not exist
</screen>
     <literal>=</literal>符号也可以用来替代关键词
     <literal>DEFAULT</literal>。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-table-functions">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions as Table Sources</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym> 函数作为表来源</title>

<!--==========================orignal english content==========================
    <para>
     All SQL functions can be used in the <literal>FROM</literal> clause of a query,
     but it is particularly useful for functions returning composite types.
     If the function is defined to return a base type, the table function
     produces a one-column table.  If the function is defined to return
     a composite type, the table function produces a column for each attribute
     of the composite type.
    </para>
____________________________________________________________________________-->
    <para>
     所有的 SQL 函数都可以被用在查询的<literal>FROM</literal>子句中，但是
     对于返回组合类型的函数特别有用。如果函数被定义为返回一种基本类型，
     该表函数会产生一个单列表。如果该函数被定义为返回一种组合类型，该
     表函数会为该组合类型的每一个属性产生一列。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example:

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
     1 |        1 | Joe     | JOE
(1 row)
</screen>

     As the example shows, we can work with the columns of the function's
     result just the same as if they were columns of a regular table.
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子：

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)
</screen>

     正如例子所示，我们可以把函数结果的列当作常规表的列来使用。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that we only got one row out of the function.  This is because
     we did not use <literal>SETOF</literal>.  That is described in the next section.
    </para>
____________________________________________________________________________-->
    <para>
     注意我们只从函数得到了一行。这是因为我们没有使用<literal>SETOF</literal>。
     这会在下一节中介绍。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-set">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions Returning Sets</title>
____________________________________________________________________________-->
    <title>返回集合的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>with SETOF</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>with SETOF</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     When an SQL function is declared as returning <literal>SETOF
     <replaceable>sometype</replaceable></literal>, the function's final
     query is executed to completion, and each row it
     outputs is returned as an element of the result set.
    </para>
____________________________________________________________________________-->
    <para>
     当一个 SQL 函数被声明为返回<literal>SETOF
     <replaceable>sometype</replaceable></literal>时，该函数的
     最后一个查询会被执行完，并且它输出的每一行都会被
     作为结果集的一个元素返回。
    </para>

<!--==========================orignal english content==========================
    <para>
     This feature is normally used when calling the function in the <literal>FROM</literal>
     clause.  In this case each row returned by the function becomes
     a row of the table seen by the query.  For example, assume that
     table <literal>foo</literal> has the same contents as above, and we say:

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

     Then we would get:
<screen>
 fooid | foosubid | fooname
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在<literal>FROM</literal>子句中调用函数时通常会使用这种特性。在这种
     情况下，该函数返回的每一行都变成查询所见的表的一行。例如，假设
     表<literal>foo</literal>具有和上文一样的内容，并且我们做了以下动作：

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

     那么我们会得到：
<screen>
 fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     It is also possible to return multiple rows with the columns defined by
     output parameters, like this:

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

     The key point here is that you must write <literal>RETURNS SETOF record</literal>
     to indicate that the function returns multiple rows instead of just one.
     If there is only one output parameter, write that parameter's type
     instead of <type>record</type>.
    </para>
____________________________________________________________________________-->
    <para>
     也可以返回多个带有由输出参数定义的列的行，像这样：

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

     这里的关键点是必须写上<literal>RETURNS SETOF record</literal>来指示
     该函数返回多行而不是一行。如果只有一个输出参数，则写上该参数的
     类型而不是<type>record</type>。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is frequently useful to construct a query's result by invoking a
     set-returning function multiple times, with the parameters for each
     invocation coming from successive rows of a table or subquery.  The
     preferred way to do this is to use the <literal>LATERAL</literal> key word,
     which is described in <xref linkend="queries-lateral"/>.
     Here is an example using a set-returning function to enumerate
     elements of a tree structure:

<screen>
SELECT * FROM nodes;
   name    | parent
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     This example does not do anything that we couldn't have done with a
     simple join, but in more complex calculations the option to put
     some of the work into a function can be quite convenient.
    </para>
____________________________________________________________________________-->
    <para>
     通过多次调用集合返回函数来构建查询的结果非常有用，每次调用的参数
     来自于一个表或者子查询的连续行。做这种事情最好的方法是使用
     <xref linkend="queries-lateral"/>中描述的<literal>LATERAL</literal>关键
     词。这里是一个使用集合返回函数枚举树结构中元素的例子：

<screen>
SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     这个例子和我们使用的简单连接的效果没什么不同，但是在更复杂的
     计算中，把一些工作放在函数中会是一种很方便的选项。
    </para>

<!--==========================orignal english content==========================
    <para>
     Functions returning sets can also be called in the select list
     of a query.  For each row that the query
     generates by itself, the set-returning function is invoked, and an output
     row is generated for each element of the function's result set.
     The previous example could also be done with queries like
     these:

<screen>
SELECT listchildren('Top');
 listchildren
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     In the last <command>SELECT</command>,
     notice that no output row appears for <literal>Child2</literal>, <literal>Child3</literal>, etc.
     This happens because <function>listchildren</function> returns an empty set
     for those arguments, so no result rows are generated.  This is the same
     behavior as we got from an inner join to the function result when using
     the <literal>LATERAL</literal> syntax.
    </para>
____________________________________________________________________________-->
    <para>
     返回集合的函数也能在查询的选择列表中调用。对于该查询本身产生的每一行都会调用集合返回函数，并且会从该函数的结果集中的每一个元素生成一个输出行。之前的例子也可以用这样的查询实现：

<screen>
SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     在最后一个<command>SELECT</command>中，注意对于<literal>Child2</literal>、
     <literal>Child3</literal>等没有出现输出行。这是因为<function>listchildren</function>
     对这些参数返回空集，因此没有产生结果行。这和使用<literal>LATERAL</literal>
     语法时，我们从与该函数结果的内连接得到的行为是一样的。
    </para>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname>'s behavior for a set-returning function in a
     query's select list is almost exactly the same as if the set-returning
     function had been written in a <literal>LATERAL FROM</literal>-clause item
     instead.  For example,
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     is almost equivalent to
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     It would be exactly the same, except that in this specific example,
     the planner could choose to put <structname>g</structname> on the outside of the
     nested-loop join, since <structname>g</structname> has no actual lateral dependency
     on <structname>tab</structname>.  That would result in a different output row
     order.  Set-returning functions in the select list are always evaluated
     as though they are on the inside of a nested-loop join with the rest of
     the <literal>FROM</literal> clause, so that the function(s) are run to
     completion before the next row from the <literal>FROM</literal> clause is
     considered.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>中，写在查询的选择列表中的集合返回函数的行为几乎和写在<literal>LATERAL FROM</literal>子句项中的集合返回函数完全一样。例如：
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     几乎等效于
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     这会是完全一样的，除了在这个特别的例子中，规划器会选择把<structname>g</structname>放在嵌套循环连接的外侧，因为<structname>g</structname>对<structname>tab</structname>没有实际的横向依赖。那会导致一种不同的输出行顺序。选择列表中的集合返回函数总是会被计算，就好像它们在<literal>FROM</literal>子句剩余部分的嵌套循环连接的内侧一样，因此在考虑来自<literal>FROM</literal>子句的下一行之前，这些函数会运行到完成。
    </para>

<!--==========================orignal english content==========================
    <para>
     If there is more than one set-returning function in the query's select
     list, the behavior is similar to what you get from putting the functions
     into a single <literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>-clause
     item.  For each row from the underlying query, there is an output row
     using the first result from each function, then an output row using the
     second result, and so on.  If some of the set-returning functions
     produce fewer outputs than others, null values are substituted for the
     missing data, so that the total number of rows emitted for one
     underlying row is the same as for the set-returning function that
     produced the most outputs.  Thus the set-returning functions
     run <quote>in lockstep</quote> until they are all exhausted, and then
     execution continues with the next underlying row.
    </para>
____________________________________________________________________________-->
    <para>
     如果在查询的选择列表中有不止一个集合返回函数，则行为类似于把那些函数放到一个单一的<literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>子句项中的行为。对于来自底层查询的每一行，都有一个用到每个函数首个结果的输出行，然后是一个使用每个函数第二个结果的输出行，以此类推。如果某些集合返回函数产生的输出比其他函数少，会用空值代替缺失的数据，因此为一个底层行形成的总行数等于产生最多输出的集合返回函数的输出行数。因此集合返回函数会<quote>步调一致</quote>地运行直到它们的输出被耗尽，然后用下一个底层行继续执行。
    </para>

<!--==========================orignal english content==========================
    <para>
     Set-returning functions can be nested in a select list, although that is
     not allowed in <literal>FROM</literal>-clause items.  In such cases, each level
     of nesting is treated separately, as though it were
     a separate <literal>LATERAL ROWS FROM( ... )</literal> item.  For example, in
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     the set-returning functions <function>srf2</function>, <function>srf3</function>,
     and <function>srf5</function> would be run in lockstep for each row
     of <structname>tab</structname>, and then <function>srf1</function> and <function>srf4</function>
     would be applied in lockstep to each row produced by the lower
     functions.
    </para>
____________________________________________________________________________-->
    <para>
     集合返回函数可以被嵌套在一个选择列表中，不过在<literal>FROM</literal>子句项中不允许这样做。在这种情况下，嵌套的每一层会被单独对待，就像它是一个单独的<literal>LATERAL ROWS FROM( ... )</literal>项一样。例如，在
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     中，集合返回函数<function>srf2</function>、<function>srf3</function>和<function>srf5</function>将为<structname>tab</structname>的每一行步调一致地运行，然后会对较低层的函数产生的每一行以步调一致的形式应用<function>srf1</function>和<function>srf4</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Set-returning functions cannot be used within conditional-evaluation
     constructs, such as <literal>CASE</literal> or <literal>COALESCE</literal>.  For
     example, consider
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     It might seem that this should produce five repetitions of input rows
     that have <literal>x &gt; 0</literal>, and a single repetition of those that do
     not; but actually, because <function>generate_series(1, 5)</function> would be
     run in an implicit <literal>LATERAL FROM</literal> item before
     the <literal>CASE</literal> expression is ever evaluated, it would produce five
     repetitions of every input row.  To reduce confusion, such cases produce
     a parse-time error instead.
    </para>
____________________________________________________________________________-->
    <para>
     在<literal>CASE</literal>或<literal>COALESCE</literal>这样的条件计算结构中，不能使用集合返回函数。例如，考虑
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     看起来这个语句应该产生满足<literal>x &gt; 0</literal>的输入行的五次重复，以及不满足的行的一次重复。但实际上，由于在<literal>CASE</literal>表达时被计算前，<function>generate_series(1, 5)</function>会被运行在一个隐式的<literal>LATERAL FROM</literal>项中，它会为每个输入行产生五次重复。为了减少混乱，这类情况会产生一个解析时错误。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      If a function's last command is <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command> with <literal>RETURNING</literal>, that command will
      always be executed to completion, even if the function is not declared
      with <literal>SETOF</literal> or the calling query does not fetch all the
      result rows.  Any extra rows produced by the <literal>RETURNING</literal>
      clause are silently dropped, but the commanded table modifications
      still happen (and are all completed before returning from the function).
     </para>
____________________________________________________________________________-->
     <para>
      如果函数的最后一个命令是带有<literal>RETURNING</literal>的
      <command>INSERT</command>、<command>UPDATE</command>或者
      <command>DELETE</command>，该命令将总是会被执行完，即使函数没有用
      <literal>SETOF</literal>定义或者调用查询不要求取出所有结果行也是如此。
      <literal>RETURNING</literal>子句产生的多余的行会被悄无声息地丢掉，但是
      在命令的目标表上的修改仍然会发生（而且在从该函数返回前就会全部完成）。
     </para>
    </note>

    <note>
<!--==========================orignal english content==========================
     <para>
      Before <productname>PostgreSQL</productname> 10, putting more than one
      set-returning function in the same select list did not behave very
      sensibly unless they always produced equal numbers of rows.  Otherwise,
      what you got was a number of output rows equal to the least common
      multiple of the numbers of rows produced by the set-returning
      functions.  Also, nested set-returning functions did not work as
      described above; instead, a set-returning function could have at most
      one set-returning argument, and each nest of set-returning functions
      was run independently.  Also, conditional execution (set-returning
      functions inside <literal>CASE</literal> etc) was previously allowed,
      complicating things even more.
      Use of the <literal>LATERAL</literal> syntax is recommended when writing
      queries that need to work in older <productname>PostgreSQL</productname> versions,
      because that will give consistent results across different versions.
      If you have a query that is relying on conditional execution of a
      set-returning function, you may be able to fix it by moving the
      conditional test into a custom set-returning function.  For example,
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      could become
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      This formulation will work the same in all versions
      of <productname>PostgreSQL</productname>.
     </para>
____________________________________________________________________________-->
     <para>
      在<productname>PostgreSQL</productname> 10之前，把多个集合返回函数放在同一个选择列表中的行为并不容易察觉，除非它们总是产生同等的行数。否则，你得到的输出行数将会是各集合返回函数产生的行数的最小公倍数。此外，嵌套的集合返回函数不会按照上述的方式工作。相反，一个集合返回函数只能有最多一个集合返回参数，集合返回函数的每一次嵌套会被独立运行。此外，条件执行（<literal>CASE</literal>等中的集合返回函数）以前是被允许的，但是会让事情更加复杂。在编写需要在较老的<productname>PostgreSQL</productname>版本中工作的查询时，推荐使用<literal>LATERAL</literal>语法，因为这种语法能够在不同的版本间提供一致的结果。如果有一个依赖于集合返回函数的条件执行，那么可能可以通过把条件测试移到一个自定义集合返回函数中来修正该问题。例如，
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      可以变成
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      这种表达形式将在所有版本的<productname>PostgreSQL</productname>中以相同的方式工作。
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-table">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions Returning <literal>TABLE</literal></title>
____________________________________________________________________________-->
    <title>返回<literal>TABLE</literal>的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     There is another way to declare a function as returning a set,
     which is to use the syntax
     <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.
     This is equivalent to using one or more <literal>OUT</literal> parameters plus
     marking the function as returning <literal>SETOF record</literal> (or
     <literal>SETOF</literal> a single output parameter's type, as appropriate).
     This notation is specified in recent versions of the SQL standard, and
     thus may be more portable than using <literal>SETOF</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     还有另一种方法可以把函数声明为返回一个集合，即使用
     <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>语法。
     这等效于使用一个或者多个<literal>OUT</literal>参数外加把函数标记为返回
     <literal>SETOF record</literal>（或者是<literal>SETOF</literal>单个输出参数的
     类型）。这种写法是在最近的 SQL 标准中指定的，因此可能比使用
     <literal>SETOF</literal>的移植性更好。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example, the preceding sum-and-product example could also be
     done this way:

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

     It is not allowed to use explicit <literal>OUT</literal> or <literal>INOUT</literal>
     parameters with the <literal>RETURNS TABLE</literal> notation &mdash; you must
     put all the output columns in the <literal>TABLE</literal> list.
    </para>
____________________________________________________________________________-->
    <para>
     例如，前面的求和并且相乘的例子也可以这样来做：

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

     不允许把显式的<literal>OUT</literal>或者<literal>INOUT</literal>参数用于
     <literal>RETURNS TABLE</literal>记法 &mdash; 必须把所有输出列放在
     <literal>TABLE</literal>列表中。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-polymorphic-functions">
<!--==========================orignal english content==========================
    <title>Polymorphic <acronym>SQL</acronym> Functions</title>
____________________________________________________________________________-->
    <title>多态<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <para>
     <acronym>SQL</acronym> functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.  Here is a polymorphic
     function <function>make_array</function> that builds up an array
     from two arbitrary data type elements:
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>函数可以声明为接受和返回<xref linkend="extend-types-polymorphic"/>中描述的多态类型。
     这是一个多态函数<function>make_array</function>，它从两个任意数据类型元素构建一个数组：
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Notice the use of the typecast <literal>'a'::text</literal>
     to specify that the argument is of type <type>text</type>. This is
     required if the argument is just a string literal, since otherwise
     it would be treated as type
     <type>unknown</type>, and array of <type>unknown</type> is not a valid
     type.
     Without the typecast, you will get errors like this:
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     注意类型造型<literal>'a'::text</literal>的使用是为了指定该参数的类型
     是<type>text</type>。如果该参数只是一个字符串这就是必须的，因为
     否则它会被当作<type>unknown</type>类型，并且
     <type>unknown</type>的数组也不是一种合法的类型。如果没有改类型
     造型，将得到这样的错误：
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     With <function>make_array</function> declared as above, you must
     provide two arguments that are of exactly the same data type; the
     system will not attempt to resolve any type differences.  Thus for
     example this does not work:
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
     An alternative approach is to use the <quote>common</quote> family of
     polymorphic types, which allows the system to try to identify a
     suitable common type:
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2.5}
(1 row)
</screen>
     Because the rules for common type resolution default to choosing
     type <type>text</type> when all inputs are of unknown types, this
     also works:
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray 
-&minus;-&minus;-&minus;-&minus;-&minus;-
 {a,b}
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     使用上述声明的<function>make_array</function>，您必须提供两个数据类型完全相同的参数； 
     系统不会尝试解决任何类型差异。因此，例如，这并不工作：
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
     另一种方法是使用<quote>common</quote>多态类型系列，它允许系统尝试识别合适的公共类型：
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
--------------
 {1,2.5}
(1 row)
</screen>
     因为当所有输入都是未知类型时，通用类型解析规则默认选择类型<type>text</type>，这也适用：
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray 
-----------
 {a,b}
(1 row)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     It is permitted to have polymorphic arguments with a fixed
     return type, but the converse is not. For example:
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     允许具有多态参数和固定的返回类型，但是反过来不行。例如：
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Polymorphism can be used with functions that have output arguments.
     For example:
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 22 | {22,22}
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     多态化可以用在具有输出参数的函数上。例如：
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Polymorphism can also be used with variadic functions.
     For example:
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
-&minus;-&minus;-&minus;-&minus;-&minus;
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
-&minus;-&minus;-&minus;-&minus;-&minus;
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1|4|2
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     多态化也可以用在 variadic 函数上。例如：
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)
</screen>
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Functions with Collations</title>
____________________________________________________________________________-->
    <title>带有排序规则的<acronym>SQL</acronym>函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>collation</primary>
     <secondary>in SQL functions</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>collation</primary>
     <secondary>in SQL functions</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     When a SQL function has one or more parameters of collatable data types,
     a collation is identified for each function call depending on the
     collations assigned to the actual arguments, as described in <xref
     linkend="collation"/>.  If a collation is successfully identified
     (i.e., there are no conflicts of implicit collations among the arguments)
     then all the collatable parameters are treated as having that collation
     implicitly.  This will affect the behavior of collation-sensitive
     operations within the function.  For example, using the
     <function>anyleast</function> function described above, the result of
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
     will depend on the database's default collation.  In <literal>C</literal> locale
     the result will be <literal>ABC</literal>, but in many other locales it will
     be <literal>abc</literal>.  The collation to use can be forced by adding
     a <literal>COLLATE</literal> clause to any of the arguments, for example
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
     Alternatively, if you wish a function to operate with a particular
     collation regardless of what it is called with, insert
     <literal>COLLATE</literal> clauses as needed in the function definition.
     This version of <function>anyleast</function> would always use <literal>en_US</literal>
     locale to compare strings:
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
     But note that this will throw an error if applied to a non-collatable
     data type.
    </para>
____________________________________________________________________________-->
    <para>
     当一个 SQL 函数具有一个或者更多可排序数据类型的参数时，按照
     <xref linkend="collation"/>中所述，对每一次函数调用都会根据分
     配给实参的排序规则为其确定一个排序规则。如果成功地确定（即在
     参数之间没有隐式排序规则的冲突），那么所有的可排序参数都被认
     为隐式地具有该排序规则。这将会影响函数中对排序敏感的操作的行
     为。例如，使用上述的<function>anyleast</function>函数时，
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
     的结果将依赖于数据库的默认排序规则。在<literal>C</literal>区域中，
     结果将是<literal>ABC</literal>，但是在很多其他区域中它将是
     <literal>abc</literal>。可以在任意参数上增加一个<literal>COLLATE</literal>
     子句来强制要使用的排序规则，例如：
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
     此外，如果你希望一个函数用一个特定的排序规则工作而不管用什么排序规则
     调用它，可根据需要在函数定义中插入<literal>COLLATE</literal>子句。
     这种版本的<function>anyleast</function>将总是使用<literal>en_US</literal>区域来比
     较字符串：
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
     但是注意如果应用到不可排序数据类型上，这将会抛出一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     If no common collation can be identified among the actual arguments,
     then a SQL function treats its parameters as having their data types'
     default collation (which is usually the database's default collation,
     but could be different for parameters of domain types).
    </para>
____________________________________________________________________________-->
    <para>
     如果在实参之间无法确定共同的排序规则，那么 SQL 函数会把它的参数
     当作拥有其数据类型的默认排序规则（通常是数据库的默认排序规则，
     但是域类型的参数可能会不同）。
    </para>

<!--==========================orignal english content==========================
    <para>
     The behavior of collatable parameters can be thought of as a limited
     form of polymorphism, applicable only to textual data types.
    </para>
____________________________________________________________________________-->
    <para>
     可排序参数的行为可以被想成是多态的一种受限形式，只对于文本数据
     类型有效。
    </para>
   </sect2>
  </sect1>

  <sect1 id="xfunc-overload">
<!--==========================orignal english content==========================
   <title>Function Overloading</title>
____________________________________________________________________________-->
   <title>函数重载</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-overload">
    <primary>overloading</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-overload">
    <primary>overloading</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    More than one function can be defined with the same SQL name, so long
    as the arguments they take are different.  In other words,
    function names can be <firstterm>overloaded</firstterm>.  Whether or not
    you use it, this capability entails security precautions when calling
    functions in databases where some users mistrust other users; see
    <xref linkend="typeconv-func"/>.  When a query is executed, the server
    will determine which function to call from the data types and the number
    of the provided arguments.  Overloading can also be used to simulate
    functions with a variable number of arguments, up to a finite maximum
    number.
   </para>
____________________________________________________________________________-->
   <para>
    可以用同样的 SQL 名称定义多于一个函数，只要它们的参数不同即可。
    换句话说，函数名可以被<firstterm>重载</firstterm>。不管你是否使用它，这种能力都要求在某些用户不信任其他用户的数据中调用函数时做一些预防措施，见<xref linkend="typeconv-func"/>。当一个查询
    被执行时，服务器将从数据类型和所提供的参数个数来决定要调用哪个
    函数。重载也可用来模拟具有可变参数个数（最大个数有限）的函数。
   </para>

<!--==========================orignal english content==========================
   <para>
    When creating a family of overloaded functions, one should be
    careful not to create ambiguities.  For instance, given the
    functions:
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
    it is not immediately clear which function would be called with
    some trivial input like <literal>test(1, 1.5)</literal>.  The
    currently implemented resolution rules are described in
    <xref linkend="typeconv"/>, but it is unwise to design a system that subtly
    relies on this behavior.
   </para>
____________________________________________________________________________-->
   <para>
    在创建一个重载函数家族时，应该小心不要创建歧义。例如，给定函数：
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
    对于<literal>test(1, 1.5)</literal>这样的输入就无法立刻清楚地知道
    应该调用哪个函数。当前实现的解决规则在<xref linkend="typeconv"/>
    中有描述，但是设计一个依赖于这种行为的系统是不明智的。
   </para>

<!--==========================orignal english content==========================
   <para>
    A function that takes a single argument of a composite type should
    generally not have the same name as any attribute (field) of that type.
    Recall that <literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>
    is considered equivalent
    to <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>.
    In the case that there is an
    ambiguity between a function on a composite type and an attribute of
    the composite type, the attribute will always be used.  It is possible
    to override that choice by schema-qualifying the function name
    (that is, <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)
    </literal>) but it's better to
    avoid the problem by not choosing conflicting names.
   </para>
____________________________________________________________________________-->
   <para>
    一个具有单个组合类型参数的函数通常不应与该类型的任何属性（域）
    重名。回想一下，<literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>被认为等效于
    <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>。在出现“一个组合类型
    上的函数”与“组合类型的一个属性”的情况下，将总是使用属性。
    可以通过用模式限定该函数名（即
    <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)
    </literal>）来覆盖这种选择，但是最好
    不要选择有冲突的名称以避免此类问题。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another possible conflict is between variadic and non-variadic functions.
    For instance, it is possible to create both <literal>foo(numeric)</literal> and
    <literal>foo(VARIADIC numeric[])</literal>.  In this case it is unclear which one
    should be matched to a call providing a single numeric argument, such as
    <literal>foo(10.1)</literal>.  The rule is that the function appearing
    earlier in the search path is used, or if the two functions are in the
    same schema, the non-variadic one is preferred.
   </para>
____________________________________________________________________________-->
   <para>
    另一种可能的冲突在于 variadic 和非 variadic 函数之间。例如，可以创建
    <literal>foo(numeric)</literal>和<literal>foo(VARIADIC numeric[])</literal>。
    在这种情况下，对于提供了一个数字参数的调用（例如<literal>foo(10.1)</literal>）
    就不清楚应该匹配哪一个函数。规则是使用在搜索路径中出现得较早的
    函数，或者当两者都在同一个模式中时优先使用非 variadic 的那一个函数。
   </para>

<!--==========================orignal english content==========================
   <para>
    When overloading C-language functions, there is an additional
    constraint: The C name of each function in the family of
    overloaded functions must be different from the C names of all
    other functions, either internal or dynamically loaded.  If this
    rule is violated, the behavior is not portable.  You might get a
    run-time linker error, or one of the functions will get called
    (usually the internal one).  The alternative form of the
    <literal>AS</literal> clause for the SQL <command>CREATE
    FUNCTION</command> command decouples the SQL function name from
    the function name in the C source code.  For instance:
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
    The names of the C functions here reflect one of many possible conventions.
   </para>
____________________________________________________________________________-->
   <para>
    在重载 C 语言函数时有一个额外的约束：重载函数家族中的每一个
    函数的 C 名称必须与其他所有函数的 C 名称不同，不管是内部的
    还是动态载入的。如果这条规则被违背，该行为将不可移植。你可能
    会得到一个运行时链接器错误，或者这些函数之一将被调用（通常
    是内部的那一个）。SQL <command>CREATE
    FUNCTION</command>命令的<literal>AS</literal>子句的另一种形式
    可以把 SQL 函数名和 C 源代码中的函数名分离。例如：
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
    这里的 C 函数名称反映了很多种可能的习惯之一。
   </para>
  </sect1>

  <sect1 id="xfunc-volatility">
<!--==========================orignal english content==========================
   <title>Function Volatility Categories</title>
____________________________________________________________________________-->
   <title>函数易变性分类</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-volatility">
    <primary>volatility</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>volatility</primary>
    <secondary>functions</secondary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Every function has a <firstterm>volatility</firstterm> classification, with
    the possibilities being <literal>VOLATILE</literal>, <literal>STABLE</literal>, or
    <literal>IMMUTABLE</literal>.  <literal>VOLATILE</literal> is the default if the
    <xref linkend="sql-createfunction"/>
    command does not specify a category.  The volatility category is a
    promise to the optimizer about the behavior of the function:

   <itemizedlist>
    <listitem>
     <para>
      A <literal>VOLATILE</literal> function can do anything, including modifying
      the database.  It can return different results on successive calls with
      the same arguments.  The optimizer makes no assumptions about the
      behavior of such functions.  A query using a volatile function will
      re-evaluate the function at every row where its value is needed.
     </para>
    </listitem>
    <listitem>
     <para>
      A <literal>STABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments
      for all rows within a single statement. This category allows the
      optimizer to optimize multiple calls of the function to a single
      call. In particular, it is safe to use an expression containing
      such a function in an index scan condition. (Since an index scan
      will evaluate the comparison value only once, not once at each
      row, it is not valid to use a <literal>VOLATILE</literal> function in an
      index scan condition.)
     </para>
    </listitem>
    <listitem>
     <para>
      An <literal>IMMUTABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments forever.
      This category allows the optimizer to pre-evaluate the function when
      a query calls it with constant arguments.  For example, a query like
      <literal>SELECT ... WHERE x = 2 + 2</literal> can be simplified on sight to
      <literal>SELECT ... WHERE x = 4</literal>, because the function underlying
      the integer addition operator is marked <literal>IMMUTABLE</literal>.
     </para>
    </listitem>
   </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    每一个函数都有一个<firstterm>易变性</firstterm>分类，可能是
    <literal>VOLATILE</literal>、<literal>STABLE</literal>或者<literal>IMMUTABLE</literal>。
    如果<xref linkend="sql-createfunction"/>命令没有指定一个分类，则默认是
    <literal>VOLATILE</literal>。易变性分类是给优化器的关于该函数行为的一种承诺：

   <itemizedlist>
    <listitem>
     <para>
      一个<literal>VOLATILE</literal>函数可以做任何事情，包括修改数据库。在
      使用相同的参数连续调用时，它能返回不同的结果。优化器不会对这类函
      数的行为做任何假定。在每一行需要 volatile 函数值时，一个使用 volatile
      函数的查询都会重新计算该函数。
     </para>
    </listitem>
    <listitem>
     <para>
      一个<literal>STABLE</literal>函数不能修改数据库并且被确保对一个语句中
      的所有行用给定的相同参数返回相同的结果。这种分类允许优化器把该函
      数的多个调用优化成一个调用。特别是，在一个索引扫描条件中使用包含
      这样一个函数的表达式是安全的（因为一次索引扫描只会计算一次比较值，
      而不是为每一行都计算一次，在一个索引扫描条件中不能使用
      <literal>VOLATILE</literal>函数）。
     </para>
    </listitem>
    <listitem>
     <para>
      一个<literal>IMMUTABLE</literal>函数不能修改数据库并且被确保用相同的参数
      永远返回相同的结果。这种分类允许优化器在一个查询用常量参数调用该函数
      时提前计算该函数。例如，一个
      <literal>SELECT ... WHERE x = 2 + 2</literal>这样的查询可以被简化为
      <literal>SELECT ... WHERE x = 4</literal>，因为整数加法操作符底层的函数被
      标记为<literal>IMMUTABLE</literal>。
     </para>
    </listitem>
   </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    For best optimization results, you should label your functions with the
    strictest volatility category that is valid for them.
   </para>
____________________________________________________________________________-->
   <para>
    为了最好的优化结果，你应该把函数标记为对它们合法的易变性分类中最严格
    的那种。
   </para>

<!--==========================orignal english content==========================
   <para>
    Any function with side-effects <emphasis>must</emphasis> be labeled
    <literal>VOLATILE</literal>, so that calls to it cannot be optimized away.
    Even a function with no side-effects needs to be labeled
    <literal>VOLATILE</literal> if its value can change within a single query;
    some examples are <literal>random()</literal>, <literal>currval()</literal>,
    <literal>timeofday()</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    任何带有副作用的函数<emphasis>必须</emphasis>被标记为<literal>VOLATILE</literal>，
    这样对它的调用就不能被优化掉。甚至如果一个函数的值在一个查询中会
    变化，即使它没有副作用也需要被标记为<literal>VOLATILE</literal>。这样的
    例子有<literal>random()</literal>、<literal>currval()</literal>、
    <literal>timeofday()</literal>等。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another important example is that the <function>current_timestamp</function>
    family of functions qualify as <literal>STABLE</literal>, since their values do
    not change within a transaction.
   </para>
____________________________________________________________________________-->
   <para>
    另一种重要的例子是<function>current_timestamp</function>家族的函数有资格
    被标记为<literal>STABLE</literal>，因为它们的值在一个事务中不会改变。
   </para>

<!--==========================orignal english content==========================
   <para>
    There is relatively little difference between <literal>STABLE</literal> and
    <literal>IMMUTABLE</literal> categories when considering simple interactive
    queries that are planned and immediately executed: it doesn't matter
    a lot whether a function is executed once during planning or once during
    query execution startup.  But there is a big difference if the plan is
    saved and reused later.  Labeling a function <literal>IMMUTABLE</literal> when
    it really isn't might allow it to be prematurely folded to a constant during
    planning, resulting in a stale value being re-used during subsequent uses
    of the plan.  This is a hazard when using prepared statements or when
    using function languages that cache plans (such as
    <application>PL/pgSQL</application>).
   </para>
____________________________________________________________________________-->
   <para>
    在考虑先规划然后立即执行的简单交互式查询时，在<literal>STABLE</literal>和
    <literal>IMMUTABLE</literal>分类间的区别相对较小：一个函数是在规划时只
    执行一次还是在查询执行开始期间只执行一次没有太大关系。但是如果计划
    被保存下来然后在后面被重用，区别就大了。如果在不允许过早把一个函数
    变成规划期间的一个常数时把它标记为<literal>IMMUTABLE</literal>，会导致
    在后续重用该计划时用到一个陈旧的值。当使用预备语句或者使用会缓存计
    划的函数语言（<application>PL/pgSQL</application>）时，这就会是一种灾难。
   </para>

<!--==========================orignal english content==========================
   <para>
    For functions written in SQL or in any of the standard procedural
    languages, there is a second important property determined by the
    volatility category, namely the visibility of any data changes that have
    been made by the SQL command that is calling the function.  A
    <literal>VOLATILE</literal> function will see such changes, a <literal>STABLE</literal>
    or <literal>IMMUTABLE</literal> function will not.  This behavior is implemented
    using the snapshotting behavior of MVCC (see <xref linkend="mvcc"/>):
    <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions use a snapshot
    established as of the start of the calling query, whereas
    <literal>VOLATILE</literal> functions obtain a fresh snapshot at the start of
    each query they execute.
   </para>
____________________________________________________________________________-->
   <para>
    对于用 SQL 或者其他任何标准过程语言编写的函数，还有第二种由易变性分类
    决定的特性，即由调用该函数的 SQL 命令所作的数据修改的可见性。
    <literal>VOLATILE</literal>函数将看到这些更改，<literal>STABLE</literal>
    或者<literal>IMMUTABLE</literal>函数则看不到。这种行为使用 MVCC 的快照
    行为（见<xref linkend="mvcc"/>）实现：<literal>STABLE</literal>和
    <literal>IMMUTABLE</literal>函数使用一个在调用查询开始时建立的快照，而
    <literal>VOLATILE</literal>函数在它们执行的每一个查询的开始都获得一个新鲜
    的快照。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Functions written in C can manage snapshots however they want, but it's
     usually a good idea to make C functions work this way too.
    </para>
____________________________________________________________________________-->
    <para>
     用 C 编写的函数按照它们自己需要的方式管理快照，但是通常最好
     让 C 函数也按照上面的方式来。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Because of this snapshotting behavior,
    a function containing only <command>SELECT</command> commands can safely be
    marked <literal>STABLE</literal>, even if it selects from tables that might be
    undergoing modifications by concurrent queries.
    <productname>PostgreSQL</productname> will execute all commands of a
    <literal>STABLE</literal> function using the snapshot established for the
    calling query, and so it will see a fixed view of the database throughout
    that query.
   </para>
____________________________________________________________________________-->
   <para>
    由于这种快照行为，一个只包含<command>SELECT</command>命令的函数可以被
    安全地标记为<literal>STABLE</literal>，即便它选择的表可能正在被并发查询所
    修改。<productname>PostgreSQL</productname>将使用为调用查询所
    建立的快照来执行<literal>STABLE</literal>函数中的所有命令，因此它将在整个
    查询期间看到一种数据库的固定视图。
   </para>

<!--==========================orignal english content==========================
   <para>
    The same snapshotting behavior is used for <command>SELECT</command> commands
    within <literal>IMMUTABLE</literal> functions.  It is generally unwise to select
    from database tables within an <literal>IMMUTABLE</literal> function at all,
    since the immutability will be broken if the table contents ever change.
    However, <productname>PostgreSQL</productname> does not enforce that you
    do not do that.
   </para>
____________________________________________________________________________-->
   <para>
    对<literal>IMMUTABLE</literal>函数中的<command>SELECT</command>使用了相同
    的快照行为。通常在一个<literal>IMMUTABLE</literal>函数中从数据库表选择是
    不明智的，因为如果表内容变化就会破坏不变性。不过，
    <productname>PostgreSQL</productname>不会强制不让你这样做。
   </para>

<!--==========================orignal english content==========================
   <para>
    A common error is to label a function <literal>IMMUTABLE</literal> when its
    results depend on a configuration parameter.  For example, a function
    that manipulates timestamps might well have results that depend on the
    <xref linkend="guc-timezone"/> setting.  For safety, such functions should
    be labeled <literal>STABLE</literal> instead.
   </para>
____________________________________________________________________________-->
   <para>
    一种常见的错误是当一个函数的结果依赖于一个配置参数时把它标记为
    <literal>IMMUTABLE</literal>。例如，一个操纵时间戳的函数有可能结果
    依赖于<xref linkend="guc-timezone"/>设置。为了安全起见，这类
    函数应该被标记为<literal>STABLE</literal>。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> requires that <literal>STABLE</literal>
     and <literal>IMMUTABLE</literal> functions contain no SQL commands other
     than <command>SELECT</command> to prevent data modification.
     (This is not a completely bulletproof test, since such functions could
     still call <literal>VOLATILE</literal> functions that modify the database.
     If you do that, you will find that the <literal>STABLE</literal> or
     <literal>IMMUTABLE</literal> function does not notice the database changes
     applied by the called function, since they are hidden from its snapshot.)
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>要求<literal>STABLE</literal>
     和<literal>IMMUTABLE</literal>函数中不包含非<command>SELECT</command>
     的 SQL 命令以阻止数据修改（这也不是完全万无一失，因为这类函数还可以
     调用修改数据库的<literal>VOLATILE</literal>函数。如果那样做，你将发现
     该<literal>STABLE</literal>或<literal>IMMUTABLE</literal>函数不会发现由被调
     用函数所作的数据库改变，因为它们对它的快照不可见）。
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-pl">
<!--==========================orignal english content==========================
   <title>Procedural Language Functions</title>
____________________________________________________________________________-->
   <title>过程语言函数</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows user-defined functions
    to be written in other languages besides SQL and C.  These other
    languages are generically called <firstterm>procedural
    languages</firstterm> (<acronym>PL</acronym>s).
    Procedural languages aren't built into the
    <productname>PostgreSQL</productname> server; they are offered
    by loadable modules.
    See <xref linkend="xplang"/> and following chapters for more
    information.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许用除 SQL 和 C 之外
    的语言编写用户定义的函数。这些语言通常被称为<firstterm>过程语言</firstterm>（<acronym>PL</acronym>）。
    过程语言并不内建在<productname>PostgreSQL</productname>服务器中，
    它们通过可装载模块提供。更多信息请见<xref linkend="xplang"/>以及接下来的
    章节。
   </para>
  </sect1>

  <sect1 id="xfunc-internal">
<!--==========================orignal english content==========================
   <title>Internal Functions</title>
____________________________________________________________________________-->
   <title>内部函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>

<!--==========================orignal english content==========================
   <para>
    Internal functions are functions written in C that have been statically
    linked into the <productname>PostgreSQL</productname> server.
    The <quote>body</quote> of the function definition
    specifies the C-language name of the function, which need not be the
    same as the name being declared for SQL use.
    (For reasons of backward compatibility, an empty body
    is accepted as meaning that the C-language function name is the
    same as the SQL name.)
   </para>
____________________________________________________________________________-->
   <para>
    内部函数由 C 编写并且已经被静态链接到<productname>PostgreSQL</productname>
    服务器中。该函数定义的<quote>主体</quote>指定该函数的 C 语言名称，
    它必须和声明 SQL 函数所用的名称一样（为了向后兼容性的原因，也接受空
    主体，那时会认为 C 语言函数名与 SQL 函数名相同）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Normally, all internal functions present in the
    server are declared during the initialization of the database cluster
    (see <xref linkend="creating-cluster"/>),
    but a user could use <command>CREATE FUNCTION</command>
    to create additional alias names for an internal function.
    Internal functions are declared in <command>CREATE FUNCTION</command>
    with language name <literal>internal</literal>.  For instance, to
    create an alias for the <function>sqrt</function> function:
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
    (Most internal functions expect to be declared <quote>strict</quote>.)
   </para>
____________________________________________________________________________-->
   <para>
    通常，所有存在于服务器中的内部函数都在数据库集簇的初始化（见
    <xref linkend="creating-cluster"/>）期间被声明，但是用户可以使用
    <command>CREATE FUNCTION</command>为一个内部函数创建
    额外的别名。在<command>CREATE FUNCTION</command>中用
    语言名<literal>internal</literal>来声明内部函数。例如，要为
    <function>sqrt</function>函数创建一个别名：
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
    （大部分内部函数应该被声明为<quote>严格</quote>）。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Not all <quote>predefined</quote> functions are
     <quote>internal</quote> in the above sense.  Some predefined
     functions are written in SQL.
    </para>
____________________________________________________________________________-->
    <para>
     上述场景中并非所有<quote>预定义</quote>的函数都是
     <quote>内部</quote>函数。有些预定义的函数由 SQL
     编写。
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-c">
<!--==========================orignal english content==========================
   <title>C-Language Functions</title>
____________________________________________________________________________-->
   <title>C 语言函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <quote>C language</quote> functions
    from <quote>internal</quote> functions &mdash; the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
   </para>
____________________________________________________________________________-->
   <para>
    用户定义的函数可以用 C 编写（或者可以与 C 兼容的语言，例如 C++）。
    这类函数被编译成动态载入对象（也被称为共享库）并且由服务器在
    需要时载入。动态载入是把<quote>C语言</quote>函数和
    <quote>内部</quote>函数区分开的特性 &mdash; 两者真正的编码习惯
    实际上是一样的（因此，标准的内部函数库是用户定义的 C 函数很好
    的源代码实例）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Currently only one calling convention is used for C functions
    (<quote>version 1</quote>). Support for that calling convention is
    indicated by writing a <literal>PG_FUNCTION_INFO_V1()</literal> macro
    call for the function, as illustrated below.
   </para>
____________________________________________________________________________-->
   <para>
    当前仅有一种调用约定被用于C函数（<quote>版本1</quote>）。如下文所示，为函数编写一个<literal>PG_FUNCTION_INFO_V1()</literal>宏就能指示对该调用约定的支持。
   </para>

  <sect2 id="xfunc-c-dynload">
<!--==========================orignal english content==========================
   <title>Dynamic Loading</title>
____________________________________________________________________________-->
   <title>动态载入</title>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>dynamic loading</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>动态载入</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The first time a user-defined function in a particular
    loadable object file is called in a session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <command>CREATE FUNCTION</command>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
   </para>
____________________________________________________________________________-->
   <para>
    在一个会话中第一次调用一个特定可载入对象文件中的用户定义函数时，
    动态载入器会把那个对象文件载入到内存以便该函数被调用。因此用户
    定义的 C 函数的<command>CREATE FUNCTION</command>必须
    为该函数指定两块信息：可载入对象文件的名称，以及要在该对象文件中
    调用的特定函数的 C 名称（链接符号）。如果没有显式指定 C 名称，则
    它被假定为和 SQL 函数名相同。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following algorithm is used to locate the shared object file
    based on the name given in the <command>CREATE FUNCTION</command>
    command:

    <orderedlist>
     <listitem>
      <para>
       If the name is an absolute path, the given file is loaded.
      </para>
     </listitem>

     <listitem>
      <para>
       If the name starts with the string <literal>$libdir</literal>,
       that part is replaced by the <productname>PostgreSQL</productname> package
        library directory
       name, which is determined at build time.<indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <xref linkend="guc-dynamic-library-path"/>.<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
      </para>
     </listitem>
    </orderedlist>

    If this sequence does not work, the platform-specific shared
    library file name extension (often <filename>.so</filename>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
   </para>
____________________________________________________________________________-->
   <para>
    下面的算法被用来基于<command>CREATE FUNCTION</command>
    命令中给定的名称来定位共享对象文件：

    <orderedlist>
     <listitem>
      <para>
       如果名称是一个绝对路径，则载入给定的文件。
      </para>
     </listitem>

     <listitem>
      <para>
       如果该名称以字符串<literal>$libdir</literal>开始，那么这一部分会被
       <productname>PostgreSQL</productname>包的库目录名（在编译时确定）替换。
       <indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       如果该名称不包含目录部分，会在配置变量
       <xref linkend="guc-dynamic-library-path"/>指定的路径中搜索该
       文件。<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       否则（在该路径中没找到该文件，或者它包含一个非绝对目录），
       动态载入器将尝试接受给定的名称，这大部分会导致失败（依赖
       当前工作目录是不可靠的）。
      </para>
     </listitem>
    </orderedlist>

    如果这个序列不起作用，会把平台相关的共享库文件名扩展（通常是
    <filename>.so</filename>）追加到给定的名称并且再次尝试上述
    的过程。如果还是失败，则载入失败。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is recommended to locate shared libraries either relative to
    <literal>$libdir</literal> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <literal>$libdir</literal> stands for can be found out with the
    command <literal>pg_config -&minus;pkglibdir</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    我们推荐相对于<literal>$libdir</literal>或者通过动态库路径来
    定位共享库。如果升级版本时新的安装在一个不同的位置，则可以
    简化升级过程。<literal>$libdir</literal>实际表示的目录可以用
    命令<literal>pg_config --pkglibdir</literal>来找到。
   </para>

<!--==========================orignal english content==========================
   <para>
    The user ID the <productname>PostgreSQL</productname> server runs
    as must be able to traverse the path to the file you intend to
    load.  Making the file or a higher-level directory not readable
    and/or not executable by the <systemitem>postgres</systemitem>
    user is a common mistake.
   </para>
____________________________________________________________________________-->
   <para>
    用于运行<productname>PostgreSQL</productname>服务器的
    用户 ID 必须能够通过要载入文件的路径。常见的错误是把文件或
    更高层的目录变得对<systemitem>postgres</systemitem>用户
    不可读或者不可执行。
   </para>

<!--==========================orignal english content==========================
   <para>
    In any case, the file name that is given in the
    <command>CREATE FUNCTION</command> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
   </para>
____________________________________________________________________________-->
   <para>
    在任何情况下，<command>CREATE FUNCTION</command>命令
    中给定的文件名会被原封不动地记录在系统目录中，这样如果需要再次
    载入该文件则会应用同样的过程。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <command>CREATE
     FUNCTION</command> command.  See <xref linkend="dfunc"/> for additional
     information.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不会自动编译 C 函数。在
     从<command>CREATE FUNCTION</command>命令中引用对象文件
     之前，它必须先被编译好。更多信息请见<xref linkend="dfunc"/>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>magic block</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>magic block</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To ensure that a dynamically loaded object file is not loaded into an
    incompatible server, <productname>PostgreSQL</productname> checks that the
    file contains a <quote>magic block</quote> with the appropriate contents.
    This allows the server to detect obvious incompatibilities, such as code
    compiled for a different major version of
    <productname>PostgreSQL</productname>. To include a magic block,
    write this in one (and only one) of the module source files, after having
    included the header <filename>fmgr.h</filename>:

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    为了确保动态载入对象文件不会被载入到一个不兼容的服务器，
    <productname>PostgreSQL</productname>会检查该文件是否包含一个
    带有合适内容的<quote>magic block</quote>。这允许服务器检测到明显的不兼
    容，例如为不同<productname>PostgreSQL</productname>主版本编译
    的代码。要包括一个 magic block，在写上包括
    头文件<filename>fmgr.h</filename>的语句之后，在该模块的源文件之一（并且只
    能在其中一个）中写上这些：

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    After it is used for the first time, a dynamically loaded object
    file is retained in memory.  Future calls in the same session to
    the function(s) in that file will only incur the small overhead of
    a symbol table lookup.  If you need to force a reload of an object
    file, for example after recompiling it, begin a fresh session.
   </para>
____________________________________________________________________________-->
   <para>
    在被第一次使用后，动态载入对象文件会留在内存中。在同一个会话中
    对该函数未来的调用将只会消耗很小的负荷进行符号表查找。如果需要
    重新载入一个对象文件（例如重新编译以后），需要开始一个新的会话。
   </para>

<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_fini</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_fini</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>library initialization function</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>库初始化函数</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="xfunc-c-dynload">
    <primary>library finalization function</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>库初始化函数</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Optionally, a dynamically loaded file can contain initialization and
    finalization functions.  If the file includes a function named
    <function>_PG_init</function>, that function will be called immediately after
    loading the file.  The function receives no parameters and should
    return void.  If the file includes a function named
    <function>_PG_fini</function>, that function will be called immediately before
    unloading the file.  Likewise, the function receives no parameters and
    should return void.  Note that <function>_PG_fini</function> will only be called
    during an unload of the file, not during process termination.
    (Presently, unloads are disabled and will never occur, but this may
    change in the future.)
   </para>
____________________________________________________________________________-->
   <para>
    可以选择让一个动态载入文件包含初始化和终止化函数。如果文件包含一个
    名为<function>_PG_init</function>的函数，则文件被载入后会立刻调用该函数。
    该函数不接受参数并且应该返回 void。如果文件包括一个名为
    <function>_PG_fini</function>的函数，则在卸载该文件之前会立即调用该函数。
    同样地，该函数不接受参数并且应该返回 void。注意将只在卸载文件的过程
    中会调用<function>_PG_fini</function>，进程结束时不会调用它（当前，卸载被
    禁用并且从不发生，但是未来可能会改变）。
   </para>

  </sect2>

   <sect2 id="xfunc-c-basetype">
<!--==========================orignal english content==========================
    <title>Base Types in C-Language Functions</title>
____________________________________________________________________________-->
    <title>C 语言函数中的基本类型</title>

<!--==========================orignal english content==========================
    <indexterm zone="xfunc-c-basetype">
     <primary>data type</primary>
     <secondary>internal organization</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="xfunc-c-basetype">
     <primary>数据类型</primary>
     <secondary>内部组织</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     To know how to write C-language functions, you need to know how
     <productname>PostgreSQL</productname> internally represents base
     data types and how they can be passed to and from functions.
     Internally, <productname>PostgreSQL</productname> regards a base
     type as a <quote>blob of memory</quote>.  The user-defined
     functions that you define over a type in turn define the way that
     <productname>PostgreSQL</productname> can operate on it.  That
     is, <productname>PostgreSQL</productname> will only store and
     retrieve the data from disk and use your user-defined functions
     to input, process, and output the data.
    </para>
____________________________________________________________________________-->
    <para>
     要了解如何编写 C 语言函数，你需要了解
     <productname>PostgreSQL</productname>如何在内部表达基本数据类型
     以及如何与函数传递它们。在内部，
     <productname>PostgreSQL</productname>把一个基本类型认为是
     <quote>一团内存</quote>。在类型上定义的用户定义函数说明了
     <productname>PostgreSQL</productname>在该类型上操作的方式。也就
     是说，<productname>PostgreSQL</productname>将只负责把数据存在磁盘以
     及从磁盘检索数据，而使用你的用户定义函数来输入、处理和输出该数据。
    </para>

<!--==========================orignal english content==========================
    <para>
     Base types can have one of three internal formats:

     <itemizedlist>
      <listitem>
       <para>
        pass by value, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, variable-length
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     基本类型可以有三种内部格式之一：

     <itemizedlist>
      <listitem>
       <para>
        传值，定长
       </para>
      </listitem>
      <listitem>
       <para>
        传引用，定长
       </para>
      </listitem>
      <listitem>
       <para>
        串引用，变长
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     By-value  types  can  only be 1, 2, or 4 bytes in length
     (also 8 bytes, if <literal>sizeof(Datum)</literal> is 8 on your machine).
     You should be careful to define your types such that they will be the
     same size (in bytes) on all architectures.  For example, the
     <literal>long</literal> type is dangerous because it is 4 bytes on some
     machines and 8 bytes on others, whereas <type>int</type> type is 4 bytes
     on most Unix machines.  A reasonable implementation of the
     <type>int4</type> type on Unix machines might be:

<programlisting>
/* 4-byte integer, passed by value */
typedef int int4;
</programlisting>

     (The actual PostgreSQL C code calls this type <type>int32</type>, because
     it is a convention in C that <type>int<replaceable>XX</replaceable></type>
     means <replaceable>XX</replaceable> <emphasis>bits</emphasis>.  Note
     therefore also that the C type <type>int8</type> is 1 byte in size.  The
     SQL type <type>int8</type> is called <type>int64</type> in C.  See also
     <xref linkend="xfunc-c-type-table"/>.)
    </para>
____________________________________________________________________________-->
    <para>
     传值类型在长度上只能是 1、2 或 4 字节（如果你的机器上
     <literal>sizeof(Datum)</literal>是 8，则还有 8 字节）。你应当小心地
     定义你的类型以便它们在所有的架构上都是相同的尺寸（字节）。例如，
     <literal>long</literal>类型很危险，因为它在某些机器上是 4 字节但在
     另外一些机器上是 8 字节，而<type>int</type>类型在大部分 Unix 机器
     上都是 4 字节。在 Unix 机器上<type>int4</type>类型一种合理的实现
     可能是：

<programlisting>
/* 4 字节整数，传值 */
typedef int int4;
</programlisting>

     （实际的 PostgreSQL C 代码会把这种类型称为<type>int32</type>，因为
     C 中的习惯是<type>int<replaceable>XX</replaceable></type>
     表示<replaceable>XX</replaceable> <emphasis>位</emphasis>。注意
     因此还有尺寸为 1 字节的 C 类型<type>int8</type>。SQL 类型
     <type>int8</type>在 C 中被称为<type>int64</type>。另见
     <xref linkend="xfunc-c-type-table"/>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     On  the  other hand, fixed-length types of any size can
     be passed by-reference.  For example, here is a  sample
     implementation of a <productname>PostgreSQL</productname> type:

<programlisting>
/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     Only  pointers  to  such types can be used when passing
     them in and out of <productname>PostgreSQL</productname> functions.
     To return a value of such a type, allocate the right amount of
     memory with <literal>palloc</literal>, fill in the allocated memory,
     and return a pointer to it.  (Also, if you just want to return the
     same value as one of your input arguments that's of the same data type,
     you can skip the extra <literal>palloc</literal> and just return the
     pointer to the input value.)
    </para>
____________________________________________________________________________-->
    <para>
     在另一方面，任何尺寸的定长类型可以用传引用的方法传递。例如，这里有一种
     <productname>PostgreSQL</productname>类型的实现示例：

<programlisting>
/* 16 字节结构，传引用 */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     在<productname>PostgreSQL</productname>函数中传进或传出这种
     类型时，只能使用指向这种类型的指针。要返回这样一种类型的值，用
     <literal>palloc</literal>分配正确的内存量，然后填充分配好的内存，
     并且返回一个指向该内存的指针（还有，如果只想返回与具有相同数据类型的
     一个输入参数相同的值，可以跳过额外的<literal>palloc</literal>并且返回
     指向该输入值的指针）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with an opaque length field of exactly 4 bytes, which will be set
     by <symbol>SET_VARSIZE</symbol>; never set this field directly! All data to
     be  stored within that type must be located in the memory
     immediately  following  that  length  field.   The
     length field contains the total length of the structure,
     that is,  it  includes  the  size  of  the  length  field
     itself.
    </para>
____________________________________________________________________________-->
    <para>
     最后，所有变长类型必须也以引用的方式传递。所有变长类型必须用一个
     正好 4 字节的不透明长度域开始，该域会由<symbol>SET_VARSIZE</symbol>
     设置，绝不要直接设置该域！所有要被存储在该类型中的数据必须在内存
     中接着该长度域的后面存储。长度域包含该结构的总长度，也就是包括长
     度域本身的尺寸。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another important point is to avoid leaving any uninitialized bits
     within data type values; for example, take care to zero out any
     alignment padding bytes that might be present in structs.  Without
     this, logically-equivalent constants of your data type might be
     seen as unequal by the planner, leading to inefficient (though not
     incorrect) plans.
    </para>
____________________________________________________________________________-->
    <para>
     另一个重点是要避免在数据类型值中留下未被初始化的位。例如，要注意
     把可能存在于结构中的任何对齐填充字节置零。如果不这样做，你的数据
     类型的逻辑等价常量可能会被规划器认为是不等的，进而导致低效的（不过
     还是正确的）计划。
    </para>

    <warning>
<!--==========================orignal english content==========================
     <para>
      <emphasis>Never</emphasis> modify the contents of a pass-by-reference input
      value.  If you do so you are likely to corrupt on-disk data, since
      the pointer you are given might point directly into a disk buffer.
      The sole exception to this rule is explained in
      <xref linkend="xaggr"/>.
     </para>
____________________________________________________________________________-->
     <para>
      <emphasis>绝不要</emphasis>修改通过引用传递的输入值的内容。如果这样做
      很可能会破坏磁盘上的数据，因为给出的指针可能直接指向一个磁盘缓冲
      区。这条规则唯一的例外在<xref linkend="xaggr"/>中有解释。
     </para>
    </warning>

<!--==========================orignal english content==========================
    <para>
     As an example, we can define the type <type>text</type> as
     follows:

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

     The <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> notation means that the actual
     length of the data part is not specified by this declaration.
    </para>
____________________________________________________________________________-->
    <para>
     例如，我们可以这样定义类型<type>text</type>：

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

     <literal>[FLEXIBLE_ARRAY_MEMBER]</literal>记号表示数据部分的实际
     长度不由该声明指定。
    </para>

<!--==========================orignal english content==========================
    <para>
     When manipulating
     variable-length types, we must  be  careful  to  allocate
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a <structname>text</structname>
     structure, we might use a code fragment like this:

<programlisting><![CDATA[
#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

     <literal>VARHDRSZ</literal> is the same as <literal>sizeof(int32)</literal>, but
     it's considered good style to use the macro <literal>VARHDRSZ</literal>
     to refer to the size of the overhead for a variable-length type.
     Also, the length field <emphasis>must</emphasis> be set using the
     <literal>SET_VARSIZE</literal> macro, not by simple assignment.
    </para>
____________________________________________________________________________-->
    <para>
     在操纵变长字节时，我们必须小心地分配正确数量的内存并且正确地
     设置长度域。例如，如果我们想在一个<structname>text</structname>结构
     中存储 40 字节，我们可以使用这样的代码片段：

<programlisting><![CDATA[
#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

     <literal>VARHDRSZ</literal>和<literal>sizeof(int32)</literal>一样，
     但是用宏<literal>VARHDRSZ</literal>来引用变长类型的载荷的
     尺寸被认为是比较好的风格。还有，<emphasis>必须</emphasis>
     使用<literal>SET_VARSIZE</literal>宏来设置长度域，而不是用
     简单的赋值来设置。
    </para>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="xfunc-c-type-table"/> specifies which C type
     corresponds to which SQL type when writing a C-language function
     that uses a built-in type of <productname>PostgreSQL</productname>.
     The <quote>Defined In</quote> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition might be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <filename>postgres.h</filename> first in any source file, because
     it declares a number of things that you will need anyway.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="xfunc-c-type-table"/>指定在编写使用一种
     <productname>PostgreSQL</productname>内建类型的 C 语言函数时，
     哪一种 C 类型对应于哪一种 SQL 类型。
     <quote>定义文件</quote>列给出了要得到该类型定义需要
     包括的头文件（实际的定义可能在一个由列举文件包括的不同
     文件中。推荐用户坚持使用已定义的接口）。注意在任何源文
     件中应该总是首先包括<filename>postgres.h</filename>，
     因为它声明了很多你需要的东西。
    </para>

     <table tocentry="1" id="xfunc-c-type-table">
<!--==========================orignal english content==========================
      <title>Equivalent C Types for Built-in SQL Types</title>
____________________________________________________________________________-->
      <title>内建 SQL 类型等效的 C 类型</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>
          SQL Type
         </entry>
         <entry>
          C Type
         </entry>
         <entry>
          Defined In
         </entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>
          SQL 类型
         </entry>
         <entry>
          C 类型
         </entry>
         <entry>
          定义文件
         </entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
         <entry><filename>postgres.h</filename> (maybe compiler built-in)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
         <entry><filename>postgres.h</filename>（可能是编译器内建）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>box</type></entry>
         <entry><type>BOX*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>box</type></entry>
         <entry><type>BOX*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>bytea</type></entry>
         <entry><type>bytea*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>bytea</type></entry>
         <entry><type>bytea*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
         <entry>(compiler built-in)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
         <entry>（编译器内建）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>character</type></entry>
         <entry><type>BpChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>character</type></entry>
         <entry><type>BpChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>cid</type></entry>
         <entry><type>CommandId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>cid</type></entry>
         <entry><type>CommandId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>date</type></entry>
         <entry><type>DateADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>date</type></entry>
         <entry><type>DateADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>smallint</type> (<type>int2</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>smallint</type> (<type>int2</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>int2vector</type></entry>
         <entry><type>int2vector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>int2vector</type></entry>
         <entry><type>int2vector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>integer</type> (<type>int4</type>)</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>integer</type> (<type>int4</type>)</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>real</type> (<type>float4</type>)</entry>
         <entry><type>float4*</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>real</type> (<type>float4</type>)</entry>
         <entry><type>float4*</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>double precision</type> (<type>float8</type>)</entry>
         <entry><type>float8*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>double precision</type> (<type>float8</type>)</entry>
         <entry><type>float8*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>interval</type></entry>
         <entry><type>Interval*</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>interval</type></entry>
         <entry><type>Interval*</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>lseg</type></entry>
         <entry><type>LSEG*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>lseg</type></entry>
         <entry><type>LSEG*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>name</type></entry>
         <entry><type>Name</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>name</type></entry>
         <entry><type>Name</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>oid</type></entry>
         <entry><type>Oid</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>oid</type></entry>
         <entry><type>oid</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>oidvector</type></entry>
         <entry><type>oidvector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>oidvector</type></entry>
         <entry><type>oidvector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>path</type></entry>
         <entry><type>PATH*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>path</type></entry>
         <entry><type>PATH*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>point</type></entry>
         <entry><type>POINT*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>point</type></entry>
         <entry><type>POINT*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>regproc</type></entry>
         <entry><type>regproc</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>regproc</type></entry>
         <entry><type>regproc</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>text</type></entry>
         <entry><type>text*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>text</type></entry>
         <entry><type>text*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>tid</type></entry>
         <entry><type>ItemPointer</type></entry>
         <entry><filename>storage/itemptr.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>tid</type></entry>
         <entry><type>ItemPointer</type></entry>
         <entry><filename>storage/itemptr.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>time</type></entry>
         <entry><type>TimeADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>time</type></entry>
         <entry><type>TimeADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>time with time zone</type></entry>
         <entry><type>TimeTzADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>time with time zone</type></entry>
         <entry><type>TimeTzADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>timestamp</type></entry>
         <entry><type>Timestamp</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>timestamp</type></entry>
         <entry><type>Timestamp</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>varchar</type></entry>
         <entry><type>VarChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>varchar</type></entry>
         <entry><type>VarChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><type>xid</type></entry>
         <entry><type>TransactionId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>xid</type></entry>
         <entry><type>TransactionId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
    <para>
     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
    </para>
____________________________________________________________________________-->
    <para>
     现在我们已经复习了基本类型所有可能的结构，现在可以展示一些
     真实函数的例子了。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Version 1 Calling Conventions</title>
____________________________________________________________________________-->
    <title>版本 1 的调用约定</title>

<!--==========================orignal english content==========================
    <para>
     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always:
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
     In addition, the macro call:
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     must appear in the same source file.  (Conventionally, it's
     written just before the function itself.)  This macro call is not
     needed for <literal>internal</literal>-language functions, since
     <productname>PostgreSQL</productname> assumes that all internal functions
     use the version-1 convention.  It is, however, required for
     dynamically-loaded functions.
    </para>
____________________________________________________________________________-->
    <para>
     版本-1 的调用规范依赖于宏来降低传参数和结果的复杂度。版本-1 函数的
     C 声明总是：
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
     此外，宏调用：
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     必须出现在同一个源文件中（按惯例会正好写在该函数本身之前）。
     这种宏调用不是<literal>internal</literal>语言函数所需要的，因为
     <productname>PostgreSQL</productname>会假定所有内部函数都使用
     版本-1 规范。不过，对于动态载入函数是必需的。
    </para>

<!--==========================orignal english content==========================
    <para>
     In a version-1 function, each actual argument is fetched using a
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macro that corresponds to the argument's data type.  (In non-strict
     functions there needs to be a previous check about argument null-ness
     using <function>PG_ARGISNULL()</function>; see below.)
     The result is returned using a
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     macro for the return type.
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     takes as its argument the number of the function argument to
     fetch, where the count starts at 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     takes as its argument the actual value to return.
    </para>
____________________________________________________________________________-->
    <para>
     在版本-1 函数中，每一个实参都使用对应于该参数数据类型的<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏取得。（在非严格的函数中，需要使用<function>PG_ARGISNULL()</function>对参数是否为空提前做检查；见下文。）结果要用对应于返回类型的<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>宏返回。<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>的参数是要取得的函数参数的编号，从零开始计。<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>的参数是实际要返回的值。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are some examples using the version-1 calling convention:
    </para>
____________________________________________________________________________-->
    <para>
     这里是一些使用版本-1调用约定的例子：
    </para>

<!--==========================orignal english content==========================
<programlisting><![CDATA[
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

/* by value */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* by reference, fixed length */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* The macros for FLOAT8 hide its pass-by-reference nature. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Here, the pass-by-reference nature of Point is not hidden. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

/* by reference, variable length */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
     * VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
     * VARHDRSZ or VARHDRSZ_SHORT of its header.  Construct the copy with a
     * full-length header.
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATA is a pointer to the data region of the new struct.  The source
     * could be a short datum, so retrieve its data through VARDATA_ANY.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA_ANY(t), /* source */
           VARSIZE_ANY_EXHDR(t));   /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting><![CDATA[
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

/* 传值 */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* 传引用，定长 */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* FLOAT8 的宏隐藏了它的传引用本质。 */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* 这里，Point 的传引用本质没有被掩盖。 */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

/* 传引用，变长 */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
     * VARSIZE_ANY_EXHDR是该结构的尺寸（以字节为单位）减去其头部的
     * VARHDRSZ或VARHDRSZ_SHORT。用一个完整长度的头部构建该拷贝。
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATA是指向新结构的数据区域的指针。来源可以是一个短数据，
     * 所以要通过VARDATA_ANY检索它的数据。
     */
    memcpy((void *) VARDATA(new_t), /* 目标 */
           (void *) VARDATA_ANY(t), /* 源头 */
           VARSIZE_ANY_EXHDR(t));   /* 多少字节 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]>
</programlisting>

<!--==========================orignal english content==========================
    <para>
     Supposing that the above code has been prepared in file
     <filename>funcs.c</filename> and compiled into a shared object,
     we could define the functions to <productname>PostgreSQL</productname>
     with commands like this:
    </para>
____________________________________________________________________________-->
    <para>
     假定上述代码已经准备在文件<filename>funcs.c</filename>中并且被编译成一个共享对象，我们可以用这样的命令在<productname>PostgreSQL</productname>中定义函数：
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-&minus; note overloading of SQL function name "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- 注意SQL函数名“add_one”的重载
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>

<!--==========================orignal english content==========================
    <para>
     Here, <replaceable>DIRECTORY</replaceable> stands for the
     directory of the shared library file (for instance the
     <productname>PostgreSQL</productname> tutorial directory, which
     contains the code for the examples used in this section).
     (Better style would be to use just <literal>'funcs'</literal> in the
     <literal>AS</literal> clause, after having added
     <replaceable>DIRECTORY</replaceable> to the search path.  In any
     case, we can omit the system-specific extension for a shared
     library, commonly <literal>.so</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     这里，<replaceable>DIRECTORY</replaceable>表示共享库文件的目录（例如<productname>PostgreSQL</productname>的教程目录，它包含这一节中用到的例子的代码）。（更好的风格是先把<replaceable>DIRECTORY</replaceable>放入搜索路径，在<literal>AS</literal>子句中只使用<literal>'funcs'</literal>。在任何情况下，我们可以为一个共享库省略系统相关的扩展名，通常是<literal>.so</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Notice that we have specified the functions as <quote>strict</quote>,
     meaning that
     the system should automatically assume a null result if any input
     value is null.  By doing this, we avoid having to check for null inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, using <function>PG_ARGISNULL()</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意我们已经把函数指定为<quote>strict</quote>，这意味着如果有任何输入值为空，系统应该自动假定得到空结果。通过这种做法，我们避免在函数代码中检查空值输入。如果不这样做，我们必须使用<function>PG_ARGISNULL()</function>明确地检查空值输入。
    </para>

<!--==========================orignal english content==========================
    <para>
     The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>
     allows a function to test whether each input is null.  (Of course, doing
     this is only necessary in functions not declared <quote>strict</quote>.)
     As with the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> until
     one has verified that the argument isn't null.
     To return a null result, execute <function>PG_RETURN_NULL()</function>;
     this works in both strict and nonstrict functions.
    </para>
____________________________________________________________________________-->
    <para>
     宏<function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>允许一个函数测试是否每一个输入为空（当然，只需要在没有声明为<quote>strict</quote>的函数中这样做）。和<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏一样，输入参数也是从零开始计数。注意应该在验证了一个参数不是空之后才执行<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>。要返回一个空结果，应执行<function>PG_RETURN_NULL()</function>，它对严格的以及非严格的函数都有用。
    </para>

<!--==========================orignal english content==========================
    <para>
     At first glance, the version-1 coding conventions might appear
     to be just pointless obscurantism, compared to using
     plain <literal>C</literal> calling conventions.  They do however allow
     us to deal with <literal>NULL</literal>able arguments/return values,
     and <quote>toasted</quote> (compressed or out-of-line) values.
    </para>
____________________________________________________________________________-->
    <para>
     乍一看，与使用普通的<literal>C</literal>调用约定相比，版本 1 编码约定似乎只是毫无意义的愚民政策。
     然而，它们确实允许我们处理<literal>NULL</literal>able 参数/返回值，以及<quote>toasted</quote>（压缩或离线）值。
    </para>

<!--==========================orignal english content==========================
    <para>
     Other options provided by the version-1 interface are two
     variants of the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macros. The first of these,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,
     guarantees to return a copy of the specified argument that is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, which
     must not be written to. Using the
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>
     macros guarantees a writable result.)
    The second variant consists of the
    <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
    macros which take three arguments. The first is the number of the
    function argument (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These macros provide more efficient access to
    parts of large values in the case where they have storage type
    <quote>external</quote>. (The storage type of a column can be specified using
    <literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER
    COLUMN <replaceable>colname</replaceable> SET STORAGE
    <replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</replaceable> is one of
    <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal>,
     or <literal>main</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     在版本-1接口中提供的其他选项是<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏的两个变种。其中的第一种是<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>，它确保返回的指定参数的拷贝可以被安全地写入（通常的宏有时会返回一个指向表中物理存储的值，它不能被写入。使用<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>宏可以保证得到一个可写的结果）。第二种变种<function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>宏有三个参数。第一个是函数参数的编号（如上文）。第二个和第三个是要被返回的段的偏移量和长度。偏移量从零开始计算，而负值的长度则表示要求返回该值的剩余部分。当大型值的存储类型为<quote>external</quote>时，这些宏提供了访问这些大型值的更有效的方法（列的存储类型可以使用<literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER COLUMN <replaceable>colname</replaceable> SET STORAGE <replaceable>storagetype</replaceable></literal>来指定。<replaceable>storagetype</replaceable>取<literal>plain</literal>、<literal>external</literal>、<literal>extended</literal>或者<literal>main</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Finally, the version-1 function call conventions make it possible
     to return set results (<xref linkend="xfunc-c-return-set"/>) and
     implement trigger functions (<xref linkend="triggers"/>) and
     procedural-language call handlers (<xref
     linkend="plhandler"/>).  For more details
     see <filename>src/backend/utils/fmgr/README</filename> in the
     source distribution.
    </para>
____________________________________________________________________________-->
    <para>
     最后，版本-1 的函数调用规范可以返回集合结果（<xref linkend="xfunc-c-return-set"/>）、实现触发器函数（<xref linkend="triggers"/>）和过程语言调用处理器（<xref linkend="plhandler"/>）。更多细节
     可见源代码发布中的<filename>src/backend/utils/fmgr/README</filename>。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Writing Code</title>
____________________________________________________________________________-->
    <title>编写代码</title>

<!--==========================orignal english content==========================
    <para>
     Before we turn to the more advanced topics, we should discuss
     some coding rules for <productname>PostgreSQL</productname>
     C-language functions.  While it might be possible to load functions
     written in languages other than C into
     <productname>PostgreSQL</productname>, this is usually difficult
     (when it is possible at all) because other languages, such as
     C++, FORTRAN, or Pascal often do not follow the same calling
     convention as C.  That is, other languages do not pass argument
     and return values between functions in the same way.  For this
     reason, we will assume that your C-language functions are
     actually written in C.
    </para>
____________________________________________________________________________-->
    <para>
     在开始更高级的话题之前，我们应该讨论一下用于
     <productname>PostgreSQL</productname> C 语言函数的编码规则。
     虽然可以把不是 C 编写的函数载入到
     <productname>PostgreSQL</productname>中，这通常是很困难的，
     因为其他语言（例如 C++、FORTRAN 或者 Pascal）通常不会遵循和 C
     相同的调用规范。也就是说，其他语言不会以同样的方式在函数之间传递
     参数以及返回值。由于这个原因，我们会假定你的 C 语言函数确实是用 C
     编写的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The basic rules for writing and building C functions are as follows:

     <itemizedlist>
      <listitem>
       <para>
        Use <literal>pg_config
        -&minus;includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        to find out where the <productname>PostgreSQL</productname> server header
        files are installed on your system (or the system that your
        users will be running on).
       </para>
      </listitem>

      <listitem>
       <para>
        Compiling and linking your code so that it can be dynamically
        loaded into <productname>PostgreSQL</productname> always
        requires special flags.  See <xref linkend="dfunc"/> for a
        detailed explanation of how to do it for your particular
        operating system.
       </para>
      </listitem>

      <listitem>
       <para>
        Remember to define a <quote>magic block</quote> for your shared library,
        as described in <xref linkend="xfunc-c-dynload"/>.
       </para>
      </listitem>

      <listitem>
       <para>
        When allocating memory, use the
        <productname>PostgreSQL</productname> functions
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm> and <function>pfree</function><indexterm><primary>pfree</primary></indexterm>
        instead of the corresponding C library functions
        <function>malloc</function> and <function>free</function>.
        The memory allocated by <function>palloc</function> will be
        freed automatically at the end of each transaction, preventing
        memory leaks.
       </para>
      </listitem>

      <listitem>
       <para>
        Always zero the bytes of your structures using <function>memset</function>
        (or allocate them with <function>palloc0</function> in the first place).
        Even if you assign to each field of your structure, there might be
        alignment padding (holes in the structure) that contain
        garbage values.  Without this, it's difficult to
        support hash indexes or hash joins, as you must pick out only
        the significant bits of your data structure to compute a hash.
        The planner also sometimes relies on comparing constants via
        bitwise equality, so you can get undesirable planning results if
        logically-equivalent values aren't bitwise equal.
       </para>
      </listitem>

      <listitem>
       <para>
        Most of the internal <productname>PostgreSQL</productname>
        types are declared in <filename>postgres.h</filename>, while
        the function manager interfaces
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.)  are in
        <filename>fmgr.h</filename>, so you will need to include at
        least these two files.  For portability reasons it's best to
        include <filename>postgres.h</filename> <emphasis>first</emphasis>,
        before any other system or user header files.  Including
        <filename>postgres.h</filename> will also include
        <filename>elog.h</filename> and <filename>palloc.h</filename>
        for you.
       </para>
      </listitem>

      <listitem>
       <para>
        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <productname>PostgreSQL</productname> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     编写和编译 C 函数的基本规则如下：

     <itemizedlist>
      <listitem>
       <para>
        使用<literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        找出<productname>PostgreSQL</productname>服务器头文件安装在
        系统的哪个位置。
       </para>
      </listitem>

      <listitem>
       <para>
        编译并且链接你的代码（这样它就能被动态载入到
        <productname>PostgreSQL</productname>中）总是
        要求特殊的标志。对特定的操作系统的做法详见
        <xref linkend="dfunc"/>。
       </para>
      </listitem>

      <listitem>
       <para>
        记住为你的共享库按<xref linkend="xfunc-c-dynload"/>中所述
        定义一个<quote>magic block</quote>。
       </para>
      </listitem>

      <listitem>
       <para>
        在分配内存时，使用
        <productname>PostgreSQL</productname>函数
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm>和 <function>pfree</function><indexterm><primary>pfree</primary></indexterm>，
        而不是使用对应的 C 库函数
        <function>malloc</function>和<function>free</function>。
        在每个事务结束时会自动释放通过<function>palloc</function>
        分配的内存，以免内存泄露。
       </para>
      </listitem>

      <listitem>
       <para>
        总是要使用<function>memset</function>把你的结构中的字节置零（或者
        最开始就用<function>palloc0</function>分配它们）。即使你对结构中的
        每个域都赋值，也可能有对齐填充（结构中的空洞）包含着垃圾值。
        如果不这样做，很难支持哈希索引或哈希连接，因为你必须选出数据
        结构中有意义的位进行哈希计算。规划器有时也依赖于用按位相等来
        比较常量，因此如果逻辑等价的值不是按位相等的会导致出现不想要
        的规划结果。
       </para>
      </listitem>

      <listitem>
       <para>
        大部分的内部<productname>PostgreSQL</productname>类型
        都声明在<filename>postgres.h</filename>中，不过函数管理器
        接口（<symbol>PG_FUNCTION_ARGS</symbol>等）在
        <filename>fmgr.h</filename>中，因此你将需要包括至少这两个
        文件。为了移植性，最好在包括任何其他系统或者用户头文件之前，
        <emphasis>先</emphasis>包括<filename>postgres.h</filename>。包
        括<filename>postgres.h</filename>也将会为你包括
        <filename>elog.h</filename>和<filename>palloc.h</filename>。
       </para>
      </listitem>

      <listitem>
       <para>
        对象文件中定义的符号名不能相互冲突或者与
        <productname>PostgreSQL</productname>服务器可执行程序中
        定义的符号冲突。如果出现有关于此的错误消息，你将必须重命名你的
        函数或者变量。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

   <sect2>
<!--==========================orignal english content==========================
    <title>Composite-Type Arguments</title>
____________________________________________________________________________-->
    <title>组合类型参数</title>

<!--==========================orignal english content==========================
    <para>
     Composite types do not have a fixed layout like C structures.
     Instances of a composite type can contain null fields.  In
     addition, composite types that are part of an inheritance
     hierarchy can have different fields than other members of the
     same inheritance hierarchy.  Therefore,
     <productname>PostgreSQL</productname> provides a function
     interface for accessing fields of composite types from C.
    </para>
____________________________________________________________________________-->
    <para>
     组合类型没有像 C 结构那样的固定布局。组合类型的实例可能包含
     空值域。此外，继承层次中的组合类型可能具有和同一继承层次中
     其他成员不同的域。因此，
     <productname>PostgreSQL</productname>提供了函数接口
     来访问 C 的组合类型的域。
    </para>

<!--==========================orignal english content==========================
    <para>
     Suppose we want to write a function to answer the query:

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

     Using the version-1 calling conventions, we can define
     <function>c_overpaid</function> as:

<programlisting><![CDATA[
#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     假设我们想要写一个函数来回答查询：

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

     如果使用版本-1的调用规范，我们可以定义
     <function>c_overpaid</function>为：

<programlisting><![CDATA[
#include "postgres.h"
#include "executor/executor.h"  /* 用于 GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* 另外，我们可能更想对空 salary 用 PG_RETURN_NULL() 。*/

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>GetAttributeByName</function> is the
     <productname>PostgreSQL</productname> system function that
     returns attributes out of the specified row.  It has
     three arguments: the argument of type <type>HeapTupleHeader</type> passed
     into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <function>GetAttributeByName</function> returns a <type>Datum</type>
     value that you can convert to the proper data type by using the
     appropriate <function>DatumGet<replaceable>XXX</replaceable>()</function>
     macro.  Note that the return value is meaningless if the null flag is
     set; always check the null flag before trying to do anything with the
     result.
    </para>
____________________________________________________________________________-->
    <para>
     <function>GetAttributeByName</function>是返回指定行的属性的
     <productname>PostgreSQL</productname>系统函数。它有三个参数：
     类型为<type>HeapTupleHeader</type>的传入参数、想要访问的函数名
     以及一个说明该属性是否为空的返回参数。
     <function>GetAttributeByName</function>返回一个<type>Datum</type>
     值，可以把它用合适的<function>DatumGet<replaceable>XXX</replaceable>()</function>
     宏转换成正确的数据类型。注意如果空值标志被设置，那么返回值是没有
     意义的，所以在对结果做任何事情之前应该先检查空值标志。
    </para>

<!--==========================orignal english content==========================
    <para>
     There is also <function>GetAttributeByNum</function>, which selects
     the target attribute by column number instead of name.
    </para>
____________________________________________________________________________-->
    <para>
     也有<function>GetAttributeByNum</function>函数，它可以用目标属性
     的属性号而不是属性名来选择目标属性。
    </para>

<!--==========================orignal english content==========================
    <para>
     The following command declares the function
     <function>c_overpaid</function> in SQL:

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

     Notice we have used <literal>STRICT</literal> so that we did not have to
     check whether the input arguments were NULL.
    </para>
____________________________________________________________________________-->
    <para>
     下面的命令声明 SQL 中的<function>c_overpaid</function>：

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

     注意我们用了<literal>STRICT</literal>，这样我们不需要检查输入参数是否
     为 NULL。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Returning Rows (Composite Types)</title>
____________________________________________________________________________-->
    <title>返回行（组合类型）</title>

<!--==========================orignal english content==========================
    <para>
     To return a row or composite-type value from a C-language
     function, you can use a special API that provides macros and
     functions to hide most of the complexity of building composite
     data types.  To use this API, the source file must include:
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要从一个 C 语言函数中返回一个行或者组合类型值，你可以使用一种
     特殊的 API，它提供的宏和函数隐藏了大部分的构建组合数据类型的
     复杂性。要使用这种 API，源文件中必须包括：
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     There are two ways you can build a composite data value (henceforth
     a <quote>tuple</quote>): you can build it from an array of Datum values,
     or from an array of C strings that can be passed to the input
     conversion functions of the tuple's column data types.  In either
     case, you first need to obtain or construct a <structname>TupleDesc</structname>
     descriptor for the tuple structure.  When working with Datums, you
     pass the <structname>TupleDesc</structname> to <function>BlessTupleDesc</function>,
     and then call <function>heap_form_tuple</function> for each row.  When working
     with C strings, you pass the <structname>TupleDesc</structname> to
     <function>TupleDescGetAttInMetadata</function>, and then call
     <function>BuildTupleFromCStrings</function> for each row.  In the case of a
     function returning a set of tuples, the setup steps can all be done
     once during the first call of the function.
    </para>
____________________________________________________________________________-->
    <para>
     有两种方式可以构建一个组合数据值（以后就叫一个<quote>元组</quote>）：
     可以从一个 Datum 值的数组构造，或者从一个 C 字符串（可被传递给该元组
     各列的数据类型的输入转换函数）的数组构造。在两种情况下，都首先需要为
     该元组的结构获得或者构造一个<structname>TupleDesc</structname>描述符。在处
     理 Datum 时，需要把该<structname>TupleDesc</structname>传递给
     <function>BlessTupleDesc</function>，接着为每一行调用
     <function>heap_form_tuple</function>。在处理 C 字符串时，需要把该
     <structname>TupleDesc</structname>传递给
     <function>TupleDescGetAttInMetadata</function>，接着为每一行调用
     <function>BuildTupleFromCStrings</function>。对于返回一个元组集合的函数，
     这些设置步骤可以在第一次调用该函数时一次性完成。
    </para>

<!--==========================orignal english content==========================
    <para>
     Several helper functions are available for setting up the needed
     <structname>TupleDesc</structname>.  The recommended way to do this in most
     functions returning composite values is to call:
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
     passing the same <literal>fcinfo</literal> struct passed to the calling function
     itself.  (This of course requires that you use the version-1
     calling conventions.)  <varname>resultTypeId</varname> can be specified
     as <literal>NULL</literal> or as the address of a local variable to receive the
     function's result type OID.  <varname>resultTupleDesc</varname> should be the
     address of a local <structname>TupleDesc</structname> variable.  Check that the
     result is <literal>TYPEFUNC_COMPOSITE</literal>; if so,
     <varname>resultTupleDesc</varname> has been filled with the needed
     <structname>TupleDesc</structname>.  (If it is not, you can report an error along
     the lines of <quote>function returning record called in context that
     cannot accept type record</quote>.)
    </para>
____________________________________________________________________________-->
    <para>
     有一些助手函数可以用来设置所需的<structname>TupleDesc</structname>。在大部分
     返回组合值的函数中推荐的方式是调用：
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
     传递传给调用函数本身的同一个<literal>fcinfo</literal>结构（这当然要求使用的
     是版本-1 的调用规范）。<varname>resultTypeId</varname>可以被指定为
     <literal>NULL</literal>或者一个本地变量的地址以接收该函数的结果类型 OID。
     <varname>resultTupleDesc</varname>应该是一个本地
     <structname>TupleDesc</structname>变量的地址。检查结果是不是
     <literal>TYPEFUNC_COMPOSITE</literal>，如果是则
     <varname>resultTupleDesc</varname>已经被用所需的
     <structname>TupleDesc</structname>填充（如果不是，你可以报告一个错误，并且
     返回<quote>function returning record called in context that
     cannot accept type record</quote>字样的消息）。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      <function>get_call_result_type</function> can resolve the actual type of a
      polymorphic function result; so it is useful in functions that return
      scalar polymorphic results, not only functions that return composites.
      The <varname>resultTypeId</varname> output is primarily useful for functions
      returning polymorphic scalars.
     </para>
____________________________________________________________________________-->
     <para>
      <function>get_call_result_type</function>能够解析一个多态函数结果的实际类型，
      因此不仅在返回组合类型的函数中，在返回标量多态结果的函数中它也是非常
      有用的。<varname>resultTypeId</varname>输出主要用于返回多态标量的函数。
     </para>
    </tip>

    <note>
<!--==========================orignal english content==========================
     <para>
      <function>get_call_result_type</function> has a sibling
      <function>get_expr_result_type</function>, which can be used to resolve the
      expected output type for a function call represented by an expression
      tree.  This can be used when trying to determine the result type from
      outside the function itself.  There is also
      <function>get_func_result_type</function>, which can be used when only the
      function's OID is available.  However these functions are not able
      to deal with functions declared to return <structname>record</structname>, and
      <function>get_func_result_type</function> cannot resolve polymorphic types,
      so you should preferentially use <function>get_call_result_type</function>.
     </para>
____________________________________________________________________________-->
     <para>
      <function>get_call_result_type</function>有一个兄弟
      <function>get_expr_result_type</function>，它被用来解析被表示为一棵表达式
      树的函数调用的输出类型。在尝试确定来自函数外部的结果类型时可以用它。
      也有一个<function>get_func_result_type</function>，当只有函数的 OID 可用时
      可以用它。不过这些函数无法处理被声明为返回<structname>record</structname>的
      函数，并且<function>get_func_result_type</function>无法解析多态类型，因此你
      应该优先使用<function>get_call_result_type</function>。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     Older, now-deprecated functions for obtaining
     <structname>TupleDesc</structname>s are:
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
     to get a <structname>TupleDesc</structname> for the row type of a named relation,
     and:
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     to get a <structname>TupleDesc</structname> based on a type OID. This can
     be used to get a <structname>TupleDesc</structname> for a base or
     composite type.  It will not work for a function that returns
     <structname>record</structname>, however, and it cannot resolve polymorphic
     types.
    </para>
____________________________________________________________________________-->
    <para>
     比较老的，现在已经被废弃的获得<structname>TupleDesc</structname>的函数是：
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
     它可以为一个提到的关系的行类型得到<structname>TupleDesc</structname>，
     还有：
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     可以基于一个类型 OID 得到<structname>TupleDesc</structname>。这可以被用来
     为一种基础或者组合类型获得<structname>TupleDesc</structname>。不过，对于
     返回<structname>record</structname>的函数它不起作用，并且它无法解析多态类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Once you have a <structname>TupleDesc</structname>, call:
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     if you plan to work with Datums, or:
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     if you plan to work with C strings.  If you are writing a function
     returning set, you can save the results of these functions in the
     <structname>FuncCallContext</structname> structure &mdash; use the
     <structfield>tuple_desc</structfield> or <structfield>attinmeta</structfield> field
     respectively.
    </para>
____________________________________________________________________________-->
    <para>
     一旦有了一个<structname>TupleDesc</structname>，如果计划处理 Datum可以调用：
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     如果计划处理 C 字符串，可调用：
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     如果正在编写一个返回集合的函数，你可以把这些函数的结果保存在
     <structname>FuncCallContext</structname>结构中 &mdash; 分别使用
     <structfield>tuple_desc</structfield>或者<structfield>attinmeta</structfield>域。
    </para>

<!--==========================orignal english content==========================
    <para>
     When working with Datums, use:
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data in Datum form.
    </para>
____________________________________________________________________________-->
    <para>
     在处理 Datum 时，使用
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
     来用 Datum 形式的用户数据构建一个<structname>HeapTuple</structname>。
    </para>

<!--==========================orignal english content==========================
    <para>
     When working with C strings, use:
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data
     in C string form.  <parameter>values</parameter> is an array of C strings,
     one for each attribute of the return row. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <parameter>values</parameter> array
     should be set to <symbol>NULL</symbol>.  This function will need to
     be called again for each row you return.
    </para>
____________________________________________________________________________-->
    <para>
     在处理 C 字符串时，使用
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     来用 C 字符串形式的用户数据构建一个<structname>HeapTuple</structname>。
     <parameter>values</parameter>是一个 C 字符串数组，每一个元素是返回行
     的一个属性。每一个 C 字符串应该是该属性数据类型的输入函数所期望
     的格式。为了对一个属性返回空值，<parameter>values</parameter>数组中对
     应的指针应该被设置为<symbol>NULL</symbol>。对于你返回的每一行都将
     再次调用这个函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Once you have built a tuple to return from your function, it
     must be converted into a <type>Datum</type>. Use:
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     to convert a <structname>HeapTuple</structname> into a valid Datum.  This
     <type>Datum</type> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
    </para>
____________________________________________________________________________-->
    <para>
     一旦已经构建了一个要从函数中返回的元组，它必须被转换成一个
     <type>Datum</type>。使用
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     可把一个<structname>HeapTuple</structname>转换成合法的 Datum。如果你
     只想返回一行，那么这个<type>Datum</type>可以被直接返回，在一个
     集合返回函数中它也可以被当做当前的返回值。
    </para>

<!--==========================orignal english content==========================
    <para>
     An example appears in the next section.
    </para>
____________________________________________________________________________-->
    <para>
     下一节中会有一个例子。
    </para>

   </sect2>

   <sect2 id="xfunc-c-return-set">
<!--==========================orignal english content==========================
    <title>Returning Sets</title>
____________________________________________________________________________-->
    <title>返回集合</title>

<!--==========================orignal english content==========================
    <para>
     C-language functions have two options for returning sets (multiple
     rows).  In one method, called <firstterm>ValuePerCall</firstterm>
     mode, a set-returning function is called repeatedly (passing the same
     arguments each time) and it returns one new row on each call, until
     it has no more rows to return and signals that by returning NULL.
     The set-returning function (<acronym>SRF</acronym>) must therefore
     save enough state across calls to remember what it was doing and
     return the correct next item on each call.
     In the other method, called <firstterm>Materialize</firstterm> mode,
     a SRF fills and returns a tuplestore object containing its
     entire result; then only one call occurs for the whole result, and
     no inter-call state is needed.
    </para>
____________________________________________________________________________-->
    <para>
     C 语言函数有两个返回集合（多行）的选项。在一种称为<firstterm>ValuePerCall</firstterm>
     模式的方法中，一个集合返回函数被重复调用（每次传递相同的参数），并在每次调用时返回一个新行，
     直到没有更多行要返回并且 通过返回 NULL 来表示这一点。因此，集合返回函数 (<acronym>SRF</acronym>) 
     必须在调用之间保存足够的状态以记住它在做什么并在每次调用时返回正确的下一项。
     在另一种称为<firstterm>Materialize</firstterm>模式的方法中，SRF 填充并返回一个包含其整个结果的 tuplestore 对象； 
     那么整个结果只发生一次调用，不需要调用间状态。
    </para>

<!--==========================orignal english content==========================
    <para>
     When using ValuePerCall mode, it is important to remember that the
     query is not guaranteed to be run to completion; that is, due to
     options such as <literal>LIMIT</literal>, the executor might stop
     making calls to the set-returning function before all rows have been
     fetched.  This means it is not safe to perform cleanup activities in
     the last call, because that might not ever happen.  It's recommended
     to use Materialize mode for functions that need access to external
     resources, such as file descriptors.
    </para>
____________________________________________________________________________-->
    <para>
     使用 ValuePerCall 模式时，重要的是要记住查询不能保证运行完成； 
     也就是说，由于诸如<literal>LIMIT</literal>之类的选项，
     执行程序可能会在获取所有行之前停止调用 set-returning 函数。
     这意味着在最后一次调用中执行清理活动是不安全的，因为这可能永远不会发生。
     对于需要访问外部资源（例如文件描述符）的函数，建议使用 Materialize 模式。
    </para>

<!--==========================orignal english content==========================
    <para>
     The remainder of this section documents a set of helper macros that
     are commonly used (though not required to be used) for SRFs using
     ValuePerCall mode.  Additional details about Materialize mode can be
     found in <filename>src/backend/utils/fmgr/README</filename>.  Also,
     the <filename>contrib</filename> modules in
     the <productname>PostgreSQL</productname> source distribution contain
     many examples of SRFs using both ValuePerCall and Materialize mode.
    </para>
____________________________________________________________________________-->
    <para>
     本节的其余部分记录了一组使用 ValuePerCall 模式的 SRF 常用（尽管不是必须使用）的帮助程序宏。
     有关 Materialize 模式的其他详细信息可以在<filename>src/backend/utils/fmgr/README</filename>中找到。
     此外，<productname>PostgreSQL</productname>源代码分发中的<filename>contrib</filename> 
     模块包含许多使用 ValuePerCall 和 Materialize 模式的 SRF 示例。
    </para>

<!--==========================orignal english content==========================
    <para>
     To use the ValuePerCall support macros described here,
     include <filename>funcapi.h</filename>.  These macros work with a
     structure <structname>FuncCallContext</structname> that contains the
     state that needs to be saved across calls.  Within the calling
     SRF, <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal> is used to
     hold a pointer to <structname>FuncCallContext</structname> across
     calls.  The macros automatically fill that field on first use,
     and expect to find the same pointer there on subsequent uses.
<programlisting>
typedef struct FuncCallContext
{
    /*
     * Number of times we've been called before
     *
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint64 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint64 max_calls;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * OPTIONAL pointer to struct containing tuple description
     *
     * tuple_desc is for use when returning tuples (i.e., composite data types)
     * and is only needed if you are going to build the tuples with
     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
     * the TupleDesc pointer stored here should usually have been run through
     * BlessTupleDesc() first.
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要使用此处描述的 ValuePerCall 支持宏，请包含<filename>funcapi.h</filename>。
     这些宏与结构<structname>FuncCallContext</structname>一起使用，该结构包含需要跨调用保存的状态。
     在调用 SRF 中，<literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>用于在调用之间保存
     指向<structname>FuncCallContext</structname>的指针。
     宏在第一次使用时自动填充该字段，并期望在后续使用中找到相同的指针。
<programlisting>
typedef struct FuncCallContext
{
    /*
     * 本次调用以前已经被调用过多少次
     *
     * SRF_FIRSTCALL_INIT() 会为你把 call_cntr 初始化为 0，
     * 并且在每次调用 SRF_RETURN_NEXT() 时增加。
     */
    uint64 call_cntr;

    /*
     * 可选：最大调用次数
     *
     * 这里的 max_calls 只是为了方便，设置它是可选的。
     * 如果没有设置，你必须提供替代的方法来了解函数什么时候做完。
     */
    uint64 max_calls;

    /*
     * 可选：指向用户提供的上下文信息的指针
     *
     * user_fctx 是一个指向你自己的数据的指针，它可用来在函数的多次
     * 调用之间保存任意的上下文信息。
     */
    void *user_fctx;

    /*
     * 可选：指向包含属性类型输入元数据的结构的指针
     *
     * attinmeta 被用在返回元组（即组合数据类型）时，在返回基本数据类型
     * 时不会使用。只有想用BuildTupleFromCStrings()创建返回元组时才需要它。
     */
    AttInMetadata *attinmeta;

    /*
     * 用于保存必须在多次调用间都存在的结构的内存上下文
     *
     * SRF_FIRSTCALL_INIT() 会为你设置 multi_call_memory_ctx，并且由
     * SRF_RETURN_DONE() 来清理。对于任何需要在 SRF 的多次调用间都
     * 存在的内存来说，它是最合适的内存上下文。
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 可选：指向包含元组描述的结构的指针
     *
     * tuple_desc 被用在返回元组（即组合数据类型）时，并且只有在用
     * heap_form_tuple() 而不是 BuildTupleFromCStrings() 构建元组时才需要它。
     * 注意这里存储的 TupleDesc 指针通常已经被先运行过 BlessTupleDesc()。
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The macros to be used by an <acronym>SRF</acronym> using this
     infrastructure are:
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     Use this to determine if your function is being called for the first or a
     subsequent time. On the first call (only), call:
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     to initialize the <structname>FuncCallContext</structname>. On every function call,
     including the first, call:
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     to set up for using the <structname>FuncCallContext</structname>.
    </para>
____________________________________________________________________________-->
    <para>
     使用此基础结构的<acronym>SRF</acronym>将使用的宏是：
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     来判断你的函数是否是第一次被调用。在第一次调用时（只能在第一次调用时）使用：
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     使用它来确定您的函数是第一次还是随后被调用。 在第一次调用时（仅），调用：
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     设置使用<structname>FuncCallContext</structname>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If your function has data to return in the current call, use:
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     to return it to the caller.  (<literal>result</literal> must be of type
     <type>Datum</type>, either a single value or a tuple prepared as
     described above.)  Finally, when your function is finished
     returning data, use:
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     to clean up and end the <acronym>SRF</acronym>.
    </para>
____________________________________________________________________________-->
    <para>
     如果您的函数有数据要在当前调用中返回，请使用：
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     把它返回给调用者（<literal>result</literal>必须是类型<type>Datum</type>，
     可以是一个单一值或者按上文所述准备好的元组）。最后，当函数完成了
     数据返回后，可使用：
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     来清理并且结束<acronym>SRF</acronym>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The memory context that is current when the <acronym>SRF</acronym> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to call <function>pfree</function> on everything
     you allocated using <function>palloc</function>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <structfield>multi_call_memory_ctx</structfield> is a suitable location for any
     data that needs to survive until the <acronym>SRF</acronym> is finished running.  In most
     cases, this means that you should switch into
     <structfield>multi_call_memory_ctx</structfield> while doing the
     first-call setup.
     Use <literal>funcctx-&gt;user_fctx</literal> to hold a pointer to
     any such cross-call data structures.
     (Data you allocate
     in <structfield>multi_call_memory_ctx</structfield> will go away
     automatically when the query ends, so it is not necessary to free
     that data manually, either.)
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SRF</acronym>被调用时的当前内存上下文被称作一个瞬时上下文，
     在两次调用之间会清除它。这意味着你不必对用<function>palloc</function>
     分配的所有东西调用<function>pfree</function>，它们将自动被释放。不过，
     如果你想要分配任何需要在多次调用间都存在的数据结构，需要把它们
     放在其他地方。对于任何需要在<acronym>SRF</acronym>结束运行之前都存
     在的数据来说，<structfield>multi_call_memory_ctx</structfield>引用的内存
     上下文是一个合适的位置。在大多数情况下，这意味着您应该在进行首次调用设置时切换到
     <structfield>multi_call_memory_ctx</structfield>。 
     使用<literal>funcctx-&gt;user_fctx</literal>来保存指向任何此类交叉调用数据结构的指针。
     （您在<structfield>multi_call_memory_ctx</structfield>中分配的数据将在查询结束时自动消失，
     因此也无需手动释放该数据。）
    </para>

    <warning>
<!--==========================orignal english content==========================
     <para>
      While the actual arguments to the function remain unchanged between
      calls, if you detoast the argument values (which is normally done
      transparently by the
      <function>PG_GETARG_<replaceable>xxx</replaceable></function> macro)
      in the transient context then the detoasted copies will be freed on
      each cycle. Accordingly, if you keep references to such values in
      your <structfield>user_fctx</structfield>, you must either copy them into the
      <structfield>multi_call_memory_ctx</structfield> after detoasting, or ensure
      that you detoast the values only in that context.
     </para>
____________________________________________________________________________-->
     <para>
      虽然函数的实参在多次调用之间保持不变，但如果在瞬时上下文中
      反 TOAST 了参数（通常由
      <function>PG_GETARG_<replaceable>xxx</replaceable></function>
      宏完成），那么被反 TOAST 的拷贝将在每次循环中被释放。相应地，
      如果你把这些值的引用保存在<structfield>user_fctx</structfield>中，你也必
      须在反 TOAST 之后把它们拷贝到
      <structfield>multi_call_memory_ctx</structfield>中，或者确保你只在那个
      上下文中反 TOAST 这些值。
     </para>
    </warning>

<!--==========================orignal english content==========================
    <para>
     A complete pseudo-code example looks like the following:
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items, so just report that fact. */
        /* (Resist the temptation to put cleanup code here.) */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一个完整的伪代码例子：
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 这里是一次性设置代码： */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 这里是每一次都要做的设置代码： */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* 这里只是一种测试是否执行完的方法： */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* 这里返回另一个项： */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* 这里已经完成了项的返回，所以只报告事实。 */
        /* （不要将清理代码放在这里的。） */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     A complete example of a simple <acronym>SRF</acronym> returning a composite type
     looks like:
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* stuff done only on the first call of the function */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx->max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

     One way to declare this function in SQL is:
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     A different way is to use OUT parameters:
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     Notice that in this method the output type of the function is formally
     an anonymous <structname>record</structname> type.
    </para>
____________________________________________________________________________-->
    <para>
     一个返回组合类型的简单<acronym>SRF</acronym>的完整例子：
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* 只在第一次函数调用时做的事情 */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* 创建一个函数上下文，让它在多次调用间都保持存在 */
        funcctx = SRF_FIRSTCALL_INIT();

        /* 切换到适合多次函数调用的内存上下文 */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* 要返回的元组总数 */
        funcctx->max_calls = PG_GETARG_UINT32(0);

        /* 为结果类型构造一个元组描述符 */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * 生成后面需要用来从原始 C 字符串产生元组的属性元数据
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* 在每一次函数调用都要完成的事情 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* 如果还有要发送的 */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * 为构建返回元组准备一个值数组。这应该是一个 C
         * 字符串数组，之后类型输入函数会处理它。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* 构建一个元组 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* 把元组变成 datum */
        result = HeapTupleGetDatum(tuple);

        /* 清理（实际并不必要） */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* 如果没有要发送的 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

     在 SQL 中声明这个函数的一种方法是：
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     一种不同的方法是使用 OUT 参数：
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     注意在这种方法中，函数的输出类型在形式上是一种匿名的
     <structname>record</structname>类型。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Polymorphic Arguments and Return Types</title>
____________________________________________________________________________-->
    <title>多态参数和返回类型</title>

<!--==========================orignal english content==========================
    <para>
     C-language functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.
     When a function's arguments or return types
     are defined as polymorphic types, the function author cannot know
     in advance what data type it will be called with, or
     need to return. There are two routines provided in <filename>fmgr.h</filename>
     to allow a version-1 C function to discover the actual data types
     of its arguments and the type it is expected to return. The routines are
     called <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> and
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>.
     They return the result or argument type OID, or <symbol>InvalidOid</symbol> if the
     information is not available.
     The structure <literal>flinfo</literal> is normally accessed as
     <literal>fcinfo-&gt;flinfo</literal>. The parameter <literal>argnum</literal>
     is zero based.  <function>get_call_result_type</function> can also be used
     as an alternative to <function>get_fn_expr_rettype</function>.
     There is also <function>get_fn_expr_variadic</function>, which can be used to
     find out whether variadic arguments have been merged into an array.
     This is primarily useful for <literal>VARIADIC "any"</literal> functions,
     since such merging will always have occurred for variadic functions
     taking ordinary array types.
    </para>
____________________________________________________________________________-->
    <para>
     可以声明 C 语言函数来接受和返回<xref linkend="extend-types-polymorphic"/>中描述的多态类型。当函数参数或者返回
     类型被定义为多态类型时，函数的编写者无法提前知道会用什么数据类型
     调用该函数或者该函数需要返回什么数据类型。在<filename>fmgr.h</filename>
     中提供了两种例程来允许版本-1 的 C 函数发现其参数的实际数据类型以及
     它要返回的类型。这些例程被称为
     <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal>和
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>。它们
     返回结果或者参数的类型的 OID，或者当该信息不可用时返回
     <symbol>InvalidOid</symbol>。结构<literal>flinfo</literal>通常被当做
     <literal>fcinfo-&gt;flinfo</literal>访问。参数<literal>argnum</literal>则是从零
     开始计。<function>get_call_result_type</function>也可被用作
     <function>get_fn_expr_rettype</function>的一种替代品。还有
     <function>get_fn_expr_variadic</function>，它可以被用来找出 variadic 参数
     是否已经被合并到了一个数组中。这主要用于
     <literal>VARIADIC "any"</literal>函数，因为对于接收普通数组类型的
     variadic 函数来说总是会发生这类合并。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example, suppose we want to write a function to accept a single
     element of any type, and return a one-dimensional array of that type:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element, being careful in case it's NULL */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     例如，假设我们想要写一个接收一个任意类型元素并且返回一个该类型的一维
     数组的函数：

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 得到提供的元素，小心它为 NULL 的情况 */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* 只有一个维度 */
    ndims = 1;
    /* 和一个元素 */
    dims[0] = 1;
    /* 且下界是 1 */
    lbs[0] = 1;

    /* 得到该元素类型所需的信息 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* 现在构建数组 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The following command declares the function
     <function>make_array</function> in SQL:

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     下面的命令在 SQL 中声明函数<function>make_array</function>：

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     There is a variant of polymorphism that is only available to C-language
     functions: they can be declared to take parameters of type
     <literal>"any"</literal>.  (Note that this type name must be double-quoted,
     since it's also a SQL reserved word.)  This works like
     <type>anyelement</type> except that it does not constrain different
     <literal>"any"</literal> arguments to be the same type, nor do they help
     determine the function's result type.  A C-language function can also
     declare its final parameter to be <literal>VARIADIC "any"</literal>.  This will
     match one or more actual arguments of any type (not necessarily the same
     type).  These arguments will <emphasis>not</emphasis> be gathered into an array
     as happens with normal variadic functions; they will just be passed to
     the function separately.  The <function>PG_NARGS()</function> macro and the
     methods described above must be used to determine the number of actual
     arguments and their types when using this feature.  Also, users of such
     a function might wish to use the <literal>VARIADIC</literal> keyword in their
     function call, with the expectation that the function would treat the
     array elements as separate arguments.  The function itself must implement
     that behavior if wanted, after using <function>get_fn_expr_variadic</function> to
     detect that the actual argument was marked with <literal>VARIADIC</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     有一种只对 C 语言函数可用的多态变体：它们可以被声明为接受类型为
     <literal>"any"</literal>的参数（注意这种类型名必须用双引号引用，因为它也
     是一个 SQL 保留字）。这和<type>anyelement</type>相似，不过它不约束
     不同的<literal>"any"</literal>参数为同一种类型，它们也不会帮助确定函数的
     结果类型。C 语言函数也能声明它的第一个参数为
     <literal>VARIADIC "any"</literal>。这可以匹配一个或者多个任意类型的实参（
     不需要是同一种类型）。这些参数<emphasis>不会</emphasis>像普通 variadic 函
     数那样被收集到一个数组中，它们将被单独传递给该函数。使用这种特性时，
     必须用<function>PG_NARGS()</function>宏以及上述方法来判断实参的个数和类
     型。还有，这种函数的用户可能希望在他们的函数调用中使用
     <literal>VARIADIC</literal>关键词，以期让该函数将数组元素作为单独的参数
     对待。如果想要这样，在使用<function>get_fn_expr_variadic</function>检测被
     标记为<literal>VARIADIC</literal>的实参之后，函数本身必须实现这种行为。
    </para>
   </sect2>

   <sect2 id="xfunc-shared-addin">
<!--==========================orignal english content==========================
    <title>Shared Memory and LWLocks</title>
____________________________________________________________________________-->
    <title>共享内存和 LWLock</title>

<!--==========================orignal english content==========================
    <para>
     Add-ins can reserve LWLocks and an allocation of shared memory on server
     startup.  The add-in's shared library must be preloaded by specifying
     it in
     <xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>.
     Shared memory is reserved by calling:
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
     from your <function>_PG_init</function> function.
    </para>
____________________________________________________________________________-->
    <para>
     外接程序可以在服务器启动时保留 LWLock 和共享内存。
     必须通过在<xref linkend="guc-shared-preload-libraries"/>
     <indexterm><primary>shared_preload_libraries</primary></indexterm>中
     指定外接程序的共享库来预先载入它。从<function>_PG_init</function>
     函数中调用
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
     可以保留共享内存。
    </para>
<!--==========================orignal english content==========================
    <para>
     LWLocks are reserved by calling:
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
     from <function>_PG_init</function>.  This will ensure that an array of
     <literal>num_lwlocks</literal> LWLocks is available under the name
     <literal>tranche_name</literal>.  Use <function>GetNamedLWLockTranche</function>
     to get a pointer to this array.
    </para>
____________________________________________________________________________-->
    <para>
     通过从<function>_PG_init</function>中调用
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
     可以保留 LWLock。这将确保一个名为<literal>tranche_name</literal>
     的 LWLock 数组可用，该数组的长度为<literal>num_lwlocks</literal>。
     使用<function>GetNamedLWLockTranche</function>可得到该数组的指针。
    </para>
<!--==========================orignal english content==========================
    <para>
     To avoid possible race-conditions, each backend should use the LWLock
     <function>AddinShmemInitLock</function> when connecting to and initializing
     its allocation of shared memory, as shown here:
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     为了避免可能的竞争情况，在连接并且初始化共享内存时，每一个
     后端应该使用 LWLock
     <function>AddinShmemInitLock</function>，如下所示：
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
   </sect2>

   <sect2 id="extend-cpp">
<!--==========================orignal english content==========================
    <title>Using C++ for Extensibility</title>
____________________________________________________________________________-->
    <title>把 C++ 用于可扩展性</title>

<!--==========================orignal english content==========================
    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Although the <productname>PostgreSQL</productname> backend is written in
     C, it is possible to write extensions in C++ if these guidelines are
     followed:

     <itemizedlist>
      <listitem>
       <para>
         All functions accessed by the backend must present a C interface
         to the backend;  these C functions can then call C++ functions.
         For example, <literal>extern C</literal> linkage is required for
         backend-accessed functions.  This is also necessary for any
         functions that are passed as pointers between the backend and
         C++ code.
       </para>
      </listitem>
      <listitem>
       <para>
        Free memory using the appropriate deallocation method.  For example,
        most backend memory is allocated using <function>palloc()</function>, so use
        <function>pfree()</function> to free it.  Using C++
        <function>delete</function> in such cases will fail.
       </para>
      </listitem>
      <listitem>
       <para>
        Prevent exceptions from propagating into the C code (use a catch-all
        block at the top level of all <literal>extern C</literal> functions).  This
        is necessary even if the C++ code does not explicitly throw any
        exceptions, because events like out-of-memory can still throw
        exceptions.  Any exceptions must be caught and appropriate errors
        passed back to the C interface.  If possible, compile C++ with
        <option>-fno-exceptions</option> to eliminate exceptions entirely; in such
        cases, you must check for failures in your C++ code, e.g.,  check for
        NULL returned by <function>new()</function>.
       </para>
      </listitem>
      <listitem>
       <para>
        If calling backend functions from C++ code, be sure that the
        C++ call stack contains only plain old data structures
        (<acronym>POD</acronym>).  This is necessary because backend errors
        generate a distant <function>longjmp()</function> that does not properly
        unroll a C++ call stack with non-POD objects.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     尽管<productname>PostgreSQL</productname>后端是用 C 编写的，
     只要遵循下面的指导方针也可以用 C++ 编写扩展：

     <itemizedlist>
      <listitem>
       <para>
         所有被后端访问的函数必须对后端呈现一种 C 接口，然后这些 C 函数
         调用 C++ 函数。例如，对后端访问的函数要求<literal>extern C</literal>
         链接。对需要在后端和 C++ 代码之间作为指针传递的任何函数也要
         这样做。
       </para>
      </listitem>
      <listitem>
       <para>
        使用合适的释放方法释放内存。例如，大部分后端内存是通过
        <function>palloc()</function>分配的，所以应使用<function>pfree()</function>
        来释放。在这种情况中使用 C++ 的<function>delete</function>会失败。
       </para>
      </listitem>
      <listitem>
       <para>
        防止异常传播到 C 代码中（在所有<literal>extern C</literal>函数的顶层
        使用一个捕捉全部异常的块）。即使 C++ 代码不会显式地抛出任何
        异常也需要这样做，因为类似内存不足等事件仍会抛出异常。任何异常
        都必须被捕捉并且用适当的错误传回给 C 接口。如果可能，用
        <option>-fno-exceptions</option> 来编译 C++ 以完全消灭异常。在这种
        情况下，你必须在 C++ 代码中检查失败，例如检查<function>new()</function>
        返回的 NULL。
       </para>
      </listitem>
      <listitem>
       <para>
        如果从 C++ 代码调用后端函数，确定 C++ 调用栈值包含传统 C 风格
        的数据结构（<acronym>POD</acronym>）。这是必要的，因为后端错误会
        产生远距离的<function>longjmp()</function>，它无法正确的退回具有非
        POD 对象的 C++ 调用栈。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     In summary, it is best to place C++ code behind a wall of
     <literal>extern C</literal> functions that interface to the backend,
     and avoid exception, memory, and call stack leakage.
    </para>
____________________________________________________________________________-->
    <para>
     总之，最好把 C++ 代码放在与后端交互的<literal>extern C</literal>函数之后，
     并且避免异常、内存和调用栈泄露。
    </para>
   </sect2>

  </sect1>

  <sect1 id="xfunc-optimization">
<!--==========================orignal english content==========================
   <title>Function Optimization Information</title>
____________________________________________________________________________-->
   <title>函数优化信息</title>

<!--==========================orignal english content==========================
  <indexterm zone="xfunc-optimization">
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="xfunc-optimization">
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    By default, a function is just a <quote>black box</quote> that the
    database system knows very little about the behavior of.  However,
    that means that queries using the function may be executed much less
    efficiently than they could be.  It is possible to supply additional
    knowledge that helps the planner optimize function calls.
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，函数只是一个<quote>black box</quote>，数据库系统对它的行为了解得很少。 
    不过，这意味着使用函数的查询执行效率可能会低于它们的能力。可以提供额外的知识帮助计划器优化函数调用。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some basic facts can be supplied by declarative annotations provided in
    the <xref linkend="sql-createfunction"/> command.  Most important of
    these is the function's <link linkend="xfunc-volatility">volatility
    category</link> (<literal>IMMUTABLE</literal>, <literal>STABLE</literal>,
    or <literal>VOLATILE</literal>); one should always be careful to
    specify this correctly when defining a function.
    The parallel safety property (<literal>PARALLEL
    UNSAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or
    <literal>PARALLEL SAFE</literal>) must also be specified if you hope
    to use the function in parallelized queries.
    It can also be useful to specify the function's estimated execution
    cost, and/or the number of rows a set-returning function is estimated
    to return.  However, the declarative way of specifying those two
    facts only allows specifying a constant value, which is often
    inadequate.
   </para>
____________________________________________________________________________-->
   <para>
    一些基本事实可以通过<xref linkend="sql-createfunction"/>命令中提供的声明性注释来提供。
    这里面最重要的是函数的<link linkend="xfunc-volatility">volatility category</link> (<literal>IMMUTABLE</literal>、 <literal>STABLE</literal>或 <literal>VOLATILE</literal>)；在定义函数时，要始终小心地正确指定这个。
    并行安全属性(<literal>PARALLEL UNSAFE</literal>、<literal>PARALLEL RESTRICTED</literal>或<literal>PARALLEL SAFE</literal>)也必须被指定，如果你希望在并行查询中使用该函数。
    指定函数的估算执行开销也会有作用，和/或集返回函数估计返回的行数。不过，指定这两个事实的声明方式只允许指定常数值，而这通常是不够的。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is also possible to attach a <firstterm>planner support
    function</firstterm> to a SQL-callable function (called
    its <firstterm>target function</firstterm>), and thereby provide
    knowledge about the target function that is too complex to be
    represented declaratively.  Planner support functions have to be
    written in C (although their target functions might not be), so this is
    an advanced feature that relatively few people will use.
   </para>
____________________________________________________________________________-->
   <para>
    也可以将一个<firstterm>planner support function</firstterm> 附加到SQL-可调用函数（称为<firstterm>target function</firstterm>），
    从而提供关于目标函数的知识，该函数过于复杂而无法以声明方式表示。
    计划器支持函数必须写在 C 中（尽管它们的目标函数可以不是），所以这是一个高级功能，相对很少有人会使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    A planner support function must have the SQL signature
<programlisting>
supportfn(internal) returns internal
</programlisting>
    It is attached to its target function by specifying
    the <literal>SUPPORT</literal> clause when creating the target function.
   </para>
____________________________________________________________________________-->
   <para>
    计划器支持函数必须具有SQL签名
<programlisting>
supportfn(internal) returns internal
</programlisting>
    当建立目标函数时，它通过指定<literal>SUPPORT</literal>子句附加到它的目标函数。
   </para>

<!--==========================orignal english content==========================
   <para>
    The details of the API for planner support functions can be found in
    file <filename>src/include/nodes/supportnodes.h</filename> in the
    <productname>PostgreSQL</productname> source code.  Here we provide
    just an overview of what planner support functions can do.
    The set of possible requests to a support function is extensible,
    so more things might be possible in future versions.
   </para>
____________________________________________________________________________-->
   <para>
    计划器支持函数的 API 的详细信息可以在 <productname>PostgreSQL</productname>源代码中的<filename>src/include/nodes/supportnodes.h</filename>文件中找到。 
    这里我们提供了计划器支持函数的概述。支持函数的可能请求集合是可扩展的，所以在将来的版本中可能会有更多(功能)。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some function calls can be simplified during planning based on
    properties specific to the function.  For example,
    <literal>int4mul(n, 1)</literal> could be simplified to
    just <literal>n</literal>.  This type of transformation can be
    performed by a planner support function, by having it implement
    the <literal>SupportRequestSimplify</literal> request type.
    The support function will be called for each instance of its target
    function found in a query parse tree.  If it finds that the particular
    call can be simplified into some other form, it can build and return a
    parse tree representing that expression.  This will automatically work
    for operators based on the function, too &mdash; in the example just
    given, <literal>n * 1</literal> would also be simplified to
    <literal>n</literal>.
    (But note that this is just an example; this particular
    optimization is not actually performed by
    standard <productname>PostgreSQL</productname>.)
    We make no guarantee that <productname>PostgreSQL</productname> will
    never call the target function in cases that the support function could
    simplify.  Ensure rigorous equivalence between the simplified
    expression and an actual execution of the target function.
   </para>
____________________________________________________________________________-->
   <para>
    在规划期间，根据指定函数的特性，一些函数调用可以进行简化。
    例如，<literal>int4mul(n, 1)</literal>可以被简化为<literal>n</literal>。 
    这种类型的转换可以通过计划器支持函数执行，通过它实现<literal>SupportRequestSimplify</literal>请求类型。
    对于在查询解析树中找到其目标函数的每个实例，将调用支持函数。如果它发现特定的调用可以简化成某种其他窗体，它可以构建并返回表示该表达式的解析树。 
    这将为基于函数的操作符自动工作，非常&mdash;在刚才的示例中，<literal>n * 1</literal>也将简化为<literal>n</literal>。
    （但注意这只是一个例子；这个特殊的优化实际上不是标准的<productname>PostgreSQL</productname>执行）。
    我们不保证<productname>PostgreSQL</productname>在支持函数能够简化的情况下，永远不会调用目标函数。 确保简化表达式与目标函数的实际执行之间严格等效。
   </para>

<!--==========================orignal english content==========================
   <para>
    For target functions that return <type>boolean</type>, it is often useful to estimate
    the fraction of rows that will be selected by a <literal>WHERE</literal> clause using that
    function.  This can be done by a support function that implements
    the <literal>SupportRequestSelectivity</literal> request type.
   </para>
____________________________________________________________________________-->
   <para>
    对于返回 <type>boolean</type> 的目标函数，估计使用该函数的 <literal>WHERE</literal> 子句将选择的行的比重通常会有用。
    这可以通过实现<literal>SupportRequestSelectivity</literal>请求类型的支持函数来完成。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the target function's run time is highly dependent on its inputs,
    it may be useful to provide a non-constant cost estimate for it.
    This can be done by a support function that implements
    the <literal>SupportRequestCost</literal> request type.
   </para>
____________________________________________________________________________-->
   <para>
    如果目标函数的运行时间高度依赖于其输入，提供非固定开销估算可能很有用。这可以通过实现<literal>SupportRequestCost</literal>请求类型的支持函数来完成。
   </para>

<!--==========================orignal english content==========================
   <para>
    For target functions that return sets, it is often useful to provide
    a non-constant estimate for the number of rows that will be returned.
    This can be done by a support function that implements
    the <literal>SupportRequestRows</literal> request type.
   </para>
____________________________________________________________________________-->
   <para>
    对于返回集的目标函数，为提供要返回的行数的非常量估计通常很有用。这可以通过实现<literal>SupportRequestRows</literal>请求类型的支持函数来完成。
   </para>

<!--==========================orignal english content==========================
   <para>
    For target functions that return <type>boolean</type>, it may be possible to
    convert a function call appearing in <literal>WHERE</literal> into an indexable operator
    clause or clauses.  The converted clauses might be exactly equivalent
    to the function's condition, or they could be somewhat weaker (that is,
    they might accept some values that the function condition does not).
    In the latter case the index condition is said to
    be <firstterm>lossy</firstterm>; it can still be used to scan an index,
    but the function call will have to be executed for each row returned by
    the index to see if it really passes the <literal>WHERE</literal> condition or not.
    To create such conditions, the support function must implement
    the <literal>SupportRequestIndexCondition</literal> request type.
   </para>
____________________________________________________________________________-->
   <para>
    对于返回 <type>boolean</type>的目标函数，可以将<literal>WHERE</literal>中出现的函数调用转换为一个可索引操作符子句或多个子句。
    转换的子句可能与函数的条件完全相同，或者它们可能比较弱态一些(也就是说，它们可能接受函数条件所不接受的一些值)。
    在后一种情况下，索引条件被称作<firstterm>lossy</firstterm>；它仍然可用于扫描索引，但必须为索引返回的每一行执行函数调用，以看它是否真的通过 <literal>WHERE</literal>条件或没有。
    要建立这样的条件，支持函数必须实现<literal>SupportRequestIndexCondition</literal>需求类型。
   </para>
  </sect1>