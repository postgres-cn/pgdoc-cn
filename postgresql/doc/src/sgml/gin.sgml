<!-- doc/src/sgml/gin.sgml -->

<chapter id="GIN">
<!--==========================orignal english content==========================
<title>GIN Indexes</title>
____________________________________________________________________________-->
<title>GIN 索引</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>索引</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
<!--==========================orignal english content==========================
 <title>Introduction</title>
____________________________________________________________________________-->
 <title>简介</title>

<!--==========================orignal english content==========================
 <para>
  <acronym>GIN</acronym> stands for Generalized Inverted Index.
  <acronym>GIN</acronym> is designed for handling cases where the items
  to be indexed are composite values, and the queries to be handled by
  the index need to search for element values that appear within
  the composite items.  For example, the items could be documents,
  and the queries could be searches for documents containing specific words.
 </para>
____________________________________________________________________________-->
 <para>
  <acronym>GIN</acronym>意思是通用倒排索引。<acronym>GIN</acronym>被设计为处理被索引项为组合值的情况，并且这种索引所处理的查询需要搜索出现在组合项中的元素值。例如，项可以是文档，并且查询可以是搜索包含指定词的文档。
 </para>

<!--==========================orignal english content==========================
 <para>
  We use the word <firstterm>item</> to refer to a composite value that
  is to be indexed, and the word <firstterm>key</> to refer to an element
  value.  <acronym>GIN</acronym> always stores and searches for keys,
  not item values per se.
 </para>
____________________________________________________________________________-->
 <para>
  我们使用词<firstterm>项</>来表示要被索引的一个组合值，并且用词<firstterm>键</>来表示一个元素值。<acronym>GIN</acronym>总是存储和搜索键，而不是项值本身。
 </para>

<!--==========================orignal english content==========================
 <para>
  A <acronym>GIN</acronym> index stores a set of (key, posting list) pairs,
  where a <firstterm>posting list</> is a set of row IDs in which the key
  occurs.  The same row ID can appear in multiple posting lists, since
  an item can contain more than one key.  Each key value is stored only
  once, so a <acronym>GIN</acronym> index is very compact for cases
  where the same key appears many times.
 </para>
____________________________________________________________________________-->
 <para>
  一个<acronym>GIN</acronym>存储一个（键，位置列表）对的集合，这里一个<firstterm>posting list</>是键在其中出现的一个行 ID 的集合。相同的行 ID 可以出现在多个位置列表中，因为一个项可以包含多于一个键。每个键值只被存储一次，因此对于同一个键出现多次的情况，一个<acronym>GIN</acronym>索引是非常紧凑的。
 </para>

<!--==========================orignal english content==========================
 <para>
  <acronym>GIN</acronym> is generalized in the sense that the
  <acronym>GIN</acronym> access method code does not need to know the
  specific operations that it accelerates.
  Instead, it uses custom strategies defined for particular data types.
  The strategy defines how keys are extracted from indexed items and
  query conditions, and how to determine whether a row that contains
  some of the key values in a query actually satisfies the query.
 </para>
____________________________________________________________________________-->
 <para>
  <acronym>GIN</acronym>访问方法代码不需要知道它所加速的是什么操作，从这个意义上来说，<acronym>GIN</acronym>是通用的。相反，它使用为特定数据类型定义的自定义策略。策略定义如何从被索引项和查询条件中抽取键，并且如何决定一个包含查询中某些键值的行是否真正满足查询。
 </para>

<!--==========================orignal english content==========================
 <para>
  One advantage of <acronym>GIN</acronym> is that it allows the development
  of custom data types with the appropriate access methods, by
  an expert in the domain of the data type, rather than a database expert.
  This is much the same advantage as using <acronym>GiST</acronym>.
 </para>
____________________________________________________________________________-->
 <para>
  <acronym>GIN</acronym>的一个优点是它允许由数据类型的领域专家开发有合适访问方法的自定义数据类型，而不是让一个数据库专家来做这件事。在这一点上很像<acronym>GiST</acronym>。
 </para>

<!--==========================orignal english content==========================
 <para>
  The <acronym>GIN</acronym>
  implementation in <productname>PostgreSQL</productname> is primarily
  maintained by Teodor Sigaev and Oleg Bartunov. There is more
  information about <acronym>GIN</acronym> on their
  <ulink url="http://www.sai.msu.su/~megera/wiki/Gin">website</ulink>.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>中的<acronym>GIN</acronym>实现主要由 Teodor Sigaev 和 Oleg Bartunov 维护。在他们的<ulink url="http://www.sai.msu.su/~megera/wiki/Gin">网站</ulink>上有更多关于<acronym>GIN</acronym>的信息。
 </para>
</sect1>

<sect1 id="gin-builtin-opclasses">
<!--==========================orignal english content==========================
 <title>Built-in Operator Classes</title>
____________________________________________________________________________-->
 <title>内建操作符类</title>

<!--==========================orignal english content==========================
 <para>
  The core <productname>PostgreSQL</> distribution
  includes the <acronym>GIN</acronym> operator classes shown in
  <xref linkend="gin-builtin-opclasses-table">.
  (Some of the optional modules described in <xref linkend="contrib">
  provide additional <acronym>GIN</acronym> operator classes.)
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</>的核心发布包括<xref linkend="gin-builtin-opclasses-table">
  中所示的<acronym>GIN</acronym>操作符类（<xref linkend="contrib">中描述的一些
  可选模块提供了额外的<acronym>GIN</acronym>操作符类）。
 </para>

  <table id="gin-builtin-opclasses-table">
<!--==========================orignal english content==========================
   <title>Built-in <acronym>GIN</acronym> Operator Classes</title>
____________________________________________________________________________-->
   <title>内建<acronym>GIN</acronym>操作符类</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Indexed Data Type</entry>
      <entry>Indexable Operators</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>索引数据类型</entry>
      <entry>可索引操作符</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>array_ops</></entry>
      <entry><type>anyarray</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>array_ops</></entry>
      <entry><type>anyarray</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>jsonb_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>?</>
       <literal>?&amp;</>
       <literal>?|</>
       <literal>@&gt;</>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>jsonb_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>?</>
       <literal>?&amp;</>
       <literal>?|</>
       <literal>@&gt;</>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>jsonb_path_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>@&gt;</>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>jsonb_path_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>@&gt;</>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>tsvector_ops</></entry>
      <entry><type>tsvector</></entry>
      <entry>
       <literal>@@</>
       <literal>@@@</>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>tsvector_ops</></entry>
      <entry><type>tsvector</></entry>
      <entry>
       <literal>@@</>
       <literal>@@@</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
 <para>
  Of the two operator classes for type <type>jsonb</>, <literal>jsonb_ops</>
  is the default.  <literal>jsonb_path_ops</> supports fewer operators but
  offers better performance for those operators.
  See <xref linkend="json-indexing"> for details.
 </para>
____________________________________________________________________________-->
 <para>
  在两种用于类型<type>jsonb</>的操作符类中，<literal>jsonb_ops</>是默认项。
  <literal>jsonb_path_ops</>支持较少的操作符但是为那些操作符提供了更好的性能。
  详见<xref linkend="json-indexing">。
 </para>

</sect1>

<sect1 id="gin-extensibility">
<!--==========================orignal english content==========================
 <title>Extensibility</title>
____________________________________________________________________________-->
 <title>可扩展性</title>

<!--==========================orignal english content==========================
 <para>
   The <acronym>GIN</acronym> interface has a high level of abstraction,
   requiring the access method implementer only to implement the semantics of
   the data type being accessed.  The <acronym>GIN</acronym> layer itself
   takes care of concurrency, logging and searching the tree structure.
 </para>
____________________________________________________________________________-->
 <para>
   <acronym>GIN</acronym>接口有一个高层次的抽象，要求访问方法实现者只需要实现数据类型被访问的语义。<acronym>GIN</acronym>层本身会操心并发、日志和搜索树结构的事情。
 </para>

<!--==========================orignal english content==========================
 <para>
   All it takes to get a <acronym>GIN</acronym> access method working is to
   implement a few user-defined methods, which define the behavior of
   keys in the tree and the relationships between keys, indexed items,
   and indexable queries. In short, <acronym>GIN</acronym> combines
   extensibility with generality, code reuse, and a clean interface.
 </para>
____________________________________________________________________________-->
 <para>
   要让一个<acronym>GIN</acronym>访问方法工作起来所要做的全部事情就是实现一些用户定义的方法，它们定义了树中键的行为以及键、被索引项以及可索引查询之间的关系。简而言之，<acronym>GIN</acronym>的可扩展性结合了通用性、代码重用和一个干净的接口。
 </para>

<!--==========================orignal english content==========================
 <para>
   There are two methods that an operator class for
   <acronym>GIN</acronym> must provide:

  <variablelist>
    <varlistentry>
     <term><function>Datum *extractValue(Datum itemValue, int32 *nkeys,
        bool **nullFlags)</></term>
     <listitem>
      <para>
       Returns a palloc'd array of keys given an item to be indexed.  The
       number of returned keys must be stored into <literal>*nkeys</>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> <type>bool</type> fields, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left <symbol>NULL</symbol> (its initial value)
       if all keys are non-null.
       The return value can be <symbol>NULL</symbol> if the item contains no keys.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractQuery(Datum query, int32 *nkeys,
        StrategyNumber n, bool **pmatch, Pointer **extra_data,
        bool **nullFlags, int32 *searchMode)</></term>
     <listitem>
      <para>
       Returns a palloc'd array of keys given a value to be queried; that is,
       <literal>query</> is the value on the right-hand side of an
       indexable operator whose left-hand side is the indexed column.
       <literal>n</> is the strategy number of the operator within the
       operator class (see <xref linkend="xindex-strategies">).
       Often, <function>extractQuery</> will need
       to consult <literal>n</> to determine the data type of
       <literal>query</> and the method it should use to extract key values.
       The number of returned keys must be stored into <literal>*nkeys</>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> <type>bool</type> fields, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left <symbol>NULL</symbol> (its initial value)
       if all keys are non-null.
       The return value can be <symbol>NULL</symbol> if the <literal>query</> contains no keys.
      </para>

      <para>
       <literal>searchMode</> is an output argument that allows
       <function>extractQuery</> to specify details about how the search
       will be done.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_DEFAULT</> (which is the value it is
       initialized to before call), only items that match at least one of
       the returned keys are considered candidate matches.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_INCLUDE_EMPTY</>, then in addition to items
       containing at least one matching key, items that contain no keys at
       all are considered candidate matches.  (This mode is useful for
       implementing is-subset-of operators, for example.)
       If <literal>*searchMode</> is set to <literal>GIN_SEARCH_MODE_ALL</>,
       then all non-null items in the index are considered candidate
       matches, whether they match any of the returned keys or not.  (This
       mode is much slower than the other two choices, since it requires
       scanning essentially the entire index, but it may be necessary to
       implement corner cases correctly.  An operator that needs this mode
       in most cases is probably not a good candidate for a GIN operator
       class.)
       The symbols to use for setting this mode are defined in
       <filename>access/gin.h</>.
      </para>

      <para>
       <literal>pmatch</> is an output argument for use when partial match
       is supported.  To use it, <function>extractQuery</> must allocate
       an array of <literal>*nkeys</> booleans and store its address at
       <literal>*pmatch</>.  Each element of the array should be set to TRUE
       if the corresponding key requires partial match, FALSE if not.
       If <literal>*pmatch</> is set to <symbol>NULL</symbol> then GIN assumes partial match
       is not required.  The variable is initialized to <symbol>NULL</symbol> before call,
       so this argument can simply be ignored by operator classes that do
       not support partial match.
      </para>

      <para>
       <literal>extra_data</> is an output argument that allows
       <function>extractQuery</> to pass additional data to the
       <function>consistent</> and <function>comparePartial</> methods.
       To use it, <function>extractQuery</> must allocate
       an array of <literal>*nkeys</> pointers and store its address at
       <literal>*extra_data</>, then store whatever it wants to into the
       individual pointers.  The variable is initialized to <symbol>NULL</symbol> before
       call, so this argument can simply be ignored by operator classes that
       do not require extra data.  If <literal>*extra_data</> is set, the
       whole array is passed to the <function>consistent</> method, and
       the appropriate element to the <function>comparePartial</> method.
      </para>

     </listitem>
    </varlistentry>
  </variablelist>

  An operator class must also provide a function to check if an indexed item
  matches the query. It comes in two flavors, a boolean <function>consistent</>
  function, and a ternary <function>triConsistent</> function.
  <function>triConsistent</> covers the functionality of both, so providing
  <function>triConsistent</> alone is sufficient. However, if the boolean
  variant is significantly cheaper to calculate, it can be advantageous to
  provide both.  If only the boolean variant is provided, some optimizations
  that depend on refuting index items before fetching all the keys are
  disabled.

  <variablelist>
    <varlistentry>
     <term><function>bool consistent(bool check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[], bool *recheck,
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
       Returns TRUE if an indexed item satisfies the query operator with
       strategy number <literal>n</> (or might satisfy it, if the recheck
       indication is returned).  This function does not have direct access
       to the indexed item's value, since <acronym>GIN</acronym> does not
       store items explicitly.  Rather, what is available is knowledge
       about which key values extracted from the query appear in a given
       indexed item.  The <literal>check</> array has length
       <literal>nkeys</>, which is the same as the number of keys previously
       returned by <function>extractQuery</> for this <literal>query</> datum.
       Each element of the
       <literal>check</> array is TRUE if the indexed item contains the
       corresponding query key, i.e., if (check[i] == TRUE) the i-th key of the
       <function>extractQuery</> result array is present in the indexed item.
       The original <literal>query</> datum is
       passed in case the <function>consistent</> method needs to consult it,
       and so are the <literal>queryKeys[]</> and <literal>nullFlags[]</>
       arrays previously returned by <function>extractQuery</>.
       <literal>extra_data</> is the extra-data array returned by
       <function>extractQuery</>, or <symbol>NULL</symbol> if none.
      </para>

      <para>
       When <function>extractQuery</> returns a null key in
       <literal>queryKeys[]</>, the corresponding <literal>check[]</> element
       is TRUE if the indexed item contains a null key; that is, the
       semantics of <literal>check[]</> are like <literal>IS NOT DISTINCT
       FROM</>.  The <function>consistent</> function can examine the
       corresponding <literal>nullFlags[]</> element if it needs to tell
       the difference between a regular value match and a null match.
      </para>

      <para>
       On success, <literal>*recheck</> should be set to TRUE if the heap
       tuple needs to be rechecked against the query operator, or FALSE if
       the index test is exact.  That is, a FALSE return value guarantees
       that the heap tuple does not match the query; a TRUE return value with
       <literal>*recheck</> set to FALSE guarantees that the heap tuple does
       match the query; and a TRUE return value with
       <literal>*recheck</> set to TRUE means that the heap tuple might match
       the query, so it needs to be fetched and rechecked by evaluating the
       query operator directly against the originally indexed item.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[],
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
       <function>triConsistent</> is similar to <function>consistent</>,
       but instead of booleans in the <literal>check</> vector, there are
       three possible values for each
       key: <literal>GIN_TRUE</>, <literal>GIN_FALSE</> and
       <literal>GIN_MAYBE</>. <literal>GIN_FALSE</> and <literal>GIN_TRUE</>
       have the same meaning as regular boolean values, while
       <literal>GIN_MAYBE</> means that the presence of that key is not known.
       When <literal>GIN_MAYBE</> values are present, the function should only
       return <literal>GIN_TRUE</> if the item certainly matches whether or
       not the index item contains the corresponding query keys. Likewise, the
       function must return <literal>GIN_FALSE</> only if the item certainly
       does not match, whether or not it contains the <literal>GIN_MAYBE</>
       keys. If the result depends on the <literal>GIN_MAYBE</> entries, i.e.,
       the match cannot be confirmed or refuted based on the known query keys,
       the function must return <literal>GIN_MAYBE</>.
      </para>
      <para>
       When there are no <literal>GIN_MAYBE</> values in the <literal>check</>
       vector, a <literal>GIN_MAYBE</> return value is the equivalent of
       setting the <literal>recheck</> flag in the
       boolean <function>consistent</> function.
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </para>
____________________________________________________________________________-->
 <para>
   一个用于<acronym>GIN</acronym>的操作符类必须提供的两个方法是：

 <variablelist>

    <varlistentry>
     <term><function>Datum *extractValue(Datum itemValue, int32 *nkeys,
        bool **nullFlags)</></term>
     <listitem>
      <para>
       给定一个要被索引的项，返回一个 palloc 过的键的数组。被返回的键的数量必须被存储在<literal>*nkeys</>中。如果键中的任意一个可能为空，还要 palloc 一个<literal>*nkeys</> 个<type>bool</type>域的数组，将它的地址存储在<literal>*nullFlags</>中，并且根据需要设置这些空值标志。如果所有的键都非空，<literal>*nullFlags</>可以被留成<symbol>NULL</symbol>（其初始值）。如果该项不包含键，返回值可以为<symbol>NULL</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractQuery(Datum query, int32 *nkeys,
        StrategyNumber n, bool **pmatch, Pointer **extra_data,
        bool **nullFlags, int32 *searchMode)</></term>
     <listitem>
      <para>
       给定一个要被查询的值，返回一个 palloc 过的键的数组。即<literal>query</>是一个可索引操作符（左手边是被索引列）的右手边的值。<literal>n</>是操作符类中操作符的策略号（见<xref linkend="xindex-strategies">）。通常，<function>extractQuery</>将需要参考<literal>n</>来判断<literal>query</>的数据类型以及它应该用什么方法来抽取键值。被返回的键的数量必须被存储在<literal>*nkeys</>中。如果键中的任意一个可能为空，还要 palloc 一个<literal>*nkeys</> 个<type>bool</type>域的数组，将它的地址存储在<literal>*nullFlags</>中，并且根据需要设置这些空值标志。如果所有的键都非空，<literal>*nullFlags</>可以被留成<symbol>NULL</symbol>（其初始值）。如果该项不包含键，返回值可以为<symbol>NULL</symbol>。
      </para>

      <para>
       <literal>searchMode</>是一个输出参数，它允许<function>extractQuery</>指定有关搜索如何被完成的细节。如果<literal>*searchMode</>被设置为<literal>GIN_SEARCH_MODE_DEFAULT</>（这是在被调用之前它被初始化的值），只有那些匹配至少一个被返回键的项才会被考虑作为候选匹配。如果<literal>*searchMode</>被设置为<literal>GIN_SEARCH_MODE_INCLUDE_EMPTY</>，那么除了至少包含一个匹配键的项之外，根本不包含键的项也被考虑作为候选匹配（例如，这种模式对于实现“是...的子集”操作符有用）。如果<literal>*searchMode</>被设置为<literal>GIN_SEARCH_MODE_ALL</>，那么索引中所有非空项都被考虑作为候选匹配，不管它们是否匹配被返回的键（这种模式比其他两种选择要慢很多，但是它对于正确实现极端情况可能是必要的。需要这种模式的操作符在大部分情况下可能并不是一个 GIN 操作符类的好选择）。用于设置这个模式的符号被定义在<filename>access/gin.h</>中。
      </para>

      <para>
       <literal>pmatch</>是一个输出参数，它用于在部分匹配匹配被支持时使用。要用它，<function>extractQuery</>必须分配一个<literal>*nkeys</>个布尔值的数组，并且把它的地址存储在<literal>*pmatch</>中。如果一个键要求部分匹配，该数组的对应元素应该被设置为 TRUE，否则设置为 FALSE。如果<literal>*pmatch</>被设置为<symbol>NULL</symbol>，则 GIN 假定不需要部分匹配。在调用前，该变量被初始化为<symbol>NULL</symbol>，这样这个参数可以简单地被不支持部分匹配的操作符类忽略。
      </para>

      <para>
       <literal>extra_data</>是一个输出参数，它允许<function>extractQuery</>传递额外数据给<function>consistent</>和<function>comparePartial</>方法。要用它，<function>extractQuery</>必须分配一个<literal>*nkeys</>个指针的数组，并且把它的地址存储在<literal>*extra_data</>中，然后把任何它想存储的东西存到单个指针中。在调用前该变量被初始化为<symbol>NULL</symbol>，这样这个参数可以简单地被不需要额外数据的操作符类忽略。如果<literal>*extra_data</>被设置，整个数组被传递给<function>consistent</>方法，并且适当的元素会被传递给<function>comparePartial</>方法。
      </para>

     </listitem>
    </varlistentry>
</variablelist>

  一个操作符类必须提供一个函数检查一个被索引的项是否匹配查询。有两种形式，
  一个布尔函数<function>consistent</>，以及一个三元函数<function>triConsistent</>。
  <function>triConsistent</>覆盖了两者的功能，因此提供<function>triConsistent</>一个足矣。但是，
  如果布尔变体的计算代价要更低，两者都提供就会有好处。如果只提供布尔变体，
  一些基于在取得所有键之前拒绝索引项的优化将会被禁用。

  <variablelist>

    <varlistentry>
     <term><function>bool consistent(bool check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[], bool *recheck,
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
       如果一个被索引项满足（如果重新检查指示被返回，则表示可能满足）有策略号<literal>n</>的查询操作符，则返回 TRUE。这个函数并没有直接访问被索引项的值，因为<acronym>GIN</acronym>没有显式存储项。可用的是关于哪些从查询抽取出的键值出现在一个给定被索引项中的知识。<literal>check</>数组的长度是<literal>nkeys</>，它和前面由<function>extractQuery</>为这个<literal>查询</>数据返回的键的数目相同。
       如果被索引项包含一个查询键，那么<literal>check</>数组的对应元素为 TRUE，即如果 (check[i] == TRUE) ，则<function>extractQuery</>结果数组的第 i 个键存在于被索引项中。在<function>consistent</>方法需要参考原始<literal>query</>数据的情况中，它会被传递进来，前面由<function>extractQuery</>返回的<literal>queryKeys[]</>和<literal>nullFlags[]</>数组也一样。<literal>extra_data</>是由<function>extractQuery</>返回的额外数据数组，如果没有额外数据则为<symbol>NULL</symbol>。
      </para>

      <para>
       当<function>extractQuery</>在<literal>queryKeys[]</>中返回一个空值键时，如果被索引项包含一个空值键则对应的<literal>check[]</>元素为 TRUE。即，<literal>check[]</>的语义类似<literal>IS NOT DISTINCT FROM</>。如果<function>consistent</>函数需要说出一个常规值匹配和一个空值匹配之间的区别，它可以检查对应的<literal>nullFlags[]</>元素。
      </para>

      <para>
       在成功时，如果堆元组需要根据查询操作符被重新检查，则<literal>*recheck</>应该被设置为 TRUE，或者如果索引测试是准确的则设置为 FALSE。即，一个 FALSE 返回值保证堆元组不匹配查询；一个 TRUE 返回值以及设置为 FALSE 的<literal>*recheck</>保证堆元组匹配查询；并且一个 TRUE 返回值和设置为 TRUE 的<literal>*recheck</>表示堆元组可能匹配查询，因此它需要被取出并且通过在原始的被索引项上计算查询操作符来重新检查。
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><function>GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[],
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
       <function>triConsistent</>类似于<function>consistent</>，
       但和<literal>check[]</>中的布尔值不同，对每个键有三种可能值：
       <literal>GIN_TRUE</>、<literal>GIN_FALSE</>和<literal>GIN_MAYBE</>。
       <literal>GIN_FALSE</>和<literal>GIN_TRUE</>具有和常规布尔值相同的含义，
       而<literal>GIN_MAYBE</>意味着键的存在未知。当<literal>GIN_MAYBE</>值出现时，
       如果项必定匹配（不管该索引项是否包含对应的查询键），该函数应该只返回<literal>GIN_TRUE</>。
       同样地，如果项必定不匹配（不管它是否包含<literal>GIN_MAYBE</>），
       该函数必须只返回<literal>GIN_FALSE</>。
       如果结果依赖于<literal>GIN_MAYBE</>项，即无法根据已知查询键确认或拒绝匹配，
       该函数必须返回<literal>GIN_MAYBE</>。
      </para>
      <para>
       当在<literal>check</>向量中没有<literal>GIN_MAYBE</>值时，
       <literal>GIN_MAYBE</>返回值等效于在布尔函数<function>consistent</>中设置
       <literal>recheck</>标志等效。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </para>

<!--==========================orignal english content==========================
 <para>
  In addition, GIN must have a way to sort the key values stored in the index.
  The operator class can define the sort ordering by specifying a comparison
  method:

  <variablelist>
    <varlistentry>
     <term><function>int compare(Datum a, Datum b)</></term>
     <listitem>
      <para>
       Compares two keys (not indexed items!) and returns an integer less than
       zero, zero, or greater than zero, indicating whether the first key is
       less than, equal to, or greater than the second.  Null keys are never
       passed to this function.
      </para>
     </listitem>
    </varlistentry>
  </variablelist>

  Alternatively, if the operator class does not provide a <function>compare</>
  method, GIN will look up the default btree operator class for the index
  key data type, and use its comparison function.  It is recommended to
  specify the comparison function in a GIN operator class that is meant for
  just one data type, as looking up the btree operator class costs a few
  cycles.  However, polymorphic GIN operator classes (such
  as <literal>array_ops</>) typically cannot specify a single comparison
  function.
 </para>
____________________________________________________________________________-->
 <para>
  另外，GIN必须有一种方法来对存储在索引中的键值进行排序。
  运算符类可以通过指定比较方法来定义排序顺序：

  <variablelist>
    <varlistentry>
     <term><function>int compare(Datum a, Datum b)</></term>
     <listitem>
      <para>
       比较两个键（不是被索引项）并且返回一个整数，整数可以是小于零、零、大于零，分别表示第一个键小于、等于、大于第二个键。空值键不会被传递给这个函数。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>

  或者，如果运算符类没有提供<function>compare</>方法，
  GIN将查找索引键数据类型的默认btree运算符类，并使用它的比较函数。
  建议在仅用于一种数据类型的GIN操作符类中指定比较函数，
  因为查找btree操作符类会花费几个周期。但是，多态GIN操作符类
  （如<literal>array_ops</>）通常不能指定单个比较函数。
 </para>

<!--==========================orignal english content==========================
 <para>
  Optionally, an operator class for <acronym>GIN</acronym> can supply the
  following method:

  <variablelist>
    <varlistentry>
     <term><function>int comparePartial(Datum partial_key, Datum key, StrategyNumber n,
                              Pointer extra_data)</></term>
     <listitem>
      <para>
       Compare a partial-match query key to an index key.  Returns an integer
       whose sign indicates the result: less than zero means the index key
       does not match the query, but the index scan should continue; zero
       means that the index key does match the query; greater than zero
       indicates that the index scan should stop because no more matches
       are possible.  The strategy number <literal>n</> of the operator
       that generated the partial match query is provided, in case its
       semantics are needed to determine when to end the scan.  Also,
       <literal>extra_data</> is the corresponding element of the extra-data
       array made by <function>extractQuery</>, or <symbol>NULL</symbol> if none.
       Null keys are never passed to this function.
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </para>
____________________________________________________________________________-->
 <para>
  可选的，一个用于<acronym>GIN</acronym>的操作符类可以提供下列方法：

  <variablelist>
    <varlistentry>
     <term><function>int comparePartial(Datum partial_key, Datum key, StrategyNumber n,
                              Pointer extra_data)</></term>
     <listitem>
      <para>
       比较一个部分匹配键和一个索引键。返回一个整数，其符号指示结果：小于零表示索引键不匹配查询，但是索引扫描应该继续；零表示索引键匹配查询；大于零表示索引扫描应该停止，因为没有更多可能的匹配。产生该部分匹配查询的操作符的策略号<literal>n</>将被提供，可以通过其语义决定什么时候结束扫描。还有，<literal>extra_data</>是由<function>extractQuery</>产生的额外数据数组中的对应元素，如果没有则为<symbol>NULL</symbol>。空值不会被传递给这个函数。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </para>

<!--==========================orignal english content==========================
 <para>
  To support <quote>partial match</> queries, an operator class must
  provide the <function>comparePartial</> method, and its
  <function>extractQuery</> method must set the <literal>pmatch</>
  parameter when a partial-match query is encountered.  See
  <xref linkend="gin-partial-match"> for details.
 </para>
____________________________________________________________________________-->
 <para>
  要支持<quote>部分匹配</>查询，一个操作符类必须提供<function>comparePartial</>方法，并且它的<function>extractQuery</>方法必须在遇到一个部分匹配查询时设置<literal>pmatch</>参数。详见<xref linkend="gin-partial-match">。
 </para>

<!--==========================orignal english content==========================
 <para>
  The actual data types of the various <literal>Datum</> values mentioned
  above vary depending on the operator class.  The item values passed to
  <function>extractValue</> are always of the operator class's input type, and
  all key values must be of the class's <literal>STORAGE</> type.  The type of
  the <literal>query</> argument passed to <function>extractQuery</>,
  <function>consistent</> and <function>triConsistent</> is whatever is the
  right-hand input type of the class member operator identified by the
  strategy number.  This need not be the same as the indexed type, so long as
  key values of the correct type can be extracted from it.  However, it is
  recommended that the SQL declarations of these three support functions use
  the opclass's indexed data type for the <literal>query</> argument, even
  though the actual type might be something else depending on the operator.
 </para>
____________________________________________________________________________-->
 <para>
  上面提到的多个<literal>Datum</>值的实际数据类型随着操作符类而变化。
  被传递给<function>extractValue</>的项值总是操作符类的输入类型，
  并且所有的键值必须是类的<literal>STORAGE</>类型。被传递给<function>extractQuery</>、
  <function>consistent</>和<function>triConsistent</>的<literal>query</>
  参数是由该策略号标识的类成员操作符的右手边输入类型。
  这不需要和被索引类型相同，只要正确类型的键值能从其中被抽取出来。不过，
  推荐这三个支持函数的 SQL 声明对<literal>query</>参数使用操作符类的被
  索引数据类型，即便实际类型可能是某种其他依赖于操作符的东西时也应如此。
 </para>

</sect1>

<sect1 id="gin-implementation">
<!--==========================orignal english content==========================
 <title>Implementation</title>
____________________________________________________________________________-->
 <title>实现</title>

<!--==========================orignal english content==========================
 <para>
  Internally, a <acronym>GIN</acronym> index contains a B-tree index
  constructed over keys, where each key is an element of one or more indexed
  items (a member of an array, for example) and where each tuple in a leaf
  page contains either a pointer to a B-tree of heap pointers (a
  <quote>posting tree</>), or a simple list of heap pointers (a <quote>posting
  list</>) when the list is small enough to fit into a single index tuple along
  with the key value.
 </para>
____________________________________________________________________________-->
 <para>
  在内部，一个<acronym>GIN</acronym>索引包含一个在键上构建的 B 树索引，其中每一个键是一个或者多个被索引项的一个元素（例如，数组的一个成员），并且叶子页中的每一个元组包含一个指向堆指针 B 树的指针（一个<quote>位置树</>）或者一个堆指针的简单列表（<quote>位置列表</>），只有位置列表小到能够和键值一起放入索引时才使用后一种形式。
 </para>

<!--==========================orignal english content==========================
 <para>
  As of <productname>PostgreSQL</productname> 9.1, null key values can be
  included in the index.  Also, placeholder nulls are included in the index
  for indexed items that are null or contain no keys according to
  <function>extractValue</>.  This allows searches that should find empty
  items to do so.
 </para>
____________________________________________________________________________-->
 <para>
  自<productname>PostgreSQL</productname> 9.1 起，空键值可以被包括在索引中。同样，用于为空或者根据<function>extractValue</>不包含键的被索引项的占位符空值也被包括在索引中。这允许实现应该找到空项的搜索。
 </para>

<!--==========================orignal english content==========================
 <para>
  Multicolumn <acronym>GIN</acronym> indexes are implemented by building
  a single B-tree over composite values (column number, key value).  The
  key values for different columns can be of different types.
 </para>
____________________________________________________________________________-->
 <para>
  多列<acronym>GIN</acronym>索引可以通过在组合值（列号，键值）上建立一个单一 B 树实现。不同列的键值可以是不同类型。
 </para>

 <sect2 id="gin-fast-update">
<!--==========================orignal english content==========================
  <title>GIN Fast Update Technique</title>
____________________________________________________________________________-->
  <title>GIN 快速更新技术</title>

<!--==========================orignal english content==========================
  <para>
   Updating a <acronym>GIN</acronym> index tends to be slow because of the
   intrinsic nature of inverted indexes: inserting or updating one heap row
   can cause many inserts into the index (one for each key extracted
   from the indexed item). As of <productname>PostgreSQL</productname> 8.4,
   <acronym>GIN</> is capable of postponing much of this work by inserting
   new tuples into a temporary, unsorted list of pending entries.
   When the table is vacuumed or autoanalyzed, or when
   <function>gin_clean_pending_list</function> function is called, or if the
   pending list becomes larger than
   <xref linkend="guc-gin-pending-list-limit">, the entries are moved to the
   main <acronym>GIN</acronym> data structure using the same bulk insert
   techniques used during initial index creation.  This greatly improves
   <acronym>GIN</acronym> index update speed, even counting the additional
   vacuum overhead.  Moreover the overhead work can be done by a background
   process instead of in foreground query processing.
  </para>
____________________________________________________________________________-->
  <para>
   更新一个<acronym>GIN</acronym>索引可能会比较慢，这是因为倒排索引的天然特性造成的：
   对一个堆行的插入或更新可能导致对索引的很多次插入（每一次插入用于从被索引项中抽取的一个键）。
   从<productname>PostgreSQL</productname> 8.4 开始，<acronym>GIN</>可以通过将新元组插入到一个临时的未排序的待处理条目列表中来推迟很多这种工作。
   当表被清理、自动分析、<function>gin_clean_pending_list</function>函数被调用
   或者待处理列表变得大于<xref linkend="guc-gin-pending-list-limit">时，
   这些条目被使用初始索引创建时使用的批量插入技术移动到主<acronym>GIN</acronym>数据结构中。
   这大幅度提高了<acronym>GIN</acronym>索引的更新速度，虽然带了一些额外的清理负荷。
   此外，这些开销可以通过用一个后台进程来取代一个前台进程执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   The main disadvantage of this approach is that searches must scan the list
   of pending entries in addition to searching the regular index, and so
   a large list of pending entries will slow searches significantly.
   Another disadvantage is that, while most updates are fast, an update
   that causes the pending list to become <quote>too large</> will incur an
   immediate cleanup cycle and thus be much slower than other updates.
   Proper use of autovacuum can minimize both of these problems.
  </para>
____________________________________________________________________________-->
  <para>
   这种方式的主要缺点是搜索必须在搜索普通索引之外扫描待处理条目的列表，并且因此一个大型的待处理条目列表会显著地拖慢搜索。另一个缺点是，虽然大部分更新变快了，一次导致待处理列表变得<quote>太大</>的更新将导致一次立即清理循环并且因此会比其他更新慢很多。正确使用自动清理可以把这些问题的影响变得最小。
  </para>

<!--==========================orignal english content==========================
  <para>
   If consistent response time is more important than update speed,
   use of pending entries can be disabled by turning off the
   <literal>fastupdate</literal> storage parameter for a
   <acronym>GIN</acronym> index.  See <xref linkend="sql-createindex">
   for details.
  </para>
____________________________________________________________________________-->
  <para>
   如果一致的响应时间比更新速度更重要，可以通过为一个<acronym>GIN</acronym>关闭<literal>fastupdate</literal>存储参数来禁用对待处理条目的使用。详见<xref linkend="sql-createindex">。
  </para>
 </sect2>

 <sect2 id="gin-partial-match">
<!--==========================orignal english content==========================
  <title>Partial Match Algorithm</title>
____________________________________________________________________________-->
  <title>部分匹配算法</title>

<!--==========================orignal english content==========================
  <para>
   GIN can support <quote>partial match</> queries, in which the query
   does not determine an exact match for one or more keys, but the possible
   matches fall within a reasonably narrow range of key values (within the
   key sorting order determined by the <function>compare</> support method).
   The <function>extractQuery</> method, instead of returning a key value
   to be matched exactly, returns a key value that is the lower bound of
   the range to be searched, and sets the <literal>pmatch</> flag true.
   The key range is then scanned using the <function>comparePartial</>
   method.  <function>comparePartial</> must return zero for a matching
   index key, less than zero for a non-match that is still within the range
   to be searched, or greater than zero if the index key is past the range
   that could match.
  </para>
____________________________________________________________________________-->
  <para>
   GIN 可以支持<quote>部分匹配</>查询，在其中查询不能判断一个或多个键的精确匹配，但是可以确定落在键值（在<function>compare</>支持方法决定的键排序顺序中）的一个合理的狭窄范围内的可能匹配。<function>extractQuery</>方法，不会返回一个要被精确匹配的键值，而是返回一个作为要被搜索范围下界的键值，并且将<literal>pmatch</>标志设置为真。然后键范围将被使用<function>comparePartial</>方法扫描。<function>comparePartial</>必须对于一个匹配的索引键返回零，对一个不匹配但仍在要被搜索的范围内的返回小于零，对于超过被搜索范围的索引键返回大于零。
  </para>
 </sect2>

</sect1>

<sect1 id="gin-tips">
<!--==========================orignal english content==========================
<title>GIN Tips and Tricks</title>
____________________________________________________________________________-->
<title>GIN 提示和技巧</title>

 <variablelist>
  <varlistentry>
<!--==========================orignal english content==========================
   <term>Create vs. insert</term>
____________________________________________________________________________-->
   <term>创建 vs. 插入</term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Insertion into a <acronym>GIN</acronym> index can be slow
     due to the likelihood of many keys being inserted for each item.
     So, for bulk insertions into a table it is advisable to drop the GIN
     index and recreate it after finishing bulk insertion.
    </para>
____________________________________________________________________________-->
    <para>
     插入到一个<acronym>GIN</acronym>索引可能会很慢，因为为一个项可能需要插入很多歌键。因此，对于一个表的批量插入，我们建议删除 GIN 索引，然后在完成批量插入后重建它。
    </para>

<!--==========================orignal english content==========================
    <para>
     As of <productname>PostgreSQL</productname> 8.4, this advice is less
     necessary since delayed indexing is used (see <xref
     linkend="gin-fast-update"> for details).  But for very large updates
     it may still be best to drop and recreate the index.
    </para>
____________________________________________________________________________-->
    <para>
     从<productname>PostgreSQL</productname> 8.4 开始，这个建议已经不再需要了，因为可以使用延迟索引（详见<xref linkend="gin-fast-update">）。但是对于非常大量的更新，还是最好先删除再重建索引。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><xref linkend="guc-maintenance-work-mem"></term>
____________________________________________________________________________-->
   <term><xref linkend="guc-maintenance-work-mem"></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Build time for a <acronym>GIN</acronym> index is very sensitive to
     the <varname>maintenance_work_mem</> setting; it doesn't pay to
     skimp on work memory during index creation.
    </para>
____________________________________________________________________________-->
    <para>
     一个<acronym>GIN</acronym>索引的建立时间对<varname>maintenance_work_mem</>设置很敏感；它不考虑在索引创建期间在工作内存上的节省。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><xref linkend="guc-gin-pending-list-limit"></term>
____________________________________________________________________________-->
   <term><xref linkend="guc-gin-pending-list-limit"></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     During a series of insertions into an existing <acronym>GIN</acronym>
     index that has <literal>fastupdate</> enabled, the system will clean up
     the pending-entry list whenever the list grows larger than
     <varname>gin_pending_list_limit</>. To avoid fluctuations in observed
     response time, it's desirable to have pending-list cleanup occur in the
     background (i.e., via autovacuum).  Foreground cleanup operations
     can be avoided by increasing <varname>gin_pending_list_limit</>
     or making autovacuum more aggressive.
     However, enlarging the threshold of the cleanup operation means that
     if a foreground cleanup does occur, it will take even longer.
    </para>
____________________________________________________________________________-->
    <para>
     在向一个已有的开启了<literal>fastupdate</>的<acronym>GIN</acronym>
     中进行插入时，系统将在待处理项列表增长到超过<varname>gin_pending_list_limit</>
     时清理该列表。为了避免在观测到的响应时间上出现波动，让待处理列表清理操作
     在后台进行（即通过 autovacuum）比较好。可以通过增加<varname>gin_pending_list_limit</>
     或者让 autovacuum 更激进来避免前台的清理操作。不过，增大清理操作的
     阈值意味着如果一次前台清理发生，它将需要更长的时间。
    </para>
<!--==========================orignal english content==========================
    <para>
     <varname>gin_pending_list_limit</> can be overridden for individual
     GIN indexes by changing storage parameters, and which allows each
     GIN index to have its own cleanup threshold.
     For example, it's possible to increase the threshold only for the GIN
     index which can be updated heavily, and decrease it otherwise.
    </para>
____________________________________________________________________________-->
    <para>
     可以通过改变存储参数为每个 GIN 索引覆盖它所用的<varname>gin_pending_list_limit</>，
     这样允许每个 GIN 索引拥有自己的清理阈值。例如，可以只为被大量更新的 GIN 索引增加
     该阈值，而对其他的索引减小该阈值。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><xref linkend="guc-gin-fuzzy-search-limit"></term>
____________________________________________________________________________-->
   <term><xref linkend="guc-gin-fuzzy-search-limit"></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     The primary goal of developing <acronym>GIN</acronym> indexes was
     to create support for highly scalable full-text search in
     <productname>PostgreSQL</productname>, and there are often situations when
     a full-text search returns a very large set of results.  Moreover, this
     often happens when the query contains very frequent words, so that the
     large result set is not even useful.  Since reading many
     tuples from the disk and sorting them could take a lot of time, this is
     unacceptable for production.  (Note that the index search itself is very
     fast.)
    </para>
____________________________________________________________________________-->
    <para>
     开发<acronym>GIN</acronym>索引的主要目的是在<productname>PostgreSQL</productname>中创建对高可扩展全文搜索的支持，并且一次全文搜索返回一个非常大的结果集也是很常见的情况。此外，当查询包含非常频繁的词时情况也是如此，因此大结果集不是非常有用。因为从磁盘读取很多元组并且对它们排序可能会花费很多时间，这对于产品来说是不可接受的（注意索引搜索本身是很快的）。
    </para>
<!--==========================orignal english content==========================
    <para>
     To facilitate controlled execution of such queries,
     <acronym>GIN</acronym> has a configurable soft upper limit on the
     number of rows returned: the
     <varname>gin_fuzzy_search_limit</varname> configuration parameter.
     It is set to 0 (meaning no limit) by default.
     If a non-zero limit is set, then the returned set is a subset of
     the whole result set, chosen at random.
    </para>
____________________________________________________________________________-->
    <para>
     为了能够控制这类查询的执行，<acronym>GIN</acronym>对于返回的行数有一个可配置的软上限：<varname>gin_fuzzy_search_limit</varname>配置参数。默认它被设置为 0 （意为无限制）。如果设置了一个非零限制，那么被返回的集合是整个结果集的一个子集，并且是随机选择的。
    </para>
<!--==========================orignal english content==========================
    <para>
     <quote>Soft</quote> means that the actual number of returned results
     could differ somewhat from the specified limit, depending on the query
     and the quality of the system's random number generator.
    </para>
____________________________________________________________________________-->
    <para>
     <quote>软</quote>意味着被返回结果的实际数量可以与指定的限制不同，这取决于查询和系统随机数生成器的质量。
    </para>
<!--==========================orignal english content==========================
    <para>
     From experience, values in the thousands (e.g., 5000 &mdash; 20000)
     work well.
    </para>
____________________________________________________________________________-->
    <para>
     根据经验，在数千级别的值（如 5000 &mdash; 20000）比较好。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
<!--==========================orignal english content==========================
 <title>Limitations</title>
____________________________________________________________________________-->
 <title>限制</title>

<!--==========================orignal english content==========================
 <para>
  <acronym>GIN</acronym> assumes that indexable operators are strict.  This
  means that <function>extractValue</> will not be called at all on a null
  item value (instead, a placeholder index entry is created automatically),
  and <function>extractQuery</function> will not be called on a null query
  value either (instead, the query is presumed to be unsatisfiable).  Note
  however that null key values contained within a non-null composite item
  or query value are supported.
 </para>
____________________________________________________________________________-->
 <para>
  <acronym>GIN</acronym>假定可索引操作符是严格的。这意味着对于一个空项值，<function>extractValue</>将根本不会被调用（相反，一个占位符索引项将被自动创建），并且在一个空查询值上也不会调用<function>extractQuery</function>（相反，该查询被假定为不可满足的）。不过注意，在一个非空组合项或查询值中的空键值是被支持的。
 </para>
</sect1>

<sect1 id="gin-examples">
<!--==========================orignal english content==========================
 <title>Examples</title>
____________________________________________________________________________-->
 <title>例子</title>

<!--==========================orignal english content==========================
 <para>
  The core <productname>PostgreSQL</> distribution
  includes the <acronym>GIN</acronym> operator classes previously shown in
  <xref linkend="gin-builtin-opclasses-table">.
  The following <filename>contrib</> modules also contain
  <acronym>GIN</acronym> operator classes:

 <variablelist>
  <varlistentry>
   <term><filename>btree_gin</></term>
   <listitem>
    <para>B-tree equivalent functionality for several data types</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</></term>
   <listitem>
    <para>Module for storing (key, value) pairs</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</></term>
   <listitem>
    <para>Enhanced support for <type>int[]</type></para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</></term>
   <listitem>
    <para>Text similarity using trigram matching</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>
____________________________________________________________________________-->
 <para>
  核心<productname>PostgreSQL</productname>发布包括以前在<xref linkend="gin-builtin-opclasses-table">
  中显示的<acronym>GIN</acronym>操作符类。下列<filename>contrib</>模块也包含<acronym>GIN</acronym>操作符类：

 <variablelist>
  <varlistentry>
   <term><filename>btree_gin</></term>
   <listitem>
    <para>多种数据类型的 B 树等效功能</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</></term>
   <listitem>
    <para>存储键值对的模块</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</></term>
   <listitem>
    <para><type>int[]</type>的增强支持</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</></term>
   <listitem>
    <para>使用 trigram 匹配的文本相似性</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>
</sect1>

</chapter>
