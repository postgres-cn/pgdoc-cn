<!-- doc/src/sgml/dblink.sgml -->

<sect1 id="dblink" xreflabel="dblink">
<!--==========================orignal english content==========================
 <title>dblink</title>
____________________________________________________________________________-->
 <title>dblink</title>

<!--==========================orignal english content==========================
 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  <filename>dblink</filename> is a module that supports connections to
  other <productname>PostgreSQL</productname> databases from within a database
  session.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>dblink</filename>是一个支持在一个数据库会话中连接到其他<productname>PostgreSQL</productname>数据库的模块。
 </para>

<!--==========================orignal english content==========================
 <para>
  See also <xref linkend="postgres-fdw"/>, which provides roughly the same
  functionality using a more modern and standards-compliant infrastructure.
 </para>
____________________________________________________________________________-->
 <para>
  还可以看看<xref linkend="postgres-fdw"/>，它以一种更现代和更加兼容标准的架构提供了相同的功能。
 </para>

 <refentry id="contrib-dblink-connect">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_connect</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_connect</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>opens a persistent connection to a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>打开一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_connect(text connstr) returns text
dblink_connect(text connname, text connstr) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_connect(text connstr) 返回 text
dblink_connect(text connname, text connstr) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_connect()</function> establishes a connection to a remote
    <productname>PostgreSQL</productname> database.  The server and database to
    be contacted are identified through a standard <application>libpq</application>
    connection string.  Optionally, a name can be assigned to the
    connection.  Multiple named connections can be open at once, but
    only one unnamed connection is permitted at a time.  The connection
    will persist until closed or until the database session is ended.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_connect()</function>建立一个到远程<productname>PostgreSQL</productname>数据库的连接。要联系的服务器和数据库通过一个标准的<application>libpq</application>连接串来标识。可以选择将一个名字赋予给该连接。多个命名的连接可以被一次打开，但是一次只允许一个未命名连接。连接将会持续直到被关闭或者数据库会话结束。
   </para>

<!--==========================orignal english content==========================
   <para>
    The connection string may also be the name of an existing foreign
    server.  It is recommended to use the foreign-data wrapper
    <literal>dblink_fdw</literal> when defining the foreign
    server.  See the example below, as well as
    <xref linkend="sql-createserver"/> and
    <xref linkend="sql-createusermapping"/>.
   </para>
____________________________________________________________________________-->
   <para>
    连接串也可以是一个现存外部服务器的名字。在使用外部服务器时，我们推荐使用外部数据包装器<literal>dblink_fdw</literal>。见下面的例子，以及<xref linkend="sql-createserver"/>和<xref linkend="sql-createusermapping"/>。
   </para>

  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name to use for this connection; if omitted, an unnamed
       connection is opened, replacing any existing unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要用于这个连接的名字。如果被忽略，将打开一个未命名连接并且替换掉任何现有的未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connstr</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connstr</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para><application>libpq</application>-style connection info string, for example
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres
       password=mypasswd options=-csearch_path=</literal>.
       For details see <xref linkend="libpq-connstring"/>.
       Alternatively, the name of a foreign server.
      </para>
____________________________________________________________________________-->
      <para><application>libpq</application>-风格的连接信息串，例如
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres
       password=mypasswd</literal>。详见<xref linkend="libpq-connstring"/>。此外，还可以是一个外部服务器的名字。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns status, which is always <literal>OK</literal> (since any error
    causes the function to throw an error instead of returning).
   </para>
____________________________________________________________________________-->
   <para>
    返回状态，它总是<literal>OK</literal>（因为任何错误会导致该函数抛出一个错误而不是返回）。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    If untrusted users have access to a database that has not adopted a
    <link linkend="ddl-schemas-patterns">secure schema usage pattern</link>,
    begin each session by removing publicly-writable schemas from
    <varname>search_path</varname>.  One could, for example,
    add <literal>options=-csearch_path=</literal> to
    <parameter>connstr</parameter>.  This consideration is not specific
    to <filename>dblink</filename>; it applies to every interface for
    executing arbitrary SQL commands.
   </para>
____________________________________________________________________________-->
   <para>
    如果不可信用户能够访问一个没有采用<link linkend="ddl-schemas-patterns">安全方案使用模式</link>的数据库，应该在开始每个会话时从<varname>search_path</varname>中移除公共可写的方案。例如，可以把<literal>options=-csearch_path=</literal>增加到<parameter>connstr</parameter>。这种考虑不是特别针对<filename>dblink</filename>，它适用于每一种执行任意SQL命令的接口。
   </para>

<!--==========================orignal english content==========================
   <para>
    Only superusers may use <function>dblink_connect</function> to create
    non-password-authenticated connections.  If non-superusers need this
    capability, use <function>dblink_connect_u</function> instead.
   </para>
____________________________________________________________________________-->
   <para>
    只有超级用户能够使用<function>dblink_connect</function>来创建无口令认证连接。如果非超级用户需要这种能力，使用<function>dblink_connect_u</function>。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is unwise to choose connection names that contain equal signs,
    as this opens a risk of confusion with connection info strings
    in other <filename>dblink</filename> functions.
   </para>
____________________________________________________________________________-->
   <para>
    选择包含等号的连接名是不明智的，因为这会产生与在其他<filename>dblink</filename>函数中的连接信息串混淆的风险。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_connect('myconn', 'dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

-&minus; FOREIGN DATA WRAPPER functionality
-&minus; Note: local connection must require password authentication for this to work properly
-&minus;       Otherwise, you will receive the following error from dblink_connect():
-&minus;       -&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
-&minus;       ERROR:  password is required
-&minus;       DETAIL:  Non-superuser cannot connect if the server does not request a password.
-&minus;       HINT:  Target server's authentication method must be changed.

CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');

CREATE USER regress_dblink_user WITH PASSWORD 'secret';
CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user 'regress_dblink_user', password 'secret');
GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;
GRANT SELECT ON TABLE foo TO regress_dblink_user;

\set ORIGINAL_USER :USER
\c - regress_dblink_user
SELECT dblink_connect('myconn', 'fdtest');
 dblink_connect 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
 a  | b |       c       
-&minus;-&minus;+-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
  0 | a | {a0,b0,c0}
  1 | b | {a1,b1,c1}
  2 | c | {a2,b2,c2}
  3 | d | {a3,b3,c3}
  4 | e | {a4,b4,c4}
  5 | f | {a5,b5,c5}
  6 | g | {a6,b6,c6}
  7 | h | {a7,b7,c7}
  8 | i | {a8,b8,c8}
  9 | j | {a9,b9,c9}
 10 | k | {a10,b10,c10}
(11 rows)

\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;
REVOKE SELECT ON TABLE foo FROM regress_dblink_user;
DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;
DROP USER regress_dblink_user;
DROP SERVER fdtest;
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_connect('myconn', 'dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

-- FOREIGN DATA WRAPPER functionality
-- Note: local connection must require password authentication for this to work properly
--       Otherwise, you will receive the following error from dblink_connect():
--       ----------------------------------------------------------------------
--       ERROR:  password is required
--       DETAIL:  Non-superuser cannot connect if the server does not request a password.
--       HINT:  Target server's authentication method must be changed.

CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');

CREATE USER regress_dblink_user WITH PASSWORD 'secret';
CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user 'regress_dblink_user', password 'secret');
GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;
GRANT SELECT ON TABLE foo TO regress_dblink_user;

\set ORIGINAL_USER :USER
\c - regress_dblink_user
SELECT dblink_connect('myconn', 'fdtest');
 dblink_connect 
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
 a  | b |       c
----+---+---------------
  0 | a | {a0,b0,c0}
  1 | b | {a1,b1,c1}
  2 | c | {a2,b2,c2}
  3 | d | {a3,b3,c3}
  4 | e | {a4,b4,c4}
  5 | f | {a5,b5,c5}
  6 | g | {a6,b6,c6}
  7 | h | {a7,b7,c7}
  8 | i | {a8,b8,c8}
  9 | j | {a9,b9,c9}
 10 | k | {a10,b10,c10}
(11 rows)

\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;
REVOKE SELECT ON TABLE foo FROM regress_dblink_user;
DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;
DROP USER regress_dblink_user;
DROP SERVER fdtest;
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-connect-u">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_connect_u</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_connect_u</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_connect_u</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_connect_u</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_connect_u</refname>
   <refpurpose>opens a persistent connection to a remote database, insecurely</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_connect_u</refname>
   <refpurpose>不安全地打开一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_connect_u(text connstr) returns text
dblink_connect_u(text connname, text connstr) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_connect_u(text connstr) 返回 text
dblink_connect_u(text connname, text connstr) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_connect_u()</function> is identical to
    <function>dblink_connect()</function>, except that it will allow non-superusers
    to connect using any authentication method.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_connect_u()</function>和<function>dblink_connect()</function>一样，不过它将允许非超级用户使用任意认证方式来连接。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the remote server selects an authentication method that does not
    involve a password, then impersonation and subsequent escalation of
    privileges can occur, because the session will appear to have
    originated from the user as which the local <productname>PostgreSQL</productname>
    server runs.  Also, even if the remote server does demand a password,
    it is possible for the password to be supplied from the server
    environment, such as a <filename>~/.pgpass</filename> file belonging to the
    server's user.  This opens not only a risk of impersonation, but the
    possibility of exposing a password to an untrustworthy remote server.
    Therefore, <function>dblink_connect_u()</function> is initially
    installed with all privileges revoked from <literal>PUBLIC</literal>,
    making it un-callable except by superusers.  In some situations
    it may be appropriate to grant <literal>EXECUTE</literal> permission for
    <function>dblink_connect_u()</function> to specific users who are considered
    trustworthy, but this should be done with care.  It is also recommended
    that any <filename>~/.pgpass</filename> file belonging to the server's user
    <emphasis>not</emphasis> contain any records specifying a wildcard host name.
   </para>
____________________________________________________________________________-->
   <para>
    如果远程服务器选择了一种不涉及口令的认证方式，那么可能发生模仿以及后续的扩大权限，因为该会话看起来像由运行<productname>PostgreSQL</productname>的用户发起的。此外，即使远程服务器不要求一个口令，也可能从服务器环境提供该口令，例如一个属于服务器用户的<filename>~/.pgpass</filename>文件。这带来的不只是模仿的风险，而且还有将口令暴露给不可信的远程服务器的风险。因此，<function>dblink_connect_u()</function>最初是用所有从<literal>PUBLIC</literal>撤销的特权安装的，这让它只能被超级用户调用。在某些情况中，为<function>dblink_connect_u()</function>授予<literal>EXECUTE</literal>权限给可信的指定用户是合适的，但是必须小心。我们也推荐任何属于服务器用户的<filename>~/.pgpass</filename>文件<emphasis>不能</emphasis>包含任何指定了一个通配符主机名的记录。
   </para>

<!--==========================orignal english content==========================
   <para>
    For further details see <function>dblink_connect()</function>.
   </para>
____________________________________________________________________________-->
   <para>
    详见<function>dblink_connect()</function>。
   </para>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-disconnect">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_disconnect</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_disconnect</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_disconnect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_disconnect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>closes a persistent connection to a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>关闭一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_disconnect() returns text
dblink_disconnect(text connname) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_disconnect() 返回 text
dblink_disconnect(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_disconnect()</function> closes a connection previously opened
    by <function>dblink_connect()</function>.  The form with no arguments closes
    an unnamed connection.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_disconnect()</function>关闭一个之前被<function>dblink_connect()</function>打开的连接。不带参数的形式关闭一个未命名连接。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of a named connection to be closed.
      </para>
____________________________________________________________________________-->
      <para>
       要被关闭的命名连接的名字。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns status, which is always <literal>OK</literal> (since any error
    causes the function to throw an error instead of returning).
   </para>
____________________________________________________________________________-->
   <para>
    它总是<literal>OK</literal>（因为任何错误会导致该函数抛出一个错误而不是返回）。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_disconnect();
 dblink_disconnect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 OK
(1 row)

SELECT dblink_disconnect('myconn');
 dblink_disconnect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 OK
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_disconnect();
 dblink_disconnect
-------------------
 OK
(1 row)

SELECT dblink_disconnect('myconn');
 dblink_disconnect
-------------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-function">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>executes a query in a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>在一个远程数据库中执行一个查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink(text connname, text sql [, bool fail_on_error]) returns setof record
dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
dblink(text sql [, bool fail_on_error]) returns setof record
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink(text connname, text sql [, bool fail_on_error]) 返回记录集
dblink(text connstr, text sql [, bool fail_on_error]) 返回记录集
dblink(text sql [, bool fail_on_error]) 返回记录集
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink</function> executes a query (usually a <command>SELECT</command>,
    but it can be any SQL statement that returns rows) in a remote database.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink</function>在一个远程数据库中执行一个查询（通常是一个<command>SELECT</command>，但是也可以是任意返回行的 SQL 语句）。
   </para>

<!--==========================orignal english content==========================
   <para>
    When two <type>text</type> arguments are given, the first one is first
    looked up as a persistent connection's name; if found, the command
    is executed on that connection.  If not found, the first argument
    is treated as a connection info string as for <function>dblink_connect</function>,
    and the indicated connection is made just for the duration of this command.
   </para>
____________________________________________________________________________-->
   <para>
    当给定两个<type>text</type>参数时，第一个被首先作为一个持久连接的名称进行查找；如果找到，该命令会在该连接上被执行。如果没有找到，第一个参数被视作一个用于<function>dblink_connect</function>的连接信息字符串，并且被指出的连接只是在这个命令的持续期间被建立。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connstr</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connstr</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       A connection info string, as previously described for
       <function>dblink_connect</function>.
      </para>
____________________________________________________________________________-->
      <para>
       如之前为<function>dblink_connect</function>所描述的一个连接信息字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>sql</parameter></term>
____________________________________________________________________________-->
     <term><parameter>sql</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The SQL query that you wish to execute in the remote database,
       for example <literal>select * from foo</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       你希望在远程数据库中执行的 SQL 查询，例如<literal>select * from foo</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不反回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    The function returns the row(s) produced by the query.  Since
    <function>dblink</function> can be used with any query, it is declared
    to return <type>record</type>, rather than specifying any particular
    set of columns.  This means that you must specify the expected
    set of columns in the calling query &mdash; otherwise
    <productname>PostgreSQL</productname> would not know what to expect.
    Here is an example:

<programlisting>
SELECT *
    FROM dblink('dbname=mydb options=-csearch_path=',
                'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>

    The <quote>alias</quote> part of the <literal>FROM</literal> clause must
    specify the column names and types that the function will return.
    (Specifying column names in an alias is actually standard SQL
    syntax, but specifying column types is a <productname>PostgreSQL</productname>
    extension.)  This allows the system to understand what
    <literal>*</literal> should expand to, and what <structname>proname</structname>
    in the <literal>WHERE</literal> clause refers to, in advance of trying
    to execute the function.  At run time, an error will be thrown
    if the actual query result from the remote database does not
    have the same number of columns shown in the <literal>FROM</literal> clause.
    The column names need not match, however, and <function>dblink</function>
    does not insist on exact type matches either.  It will succeed
    so long as the returned data strings are valid input for the
    column type declared in the <literal>FROM</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    该函数返回查询产生的行。因为<function>dblink</function>能与任何查询一起使用，它被声明为返回<type>record</type>，而不是指定任意特定的列集合。这意味着你必须指定在调用的查询中所期待的列集合 &mdash; 否则<productname>PostgreSQL</productname>将不知道会得到什么。这里是一个例子：

<programlisting>
SELECT *
    FROM dblink('dbname=mydb options=-csearch_path=',
                'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>

    <literal>FROM</literal>子句的<quote>alias</quote>部分必须指定函数将返回的列名及类型（在一个别名中指定列名实际上是标准 SQL 语法，但是指定列类型是一种<productname>PostgreSQL</productname>扩展）。这允许系统在尝试执行该函数之前就理解<literal>*</literal>将展开成什么，以及<literal>WHERE</literal>子句中的<structname>proname</structname>指的什么。在运行时，如果来自远程数据库的实际查询结果和<literal>FROM</literal>子句中显示的列数不同，将会抛出一个错误。不过，列名不需要匹配，并且<function>dblink</function>并不坚持精确地匹配类型。只要被返回的数据字符串是<literal>FROM</literal>子句中声明的列类型的合法输入，它就将会成功。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    A convenient way to use <function>dblink</function> with predetermined
    queries is to create a view.
    This allows the column type information to be buried in the view,
    instead of having to spell it out in every query.  For example,

<programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres options=-csearch_path=',
                'select proname, prosrc from pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
</programlisting></para>
____________________________________________________________________________-->
   <para>
    一种将预定义查询用于<function>dblink</function>的方便方法是创建一个视图。这允许列类型信息被埋藏在该视图中，而不是在每一个查询中都拼写出来。例如：

<programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres options=-csearch_path=',
                'select proname, prosrc from pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
</programlisting></para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT * FROM dblink('dbname=postgres options=-csearch_path=',
                     'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT * FROM dblink('select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('myconn', 'dbname=regression options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 bytearecv  | bytearecv
 byteasend  | byteasend
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteain    | byteain
 byteaout   | byteaout
(14 rows)
</screen>
____________________________________________________________________________-->
<screen>
SELECT * FROM dblink('dbname=postgres options=-csearch_path=',
                     'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('myconn', 'dbname=regression options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 bytearecv  | bytearecv
 byteasend  | byteasend
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteain    | byteain
 byteaout   | byteaout
(14 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-exec">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_exec</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_exec</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_exec</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_exec</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>executes a command in a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>在一个远程数据库中执行一个命令</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_exec</function> executes a command (that is, any SQL statement
    that doesn't return rows) in a remote database.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_exec</function>在一个远程数据库中执行一个命令（也就是，任何不返回行的 SQL 语句）。
   </para>

<!--==========================orignal english content==========================
   <para>
    When two <type>text</type> arguments are given, the first one is first
    looked up as a persistent connection's name; if found, the command
    is executed on that connection.  If not found, the first argument
    is treated as a connection info string as for <function>dblink_connect</function>,
    and the indicated connection is made just for the duration of this command.
   </para>
____________________________________________________________________________-->
   <para>
    当给定两个<type>text</type>参数时，第一个被首先作为一个持久连接的名称进行查找；如果找到，该命令会在该连接上被执行。如果没有找到，第一个参数被视作一个用于<function>dblink_connect</function>的连接信息字符串，并且被指出的连接只是在这个命令的持续期间被建立。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connstr</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connstr</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       A connection info string, as previously described for
       <function>dblink_connect</function>.
      </para>
____________________________________________________________________________-->
      <para>
       如之前为<function>dblink_connect</function>所描述的一个连接信息字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>sql</parameter></term>
____________________________________________________________________________-->
     <term><parameter>sql</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The SQL command that you wish to execute in the remote database,
       for example
       <literal>insert into foo values(0,'a','{"a0","b0","c0"}')</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       你希望在远程数据库中执行的 SQL 命令，例如<literal>insert into foo values(0,'a','{"a0","b0","c0"}')</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns status, either the command's status string or <literal>ERROR</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    返回状态，可能是命令的状态字符串或<literal>ERROR</literal>。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_connect('dbname=dblink_test_standby');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 INSERT 943366 1
(1 row)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 INSERT 6432584 1
(1 row)

SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE:  sql error
DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

 dblink_exec
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ERROR
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_connect('dbname=dblink_test_standby');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-----------------
 INSERT 943366 1
(1 row)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
------------------
 INSERT 6432584 1
(1 row)

SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE:  sql error
DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

 dblink_exec
-------------
 ERROR
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-open">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_open</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_open</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_open</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_open</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>opens a cursor in a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>在一个远程数据库中打开一个游标</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_open(text cursorname, text sql [, bool fail_on_error]) 返回 text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_open()</function> opens a cursor in a remote database.
    The cursor can subsequently be manipulated with
    <function>dblink_fetch()</function> and <function>dblink_close()</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_open()</function>在一个远程数据库中打开一个游标。该游标能够随后使用<function>dblink_fetch()</function>和<function>dblink_close()</function>进行操纵。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>cursorname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>cursorname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name to assign to this cursor.
      </para>
____________________________________________________________________________-->
      <para>
       要赋予给这个游标的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>sql</parameter></term>
____________________________________________________________________________-->
     <term><parameter>sql</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The <command>SELECT</command> statement that you wish to execute in the remote
       database, for example <literal>select * from pg_class</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       你希望在远程数据库中执行的<command>SELECT</command>语句，例如<literal>select * from pg_class</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns status, either <literal>OK</literal> or <literal>ERROR</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    返回状态，<literal>OK</literal>或者<literal>ERROR</literal>。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    Since a cursor can only persist within a transaction,
    <function>dblink_open</function> starts an explicit transaction block
    (<command>BEGIN</command>) on the remote side, if the remote side was
    not already within a transaction.  This transaction will be
    closed again when the matching <function>dblink_close</function> is
    executed.  Note that if
    you use <function>dblink_exec</function> to change data between
    <function>dblink_open</function> and <function>dblink_close</function>,
    and then an error occurs or you use <function>dblink_disconnect</function> before
    <function>dblink_close</function>, your change <emphasis>will be
    lost</emphasis> because the transaction will be aborted.
   </para>
____________________________________________________________________________-->
   <para>
    因为一个游标只能在一个事务中持续，如果远端还没有在一个事务中，<function>dblink_open</function>会在远端开始一个显式事务块（<command>BEGIN</command>）。当匹配的<function>dblink_close</function>被执行时，这个事务将再次被关闭。注意如果你使用<function>dblink_exec</function>在<function>dblink_open</function>和<function>dblink_close</function>之间改变数据，并且接着发生了一个错误或者你在<function>dblink_close</function>之前使用了<function>dblink_disconnect</function>，你的更改<emphasis>将被丢失</emphasis>，因为事务将被中止。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 OK
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-fetch">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_fetch</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_fetch</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_fetch</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_fetch</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>returns rows from an open cursor in a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>从一个远程数据库中的打开的游标返回行</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) 返回 record 集合
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) 返回 record 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_fetch</function> fetches rows from a cursor previously
    established by <function>dblink_open</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_fetch</function>从一个之前由<function>dblink_open</function>建立的游标中取得行。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>cursorname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>cursorname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of the cursor to fetch from.
      </para>
____________________________________________________________________________-->
      <para>
       要从中取数据的游标名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>howmany</parameter></term>
____________________________________________________________________________-->
     <term><parameter>howmany</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The maximum number of rows to retrieve. The next <parameter>howmany</parameter>
       rows are fetched, starting at the current cursor position, moving
       forward. Once the cursor has reached its end, no more rows are produced.
      </para>
____________________________________________________________________________-->
      <para>
       要检索的最大行数。从当前游标位置向前的接下来<parameter>howmany</parameter>个行会被取出。一旦该游标已经到达了它的末端，将不会产生更多行。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不反回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    The function returns the row(s) fetched from the cursor.  To use this
    function, you will need to specify the expected set of columns,
    as previously discussed for <function>dblink</function>.
   </para>
____________________________________________________________________________-->
   <para>
    该函数返回从游标中取出的行。要使用这个函数，你将需要指定想要的列集合，如前面<function>dblink</function>中所讨论的。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    On a mismatch between the number of return columns specified in the
    <literal>FROM</literal> clause, and the actual number of columns returned by the
    remote cursor, an error will be thrown. In this event, the remote cursor
    is still advanced by as many rows as it would have been if the error had
    not occurred.  The same is true for any other error occurring in the local
    query after the remote <command>FETCH</command> has been done.
   </para>
____________________________________________________________________________-->
   <para>
    当<literal>FROM</literal>子句中指定的返回列的数量和远程游标返回的实际列数不匹配时，将抛出一个错误。在这个事件中，远程游标仍会被前进错误没发生时应该前进的行数。对于远程<command>FETCH</command>完成之后在本地查询中发生的任何其他错误，情况也是一样。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');
 dblink_open
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 OK
(1 row)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname |  source
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;
 byteacat | byteacat
 byteacmp | byteacmp
 byteaeq  | byteaeq
 byteage  | byteage
 byteagt  | byteagt
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname  |  source
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 byteain   | byteain
 byteale   | byteale
 bytealike | bytealike
 bytealt   | bytealt
 byteane   | byteane
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |   source
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 byteanlike | byteanlike
 byteaout   | byteaout
(2 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname | source
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;
(0 rows)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');
 dblink_open
-------------
 OK
(1 row)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname |  source
----------+----------
 byteacat | byteacat
 byteacmp | byteacmp
 byteaeq  | byteaeq
 byteage  | byteage
 byteagt  | byteagt
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname  |  source
-----------+-----------
 byteain   | byteain
 byteale   | byteale
 bytealike | bytealike
 bytealt   | bytealt
 byteane   | byteane
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |   source
------------+------------
 byteanlike | byteanlike
 byteaout   | byteaout
(2 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname | source
----------+--------
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-close">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_close</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_close</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_close</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_close</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>closes a cursor in a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>关闭一个远程数据库中的游标</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_close(text cursorname [, bool fail_on_error]) returns text
dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_close(text cursorname [, bool fail_on_error]) 返回 text
dblink_close(text connname, text cursorname [, bool fail_on_error]) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_close</function> closes a cursor previously opened with
    <function>dblink_open</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_close</function>关闭一个之前由<function>dblink_open</function>打开的游标。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>cursorname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>cursorname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of the cursor to close.
      </para>
____________________________________________________________________________-->
      <para>
       要关闭的游标名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns status, either <literal>OK</literal> or <literal>ERROR</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    返回状态，<literal>OK</literal>或者<literal>ERROR</literal>。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    If <function>dblink_open</function> started an explicit transaction block,
    and this is the last remaining open cursor in this connection,
    <function>dblink_close</function> will issue the matching <command>COMMIT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    如果<function>dblink_open</function>开始了一个显式事务块，并且这是这个连接中最后一个保持打开的游标，<function>dblink_close</function>将发出匹配的<command>COMMIT</command>。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 OK
(1 row)

SELECT dblink_close('foo');
 dblink_close
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)

SELECT dblink_close('foo');
 dblink_close
--------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-connections">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_get_connections</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_get_connections</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_get_connections</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_get_connections</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>returns the names of all open named dblink connections</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>返回所有打开的命名 dblink 连接的名称</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_get_connections() returns text[]
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_get_connections() 返回 text[]
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_get_connections</function> returns an array of the names
    of all open named <filename>dblink</filename> connections.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_get_connections</function>返回一个数组，其中是所有打开的命名<filename>dblink</filename>连接的名称。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>Returns a text array of connection names, or NULL if none.</para>
____________________________________________________________________________-->
   <para>返回一个连接名称的文本数组，如果没有则为 NULL。</para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
SELECT dblink_get_connections();
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT dblink_get_connections();
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-error-message">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_error_message</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_error_message</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_error_message</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_error_message</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>gets last error message on the named connection</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>得到在命名连接上的最后一个错误消息</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_error_message(text connname) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_error_message(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_error_message</function> fetches the most recent remote
    error message for a given connection.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_error_message</function>为一个给定连接取得最近的远程错误消息。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns last error message, or an empty string if there has been
    no error in this connection.
   </para>
____________________________________________________________________________-->
   <para>
    返回最后一个错误消息，如果在这个连接上没有错误则返回一个空字符串。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
SELECT dblink_error_message('dtest1');
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT dblink_error_message('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-send-query">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_send_query</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_send_query</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_send_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_send_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>sends an async query to a remote database</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>发送一个异步查询到远程数据库</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_send_query(text connname, text sql) returns int
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_send_query(text connname, text sql) 返回 int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_send_query</function> sends a query to be executed
    asynchronously, that is, without immediately waiting for the result.
    There must not be an async query already in progress on the
    connection.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_send_query</function>发送一个要被异步执行的查询，也就是不需要立即等待结果。在该连接上不能有还在处理中的异步查询。
   </para>

<!--==========================orignal english content==========================
   <para>
    After successfully dispatching an async query, completion status
    can be checked with <function>dblink_is_busy</function>, and the results
    are ultimately collected with <function>dblink_get_result</function>.
    It is also possible to attempt to cancel an active async query
    using <function>dblink_cancel_query</function>.
   </para>
____________________________________________________________________________-->
   <para>
    在成功地派送一个异步查询后，可以用<function>dblink_is_busy</function>检查完成状态，并且结果最终由<function>dblink_get_result</function>收集。也可以使用<function>dblink_cancel_query</function>尝试取消一个活动中的异步查询。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>sql</parameter></term>
____________________________________________________________________________-->
     <term><parameter>sql</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The SQL statement that you wish to execute in the remote database,
       for example <literal>select * from pg_class</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       你希望在远程数据库中执行的 SQL 语句，例如<literal>select * from pg_class</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns 1 if the query was successfully dispatched, 0 otherwise.
   </para>
____________________________________________________________________________-->
   <para>
    如果查询被成功地派送返回 1，否则返回 0。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-is-busy">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_is_busy</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_is_busy</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_is_busy</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_is_busy</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>checks if connection is busy with an async query</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>检查连接是否正在忙于一个异步查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_is_busy(text connname) returns int
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_is_busy(text connname) 返回 int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_is_busy</function> tests whether an async query is in progress.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_is_busy</function>测试是否一个异步查询正在进行中。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to check.
      </para>
____________________________________________________________________________-->
      <para>
       要检查的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns 1 if connection is busy, 0 if it is not busy.
    If this function returns 0, it is guaranteed that
    <function>dblink_get_result</function> will not block.
   </para>
____________________________________________________________________________-->
   <para>
    如果连接正忙则返回 1，如果不忙则返回 0。如果这个函数返回 0，<function>dblink_get_result</function>将被保证不会阻塞。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
SELECT dblink_is_busy('dtest1');
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT dblink_is_busy('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-notify">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_get_notify</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_get_notify</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_get_notify</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_get_notify</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_get_notify</refname>
   <refpurpose>retrieve async notifications on a connection</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_get_notify</refname>
   <refpurpose>在一个连接上检索异步通知</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)
dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra text)
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_get_notify() 返回 (notify_name text, be_pid int, extra text) 集合
dblink_get_notify(text connname) 返回 (notify_name text, be_pid int, extra text) 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_get_notify</function> retrieves notifications on either
    the unnamed connection, or on a named connection if specified.
    To receive notifications via dblink, <function>LISTEN</function> must
    first be issued, using <function>dblink_exec</function>.
    For details see <xref linkend="sql-listen"/> and <xref linkend="sql-notify"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_get_notify</function>在一个未命名连接或者一个指定的命名连接上检索通知。要通过 dblink 接收通知，首先必须使用<function>dblink_exec</function>发出<function>LISTEN</function>。详见<xref linkend="sql-listen"/>和<xref linkend="sql-notify"/>。
   </para>

  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of a named connection to get notifications on.
      </para>
____________________________________________________________________________-->
      <para>
       要在其上得到通知的命名连接的名称。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>
<!--==========================orignal english content==========================
    <para>Returns <type>setof (notify_name text, be_pid int, extra text)</type>, or an empty set if none.</para>
____________________________________________________________________________-->
    <para>返回 <type>(notify_name text, be_pid int, extra text) 集合</type>，或者一个空集。</para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_exec('LISTEN virtual');
 dblink_exec 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 LISTEN
(1 row)

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
(0 rows)

NOTIFY virtual;
NOTIFY

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 virtual     |   1229 |
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_exec('LISTEN virtual');
 dblink_exec
-------------
 LISTEN
(1 row)

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
(0 rows)

NOTIFY virtual;
NOTIFY

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
 virtual     |   1229 |
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-result">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_get_result</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_get_result</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_get_result</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_get_result</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>gets an async query result</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>得到一个异步查询结果</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_get_result(text connname [, bool fail_on_error]) returns setof record
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_get_result(text connname [, bool fail_on_error]) 返回 record 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_get_result</function> collects the results of an
    asynchronous query previously sent with <function>dblink_send_query</function>.
    If the query is not already completed, <function>dblink_get_result</function>
    will wait until it is.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_get_result</function>收集之前<function>dblink_send_query</function>发送的一个异步查询的结果。如果该查询还没有完成，<function>dblink_get_result</function>将等待直到它完成。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>fail_on_error</parameter></term>
____________________________________________________________________________-->
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
____________________________________________________________________________-->
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不返回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    For an async query (that is, a SQL statement returning rows),
    the function returns the row(s) produced by the query.  To use this
    function, you will need to specify the expected set of columns,
    as previously discussed for <function>dblink</function>.
   </para>
____________________________________________________________________________-->
   <para>
    对于一个异步查询（也就是一个返回行的 SQL 语句），该函数返回查询产生的行。要使用这个函数，你将需要指定所期待的列集合，如前面为<function>dblink</function>所讨论的那样。
   </para>

<!--==========================orignal english content==========================
   <para>
    For an async command (that is, a SQL statement not returning rows),
    the function returns a single row with a single text column containing
    the command's status string.  It is still necessary to specify that
    the result will have a single text column in the calling <literal>FROM</literal>
    clause.
   </para>
____________________________________________________________________________-->
   <para>
    对于一个异步命令（也就是一个不返回行的 SQL 语句），该函数返回一个只有单个文本列的单行，其中包含了该命令的状态字符串。仍必须在调用的<literal>FROM</literal>子句中指定结果将具有一个单一文本行。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    This function <emphasis>must</emphasis> be called if
    <function>dblink_send_query</function> returned 1.
    It must be called once for each query
    sent, and one additional time to obtain an empty set result,
    before the connection can be used again.
   </para>
____________________________________________________________________________-->
   <para>
    如果<function>dblink_send_query</function>返回 1，这个函数就<emphasis>必须</emphasis>被调用。对每一个已发送的查询都必须调用一次这个函数，并且在连接再次可用之前还要多调用一次来得到一个空结果集。
   </para>

<!--==========================orignal english content==========================
   <para>
    When using <function>dblink_send_query</function> and
    <function>dblink_get_result</function>, <application>dblink</application> fetches the entire
    remote query result before returning any of it to the local query
    processor.  If the query returns a large number of rows, this can result
    in transient memory bloat in the local session.  It may be better to open
    such a query as a cursor with <function>dblink_open</function> and then fetch a
    manageable number of rows at a time.  Alternatively, use plain
    <function>dblink()</function>, which avoids memory bloat by spooling large result
    sets to disk.
   </para>
____________________________________________________________________________-->
   <para>
    当使用<function>dblink_send_query</function>和<function>dblink_get_result</function>时，在将结果集中的任何一行返回给本地查询处理器之前，<application>dblink</application>将取得整个远程查询结果。如果该查询返回大量的行，这可能会导致本地会话中短暂的内存膨胀。最好将这样的一个查询用<function>dblink_open</function>打开成一个游标并且接着每次取得数量可管理的行。也可以使用简单的<function>dblink()</function>，它会避免缓冲大型结果集到磁盘上导致的内存膨胀。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
 dblink_connect
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 OK
(1 row)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;
 t1
-&minus;-&minus;
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
-&minus;-&minus;+-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
-&minus;-&minus;+-&minus;-&minus;+-&minus;-&minus;
(0 rows)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;
 t1
-&minus;-&minus;
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
-&minus;-&minus;+-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |      f3
-&minus;-&minus;+-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
  7 | h  | {a7,b7,c7}
  8 | i  | {a8,b8,c8}
  9 | j  | {a9,b9,c9}
 10 | k  | {a10,b10,c10}
(4 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
-&minus;-&minus;+-&minus;-&minus;+-&minus;-&minus;
(0 rows)
</screen>
____________________________________________________________________________-->
<screen>
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
 dblink_connect
----------------
 OK
(1 row)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |      f3
----+----+---------------
  7 | h  | {a7,b7,c7}
  8 | i  | {a8,b8,c8}
  9 | j  | {a9,b9,c9}
 10 | k  | {a10,b10,c10}
(4 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-cancel-query">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_cancel_query</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_cancel_query</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_cancel_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_cancel_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>cancels any active query on the named connection</refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>在命名连接上取消任何活动查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_cancel_query(text connname) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_cancel_query(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_cancel_query</function> attempts to cancel any query that
    is in progress on the named connection.  Note that this is not
    certain to succeed (since, for example, the remote query might
    already have finished).  A cancel request simply improves the
    odds that the query will fail soon.  You must still complete the
    normal query protocol, for example by calling
    <function>dblink_get_result</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_cancel_query</function>尝试命名连接上正在进行的任何查询。注意这不一定会成功（例如，远程查询可能已经结束）。一个取消请求仅仅提高了该查询将很快失败的几率。你仍必须完成通常的查询协议，例如通过调用<function>dblink_get_result</function>。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>connname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>connname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of the connection to use.
      </para>
____________________________________________________________________________-->
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns <literal>OK</literal> if the cancel request has been sent, or
    the text of an error message on failure.
   </para>
____________________________________________________________________________-->
   <para>
    如果取消请求已经被发送，则返回<literal>OK</literal>；如果失败，则返回一个错误消息的文本。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<programlisting>
SELECT dblink_cancel_query('dtest1');
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT dblink_cancel_query('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-pkey">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_get_pkey</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_get_pkey</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_get_pkey</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_get_pkey</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>returns the positions and field names of a relation's
    primary key fields
   </refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>返回一个关系的主键域的位置和域名称
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_get_pkey(text relname) returns setof dblink_pkey_results
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_get_pkey(text relname) 返回 dblink_pkey_results 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_get_pkey</function> provides information about the primary
    key of a relation in the local database.  This is sometimes useful
    in generating queries to be sent to remote databases.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_get_pkey</function>提供有关于本地数据库中一个关系的主键的信息。这有时候有助于生成要被发送到远程数据库的查询。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>relname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>relname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of a local relation, for example <literal>foo</literal> or
       <literal>myschema.mytab</literal>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</literal>; without quotes, the string
       will be folded to lower case.
      </para>
____________________________________________________________________________-->
      <para>
       一个本地关系的名称，例如<literal>foo</literal>或者<literal>myschema.mytab</literal>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</literal>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>
    Returns one row for each primary key field, or no rows if the relation
    has no primary key.  The result row type is defined as

<programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
</programlisting>

    The <literal>position</literal> column simply runs from 1 to <replaceable>N</replaceable>;
    it is the number of the field within the primary key, not the number
    within the table's columns.
   </para>
____________________________________________________________________________-->
   <para>
    为每一个主键域返回一行，如果该关系没有主键则不返回行。结果行类型被定义为：

<programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
</programlisting>

    <literal>position</literal>列值可以从 1 到 <replaceable>N</replaceable>，它是该域在主键中的编号，而不是在表列中的编号。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
CREATE TABLE foobar (
    f1 int,
    f2 int,
    f3 int,
    PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE

SELECT * FROM dblink_get_pkey('foobar');
 position | colname
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
        1 | f1
        2 | f2
        3 | f3
(3 rows)
</screen>
____________________________________________________________________________-->
<screen>
CREATE TABLE foobar (
    f1 int,
    f2 int,
    f3 int,
    PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE

SELECT * FROM dblink_get_pkey('foobar');
 position | colname
----------+---------
        1 | f1
        2 | f2
        3 | f3
(3 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-insert">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_build_sql_insert</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_build_sql_insert</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_build_sql_insert</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_build_sql_insert</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    builds an INSERT statement using a local tuple, replacing the
    primary key field values with alternative supplied values
   </refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    使用一个本地元组构建一个 INSERT 语句，将主键域值替换为提供的值
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_build_sql_insert(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_build_sql_insert(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_build_sql_insert</function> can be useful in doing selective
    replication of a local table to a remote database.  It selects a row
    from the local table based on primary key, and then builds a SQL
    <command>INSERT</command> command that will duplicate that row, but with
    the primary key values replaced by the values in the last argument.
    (To make an exact copy of the row, just specify the same values for
    the last two arguments.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_build_sql_insert</function>在选择性地将一个本地表复制到一个远程数据库时很有用。它基于主键从本地表选择一行，并且接着构建一个复制该行的<command>INSERT</command>命令，但是其中主键值被替换为最后一个参数中的值（要创建该行的一个准确拷贝，只要为最后两个参数指定相同的值）。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>relname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>relname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of a local relation, for example <literal>foo</literal> or
       <literal>myschema.mytab</literal>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</literal>; without quotes, the string
       will be folded to lower case.
      </para>
____________________________________________________________________________-->
      <para>
       一个本地关系的名称，例如<literal>foo</literal>或者<literal>myschema.mytab</literal>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</literal>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>primary_key_attnums</parameter></term>
____________________________________________________________________________-->
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>num_primary_key_atts</parameter></term>
____________________________________________________________________________-->
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The number of primary key fields.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>src_pk_att_vals_array</parameter></term>
____________________________________________________________________________-->
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Values of the primary key fields to be used to look up the
       local tuple.  Each field is represented in text form.
       An error is thrown if there is no local row with these
       primary key values.
      </para>
____________________________________________________________________________-->
      <para>
       要被用来查找本地元组的主键域值。每一个域都被表示为文本形式。如果没有行具有这些主键值，则抛出一个错误。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
____________________________________________________________________________-->
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Values of the primary key fields to be placed in the resulting
       <command>INSERT</command> command.  Each field is represented in text form.
      </para>
____________________________________________________________________________-->
      <para>
       要被替换到结果<command>INSERT</command>命令中的主键域值。每一个域被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>Returns the requested SQL statement as text.</para>
____________________________________________________________________________-->
   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    As of <productname>PostgreSQL</productname> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</literal>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
____________________________________________________________________________-->
   <para>
    自<productname>PostgreSQL</productname> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</literal>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
             dblink_build_sql_insert
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
             dblink_build_sql_insert
--------------------------------------------------
 INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-delete">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_build_sql_delete</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_build_sql_delete</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_build_sql_delete</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_build_sql_delete</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>builds a DELETE statement using supplied values for primary
    key field values
   </refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>使用所提供的主键域值构建一个 DELETE 语句
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_build_sql_delete(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_build_sql_delete(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_build_sql_delete</function> can be useful in doing selective
    replication of a local table to a remote database.  It builds a SQL
    <command>DELETE</command> command that will delete the row with the given
    primary key values.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_build_sql_delete</function>在选择性地将一个本地表复制到一个远程数据库时很有用。它构建一个 SQL <command>DELETE</command>命令用来删除具有给定主键值的行。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>relname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>relname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of a local relation, for example <literal>foo</literal> or
       <literal>myschema.mytab</literal>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</literal>; without quotes, the string
       will be folded to lower case.
      </para>
____________________________________________________________________________-->
      <para>
       一个本地关系的名称，例如<literal>foo</literal>或者<literal>myschema.mytab</literal>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</literal>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>primary_key_attnums</parameter></term>
____________________________________________________________________________-->
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>num_primary_key_atts</parameter></term>
____________________________________________________________________________-->
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The number of primary key fields.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
____________________________________________________________________________-->
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Values of the primary key fields to be used in the resulting
       <command>DELETE</command> command.  Each field is represented in text form.
      </para>
____________________________________________________________________________-->
      <para>
       要用在结果<command>DELETE</command>命令中的主键域值。每一个域都被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>Returns the requested SQL statement as text.</para>
____________________________________________________________________________-->
   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    As of <productname>PostgreSQL</productname> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</literal>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
____________________________________________________________________________-->
   <para>
    自<productname>PostgreSQL</productname> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</literal>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
           dblink_build_sql_delete
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
           dblink_build_sql_delete
---------------------------------------------
 DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-update">
<!--==========================orignal english content==========================
  <indexterm>
   <primary>dblink_build_sql_update</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>dblink_build_sql_update</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>dblink_build_sql_update</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>dblink_build_sql_update</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>builds an UPDATE statement using a local tuple, replacing
    the primary key field values with alternative supplied values
   </refpurpose>
  </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>使用一个本地元组构建一个 UPDATE 语句，将主键域值替换为提供的值
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
dblink_build_sql_update(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
dblink_build_sql_update(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Description</title>
____________________________________________________________________________-->
   <title>描述</title>

<!--==========================orignal english content==========================
   <para>
    <function>dblink_build_sql_update</function> can be useful in doing selective
    replication of a local table to a remote database.  It selects a row
    from the local table based on primary key, and then builds a SQL
    <command>UPDATE</command> command that will duplicate that row, but with
    the primary key values replaced by the values in the last argument.
    (To make an exact copy of the row, just specify the same values for
    the last two arguments.)  The <command>UPDATE</command> command always assigns
    all fields of the row &mdash; the main difference between this and
    <function>dblink_build_sql_insert</function> is that it's assumed that
    the target row already exists in the remote table.
   </para>
____________________________________________________________________________-->
   <para>
    <function>dblink_build_sql_update</function>在选择性地将一个本地表复制到一个远程数据库时很有用。它从本地表基于主键选择一行，并且接着构建一个 SQL <command>UPDATE</command>命令来复制该行，但是其中的主键值被替换为最后一个参数中的值（要创建该行的一个准确拷贝，只要为最后两个参数指定相同的值）。<command>UPDATE</command>命令总是为该行的所有域赋值 &mdash; 这个函数与<function>dblink_build_sql_insert</function>之间的主要区别是它假定目标行已经存在于远程表中。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Arguments</title>
____________________________________________________________________________-->
   <title>参数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>relname</parameter></term>
____________________________________________________________________________-->
     <term><parameter>relname</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Name of a local relation, for example <literal>foo</literal> or
       <literal>myschema.mytab</literal>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</literal>; without quotes, the string
       will be folded to lower case.
      </para>
____________________________________________________________________________-->
      <para>
       一个本地关系的名称，例如<literal>foo</literal>或者<literal>myschema.mytab</literal>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</literal>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>primary_key_attnums</parameter></term>
____________________________________________________________________________-->
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>num_primary_key_atts</parameter></term>
____________________________________________________________________________-->
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The number of primary key fields.
      </para>
____________________________________________________________________________-->
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>src_pk_att_vals_array</parameter></term>
____________________________________________________________________________-->
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Values of the primary key fields to be used to look up the
       local tuple.  Each field is represented in text form.
       An error is thrown if there is no local row with these
       primary key values.
      </para>
____________________________________________________________________________-->
      <para>
       要被用来查找本地元组的主键域值。每一个域都被表示为文本形式。如果没有行具有这些主键值，则抛出一个错误。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
____________________________________________________________________________-->
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Values of the primary key fields to be placed in the resulting
       <command>UPDATE</command> command.  Each field is represented in text form.
      </para>
____________________________________________________________________________-->
      <para>
       要用在结果<command>UPDATE</command>命令中的主键域值。每一个域都被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Return Value</title>
____________________________________________________________________________-->
   <title>返回值</title>

<!--==========================orignal english content==========================
   <para>Returns the requested SQL statement as text.</para>
____________________________________________________________________________-->
   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Notes</title>
____________________________________________________________________________-->
   <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    As of <productname>PostgreSQL</productname> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</literal>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
____________________________________________________________________________-->
   <para>
    自<productname>PostgreSQL</productname> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</literal>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
<!--==========================orignal english content==========================
   <title>Examples</title>
____________________________________________________________________________-->
   <title>例子</title>

<!--==========================orignal english content==========================
<screen>
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                   dblink_build_sql_update
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
</screen>
____________________________________________________________________________-->
<screen>
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                   dblink_build_sql_update
-------------------------------------------------------------
 UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

</sect1>
