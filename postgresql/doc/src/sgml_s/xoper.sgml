<!-- doc/src/sgml/xoper.sgml -->

 <sect1 id="xoper">
<!--==========================orignal english content==========================
  <title>User-defined Operators</title>
____________________________________________________________________________-->
  <title>用户定义的操作符</title>

<!--==========================orignal english content==========================
  <indexterm zone="xoper">
   <primary>operator</primary>
   <secondary>user-defined</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="xoper">
   <primary>操作符</primary>
   <secondary>用户定义的</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Every operator is <quote>syntactic sugar</quote> for a call to an
   underlying function that does the real work; so you must
   first create the underlying function before you can create
   the operator.  However, an operator is <emphasis>not merely</emphasis>
   syntactic sugar, because it carries additional information
   that helps the query planner optimize queries that use the
   operator.  The next section will be devoted to explaining
   that additional information.
  </para>
____________________________________________________________________________-->
  <para>
   对于一个完成实际工作的底层函数的调用来说，每一个操作符都是<quote>语法糖</quote>，因此在创建操作符之前你必须先创建底层函数。不过，一个操作符<emphasis>不只</emphasis>是语法糖，因为它携带了额外的信息来帮助查询规划器优化使用该操作符的查询。下一节将致力于解释这些额外信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> supports left unary, right
   unary, and binary operators.  Operators can be
   overloaded;<indexterm><primary>overloading</primary><secondary>operators</secondary></indexterm>
   that is, the same operator name can be used for different operators
   that have different numbers and types of operands.  When a query is
   executed, the system determines the operator to call from the
   number and types of the provided operands.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>支持左一元、右一元和二元操作符。操作符可以被重载<indexterm><primary>重载</primary><secondary>操作符</secondary></indexterm>，也就是说相同的操作符名称可以被用于具有不同操作数数量和类型的操作符。在执行一个查询时，系统会根据提供的操作数的数量和类型决定要调用的操作符。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example of creating an operator for adding two complex
   numbers.  We assume we've already created the definition of type
   <type>complex</type> (see <xref linkend="xtypes"/>).  First we need a
   function that does the work, then we can define the operator:

<programlisting>
CREATE FUNCTION complex_add(complex, complex)
    RETURNS complex
    AS '<replaceable>filename</replaceable>', 'complex_add'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR + (
    leftarg = complex,
    rightarg = complex,
    function = complex_add,
    commutator = +
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这里有一个创建用于对两个复数做加法的操作符的例子。我们假设我们已经创建了类型<type>complex</type>（见<xref linkend="xtypes"/>）的定义。首先我们需要一个函数做这个加法，然后我们可以定义该操作符：

<programlisting>
CREATE FUNCTION complex_add(complex, complex)
    RETURNS complex
    AS '<replaceable>filename</replaceable>', 'complex_add'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR + (
    leftarg = complex,
    rightarg = complex,
    function = complex_add,
    commutator = +
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Now we could execute a query like this:

<screen>
SELECT (a + b) AS c FROM test_complex;

        c
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 (5.2,6.05)
 (133.42,144.95)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   现在我们可以执行一个这样的查询：

<screen>
SELECT (a + b) AS c FROM test_complex;

        c
-----------------
 (5.2,6.05)
 (133.42,144.95)
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   We've shown how to create a binary operator here.  To create unary
   operators, just omit one of <literal>leftarg</literal> (for left unary) or
   <literal>rightarg</literal> (for right unary).  The <literal>function</literal>
   clause and the argument clauses are the only required items in
   <command>CREATE OPERATOR</command>.  The <literal>commutator</literal>
   clause shown in the example is an optional hint to the query
   optimizer.  Further details about <literal>commutator</literal> and other
   optimizer hints appear in the next section.
  </para>
____________________________________________________________________________-->
  <para>
   这里我们已经展示了如何创建一个二元操作符。要创建一元操作符，只要忽略<literal>leftarg</literal>（左一元）和<literal>rightarg</literal>（右一元）之一即可。在<command>CREATE OPERATOR</command>中只要求<literal>procedure</literal>子句和参数子句。例子中展示的<literal>commutator</literal>子句是一个可选的子句，它被用作一个查询优化器使用的提示。有关<literal>commutator</literal>以及其他优化器提示的细节出现在下一小节中。
  </para>
 </sect1>

  <sect1 id="xoper-optimization">
<!--==========================orignal english content==========================
   <title>Operator Optimization Information</title>
____________________________________________________________________________-->
   <title>操作符优化信息</title>

<!--==========================orignal english content==========================
   <para>
    A <productname>PostgreSQL</productname> operator definition can include
    several optional clauses that tell the system useful things about how
    the operator behaves.  These clauses should be provided whenever
    appropriate, because they can make for considerable speedups in execution
    of queries that use the operator.  But if you provide them, you must be
    sure that they are right!  Incorrect use of an optimization clause can
    result in slow queries, subtly wrong output, or other Bad Things.
    You can always leave out an optimization clause if you are not sure
    about it; the only consequence is that queries might run slower than
    they need to.
   </para>
____________________________________________________________________________-->
   <para>
    一个<productname>PostgreSQL</productname>的操作符定义能够包括几种可选的子句，它们可以把有关操作符行为的有用的事情告诉系统。只要合适就应该提供这些子句，因为它们能够为使用该操作符的查询带来可观的速度提升。但是如果你提供了它们，你必须确保它们是正确的！不正确地使用一个优化子句可能导致很慢的查询、错误的输出或者其他不好的事情。如果你没有把握你可以总是省去优化子句，这样做的唯一后果是查询会比正常的速度慢。
   </para>

<!--==========================orignal english content==========================
   <para>
    Additional optimization clauses might be added in future versions of
    <productname>PostgreSQL</productname>.  The ones described here are all
    the ones that release &version; understands.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>的未来版本中可能会增加更多的优化子句。这里描述的优化子句都是版本 &version; 能理解的。
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title><literal>COMMUTATOR</literal></title>
____________________________________________________________________________-->
    <title><literal>COMMUTATOR</literal></title>

<!--==========================orignal english content==========================
    <para>
     The <literal>COMMUTATOR</literal> clause, if provided, names an operator that is the
     commutator of the operator being defined.  We say that operator A is the
     commutator of operator B if (x A y) equals (y B x) for all possible input
     values x, y.  Notice that B is also the commutator of A.  For example,
     operators <literal>&lt;</literal> and <literal>&gt;</literal> for a particular data type are usually each others'
     commutators, and operator <literal>+</literal> is usually commutative with itself.
     But operator <literal>-</literal> is usually not commutative with anything.
    </para>
____________________________________________________________________________-->
    <para>
     如果提供了<literal>COMMUTATOR</literal>子句，它指定一个操作符作为被定义的操作符的交换子。如果对于所有可能输入的 x、y 值， (x A y) 等于 (y B x)，我们可以说操作符 A 是操作符 B 的交换子。注意，B 也是 A 的交换子。例如，用于一种特定数据类型的操作符 <literal>&lt;</literal> 和 <literal>&gt;</literal> 通常互为交换子，并且操作符 <literal>+</literal> 通常和它本身是交换的。但是操作符 <literal>-</literal> 通常不能与任何东西交换。
    </para>

<!--==========================orignal english content==========================
    <para>
     The left operand type of a commutable operator is the same as the
     right operand type of its commutator, and vice versa.  So the name of
     the commutator operator is all that <productname>PostgreSQL</productname>
     needs to be given to look up the commutator, and that's all that needs to
     be provided in the <literal>COMMUTATOR</literal> clause.
    </para>
____________________________________________________________________________-->
    <para>
     一个可交换操作符的左操作数类型与其交换子的右操作数类型相同，反之亦然。因此要查找交换子，只需要给<productname>PostgreSQL</productname>该交换子操作符的名称即可，并且在<literal>COMMUTATOR</literal>子句中也只需要提供它的名称。
    </para>

<!--==========================orignal english content==========================
    <para>
     It's critical to provide commutator information for operators that
     will be used in indexes and join clauses, because this allows the
     query optimizer to <quote>flip around</quote> such a clause to the forms
     needed for different plan types.  For example, consider a query with
     a WHERE clause like <literal>tab1.x = tab2.y</literal>, where <literal>tab1.x</literal>
     and <literal>tab2.y</literal> are of a user-defined type, and suppose that
     <literal>tab2.y</literal> is indexed.  The optimizer cannot generate an
     index scan unless it can determine how to flip the clause around to
     <literal>tab2.y = tab1.x</literal>, because the index-scan machinery expects
     to see the indexed column on the left of the operator it is given.
     <productname>PostgreSQL</productname> will <emphasis>not</emphasis> simply
     assume that this is a valid transformation &mdash; the creator of the
     <literal>=</literal> operator must specify that it is valid, by marking the
     operator with commutator information.
    </para>
____________________________________________________________________________-->
    <para>
     为将要在索引和连接子句中使用的操作符提供交换子信息是很关键的，因为这允许查询优化器把这样一个子句<quote>翻转</quote>成不同计划类型所需的形式。例如，考虑一个这样的 WHERE 子句<literal>tab1.x = tab2.y</literal>，其中<literal>tab1.x</literal>和<literal>tab2.y</literal>是一种用户定义的类型，并且假设<literal>tab2.y</literal>被索引。除非优化器能决定如何把该子句翻转成<literal>tab2.y = tab1.x</literal>，否则它无法产生一个索引扫描，因为索引扫描机制期望看到被索引列出现在被给出的操作符的左边。<productname>PostgreSQL</productname>将<emphasis>无法</emphasis>简单地假定有一个可用的变换 &mdash; <literal>=</literal>操作符的创建者必须指定它是合法的（通过为该操作符标记交换子信息）。
    </para>

<!--==========================orignal english content==========================
    <para>
     When you are defining a self-commutative operator, you just do it.
     When you are defining a pair of commutative operators, things are
     a little trickier: how can the first one to be defined refer to the
     other one, which you haven't defined yet?  There are two solutions
     to this problem:

     <itemizedlist>
      <listitem>
       <para>
        One way is to omit the <literal>COMMUTATOR</literal> clause in the first operator that
        you define, and then provide one in the second operator's definition.
        Since <productname>PostgreSQL</productname> knows that commutative
        operators come in pairs, when it sees the second definition it will
        automatically go back and fill in the missing <literal>COMMUTATOR</literal> clause in
        the first definition.
       </para>
      </listitem>

      <listitem>
       <para>
        The other, more straightforward way is just to include <literal>COMMUTATOR</literal> clauses
        in both definitions.  When <productname>PostgreSQL</productname> processes
        the first definition and realizes that <literal>COMMUTATOR</literal> refers to a nonexistent
        operator, the system will make a dummy entry for that operator in the
        system catalog.  This dummy entry will have valid data only
        for the operator name, left and right operand types, and result type,
        since that's all that <productname>PostgreSQL</productname> can deduce
        at this point.  The first operator's catalog entry will link to this
        dummy entry.  Later, when you define the second operator, the system
        updates the dummy entry with the additional information from the second
        definition.  If you try to use the dummy operator before it's been filled
        in, you'll just get an error message.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     在你定义一个子交换的操作符时，你这样做就行了。自拟定义一堆交换的操作符时，事情有一点棘手：如何在没有定义第二个操作符时完成第一个操作符的定义？因为第一个操作符需要第二个操作符作为其交换子。对这个问题有两种解决方案：

     <itemizedlist>
      <listitem>
       <para>
        一种方法是忽略你定义的第一个操作符的<literal>COMMUTATOR</literal>子句，并且然后在第二个操作符的定义中提供第一个操作符作为交换子。由于<productname>PostgreSQL</productname>知道交换的操作符是成对出现的，当它看到第二个定义时它将自动回去并且填上第一个定义中缺失的<literal>COMMUTATOR</literal>子句。
       </para>
      </listitem>

      <listitem>
       <para>
        另一种更直接的方法是就在两个定义中包括<literal>COMMUTATOR</literal>子句。当<productname>PostgreSQL</productname>处理第一个定义并且意识到<literal>COMMUTATOR</literal>引用了一个不存在的操作符时，系统将为那个操作符在系统目录中创造一个虚拟项。这个虚拟项只有操作符名称、左右操作数类型和结果类型的数据，因为这些是<productname>PostgreSQL</productname>在此时能够推断出来的所有东西。第一个操作符的目录项将会链接到这个虚拟项。稍后，当你定义第二个操作符时，系统用来自第二个定义的额外信息更新那个虚拟项。如果你尝试在虚拟操作符还未被填充之前使用它，你将只会得到一个错误消息。	
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title><literal>NEGATOR</literal></title>
____________________________________________________________________________-->
    <title><literal>NEGATOR</literal></title>

<!--==========================orignal english content==========================
    <para>
     The <literal>NEGATOR</literal> clause, if provided, names an operator that is the
     negator of the operator being defined.  We say that operator A
     is the negator of operator B if both return Boolean results and
     (x A y) equals NOT (x B y) for all possible inputs x, y.
     Notice that B is also the negator of A.
     For example, <literal>&lt;</literal> and <literal>&gt;=</literal> are a negator pair for most data types.
     An operator can never validly be its own negator.
    </para>
____________________________________________________________________________-->
    <para>
     如果提供了<literal>NEGATOR</literal>子句，它指定一个操作符是正在被定义的操作符的求反器。如果操作符 A 和 B 都返回布尔结果并且对于所有可能的 x、y 输入都有 (x A y) 等于 NOT (x B y)，那么我们可以说 A 是 B 的求反器。注意 B 也是 A 的求反器。例如，<literal>&lt;</literal> 和 <literal>&gt;=</literal> 就是大部分数据类型的一对求反器。一个操作符不可能是它自身的求反器。
    </para>

<!--==========================orignal english content==========================
   <para>
    Unlike commutators, a pair of unary operators could validly be marked
    as each other's negators; that would mean (A x) equals NOT (B x)
    for all x, or the equivalent for right unary operators.
   </para>
____________________________________________________________________________-->
   <para>
    与交换子不同，一对一元操作符可以合法地被标记为对方的求反器。这意味着对于所有 x 有 (A x) 等于 NOT (B x)，或者对右一元操作符也相似。
   </para>

<!--==========================orignal english content==========================
   <para>
    An operator's negator must have the same left and/or right operand types
    as the operator to be defined, so just as with <literal>COMMUTATOR</literal>, only the operator
    name need be given in the <literal>NEGATOR</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    一个操作符的求反器必须具有和被定义的操作符相同的左或右操作数类型，因此正如<literal>COMMUTATOR</literal>一样，<literal>NEGATOR</literal>子句中只需要给出操作符的名称即可。
   </para>

<!--==========================orignal english content==========================
   <para>
    Providing a negator is very helpful to the query optimizer since
    it allows expressions like <literal>NOT (x = y)</literal> to be simplified into
    <literal>x &lt;&gt; y</literal>.  This comes up more often than you might think, because
    <literal>NOT</literal> operations can be inserted as a consequence of other rearrangements.
   </para>
____________________________________________________________________________-->
   <para>
    提供一个求反器对查询优化器非常有帮助，因为它允许<literal>NOT (x = y)</literal>这样的表达式被简化为<literal>x &lt;&gt; y</literal>。这可能比你想象的更多地发生，因为<literal>NOT</literal>操作可能会被作为其他调整的结果被插入。
   </para>

<!--==========================orignal english content==========================
   <para>
    Pairs of negator operators can be defined using the same methods
    explained above for commutator pairs.
   </para>
____________________________________________________________________________-->
   <para>
    求反器对的定义可以使用与定义交换子对相同的方法来完成。
   </para>

  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>RESTRICT</literal></title>
____________________________________________________________________________-->
   <title><literal>RESTRICT</literal></title>

<!--==========================orignal english content==========================
   <para>
    The <literal>RESTRICT</literal> clause, if provided, names a restriction selectivity
    estimation function for the operator.  (Note that this is a function
    name, not an operator name.)  <literal>RESTRICT</literal> clauses only make sense for
    binary operators that return <type>boolean</type>.  The idea behind a restriction
    selectivity estimator is to guess what fraction of the rows in a
    table will satisfy a <literal>WHERE</literal>-clause condition of the form:
<programlisting>
column OP constant
</programlisting>
    for the current operator and a particular constant value.
    This assists the optimizer by
    giving it some idea of how many rows will be eliminated by <literal>WHERE</literal>
    clauses that have this form.  (What happens if the constant is on
    the left, you might be wondering?  Well, that's one of the things that
    <literal>COMMUTATOR</literal> is for...)
   </para>
____________________________________________________________________________-->
   <para>
    如果提供了<literal>RESTRICT</literal>子句，它为该操作符指定一个限制选择度估计函数（注意这是一个函数名而不是一个操作符名）。<literal>RESTRICT</literal>子句只对返回<type>boolean</type>的二元操作符有意义。一个限制选择度估计器背后的思想是猜测一个表中有多大比例的行对于当前的操作符和一个特定的常数值将会满足一个
<programlisting>
column OP constant
</programlisting>
    形式的<literal>WHERE</literal>子句条件。这能通过告知优化器具有这种形式的<literal>WHERE</literal>子句将会消除掉多少行来协助它的工作（你可能会好奇，如果常数位于左部会发生什么？好吧，<literal>COMMUTATOR</literal>就是干这个的）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Writing new restriction selectivity estimation functions is far beyond
    the scope of this chapter, but fortunately you can usually just use
    one of the system's standard estimators for many of your own operators.
    These are the standard restriction estimators:
    <simplelist>
     <member><function>eqsel</function> for <literal>=</literal></member>
     <member><function>neqsel</function> for <literal>&lt;&gt;</literal></member>
     <member><function>scalarltsel</function> for <literal>&lt;</literal></member>
     <member><function>scalarlesel</function> for <literal>&lt;=</literal></member>
     <member><function>scalargtsel</function> for <literal>&gt;</literal></member>
     <member><function>scalargesel</function> for <literal>&gt;=</literal></member>
    </simplelist>
   </para>
____________________________________________________________________________-->
   <para>
    编写一个新的限制选择度估算函数已经超出了本章的范围，但是幸运地是你通常可以将系统的一个标准估算器用于很多你自己的操作符。标准的限制估算器有：
    <simplelist>
     <member><function>eqsel</function>用于<literal>=</literal></member>
     <member><function>neqsel</function>用于<literal>&lt;&gt;</literal></member>
     <member><function>scalarltsel</function>用于<literal>&lt;</literal></member>
     <member><function>scalarlesel</function>用于<literal>&lt;=</literal></member>
     <member><function>scalargtsel</function>用于<literal>&gt;</literal></member>
     <member><function>scalargesel</function>用于<literal>&gt;=</literal></member>
   </simplelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    You can frequently get away with using either <function>eqsel</function> or <function>neqsel</function> for
    operators that have very high or very low selectivity, even if they
    aren't really equality or inequality.  For example, the
    approximate-equality geometric operators use <function>eqsel</function> on the assumption that
    they'll usually only match a small fraction of the entries in a table.
   </para>
____________________________________________________________________________-->
   <para>
    你能经常成功地为具有非常高或者非常低选择度的操作符使用<function>eqsel</function>或<function>neqsel</function>，即使它们实际上并非相等或不相等。例如，近似相等几何操作符使用<function>eqsel</function>的前提是假定它们通常只匹配表中的一小部分项。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can use <function>scalarltsel</function>, <function>scalarlesel</function>,
    <function>scalargtsel</function> and <function>scalargesel</function> for comparisons on
    data types that have some sensible means of being converted into numeric
    scalars for range comparisons.  If possible, add the data type to those
    understood by the function <function>convert_to_scalar()</function> in
    <filename>src/backend/utils/adt/selfuncs.c</filename>.
    (Eventually, this function should be replaced by per-data-type functions
    identified through a column of the <classname>pg_type</classname> system catalog; but that hasn't happened
    yet.)  If you do not do this, things will still work, but the optimizer's
    estimates won't be as good as they could be.
   </para>
____________________________________________________________________________-->
   <para>
    你可以使用<function>scalarltsel</function>、<function>scalarlesel</function>、<function>scalargtsel</function>以及<function>scalargesel</function>来比较被转换为数字标量进行范围比较具有意义的数据类型。如果可能，增加一种能被<filename>src/backend/utils/adt/selfuncs.c</filename>中的函数<function>convert_to_scalar()</function>所理解的数据类型（最后，这个函数应该被通过<classname>pg_type</classname>系统目录的一列所标识的针对每个数据类型的函数所替换，但是那还没有发生）。如果你没有这样做，还是能工作，但是优化器的估计将不会达到最好的效果。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are additional selectivity estimation functions designed for geometric
    operators in <filename>src/backend/utils/adt/geo_selfuncs.c</filename>: <function>areasel</function>, <function>positionsel</function>,
    and <function>contsel</function>.  At this writing these are just stubs, but you might want
    to use them (or even better, improve them) anyway.
   </para>
____________________________________________________________________________-->
   <para>
    有一些额外的选择度估算函数是为<filename>src/backend/utils/adt/geo_selfuncs.c</filename>中的几何操作符设计的：<function>areasel</function>、<function>positionsel</function>和<function>contsel</function>。在写这份材料时，这些还只是存根，但是你可能想要使用它们（或者甚至改进它们）。
   </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title><literal>JOIN</literal></title>
____________________________________________________________________________-->
    <title><literal>JOIN</literal></title>

<!--==========================orignal english content==========================
    <para>
     The <literal>JOIN</literal> clause, if provided, names a join selectivity
     estimation function for the operator.  (Note that this is a function
     name, not an operator name.)  <literal>JOIN</literal> clauses only make sense for
     binary operators that return <type>boolean</type>.  The idea behind a join
     selectivity estimator is to guess what fraction of the rows in a
     pair of tables will satisfy a <literal>WHERE</literal>-clause condition of the form:
<programlisting>
table1.column1 OP table2.column2
</programlisting>
     for the current operator.  As with the <literal>RESTRICT</literal> clause, this helps
     the optimizer very substantially by letting it figure out which
     of several possible join sequences is likely to take the least work.
    </para>
____________________________________________________________________________-->
    <para>
     如果提供了<literal>JOIN</literal>子句，表示用于该操作符的一个连接选择度估计函数（注意这是一个函数名而不是一个操作符名）。<literal>JOIN</literal>子句只对返回<type>boolean</type>的二元操作符有意义。一个连接选择度估算器背后的思想是猜测一对表中有多大比例的行对于当前的操作符将会满足一个
<programlisting>
table1.column1 OP table2.column2
</programlisting>
     形式的<literal>WHERE</literal>子句条件。和<literal>RESTRICT</literal>子句一样，这通过让优化器知道哪种连接序列需要做的工作最少来极大地帮助优化器。
    </para>

<!--==========================orignal english content==========================
    <para>
     As before, this chapter will make no attempt to explain how to write
     a join selectivity estimator function, but will just suggest that
     you use one of the standard estimators if one is applicable:
     <simplelist>
      <member><function>eqjoinsel</function> for <literal>=</literal></member>
      <member><function>neqjoinsel</function> for <literal>&lt;&gt;</literal></member>
      <member><function>scalarltjoinsel</function> for <literal>&lt;</literal></member>
      <member><function>scalarlejoinsel</function> for <literal>&lt;=</literal></member>
      <member><function>scalargtjoinsel</function> for <literal>&gt;</literal></member>
      <member><function>scalargejoinsel</function> for <literal>&gt;=</literal></member>
      <member><function>areajoinsel</function> for 2D area-based comparisons</member>
      <member><function>positionjoinsel</function> for 2D position-based comparisons</member>
      <member><function>contjoinsel</function> for 2D containment-based comparisons</member>
     </simplelist>
    </para>
____________________________________________________________________________-->
    <para>
     一如既往，这一章将不会尝试解释如何编写一个连接选择度估算函数，而只是建议你在适当的时候使用一种标准估算器：
     <simplelist>
      <member><function>eqjoinsel</function>用于<literal>=</literal></member>
      <member><function>neqjoinsel</function>用于<literal>&lt;&gt;</literal></member>
      <member><function>scalarltjoinsel</function>用于<literal>&lt;</literal></member>
      <member><function>scalarlejoinsel</function>用于<literal>&lt;=</literal></member>
      <member><function>scalargtjoinsel</function>用于<literal>&gt;</literal></member>
      <member><function>scalargejoinsel</function>用于<literal>&gt;=</literal></member>
      <member><function>areajoinsel</function>用于基于 2D 区域比较</member>
      <member><function>positionjoinsel</function>用于基于 2D 位置比较</member>
      <member><function>contjoinsel</function>用于基于 2D 包含比较</member>
     </simplelist>
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title><literal>HASHES</literal></title>
____________________________________________________________________________-->
    <title><literal>HASHES</literal></title>

<!--==========================orignal english content==========================
    <para>
     The <literal>HASHES</literal> clause, if present, tells the system that
     it is permissible to use the hash join method for a join based on this
     operator.  <literal>HASHES</literal> only makes sense for a binary operator that
     returns <literal>boolean</literal>, and in practice the operator must represent
     equality for some data type or pair of data types.
    </para>
____________________________________________________________________________-->
    <para>
     如果存在<literal>HASHES</literal>子句，它告诉系统它被许可为基于这个操作符的一个连接使用哈希连接方法。<literal>HASHES</literal>只对返回<literal>boolean</literal>的二元操作符有意义，并且实际上该操作符必须必须表达某种数据类型或数据类型对的相等。
    </para>

<!--==========================orignal english content==========================
    <para>
     The assumption underlying hash join is that the join operator can
     only return true for pairs of left and right values that hash to the
     same hash code.  If two values get put in different hash buckets, the
     join will never compare them at all, implicitly assuming that the
     result of the join operator must be false.  So it never makes sense
     to specify <literal>HASHES</literal> for operators that do not represent
     some form of equality.  In most cases it is only practical to support
     hashing for operators that take the same data type on both sides.
     However, sometimes it is possible to design compatible hash functions
     for two or more data types; that is, functions that will generate the
     same hash codes for <quote>equal</quote> values, even though the values
     have different representations.  For example, it's fairly simple
     to arrange this property when hashing integers of different widths.
    </para>
____________________________________________________________________________-->
    <para>
     哈希连接之下的假设是连接操作符只能对哈希到相同哈希码的左右值返回真。如果两个值被放到不同的哈希桶中，连接将根本不会比较它们，这隐式地假定该连接操作符的结果必须是假。因此，为不表示某种形式相等的操作符指定<literal>HASHES</literal>是没有意义的。在大部分情况下，只有为在两端都是相同数据类型的操作符支持哈希才有意义。不过，有时可以为两种或更多数据类型设计兼容的哈希函数，也就是说，对于<quote>相等</quote>的值（即使具有不同的表达）会产生相同哈希码的函数。例如，在哈希不同宽度的证书时，安排这个属性相当简单。
    </para>

<!--==========================orignal english content==========================
    <para>
     To be marked <literal>HASHES</literal>, the join operator must appear
     in a hash index operator family.  This is not enforced when you create
     the operator, since of course the referencing operator family couldn't
     exist yet.  But attempts to use the operator in hash joins will fail
     at run time if no such operator family exists.  The system needs the
     operator family to find the data-type-specific hash function(s) for the
     operator's input data type(s).  Of course, you must also create suitable
     hash functions before you can create the operator family.
    </para>
____________________________________________________________________________-->
    <para>
     要被标记为<literal>HASHES</literal>，连接操作符必须出现在一个哈希索引操作符族中。当你创建该操作符时这不会被强制，因为要引用的操作符族当然不可能已经存在。但是如果这样的操作符族不存在，尝试在哈希连接中使用该操作符将在运行时失败。系统需要用该操作符族来为操作符的输入数据类型寻找数据类型相关的哈希函数。当然，在创建操作符族之前，你还必须创建合适的哈希函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Care should be exercised when preparing a hash function, because there
     are machine-dependent ways in which it might fail to do the right thing.
     For example, if your data type is a structure in which there might be
     uninteresting pad bits, you cannot simply pass the whole structure to
     <function>hash_any</function>.  (Unless you write your other operators and
     functions to ensure that the unused bits are always zero, which is the
     recommended strategy.)
     Another example is that on machines that meet the <acronym>IEEE</acronym>
     floating-point standard, negative zero and positive zero are different
     values (different bit patterns) but they are defined to compare equal.
     If a float value might contain negative zero then extra steps are needed
     to ensure it generates the same hash value as positive zero.
    </para>
____________________________________________________________________________-->
    <para>
     在准备一个哈希函数时应当慎重，因为有一些方法是依赖于机器的，这样它可能无法做正确的事情。例如，如果你的数据类型是一个结构，其中可能有无用的填充位，你不能简单地把整个结构传递给<function>hash_any</function>（除非你编写你自己的操作符和函数按照推荐的策略来保证未被使用的位总是为零）。另一个例子是在符合<acronym>IEEE</acronym>浮点标准的机器上，负数零和正数零是不同的值（不同的位模式），但是它们被定义为相等。如果一个浮点值可能包含负数零，那么需要额外的步骤来保证它产生的哈希值与正数零产生的相同。
    </para>

<!--==========================orignal english content==========================
    <para>
     A hash-joinable operator must have a commutator (itself if the two
     operand data types are the same, or a related equality operator
     if they are different) that appears in the same operator family.
     If this is not the case, planner errors might occur when the operator
     is used.  Also, it is a good idea (but not strictly required) for
     a hash operator family that supports multiple data types to provide
     equality operators for every combination of the data types; this
     allows better optimization.
    </para>
____________________________________________________________________________-->
    <para>
     一个可哈希连接的操作符必须拥有一个出现在同一操作符族中的交换子（如果两个操作数数据类型相同，那么就是它自身，否则是一个相关的相等操作符）。如果情况不是这样，在使用该操作符时，可能会发生规划器错误。此外，一个支持多种数据类型的哈希操作符族为数据类型的每一种组合都提供相等操作符是一个好主意（但是并不被严格要求），这会带来更好的优化。
    </para>

    <note>
<!--==========================orignal english content==========================
    <para>
     The function underlying a hash-joinable operator must be marked
     immutable or stable.  If it is volatile, the system will never
     attempt to use the operator for a hash join.
    </para>
____________________________________________________________________________-->
    <para>
     一个可哈希连接的操作符底层的函数必须被标记为可交换或者稳定。如果它是不稳定的，系统将永远不会为一个哈希连接尝试使用该操作符。
    </para>
    </note>

    <note>
<!--==========================orignal english content==========================
    <para>
     If a hash-joinable operator has an underlying function that is marked
     strict, the
     function must also be complete: that is, it should return true or
     false, never null, for any two nonnull inputs.  If this rule is
     not followed, hash-optimization of <literal>IN</literal> operations might
     generate wrong results.  (Specifically, <literal>IN</literal> might return
     false where the correct answer according to the standard would be null;
     or it might yield an error complaining that it wasn't prepared for a
     null result.)
    </para>
____________________________________________________________________________-->
    <para>
     如果一个可哈希连接的操作符有一个被标记为 strict 的底层函数，该函数必须也是 complete：也就是对于任意两个非空输入它应当返回真或假，从不会返回空。如果没有遵守这个规则，<literal>IN</literal>操作的哈希优化可能产生错误的结果（特别是，当依据标准的正确答案可能是空时，<literal>IN</literal>可能会返回假，或者它会产生一个错误来抱怨它没有准备会收到一个空结果）。
    </para>
    </note>

   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title><literal>MERGES</literal></title>
____________________________________________________________________________-->
    <title><literal>MERGES</literal></title>

<!--==========================orignal english content==========================
    <para>
     The <literal>MERGES</literal> clause, if present, tells the system that
     it is permissible to use the merge-join method for a join based on this
     operator.  <literal>MERGES</literal> only makes sense for a binary operator that
     returns <literal>boolean</literal>, and in practice the operator must represent
     equality for some data type or pair of data types.
    </para>
____________________________________________________________________________-->
    <para>
     如果存在<literal>MERGES</literal>子句，它告诉系统它被许可为基于这个操作符的一个连接使用归并连接方法。<literal>MERGES</literal>只对返回<literal>boolean</literal>的二元操作符有意义，并且实际上该操作符必须必须表达某种数据类型或数据类型对的相等。
    </para>

<!--==========================orignal english content==========================
    <para>
     Merge join is based on the idea of sorting the left- and right-hand tables
     into order and then scanning them in parallel.  So, both data types must
     be capable of being fully ordered, and the join operator must be one
     that can only succeed for pairs of values that fall at the
     <quote>same place</quote>
     in the sort order.  In practice this means that the join operator must
     behave like equality.  But it is possible to merge-join two
     distinct data types so long as they are logically compatible.  For
     example, the <type>smallint</type>-versus-<type>integer</type>
     equality operator is merge-joinable.
     We only need sorting operators that will bring both data types into a
     logically compatible sequence.
    </para>
____________________________________________________________________________-->
    <para>
     归并连接的思想是排序左右手表并且接着并行扫描它们。这样，两种数据类型必须能够被完全排序，并且该连接操作符必须只为落在排序顺序上<quote>同一位置</quote>的值对返回成功。实际上这意味着该连接操作符必须和相等的行为一样。但是只要两种不同的数据类型在逻辑上是兼容的，就能对它们使用归并连接。例如，<type>smallint</type>-versus-<type>integer</type>相等操作符就是可归并连接的。我们只需要将两种数据类型变成逻辑上兼容的序列的排序操作符。
    </para>

<!--==========================orignal english content==========================
    <para>
     To be marked <literal>MERGES</literal>, the join operator must appear
     as an equality member of a <literal>btree</literal> index operator family.
     This is not enforced when you create
     the operator, since of course the referencing operator family couldn't
     exist yet.  But the operator will not actually be used for merge joins
     unless a matching operator family can be found.  The
     <literal>MERGES</literal> flag thus acts as a hint to the planner that
     it's worth looking for a matching operator family.
    </para>
____________________________________________________________________________-->
    <para>
     要被标记为<literal>MERGES</literal>，该连接操作符必须作为一个<literal>btree</literal>索引操作符的相等成员出现。当你创建该操作符时，这不是强制的，因为要引用的操作符族当然可能还不存在。但是除非能找到一个匹配的操作符族，否则该操作符将不会被实际用于归并连接。<literal>MERGES</literal>标志因此扮演着一种对于规划器的提示，表示值得去寻找一个匹配的操作符族。
    </para>

<!--==========================orignal english content==========================
    <para>
     A merge-joinable operator must have a commutator (itself if the two
     operand data types are the same, or a related equality operator
     if they are different) that appears in the same operator family.
     If this is not the case, planner errors might occur when the operator
     is used.  Also, it is a good idea (but not strictly required) for
     a <literal>btree</literal> operator family that supports multiple data types to provide
     equality operators for every combination of the data types; this
     allows better optimization.
    </para>
____________________________________________________________________________-->
    <para>
     一个可归并连接的操作符必须拥有一个出现在同一操作符族中的交换子（如果两个操作数数据类型相同，那么就是它自身，否则是一个相关的相等操作符）。如果情况不是这样，在使用该操作符时，可能会发生规划器错误。此外，一个支持多种数据类型的<literal>btree</literal>操作符族为数据类型的每一种组合都提供相等操作符是一个好主意（但是并不被严格要求），这会带来更好的优化。
    </para>

    <note>
<!--==========================orignal english content==========================
    <para>
     The function underlying a merge-joinable operator must be marked
     immutable or stable.  If it is volatile, the system will never
     attempt to use the operator for a merge join.
    </para>
____________________________________________________________________________-->
    <para>
     一个可归并连接的操作符底层的函数必须被标记为可交换或者稳定。如果它是不稳定的，系统将永远不会为一个归并连接尝试使用该操作符。
    </para>
    </note>
   </sect2>
  </sect1>
