<!-- doc/src/sgml/client-auth.sgml -->

<chapter id="client-authentication">
<!--==========================orignal english content==========================
 <title>Client Authentication</title>
____________________________________________________________________________-->
 <title>客户端认证</title>

<!--==========================orignal english content==========================
 <indexterm zone="client-authentication">
  <primary>client authentication</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="client-authentication">
  <primary>客户端认证</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  When a client application connects to the database server, it
  specifies which <productname>PostgreSQL</productname> database user name it
  wants to connect as, much the same way one logs into a Unix computer
  as a particular user. Within the SQL environment the active database
  user name determines access privileges to database objects &mdash; see
  <xref linkend="user-manag"/> for more information. Therefore, it is
  essential to restrict which database users can connect.
 </para>
____________________________________________________________________________-->
 <para>
  当一个客户端应用连接一个数据库服务器时，它将指定以哪个<productname>PostgreSQL</productname> 数据库用户名连接，就像我们以一个特定用户登录一台 Unix 计算机一样。在 SQL 环境中，活动的数据库用户名决定对数据库对象的访问权限 &mdash; 详见<xref linkend="user-manag"/>。因此，它本质上是哪些数据库用户可以连接。
 </para>

 <note>
<!--==========================orignal english content==========================
  <para>
   As explained in <xref linkend="user-manag"/>,
   <productname>PostgreSQL</productname> actually does privilege
   management in terms of <quote>roles</quote>.  In this chapter, we
   consistently use <firstterm>database user</firstterm> to mean <quote>role with the
   <literal>LOGIN</literal> privilege</quote>.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="user-manag"/>中所释，<productname>PostgreSQL</productname>实际上以<quote>角色</quote>来进行权限管理。在本章中，我们用<firstterm>数据库用户</firstterm>表示<quote>拥有<literal>LOGIN</literal>权限的角色</quote>。
  </para>
 </note>

<!--==========================orignal english content==========================
 <para>
  <firstterm>Authentication</firstterm> is the process by which the
  database server establishes the identity of the client, and by
  extension determines whether the client application (or the user
  who runs the client application) is permitted to connect with the
  database user name that was requested.
 </para>
____________________________________________________________________________-->
 <para>
  <firstterm>认证</firstterm>是数据库服务器建立客户端身份的过程，并且服务器决定客户端应用（或者运行客户端应用的用户）是否被允许以请求的数据库用户名来连接。
 </para>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> offers a number of different
  client authentication methods. The method used to authenticate a
  particular client connection can be selected on the basis of
  (client) host address, database, and user.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>提供多种不同的客户端认证方式。被用来认证一个特定客户端连接的方法可以基于（客户端）主机地址、数据库和用户来选择。
 </para>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> database user names are logically
  separate from user names of the operating system in which the server
  runs. If all the users of a particular server also have accounts on
  the server's machine, it makes sense to assign database user names
  that match their operating system user names. However, a server that
  accepts remote connections might have many database users who have no local
  operating system
  account, and in such cases there need be no connection between
  database user names and OS user names.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>数据库用户名在逻辑上是和服务器运行的操作系统中的用户名相互独立的。如果一个特定服务器的所有用户在那台服务器的机器上也有帐号，那么分配与操作系统用户名匹配的数据库用户名是有意义的。不过，一个接受远程连接的服务器可能有许多没有本地操作系统帐号的用户，并且在这种情况下数据库用户和操作系统用户名之间不必有任何联系。
 </para>

 <sect1 id="auth-pg-hba-conf">
<!--==========================orignal english content==========================
  <title>The <filename>pg_hba.conf</filename> File</title>
____________________________________________________________________________-->
  <title><filename>pg_hba.conf</filename>文件</title>

<!--==========================orignal english content==========================
  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Client authentication is controlled by a configuration file,
   which traditionally is named
   <filename>pg_hba.conf</filename> and is stored in the database
   cluster's data directory.
   (<acronym>HBA</acronym> stands for host-based authentication.) A default
   <filename>pg_hba.conf</filename> file is installed when the data
   directory is initialized by <command>initdb</command>.  It is
   possible to place the authentication configuration file elsewhere,
   however; see the <xref linkend="guc-hba-file"/> configuration parameter.
  </para>
____________________________________________________________________________-->
  <para>
   客户端认证是由一个配置文件（通常名为<filename>pg_hba.conf</filename>并被存放在数据库集簇目录中）控制（<acronym>HBA</acronym>表示基于主机的认证）。在<command>initdb</command>初始化数据目录时，它会安装一个默认的<filename>pg_hba.conf</filename>文件。不过我们也可以把认证配置文件放在其它地方； 参阅<xref linkend="guc-hba-file"/>配置参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The general format of the <filename>pg_hba.conf</filename> file is
   a set of records, one per line. Blank lines are ignored, as is any
   text after the <literal>#</literal> comment character.
   Records cannot be continued across lines.
   A record is made
   up of a number of fields which are separated by spaces and/or tabs.
   Fields can contain white space if the field value is double-quoted.
   Quoting one of the keywords in a database, user, or address field (e.g.,
   <literal>all</literal> or <literal>replication</literal>) makes the word lose its special
   meaning, and just match a database, user, or host with that name.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>pg_hba.conf</filename>文件的常用格式是一组记录，每行一条。空白行将被忽略， <literal>#</literal>注释字符后面的任何文本也被忽略。记录不能跨行。一条记录由若干用空格
   和/或制表符分隔的域组成。如果域值用双引号包围，那么它可以包含空白。在数据库、用户或地址域中
   引用一个关键字（例如，<literal>all</literal>或<literal>replication</literal>）将使该词失去其特殊
   含义，并且只是匹配一个有该名字的数据库、用户或主机。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each record specifies a connection type, a client IP address range
   (if relevant for the connection type), a database name, a user name,
   and the authentication method to be used for connections matching
   these parameters. The first record with a matching connection type,
   client address, requested database, and user name is used to perform
   authentication. There is no <quote>fall-through</quote> or
   <quote>backup</quote>: if one record is chosen and the authentication
   fails, subsequent records are not considered. If no record matches,
   access is denied.
  </para>
____________________________________________________________________________-->
  <para>
   每条记录指定一种连接类型、一个客户端 IP 地址范围（如果和连接类型相关）、一个数据库名、一个用户名以及对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、客户端地址、连接请求的数据库和用户名的记录将被用于执行认证。这个过程没有<quote>落空</quote>或者<quote>后备</quote>的说法：如果选择了一条记录而且认证失败，那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
  </para>

<!--==========================orignal english content==========================
  <para>
   A record can have one of the seven formats
<synopsis>
local      <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
   The meaning of the fields is as follows:

   <variablelist>
    <varlistentry>
     <term><literal>local</literal></term>
     <listitem>
      <para>
       This record matches connection attempts using Unix-domain
       sockets.  Without a record of this type, Unix-domain socket
       connections are disallowed.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       This record matches connection attempts made using TCP/IP.
       <literal>host</literal> records match either
       <acronym>SSL</acronym> or non-<acronym>SSL</acronym> connection
       attempts.
      </para>
     <note>
      <para>
       Remote TCP/IP connections will not be possible unless
       the server is started with an appropriate value for the
       <xref linkend="guc-listen-addresses"/> configuration parameter,
       since the default behavior is to listen for TCP/IP connections
       only on the local loopback address <literal>localhost</literal>.
      </para>
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       This record matches connection attempts made using TCP/IP,
       but only when the connection is made with <acronym>SSL</acronym>
       encryption.
      </para>

      <para>
       To make use of this option the server must be built with
       <acronym>SSL</acronym> support. Furthermore,
       <acronym>SSL</acronym> must be enabled
       by setting the <xref linkend="guc-ssl"/> configuration parameter (see
       <xref linkend="ssl-tcp"/> for more information).
       Otherwise, the <literal>hostssl</literal> record is ignored except for
       logging a warning that it cannot match any connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       This record type has the opposite behavior of <literal>hostssl</literal>;
       it only matches connection attempts made over
       TCP/IP that do not use <acronym>SSL</acronym>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       Specifies which database name(s) this record matches.  The value
       <literal>all</literal> specifies that it matches all databases.
       The value <literal>sameuser</literal> specifies that the record
       matches if the requested database has the same name as the
       requested user.  The value <literal>samerole</literal> specifies that
       the requested user must be a member of the role with the same
       name as the requested database.  (<literal>samegroup</literal> is an
       obsolete but still accepted spelling of <literal>samerole</literal>.)
       Superusers are not considered to be members of a role for the
       purposes of <literal>samerole</literal> unless they are explicitly
       members of the role, directly or indirectly, and not just by
       virtue of being a superuser.
       The value <literal>replication</literal> specifies that the record
       matches if a physical replication connection is requested (note that
       replication connections do not specify any particular database).
       Otherwise, this is the name of
       a specific <productname>PostgreSQL</productname> database.
       Multiple database names can be supplied by separating them with
       commas.  A separate file containing database names can be specified by
       preceding the file name with <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       Specifies which database user name(s) this record
       matches. The value <literal>all</literal> specifies that it
       matches all users.  Otherwise, this is either the name of a specific
       database user, or a group name preceded by <literal>+</literal>.
       (Recall that there is no real distinction between users and groups
       in <productname>PostgreSQL</productname>; a <literal>+</literal> mark really means
       <quote>match any of the roles that are directly or indirectly members
       of this role</quote>, while a name without a <literal>+</literal> mark matches
       only that specific role.) For this purpose, a superuser is only
       considered to be a member of a role if they are explicitly a member
       of the role, directly or indirectly, and not just by virtue of
       being a superuser.
       Multiple user names can be supplied by separating them with commas.
       A separate file containing user names can be specified by preceding the
       file name with <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       Specifies the client machine address(es) that this record
       matches.  This field can contain either a host name, an IP
       address range, or one of the special key words mentioned below.
      </para>

      <para>
       An IP address range is specified using standard numeric notation
       for the range's starting address, then a slash (<literal>/</literal>)
       and a <acronym>CIDR</acronym> mask length.  The mask
       length indicates the number of high-order bits of the client
       IP address that must match.  Bits to the right of this should
       be zero in the given IP address.
       There must not be any white space between the IP address, the
       <literal>/</literal>, and the CIDR mask length.
      </para>

      <para>
       Typical examples of an IPv4 address range specified this way are
       <literal>172.20.143.89/32</literal> for a single host, or
       <literal>172.20.143.0/24</literal> for a small network, or
       <literal>10.6.0.0/16</literal> for a larger one.
       An IPv6 address range might look like <literal>::1/128</literal>
       for a single host (in this case the IPv6 loopback address) or
       <literal>fe80::7a31:c1ff:0000:0000/96</literal> for a small
       network.
       <literal>0.0.0.0/0</literal> represents all
       IPv4 addresses, and <literal>::0/0</literal> represents
       all IPv6 addresses.
       To specify a single host, use a mask length of 32 for IPv4 or
       128 for IPv6.  In a network address, do not omit trailing zeroes.
      </para>

      <para>
       An entry given in IPv4 format will match only IPv4 connections,
       and an entry given in IPv6 format will match only IPv6 connections,
       even if the represented address is in the IPv4-in-IPv6 range.
       Note that entries in IPv6 format will be rejected if the system's
       C library does not have support for IPv6 addresses.
      </para>

      <para>
       You can also write <literal>all</literal> to match any IP address,
       <literal>samehost</literal> to match any of the server's own IP
       addresses, or <literal>samenet</literal> to match any address in any
       subnet that the server is directly connected to.
      </para>

      <para>
       If a host name is specified (anything that is not an IP address
       range or a special key word is treated as a host name),
       that name is compared with the result of a reverse name
       resolution of the client's IP address (e.g., reverse DNS
       lookup, if DNS is used).  Host name comparisons are case
       insensitive.  If there is a match, then a forward name
       resolution (e.g., forward DNS lookup) is performed on the host
       name to check whether any of the addresses it resolves to are
       equal to the client's IP address.  If both directions match,
       then the entry is considered to match.  (The host name that is
       used in <filename>pg_hba.conf</filename> should be the one that
       address-to-name resolution of the client's IP address returns,
       otherwise the line won't be matched.  Some host name databases
       allow associating an IP address with multiple host names, but
       the operating system will only return one host name when asked
       to resolve an IP address.)
      </para>

      <para>
       A host name specification that starts with a dot
       (<literal>.</literal>) matches a suffix of the actual host
       name.  So <literal>.example.com</literal> would match
       <literal>foo.example.com</literal> (but not just
       <literal>example.com</literal>).
      </para>

      <para>
       When host names are specified
       in <filename>pg_hba.conf</filename>, you should make sure that
       name resolution is reasonably fast.  It can be of advantage to
       set up a local name resolution cache such
       as <command>nscd</command>.  Also, you may wish to enable the
       configuration parameter <varname>log_hostname</varname> to see
       the client's host name instead of the IP address in the log.
      </para>

      <para>
       This field only applies to <literal>host</literal>,
       <literal>hostssl</literal>, and <literal>hostnossl</literal> records.
      </para>

      <note>
       <para>
        Users sometimes wonder why host names are handled
        in this seemingly complicated way, with two name resolutions
        including a reverse lookup of the client's IP address.  This
        complicates use of the feature in case the client's reverse DNS
        entry is not set up or yields some undesirable host name.
        It is done primarily for efficiency: this way, a connection attempt
        requires at most two resolver lookups, one reverse and one forward.
        If there is a resolver problem with some address, it becomes only
        that client's problem.  A hypothetical alternative
        implementation that only did forward lookups would have to
        resolve every host name mentioned in
        <filename>pg_hba.conf</filename> during every connection attempt.
        That could be quite slow if many names are listed.
        And if there is a resolver problem with one of the host names,
        it becomes everyone's problem.
       </para>

       <para>
        Also, a reverse lookup is necessary to implement the suffix
        matching feature, because the actual client host name needs to
        be known in order to match it against the pattern.
       </para>

       <para>
        Note that this behavior is consistent with other popular
        implementations of host name-based access control, such as the
        Apache HTTP Server and TCP Wrappers.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       These two fields can be used as an alternative to the
       <replaceable>IP-address</replaceable><literal>/</literal><replaceable>mask-length</replaceable>
       notation.  Instead of
       specifying the mask length, the actual mask is specified in a
       separate column. For example, <literal>255.0.0.0</literal> represents an IPv4
       CIDR mask length of 8, and <literal>255.255.255.255</literal> represents a
       CIDR mask length of 32.
      </para>

      <para>
       These fields only apply to <literal>host</literal>,
       <literal>hostssl</literal>, and <literal>hostnossl</literal> records.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
     <listitem>
      <para>
       Specifies the authentication method to use when a connection matches
       this record. The possible choices are summarized here; details
       are in <xref linkend="auth-methods"/>.

       <variablelist>
        <varlistentry>
         <term><literal>trust</literal></term>
         <listitem>
         <para>
          Allow the connection unconditionally. This method
          allows anyone that can connect to the
          <productname>PostgreSQL</productname> database server to login as
          any <productname>PostgreSQL</productname> user they wish,
          without the need for a password or any other authentication.  See <xref
          linkend="auth-trust"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</literal></term>
        <listitem>
         <para>
          Reject the connection unconditionally. This is useful for
          <quote>filtering out</quote> certain hosts from a group, for example a
          <literal>reject</literal> line could block a specific host from connecting,
          while a later line allows the remaining hosts in a specific
          network to connect.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>scram-sha-256</literal></term>
        <listitem>
         <para>
          Perform SCRAM-SHA-256 authentication to verify the user's
          password. See <xref linkend="auth-password"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</literal></term>
        <listitem>
         <para>
          Perform SCRAM-SHA-256 or MD5 authentication to verify the
          user's password. See <xref linkend="auth-password"/>
          for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</literal></term>
        <listitem>
         <para>
          Require the client to supply an unencrypted password for
          authentication.
          Since the password is sent in clear text over the
          network, this should not be used on untrusted networks.
          See <xref linkend="auth-password"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</literal></term>
        <listitem>
         <para>
          Use GSSAPI to authenticate the user. This is only
          available for TCP/IP connections. See <xref
          linkend="gssapi-auth"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</literal></term>
        <listitem>
         <para>
          Use SSPI to authenticate the user. This is only
          available on Windows. See <xref
          linkend="sspi-auth"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</literal></term>
        <listitem>
         <para>
          Obtain the operating system user name of the client
          by contacting the ident server on the client
          and check if it matches the requested database user name.
          Ident authentication can only be used on TCP/IP
          connections. When specified for local connections, peer
          authentication will be used instead.
          See <xref linkend="auth-ident"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</literal></term>
        <listitem>
         <para>
          Obtain the client's operating system user name from the operating
          system and check if it matches the requested database user name.
          This is only available for local connections.
          See <xref linkend="auth-peer"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</literal></term>
        <listitem>
         <para>
          Authenticate using an <acronym>LDAP</acronym> server. See <xref
          linkend="auth-ldap"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</literal></term>
        <listitem>
         <para>
          Authenticate using a RADIUS server. See <xref
          linkend="auth-radius"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</literal></term>
        <listitem>
         <para>
          Authenticate using SSL client certificates. See
          <xref linkend="auth-cert"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</literal></term>
        <listitem>
         <para>
          Authenticate using the Pluggable Authentication Modules
          (PAM) service provided by the operating system.  See <xref
          linkend="auth-pam"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>bsd</literal></term>
        <listitem>
         <para>
          Authenticate using the BSD Authentication service provided by the
          operating system. See <xref linkend="auth-bsd"/> for details.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       After the <replaceable>auth-method</replaceable> field, there can be field(s) of
       the form <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable> that
       specify options for the authentication method. Details about which
       options are available for which authentication methods appear below.
      </para>

      <para>
       In addition to the method-specific options listed below, there is one
       method-independent authentication option <literal>clientcert</literal>, which
       can be specified in any <literal>hostssl</literal> record.  When set
       to <literal>1</literal>, this option requires the client to present a valid
       (trusted) SSL certificate, in addition to the other requirements of the
       authentication method.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   记录可以是下面七种格式之一：
<synopsis>
local      <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
   各个域的含义如下：

   <variablelist>
    <varlistentry>
     <term><literal>local</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 Unix 域套接字的连接。如果没有这种类型的记录，就不允许 Unix 域套接字连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 TCP/IP 建立的连接。<literal>host</literal>记录匹配<acronym>SSL</acronym>和非<acronym>SSL</acronym>的连接尝试。
      </para>
     <note>
      <para>
       除非服务器带着合适的<xref linkend="guc-listen-addresses"/>配置参数值启动，否则将不可能进行远程的 TCP/IP 连接，因为默认的行为是只监听在本地环回地址<literal>localhost</literal>上的 TCP/IP 连接。
      </para>
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 TCP/IP 建立的连接，但必须是使用<acronym>SSL</acronym>加密的连接。
      </para>

      <para>
       要使用这个选项，编译服务器的时候必须打开<acronym>SSL</acronym>支持。此外，在服务器启动的时候必须通过设置<xref linkend="guc-ssl"/>配置参数（详见<xref linkend="ssl-tcp"/>）打开<acronym>SSL</acronym>。否则，<literal>hostssl</literal>记录会被忽略，并且会记录一个警告说它无法匹配任何连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       这条记录的行为与<literal>hostssl</literal>相反；它只匹配那些在 TCP/IP上不使用<acronym>SSL</acronym>的连接企图。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       指定记录所匹配的数据库名称。值<literal>all</literal>指定该记录匹配所有数据库。值 <literal>sameuser</literal>指定如果被请求的数据库和请求的用户同名，则匹配。值<literal>samerole</literal>指定请求的用户必须是一个与数据库同名的角色中的成员（<literal>samegroup</literal>是一个已经废弃了，但目前仍然被接受的<literal>samerole</literal>同义词）。对于一个用于<literal>samerole</literal>目的的角色，超级用户不会被考虑为其中的成员，除非它们是该角色的显式成员（直接或间接），而不是由于超级用户的原因。值<literal>replication</literal>指定如果一个物理复制连接被请求则该记录匹配（注意复制连接不指定任何特定的数据库）。在其它情况里，这就是一个特定的<productname>PostgreSQL</productname>数据库名字。可以通过用逗号分隔的方法指定多个数据库，也可以通过在文件名前面放<literal>@</literal>来指定一个包含数据库名的文件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       指定这条记录匹配哪些数据库用户名。值<literal>all</literal>指定它匹配所有用户。否则，它要么是一个特定数据库用户的名字或者是一个有前导<literal>+</literal>的组名称（回想一下，在<productname>PostgreSQL</productname>里，用户和组没有真正的区别，<literal>+</literal>实际表示<quote>匹配这个角色的任何直接或间接成员角色</quote>，而没有<literal>+</literal>记号的名字只匹配指定的角色）。出于这个目的，如果超级用户显式的是一个角色的成员（直接或间接），那么超级用户将只被认为是该角色的一个成员而不是作为一个超级用户。多个用户名可以通过用逗号分隔的方法提供。一个包含用户名的文件可以通过在文件名前面加上<literal>@</literal>来指定。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       指定这个记录匹配的客户端机器地址。这个域可以包含一个主机名、一个 IP 地址范围或下文提到的特殊关键字之一。
      </para>

      <para>
       一个 IP 地址范围以该范围的开始地址的标准数字记号指定，然后是一个斜线（<literal>/</literal>）
       和一个<acronym>CIDR</acronym>掩码长度。掩码长度表示客户端 IP 地址必须匹配的高序二进制位位数。在给出的 IP 地址中，这个长度的右边的二进制位必须为零。 在 IP 地址、<literal>/</literal>和 CIDR 掩码长度之间不能有空白。
      </para>

      <para>
       这种方法指定一个 IPv4 地址范围的典型例子是：
       <literal>172.20.143.89/32</literal>用于一个主机，
       <literal>172.20.143.0/24</literal>用于一个小型网络，
       <literal>10.6.0.0/16</literal>用于一个大型网络。
       一个单主机的 IPv6 地址范围看起来像这样：<literal>::1/128</literal>（IPv6 回环地址），
       一个小型网络的 IPv6 地址范围则类似于：<literal>fe80::7a31:c1ff:0000:0000/96</literal>。
       <literal>0.0.0.0/0</literal>表示所有 IPv4 地址，并且<literal>::0/0</literal>表示所有 IPv6 地址。要指定一个单一主机，IPv4 用一个长度为 32 的 CIDR 掩码或者 IPv6 用
       长度为 128 的 CIDR 掩码。在一个网络地址中，不要省略结尾的零。
      </para>

      <para>
       一个以 IPv4 格式给出的项将只匹配 IPv4 连接并且一个以 IPv6 格式给出的项将只匹配 IPv6 连接，即使对应的地址在 IPv4-in-IPv6 范围内。请注意如果系统的 C 库不支持 IPv6 地址，那么 IPv6 格式中的项将被拒绝。
      </para>

      <para>
       你也可以写<literal>all</literal>来匹配任何 IP 地址、写<literal>samehost</literal>来匹配任何本服务器自身的 IP 地址或者写<literal>samenet</literal>来匹配本服务器直接连接到的任意子网的任意地址。
      </para>

      <para>
       若果指定了一个主机名（任何除 IP 地址单位或特殊关键字之外的都被作为主机名处理），
       该名称会与客户端的 IP 地址的反向名字解析（例如使用 DNS 时的反向 DNS 查找）结果进行比较。主机名比较是大小写敏感的。如果匹配上，那么将在主机名上执行一次正向名字解析（例如正向 DNS 查找）来检查它解析到的任何地址是否等于客户端的 IP 地址。如果两个方向都匹配，则该项被认为匹配（<filename>pg_hba.conf</filename>中使用的主机名应该是客户端 IP 地址的地址到名字解析返回的结果，否则该行将不会匹配。某些主机名数据库允许将一个 IP 地址关联多个主机名，但是当被要求解析一个 IP 地址时，操作系统将只返回一个主机名）。
      </para>

      <para>
       一个以点号（<literal>.</literal>）开始的主机名声明匹配实际主机名的后缀。因此<literal>.example.com</literal>将匹配<literal>foo.example.com</literal>（但不匹配<literal>example.com</literal>）。
      </para>

      <para>
       当主机名在<filename>pg_hba.conf</filename>中被指定时，你应该保证名字解析很快。建立一个类似<command>nscd</command>的本地名字解析缓存是一种不错的选择。另外，你可能希望启用配置参数<varname>log_hostname</varname>来在日志中查看客户端的主机名而不是 IP 地址。
      </para>

      <para>
       这个域只适用于<literal>host</literal>、
       <literal>hostssl</literal>和<literal>hostnossl</literal>记录。
      </para>

      <note>
       <para>
        用户有时候会疑惑为什么这样处理的主机名看起来很复杂，因为需要两次名字解析（包括一次
        客户端 IP 地址的反向查找）。在客户端的反向 DNS 项没有建立或者得到某些意料之外的主机
        名的情况下，这种方式会让该特性的使用变得复杂。这样做主要是为了效率：通过这种方式，一次
        连接尝试要求最多两次解析器查找，一次逆向以及一次正向。如果有一个解析器对于该地址有问
        题，这仅仅是客户端的问题。一种假想的替代实现是只做前向查找，这种方法不得不在每一次连接
        尝试期间解析<filename>pg_hba.conf</filename>中提到的每一个主机名。如果列出了很多
        名称，这就会很慢。并且如果主机名之一有解析器问题，它会变成所有人的问题。
       </para>

       <para>
        另外，一次反向查找也是实现后缀匹配特性所需的，因为需要知道实际的客户端主机名来与模式进行匹配。
       </para>

       <para>
        注意这种行为与其他流行的基于主机名的访问控制实现相一致，例如 Apache HTTP Server 和 TCP Wrappers。
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       这两个域可以被用作<replaceable>IP-address</replaceable><literal>/</literal>
       <replaceable>mask-length</replaceable>记号法的替代方案。和指定掩码长度不同，实际的掩码被指
       定在一个单独的列中。例如，<literal>255.0.0.0</literal>表示 IPv4 CIDR 掩码长度 8，而<literal>255.255.255.255</literal>表示 CIDR 掩码长度 32。
      </para>

      <para>
       这些域只适用于<literal>host</literal>、<literal>hostssl</literal>和<literal>hostnossl</literal>记录。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
     <listitem>
      <para>
       指定当一个连接匹配这个记录时，要使用的认证方法。下面对可能的选择做了概述，详见<xref linkend="auth-methods"/>。

       <variablelist>
        <varlistentry>
         <term><literal>trust</literal></term>
         <listitem>
         <para>
          无条件地允许连接。这种方法允许任何可以与<productname>PostgreSQL</productname>数据库服务器连接的用户以他们期望的任意<productname>PostgreSQL</productname>数据库用户身份登入，而不需要口令或者其他任何认证。详见<xref linkend="auth-trust"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</literal></term>
        <listitem>
         <para>
          无条件地拒绝连接。这有助于从一个组中<quote>过滤出</quote>特定主机，例如一个<literal>reject</literal>行可以阻塞一个特定的主机连接，而后面一行允许一个特定网络中的其余主机进行连接。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>scram-sha-256</literal></term>
        <listitem>
         <para>
          执行SCRAM-SHA-256认证来验证用户的口令。详见<xref linkend="auth-password"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</literal></term>
        <listitem>
         <para>
          执行SCRAM-SHA-256或MD5认证来验证用户的口令。详见<xref linkend="auth-password"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</literal></term>
        <listitem>
         <para>
          要求客户端提供一个未加密的口令进行认证。因为口令是以明文形式在网络上发送的，所以我们不应该在不可信的网络上使用这种方式。详见<xref linkend="auth-password"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</literal></term>
        <listitem>
         <para>
          用 GSSAPI 认证用户。只对 TCP/IP 连接可用。详见<xref linkend="gssapi-auth"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</literal></term>
        <listitem>
         <para>
          用 SSPI 来认证用户。只在 Windows 上可用。详见<xref linkend="sspi-auth"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</literal></term>
        <listitem>
         <para>
          通过联系客户端的 ident 服务器获取客户端的操作系统名，并且检查它是否匹配被请求的数据库用户名。Ident 认证只能在 TCIP/IP 连接上使用。当为本地连接指定这种认证方式时，将用 peer 认证来替代。详见<xref linkend="auth-ident"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</literal></term>
        <listitem>
         <para>
          从操作系统获得客户端的操作系统用户，并且检查它是否匹配被请求的数据库用户名。这只对本地连接可用。详见<xref linkend="auth-peer"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</literal></term>
        <listitem>
         <para>
          使用<acronym>LDAP</acronym>服务器认证。详见<xref linkend="auth-ldap"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</literal></term>
        <listitem>
         <para>
          用 RADIUS 服务器认证。详见<xref linkend="auth-radius"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</literal></term>
        <listitem>
         <para>
          使用 SSL 客户端证书认证。详见<xref linkend="auth-cert"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</literal></term>
        <listitem>
         <para>
          使用操作系统提供的可插入认证模块服务（PAM）认证。详见<xref linkend="auth-pam"/>。
         </para>
        </listitem>
       </varlistentry>
       
       <varlistentry>
        <term><literal>bsd</literal></term>
        <listitem>
         <para>
          使用由操作系统提供的 BSD 认证服务进行认证。详见<xref linkend="auth-bsd"/>。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       在<replaceable>auth-method</replaceable>域的后面，可以是形如<replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>的域，它们指定认证方法的选项。关于哪些认证方法可以用哪些选项的细节请见下文。
      </para>
      
      <para>
       除了下文列出的与方法相关的选项之外，还有一个与方法无关的认证选项<literal>clientcert</literal>，它可以在任何<literal>hostssl</literal>记录中指定。当被设置为<literal>1</literal>时，这个选项要求客户端在认证方法的其他要求之外出示一个有效的（可信的）SSL 证书。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Files included by <literal>@</literal> constructs are read as lists of names,
   which can be separated by either whitespace or commas.  Comments are
   introduced by <literal>#</literal>, just as in
   <filename>pg_hba.conf</filename>, and nested <literal>@</literal> constructs are
   allowed.  Unless the file name following <literal>@</literal> is an absolute
   path, it is taken to be relative to the directory containing the
   referencing file.
  </para>
____________________________________________________________________________-->
  <para>
   用<literal>@</literal>结构包括的文件被读作一个名字列表，它们可以用空白或者逗号分隔。注释用<literal>#</literal>引入，就像在<filename>pg_hba.conf</filename>中那样，并且允许嵌套<literal>@</literal>结构。除非跟在<literal>@</literal>后面的文件名是一个绝对路径， 文件名都被认为是相对于包含引用文件的目录。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since the <filename>pg_hba.conf</filename> records are examined
   sequentially for each connection attempt, the order of the records is
   significant. Typically, earlier records will have tight connection
   match parameters and weaker authentication methods, while later
   records will have looser match parameters and stronger authentication
   methods. For example, one might wish to use <literal>trust</literal>
   authentication for local TCP/IP connections but require a password for
   remote TCP/IP connections. In this case a record specifying
   <literal>trust</literal> authentication for connections from 127.0.0.1 would
   appear before a record specifying password authentication for a wider
   range of allowed client IP addresses.
  </para>
____________________________________________________________________________-->
  <para>
   因为每一次连接尝试都会顺序地检查<filename>pg_hba.conf</filename>记录，所以这些记录的顺序是非常关键的。通常，靠前的记录有比较严的连接匹配参数和比较弱的认证方法，而靠后的记录有比较松的匹配参数和比较强的认证方法。 例如，我们希望对本地 TCP/IP 连接使用<literal>trust</literal>认证，而对远程 TCP/IP 连接要求口令。在这种情况下为来自于 127.0.0.1 的连接指定<literal>trust</literal>认证的记录将出现在为一个更宽范围的客户端 IP 地址指定口令认证的记录前面。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <filename>pg_hba.conf</filename> file is read on start-up and when
   the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</literal> or <literal>kill -HUP</literal>) to make it
   re-read the file.
  </para>
____________________________________________________________________________-->
  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_hba.conf</filename>文件会被读取。 如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</literal>或<literal>kill -HUP</literal>）重新读取该文件。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The preceding statement is not true on Microsoft Windows: there, any
    changes in the <filename>pg_hba.conf</filename> file are immediately
    applied by subsequent new connections.
   </para>
____________________________________________________________________________-->
   <para>
    前面的说明在Microsoft Windows上不为真：在Windows上，<filename>pg_hba.conf</filename>文件中的任何更改会立即被应用到后续的新连接上。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The system view
   <link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>
   can be helpful for pre-testing changes to the <filename>pg_hba.conf</filename>
   file, or for diagnosing problems if loading of the file did not have the
   desired effects.  Rows in the view with
   non-null <structfield>error</structfield> fields indicate problems in the
   corresponding lines of the file.
  </para>
____________________________________________________________________________-->
  <para>
   系统视图<link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>有助于预先测试对<filename>pg_hba.conf</filename>文件的更改，该视图也可以在该文件的装载没有产生预期效果时用于诊断问题。该视图中带有非空<structfield>error</structfield>域的行就表示该文件对应行中存在问题。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    To connect to a particular database, a user must not only pass the
    <filename>pg_hba.conf</filename> checks, but must have the
    <literal>CONNECT</literal> privilege for the database.  If you wish to
    restrict which users can connect to which databases, it's usually
    easier to control this by granting/revoking <literal>CONNECT</literal> privilege
    than to put the rules in <filename>pg_hba.conf</filename> entries.
   </para>
____________________________________________________________________________-->
   <para>
    要连接到一个特定数据库，一个用户必须不仅要通过<filename>pg_hba.conf</filename>检查，还必须要有该数据库上的<literal>CONNECT</literal>权限。如果你希望限制哪些用户能够连接到哪些数据库，授予/撤销<literal>CONNECT</literal>权限通常比在<filename>pg_hba.conf</filename>项中设置规则简单。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   Some examples of <filename>pg_hba.conf</filename> entries are shown in
   <xref linkend="example-pg-hba.conf"/>. See the next section for details on the
   different authentication methods.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="example-pg-hba.conf"/>中展示了<filename>pg_hba.conf</filename>项的一些例子。不同认证方法的详情请见下一节。
  </para>

   <example id="example-pg-hba.conf">
<!--==========================orignal english content==========================
    <title>Example <filename>pg_hba.conf</filename> Entries</title>
____________________________________________________________________________-->
    <title>示例 <filename>pg_hba.conf</filename> 项</title>
<!--==========================orignal english content==========================
<programlisting>
# Allow any user on the local system to connect to any database with
# any database user name using Unix-domain sockets (the default for local
# connections).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# The same using local loopback TCP/IP connections.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# The same as the previous line, but using a separate netmask column
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# The same over IPv6.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# The same using a host name (would typically cover both IPv4 and IPv6).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# Allow any user from any host with IP address 192.168.93.x to connect
# to database "postgres" as the same user name that ident reports for
# the connection (typically the operating system user name).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# Allow any user from host 192.168.12.10 to connect to database
# "postgres" if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# Allow any user from hosts in the example.com domain to connect to
# any database if the user's password is correctly supplied.
#
# Require SCRAM authentication for most users, but make an exception
# for user 'mike', who uses an older client that doesn't support SCRAM
# authentication.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             mike            .example.com            md5
host    all             all             .example.com            scram-sha-256

# In the absence of preceding "host" lines, these two lines will
# reject all connections from 192.168.54.1 (since that entry will be
# matched first), but allow GSSAPI connections from anywhere else
# on the Internet.  The zero mask causes no bits of the host IP
# address to be considered, so it matches any host.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
host    all             all             0.0.0.0/0               gss

# Allow users from 192.168.x.x hosts to connect to any database, if
# they pass the ident check.  If, for example, ident says the user is
# "bryanh" and he requests to connect as PostgreSQL user "guest1", the
# connection is allowed if there is an entry in pg_ident.conf for map
# "omicron" that says "bryanh" is allowed to connect as "guest1".
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# If these are the only three lines for local connections, they will
# allow local users to connect only to their own databases (databases
# with the same name as their database user name) except for administrators
# and members of role "support", who can connect to all databases.  The file
# $PGDATA/admins contains a list of names of administrators.  Passwords
# are required in all cases.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# The last two lines above can be combined into a single line:
local   all             @admins,+support                        md5

# The database column can also use lists and file names:
local   db1,db2,@demodbs  all                                   md5
</programlisting>
____________________________________________________________________________-->
<programlisting>
# 允许本地系统上的任何用户
# 通过 Unix 域套接字以任意
# 数据库用户名连接到任意数据库
#（本地连接的默认值）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# 相同的规则，但是使用本地环回 TCP/IP 连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# 和前一行相同，但是使用了一个独立的掩码列
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# IPv6 上相同的规则
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# 使用主机名的相同规则（通常同时覆盖 IPv4 和 IPv6）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# 允许来自任意具有 IP 地址
# 192.168.93.x 的主机上任意
# 用户以 ident 为该连接所
# 报告的相同用户名连接到
# 数据库 "postgres"
#（通常是操作系统用户名）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# 如果用户的口令被正确提供，
# 允许来自主机 192.168.12.10
# 的任意用户连接到数据库 "postgres"。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# 如果用户的口令被正确提供，
# 允许 example.com 中主机上
# 的任意用户连接到任意数据库。
#
# 为大部分用户要求SCRAM认证，但是用户'mike'是个例外，
# 他使用的是不支持SCRAM认证的旧客户端。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             mike            .example.com            md5
host    all             all             .example.com            scram-sha-256

# 如果没有前面的 "host" 行，这两
# 行将拒绝所有来自 192.168.54.1
# 的连接（因为那些项将首先被匹配），
# 但是允许来自互联网其他任何地方的
# GSSAPI 连接。零掩码导致主机
# IP 地址中的所有位都不会被考虑，
# 因此它匹配任意主机。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
host    all             all             0.0.0.0/0               gss

# 允许来自 192.168.x.x 主机的用户
# 连接到任意数据库，如果它们能够
# 通过 ident 检查。例如，假设 ident
# 说用户是 "bryanh" 并且他要求以
# PostgreSQL 用户 "guest1" 连接，
# 如果在 pg_ident.conf 有一个映射
# "omicron" 的选项说 "bryanh" 被
# 允许以 "guest1" 连接，则该连接将被允许。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# 如果这些是本地连接的唯一三行，
# 它们将允许本地用户只连接到它们
# 自己的数据库（与其数据库用户名
# 同名的数据库），不过管理员和角
# 色 "support" 的成员除外（它们可
# 以连接到所有数据库）。文件
# $PGDATA/admins 包含一个管理员
# 名字的列表。在所有情况下都要求口令。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# 上面的最后两行可以被整合为一行：
local   all             @admins,+support                        md5

# 数据库列也可以用列表和文件名：
local   db1,db2,@demodbs  all                                   md5
</programlisting>
   </example>
 </sect1>

 <sect1 id="auth-username-maps">
<!--==========================orignal english content==========================
  <title>User Name Maps</title>
____________________________________________________________________________-->
  <title>用户名映射</title>

<!--==========================orignal english content==========================
  <indexterm zone="auth-username-maps">
   <primary>User name maps</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="auth-username-maps">
   <primary>用户名映射</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When using an external authentication system such as Ident or GSSAPI,
   the name of the operating system user that initiated the connection
   might not be the same as the database user (role) that is to be used.
   In this case, a user name map can be applied to map the operating system
   user name to a database user.  To use user name mapping, specify
   <literal>map</literal>=<replaceable>map-name</replaceable>
   in the options field in <filename>pg_hba.conf</filename>. This option is
   supported for all authentication methods that receive external user names.
   Since different mappings might be needed for different connections,
   the name of the map to be used is specified in the
   <replaceable>map-name</replaceable> parameter in <filename>pg_hba.conf</filename>
   to indicate which map to use for each individual connection.
  </para>
____________________________________________________________________________-->
  <para>
   当使用像 Ident 或者 GSSAPI 之类的外部认证系统时，发起连接的操作系统用户名可能不同于要被使用的数据库用户（角色）。在这种情况下，一个用户名映射可被用来把操作系统用户名映射到数据库用户。要使用用户名映射，在<filename>pg_hba.conf</filename>的选项域指定<literal>map</literal>=<replaceable>map-name</replaceable>。此选项支持所有接收外部用户名的认证方法。由于不同的连接可能需要不同的映射，在<filename>pg_hba.conf</filename>中的<replaceable>map-name</replaceable>参数中指定要被使用的映射名，用以指示哪个映射用于每个个体连接。
  </para>

<!--==========================orignal english content==========================
  <para>
   User name maps are defined in the ident map file, which by default is named
   <filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>
   and is stored in the
   cluster's data directory.  (It is possible to place the map file
   elsewhere, however; see the <xref linkend="guc-ident-file"/>
   configuration parameter.)
   The ident map file contains lines of the general form:
<synopsis>
<replaceable>map-name</replaceable> <replaceable>system-username</replaceable> <replaceable>database-username</replaceable>
</synopsis>
   Comments and whitespace are handled in the same way as in
   <filename>pg_hba.conf</filename>.  The
   <replaceable>map-name</replaceable> is an arbitrary name that will be used to
   refer to this mapping in <filename>pg_hba.conf</filename>. The other
   two fields specify an operating system user name and a matching
   database user name. The same <replaceable>map-name</replaceable> can be
   used repeatedly to specify multiple user-mappings within a single map.
  </para>
____________________________________________________________________________-->
  <para>
   用户名映射定义在 ident 映射文件中，默认情况下它被命名为<filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>并被存储在集簇的数据目录中（不过，可以把该映射文件放在其他地方，见<xref linkend="guc-ident-file"/>配置参数）。ident 映射文件包含的行的一般格式：
<synopsis>
<replaceable>map-name</replaceable> <replaceable>system-username</replaceable> <replaceable>database-username</replaceable>
</synopsis>
   以在<filename>pg_hba.conf</filename>中同样的方式处理注释和空白。<replaceable>map-name</replaceable>是一个任意名称，它将被用于在<filename>pg_hba.conf</filename>中引用该映射。其他两个域指定一个操作系统用户名和一个匹配的数据库用户名。相同的<replaceable>map-name</replaceable>可以被反复地用在同一个映射中指定多个用户映射。
  </para>
<!--==========================orignal english content==========================
  <para>
   There is no restriction regarding how many database users a given
   operating system user can correspond to, nor vice versa.  Thus, entries
   in a map should be thought of as meaning <quote>this operating system
   user is allowed to connect as this database user</quote>, rather than
   implying that they are equivalent.  The connection will be allowed if
   there is any map entry that pairs the user name obtained from the
   external authentication system with the database user name that the
   user has requested to connect as.
  </para>
____________________________________________________________________________-->
  <para>
   对于一个给定操作系统用户可以对应多少个数据库用户没有限制，反之亦然。因此，一个映射中的项应该被看成意味着<quote>这个操作系统用户被允许作为这个数据库用户连接</quote>，而不是按时它们等价。如果有任何映射项把从外部认证系统获得的用户名和用户要求的数据库用户名配对，该连接将被允许。
  </para>
<!--==========================orignal english content==========================
  <para>
   If the <replaceable>system-username</replaceable> field starts with a slash (<literal>/</literal>),
   the remainder of the field is treated as a regular expression.
   (See <xref linkend="posix-syntax-details"/> for details of
   <productname>PostgreSQL</productname>'s regular expression syntax.)  The regular
   expression can include a single capture, or parenthesized subexpression,
   which can then be referenced in the <replaceable>database-username</replaceable>
   field as <literal>\1</literal> (backslash-one).  This allows the mapping of
   multiple user names in a single line, which is particularly useful for
   simple syntax substitutions.  For example, these entries
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   will remove the domain part for users with system user names that end with
   <literal>@mydomain.com</literal>, and allow any user whose system name ends with
   <literal>@otherdomain.com</literal> to log in as <literal>guest</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   如果<replaceable>system-username</replaceable>域以一个斜线（<literal>/</literal>）开始，域的剩余部分被当做一个正则表达式（<productname>PostgreSQL</productname>的正则表达式语法详见<xref linkend="posix-syntax-details"/>）。正则表达式可以包括一个单一的捕获，或圆括号子表达式，然后它可以在<replaceable>database-username</replaceable>域中以<literal>\1</literal>（反斜线一）被引用。这允许在单个行中多个用户名的映射，这特别有助于简单的语法替换。例如，这些项
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   将为用户移除以<literal>@mydomain.com</literal>结束的系统用户名的域部分，以及允许系统名以<literal>@otherdomain.com</literal>结束的任意用户作为<literal>guest</literal>登入。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    Keep in mind that by default, a regular expression can match just part of
    a string.  It's usually wise to use <literal>^</literal> and <literal>$</literal>, as
    shown in the above example, to force the match to be to the entire
    system user name.
   </para>
____________________________________________________________________________-->
   <para>
    记住在默认情况下，一个正则表达式可以只匹配字符串的一部分。如上例所示，使用<literal>^</literal>和<literal>$</literal>来强制匹配整个系统用户名通常是明智的。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   The <filename>pg_ident.conf</filename> file is read on start-up and
   when the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</literal> or <literal>kill -HUP</literal>) to make it
   re-read the file.
  </para>
____________________________________________________________________________-->
  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_ident.conf</filename>文件会被读取。 如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</literal>或<literal>kill -HUP</literal>）重新读取该文件。
  </para>

<!--==========================orignal english content==========================
  <para>
   A <filename>pg_ident.conf</filename> file that could be used in
   conjunction with the <filename>pg_hba.conf</filename> file in <xref
   linkend="example-pg-hba.conf"/> is shown in <xref
   linkend="example-pg-ident.conf"/>. In this example, anyone
   logged in to a machine on the 192.168 network that does not have the
   operating system user name <literal>bryanh</literal>, <literal>ann</literal>, or
   <literal>robert</literal> would not be granted access. Unix user
   <literal>robert</literal> would only be allowed access when he tries to
   connect as <productname>PostgreSQL</productname> user <literal>bob</literal>, not
   as <literal>robert</literal> or anyone else. <literal>ann</literal> would
   only be allowed to connect as <literal>ann</literal>. User
   <literal>bryanh</literal> would be allowed to connect as either
   <literal>bryanh</literal> or as <literal>guest1</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="example-pg-ident.conf"/>中展示了一个可以联合<filename>pg_hba.conf</filename>文件（<xref linkend="example-pg-hba.conf"/>）使用的<filename>pg_ident.conf</filename>文件。在这个例子中，对于任何登入到 192.168 网络上的一台机器的用户， 如果该用户没有操作系统用户名<literal>bryanh</literal>、<literal>ann</literal>或<literal>robert</literal>，则他不会被授予访问权限。只有当 Unix 用户<literal>robert</literal>尝试作为<productname>PostgreSQL</productname>用户<literal>bob</literal>（而不是作为<literal>robert</literal>或其他人）连接时，他才被允许访问。<literal>ann</literal>只被允许作为<literal>ann</literal>连接。用户<literal>bryanh</literal>被允许以<literal>bryanh</literal>或者<literal>guest1</literal>连接。
  </para>

  <example id="example-pg-ident.conf">
<!--==========================orignal english content==========================
   <title>An Example <filename>pg_ident.conf</filename> File</title>
____________________________________________________________________________-->
   <title>一个示例 <filename>pg_ident.conf</filename> 文件</title>
<!--==========================orignal english content==========================
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob has user name robert on these machines
omicron         robert                  bob
# bryanh can also connect as guest1
omicron         bryanh                  guest1
</programlisting>
____________________________________________________________________________-->
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob 在这些机器上有用户名 robert
omicron         robert                  bob
# bryanh 也可以作为 guest1 连接
omicron         bryanh                  guest1
</programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
<!--==========================orignal english content==========================
  <title>Authentication Methods</title>
____________________________________________________________________________-->
  <title>认证方法</title>
<!--==========================orignal english content==========================
  <para>
   The following sections describe the authentication methods in more detail.
  </para>
____________________________________________________________________________-->
  <para>
   下列小节更详细地描述认证方法。
  </para>
 </sect1>

  <sect1 id="auth-trust">
<!--==========================orignal english content==========================
   <title>Trust Authentication</title>
____________________________________________________________________________-->
   <title>信任认证</title>

<!--==========================orignal english content==========================
   <para>
    When <literal>trust</literal> authentication is specified,
    <productname>PostgreSQL</productname> assumes that anyone who can
    connect to the server is authorized to access the database with
    whatever database user name they specify (even superuser names).
    Of course, restrictions made in the <literal>database</literal> and
    <literal>user</literal> columns still apply.
    This method should only be used when there is adequate
    operating-system-level protection on connections to the server.
   </para>
____________________________________________________________________________-->
   <para>
    当<literal>trust</literal>认证被指定时，<productname>PostgreSQL</productname>假设任何可以连接到服务器的人都被授权使用他们指定的任何数据库用户名（即使是超级用户）访问数据库。当然，在<literal>database</literal>和 <literal>user</literal>列中设置的限制仍然适用。只有当在操作系统层对进入服务器的连接有足够保护时，才应该使用这种方法。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>trust</literal> authentication is appropriate and very
    convenient for local connections on a single-user workstation.  It
    is usually <emphasis>not</emphasis> appropriate by itself on a multiuser
    machine.  However, you might be able to use <literal>trust</literal> even
    on a multiuser machine, if you restrict access to the server's
    Unix-domain socket file using file-system permissions.  To do this, set the
    <varname>unix_socket_permissions</varname> (and possibly
    <varname>unix_socket_group</varname>) configuration parameters as
    described in <xref linkend="runtime-config-connection"/>.  Or you
    could set the <varname>unix_socket_directories</varname>
    configuration parameter to place the socket file in a suitably
    restricted directory.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>trust</literal>认证对于单用户工作站的本地连接是非常合适和方便的。通常它本身<emphasis>不</emphasis>适用于一台多用户机器。不过，只要你利用文件系统权限限制了对服务器的 Unix 域套接字文件的访问，即使在多用户机器上，你也可以使用<literal>trust</literal>。 要做这些限制，你可以设置<xref linkend="runtime-config-connection"/>中描述的<varname>unix_socket_permissions</varname>配置参数（可能还有<varname>unix_socket_group</varname>）。 或者你可以设置<varname>unix_socket_directories</varname>配置参数来把 Unix 域套接字文件放在一个经过恰当限制的目录中。
   </para>

<!--==========================orignal english content==========================
   <para>
    Setting file-system permissions only helps for Unix-socket connections.
    Local TCP/IP connections are not restricted by file-system permissions.
    Therefore, if you want to use file-system permissions for local security,
    remove the <literal>host ... 127.0.0.1 ...</literal> line from
    <filename>pg_hba.conf</filename>, or change it to a
    non-<literal>trust</literal> authentication method.
   </para>
____________________________________________________________________________-->
   <para>
    设置文件系统权限只能有助于 Unix 套接字连接。本地 TCP/IP 连接不会被文件系统权限限制。因此，如果你想利用文件系统权限来控制本地安全，那么从<filename>pg_hba.conf</filename>中移除<literal>host ... 127.0.0.1 ...</literal>行，或者把它改为一个非<literal>trust</literal>认证方法。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>trust</literal> authentication is only suitable for TCP/IP connections
    if you trust every user on every machine that is allowed to connect
    to the server by the <filename>pg_hba.conf</filename> lines that specify
    <literal>trust</literal>.  It is seldom reasonable to use <literal>trust</literal>
    for any TCP/IP connections other than those from <systemitem>localhost</systemitem> (127.0.0.1).
   </para>
____________________________________________________________________________-->
   <para>
    如果通过指定<literal>trust</literal>的<filename>pg_hba.conf</filename>行让你信任每一个被允许连接到服务器的机器上的用户，<literal>trust</literal>认证只适合 TCP/IP 连接。为任何不是来自<systemitem>localhost</systemitem>（127.0.0.1）的 TCP/IP 连接使用<literal>trust</literal>很少是合理的。
   </para>

  </sect1>

  <sect1 id="auth-password">
<!--==========================orignal english content==========================
   <title>Password Authentication</title>
____________________________________________________________________________-->
   <title>口令认证</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>MD5</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>MD5</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>SCRAM</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SCRAM</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>password</primary>
    <secondary>authentication</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>口令</primary>
    <secondary>认证</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    There are several password-based authentication methods.  These methods
    operate similarly but differ in how the users' passwords are stored on the
    server and how the password provided by a client is sent across the
    connection.
   </para>
____________________________________________________________________________-->
   <para>
    有几种基于口令的认证方法。这些方法的过程类似，但是区别在于用户口令如何被存放在服务器上以及客户端提供的口令如何被通过连接发送。
   </para>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>scram-sha-256</literal></term>
____________________________________________________________________________-->
     <term><literal>scram-sha-256</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The method <literal>scram-sha-256</literal> performs SCRAM-SHA-256
       authentication, as described in
       <ulink url="https://tools.ietf.org/html/rfc7677">RFC 7677</ulink>.  It
       is a challenge-response scheme that prevents password sniffing on
       untrusted connections and supports storing passwords on the server in a
       cryptographically hashed form that is thought to be secure.
      </para>
____________________________________________________________________________-->
      <para>
       方法<literal>scram-sha-256</literal>按照<ulink url="https://tools.ietf.org/html/rfc7677">RFC 7677</ulink>中的描述执行SCRAM-SHA-256认证。它使用的是一种挑战-响应的方案，可以防止在不可信连接上对口令的嗅探并且支持在服务器上以一种加密哈希的方式存放口令，因此被认为是安全的。
      </para>

<!--==========================orignal english content==========================
      <para>
       This is the most secure of the currently provided methods, but it is
       not supported by older client libraries.
      </para>
____________________________________________________________________________-->
      <para>
       这是当前提供的方法中最安全的一种，但是旧的客户端库不支持这种方法。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>md5</literal></term>
____________________________________________________________________________-->
     <term><literal>md5</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The method <literal>md5</literal> uses a custom less secure challenge-response
       mechanism.  It prevents password sniffing and avoids storing passwords
       on the server in plain text but provides no protection if an attacker
       manages to steal the password hash from the server.  Also, the MD5 hash
       algorithm is nowadays no longer considered secure against determined
       attacks.
      </para>
____________________________________________________________________________-->
      <para>
       方法<literal>md5</literal>使用一种自定义的安全性较低的挑战-响应机制。它能防止口令嗅探并且防止口令在服务器上以明文存储，但是无法保护攻击者想办法从服务器上窃取了口令哈希的情况。此外，现在认为MD5哈希算法对于确定攻击已经不再安全。
      </para>

<!--==========================orignal english content==========================
      <para>
       The <literal>md5</literal> method cannot be used with
       the <xref linkend="guc-db-user-namespace"/> feature.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>md5</literal>方法不能与<xref linkend="guc-db-user-namespace"/>特性一起使用。
      </para>

<!--==========================orignal english content==========================
      <para>
       To ease transition from the <literal>md5</literal> method to the newer
       SCRAM method, if <literal>md5</literal> is specified as a method
       in <filename>pg_hba.conf</filename> but the user's password on the
       server is encrypted for SCRAM (see below), then SCRAM-based
       authentication will automatically be chosen instead.
      </para>
____________________________________________________________________________-->
      <para>
       为了简化从<literal>md5</literal>方法到较新的SCRAM方法的转变，如果在<filename>pg_hba.conf</filename>中指定了<literal>md5</literal>但是用户在服务器上的口令是为SCRAM（见下文）加密的，则将自动选择基于SCRAM的认证。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>password</literal></term>
____________________________________________________________________________-->
     <term><literal>password</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The method <literal>password</literal> sends the password in clear-text and is
       therefore vulnerable to password <quote>sniffing</quote> attacks. It should
       always be avoided if possible. If the connection is protected by SSL
       encryption then <literal>password</literal> can be used safely, though.
       (Though SSL certificate authentication might be a better choice if one
       is depending on using SSL).
      </para>
____________________________________________________________________________-->
      <para>
       方法<literal>password</literal>以明文形式发送口令，因此它对于口令<quote>嗅探</quote>攻击很脆弱。如果可能应该尽量避免使用它。不过，如果连接被SSL加密保护着，那么可以安全地使用<literal>password</literal>（不过如果依靠SSL，SSL证书认证可能是更好的选择）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> database passwords are
    separate from operating system user passwords. The password for
    each database user is stored in the <literal>pg_authid</literal> system
    catalog. Passwords can be managed with the SQL commands
    <xref linkend="sql-createrole"/> and
    <xref linkend="sql-alterrole"/>,
    e.g., <userinput>CREATE ROLE foo WITH LOGIN PASSWORD 'secret'</userinput>,
    or the <application>psql</application>
    command <literal>\password</literal>.
    If no password has been set up for a user, the stored password
    is null and password authentication will always fail for that user.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>数据库口令独立于操作系统用户口令。每个数据库用户的口令被存储在<literal>pg_authid</literal>系统目录中。口令可以用 SQL 命令<xref linkend="sql-createuser"/>和<xref linkend="sql-alterrole"/>管理，例如<userinput>CREATE ROLE foo WITH LOGIN PASSWORD 'secret'</userinput>或者<application>psql</application>的<literal>\password</literal>命令。如果没有为一个用户设置口令，那么存储的口令为空并且对该用户的口令认证总会失败。
   </para>

<!--==========================orignal english content==========================
   <para>
    The availability of the different password-based authentication methods
    depends on how a user's password on the server is encrypted (or hashed,
    more accurately).  This is controlled by the configuration
    parameter <xref linkend="guc-password-encryption"/> at the time the
    password is set.  If a password was encrypted using
    the <literal>scram-sha-256</literal> setting, then it can be used for the
    authentication methods <literal>scram-sha-256</literal>
    and <literal>password</literal> (but password transmission will be in
    plain text in the latter case).  The authentication method
    specification <literal>md5</literal> will automatically switch to using
    the <literal>scram-sha-256</literal> method in this case, as explained
    above, so it will also work.  If a password was encrypted using
    the <literal>md5</literal> setting, then it can be used only for
    the <literal>md5</literal> and <literal>password</literal> authentication
    method specifications (again, with the password transmitted in plain text
    in the latter case).  (Previous PostgreSQL releases supported storing the
    password on the server in plain text.  This is no longer possible.)  To
    check the currently stored password hashes, see the system
    catalog <literal>pg_authid</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    不同的基于口令的认证方法的可用性取决于用户的口令在服务器上是如何被加密（或者更准确地说是哈希）的。这由设置口令时的配置参数<xref linkend="guc-password-encryption"/>控制。如果口令使用<literal>scram-sha-256</literal>设置加密，那么它可以被用于认证方法<literal>scram-sha-256</literal>和<literal>password</literal>（但后一种情况中口令将以明文传输）。如上所释，在这种情况下，指定的认证方法<literal>md5</literal>将自动切换到使用<literal>scram-sha-256</literal>方法。如果口令使用<literal>md5</literal>设置加密，那么它仅能用于<literal>md5</literal>和<literal>password</literal>认证方法说明（同样，后一种情况中口令以明文传输）。（之前的PostgreSQL发行版支持在服务器上存储明文口令。现在已经不可能了）。要检查当前存储的口令哈希，可以参考系统目录<literal>pg_authid</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    To upgrade an existing installation from <literal>md5</literal>
    to <literal>scram-sha-256</literal>, after having ensured that all client
    libraries in use are new enough to support SCRAM,
    set <literal>password_encryption = 'scram-sha-256'</literal>
    in <filename>postgresql.conf</filename>, make all users set new passwords,
    and change the authentication method specifications
    in <filename>pg_hba.conf</filename> to <literal>scram-sha-256</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    要把现有的安装从<literal>md5</literal>升级到<literal>scram-sha-256</literal>，可以在确保所有在用的客户端已经足以支持SCRAM之后，在<filename>postgresql.conf</filename>中设置<literal>password_encryption = 'scram-sha-256'</literal>，然后让所有用户设置新口令并且在<filename>pg_hba.conf</filename>中将认证方法说明改为<literal>scram-sha-256</literal>.
   </para>
  </sect1>

  <sect1 id="gssapi-auth">
<!--==========================orignal english content==========================
   <title>GSSAPI Authentication</title>
____________________________________________________________________________-->
   <title>GSSAPI 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>GSSAPI</productname> is an industry-standard protocol
    for secure authentication defined in RFC 2743.
    <productname>PostgreSQL</productname> supports
    <productname>GSSAPI</productname> with <productname>Kerberos</productname>
    authentication according to RFC 1964. <productname>GSSAPI</productname>
    provides automatic authentication (single sign-on) for systems
    that support it. The authentication itself is secure, but the
    data sent over the database connection will be sent unencrypted unless
    <acronym>SSL</acronym> is used.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>GSSAPI</productname>是用于 RFC 2743 中定义的安全认证的一个工业标准协议。<productname>PostgreSQL</productname>根据 RFC 1964 支持带<productname>Kerberos</productname>认证的<productname>GSSAPI</productname>。<productname>GSSAPI</productname>为支持它的系统提供自动认证（单点登录）。认证本身是安全的，但通过数据库连接发送的数据将不被加密，除非使用<acronym>SSL</acronym>。
   </para>

<!--==========================orignal english content==========================
   <para>
    GSSAPI support has to be enabled when <productname>PostgreSQL</productname> is built;
    see <xref linkend="installation"/> for more information.
   </para>
____________________________________________________________________________-->
   <para>
    当编译<productname>PostgreSQL</productname>时，GSSAPI 支持必须被启用，详见<xref linkend="installation"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    When <productname>GSSAPI</productname> uses
    <productname>Kerberos</productname>, it uses a standard principal
    in the format
    <literal><replaceable>servicename</replaceable>/<replaceable>hostname</replaceable>@<replaceable>realm</replaceable></literal>.
    The PostgreSQL server will accept any principal that is included in the keytab used by
    the server, but care needs to be taken to specify the correct principal details when
    making the connection from the client using the <literal>krbsrvname</literal> connection parameter. (See
    also <xref linkend="libpq-paramkeywords"/>.) The installation default can be
    changed from the default <literal>postgres</literal> at build time using
    <literal>./configure -&minus;with-krb-srvnam=</literal><replaceable>whatever</replaceable>.
    In most environments,
    this parameter never needs to be changed.
    Some Kerberos implementations might require a different service name,
    such as Microsoft Active Directory which requires the service name
    to be in upper case (<literal>POSTGRES</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    当<productname>GSSAPI</productname>使用<productname>Kerberos</productname>时，
    它会使用格式为
    <literal><replaceable>servicename</replaceable>/<replaceable>hostname</replaceable>@<replaceable>realm</replaceable></literal>的标准 principal。
    PostgreSQL服务器将接受该服务器所使用的 keytab 中包括的任何 principal，但是在从使用
    <literal>krbsrvname</literal>连接参数的客户端建立连接时要注意指定正确的 principal 细节（另见
    <xref linkend="libpq-paramkeywords"/>）。安装的默认值<literal>postgres</literal>
    可以在编译时使用
    <literal>./configure --with-krb-srvnam=</literal><replaceable>其他值</replaceable>修改。
    在大部分的环境中，这个参数从不需要被更改。某些 Kerberos 实现可能要求一个不同的服务名，
    例如 Microsoft Active Directory 要求服务名是大写形式（<literal>POSTGRES</literal>）。
   </para>
<!--==========================orignal english content==========================
   <para>
    <replaceable>hostname</replaceable> is the fully qualified host name of the
    server machine. The service principal's realm is the preferred realm
    of the server machine.
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>hostname</replaceable>是服务器机器的被完全限定的主机名。服务 principal 的 realm 
    是该服务器机器的首选 realm。
   </para>

<!--==========================orignal english content==========================
   <para>
    Client principals can be mapped to different <productname>PostgreSQL</productname>
    database user names with <filename>pg_ident.conf</filename>.  For example,
    <literal>pgusername@realm</literal> could be mapped to just <literal>pgusername</literal>.
    Alternatively, you can use the full <literal>username@realm</literal> principal as
    the role name in <productname>PostgreSQL</productname> without any mapping.
   </para>
____________________________________________________________________________-->
   <para>
    客户端 principal 可以被通过<filename>pg_ident.conf</filename>映射到不同的
    <productname>PostgreSQL</productname>数据库用户名。例如，
    <literal>pgusername@realm</literal>可能会被映射到<literal>pgusername</literal>。
    或者，你可以使用完整的<literal>username@realm</literal>当事人作为
    <productname>PostgreSQL</productname>中的角色而无需任何映射。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> also supports a parameter to strip the realm from
    the principal.  This method is supported for backwards compatibility and is
    strongly discouraged as it is then impossible to distinguish different users
    with the same user name but coming from different realms.  To enable this,
    set <literal>include_realm</literal> to 0.  For simple single-realm
    installations, doing that combined with setting the
    <literal>krb_realm</literal> parameter (which checks that the principal's realm
    matches exactly what is in the <literal>krb_realm</literal> parameter)
    is still secure; but this is a
    less capable approach compared to specifying an explicit mapping in
    <filename>pg_ident.conf</filename>.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>也支持一个参数把 realm 从 principal 中剥离。这种方法是为了向后兼容性，并且我们强烈反对使用它，因为这样就无法区分具有相同用户名却来自不同 realm 的不同用户了。要启用这种方法，可将<literal>include_realm</literal>设置为 0。对于简单的单 realm 安装，这样做并且设置<literal>krb_realm</literal>参数（这会检查 principal 的 realm 是否正好匹配<literal>krb_realm</literal>中的参数）仍然是安全的。但比起在<filename>pg_ident.conf</filename>中指定一个显式映射来说，这种方法的能力较低。
   </para>

<!--==========================orignal english content==========================
   <para>
    Make sure that your server keytab file is readable (and preferably
    only readable, not writable) by the <productname>PostgreSQL</productname>
    server account.  (See also <xref linkend="postgres-user"/>.) The location
    of the key file is specified by the <xref
    linkend="guc-krb-server-keyfile"/> configuration
    parameter. The default is
    <filename>/usr/local/pgsql/etc/krb5.keytab</filename> (or whatever
    directory was specified as <varname>sysconfdir</varname> at build time).
    For security reasons, it is recommended to use a separate keytab
    just for the <productname>PostgreSQL</productname> server rather
    than opening up permissions on the system keytab file.
   </para>
____________________________________________________________________________-->
   <para>
    确认你的服务器的 keytab 文件是可以被<productname>PostgreSQL</productname>服务器帐
    户读取的（最好是只读的） (又见<xref linkend="postgres-user"/>）。密钥文件的位置由配置
    参数<xref linkend="guc-krb-server-keyfile"/>指定。默认是<filename>/usr/local/pgsql/etc/krb5.keytab</filename>（或者任何在编译的时候作为<varname>sysconfdir</varname>的目录）。
    出于安全原因，推荐对<productname>PostgreSQL</productname>服务器使用一个独立
    的 keytab而不是开放系统 keytab 文件的权限。
   </para>
<!--==========================orignal english content==========================
   <para>
    The keytab file is generated by the Kerberos software; see the
    Kerberos documentation for details. The following example is
   for MIT-compatible Kerberos 5 implementations:
<screen>
<prompt>kadmin% </prompt><userinput>ank -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    keytab 文件由 Kerberos 软件生成，详见 Kerberos 文档。下面是 MIT 兼容的 Kerberos 5 实现的例子：
<screen>
<prompt>kadmin% </prompt><userinput>ank -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    When connecting to the database make sure you have a ticket for a
    principal matching the requested database user name. For example, for
    database user name <literal>fred</literal>, principal
    <literal>fred@EXAMPLE.COM</literal> would be able to connect. To also allow
    principal <literal>fred/users.example.com@EXAMPLE.COM</literal>, use a user name
    map, as described in <xref linkend="auth-username-maps"/>.
   </para>
____________________________________________________________________________-->
   <para>
    当连接到数据库时，确保你有一个匹配被请求数据库用户名的 principal 的票据。例如，对于数据库用户名<literal>fred</literal>，principal  <literal>fred@EXAMPLE.COM</literal>将能够连接。要也允许 principal <literal>fred/users.example.com@EXAMPLE.COM</literal>，可使用一个用户名映射，如<xref linkend="auth-username-maps"/>中所述。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for <productname>GSSAPI</productname>:
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.  For a GSSAPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于<productname>GSSAPI</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果设置为 0，在通过用户名映射之前（<xref linkend="auth-username-maps"/>），来自已认证用户 principal 的 realm 名称会被剥离掉。我们不鼓励这样做，这种方法主要是为了向后兼容性而存在的，因为它在多 realm 环境中是不安全的（除非也使用 <literal>krb_realm</literal>）。推荐用户让<literal>include_realm</literal>设置为默认值（1）并且在<filename>pg_ident.conf</filename>中提供一条显式的映射来把 principal 名称转换成<productname>PostgreSQL</productname>用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
        对于一个 GSSAPI/Kerberos 原则，例如<literal>username@EXAMPLE.COM</literal>
        （或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），
        用于映射的用户名会是<literal>username@EXAMPLE.COM</literal>（或者
        <literal>username/hostbased@EXAMPLE.COM</literal>，相应地），除非
        <literal>include_realm</literal>已经被设置为 0，在那种情况下
        <literal>username</literal>（或者<literal>username/hostbased</literal>）是
        映射时被视作系统用户名的东西。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        设置 realm 为对用户 principal 名进行匹配的范围。
        如果这个参数被设置，只有那个 realm 的用户将被接受。
        如果它没有被设置，任何 realm 的用户都能连接，服从任何已完成的用户名映射。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect1>

  <sect1 id="sspi-auth">
<!--==========================orignal english content==========================
   <title>SSPI Authentication</title>
____________________________________________________________________________-->
   <title>SSPI 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>SSPI</productname> is a <productname>Windows</productname>
    technology for secure authentication with single sign-on.
    <productname>PostgreSQL</productname> will use SSPI in
    <literal>negotiate</literal> mode, which will use
    <productname>Kerberos</productname> when possible and automatically
    fall back to <productname>NTLM</productname> in other cases.
    <productname>SSPI</productname> authentication only works when both
    server and client are running <productname>Windows</productname>,
    or, on non-Windows platforms, when <productname>GSSAPI</productname>
    is available.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>SSPI</productname>是一种用于带单点登录的安全认证的<productname>Windows</productname>技术。 <productname>PostgreSQL</productname>在<literal>negotiate</literal>模式中将使用 SSPI，它在可能的情况下使用<productname>Kerberos</productname>并在其他情况下自动降回到<productname>NTLM</productname>。只有在服务器和客户端都运行着<productname>Windows</productname>时，<productname>SSPI</productname>才能工作。或者在非 Windows 平台上<productname>GSSAPI</productname>可用时，<productname>SSPI</productname>也能工作。
   </para>

<!--==========================orignal english content==========================
   <para>
    When using <productname>Kerberos</productname> authentication,
    <productname>SSPI</productname> works the same way
    <productname>GSSAPI</productname> does; see <xref linkend="gssapi-auth"/>
    for details.
   </para>
____________________________________________________________________________-->
   <para>
    当使用<productname>Kerberos</productname>认证时，<productname>SSPI</productname>和<productname>GSSAPI</productname>的工作方式相同，详见<xref linkend="gssapi-auth"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for <productname>SSPI</productname>:
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>compat_realm</literal></term>
      <listitem>
       <para>
        If set to 1, the domain's SAM-compatible name (also known as the
        NetBIOS name) is used for the <literal>include_realm</literal>
        option. This is the default. If set to 0, the true realm name from
        the Kerberos user principal name is used.
       </para>
       <para>
        Do not disable this option unless your server runs under a domain
        account (this includes virtual service accounts on a domain member
        system) and all clients authenticating through SSPI are also using
        domain accounts, or authentication will fail.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>upn_username</literal></term>
      <listitem>
       <para>
        If this option is enabled along with <literal>compat_realm</literal>,
        the user name from the Kerberos UPN is used for authentication. If
        it is disabled (the default), the SAM-compatible user name is used.
        By default, these two names are identical for new user accounts.
       </para>
       <para>
        Note that <application>libpq</application> uses the SAM-compatible name if no
        explicit user name is specified. If you use
        <application>libpq</application> or a driver based on it, you should
        leave this option disabled or explicitly specify user name in the
        connection string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.  For a SSPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于<productname>SSPI</productname>：
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果设置为 0，在通过用户名映射之前（<xref linkend="auth-username-maps"/>），来自已认证用户 principal 的 realm 名称会被剥离掉。我们不鼓励这样做，这种方法主要是为了向后兼容性而存在的，因为它在多 realm 环境中是不安全的（除非也使用<literal>krb_realm</literal>）。推荐用户让 include_realm 设置为默认值（1）并且在<filename>pg_ident.conf</filename>中提供一条显式的映射来把 principal 名称转换成<productname>PostgreSQL</productname>用户名。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>compat_realm</literal></term>
      <listitem>
       <para>
        如果被设置为 1，该域的 SAM 兼容名称（也被称为 NetBIOS 名称）被用于<literal>include_realm</literal>选项。这是默认值。如果被设置为 0，会使用来自 Kerberos 用户主名的真实 realm 名称。
       </para>
       <para>
        不要禁用这个选项，除非你的服务器运行在一个域账号（这包括一个域成员系统上的虚拟服务账号）下并且所有通过 SSPI 认证的所有客户端也在使用域账号，否则认证将会失败。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>upn_username</literal></term>
      <listitem>
       <para>
        如果这个选项和<literal>compat_realm</literal>一起被启用，来自 Kerberos UPN 的用户名会被用于认证。如果它被禁用（默认），会使用 SAM 兼容的用户名。默认情况下，对于新用户账号这两种名称是一样的。
       </para>
       <para>
        注意如果没有显式指定用户名，<application>libpq</application>会使用 SAM 兼容的名称。如果你使用的是<application>libpq</application>或者基于它的驱动，你应该让这个选项保持禁用或者在连接字符串中显式指定用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
        对于一个 GSSAPI/Kerberos 原则，例如<literal>username@EXAMPLE.COM</literal>
        （或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），
        用于映射的用户名会是<literal>username@EXAMPLE.COM</literal>（或者
        <literal>username/hostbased@EXAMPLE.COM</literal>，相应地），除非
        <literal>include_realm</literal>已经被设置为 0，在那种情况下
        <literal>username</literal>（或者<literal>username/hostbased</literal>）是
        映射时被视作系统用户名的东西。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        设置领域为对用户 principal 名进行匹配的范围。如果这个参数被设置，只有那个领域的用户将被接受。如果它没有被设置，任何领域的用户都能连接，服从任何已完成的用户名映射。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect1>

  <sect1 id="auth-ident">
<!--==========================orignal english content==========================
   <title>Ident Authentication</title>
____________________________________________________________________________-->
   <title>Ident 认证</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ident</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ident</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The ident authentication method works by obtaining the client's
    operating system user name from an ident server and using it as
    the allowed database user name (with an optional user name mapping).
    This is only supported on TCP/IP connections.
   </para>
____________________________________________________________________________-->
   <para>
    ident 认证方法通过从一个 ident 服务器获得客户端的操作系统用户名并且用它作为被允许的数据库用户名（和可选的用户名映射）来工作。它只在 TCP/IP 连接上支持。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     When ident is specified for a local (non-TCP/IP) connection,
     peer authentication (see <xref linkend="auth-peer"/>) will be
     used instead.
    </para>
____________________________________________________________________________-->
    <para>
     当为一个本地（非 TCP/IP）连接指定 ident 时，将实际使用 peer 认证（见<xref linkend="auth-peer"/>）。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for <productname>ident</productname>:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于<productname>ident</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <quote>Identification Protocol</quote> is described in
    RFC 1413. Virtually every Unix-like
    operating system ships with an ident server that listens on TCP
    port 113 by default. The basic functionality of an ident server
    is to answer questions like <quote>What user initiated the
    connection that goes out of your port <replaceable>X</replaceable>
    and connects to my port <replaceable>Y</replaceable>?</quote>.
    Since <productname>PostgreSQL</productname> knows both <replaceable>X</replaceable> and
    <replaceable>Y</replaceable> when a physical connection is established, it
    can interrogate the ident server on the host of the connecting
    client and can theoretically determine the operating system user
    for any given connection.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>Identification Protocol（标识协议）</quote>在 RFC 1413 中描述。实际上每个类 Unix 操作系统都带着一个默认监听 TCP 113 端口的 ident 服务器。ident 服务器的基本功能是回答类似这样的问题：<quote>哪个用户从你的端口<replaceable>X</replaceable>发起了连接并且连到了我的端口<replaceable>Y</replaceable>？</quote> 。因为当一个物理连接被建立后，<productname>PostgreSQL</productname>既知道<replaceable>X</replaceable>也知道<replaceable>Y</replaceable>， 所以它可以询问尝试连接的客户端主机上的 ident 服务器并且在理论上可以判断任意给定连接的操作系统用户。
   </para>

<!--==========================orignal english content==========================
   <para>
    The drawback of this procedure is that it depends on the integrity
    of the client: if the client machine is untrusted or compromised,
    an attacker could run just about any program on port 113 and
    return any user name they choose. This authentication method is
    therefore only appropriate for closed networks where each client
    machine is under tight control and where the database and system
    administrators operate in close contact. In other words, you must
    trust the machine running the ident server.
    Heed the warning:
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      The Identification Protocol is not intended as an authorization
      or access control protocol.
     </para>
    </blockquote>
   </para>
____________________________________________________________________________-->
   <para>
    这个过程的缺点是它依赖于客户端的完整性：如果客户端机器不可信或者被攻破，攻击者可能在 113 端口上运行任何程序并且返回他们选择的任何用户。因此这种认证方法只适用于封闭的网络， 这样的网络中的每台客户端机器都处于严密的控制下并且数据库和操作系统管理员操作时可以方便地联系。换句话说，你必须信任运行 ident 服务器的机器。注意这样的警告：
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      标识协议的本意不是作为一种认证或访问控制协议。
     </para>
    </blockquote>
   </para>

<!--==========================orignal english content==========================
   <para>
    Some ident servers have a nonstandard option that causes the returned
    user name to be encrypted, using a key that only the originating
    machine's administrator knows.  This option <emphasis>must not</emphasis> be
    used when using the ident server with <productname>PostgreSQL</productname>,
    since <productname>PostgreSQL</productname> does not have any way to decrypt the
    returned string to determine the actual user name.
   </para>
____________________________________________________________________________-->
   <para>
    有些 ident 服务器有一个非标准的选项，它导致返回的用户名是被加密的，使用的是只有原机器管理员知道的一个密钥。当与<productname>PostgreSQL</productname>配合使用 ident 服务器时，<emphasis>一定不要</emphasis>使用这个选项，因为<productname>PostgreSQL</productname>没有任何方法对返回的字符串进行解密以获取实际的用户名。
   </para>
  </sect1>

  <sect1 id="auth-peer">
<!--==========================orignal english content==========================
   <title>Peer Authentication</title>
____________________________________________________________________________-->
   <title>Peer 认证</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>peer</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>peer</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The peer authentication method works by obtaining the client's
    operating system user name from the kernel and using it as the
    allowed database user name (with optional user name mapping). This
    method is only supported on local connections.
   </para>
____________________________________________________________________________-->
   <para>
    Peer 认证方法通过从内核获得客户端的操作系统用户名并把它用作被允许的数据库用户名（和可选的用户名映射）来工作。这种方法只在本地连接上支持。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for <productname>peer</productname>:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于<productname>peer</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Peer authentication is only available on operating systems providing
    the <function>getpeereid()</function> function, the <symbol>SO_PEERCRED</symbol>
    socket parameter, or similar mechanisms.  Currently that includes
    <systemitem class="osname">Linux</systemitem>,
    most flavors of <systemitem class="osname">BSD</systemitem> including
    <systemitem class="osname">macOS</systemitem>,
    and <systemitem class="osname">Solaris</systemitem>.
   </para>
____________________________________________________________________________-->
   <para>
    Peer 认证只在提供<function>getpeereid()</function>函数、<symbol>SO_PEERCRED</symbol>套接字参数或相似机制的操作系统上可用。这些 OS 当前包括<systemitem class="osname">Linux</systemitem>、大部分的<systemitem class="osname">BSD</systemitem>包括<systemitem class="osname">OS X</systemitem>以及<systemitem class="osname">Solaris</systemitem>。
   </para>

  </sect1>

  <sect1 id="auth-ldap">
<!--==========================orignal english content==========================
   <title>LDAP Authentication</title>
____________________________________________________________________________-->
   <title>LDAP 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses LDAP
    as the password verification method. LDAP is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before LDAP can be used for
    authentication.
   </para>
____________________________________________________________________________-->
   <para>
    这种认证方法操作起来类似于<literal>password</literal>，只不过它使用 LDAP 作为密码验证方法。LDAP 只被用于验证用户名/口令对。因此，在使用 LDAP 进行认证之前，用户必须已经存在于数据库中。
   </para>

<!--==========================orignal english content==========================
   <para>
    LDAP authentication can operate in two modes. In the first mode,
    which we will call the simple bind mode,
    the server will bind to the distinguished name constructed as
    <replaceable>prefix</replaceable> <replaceable>username</replaceable> <replaceable>suffix</replaceable>.
    Typically, the <replaceable>prefix</replaceable> parameter is used to specify
    <literal>cn=</literal>, or <replaceable>DOMAIN</replaceable><literal>\</literal> in an Active
    Directory environment.  <replaceable>suffix</replaceable> is used to specify the
    remaining part of the DN in a non-Active Directory environment.
   </para>
____________________________________________________________________________-->
   <para>
    LDAP 认证可以在两种模式下操作。在第一种模式中（我们将称之为简单绑定模式），服务器将绑定到构造成<replaceable>prefix</replaceable> <replaceable>username</replaceable> <replaceable>suffix</replaceable>的可区分名称。通常，<replaceable>prefix</replaceable>参数被用于指定 <literal>cn=</literal>或者一个活动录环境中的<replaceable>DOMAIN</replaceable><literal>\</literal>。<replaceable>suffix</replaceable>被用来指定非活动目录环境中的DN的剩余部分。
   </para>

<!--==========================orignal english content==========================
   <para>
    In the second mode, which we will call the search+bind mode,
    the server first binds to the LDAP directory with
    a fixed user name and password, specified with <replaceable>ldapbinddn</replaceable>
    and <replaceable>ldapbindpasswd</replaceable>, and performs a search for the user trying
    to log in to the database. If no user and password is configured, an
    anonymous bind will be attempted to the directory. The search will be
    performed over the subtree at <replaceable>ldapbasedn</replaceable>, and will try to
    do an exact match of the attribute specified in
    <replaceable>ldapsearchattribute</replaceable>.
    Once the user has been found in
    this search, the server disconnects and re-binds to the directory as
    this user, using the password specified by the client, to verify that the
    login is correct. This mode is the same as that used by LDAP authentication
    schemes in other software, such as Apache <literal>mod_authnz_ldap</literal> and <literal>pam_ldap</literal>.
    This method allows for significantly more flexibility
    in where the user objects are located in the directory, but will cause
    two separate connections to the LDAP server to be made.
   </para>
____________________________________________________________________________-->
   <para>
    在第二种模式中（我们将称之为搜索与绑定模式），服务器首先用一个固定的用户名和密码（用<replaceable>ldapbinddn</replaceable>和<replaceable>ldapbindpasswd</replaceable>指定）绑定到 LDAP 目录 ，并为试图登入该数据库的用户执行一次搜索。如果没有配置用户名和密码， 将尝试一次匿名绑定到目录。搜索将在位于<replaceable>ldapbasedn</replaceable>的子树上被执行，并将尝试做一次<replaceable>ldapsearchattribute</replaceable>中指定属性的精确匹配。一旦在这次搜索中找到用户，服务器断开并且作为这个用户重新绑定到目录，使用由客户端指定的口令来验证登录是正确的。这种模式与在其他软件中的 LDAP 认证所使用的相同，例如 Apache <literal>mod_authnz_ldap</literal> 和 <literal>pam_ldap</literal>。这种方法允许位于目录中用户对象的更大灵活性，但是会导致建立两个到 LDAP 服务器的独立连接。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are used in both modes:
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        Names or IP addresses of LDAP servers to connect to. Multiple
        servers may be specified, separated by spaces.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        Port number on LDAP server to connect to. If no port is specified,
        the LDAP library's default port setting will be used.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapscheme</literal></term>
      <listitem>
       <para>
        Set to <literal>ldaps</literal> to use LDAPS.  This is a non-standard
        way of using LDAP over SSL, supported by some LDAP server
        implementations.  See also the <literal>ldaptls</literal> option for
        an alternative.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        Set to 1 to make the connection between PostgreSQL and the LDAP server
        use TLS encryption.  This uses the <literal>StartTLS</literal>
        operation per RFC 4513.  See also the <literal>ldapscheme</literal>
        option for an alternative.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列配置选项被用于两种模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        要连接的LDAP服务器的名称或IP地址。可以指定多个服务器，用空格分隔。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        要连接的LDAP服务器的端口号。如果没有指定端口，LDAP库的默认端口设置将被使用。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapscheme</literal></term>
      <listitem>
       <para>
        设置为<literal>ldaps</literal>可以使用LDAPS。这是一种非标准的在SSL之上使用LDAP的方法，在有一些LDAP服务器实现上可以支持。其他选择还可以参考<literal>ldaptls</literal>选项。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        设置为1以使PostgreSQL和LDAP服务器之间的连接使用TLS加密。这会按照RFC 4513使用<literal>StartTLS</literal>操作。其他选择还可以参考<literal>ldapscheme</literal>选项。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that using <literal>ldapscheme</literal> or
    <literal>ldaptls</literal> only encrypts the traffic between the
    PostgreSQL server and the LDAP server.  The connection between the
    PostgreSQL server and the PostgreSQL client will still be unencrypted
    unless SSL is used there as well.
   </para>
____________________________________________________________________________-->
   <para>
    注意使用<literal>ldapscheme</literal>或<literal>ldaptls</literal>仅会加密PostgreSQL服务器和LDAP服务器之间的通信。PostgreSQL服务器和PostgreSQL客户端之间的连接仍是未加密的，除非也在其上使用SSL。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following options are used in simple bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        String to prepend to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        String to append to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列选项只被用于简单绑定模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的DN的字符串。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的DN的字符串。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The following options are used in search+bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        Root DN to begin the search for the user in, when doing search+bind
        authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        DN of user to bind to the directory with to perform the search when
        doing search+bind authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        Password for user to bind to the directory with to perform the search
        when doing search+bind authentication.
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         Attribute to match against the user name in the search when doing
         search+bind authentication.  If no attribute is specified, the
         <literal>uid</literal> attribute will be used.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchfilter</literal></term>
       <listitem>
        <para>
         The search filter to use when doing search+bind authentication.
         Occurrences of <literal>$username</literal> will be replaced with the
         user name.  This allows for more flexible search filters than
         <literal>ldapsearchattribute</literal>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         An RFC 4516 LDAP URL.  This is an alternative way to write some of the
         other LDAP options in a more compact and standard form.  The format is
<synopsis>
ldap[s]://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filter</replaceable>]]]]
</synopsis>
         <replaceable>scope</replaceable> must be one
         of <literal>base</literal>, <literal>one</literal>, <literal>sub</literal>,
         typically the last.  (The default is <literal>base</literal>, which
         is normally not useful in this application.)  <replaceable>attribute</replaceable> can
         nominate a single attribute, in which case it is used as a value for
         <literal>ldapsearchattribute</literal>.  If
         <replaceable>attribute</replaceable> is empty then
         <replaceable>filter</replaceable> can be used as a value for
         <literal>ldapsearchfilter</literal>.
        </para>

        <para>
         The URL scheme <literal>ldaps</literal> chooses the LDAPS method for
         making LDAP connections over SSL, equivalent to using
         <literal>ldapscheme=ldaps</literal>.  To use encrypted LDAP
         connections using the <literal>StartTLS</literal> operation, use the
         normal URL scheme <literal>ldap</literal> and specify the
         <literal>ldaptls</literal> option in addition to
         <literal>ldapurl</literal>.
        </para>

        <para>
         For non-anonymous binds, <literal>ldapbinddn</literal>
         and <literal>ldapbindpasswd</literal> must be specified as separate
         options.
        </para>

        <para>
         LDAP URLs are currently only supported with OpenLDAP, not on Windows.
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列选项只被用于搜索与绑定模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，开始搜索用户的根DN。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，用户要绑定到目录开始执行搜索的DN。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，用户用于绑定到目录开始执行搜索的口令。
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         当做搜索与绑定认证时，在搜索中用来与用户名匹配的属性。如果没有指定属性，将会使用<literal>uid</literal>属性。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchfilter</literal></term>
       <listitem>
        <para>
         在做search+bind认证时使用的搜索过滤器。<literal>$username</literal>的出现将被替换为用户名。这允许比<literal>ldapsearchattribute</literal>更加灵活的搜索过滤器。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         一个RFC 4516 LDAP URL。这是一种用更紧凑和标准的形式书写某些其他LDAP选项的可选方法。格式是
<synopsis>
ldap[s]://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filter</replaceable>]]]]
</synopsis>
         <replaceable>scope</replaceable>必须是<literal>base</literal>、<literal>one</literal>、<literal>sub</literal>之一，通常是最后一个（默认是<literal>base</literal>，但它在这个应用中通常没啥用）。<replaceable>attribute</replaceable>可以指定一个属性，在这种情况中它被用作<literal>ldapsearchattribute</literal>的一个值。如果<replaceable>attribute</replaceable>为空，那么<replaceable>filter</replaceable>可以被用作<literal>ldapsearchfilter</literal>的一个值。
        </para>

        <para>
         URL模式<literal>ldaps</literal>选择LDAPS方法来在SSL上建立LDAP连接，等效于使用<literal>ldapscheme=ldaps</literal>。要使用<literal>StartTLS</literal>操作加密LDAP连接，可以用普通的URL模式<literal>ldap</literal>并且在<literal>ldapurl</literal>之外指定<literal>ldaptls</literal>选项。
        </para>

        <para>
         对于非匿名绑定，<literal>ldapbinddn</literal>和<literal>ldapbindpasswd</literal>必须被指定为独立选项。
        </para>

        <para>
         LDAP URL 当前只支持 OpenLDAP，而不支持 Windows。
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    It is an error to mix configuration options for simple bind with options
    for search+bind.
   </para>
____________________________________________________________________________-->
   <para>
    将简单绑定的选项中混合用于搜索与绑定的选项是一种错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    When using search+bind mode, the search can be performed using a single
    attribute specified with <literal>ldapsearchattribute</literal>, or using
    a custom search filter specified with
    <literal>ldapsearchfilter</literal>.
    Specifying <literal>ldapsearchattribute=foo</literal> is equivalent to
    specifying <literal>ldapsearchfilter="(foo=$username)"</literal>.  If neither
    option is specified the default is
    <literal>ldapsearchattribute=uid</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在使用search+bind模式时，可以用<literal>ldapsearchattribute</literal>指定的单个属性执行搜索，或者使用<literal>ldapsearchfilter</literal>指定的自定义搜索过滤器执行搜索。指定<literal>ldapsearchattribute=foo</literal>等效于指定<literal>ldapsearchfilter="(foo=$username)"</literal>。如果两个选项都没有被指定，则默认为<literal>ldapsearchattribute=uid</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example for a simple-bind LDAP configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind to the LDAP server using the DN <literal>cn=someuser, dc=example,
    dc=net</literal> and the password provided by the client.  If that connection
    succeeds, the database access is granted.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个简单绑定 LDAP 配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试使用<literal>cn=someuser, dc=example, dc=net</literal>和客户端提供的口令来绑定到 LDAP 服务器。如果那个连接成功，将被授予数据库访问。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example for a search+bind configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind anonymously (since <literal>ldapbinddn</literal> was not specified) to
    the LDAP server, perform a search for <literal>(uid=someuser)</literal>
    under the specified base DN.  If an entry is found, it will then attempt to
    bind using that found information and the password supplied by the client.
    If that second connection succeeds, the database access is granted.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个搜索与绑定配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试匿名绑定（因为没有指定<literal>ldapbinddn</literal>）到 LDAP 服务器，在指定的基础 DN 下执行一次对于<literal>(uid=someuser)</literal>的搜索。如果找到一个项，则它将尝试使用找到的信息和客户端提供的口令进行绑定。如果第二个连接成功，将被授予数据库访问。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is the same search+bind configuration written as a URL:
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    Some other software that supports authentication against LDAP uses the
    same URL format, so it will be easier to share the configuration.
   </para>
____________________________________________________________________________-->
   <para>
    这里是被写成一个 URL 的相同搜索与绑定配置：
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    一些支持根据 LDAP 认证的其他软件使用相同的 URL 格式，因此很容易共享该配置。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example for a search+bind configuration that uses
    <literal>ldapsearchfilter</literal> instead of
    <literal>ldapsearchattribute</literal> to allow authentication by
    user ID or email address:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个search+bind配置的例子，它使用<literal>ldapsearchfilter</literal>而不是<literal>ldapsearchattribute</literal>来允许用用户ID或电子邮件地址进行认证：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
</programlisting>
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Since LDAP often uses commas and spaces to separate the different
     parts of a DN, it is often necessary to use double-quoted parameter
     values when configuring LDAP options, as shown in the examples.
    </para>
____________________________________________________________________________-->
    <para>
     如例子中所示，由于 LDAP 通常使用逗号和空格来分割一个 DN 的不同部分，在配置 LDAP 选项时通常有必要使用双引号包围的参数值。
    </para>
   </tip>

  </sect1>

  <sect1 id="auth-radius">
<!--==========================orignal english content==========================
   <title>RADIUS Authentication</title>
____________________________________________________________________________-->
   <title>RADIUS 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses RADIUS
    as the password verification method. RADIUS is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before RADIUS can be used for
    authentication.
   </para>
____________________________________________________________________________-->
   <para>
    这种认证方法的操作类似于<literal>password</literal>，不过它使用 RADIUS 作为密码验证方式。RADIUS 只被用于验证 用户名/密码对。因此，在 RADIUS 能被用于认证之前，用户必须已经存在于数据库中。
   </para>

<!--==========================orignal english content==========================
   <para>
    When using RADIUS authentication, an Access Request message will be sent
    to the configured RADIUS server. This request will be of type
    <literal>Authenticate Only</literal>, and include parameters for
    <literal>user name</literal>, <literal>password</literal> (encrypted) and
    <literal>NAS Identifier</literal>. The request will be encrypted using
    a secret shared with the server. The RADIUS server will respond to
    this server with either <literal>Access Accept</literal> or
    <literal>Access Reject</literal>. There is no support for RADIUS accounting.
   </para>
____________________________________________________________________________-->
   <para>
    当使用 RADIUS 认证时，一个访问请求消息将被发送到配置好的 RADIUS 服务器。这一请求将是<literal>Authenticate Only</literal>类型，并且包含参数<literal>user name</literal>、<literal>password</literal>（加密的）和<literal>NAS Identifier</literal>。该请求将使用一个与服务器共享的密钥加密。RADIUS 服务器将对这个服务器响应<literal>Access Accept</literal>或者<literal>Access Reject</literal>。不支持RADIUS accounting。
   </para>

<!--==========================orignal english content==========================
   <para>
    Multiple RADIUS servers can be specified, in which case they will
    be tried sequentially. If a negative response is received from
    a server, the authentication will fail. If no response is received,
    the next server in the list will be tried. To specify multiple
    servers, put the names within quotes and separate the server names
    with a comma. If multiple servers are specified, all other RADIUS
    options can also be given as a comma separate list, to apply
    individual values to each server. They can also be specified as
    a single value, in which case this value will apply to all servers.
   </para>
____________________________________________________________________________-->
   <para>
    可以指定多个RADIUS服务器，这种情况下将会依次尝试它们。如果从一台服务器接收到否定响应，则认证失败。如果没有接收到响应，则将会尝试列表中的下一台服务器。要指定多台服务器，可将服务器名放在引号内并且用逗号分隔开。如果指定了多台服务器，所有其他RADIUS选项也可以以逗号分隔的列表给出，用来为每台服务器应用个别的值。也可以把选项指定为一个单一值，这样该值将被应用到所有的服务器。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for RADIUS:
     <variablelist>
      <varlistentry>
       <term><literal>radiusservers</literal></term>
       <listitem>
        <para>
         The name or IP addresses of the RADIUS servers to connect to.
         This parameter is required.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecrets</literal></term>
       <listitem>
        <para>
         The shared secrets used when talking securely to the RADIUS
         server. This must have exactly the same value on the PostgreSQL
         and RADIUS servers. It is recommended that this be a string of
         at least 16 characters. This parameter is required.
         <note>
         <para>
          The encryption vector used will only be cryptographically
          strong if <productname>PostgreSQL</productname> is built with support for
          <productname>OpenSSL</productname>. In other cases, the transmission to the
          RADIUS server should only be considered obfuscated, not secured, and
          external security measures should be applied if necessary.
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusports</literal></term>
       <listitem>
        <para>
         The port number on the RADIUS servers to connect to. If no port
         is specified, the default port <literal>1812</literal> will be used.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifiers</literal></term>
       <listitem>
        <para>
         The string used as <literal>NAS Identifier</literal> in the RADIUS
         requests. This parameter can be used as a second parameter
         identifying for example which database user the user is attempting
         to authenticate as, which can be used for policy matching on
         the RADIUS server. If no identifier is specified, the default
         <literal>postgresql</literal> will be used.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于 RADIUS：
     <variablelist>
      <varlistentry>
       <term><literal>radiusservers</literal></term>
       <listitem>
        <para>
         连接到 RADIUS 服务器的名称或IP地址。此参数是必需的。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecrets</literal></term>
       <listitem>
        <para>
         和 RADIUS 服务器秘密交谈时会用到共享密钥。这在 PostgreSQL 和 RADIUS 服务器之间必须有完全相同的值。我们推荐用一个至少 16 个字符的字符串。这个参数是必需的。
         <note>
         <para>
          如果<productname>PostgreSQL</productname>编译为支持<productname>OpenSSL</productname>，所用的加密向量将只是强密码。在其他情况下，到 RADIUS 服务器的传输应该被视为应该被视为被混淆的、不安全的。如有必要，应采用外部安全措施。
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusports</literal></term>
       <listitem>
        <para>
         用于连接到 RADIUS 服务器的端口号。如果没有指定端口，则使用默认端口<literal>1812</literal>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifiers</literal></term>
       <listitem>
        <para>
         在 RADIUS 请求中字符串被用作<literal>NAS Identifier</literal>。 这个参数可以被用作第二个参数标识例如该用户试图以哪个数据库用户进行认证，它可以被用于 RADIUS 服务器上的策略匹配。如果没有指定标识符，默认使用<literal>postgresql</literal>。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
  </sect1>

  <sect1 id="auth-cert">
<!--==========================orignal english content==========================
   <title>Certificate Authentication</title>
____________________________________________________________________________-->
   <title>证书认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="auth-cert">
    <primary>Certificate</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="auth-cert">
    <primary>证书</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This authentication method uses SSL client certificates to perform
    authentication. It is therefore only available for SSL connections.
    When using this authentication method, the server will require that
    the client provide a valid, trusted certificate.  No password prompt
    will be sent to the client.  The <literal>cn</literal> (Common Name)
    attribute of the certificate
    will be compared to the requested database user name, and if they match
    the login will be allowed.  User name mapping can be used to allow
    <literal>cn</literal> to be different from the database user name.
   </para>
____________________________________________________________________________-->
   <para>
    这种认证方法使用 SSL 客户端证书执行认证。因此，它只适用于 SSL 连接。当使用这种认证方法时，服务器将要求客户端提供一个有效的、可信的证书。不会有密码提示将被发送到客户端。证书的<literal>cn</literal>（通用名）属性将与被请求的数据库用户名进行比较，并且如果匹配将允许登录。用户名映射可以被用来允许<literal>cn</literal>与数据库用户名不同。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for SSL certificate
    authentication:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于 SSL 证书认证：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
<!--==========================orignal english content==========================
   <para>
    In a <filename>pg_hba.conf</filename> record specifying certificate
    authentication, the authentication option <literal>clientcert</literal> is
    assumed to be <literal>1</literal>, and it cannot be turned off since a client
    certificate is necessary for this method.  What the <literal>cert</literal>
    method adds to the basic <literal>clientcert</literal> certificate validity test
    is a check that the <literal>cn</literal> attribute matches the database
    user name.
   </para>
____________________________________________________________________________-->
   <para>
    在一条指定证书认证的<filename>pg_hba.conf</filename>记录中，认证选项<literal>clientcert</literal>被假定为<literal>1</literal>，并且它不能被关掉，因为这种方法中一个客户端证书是必需的。<literal>cert</literal>方法对基本<literal>clientcert</literal>证书验证测试所增加的东西是检查<literal>cn</literal>属性是否匹配数据库用户名。
   </para>
  </sect1>

  <sect1 id="auth-pam">
<!--==========================orignal english content==========================
   <title>PAM Authentication</title>
____________________________________________________________________________-->
   <title>PAM 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses PAM (Pluggable
    Authentication Modules) as the authentication mechanism. The
    default PAM service name is <literal>postgresql</literal>.
    PAM is used only to validate user name/password pairs and optionally the
    connected remote host name or IP address. Therefore the user must already
    exist in the database before PAM can be used for authentication.  For more
    information about PAM, please read the
    <ulink url="https://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</productname> Page</ulink>.
   </para>
____________________________________________________________________________-->
   <para>
    这种认证方法操作起来类似<literal>password</literal>， 只不过它使用 PAM （插入式验证模块）作为认证机制。默认的 PAM 服务名是<literal>postgresql</literal>。PAM 只被用于验证用户名/口令对并且可以有选择地验证已连接的远程主机名或 IP 地址。因此，在使用 PAM 进行认证之前，用户必须已经存在于数据库中。有关 PAM 的更多信息，请阅读<ulink url="https://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</productname> 页面</ulink>.
   </para>

<!--==========================orignal english content==========================
   <para>
    The following configuration options are supported for PAM:
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM service name.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>pam_use_hostname</literal></term>
      <listitem>
       <para>
        Determines whether the remote IP address or the host name is provided
        to PAM modules through the <symbol>PAM_RHOST</symbol> item.  By
        default, the IP address is used.  Set this option to 1 to use the
        resolved host name instead.  Host name resolution can lead to login
        delays.  (Most PAM configurations don't use this information, so it is
        only necessary to consider this setting if a PAM configuration was
        specifically created to make use of it.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    下列被支持的配置选项用于 PAM：
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM服务名称。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>pam_use_hostname</literal></term>
      <listitem>
       <para>
        判断是否通过<symbol>PAM_RHOST</symbol>项把远程 IP 地址或者主机名提供给 PAM 模块。默认情况下会使用 IP 地址。把这个选项设置为 1 可以使用解析过的主机名。主机名解析可能导致登录延迟（大部分的 PAM 配置不使用这些信息，因此只有使用为利用这种信息而特别创建的 PAM 配置时才需要考虑这个设置）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If PAM is set up to read <filename>/etc/shadow</filename>, authentication
     will fail because the PostgreSQL server is started by a non-root
     user.  However, this is not an issue when PAM is configured to use
     LDAP or other authentication methods.
    </para>
____________________________________________________________________________-->
    <para>
     如果 PAM 被设置为读取<filename>/etc/shadow</filename>，认证将会失败，因为 PostgreSQL 服务器是由一个非 root 用户启动 。然而，当 PAM 被配置为使用 LDAP 或其他认证验证方法时这就不是一个问题。
    </para>
   </note>
  </sect1>
  
   <sect1 id="auth-bsd">
<!--==========================orignal english content==========================
   <title>BSD Authentication</title>
____________________________________________________________________________-->
   <title>BSD 认证</title>

<!--==========================orignal english content==========================
   <indexterm zone="auth-bsd">
    <primary>BSD Authentication</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="auth-bsd">
    <primary>BSD 认证</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses BSD Authentication
    to verify the password. BSD Authentication is used only
    to validate user name/password pairs. Therefore the user's role must
    already exist in the database before BSD Authentication can be used
    for authentication. The BSD Authentication framework is currently
    only available on OpenBSD.
   </para>
____________________________________________________________________________-->
   <para>
    这种认证方法操作起来类似于<literal>password</literal>，不过它使用 BSD 认证来验证口令。BSD 认证只被用来验证用户名/口令对。因此，在 BSD 认证可以被用于认证之前，用户的角色必须已经存在于数据库中。BSD 认证框架当前只在 OpenBSD 上可用。
   </para>

<!--==========================orignal english content==========================
   <para>
    BSD Authentication in <productname>PostgreSQL</productname> uses
    the <literal>auth-postgresql</literal> login type and authenticates with
    the <literal>postgresql</literal> login class if that's defined
    in <filename>login.conf</filename>. By default that login class does not
    exist, and <productname>PostgreSQL</productname> will use the default login class.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>中的 BSD 认证使用<literal>auth-postgresql</literal>登录类型，如果<filename>login.conf</filename>中定义了<literal>postgresql</literal>登录分类，就会用它来认证。默认情况下这种登录分类不存在，<productname>PostgreSQL</productname>将使用默认的登录分类。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     To use BSD Authentication, the PostgreSQL user account (that is, the
     operating system user running the server) must first be added to
     the <literal>auth</literal> group.  The <literal>auth</literal> group
     exists by default on OpenBSD systems.
    </para>
____________________________________________________________________________-->
    <para>
     要使用 BSD 认证，PostgreSQL 用户账号（也就是运行服务器的操作系统用户）必须首先被加入到<literal>auth</literal>组中。在 OpenBSD 系统上默认存在<literal>auth</literal>组。
    </para>
   </note>
  </sect1>

  <sect1 id="client-authentication-problems">
<!--==========================orignal english content==========================
   <title>Authentication Problems</title>
____________________________________________________________________________-->
   <title>认证问题</title>

<!--==========================orignal english content==========================
   <para>
    Authentication failures and related problems generally
    manifest themselves through error messages like the following:
   </para>
____________________________________________________________________________-->
   <para>
    认证失败以及相关的问题通常由类似下面的错误消息显示：
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    This is what you are most likely to get if you succeed in contacting
    the server, but it does not want to talk to you. As the message
    suggests, the server refused the connection request because it found
    no matching entry in its <filename>pg_hba.conf</filename>
    configuration file.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    这条消息最可能出现的情况是你成功地联系了服务器，但它不愿意和你说话。就像消息本身所建议的，服务器拒绝了连接请求，因为它没有在其<filename>pg_hba.conf</filename>配置文件里找到匹配项。
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    Messages like this indicate that you contacted the server, and it is
    willing to talk to you, but not until you pass the authorization
    method specified in the <filename>pg_hba.conf</filename> file. Check
    the password you are providing, or check your Kerberos or ident
    software if the complaint mentions one of those authentication
    types.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    这样的消息表示你联系了服务器，并且它也愿意和你交谈，但是你必须通过<filename>pg_hba.conf</filename>文件中指定的认证方法。检查你提供的口令，或者如果错误消息提到了 Kerberos 或 ident 认证类型，检查那些软件。
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    The indicated database user name was not found.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    指示的数据库用户没有被找到。
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    The database you are trying to connect to does not exist. Note that
    if you do not specify a database name, it defaults to the database
    user name, which might or might not be the right thing.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    你试图连接的数据库不存在。请注意如果你没有声明数据库名，默认会用数据库用户名作为数据库名，这可能正确也可能不正确。
   </para>

   <tip>
<!--==========================orignal english content==========================
   <para>
    The server log might contain more information about an
    authentication failure than is reported to the client. If you are
    confused about the reason for a failure, check the server log.
   </para>
____________________________________________________________________________-->
   <para>
    服务器日志可能包含比报告给客户端的更多的有关认证失败的信息。如果你为失败的原因而困惑，那么请检查服务器日志。
   </para>
   </tip>
  </sect1>

 </chapter>
