<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
<!--==========================orignal english content==========================
 <title>Monitoring Database Activity</title>
____________________________________________________________________________-->
 <title>监控数据库活动</title>

<!--==========================orignal english content==========================
 <indexterm zone="monitoring">
  <primary>monitoring</primary>
  <secondary>database activity</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>监控</primary>
  <secondary>数据库活动</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>数据库活动</primary>
  <secondary>监控</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  A database administrator frequently wonders, <quote>What is the system
  doing right now?</quote>
  This chapter discusses how to find that out.
 </para>
____________________________________________________________________________-->
 <para>
  一个数据库管理员常常会疑惑，<quote>系统现在正在做什么？</quote>这一章会讨论如何搞清楚这个问题。
 </para>

<!--==========================orignal english content==========================
  <para>
   Several tools are available for monitoring database activity and
   analyzing performance.  Most of this chapter is devoted to describing
   <productname>PostgreSQL</productname>'s statistics collector,
   but one should not neglect regular Unix monitoring programs such as
   <command>ps</command>, <command>top</command>, <command>iostat</command>, and <command>vmstat</command>.
   Also, once one has identified a
   poorly-performing query, further investigation might be needed using
   <productname>PostgreSQL</productname>'s <xref linkend="sql-explain"/> command.
   <xref linkend="using-explain"/> discusses <command>EXPLAIN</command>
   and other methods for understanding the behavior of an individual
   query.
  </para>
____________________________________________________________________________-->
  <para>
   一些工具可以用来监控数据库活动并且分析性能。这一章的大部分都致力于描述<productname>PostgreSQL</productname>的统计收集器，但是我们也不能忽视常规的 Unix 监控程序，如<command>ps</command>、<command>top</command>、<command>iostat</command>和<command>vmstat</command>。另外，一旦我们发现了一个性能差的查询，可能需要<productname>PostgreSQL</productname>的<xref linkend="sql-explain"/>命令来进行进一步的调查。<xref linkend="using-explain"/>会讨论<command>EXPLAIN</command>以及其他用来理解个体查询行为的方法。
  </para>

 <sect1 id="monitoring-ps">
<!--==========================orignal english content==========================
  <title>Standard Unix Tools</title>
____________________________________________________________________________-->
  <title>标准 Unix 工具</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   On most Unix platforms, <productname>PostgreSQL</productname> modifies its
   command title as reported by <command>ps</command>, so that individual server
   processes can readily be identified.  A sample display is

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (The appropriate invocation of <command>ps</command> varies across different
   platforms, as do the details of what is shown.  This example is from a
   recent Linux system.)  The first process listed here is the
   master server process.  The command arguments
   shown for it are the same ones used when it was launched.  The next five
   processes are background worker processes automatically launched by the
   master process.  (The <quote>stats collector</quote> process will not be present
   if you have set the system not to start the statistics collector; likewise
   the <quote>autovacuum launcher</quote> process can be disabled.)
   Each of the remaining
   processes is a server process handling one client connection.  Each such
   process sets its command line display in the form

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  The user, database, and (client) host items remain the same for
  the life of the client connection, but the activity indicator changes.
  The activity can be <literal>idle</literal> (i.e., waiting for a client command),
  <literal>idle in transaction</literal> (waiting for client inside a <command>BEGIN</command> block),
  or a command type name such as <literal>SELECT</literal>.  Also,
  <literal>waiting</literal> is appended if the server process is presently waiting
  on a lock held by another session.  In the above example we can infer
  that process 15606 is waiting for process 15610 to complete its transaction
  and thereby release some lock.  (Process 15610 must be the blocker, because
  there is no other active session.  In more complicated cases it would be
  necessary to look into the
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  system view to determine who is blocking whom.)
  </para>
____________________________________________________________________________-->
  <para>
   在大部分 Unix 平台上，<productname>PostgreSQL</productname>会修改由<command>ps</command>报告的命令标题，这样个体服务器进程可以被标识。一个显示样例是

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   （<command>ps</command>的调用方式随不同的平台而变，但是显示的细节都差不多。这个例子来自于一个最近的 Linux 系统）。列在这里的第一个进程是主服务器进程。为它显示的命令参数是当它被启动时使用的那些。接下来的五个进程是由主进程自动启动的后台工作者进程（如果你已经设置系统为不启动统计收集器，<quote>统计收集器</quote>进程将不会出现；同样<quote>自动清理发动</quote>进程也可以被禁用）。剩余的每一个进程都是一个处理一个客户端连接的服务器进程。每个这种进程都会把它的命令行显示设置为这种形式

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  在该客户端连接的生命期中，用户、数据库以及（客户端）主机项保持不变，但是活动指示器会改变。活动可以是<literal>闲置</literal>（即等待一个客户端命令）、<literal>在事务中闲置</literal>（在一个<command>BEGIN</command>块里等待客户端）或者一个命令类型名，例如<literal>SELECT</literal>。还有，如果服务器进程正在等待一个其它会话持有的锁， <literal>等待中</literal>会被追加到上述信息中。在上面的例子中，我们可以推断：进程 15606 正在等待进程 15610 完成其事务并且因此释放一些锁（进程 15610 必定是阻塞者，因为没有其他活动会话。在更复杂的情况中，可能需要查看<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图来决定谁阻塞了谁）。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   If <xref linkend="guc-cluster-name"/> has been configured the
   cluster name will also be shown in <command>ps</command> output:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   如果配置了<xref linkend="guc-cluster-name"/>，则集簇的名字
   也将会显示在<command>ps</command>的输出中：
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   If you have turned off <xref linkend="guc-update-process-title"/> then the
   activity indicator is not updated; the process title is set only once
   when a new process is launched.  On some platforms this saves a measurable
   amount of per-command overhead;  on others it's insignificant.
  </para>
____________________________________________________________________________-->
  <para>
   如果你已经关闭了<xref linkend="guc-update-process-title"/>，那么活动指示器将不会被更新，进程标题仅在新进程被启动的时候设置一次。 在某些平台上这样做可以为每个命令节省可观的开销，但在其它平台上却不明显。
  </para>

  <tip>
<!--==========================orignal english content==========================
  <para>
  <productname>Solaris</productname> requires special handling. You must
  use <command>/usr/ucb/ps</command>, rather than
  <command>/bin/ps</command>. You also must use two <option>w</option>
  flags, not just one. In addition, your original invocation of the
  <command>postgres</command> command must have a shorter
  <command>ps</command> status display than that provided by each
  server process.  If you fail to do all three things, the <command>ps</command>
  output for each server process will be the original <command>postgres</command>
  command line.
  </para>
____________________________________________________________________________-->
  <para>
  <productname>Solaris</productname>需要特别的处理。你必需使用<command>/usr/ucb/ps</command>而不是<command>/bin/ps</command>。 你还必需使用两个<option>w</option>标志，而不是一个。另外，你对<command>postgres</command>命令的最初调用必须用一个比服务器进程提供的短的<command>ps</command>状态显示。如果你没有满足全部三个要求，每个服务器进程的<command>ps</command>输出将是原始的<command>postgres</command>命令行。
  command line.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
<!--==========================orignal english content==========================
  <title>The Statistics Collector</title>
____________________________________________________________________________-->
  <title>统计收集器</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s <firstterm>statistics collector</firstterm>
   is a subsystem that supports collection and reporting of information about
   server activity.  Presently, the collector can count accesses to tables
   and indexes in both disk-block and individual-row terms.  It also tracks
   the total number of rows in each table, and information about vacuum and
   analyze actions for each table.  It can also count calls to user-defined
   functions and the total time spent in each one.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的<firstterm>统计收集器</firstterm>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> also supports reporting dynamic
   information about exactly what is going on in the system right now, such as
   the exact command currently being executed by other server processes, and
   which other connections exist in the system.  This facility is independent
   of the collector process.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>也支持报告有关系统正在干什么的
   动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。
   这个功能是独立于收集器进程存在的。
  </para>

 <sect2 id="monitoring-stats-setup">
<!--==========================orignal english content==========================
  <title>Statistics Collection Configuration</title>
____________________________________________________________________________-->
  <title>统计收集配置</title>

<!--==========================orignal english content==========================
  <para>
   Since collection of statistics adds some overhead to query execution,
   the system can be configured to collect or not collect information.
   This is controlled by configuration parameters that are normally set in
   <filename>postgresql.conf</filename>.  (See <xref linkend="runtime-config"/> for
   details about setting configuration parameters.)
  </para>
____________________________________________________________________________-->
  <para>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<filename>postgresql.conf</filename>中设置（关于设置配置参数的细节请见<xref linkend="runtime-config"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-activities"/> enables monitoring
   of the current command being executed by any server process.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-activities"/>允许监控当前被任意服务器进程执行的命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-counts"/> controls whether
   statistics are collected about table and index accesses.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-counts"/>控制是否收集关于表和索引访问的统计信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-functions"/> enables tracking of
   usage of user-defined functions.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-functions"/>启用对用户定义函数使用的跟踪。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-io-timing"/> enables monitoring
   of block read and write times.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-io-timing"/>启用对块读写次数的监控。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally these parameters are set in <filename>postgresql.conf</filename> so
   that they apply to all server processes, but it is possible to turn
   them on or off in individual sessions using the <xref
   linkend="sql-set"/> command. (To prevent
   ordinary users from hiding their activity from the administrator,
   only superusers are allowed to change these parameters with
   <command>SET</command>.)
  </para>
____________________________________________________________________________-->
  <para>
   通常这些参数被设置在<filename>postgresql.conf</filename>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<xref linkend="sql-set"/>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<command>SET</command>来改变这些参数）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The statistics collector transmits the collected information to other
   <productname>PostgreSQL</productname> processes through temporary files.
   These files are stored in the directory named by the
   <xref linkend="guc-stats-temp-directory"/> parameter,
   <filename>pg_stat_tmp</filename> by default.
   For better performance, <varname>stats_temp_directory</varname> can be
   pointed at a RAM-based file system, decreasing physical I/O requirements.
   When the server shuts down cleanly, a permanent copy of the statistics
   data is stored in the <filename>pg_stat</filename> subdirectory, so that
   statistics can be retained across server restarts.  When recovery is
   performed at server start (e.g. after immediate shutdown, server crash,
   and point-in-time recovery), all statistics counters are reset.
  </para>
____________________________________________________________________________-->
  <para>
   统计收集器通过临时文件将收集到的信息传送给其他<productname>PostgreSQL</productname>进程。这些文件被存储在名字由<xref linkend="guc-stats-temp-directory"/>参数指定的目录中，默认是<filename>pg_stat_tmp</filename>。为了得到更好的性能，<varname>stats_temp_directory</varname>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<filename>pg_stat</filename>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
<!--==========================orignal english content==========================
  <title>Viewing Statistics</title>
____________________________________________________________________________-->
  <title>查看统计信息</title>

<!--==========================orignal english content==========================
  <para>
   Several predefined views, listed in <xref
   linkend="monitoring-stats-dynamic-views-table"/>, are available to show
   the current state of the system. There are also several other
   views, listed in <xref
   linkend="monitoring-stats-views-table"/>, available to show the results
   of statistics collection.  Alternatively, one can
   build custom views using the underlying statistics functions, as discussed
   in <xref linkend="monitoring-stats-functions"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="monitoring-stats-dynamic-views-table"/>中列出了一些预定义视图
   可以用来显示系统的当前状态。
   <xref linkend="monitoring-stats-views-table"/>中列出了另一些视图可以
   显示统计收集的结果。你也可以使用底层统计函数（在
   <xref linkend="monitoring-stats-functions"/>中讨论）来建立自定义的视图。
  </para>

<!--==========================orignal english content==========================
  <para>
   When using the statistics to monitor collected data, it is important
   to realize that the information does not update instantaneously.
   Each individual server process transmits new statistical counts to
   the collector just before going idle; so a query or transaction still in
   progress does not affect the displayed totals.  Also, the collector itself
   emits a new report at most once per <varname>PGSTAT_STAT_INTERVAL</varname>
   milliseconds (500 ms unless altered while building the server).  So the
   displayed information lags behind actual activity.  However, current-query
   information collected by <varname>track_activities</varname> is
   always up-to-date.
  </para>
____________________________________________________________________________-->
  <para>
   在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<varname>PGSTAT_STAT_INTERVAL</varname>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<varname>track_activities</varname>收集的当前查询信息总是最新的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another important point is that when a server process is asked to display
   any of these statistics, it first fetches the most recent report emitted by
   the collector process and then continues to use this snapshot for all
   statistical views and functions until the end of its current transaction.
   So the statistics will show static information as long as you continue the
   current transaction.  Similarly, information about the current queries of
   all sessions is collected when any such information is first requested
   within a transaction, and the same information will be displayed throughout
   the transaction.
   This is a feature, not a bug, because it allows you to perform several
   queries on the statistics and correlate the results without worrying that
   the numbers are changing underneath you.  But if you want to see new
   results with each query, be sure to do the queries outside any transaction
   block.  Alternatively, you can invoke
   <function>pg_stat_clear_snapshot</function>(), which will discard the
   current transaction's statistics snapshot (if any).  The next use of
   statistical information will cause a new snapshot to be fetched.
  </para>
____________________________________________________________________________-->
  <para>
   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<function>pg_stat_clear_snapshot</function>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </para>

<!--==========================orignal english content==========================
  <para>
   A transaction can also see its own statistics (as yet untransmitted to the
   collector) in the views <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname>, and
   <structname>pg_stat_xact_user_functions</structname>.  These numbers do not act as
   stated above; instead they update continuously throughout the transaction.
  </para>
____________________________________________________________________________-->
  <para>
   一个事务也可以在视图<structname>pg_stat_xact_all_tables</structname>、<structname>pg_stat_xact_sys_tables</structname>、<structname>pg_stat_xact_user_tables</structname>和<structname>pg_stat_xact_user_functions</structname>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </para>

  <table id="monitoring-stats-dynamic-views-table">
<!--==========================orignal english content==========================
   <title>Dynamic Statistics Views</title>
____________________________________________________________________________-->
   <title>动态统计视图</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       One row per server process, showing information related to
       the current activity of that process, such as state and current query.
       See <xref linkend="pg-stat-activity-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<xref linkend="pg-stat-activity-view"/>。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>One row per WAL sender process, showing statistics about
       replication to that sender's connected standby server.
       See <xref linkend="pg-stat-replication-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
       <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>每一个 WAL 发送进程一行，显示有关到该发送进程
      连接的后备服务器的复制的统计信息。详见
      <xref linkend="pg-stat-replication-view"/>。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Only one row, showing statistics about the WAL receiver from
       that receiver's connected server.
       See <xref linkend="pg-stat-wal-receiver-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<xref linkend="pg-stat-wal-receiver-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>At least one row per subscription, showing information about
       the subscription workers.
       See <xref linkend="pg-stat-subscription"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>每个订阅至少一行，显示有关该订阅的工作者的信息。详见<xref linkend="pg-stat-subscription"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       SSL used on this connection.
       See <xref linkend="pg-stat-ssl-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>每个连接（常规的或者复制）一行，显示在这个连接上使用的SSL的信息。详见<xref linkend="pg-stat-ssl-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>VACUUM</command>, showing current progress.
       See <xref linkend='vacuum-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>每个运行着<command>VACUUM</command>的后端（包括autovacuum工作者进程）一行，显示当前的进度。详见<xref linkend='vacuum-progress-reporting'/>。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
<!--==========================orignal english content==========================
   <title>Collected Statistics Views</title>
____________________________________________________________________________-->
   <title>已收集统计信息的视图</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       WAL archiver process's activity. See
       <xref linkend="pg-stat-archiver-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<xref linkend="pg-stat-archiver-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       background writer process's activity. See
       <xref linkend="pg-stat-bgwriter-view"/> for details.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>      
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>只有一行，显示有关后台写进程的活动的统计信息。详见<xref linkend="pg-stat-bgwriter-view"/>。
     </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>One row per database, showing database-wide statistics. See
       <xref linkend="pg-stat-database-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>每个数据库一行，显示数据库范围的统计信息。详见<xref linkend="pg-stat-database-view"/>。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       One row per database, showing database-wide statistics about
       query cancels due to conflict with recovery on standby servers.
       See <xref linkend="pg-stat-database-conflicts-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见
       <xref linkend="pg-stat-database-conflicts-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about accesses to that specific table.
       See <xref linkend="pg-stat-all-tables-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<xref linkend="pg-stat-all-tables-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only user
      tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_all_tables</structname>, but counts actions
      taken so far within the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_all_tables</structname> and related views).
      The columns for numbers of live and dead rows and vacuum and
      analyze actions are not present in this view.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>相似，但计数动作只在当前事务内发生（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_all_tables</structname>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database, showing statistics
       about accesses to that specific index.
       See <xref linkend="pg-stat-all-indexes-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<xref linkend="pg-stat-all-indexes-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about I/O on that specific table.
       See <xref linkend="pg-statio-all-tables-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<xref linkend="pg-statio-all-tables-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database,
       showing statistics about I/O on that specific index.
       See <xref linkend="pg-statio-all-indexes-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<xref linkend="pg-statio-all-indexes-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       One row for each sequence in the current database,
       showing statistics about I/O on that specific sequence.
       See <xref linkend="pg-statio-all-sequences-view"/> for details.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<xref linkend="pg-statio-all-sequences-view"/>。
     </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      system sequences are shown.  (Presently, no system sequences are defined,
      so this view is always empty.)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      user sequences are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示用户序列。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       One row for each tracked function, showing statistics
       about executions of that function. See
       <xref linkend="pg-stat-user-functions-view"/> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<xref linkend="pg-stat-user-functions-view"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_user_functions</structname>, but counts only
      calls during the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_user_functions</structname>).</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>和<structname>pg_stat_user_functions</structname>相似，但是只统计在当前事务期间的调用（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_user_functions</structname>中）。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The per-index statistics are particularly useful to determine which
   indexes are being used and how effective they are.
  </para>
____________________________________________________________________________-->
  <para>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_</structname> views are primarily useful to
   determine the effectiveness of the buffer cache.  When the number
   of actual disk reads is much smaller than the number of buffer
   hits, then the cache is satisfying most read requests without
   invoking a kernel call. However, these statistics do not give the
   entire story: due to the way in which <productname>PostgreSQL</productname>
   handles disk I/O, data that is not in the
   <productname>PostgreSQL</productname> buffer cache might still reside in the
   kernel's I/O cache, and might therefore still be fetched without
   requiring a physical read. Users interested in obtaining more
   detailed information on <productname>PostgreSQL</productname> I/O behavior are
   advised to use the <productname>PostgreSQL</productname> statistics collector
   in combination with operating system utilities that allow insight
   into the kernel's handling of I/O.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_</structname>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<productname>PostgreSQL</productname>处理磁盘 I/O 的方式，不在<productname>PostgreSQL</productname>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<productname>PostgreSQL</productname> I/O 行为更多细节的用户将<productname>PostgreSQL</productname>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_activity</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_activity</structname> 视图</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the database this backend is connected to</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个后端连接到的数据库的OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the database this backend is connected to</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个后端连接到的数据库的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of this backend</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>这个后端的进程 ID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the user logged into this backend</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>登录到这个后端的用户的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the user logged into this backend</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>登录到这个后端的用户的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the application that is connected
      to this backend</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>连接到这个后端的应用的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>IP address of the client connected to this backend.
      If this field is null, it indicates either that the client is
      connected via a Unix socket on the server machine or that this is an
      internal process such as autovacuum.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</structfield>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"/> is enabled.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>已连接的客户端的主机名，由<structfield>client_addr</structfield>的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有<xref linkend="guc-log-hostname"/>被启用时才会非空。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>TCP port number that the client is using for communication
      with this backend, or <literal>-1</literal> if a Unix socket is used
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为<literal>-1</literal>
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process was started.  For client backends,
      this is the time the client connected to the server.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>这个进程被启动的时间。对客户端后端来说就是客户端连接到服务器的时间。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>xact_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process' current transaction was started, or null
      if no transaction is active. If the current
      query is the first of its transaction, this column is equal to the
      <structfield>query_start</structfield> column.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>xact_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于<structfield>query_start</structfield>。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>query_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when the currently active query was started, or if
      <structfield>state</structfield> is not <literal>active</literal>, when the last query
      was started
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>query_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>当前活动查询被开始的时间，如果<structfield>state</structfield>不是<literal>active</literal>，这个域为上一个查询被开始的时间
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>state_change</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when the <structfield>state</structfield> was last changed</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>state_change</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry><structfield>state</structfield>上一次被改变的时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
      <entry><structfield>wait_event_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The type of event for which the backend is waiting, if any;
       otherwise NULL. Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>LWLock</literal>: The backend is waiting for a lightweight lock.
          Each such lock protects a particular data structure in shared memory.
          <literal>wait_event</literal> will contain a name identifying the purpose
          of the lightweight lock.  (Some locks have specific names; others
          are part of a group of locks each with a similar purpose.)
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Lock</literal>: The backend is waiting for a heavyweight lock.
          Heavyweight locks, also known as lock manager locks or simply locks,
          primarily protect SQL-visible objects such as tables.  However,
          they are also used to ensure mutual exclusion for certain internal
          operations such as relation extension.  <literal>wait_event</literal> will
          identify the type of lock awaited.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>BufferPin</literal>: The server process is waiting to access to
          a data buffer during a period when no other process can be
          examining that buffer.  Buffer pin waits can be protracted if
          another process holds an open cursor which last read data from the
          buffer in question.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Activity</literal>: The server process is idle.  This is used by
          system processes waiting for activity in their main processing loop.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Extension</literal>: The server process is waiting for activity
          in an extension module.  This category is useful for modules to
          track custom waiting points.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Client</literal>: The server process is waiting for some activity
          on a socket from user applications, and that the server expects
          something to happen that is independent from its internal processes.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IPC</literal>: The server process is waiting for some activity
          from another process in the server.  <literal>wait_event</literal> will
          identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Timeout</literal>: The server process is waiting for a timeout
          to expire.  <literal>wait_event</literal> will identify the specific wait
          point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IO</literal>: The server process is waiting for a IO to complete.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
       </itemizedlist>
      </entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry><structfield>wait_event_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry>后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：
       <itemizedlist>
        <listitem>
         <para>
          <literal>LWLock</literal>：后端正在等待一个轻量级锁。每一个这样的锁保护着共享内存中的一个特殊数据结构。<literal>wait_event</literal>将含有一个标识该轻量级锁目的的名称（一些锁具有特定的名称，其他是一组具有类似目的的锁中的一部分）。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Lock</literal>：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。<literal>wait_event</literal>将标识等待的锁的类型。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>BufferPin</literal>：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Activity</literal>：服务器进程处于闲置状态。这被用于在其主处理循环中等待活动的系统进程。<literal>wait_event</literal>将标识特定的等待点。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Extension</literal>：服务器进程正在一个扩展模块中等待活动。这一个分类被用于要跟踪自定义等待点的模块。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Client</literal>：服务器进程正在一个套接字上等待来自用户应用的某种活动，并且该服务器预期某种与其内部处理无关的事情发生。<literal>wait_event</literal>将标识特定的等待点。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IPC</literal>：服务器进程正在等待来自服务器中另一个进程的某种活动。<literal>wait_event</literal>将标识特定的等待点。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Timeout</literal>：服务器进程正在等待一次超时发生。<literal>wait_event</literal>将标识特定的等待点。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IO</literal>：服务器进程正在等待一次IO完成。<literal>wait_event</literal>将标识特定的等待点。
         </para>
        </listitem>
       </itemizedlist>
      </entry>
     </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>wait_event</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Wait event name if backend is currently waiting, otherwise NULL.
     See <xref linkend="wait-event-table"/> for details.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>wait_event</structfield></entry>
     <entry><type>text</type></entry>
     <entry>如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见<xref linkend="wait-event-table"/>。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Current overall state of this backend.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>: The backend is executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>: The backend is waiting for a new client command.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>: The backend is in a transaction,
           but is not currently executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>: This state is similar to
           <literal>idle in transaction</literal>, except one of the statements in
           the transaction caused an error.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>: The backend is executing a
           fast-path function.
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>: This state is reported if <xref
           linkend="guc-track-activities"/> is disabled in this backend.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>这个后端的当前总体状态。可能的值是：
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>：后端正在执行一个查询。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>：后端正在等待一个新的客户端命令。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>：后端在一个事务中，但是当前没有正在执行一个查询。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>：这个状态与<literal>idle in transaction</literal>相似，不过在该事务中的一个语句导致了一个错误。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>：后端正在执行一个 fast-path 函数。
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>：如果在这个后端中<xref linkend="guc-track-activities"/>被禁用，则报告这个状态。
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>Top-level transaction identifier of this backend, if any.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>这个后端的顶层事务标识符（如果存在）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>The current backend's <literal>xmin</literal> horizon.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>当前后端的<literal>xmin</literal>范围。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>query</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Text of this backend's most recent query. If
      <structfield>state</structfield> is <literal>active</literal> this field shows the
      currently executing query. In all other states, it shows the last query
      that was executed. By default the query text is truncated at 1024
      characters; this value can be changed via the parameter
      <xref linkend="guc-track-activity-query-size"/>.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>query</structfield></entry>
     <entry><type>text</type></entry>
     <entry>这个后端最近查询的文本。如果<structfield>state</structfield>为<literal>active</literal>，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字符，这个值可以通过参数<xref linkend="guc-track-activity-query-size"/>更改。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_type</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Type of current backend. Possible types are
      <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
      <literal>logical replication launcher</literal>,
      <literal>logical replication worker</literal>,
      <literal>parallel worker</literal>, <literal>background writer</literal>,
      <literal>client backend</literal>, <literal>checkpointer</literal>,
      <literal>startup</literal>, <literal>walreceiver</literal>,
      <literal>walsender</literal> and <literal>walwriter</literal>.
      In addition, background workers registered by extensions may have
      additional types.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_type</structfield></entry>
     <entry><type>text</type></entry>
     <entry>当前后端的类型。可能的类型是
      <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
      <literal>logical replication launcher</literal>,
      <literal>logical replication worker</literal>,
      <literal>parallel worker</literal>, <literal>background writer</literal>,
      <literal>client backend</literal>, <literal>checkpointer</literal>,
      <literal>startup</literal>, <literal>walreceiver</literal>,
      <literal>walsender</literal> 以及 <literal>walwriter</literal>。
      除此以外，由扩展注册的后台Worker可能有额外的类型。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_activity</structname>视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <structfield>wait_event</structfield> and <structfield>state</structfield> columns are
    independent.  If a backend is in the <literal>active</literal> state,
    it may or may not be <literal>waiting</literal> on some event.  If the state
    is <literal>active</literal> and <structfield>wait_event</structfield> is non-null, it
    means that a query is being executed, but is being blocked somewhere
    in the system.
   </para>
____________________________________________________________________________-->
   <para>
    <structfield>wait_event</structfield>和<structfield>state</structfield>列是独立的。如果一个后端处于<literal>active</literal>状态，它可能是也可能不是某个事件上的<literal>waiting</literal>。如果状态是<literal>active</literal>并且<structfield>wait_event</structfield>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </para>
  </note>
  
  <table id="wait-event-table">
<!--==========================orignal english content==========================
   <title><structname>wait_event</structname> Description</title>
____________________________________________________________________________-->
   <title><structname>wait_event</structname> 描述</title>

    <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Wait Event Type</entry>
        <entry>Wait Event Name</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>等待事件类型</entry>
        <entry>等待事件名称</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry morerows="64"><literal>LWLock</literal></entry>
        <entry><literal>ShmemIndexLock</literal></entry>
        <entry>Waiting to find or allocate space in shared memory.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry morerows="64"><literal>LWLock</literal></entry>
        <entry><literal>ShmemIndexLock</literal></entry>
        <entry>正等待在共享内存中查找或者分配空间。</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>OidGenLock</literal></entry>
        <entry>Waiting to allocate or assign an OID.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>OidGenLock</literal></entry>
        <entry>正等待分配或者赋予一个 OID。</entry>
       </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>XidGenLock</literal></entry>
         <entry>Waiting to allocate or assign a transaction id.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>XidGenLock</literal></entry>
         <entry>正等待分配或者赋予一个事务 ID。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ProcArrayLock</literal></entry>
         <entry>Waiting to get a snapshot or clearing a transaction id at
         transaction end.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ProcArrayLock</literal></entry>
         <entry>正等待在事务结尾得到一个快照或者清除事务 ID。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SInvalReadLock</literal></entry>
         <entry>Waiting to retrieve or remove messages from shared invalidation
         queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SInvalReadLock</literal></entry>
         <entry>正等待从共享无效消息队列中检索或者移除消息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SInvalWriteLock</literal></entry>
         <entry>Waiting to add a message in shared invalidation queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SInvalWriteLock</literal></entry>
         <entry>正等待在共享无效消息队列中增加一个消息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALBufMappingLock</literal></entry>
         <entry>Waiting to replace a page in WAL buffers.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALBufMappingLock</literal></entry>
         <entry>正等待在 WAL 缓冲区中替换一个页面。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALWriteLock</literal></entry>
         <entry>Waiting for WAL buffers to be written to disk.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALWriteLock</literal></entry>
         <entry>正等待 WAL 缓冲区被写入到磁盘。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileLock</literal></entry>
         <entry>Waiting to read or update the control file or creation of a
         new WAL file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileLock</literal></entry>
         <entry>正等待读取或者更新控制文件或创建一个新的 WAL 文件。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CheckpointLock</literal></entry>
         <entry>Waiting to perform checkpoint.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CheckpointLock</literal></entry>
         <entry>正等待执行检查点。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CLogControlLock</literal></entry>
         <entry>Waiting to read or update transaction status.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CLogControlLock</literal></entry>
         <entry>正等待读取或者更新事务状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SubtransControlLock</literal></entry>
         <entry>Waiting to read or update sub-transaction information.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SubtransControlLock</literal></entry>
         <entry>正等待读取或者更新子事务信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MultiXactGenLock</literal></entry>
         <entry>Waiting to read or update shared multixact state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MultiXactGenLock</literal></entry>
         <entry>正等待读取或者更新共享多事务状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MultiXactOffsetControlLock</literal></entry>
         <entry>Waiting to read or update multixact offset mappings.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MultiXactOffsetControlLock</literal></entry>
         <entry>正等待读取或者更新多事务偏移映射。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MultiXactMemberControlLock</literal></entry>
         <entry>Waiting to read or update multixact member mappings.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MultiXactMemberControlLock</literal></entry>
         <entry>正等待读取或者更新多事务成员映射。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RelCacheInitLock</literal></entry>
         <entry>Waiting to read or write relation cache initialization
         file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RelCacheInitLock</literal></entry>
         <entry>正等待读取或者写入关系缓冲区初始化文件。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CheckpointerCommLock</literal></entry>
         <entry>Waiting to manage fsync requests.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CheckpointerCommLock</literal></entry>
         <entry>正等待管理 fsync 请求。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TwoPhaseStateLock</literal></entry>
         <entry>Waiting to read or update the state of prepared transactions.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TwoPhaseStateLock</literal></entry>
         <entry>正等待读取或者更新预备事务的状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TablespaceCreateLock</literal></entry>
         <entry>Waiting to create or drop the tablespace.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TablespaceCreateLock</literal></entry>
         <entry>正等待创建或者删除表空间。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BtreeVacuumLock</literal></entry>
          <entry>Waiting to read or update vacuum-related information for a
          B-tree index.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BtreeVacuumLock</literal></entry>
          <entry>正等待读取或者更新一个 B-树索引的 vacuum 相关的信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AddinShmemInitLock</literal></entry>
         <entry>Waiting to manage space allocation in shared memory.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AddinShmemInitLock</literal></entry>
         <entry>正等待管理共享内存中的空间分配。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AutovacuumLock</literal></entry>
         <entry>Autovacuum worker or launcher waiting to update or
         read the current state of autovacuum workers.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AutovacuumLock</literal></entry>
         <entry>自动清理工作者或者启动器正等待更新或者读取自动清理工作者的当前状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AutovacuumScheduleLock</literal></entry>
         <entry>Waiting to ensure that the table it has selected for a vacuum
         still needs vacuuming.
         </entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AutovacuumScheduleLock</literal></entry>
         <entry>正等待确认选中进行清理的表仍需要清理。
         </entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SyncScanLock</literal></entry>
         <entry>Waiting to get the start location of a scan on a table for
         synchronized scans.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SyncScanLock</literal></entry>
         <entry>正等待为同步扫描得到一个表上扫描的开始位置。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RelationMappingLock</literal></entry>
         <entry>Waiting to update the relation map file used to store catalog
         to filenode mapping.
         </entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RelationMappingLock</literal></entry>
         <entry>正等待更新用来存储目录到文件节点映射的关系映射文件。
         </entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AsyncCtlLock</literal></entry>
         <entry>Waiting to read or update shared notification state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AsyncCtlLock</literal></entry>
         <entry>正等待读取或者更新共享通知状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AsyncQueueLock</literal></entry>
          <entry>Waiting to read or update notification messages.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AsyncQueueLock</literal></entry>
          <entry>正等待读取或者更新通知消息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SerializableXactHashLock</literal></entry>
         <entry>Waiting to retrieve or store information about serializable
         transactions.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SerializableXactHashLock</literal></entry>
         <entry>正等待检索或者存储有关可序列化事务的信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SerializableFinishedListLock</literal></entry>
         <entry>Waiting to access the list of finished serializable
         transactions.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SerializableFinishedListLock</literal></entry>
         <entry>正等待访问已结束可序列化事务的列表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SerializablePredicateLockListLock</literal></entry>
         <entry>Waiting to perform an operation on a list of locks held by
         serializable transactions.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SerializablePredicateLockListLock</literal></entry>
         <entry>正等待在由可序列化事务持有的所列表上执行一个操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>OldSerXidLock</literal></entry>
         <entry>Waiting to read or record conflicting serializable
         transactions.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>OldSerXidLock</literal></entry>
         <entry>正等待读取或者记录冲突的可序列化事务。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SyncRepLock</literal></entry>
         <entry>Waiting to read or update information about synchronous
         replicas.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SyncRepLock</literal></entry>
         <entry>正等待读取或者更新有关同步复制的信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BackgroundWorkerLock</literal></entry>
         <entry>Waiting to read or update background worker state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BackgroundWorkerLock</literal></entry>
         <entry>正等待读取或者更新后台工作者状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DynamicSharedMemoryControlLock</literal></entry>
         <entry>Waiting to read or update dynamic shared memory state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DynamicSharedMemoryControlLock</literal></entry>
         <entry>正等待读取或者更新动态共享内存状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AutoFileLock</literal></entry>
         <entry>Waiting to update the <filename>postgresql.auto.conf</filename> file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AutoFileLock</literal></entry>
         <entry>正等待更新<filename>postgresql.auto.conf</filename>文件。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotAllocationLock</literal></entry>
         <entry>Waiting to allocate or free a replication slot.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotAllocationLock</literal></entry>
         <entry>正等待分配或者释放一个复制槽。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotControlLock</literal></entry>
         <entry>Waiting to read or update replication slot state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotControlLock</literal></entry>
         <entry>正等待读取或者更新复制槽状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CommitTsControlLock</literal></entry>
         <entry>Waiting to read or update transaction commit timestamps.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CommitTsControlLock</literal></entry>
         <entry>正等待读取或者更新事务提交时间戳。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CommitTsLock</literal></entry>
         <entry>Waiting to read or update the last value set for the
         transaction timestamp.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CommitTsLock</literal></entry>
         <entry>正等待读取或者更新事务时间戳的最新设置值。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationOriginLock</literal></entry>
         <entry>Waiting to setup, drop or use replication origin.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationOriginLock</literal></entry>
         <entry>正等待设置、删除或者使用复制源头。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MultiXactTruncationLock</literal></entry>
         <entry>Waiting to read or truncate multixact information.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MultiXactTruncationLock</literal></entry>
         <entry>正等待读取或者阶段多事务信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>OldSnapshotTimeMapLock</literal></entry>
         <entry>Waiting to read or update old snapshot control information.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>OldSnapshotTimeMapLock</literal></entry>
         <entry>正等待读取或者更新旧的快照控制信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BackendRandomLock</literal></entry>
         <entry>Waiting to generate a random number.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BackendRandomLock</literal></entry>
         <entry>正等待产生一个随机数。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRepWorkerLock</literal></entry>
         <entry>Waiting for action on logical replication worker to finish.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRepWorkerLock</literal></entry>
         <entry>正等待逻辑复制工作者上的动作完成。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CLogTruncationLock</literal></entry>
         <entry>Waiting to truncate the write-ahead log or waiting for write-ahead log truncation to finish.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CLogTruncationLock</literal></entry>
         <entry>正等待截断预写式日志或者等待预写式日志截断操作完成。</entry>
        </row> 
<!--==========================orignal english content==========================
        <row>
         <entry><literal>clog</literal></entry>
         <entry>Waiting for I/O on a clog (transaction status) buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>clog</literal></entry>
         <entry>正在等地clog (事务状态)缓冲区上的I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>commit_timestamp</literal></entry>
         <entry>Waiting for I/O on commit timestamp buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>commit_timestamp</literal></entry>
         <entry>正等待提交时间戳缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>subtrans</literal></entry>
         <entry>Waiting for I/O a subtransaction buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>subtrans</literal></entry>
         <entry>正等待子事务缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>multixact_offset</literal></entry>
         <entry>Waiting for I/O on a multixact offset buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>multixact_offset</literal></entry>
         <entry>正等待多事务偏移缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>multixact_member</literal></entry>
         <entry>Waiting for I/O on a multixact_member buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>multixact_member</literal></entry>
         <entry>正等待多事务成员缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>async</literal></entry>
         <entry>Waiting for I/O on an async (notify) buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>async</literal></entry>
         <entry>正等待 async（通知）缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>oldserxid</literal></entry>
         <entry>Waiting for I/O on an oldserxid buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>oldserxid</literal></entry>
         <entry>正等待 oldserxid 缓冲区上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>wal_insert</literal></entry>
         <entry>Waiting to insert WAL into a memory buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>wal_insert</literal></entry>
         <entry>正等待把 WAL 插入到一个内存缓冲区。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>buffer_content</literal></entry>
         <entry>Waiting to read or write a data page in memory.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>buffer_content</literal></entry>
         <entry>正等待读取或者写入内存中的一个数据页。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>buffer_io</literal></entry>
         <entry>Waiting for I/O on a data page.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>buffer_io</literal></entry>
         <entry>正等待一个数据页面上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>replication_origin</literal></entry>
         <entry>Waiting to read or update the replication progress.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>replication_origin</literal></entry>
         <entry>正等待读取或者更新复制进度。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>replication_slot_io</literal></entry>
         <entry>Waiting for I/O on a replication slot.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>replication_slot_io</literal></entry>
         <entry>正等待一个复制槽上的 I/O。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>proc</literal></entry>
         <entry>Waiting to read or update the fast-path lock information.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>proc</literal></entry>
         <entry>正等待读取或者更新 fast-path 锁信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>buffer_mapping</literal></entry>
         <entry>Waiting to associate a data block with a buffer in the buffer
         pool.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>buffer_mapping</literal></entry>
         <entry>正等待把一个数据块与缓冲池中的一个缓冲区关联。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>lock_manager</literal></entry>
         <entry>Waiting to add or examine locks for backends, or waiting to
         join or exit a locking group (used by parallel query).</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>lock_manager</literal></entry>
         <entry>正等待增加或者检查用于后端的锁，或者正等待加入或者退出一个锁定组（并行查询使用）。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>predicate_lock_manager</literal></entry>
         <entry>Waiting to add or examine predicate lock information.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>predicate_lock_manager</literal></entry>
         <entry>正等待增加或者检查谓词锁信息。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>parallel_query_dsa</literal></entry>
         <entry>Waiting for parallel query dynamic shared memory allocation lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>parallel_query_dsa</literal></entry>
         <entry>正等待并行查询动态共享内存分配锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>tbm</literal></entry>
         <entry>Waiting for TBM shared iterator lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>tbm</literal></entry>
         <entry>正等待TBM共享迭代器锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>parallel_append</literal></entry>
         <entry>Waiting to choose the next subplan during Parallel Append plan
         execution.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>parallel_append</literal></entry>
         <entry>在Parallel Append计划执行期间等待选择下一个子计划。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>parallel_hash_join</literal></entry>
         <entry>Waiting to allocate or exchange a chunk of memory or update
         counters during Parallel Hash plan execution.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>parallel_hash_join</literal></entry>
         <entry>在Parallel Hash计划执行期间等待分配或交换一块内存或者更新计数器。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="9"><literal>Lock</literal></entry>
         <entry><literal>relation</literal></entry>
         <entry>Waiting to acquire a lock on a relation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="9"><literal>Lock</literal></entry>
         <entry><literal>relation</literal></entry>
         <entry>正等待获得一个关系上的锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>extend</literal></entry>
         <entry>Waiting to extend a relation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>extend</literal></entry>
         <entry>正等待扩展一个关系。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>page</literal></entry>
         <entry>Waiting to acquire a lock on page of a relation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>page</literal></entry>
         <entry>正等待获得一个关系上的页面的锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>tuple</literal></entry>
         <entry>Waiting to acquire a lock on a tuple.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>tuple</literal></entry>
         <entry>正等待获得一个元组上的锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>transactionid</literal></entry>
         <entry>Waiting for a transaction to finish.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>transactionid</literal></entry>
         <entry>正等待一个事务结束。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>virtualxid</literal></entry>
         <entry>Waiting to acquire a virtual xid lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>virtualxid</literal></entry>
         <entry>正等待获得一个虚拟 xid 锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>speculative token</literal></entry>
         <entry>Waiting to acquire a speculative insertion lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>speculative token</literal></entry>
         <entry>正等待获取一个  speculative insertion lock。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>object</literal></entry>
         <entry>Waiting to acquire a lock on a non-relation database object.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>object</literal></entry>
         <entry>正等待获得一个非关系数据库对象上的锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>userlock</literal></entry>
         <entry>Waiting to acquire a user lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>userlock</literal></entry>
         <entry>正等待获得一个用户锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>advisory</literal></entry>
         <entry>Waiting to acquire an advisory user lock.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>advisory</literal></entry>
         <entry>正等待获得一个咨询用户锁。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BufferPin</literal></entry>
         <entry><literal>BufferPin</literal></entry>
         <entry>Waiting to acquire a pin on a buffer.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BufferPin</literal></entry>
         <entry><literal>BufferPin</literal></entry>
         <entry>正等待在一个缓冲区上加 pin。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="13"><literal>Activity</literal></entry>
         <entry><literal>ArchiverMain</literal></entry>
         <entry>Waiting in main loop of the archiver process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="13"><literal>Activity</literal></entry>
         <entry><literal>ArchiverMain</literal></entry>
         <entry>正在归档进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>AutoVacuumMain</literal></entry>
         <entry>Waiting in main loop of autovacuum launcher process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>AutoVacuumMain</literal></entry>
         <entry>正在autovacuum启动器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BgWriterHibernate</literal></entry>
         <entry>Waiting in background writer process, hibernating.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BgWriterHibernate</literal></entry>
         <entry>正在后台写入器进程中等待，休眠中。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BgWriterMain</literal></entry>
         <entry>Waiting in main loop of background writer process background worker.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BgWriterMain</literal></entry>
         <entry>正在后台写入器进程的后台工作者的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CheckpointerMain</literal></entry>
         <entry>Waiting in main loop of checkpointer process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CheckpointerMain</literal></entry>
         <entry>正在检查点进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalApplyMain</literal></entry>
         <entry>Waiting in main loop of logical apply process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalApplyMain</literal></entry>
         <entry>正在逻辑应用进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalLauncherMain</literal></entry>
         <entry>Waiting in main loop of logical launcher process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalLauncherMain</literal></entry>
         <entry>正在逻辑启动器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PgStatMain</literal></entry>
         <entry>Waiting in main loop of the statistics collector process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PgStatMain</literal></entry>
         <entry>正在统计收集器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RecoveryWalAll</literal></entry>
         <entry>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RecoveryWalAll</literal></entry>
         <entry>在恢复时等待来自于任意类型来源（本地、归档或流）的WAL。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RecoveryWalStream</literal></entry>
         <entry>Waiting for WAL from a stream at recovery.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RecoveryWalStream</literal></entry>
         <entry>在恢复时等待来自于一个流的WAL。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SysLoggerMain</literal></entry>
         <entry>Waiting in main loop of syslogger process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SysLoggerMain</literal></entry>
         <entry>正在系统日志进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalReceiverMain</literal></entry>
         <entry>Waiting in main loop of WAL receiver process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalReceiverMain</literal></entry>
         <entry>正在WAL接收器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalSenderMain</literal></entry>
         <entry>Waiting in main loop of WAL sender process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalSenderMain</literal></entry>
         <entry>正在WAL发送器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalWriterMain</literal></entry>
         <entry>Waiting in main loop of WAL writer process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalWriterMain</literal></entry>
         <entry>正在WAL写入器进程的主循环中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="7"><literal>Client</literal></entry>
         <entry><literal>ClientRead</literal></entry>
         <entry>Waiting to read data from the client.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="7"><literal>Client</literal></entry>
         <entry><literal>ClientRead</literal></entry>
         <entry>正等待从客户端读取数据。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ClientWrite</literal></entry>
         <entry>Waiting to write data to the client.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ClientWrite</literal></entry>
         <entry>正等待向客户端写入数据。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LibPQWalReceiverConnect</literal></entry>
         <entry>Waiting in WAL receiver to establish connection to remote server.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LibPQWalReceiverConnect</literal></entry>
         <entry>正在WAL接收器中等待建立与远程服务器的连接。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LibPQWalReceiverReceive</literal></entry>
         <entry>Waiting in WAL receiver to receive data from remote server.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LibPQWalReceiverReceive</literal></entry>
         <entry>正在WAL接收器中等待从远程服务器接收数据。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SSLOpenServer</literal></entry>
         <entry>Waiting for SSL while attempting connection.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SSLOpenServer</literal></entry>
         <entry>正在尝试连接期间等待SSL。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalReceiverWaitStart</literal></entry>
         <entry>Waiting for startup process to send initial data for streaming replication.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalReceiverWaitStart</literal></entry>
         <entry>正等待startup进程发送流复制的初始数据。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalSenderWaitForWAL</literal></entry>
         <entry>Waiting for WAL to be flushed in WAL sender process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalSenderWaitForWAL</literal></entry>
         <entry>正在WAL发送器进程中等待WAL被刷写。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WalSenderWriteData</literal></entry>
         <entry>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WalSenderWriteData</literal></entry>
         <entry>在WAL发送器进程中处理来自WAL接收器的回复时等待任意活动。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>Extension</literal></entry>
         <entry><literal>Extension</literal></entry>
         <entry>Waiting in an extension.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>Extension</literal></entry>
         <entry><literal>Extension</literal></entry>
         <entry>正在一个扩展中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="33"><literal>IPC</literal></entry>
         <entry><literal>BgWorkerShutdown</literal></entry>
         <entry>Waiting for background worker to shut down.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="33"><literal>IPC</literal></entry>
         <entry><literal>BgWorkerShutdown</literal></entry>
         <entry>正等待后台工作者关闭。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BgWorkerStartup</literal></entry>
         <entry>Waiting for background worker to start up.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BgWorkerStartup</literal></entry>
         <entry>正等待后台工作者启动。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BtreePage</literal></entry>
         <entry>Waiting for the page number needed to continue a parallel B-tree scan to become available.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BtreePage</literal></entry>
         <entry>正等待继续并行B-树扫描所需的页号变得可用。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ClogGroupUpdate</literal></entry>
         <entry>Waiting for group leader to update transaction status at transaction end.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ClogGroupUpdate</literal></entry>
         <entry>正等待组领袖在事务结束时更新事务状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ExecuteGather</literal></entry>
         <entry>Waiting for activity from child process when executing <literal>Gather</literal> node.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ExecuteGather</literal></entry>
         <entry>在执行<literal>Gather</literal>节点时等待来自子进程的活动。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Batch/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate a hash table.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Batch/Allocating</literal></entry>
          <entry>正等待一个选出的Parallel Hash参与者分配哈希表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Batch/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate a hash table.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Batch/Electing</literal></entry>
          <entry>正在选出一个Parallel Hash参与者来分配一个哈希表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Batch/Loading</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish loading a hash table.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Batch/Loading</literal></entry>
          <entry>正等待其他Parallel Hash参与者完成装载哈希表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Build/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Build/Allocating</literal></entry>
          <entry>正等待一个选出的Parallel Hash参与者分配初始哈希表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Build/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate the initial hash table.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Build/Electing</literal></entry>
          <entry>正在选出一个Parallel Hash参与者以分配初始哈希表。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Build/HashingInner</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish hashing the inner relation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Build/HashingInner</literal></entry>
          <entry>正等待其他Parallel Hash参与者完成对内关系的哈希操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/Build/HashingOuter</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/Build/HashingOuter</literal></entry>
          <entry>正等待其他Parallel Hash参与者完成对外关系的哈希操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBatches/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate more batches.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBatches/Allocating</literal></entry>
          <entry>正等待一个选出的Parallel Hash参与者分配更多批次。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBatches/Deciding</literal></entry>
          <entry>Electing a Parallel Hash participant to decide on future batch growth.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBatches/Deciding</literal></entry>
          <entry>正在选出一个Parallel Hash参与者决定未来的批次增长。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBatches/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate more batches.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBatches/Electing</literal></entry>
          <entry>正在选出一个Parallel Hash参与者分配更多批次。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBatches/Finishing</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to decide on future batch growth.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBatches/Finishing</literal></entry>
          <entry>正在等待一个选出的Parallel Hash参与者决定未来的批次增长。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBatches/Repartitioning</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finishing repartitioning.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBatches/Repartitioning</literal></entry>
          <entry>正等待其他Parallel Hash参与者完成重新分区。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBuckets/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBuckets/Allocating</literal></entry>
          <entry>正等待一个选出的Parallel Hash参与者完成更多桶的分配。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBuckets/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate more buckets.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBuckets/Electing</literal></entry>
          <entry>正在选出一个Parallel Hash参与者分配更多桶。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
          <entry><literal>Hash/GrowBuckets/Reinserting</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</entry>
        </row>
____________________________________________________________________________-->
        <row>
          <entry><literal>Hash/GrowBuckets/Reinserting</literal></entry>
          <entry>正等待其他Parallel Hash参与者完成将元组插入到新桶的操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalSyncData</literal></entry>
         <entry>Waiting for logical replication remote server to send data for initial table synchronization.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalSyncData</literal></entry>
         <entry>正等待逻辑复制的远程服务器发送用于初始表同步的数据。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalSyncStateChange</literal></entry>
         <entry>Waiting for logical replication remote server to change state.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalSyncStateChange</literal></entry>
         <entry>正等待逻辑复制的远程服务器更改状态。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MessageQueueInternal</literal></entry>
         <entry>Waiting for other process to be attached in shared message queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MessageQueueInternal</literal></entry>
         <entry>正等待其他进程被挂接到共享消息队列。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MessageQueuePutMessage</literal></entry>
         <entry>Waiting to write a protocol message to a shared message queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MessageQueuePutMessage</literal></entry>
         <entry>正等待把一个协议消息写到一个共享消息队列。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MessageQueueReceive</literal></entry>
         <entry>Waiting to receive bytes from a shared message queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MessageQueueReceive</literal></entry>
         <entry>正等待从一个共享消息队列接收字节。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MessageQueueSend</literal></entry>
         <entry>Waiting to send bytes to a shared message queue.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MessageQueueSend</literal></entry>
         <entry>正等待向一个共享消息队列中发送字节。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ParallelBitmapScan</literal></entry>
         <entry>Waiting for parallel bitmap scan to become initialized.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ParallelBitmapScan</literal></entry>
         <entry>正等待并行位图扫描被初始化。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ParallelCreateIndexScan</literal></entry>
         <entry>Waiting for parallel <command>CREATE INDEX</command> workers to finish heap scan.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ParallelCreateIndexScan</literal></entry>
         <entry>正等待并行<command>CREATE INDEX</command>工作者完成堆扫描。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ParallelFinish</literal></entry>
         <entry>Waiting for parallel workers to finish computing.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ParallelFinish</literal></entry>
         <entry>正等待并行工作者完成计算。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ProcArrayGroupUpdate</literal></entry>
         <entry>Waiting for group leader to clear transaction id at transaction end.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ProcArrayGroupUpdate</literal></entry>
         <entry>正等待组领袖在事务结束时清除事务ID。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationOriginDrop</literal></entry>
         <entry>Waiting for a replication origin to become inactive to be dropped.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationOriginDrop</literal></entry>
         <entry>正等待一个复制源头变得不活跃以便被删除。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotDrop</literal></entry>
         <entry>Waiting for a replication slot to become inactive to be dropped.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotDrop</literal></entry>
         <entry>正等待一个复制槽变得不活跃以便被删除。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SafeSnapshot</literal></entry>
         <entry>Waiting for a snapshot for a <literal>READ ONLY DEFERRABLE</literal> transaction.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SafeSnapshot</literal></entry>
         <entry>正等待一个用于<literal>READ ONLY DEFERRABLE</literal>事务的快照。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SyncRep</literal></entry>
         <entry>Waiting for confirmation from remote server during synchronous replication.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SyncRep</literal></entry>
         <entry>正在同步复制期间等待来自远程服务器的确认。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="2"><literal>Timeout</literal></entry>
         <entry><literal>BaseBackupThrottle</literal></entry>
         <entry>Waiting during base backup when throttling activity.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="2"><literal>Timeout</literal></entry>
         <entry><literal>BaseBackupThrottle</literal></entry>
         <entry>当有限流活动时在基础备份期间等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PgSleep</literal></entry>
         <entry>Waiting in process that called <function>pg_sleep</function>.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PgSleep</literal></entry>
         <entry>正在调用<function>pg_sleep</function>的进程中等待。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RecoveryApplyDelay</literal></entry>
         <entry>Waiting to apply WAL at recovery because it is delayed.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RecoveryApplyDelay</literal></entry>
         <entry>在恢复时等待应用WAL，因为它被延迟了。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry morerows="65"><literal>IO</literal></entry>
         <entry><literal>BufFileRead</literal></entry>
         <entry>Waiting for a read from a buffered file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry morerows="65"><literal>IO</literal></entry>
         <entry><literal>BufFileRead</literal></entry>
         <entry>正等待从一个缓存的文件中读取。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>BufFileWrite</literal></entry>
         <entry>Waiting for a write to a buffered file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>BufFileWrite</literal></entry>
         <entry>正等待向一个缓存的文件中写入。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileRead</literal></entry>
         <entry>Waiting for a read from the control file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileRead</literal></entry>
         <entry>正等待从控制文件中读取。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileSync</literal></entry>
         <entry>Waiting for the control file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileSync</literal></entry>
         <entry>正等待控制文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileSyncUpdate</literal></entry>
         <entry>Waiting for an update to the control file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileSyncUpdate</literal></entry>
         <entry>正等待对控制文件的更新到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileWrite</literal></entry>
         <entry>Waiting for a write to the control file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileWrite</literal></entry>
         <entry>正等待一个对控制文件的写入。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ControlFileWriteUpdate</literal></entry>
         <entry>Waiting for a write to update the control file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ControlFileWriteUpdate</literal></entry>
         <entry>正等待一个写操作更新控制文件。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CopyFileRead</literal></entry>
         <entry>Waiting for a read during a file copy operation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CopyFileRead</literal></entry>
         <entry>正在文件拷贝操作期间等待一个读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CopyFileWrite</literal></entry>
         <entry>Waiting for a write during a file copy operation.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CopyFileWrite</literal></entry>
         <entry>正在文件拷贝操作期间等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileExtend</literal></entry>
         <entry>Waiting for a relation data file to be extended.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileExtend</literal></entry>
         <entry>正等待一个关系数据文件被扩充。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileFlush</literal></entry>
         <entry>Waiting for a relation data file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileFlush</literal></entry>
         <entry>正等待一个关系数据文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileImmediateSync</literal></entry>
         <entry>Waiting for an immediate synchronization of a relation data file to stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileImmediateSync</literal></entry>
         <entry>正等待一个关系数据文件的立即同步到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFilePrefetch</literal></entry>
         <entry>Waiting for an asynchronous prefetch from a relation data file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFilePrefetch</literal></entry>
         <entry>正等待从一个关系数据文件中的一次异步预取。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileRead</literal></entry>
         <entry>Waiting for a read from a relation data file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileRead</literal></entry>
         <entry>正等待一次对一个关系数据文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileSync</literal></entry>
         <entry>Waiting for changes to a relation data file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileSync</literal></entry>
         <entry>正等待对一个关系数据文件的更改到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileTruncate</literal></entry>
         <entry>Waiting for a relation data file to be truncated.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileTruncate</literal></entry>
         <entry>正等待一个关系数据文件被截断。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DataFileWrite</literal></entry>
         <entry>Waiting for a write to a relation data file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DataFileWrite</literal></entry>
         <entry>正等待一次对一个关系数据文件的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>DSMFillZeroWrite</literal></entry>
         <entry>Waiting to write zero bytes to a dynamic shared memory backing file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>DSMFillZeroWrite</literal></entry>
         <entry>等待向一个动态共享内存备份文件中写零字节。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileAddToDataDirRead</literal></entry>
         <entry>Waiting for a read while adding a line to the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileAddToDataDirRead</literal></entry>
         <entry>在向数据目录锁文件中增加一行时等待一个读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileAddToDataDirSync</literal></entry>
         <entry>Waiting for data to reach stable storage while adding a line to the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileAddToDataDirSync</literal></entry>
         <entry>在向数据目录锁文件中增加一行时等待数据到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileAddToDataDirWrite</literal></entry>
         <entry>Waiting for a write while adding a line to the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileAddToDataDirWrite</literal></entry>
         <entry>在向数据目录锁文件中增加一行时等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileCreateRead</literal></entry>
         <entry>Waiting to read while creating the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileCreateRead</literal></entry>
         <entry>在创建数据目录锁文件期间等待读取。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileCreateSync</literal></entry>
         <entry>Waiting for data to reach stable storage while creating the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileCreateSync</literal></entry>
         <entry>在创建数据目录锁文件期间等待数据到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileCreateWrite</literal></entry>
         <entry>Waiting for a write while creating the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileCreateWrite</literal></entry>
         <entry>在创建数据目录锁文件期间等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LockFileReCheckDataDirRead</literal></entry>
         <entry>Waiting for a read during recheck of the data directory lock file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LockFileReCheckDataDirRead</literal></entry>
         <entry>在重新检查数据目录锁文件的过程中等待一个读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
         <entry>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
         <entry>在一个检查点期间等待逻辑重写映射到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRewriteMappingSync</literal></entry>
         <entry>Waiting for mapping data to reach stable storage during a logical rewrite.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRewriteMappingSync</literal></entry>
         <entry>在一次逻辑重写期间等待映射数据到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRewriteMappingWrite</literal></entry>
         <entry>Waiting for a write of mapping data during a logical rewrite.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRewriteMappingWrite</literal></entry>
         <entry>在一次逻辑重写期间等待对映射数据的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRewriteSync</literal></entry>
         <entry>Waiting for logical rewrite mappings to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRewriteSync</literal></entry>
         <entry>正等待逻辑重写映射到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>LogicalRewriteWrite</literal></entry>
         <entry>Waiting for a write of logical rewrite mappings.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>LogicalRewriteWrite</literal></entry>
         <entry>正等待对逻辑重写映射的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RelationMapRead</literal></entry>
         <entry>Waiting for a read of the relation map file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RelationMapRead</literal></entry>
         <entry>正等待对关系映射文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RelationMapSync</literal></entry>
         <entry>Waiting for the relation map file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RelationMapSync</literal></entry>
         <entry>正等待关系映射文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RelationMapWrite</literal></entry>
         <entry>Waiting for a write to the relation map file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RelationMapWrite</literal></entry>
         <entry>正等待对关系映射文件的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReorderBufferRead</literal></entry>
         <entry>Waiting for a read during reorder buffer management.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReorderBufferRead</literal></entry>
         <entry>在重排序缓冲区管理期间等待一个读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReorderBufferWrite</literal></entry>
         <entry>Waiting for a write during reorder buffer management.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReorderBufferWrite</literal></entry>
         <entry>在重排序缓冲区管理期间等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReorderLogicalMappingRead</literal></entry>
         <entry>Waiting for a read of a logical mapping during reorder buffer management.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReorderLogicalMappingRead</literal></entry>
         <entry>在重排序缓冲区管理期间等待对一个逻辑映射的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotRead</literal></entry>
         <entry>Waiting for a read from a replication slot control file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotRead</literal></entry>
         <entry>正等待对一个复制槽控制文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotRestoreSync</literal></entry>
         <entry>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotRestoreSync</literal></entry>
         <entry>在把一个复制槽控制文件恢复到内存的过程中等待它到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotSync</literal></entry>
         <entry>Waiting for a replication slot control file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotSync</literal></entry>
         <entry>正等待一个复制槽控制文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ReplicationSlotWrite</literal></entry>
         <entry>Waiting for a write to a replication slot control file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ReplicationSlotWrite</literal></entry>
         <entry>正等待对一个复制槽控制文件的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SLRUFlushSync</literal></entry>
         <entry>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SLRUFlushSync</literal></entry>
         <entry>在检查点或者数据库关闭期间等待SLRU数据到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SLRURead</literal></entry>
         <entry>Waiting for a read of an SLRU page.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SLRURead</literal></entry>
         <entry>正等待对一个SLRU页面的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SLRUSync</literal></entry>
         <entry>Waiting for SLRU data to reach stable storage following a page write.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SLRUSync</literal></entry>
         <entry>正等待SLRU数据在一个页面写之后到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SLRUWrite</literal></entry>
         <entry>Waiting for a write of an SLRU page.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SLRUWrite</literal></entry>
         <entry>正等待一个SLRU页面上的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SnapbuildRead</literal></entry>
         <entry>Waiting for a read of a serialized historical catalog snapshot.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SnapbuildRead</literal></entry>
         <entry>正等待一个序列化历史目录快照的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SnapbuildSync</literal></entry>
         <entry>Waiting for a serialized historical catalog snapshot to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SnapbuildSync</literal></entry>
         <entry>正等待一个序列化历史目录快照到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SnapbuildWrite</literal></entry>
         <entry>Waiting for a write of a serialized historical catalog snapshot.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SnapbuildWrite</literal></entry>
         <entry>正等待一个序列化历史目录快照的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TimelineHistoryFileSync</literal></entry>
         <entry>Waiting for a timeline history file received via streaming replication to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TimelineHistoryFileSync</literal></entry>
         <entry>正等待一个通过流复制接收到的时间线历史文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TimelineHistoryFileWrite</literal></entry>
         <entry>Waiting for a write of a timeline history file received via streaming replication.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TimelineHistoryFileWrite</literal></entry>
         <entry>正等待一个通过流复制接收到的时间线历史文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TimelineHistoryRead</literal></entry>
         <entry>Waiting for a read of a timeline history file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TimelineHistoryRead</literal></entry>
         <entry>正等待一个时间线历史文件上的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TimelineHistorySync</literal></entry>
         <entry>Waiting for a newly created timeline history file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TimelineHistorySync</literal></entry>
         <entry>正等待一个新创建的时间线历史文件达到稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TimelineHistoryWrite</literal></entry>
         <entry>Waiting for a write of a newly created timeline history file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TimelineHistoryWrite</literal></entry>
         <entry>正等待一个新创建的时间线历史文件上的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TwophaseFileRead</literal></entry>
         <entry>Waiting for a read of a two phase state file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TwophaseFileRead</literal></entry>
         <entry>正等待一个两阶段状态文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TwophaseFileSync</literal></entry>
         <entry>Waiting for a two phase state file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TwophaseFileSync</literal></entry>
         <entry>正等待一个两阶段状态文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TwophaseFileWrite</literal></entry>
         <entry>Waiting for a write of a two phase state file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TwophaseFileWrite</literal></entry>
         <entry>正等待一个两阶段状态文件的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALBootstrapSync</literal></entry>
         <entry>Waiting for WAL to reach stable storage during bootstrapping.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALBootstrapSync</literal></entry>
         <entry>在自举期间等待WAL到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALBootstrapWrite</literal></entry>
         <entry>Waiting for a write of a WAL page during bootstrapping.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALBootstrapWrite</literal></entry>
         <entry>在自举期间等待一个WAL页面的写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALCopyRead</literal></entry>
         <entry>Waiting for a read when creating a new WAL segment by copying an existing one.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALCopyRead</literal></entry>
         <entry>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALCopySync</literal></entry>
         <entry>Waiting a new WAL segment created by copying an existing one to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALCopySync</literal></entry>
         <entry>正等待一个通过拷贝已有WAL段创建的新WAL段到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALCopyWrite</literal></entry>
         <entry>Waiting for a write when creating a new WAL segment by copying an existing one.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALCopyWrite</literal></entry>
         <entry>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALInitSync</literal></entry>
         <entry>Waiting for a newly initialized WAL file to reach stable storage.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALInitSync</literal></entry>
         <entry>正等待一个新初始化的WAL文件到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALInitWrite</literal></entry>
         <entry>Waiting for a write while initializing a new WAL file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALInitWrite</literal></entry>
         <entry>在初始化一个新的WAL文件期间等待一个写操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALRead</literal></entry>
         <entry>Waiting for a read from a WAL file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALRead</literal></entry>
         <entry>正等待一次对一个WAL文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
         <entry>Waiting for a read from a timeline history file during walsender timeline command.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
         <entry>在walsender的时间线命令期间等待对一个时间线历史文件的读操作。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALSyncMethodAssign</literal></entry>
         <entry>Waiting for data to reach stable storage while assigning WAL sync method.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALSyncMethodAssign</literal></entry>
         <entry>在指派WAL同步方法时等待数据到达稳定存储。</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>WALWrite</literal></entry>
         <entry>Waiting for a write to a WAL file.</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>WALWrite</literal></entry>
         <entry>正等待一次对一个WAL文件的写操作。</entry>
        </row>
      </tbody>
     </tgroup>
    </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     For tranches registered by extensions, the name is specified by extension
     and this will be displayed as <structfield>wait_event</structfield>.  It is quite
     possible that user has registered the tranche in one of the backends (by
     having allocation in dynamic shared memory) in which case other backends
     won't have that information, so we display <literal>extension</literal> for such
     cases.
    </para>
____________________________________________________________________________-->
    <para>
     对于扩展安装的切片（tranche），这个名称由扩展指定并且会被<structfield>wait_event</structfield>显示出来。很有可能在其他后端不知道的情况下，用户在其中一个后端中注册了切片（通过在动态共享内存中分配），那么我们对这种情况会显示<literal>extension</literal>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
     Here is an example of how wait events can be viewed

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
     下面的例子展示了如何查看等待事件

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)
</programlisting>
   </para>
  
  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_replication</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_replication</structname> 视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of a WAL sender process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>一个 WAL 发送进程的进程 ID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the user logged into this WAL sender process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>登录到这个 WAL 发送进程的用户的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the user logged into this WAL sender process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>登录到这个 WAL 发送进程的用户的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the application that is connected
      to this WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>连接到这个 WAL 发送进程的应用的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>IP address of the client connected to this WAL sender.
      If this field is null, it indicates that the client is
      connected via a Unix socket on the server machine.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>连接到这个 WAL 发送进程的客户端的 IP 地址。
     如果这个域为空，它表示该客户端通过服务器机器上的一个
     Unix 套接字连接。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</structfield>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"/> is enabled.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>连接上的客户端的主机名，由一次对<structfield>client_addr</structfield>
     的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在
     <xref linkend="guc-log-hostname"/>被启用时非空
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>TCP port number that the client is using for communication
      with this WAL sender, or <literal>-1</literal> if a Unix socket is used
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，
     如果使用 Unix 套接字则为<literal>-1</literal>
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process was started, i.e., when the
      client connected to this WAL sender
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>这个进程开始的时间，即客户端是何时连接到这个
     WAL 发送进程的
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>This standby's <literal>xmin</literal> horizon reported
     by <xref linkend="guc-hot-standby-feedback"/>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>由<xref linkend="guc-hot-standby-feedback"/>报告
     的这个后备机的<literal>xmin</literal>水平线。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Current WAL sender state.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>startup</literal>: This WAL sender is starting up.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>catchup</literal>: This WAL sender's connected standby is
           catching up with the primary.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>streaming</literal>: This WAL sender is streaming changes
           after its connected standby server has caught up with the primary.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>backup</literal>: This WAL sender is sending a backup.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>stopping</literal>: This WAL sender is stopping.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>当前的 WAL 发送进程状态。
       可能的值是：
       <itemizedlist>
         <listitem>
          <para>
           <literal>startup</literal>：这个WAL发送器正在启动。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>catchup</literal>：这个WAL发送器连接的后备机正在追赶主服务器。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>streaming</literal>：这个WAL发送器在它连接的后备服务器追上主服务器之后用流传送更改。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>backup</literal>：这个WAL发送器正在发送一个备份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>stopping</literal>：这个WAL发送器正在停止。
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sent_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location sent on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sent_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>在这个连接上发送的最后一个预写式日志的位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>write_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location written to disk by this standby
      server</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>write_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>被这个后备服务器写入到磁盘的最后一个预写式日志的位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>flush_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location flushed to disk by this standby
      server</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>flush_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>被这个后备服务器刷入到磁盘的最后一个预写式日志的位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>replay_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location replayed into the database on this
      standby server</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>replay_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>write_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written it (but not yet
      flushed it or applied it).  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>remote_write</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>write_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>在本地刷写近期的WAL与接收到后备服务器已经写入它（但还没有刷写或者应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>remote_write</literal>所导致的延迟。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>flush_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written and flushed it
      (but not yet applied it).  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>on</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>flush_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>on</literal>所导致的延迟。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>replay_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written, flushed and
      applied it.  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>remote_apply</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>replay_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>remote_apply</literal>所导致的延迟。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sync_priority</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Priority of this standby server for being chosen as the
      synchronous standby in a priority-based synchronous replication.
      This has no effect in a quorum-based synchronous replication.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sync_priority</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sync_state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Synchronous state of this standby server.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>async</literal>: This standby server is asynchronous.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>potential</literal>: This standby server is now asynchronous,
           but can potentially become synchronous if one of current
           synchronous ones fails.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>sync</literal>: This standby server is synchronous.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>quorum</literal>: This standby server is considered as a candidate
           for quorum standbys.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sync_state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>这一台后备服务器的同步状态。
       可能的值是：
       <itemizedlist>
         <listitem>
          <para>
           <literal>async</literal>：这台后备服务器是异步的。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>potential</literal>：这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>sync</literal>：这台后备服务器是同步的。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>quorum</literal>：这台后备服务器被当做规定数量后备服务器的候选。
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_replication</structname>视图中将为每一个 WAL
   发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。
   这个视图中只会列出直接连接的后备机，下游后备服务器的信息不包含在此。
  </para>

<!--==========================orignal english content==========================
  <para>
   The lag times reported in the <structname>pg_stat_replication</structname>
   view are measurements of the time taken for recent WAL to be written,
   flushed and replayed and for the sender to know about it.  These times
   represent the commit delay that was (or would have been) introduced by each
   synchronous commit level, if the remote server was configured as a
   synchronous standby.  For an asynchronous standby, the
   <structfield>replay_lag</structfield> column approximates the delay
   before recent transactions became visible to queries.  If the standby
   server has entirely caught up with the sending server and there is no more
   WAL activity, the most recently measured lag times will continue to be
   displayed for a short time and then show NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_replication</structname>视图中报告的滞后时间近期的WAL被写入、刷写并且重放以及发送器知道这一切所花的时间的度量。如果远程服务器被配置为一台同步后备，这些时间表示由每一种同步提交级别所带来（或者是可能带来）的提交延迟。对于一台异步后备，<structfield>replay_lag</structfield>列是最近的事务变得对查询可见的延迟时间的近似值。如果后备服务器已经完全追上了发送服务器并且没有WAL活动，在短时间内将继续显示最近测到的滞后时间，再然后就会显示为NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   Lag times work automatically for physical replication. Logical decoding
   plugins may optionally emit tracking messages; if they do not, the tracking
   mechanism will simply display NULL lag.
  </para>
____________________________________________________________________________-->
  <para>
   对于物理复制会自动测量滞后时间。逻辑解码插件可能会选择性地发出跟踪消息，如果它们没有这样做，跟踪机制将把滞后显示为NULL。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The reported lag times are not predictions of how long it will take for
    the standby to catch up with the sending server assuming the current
    rate of replay.  Such a system would show similar times while new WAL is
    being generated, but would differ when the sender becomes idle.  In
    particular, when the standby has caught up completely,
    <structname>pg_stat_replication</structname> shows the time taken to
    write, flush and replay the most recent reported WAL location rather than
    zero as some users might expect.  This is consistent with the goal of
    measuring synchronous commit and transaction visibility delays for
    recent write transactions.
    To reduce confusion for users expecting a different model of lag, the
    lag columns revert to NULL after a short time on a fully replayed idle
    system. Monitoring systems should choose whether to represent this
    as missing data, zero or continue to display the last known value.
   </para>
____________________________________________________________________________-->
   <para>
    报告的滞后时间并非按照当前的重放速率该后备还有多久才能追上发送服务器的预测。在新的WAL被生成期间，这样一种系统将显示类似的时间，但是当发送器变为闲置时会显示不同的值。特别是当后备服务器完全追上时，<structname>pg_stat_replication</structname>显示的是写入、刷写及重放最近报告的WAL位置所花的时间而不是一些用户可能预期的零。这种做法与为近期的写事务测量同步提交和事务可见性延迟的目的一致。为了降低用户预期一种不同的滞后模型带来的混淆，在一个完全重放完的闲置系统上，lag列会在一段比较短的时间后回复成NULL。监控系统应该选择将这种情况表示为缺失数据、零或者继续显示最近的已知值。
   </para>
  </note>
  
  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_wal_receiver</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_wal_receiver</structname> 视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of the WAL receiver process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>WAL 接收器进程的进程 ID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>status</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Activity status of the WAL receiver process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>status</structfield></entry>
     <entry><type>text</type></entry>
     <entry>WAL 接收器进程的活动状态</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>receive_start_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>First write-ahead log location used when WAL receiver is
      started</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>receive_start_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>WAL 接收器启动时使用的第一个预写式日志位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>receive_start_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>First timeline number used when WAL receiver is started</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>receive_start_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>WAL 接收器启动时使用的第一个时间线编号</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location already received and flushed to
      disk, the initial value of this field being the first log location used
      when WAL receiver is started</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>已经接收到并且已经被杀入磁盘的最后一个预写式日志的位置，这个域的初始值是 WAL 接收器启动时使用的第一个日志位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>received_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Timeline number of last write-ahead log location received and
      flushed to disk, the initial value of this field being the timeline
      number of the first log location used when WAL receiver is started
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>received_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>已经接收到并且已经被杀入磁盘的最后一个预写式日志的时间线编号，这个域的初始值是 WAL 接收器启动时使用的第一个日志所在的时间线编号
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Send time of last message received from origin WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>从源头 WAL 发送器接收到的最后一个消息的发送时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Receipt time of last message received from origin WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>从源头 WAL 发送器接收到的最后一个消息的接收时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location reported to origin WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>报告给源头 WAL 发送器的最后一个预写式日志位置</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time of last write-ahead log location reported to origin WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>报告给源头 WAL 发送器最后一个事务日志位置的时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>slot_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Replication slot name used by this WAL receiver</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>slot_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>这个 WAL 接收器使用的复制槽的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sender_host</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Host of the <productname>PostgreSQL</productname> instance
      this WAL receiver is connected to. This can be a host name,
      an IP address, or a directory path if the connection is via
      Unix socket.  (The path case can be distinguished because it
      will always be an absolute path, beginning with <literal>/</literal>.)
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sender_host</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      这个WAL接收器连接到的<productname>PostgreSQL</productname>实例的主机。这可以是一个主机名、一个IP地址，如果连接是通过Unix套接字则是一个目录路径（为目录的情况可以被辨别出来，因为路径将总是一个绝对路径并且以<literal>/</literal>开头）。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sender_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>
      Port number of the <productname>PostgreSQL</productname> instance
      this WAL receiver is connected to.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sender_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>
      这个WAL接收器连接到的<productname>PostgreSQL</productname>实例的端口号。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>conninfo</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Connection string used by this WAL receiver,
      with security-sensitive fields obfuscated.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>conninfo</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      这个 WAL 接收器使用的连接串，安全相关的域会被隐去。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_wal_receiver</structname> view will contain only
   one row, showing statistics about the WAL receiver from that receiver's
   connected server.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_wal_receiver</structname>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </para>

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_subscription</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_subscription</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>介绍</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>subid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the subscription</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>subid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>订阅的OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>subname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the subscription</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>subname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>订阅的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of the subscription worker process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>订阅工作者进程的进程ID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>Oid</type></entry>
     <entry>OID of the relation that the worker is synchronizing; null for the
     main apply worker</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>Oid</type></entry>
     <entry>工作者正在同步的关系的OID，对于主应用工作者为空</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location received, the initial value of
      this field being 0</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>接收到的最后一个预写式日志位置，这个字段的初始值是0</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Send time of last message received from origin WAL sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>从源头WAL发送器接收到的最后一个消息的发送时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Receipt time of last message received from origin WAL sender
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>从源头WAL发送器接收到的最后一个消息的接收时间
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location reported to origin WAL sender
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>最后一个报告给源头WAL发送器的预写式日志位置
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time of last write-ahead log location reported to origin WAL
      sender</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>报告给源头WAL发送器的最后一个预写式日志位置的时间</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_subscription</structname> view will contain one
   row per subscription for main worker (with null PID if the worker is
   not running), and additional rows for workers handling the initial data
   copy of the subscribed tables.
  </para>
____________________________________________________________________________-->
  <para>
   每一个订阅的主工作者都在<structname>pg_stat_subscription</structname>视图中有一行（如果工作者没有运行则PID为空），处理被订阅表的初始数据拷贝操作的工作者还会有额外的行。
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_ssl</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_ssl</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of a backend or WAL sender process</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>一个后端或者 WAL 发送进程的进程 ID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>ssl</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if SSL is used on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>ssl</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>如果在这个连接上使用了 SSL 则为真</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>version</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Version of SSL in use, or NULL if SSL is not in use
      on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>version</structfield></entry>
     <entry><type>text</type></entry>
     <entry>在用的 SSL 版本，如果这个连接上没有使用 SSL 则为 NULL</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>cipher</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of SSL cipher in use, or NULL if SSL is not in use
      on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>cipher</structfield></entry>
     <entry><type>text</type></entry>
     <entry>在用的 SSL 密码的名称，如果这个连接上没有使用 SSL 则为 NULL</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>bits</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Number of bits in the encryption algorithm used, or NULL
     if SSL is not used on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>bits</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>使用的加密算法中的位数，如果这个连接上没有使用 SSL 则为 NULL</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>compression</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if SSL compression is in use, false if not,
      or NULL if SSL is not in use on this connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>compression</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>如果使用了 SSL 压缩则为真，否则为假，
     如果这个连接上没有使用 SSL 则为 NULL</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>clientdn</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Distinguished Name (DN) field from the client certificate
      used, or NULL if no client certificate was supplied or if SSL
      is not in use on this connection. This field is truncated if the
      DN field is longer than <symbol>NAMEDATALEN</symbol> (64 characters
      in a standard build)
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>clientdn</structfield></entry>
     <entry><type>text</type></entry>
     <entry>来自所使用的客户端证书的识别名（DN）域，
     如果没有提供客户端证书或者这个连接上没有使用 SSL 
     则为 NULL。如果 DN 域长度超过
     <symbol>NAMEDATALEN</symbol>（标准编译
     中是 64 个字符），则它会被截断。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_ssl</structname> view will contain one row per
   backend or WAL sender process, showing statistics about SSL usage on
   this connection. It can be joined to <structname>pg_stat_activity</structname>
   or <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_ssl</structname>视图将为每一个后端或者 WAL 发送进程
   包含一行，用来显示这个连接上的 SSL 使用情况。可以把它与
   <structname>pg_stat_activity</structname>或者
   <structname>pg_stat_replication</structname>通过
   <structfield>pid</structfield>列连接来得到更多有关该连接的细节。
  </para>
  
  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_archiver</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_archiver</structname>视图</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>archived_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of WAL files that have been successfully archived</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>archived_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>已被成功归档的 WAL 文件数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>last_archived_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of the last WAL file successfully archived</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>last_archived_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>最后一个被成功归档的 WAL 文件名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>last_archived_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time of the last successful archive operation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>last_archived_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最后一次成功归档操作的时间</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>failed_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of failed attempts for archiving WAL files</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>failed_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>失败的归档 WAL 文件尝试的数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>last_failed_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of the WAL file of the last failed archival operation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>last_failed_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>最后一次失败的归档操作的 WAL 文件名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>last_failed_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time of the last failed archival operation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>last_failed_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最后一次失败的归档操作的时间</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time at which these statistics were last reset</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这些统计信息最后一次被重置的时间</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_archiver</structname> view will always have a
   single row, containing data about the archiver process of the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   The <structname>pg_stat_archiver</structname>视图将总是一个单一的行，
   该行包含着有关集簇的归档进程的数据。
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_bgwriter</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_bgwriter</structname>视图</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>checkpoints_timed</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of scheduled checkpoints that have been performed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>checkpoints_timed</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>已经被执行的计划中检查点的数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>checkpoints_req</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of requested checkpoints that have been performed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>checkpoints_req</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>已经被执行的请求检查点的数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>checkpoint_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are written to disk, in milliseconds
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>checkpoint_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>checkpoint_sync_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are synchronized to disk, in
        milliseconds
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>checkpoint_sync_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>buffers_checkpoint</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written during checkpoints</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>buffers_checkpoint</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>在检查点期间被写的缓冲区数目</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>buffers_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written by the background writer</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>buffers_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>被后台写进程写的缓冲区数目</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>maxwritten_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of times the background writer stopped a cleaning
       scan because it had written too many buffers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>maxwritten_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>buffers_backend</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written directly by a backend</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>buffers_backend</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>被一个后端直接写的缓冲区数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>buffers_backend_fsync</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of times a backend had to execute its own
       <function>fsync</function> call (normally the background writer handles those
       even when the backend does its own write)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>buffers_backend_fsync</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>一个后端不得不自己执行<function>fsync</function>调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>buffers_alloc</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers allocated</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>buffers_alloc</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>被分配的缓冲区数量</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time at which these statistics were last reset</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这些统计信息上次被重置的时间</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_bgwriter</structname> view will always have a
   single row, containing global data for the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_bgwriter</structname>视图将总是只有单独的一行，它包含集簇的全局数据。
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_database</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_database</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个数据库的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个数据库的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>numbackends</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Number of backends currently connected to this database.
     This is the only column in this view that returns a value reflecting
     current state; all other columns return the accumulated values since
     the last reset.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>numbackends</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>xact_commit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of transactions in this database that have been
      committed</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>xact_commit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中已经被提交的事务的数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>xact_rollback</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of transactions in this database that have been
      rolled back</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>xact_rollback</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中已经被回滚的事务的数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被读取的磁盘块的数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times disk blocks were found already in the buffer
      cache, so that a read was not necessary (this only includes hits in the
      PostgreSQL buffer cache, not the operating system's file system cache)
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tup_returned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows returned by queries in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tup_returned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询返回的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tup_fetched</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows fetched by queries in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tup_fetched</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询取出的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tup_inserted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows inserted by queries in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tup_inserted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询插入的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tup_updated</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows updated by queries in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tup_updated</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询更新的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tup_deleted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows deleted by queries in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tup_deleted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询删除的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>conflicts</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries canceled due to conflicts with recovery
      in this database. (Conflicts occur only on standby servers; see
      <xref linkend="pg-stat-database-conflicts-view"/> for details.)
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>conflicts</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见<xref linkend="pg-stat-database-conflicts-view"/>）。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>temp_files</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of temporary files created by queries in this database.
      All temporary files are counted, regardless of why the temporary file
      was created (e.g., sorting or hashing), and regardless of the
      <xref linkend="guc-log-temp-files"/> setting.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>temp_files</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files"/>设置。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>temp_bytes</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Total amount of data written to temporary files by queries in
      this database. All temporary files are counted, regardless of why
      the temporary file was created, and
      regardless of the <xref linkend="guc-log-temp-files"/> setting.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>temp_bytes</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files"/>设置。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>deadlocks</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of deadlocks detected in this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>deadlocks</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个数据库中被检测到的死锁数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blk_read_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Time spent reading data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blk_read_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blk_write_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Time spent writing data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blk_write_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>stats_reset</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time at which these statistics were last reset</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>stats_reset</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>这些统计信息上次被重置的时间</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, showing database-wide statistics.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_database</structname>视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。
  </para>
  
  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_database_conflicts</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_database_conflicts</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个数据库的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this database</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个数据库的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>confl_tablespace</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      dropped tablespaces</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>confl_tablespace</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个数据库中由于表空间被删掉而取消的查询数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>confl_lock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      lock timeouts</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>confl_lock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个数据库中由于锁超时而取消的查询数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>confl_snapshot</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      old snapshots</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>confl_snapshot</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个数据库中由于旧快照而取消的查询数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>confl_bufferpin</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      pinned buffers</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>confl_bufferpin</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个数据库中由于被占用的缓冲区而取消的查询数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>confl_deadlock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      deadlocks</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>confl_deadlock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个数据库中由于死锁而取消的查询数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on master servers.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_database_conflicts</structname>视图为每一个
   数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程
   冲突而被取消的查询的统计信息。 这个视图将只包含后备服务器上的信息，
   因为冲突会不发生在主服务器上。
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_all_tables</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个表的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个表所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个表的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>seq_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of sequential scans initiated on this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>seq_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表上发起的顺序扫描的次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>seq_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live rows fetched by sequential scans</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>seq_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被顺序扫描取得的活着的行的数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index scans initiated on this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表上发起的索引扫描的次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live rows fetched by index scans</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被索引扫描取得的活着的行的数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_tup_ins</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows inserted</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_tup_ins</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被插入的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_tup_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows updated (includes HOT updated rows)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_tup_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被更新的行数（包括 HOT 更新的行）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_tup_del</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows deleted</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_tup_del</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被删除的行数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_tup_hot_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows HOT updated (i.e., with no separate index
      update required)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_tup_hot_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被更新的 HOT 行数（即不要求独立索引更新的行更新）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_live_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Estimated number of live rows</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_live_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>活着的行的估计数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_dead_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Estimated number of dead rows</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_dead_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>死亡行的估计数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>n_mod_since_analyze</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Estimated number of rows modified since this table was last analyzed</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>n_mod_since_analyze</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个表最后一次被分析后备修改的行的估计数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_vacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was manually vacuumed
      (not counting <command>VACUUM FULL</command>)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_vacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>上次这个表被手动清理的时间（不统计<command>VACUUM FULL</command>）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_autovacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was vacuumed by the autovacuum
      daemon</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_autovacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>上次这个表被自动清理守护进程清理的时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_analyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was manually analyzed</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_analyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>上次这个表被手动分析的时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>last_autoanalyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was analyzed by the autovacuum
      daemon</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>last_autoanalyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>上次这个表被自动清理守护进程分析的时间</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been manually vacuumed
      (not counting <command>VACUUM FULL</command>)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个表已被手工清理的次数（不统计<command>VACUUM FULL</command>）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>autovacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been vacuumed by the autovacuum
      daemon</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>autovacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个表已被自动清理守护进程清理的次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>analyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been manually analyzed</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>analyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个表已被手工分析的次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>autoanalyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been analyzed by the autovacuum
      daemon</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>autoanalyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个表已被自动清理守护进程分析的次数</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_all_tables</structname>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。<structname>pg_stat_user_tables</structname>和<structname>pg_stat_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_all_indexes</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table for this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个索引的基表的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个索引的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the table for this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引的基表的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index scans initiated on this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个索引上发起的索引扫描次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index entries returned by scans on this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个索引上由扫描返回的索引项数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live table rows fetched by simple index scans using this
      index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>被使用这个索引的简单索引扫描取得的活着的表行数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<structname>pg_stat_user_indexes</structname>和<structname>pg_stat_sys_indexes</structname>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Indexes can be used by simple index scans, <quote>bitmap</quote> index scans,
   and the optimizer.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
   The optimizer also accesses indexes to check for supplied constants
   whose values are outside the recorded range of the optimizer statistics
   because the optimizer statistics might be stale.
  </para>
____________________________________________________________________________-->
  <para>
   索引可以被简单索引扫描、<quote>位图</quote>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>计数，并且为每个表增加<structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>计数，但是它不影响<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <structfield>idx_tup_read</structfield> and <structfield>idx_tup_fetch</structfield> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</structfield> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</structfield>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
____________________________________________________________________________-->
   <para>
    即使不用位图扫描，<structfield>idx_tup_read</structfield>和<structfield>idx_tup_fetch</structfield>计数也可能不同，因为<structfield>idx_tup_read</structfield>统计从该索引取得的索引项而<structfield>idx_tup_fetch</structfield>统计从表取得的或者的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_tables</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个表的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个表所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个表的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>heap_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>heap_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个表读取的磁盘块数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>heap_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>heap_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表中的缓冲区命中数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from all indexes on this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个表上所有索引中读取的磁盘块数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in all indexes on this table</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表上的所有索引中的缓冲区命中数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>toast_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table's TOAST table (if any)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>toast_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个表的 TOAST 表（如果有）读取的磁盘块数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>toast_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table's TOAST table (if any)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>toast_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tidx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table's TOAST table indexes (if any)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tidx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>tidx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table's TOAST table indexes (if any)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>tidx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_tables</structname>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<structname>pg_statio_user_tables</structname>和<structname>pg_statio_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_indexes</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table for this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个索引的基表的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个索引的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the table for this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引的基表的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个索引的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个索引读取的磁盘块数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this index</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个索引中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。<structname>pg_statio_user_indexes</structname>和<structname>pg_statio_sys_indexes</structname>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_sequences</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_sequences</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a sequence</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个序列的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this sequence is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个序列所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this sequence</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个序列的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this sequence</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>从这个序列中读取的磁盘块数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this sequence</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>在这个序列中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_sequences</structname>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_user_functions</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_user_functions</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>funcid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a function</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>funcid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>一个函数的 OID</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this function is in</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个函数所在的模式的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>funcname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this function</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>funcname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个函数的名称</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>calls</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this function has been called</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>calls</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>这个函数已经被调用的次数</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>total_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Total time spent in this function and all other functions
     called by it, in milliseconds</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>total_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>self_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Total time spent in this function itself, not including
     other functions called by it, in milliseconds</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>self_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"/> parameter
   controls exactly which functions are tracked.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_user_functions</structname>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。<xref linkend="guc-track-functions"/>参数控制到底哪些函数被跟踪。
  </para>
 </sect2>

 <sect2 id="monitoring-stats-functions">
<!--==========================orignal english content==========================
  <title>Statistics Functions</title>
____________________________________________________________________________-->
  <title>统计函数</title>

<!--==========================orignal english content==========================
  <para>
   Other ways of looking at the statistics can be set up by writing
   queries that use the same underlying statistics access functions used by
   the standard views shown above.  For details such as the functions' names,
   consult the definitions of the standard views.  (For example, in
   <application>psql</application> you could issue <literal>\d+ pg_stat_activity</literal>.)
   The access functions for per-database statistics take a database OID as an
   argument to identify which database to report on.
   The per-table and per-index functions take a table or index OID.
   The functions for per-function statistics take a function OID.
   Note that only tables, indexes, and functions in the current database
   can be seen with these functions.
  </para>
____________________________________________________________________________-->
  <para>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。如要了解如函数名等细节，可参考标准视图的定义（例如，在<application>psql</application>中你可以发出<literal>\d+ pg_stat_activity</literal>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </para>

<!--==========================orignal english content==========================
  <para>
   Additional functions related to statistics collection are listed in <xref
   linkend="monitoring-stats-funcs-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   与统计收集相关的额外函数被列举在<xref linkend="monitoring-stats-funcs-table"/>中。
  </para>

  <table id="monitoring-stats-funcs-table">
<!--==========================orignal english content==========================
   <title>Additional Statistics Functions</title>
____________________________________________________________________________-->
   <title>额外统计函数</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
       <!-&minus; See also the entry for this in func.sgml -&minus;>
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Process ID of the server process handling the current session
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       处理当前会话的服务器进程的进程 ID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Returns a record of information about the backend with the specified PID, or
       one record for each active backend in the system if <symbol>NULL</symbol> is
       specified. The fields returned are a subset of those in the
       <structname>pg_stat_activity</structname> view.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       返回具有指定 PID 的后端相关的一个记录，或者在指定<symbol>NULL</symbol>的情况下为系统中每一个活动后端返回一个记录。被返回的域是<structname>pg_stat_activity</structname>视图中的那些域的一个子集。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_snapshot_timestamp()</function></literal><indexterm><primary>pg_stat_get_snapshot_timestamp</primary></indexterm></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       Returns the timestamp of the current statistics snapshot
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_snapshot_timestamp()</function></literal><indexterm><primary>pg_stat_get_snapshot_timestamp</primary></indexterm></entry>
      <entry><type>带时区的时间戳</type></entry>
      <entry>
       返回当前统计信息快照的时间戳
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Discard the current statistics snapshot
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       抛弃当前的统计快照
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset all statistics counters for the current database to zero
       (requires superuser privileges by default, but EXECUTE for this
       function can be granted to others.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把用于当前数据库的所有统计计数器重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset some cluster-wide statistics counters to zero, depending on the
       argument (requires superuser privileges by default, but EXECUTE for
       this function can be granted to others).
       Calling <literal>pg_stat_reset_shared('bgwriter')</literal> will zero all the
       counters shown in the <structname>pg_stat_bgwriter</structname> view.
       Calling <literal>pg_stat_reset_shared('archiver')</literal> will zero all the
       counters shown in the <structname>pg_stat_archiver</structname> view.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
       调用<literal>pg_stat_reset_shared('bgwriter')</literal>把<structname>pg_stat_bgwriter</structname>
       视图中显示的所有计数器清零。调用<literal>pg_stat_reset_shared('archiver')</literal>
       将会把<structname>pg_stat_archiver</structname>视图中展示的所有计数器清零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single table or index in the current database to
       zero (requires superuser privileges by default, but EXECUTE for this
       function can be granted to others)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把当前数据库中用于单个表或索引的统计数据重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single function in the current database to
       zero (requires superuser privileges by default, but EXECUTE for this
       function can be granted to others)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把当前数据库中用于单个函数的统计信息重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <function>pg_stat_get_activity</function>, the underlying function of
   the <structname>pg_stat_activity</structname> view, returns a set of records
   containing all the available information about each backend process.
   Sometimes it may be more convenient to obtain just a subset of this
   information.  In such cases, an older set of per-backend statistics
   access functions can be used; these are shown in <xref
   linkend="monitoring-stats-backend-funcs-table"/>.
   These access functions use a backend ID number, which ranges from one
   to the number of currently active backends.
   The function <function>pg_stat_get_backend_idset</function> provides a
   convenient way to generate one row for each active backend for
   invoking these functions.  For example, to show the <acronym>PID</acronym>s and
   current queries of all backends:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_stat_get_activity</function>是<structname>pg_stat_activity</structname>视图的底层函数，它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<xref linkend="monitoring-stats-backend-funcs-table"/>中。这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。函数<function>pg_stat_get_backend_idset</function>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示<acronym>PID</acronym>以及所有后端当前的查询：

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
<!--==========================orignal english content==========================
   <title>Per-Backend Statistics Functions</title>
____________________________________________________________________________-->
   <title>针对每个后端的统计函数</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>Set of currently active backend ID numbers (from 1 to the
       number of active backends)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>当前活动后端 ID 号的集合（从 1 到活动后端数目）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>Text of this backend's most recent query</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>这个后端最近查询的文本</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the most recent query was started</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最近查询被开始的时间</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>IP address of the client connected to this backend</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>该客户端连接到这个后端的 IP 地址</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>TCP port number that the client is using for communication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>该客户端用来通信的 TCP 端口号</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the database this backend is connected to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>这个后端连接到的数据库的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>Process ID of this backend</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>这个后端的进程 ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when this process was started</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这个进程被开始的时间</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the user logged into this backend</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>登录到这个后端的用户的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
       <entry><literal><function>pg_stat_get_backend_wait_event_type(integer)</function></literal></entry>
       <entry><type>text</type></entry>
        <entry>Wait event type name if backend is currently waiting, otherwise NULL.
        See <xref linkend="wait-event-table"/> for details.
        </entry>
      </row>
____________________________________________________________________________-->
     <row>
       <entry><literal><function>pg_stat_get_backend_wait_event_type(integer)</function></literal></entry>
       <entry><type>text</type></entry>
        <entry>如果后端正在等待，则是等待事件类型的名称，否则为 NULL。详见<xref linkend="wait-event-table"/>。
        </entry>
      </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_wait_event(integer)</function></literal></entry>
      <entry><type>text</type></entry>
       <entry>Wait event name if backend is currently waiting, otherwise NULL.
       See <xref linkend="wait-event-table"/> for details.
       </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_wait_event(integer)</function></literal></entry>
      <entry><type>text</type></entry>
       <entry>如果后端正在等待，则是等待事件的名称，否则为 NULL。详见<xref linkend="wait-event-table"/>。
       </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the current transaction was started</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>当前事务被开始的时间</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
<!--==========================orignal english content==========================
  <title>Viewing Locks</title>
____________________________________________________________________________-->
  <title>查看锁</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Another useful tool for monitoring database activity is the
   <structname>pg_locks</structname> system table.  It allows the
   database administrator to view information about the outstanding
   locks in the lock manager. For example, this capability can be used
   to:

   <itemizedlist>
    <listitem>
     <para>
      View all the locks currently outstanding, all the locks on
      relations in a particular database, all the locks on a
      particular relation, or all the locks held by a particular
      <productname>PostgreSQL</productname> session.
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the relation in the current database with the most
      ungranted locks (which might be a source of contention among
      database clients).
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the effect of lock contention on overall database
      performance, as well as the extent to which contention varies
      with overall database traffic.
     </para>
    </listitem>
   </itemizedlist>

   Details of the <structname>pg_locks</structname> view appear in
   <xref linkend="view-pg-locks"/>.
   For more information on locking and managing concurrency with
   <productname>PostgreSQL</productname>, refer to <xref linkend="mvcc"/>.
  </para>
____________________________________________________________________________-->
  <para>
   监控数据库活动的另外一个有用的工具是<structname>pg_locks</structname>系统表。这样就允许数据库管理员查看在锁管理器里面未解决的锁的信息。例如，这个功能可以被用于：

   <itemizedlist>
    <listitem>
     <para>
      查看当前所有未解决的锁、在一个特定数据库中的关系上所有的锁、在一个特定关系上所有的锁，或者由一个特定<productname>PostgreSQL</productname>会话持有的所有的锁。
     </para>
    </listitem>

    <listitem>
     <para>
      判断当前数据库中带有最多未授予锁的关系（它很可能是数据库客户端的竞争源）。
     </para>
    </listitem>

    <listitem>
     <para>
      判断锁竞争给数据库总体性能带来的影响，以及锁竞争随着整个数据库流量的变化范围。
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_locks</structname>视图的细节在<xref linkend="view-pg-locks"/>中。更多有关<productname>PostgreSQL</productname>的锁和管理并发性的信息，请参考<xref linkend="mvcc"/>。
  </para>
 </sect1>
 
 <sect1 id="progress-reporting">
<!--==========================orignal english content==========================
  <title>Progress Reporting</title>
____________________________________________________________________________-->
  <title>进度报告</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> has the ability to report the progress of
   certain commands during command execution.  Currently, the only command
   which supports progress reporting is <command>VACUUM</command>.  This may be
   expanded in the future.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>有能力在命令执行期间报告特定命令的进度。当前，唯一一种支持进度报告的命令是<command>VACUUM</command>。这在未来可能会被扩充。
  </para>

 <sect2 id="vacuum-progress-reporting">
<!--==========================orignal english content==========================
  <title>VACUUM Progress Reporting</title>
____________________________________________________________________________-->
  <title>VACUUM进度报告</title>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>VACUUM</command> is running, the
   <structname>pg_stat_progress_vacuum</structname> view will contain
   one row for each backend (including autovacuum worker processes) that is
   currently vacuuming.  The tables below describe the information
   that will be reported and provide information about how to interpret it.
   Progress reporting is not currently supported for <command>VACUUM FULL</command>
   and backends running <command>VACUUM FULL</command> will not be listed in this
   view.
  </para>
____________________________________________________________________________-->
  <para>
   只要<command>VACUUM</command>正在运行，每一个当前正在清理的后端（包括autovacuum工作者进程）在<structname>pg_stat_progress_vacuum</structname>视图中都会有一行。下面的表描述了将被报告的信息并且提供了如何解释它们的信息。进度报告当前不支持<command>VACUUM FULL</command>，运行着<command>VACUUM FULL</command>的后端将不会在这个视图中列出。
  </para>

  <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_vacuum</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_vacuum</structname>视图</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of backend.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>后端的进程ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the database to which this backend is connected.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>这个后端连接的数据库的OID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the database to which this backend is connected.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>这个后端连接的数据库的名称。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table being vacuumed.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>被vacuum的表的OID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>phase</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
       Current processing phase of vacuum.  See <xref linkend='vacuum-phases'/>.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>phase</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
       vacuum的当前处理阶段。请参考<xref linkend='vacuum-phases'/>。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>heap_blks_total</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of the scan; blocks added later will not be (and
       need not be) visited by this <command>VACUUM</command>.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>heap_blks_total</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       该表中堆块的总数。这个数字在扫描开始时报告，之后增加的块将不会（并且不需要）被这个<command>VACUUM</command>访问。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>heap_blks_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of heap blocks scanned.  Because the
       <link linkend="storage-vm">visibility map</link> is used to optimize scans,
       some blocks will be skipped without inspection; skipped blocks are
       included in this total, so that this number will eventually become
       equal to <structfield>heap_blks_total</structfield> when the vacuum is complete.
       This counter only advances when the phase is <literal>scanning heap</literal>.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>heap_blks_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       被扫描的堆块数量。由于<link linkend="storage-vm">可见性映射</link>被用来优化扫描，一些块将被跳过而不做检查，被跳过的块会被包括在这个总数中，因此当清理完成时这个数字最终将会等于<structfield>heap_blks_total</structfield>。仅当处于<literal>扫描堆</literal>阶段时这个计数器才会前进。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>heap_blks_vacuumed</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of heap blocks vacuumed.  Unless the table has no indexes, this
       counter only advances when the phase is <literal>vacuuming heap</literal>.
       Blocks that contain no dead tuples are skipped, so the counter may
       sometimes skip forward in large increments.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>heap_blks_vacuumed</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       被清理的堆块数量。除非表没有索引，这个计数器仅在处于<literal>清理堆</literal>阶段时才会前进。不包含死亡元组的块会被跳过，因此这个计数器可能有时会向前跳跃一个比较大的增量。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>index_vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of completed index vacuum cycles.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>index_vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       已完成的索引清理周期数。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>max_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
      Number of dead tuples that we can store before needing to perform
      an index vacuum cycle, based on
      <xref linkend="guc-maintenance-work-mem"/>.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>max_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
      在需要执行一个索引清理周期之前我们可以存储的死亡元组数，取决于<xref linkend="guc-maintenance-work-mem"/>。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>num_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of dead tuples collected since the last index vacuum cycle.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>num_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       从上一个索引清理周期以来收集的死亡元组数。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <table id="vacuum-phases">
<!--==========================orignal english content==========================
   <title>VACUUM phases</title>
____________________________________________________________________________-->
   <title>VACUUM的阶段</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       <command>VACUUM</command> is preparing to begin scanning the heap.  This
       phase is expected to be very brief.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>初始化</literal></entry>
     <entry>
       <command>VACUUM</command>正在准备开始扫描堆。这个阶段应该很简短。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>scanning heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently scanning the heap.  It will prune and
       defragment each page if required, and possibly perform freezing
       activity.  The <structfield>heap_blks_scanned</structfield> column can be used
       to monitor the progress of the scan.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>扫描堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在扫描堆。如果需要，它将会对每个页面进行修建以及碎片整理，并且可能会执行冻结动作。<structfield>heap_blks_scanned</structfield>列可以用来监控扫描的进度。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>vacuuming indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the indexes.  If a table has
       any indexes, this will happen at least once per vacuum, after the heap
       has been completely scanned.  It may happen multiple times per vacuum
       if <xref linkend="guc-maintenance-work-mem"/> is insufficient to
       store the number of dead tuples found.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清理索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理索引。如果一个表拥有索引，那么每次清理时这个阶段会在堆扫描完成后至少发生一次。如果<xref linkend="guc-maintenance-work-mem"/>不足以存放找到的死亡元组，则每次清理时会多次清理索引。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>vacuuming heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the heap.  Vacuuming the heap
       is distinct from scanning the heap, and occurs after each instance of
       vacuuming indexes.  If <structfield>heap_blks_scanned</structfield> is less than
       <structfield>heap_blks_total</structfield>, the system will return to scanning
       the heap after this phase is completed; otherwise, it will begin
       cleaning up indexes after this phase is completed.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清理堆</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理堆。清理堆与扫描堆不是同一个概念，清理堆发生在每一次清理索引的实例之后。如果<structfield>heap_blks_scanned</structfield>小于<structfield>heap_blks_total</structfield>，系统将在这个阶段完成之后回去扫描堆；否则，系统将在这个阶段完成后开始清理索引。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>cleaning up indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently cleaning up indexes.  This occurs after
       the heap has been completely scanned and all vacuuming of the indexes
       and the heap has been completed.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清除索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清除索引。这个阶段发生在堆被完全扫描并且对堆和索引的所有清理都已经完成以后。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>truncating heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently truncating the heap so as to return
       empty pages at the end of the relation to the operating system.  This
       occurs after cleaning up indexes.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>截断堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在截断堆，以便把关系尾部的空页面返还给操作系统。这个阶段发生在清除完索引之后。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       <command>VACUUM</command> is performing final cleanup.  During this phase,
       <command>VACUUM</command> will vacuum the free space map, update statistics
       in <literal>pg_class</literal>, and report statistics to the statistics
       collector.  When this phase is completed, <command>VACUUM</command> will end.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>执行最后的清除</literal></entry>
     <entry>
       <command>VACUUM</command>在执行最终的清除。在这个阶段中，<command>VACUUM</command>将清理空闲空间映射、更新<literal>pg_class</literal>中的统计信息并且将统计信息报告给统计收集器。当这个阶段完成时，<command>VACUUM</command>也就结束了。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="dynamic-trace">
<!--==========================orignal english content==========================
  <title>Dynamic Tracing</title>
____________________________________________________________________________-->
  <title>动态追踪</title>

<!--==========================orignal english content==========================
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides facilities to support
   dynamic tracing of the database server. This allows an external
   utility to be called at specific points in the code and thereby trace
   execution.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了功能来支持数据库服务器的动态追踪。这样就允许在代码中的特 定点上调用外部工具来追踪执行过程。
  </para>

<!--==========================orignal english content==========================
  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>
____________________________________________________________________________-->
  <para>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。默认情况下，探针不被编译到<productname>PostgreSQL</productname>中；用户需要显式地告诉配置脚本使得探针可用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Currently, the
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   utility is supported, which, at the time of this writing, is available
   on Solaris, macOS, FreeBSD, NetBSD, and Oracle Linux.  The
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux provides a DTrace equivalent and can also be used.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   目前，在写本文当时<ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>已被支持，它在 Solaris、macOS、FreeBSD、NetBSD 和 Oracle Linux 上可用。Linux 的<ulink url="http://sourceware.org/systemtap/">SystemTap</ulink>项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变<filename>src/include/utils/probes.h</filename>中的宏定义实现。
  </para>

  <sect2 id="compiling-for-trace">
<!--==========================orignal english content==========================
   <title>Compiling for Dynamic Tracing</title>
____________________________________________________________________________-->
   <title>动态追踪的编译</title>

<!--==========================orignal english content==========================
  <para>
   By default, probes are not available, so you will need to
   explicitly tell the configure script to make the probes available
   in <productname>PostgreSQL</productname>. To include DTrace support
   specify <option>-&minus;enable-dtrace</option> to configure.  See <xref
   linkend="install-procedure"/> for further information.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，探针是不可用的，因此你将需要显式地告诉配置脚本让探针在<productname>PostgreSQL</productname>中可用。要包括 DTrace 支持，在配置时指定<option>--enable-dtrace</option>。更多信息请见<xref linkend="install-procedure"/>。
  </para>
  </sect2>

  <sect2 id="trace-points">
<!--==========================orignal english content==========================
   <title>Built-in Probes</title>
____________________________________________________________________________-->
   <title>内建探针</title>

<!--==========================orignal english content==========================
  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table"/>;
   <xref linkend="typedefs-table"/>
   shows the types used in the probes.  More probes can certainly be
   added to enhance <productname>PostgreSQL</productname>'s observability.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="dtrace-probe-point-table"/>所示，源代码中提供了一些标准探针。<xref linkend="typedefs-table"/>显式了在探针中使用的类型。当然，可以增加更多探针来增强<productname>PostgreSQL</productname>的可观测性。
  </para>

 <table id="dtrace-probe-point-table">
<!--==========================orignal english content==========================
  <title>Built-in DTrace Probes</title>
____________________________________________________________________________-->
  <title>内建 DTrace 探针</title>
  <tgroup cols="3">
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>Description</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>名称</entry>
     <entry>参数</entry>
     <entry>描述</entry>
    </row>
   </thead>

   <tbody>

<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个新事务开始时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个事务成功完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>当一个事务失败完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
      arg0 is the new status string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>任何时候当服务器进程更新它的<structname>pg_stat_activity</structname>.<structfield>status</structfield>时触发的探针。arg0 是新的状态字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of WAL files added,
      removed and recycled respectively.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、删除和循环回收的 WAL 文件的数量。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for <literal>clog-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与<literal>clog-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>subtrans-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与<literal>subtrans-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>multixact-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分完成时触发的探针。arg0 的含义与<literal>multixact-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点的写缓冲区部分被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      <literal>buffer-sync-start</literal>); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（<literal>buffer-sync-start</literal>的 arg1）；arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当同步缓冲区到磁盘完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>当一次缓冲区读完成时触发的探测器。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，为假表示没有找到。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for <literal>buffer-flush-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，它通常并没有实际地被写入到磁盘）。参数和<literal>buffer-flush-start</literal>的相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"/> is too
      small or the background writer control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-shared-buffers"/>太小，或需要调整后台写入器的控制参数）。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for <literal>buffer-write-dirty-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一次脏缓冲区写完成时触发的探针。参数与<literal>buffer-write-dirty-start</literal>相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"/> is too small.)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-wal-buffers"/>太小）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一次脏 WAL 缓冲区完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。arg1 包含 info 标志。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当请求一次 WAL 段切换时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.
      arg5 indicates serial when <literal>0</literal>, parallel worker when
      <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。arg1 为真表示唯一值强制。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。如果要求随机访问排序结果，那么 arg4 为真。arg5为<literal>0</literal>时表示串行，为<literal>1</literal>时表示并行工作者，为<literal>2</literal>时表示并行领袖。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>当一次排序完成时触发的探针。arg0 为真表示外排序，为假表示内排序。arg1 是用于一次外排序的磁盘块的数目，或用于一次内排序的以千字节计的内存。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's tranche.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个进程从对一个 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for <literal>lock-wait-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。参数与<literal>lock-wait-start</literal>一样。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当死锁检测器发现死锁时触发的探针。</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
<!--==========================orignal english content==========================
  <title>Defined Types Used in Probe Parameters</title>
____________________________________________________________________________-->
  <title>定义用在探针参数中的类型</title>
  <tgroup cols="2">
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>类型</entry>
     <entry>定义</entry>
    </row>
   </thead>

   <tbody>

<!--==========================orignal english content==========================
    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>Oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>bool</type></entry>
     <entry><type>char</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>bool</type></entry>
     <entry><type>char</type></entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
<!--==========================orignal english content==========================
   <title>Using Probes</title>
____________________________________________________________________________-->
   <title>使用探针</title>

<!--==========================orignal english content==========================
  <para>
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</structname> before and after a performance test:
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   When executed, the example D script gives output such as:
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   下面的例子展示了一个分析系统中事务计数的 DTrace 脚本，可以用来代替一次性能测试之前和之后的<structname>pg_stat_database</structname>快照：
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   当被执行时，该例子 D 脚本给出这样的输出：
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
____________________________________________________________________________-->
   <para>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。在未来的 SystemTap 发行中这很可能会被修复。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>
____________________________________________________________________________-->
  <para>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。在大部分发现问题的情况中，它就是发生问题的部件，而不是底层系统。当讨论使用动态追踪发现的信息时，一定要封闭使用的脚本来允许这些以便被检查和讨论。
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
<!--==========================orignal english content==========================
   <title>Defining New Probes</title>
____________________________________________________________________________-->
   <title>定义新探针</title>

<!--==========================orignal english content==========================
  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>
____________________________________________________________________________-->
  <para>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </para>

  <procedure>
   <step>
<!--==========================orignal english content==========================
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
____________________________________________________________________________-->
    <para>
     决定探针名称以及探针可用的数据
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</filename>
    </para>
____________________________________________________________________________-->
    <para>
     把该探针定义加入到<filename>src/backend/utils/probes.d</filename>
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Include <filename>pg_trace.h</filename> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</literal> probe macros at the desired locations
     in the source code
    </para>
____________________________________________________________________________-->
    <para>
     如果<filename>pg_trace.h</filename>还不存在于包含该探针点的模块中，包括它，并且在源代码中期望的位置插入<literal>TRACE_POSTGRESQL</literal>探针宏
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Recompile and verify that the new probes are available
    </para>
____________________________________________________________________________-->
    <para>
     重新编译并验证新探针是可用的
    </para>
   </step>
  </procedure>

  <formalpara>
<!--==========================orignal english content==========================
   <title>Example:</title>
____________________________________________________________________________-->
   <title>例子：</title>
<!--==========================orignal english content==========================
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </para>
  </formalpara>

  <procedure>
   <step>
<!--==========================orignal english content==========================
    <para>
     Decide that the probe will be named <literal>transaction-start</literal> and
     requires a parameter of type <type>LocalTransactionId</type>
    </para>
____________________________________________________________________________-->
    <para>
     决定探针将被命名为<literal>transaction-start</literal>并且需要一个<type>LocalTransactionId</type>类型的参数
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</filename>:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</literal> is the name to document for
     users.
    </para>
____________________________________________________________________________-->
    <para>
     将该探针定义加入到<filename>src/backend/utils/probes.d</filename>：
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，双下划线需要被替换为一个连字符，因此 ，对用户而言<literal>transaction-start</literal>是文档名。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     At compile time, <literal>transaction__start</literal> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</filename>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在编译时，<literal>transaction__start</literal>被转换成一个宏调用<literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>（注意这里是单下划线），可以通过包括头文件<filename>pg_trace.h</filename>获得。将宏调用加入到源代码中的合适位置。在这种情况下，看起来类似：

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。你应该看到类似下面的输出：
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

<!--==========================orignal english content==========================
  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>-&minus;enable-dtrace</option>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</emphasis>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</literal> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>
____________________________________________________________________________-->
  <para>
   向C代码中添加追踪宏时，有一些事情需要注意：

   <itemizedlist>
    <listitem>
     <para>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </para>
    </listitem>


    <listitem>
     <para>
      在大多数平台上，如果用<option>--enable-dtrace</option>编译了<productname>PostgreSQL</productname>，无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<emphasis>即使没有进行追踪也会这样做</emphasis>。通常不需要担心你是否只在报告一些局部变量的值。但要注意将开销大的函数调用放置在这些参数中。如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      每个追踪宏有一个对应的<literal>ENABLED</literal>宏。
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
