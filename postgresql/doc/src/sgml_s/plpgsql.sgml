<!-- doc/src/sgml/plpgsql.sgml -->

<chapter id="plpgsql">
<!--==========================orignal english content==========================
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym> Procedural Language</title>
____________________________________________________________________________-->
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym>过程语言</title>

<!--==========================orignal english content==========================
 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>综述</title>

<!--==========================orignal english content==========================
 <para>
  <application>PL/pgSQL</application> is a loadable procedural
  language for the <productname>PostgreSQL</productname> database
  system.  The design goals of <application>PL/pgSQL</application> were to create
  a loadable procedural language that

    <itemizedlist>
     <listitem>
      <para>
       can be used to create functions and triggers,
      </para>
     </listitem>
     <listitem>
      <para>
       adds control structures to the <acronym>SQL</acronym> language,
      </para>
     </listitem>
     <listitem>
      <para>
       can perform complex computations,
      </para>
     </listitem>
     <listitem>
      <para>
       inherits all user-defined types, functions, and operators,
      </para>
     </listitem>
     <listitem>
      <para>
       can be defined to be trusted by the server,
      </para>
     </listitem>
     <listitem>
      <para>
       is easy to use.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
 <para>
  <application>PL/pgSQL</application>是一种用于<productname>PostgreSQL</productname>数据库系统的可载入的过程语言。<application>PL/pgSQL</application>的设计目标是创建一种这样的可载入过程语言

    <itemizedlist>
     <listitem>
      <para>
       可以被用来创建函数和触发器过程，
      </para>
     </listitem>
     <listitem>
      <para>
       对<acronym>SQL</acronym>语言增加控制结构，
      </para>
     </listitem>
     <listitem>
      <para>
       可以执行复杂计算，
      </para>
     </listitem>
     <listitem>
      <para>
       继承所有用户定义类型、函数和操作符，
      </para>
     </listitem>
     <listitem>
      <para>
       可以被定义为受服务器信任，
      </para>
     </listitem>
     <listitem>
      <para>
       便于使用。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Functions created with <application>PL/pgSQL</application> can be
    used anywhere that built-in functions could be used.
    For example, it is possible to
    create complex conditional computation functions and later use
    them to define operators or use them in index expressions.
   </para>
____________________________________________________________________________-->
   <para>
    用<application>PL/pgSQL</application>创建的函数可以被用在任何可以使用内建函数的地方。例如，可以创建复杂条件的计算函数并且后面用它们来定义操作符或把它们用于索引表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    In <productname>PostgreSQL</productname> 9.0 and later,
    <application>PL/pgSQL</application> is installed by default.
    However it is still a loadable module, so especially security-conscious
    administrators could choose to remove it.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 9.0 和以后的版本中，<application>PL/pgSQL</application>是默认被安装的。但是它仍然是一种可载入模块，因此特别关注安全性的管理员可以选择移除它。
   </para>

  <sect2 id="plpgsql-advantages">
<!--==========================orignal english content==========================
   <title>Advantages of Using <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
   <title>使用<application>PL/pgSQL</application>的优点</title>

<!--==========================orignal english content==========================
    <para>
     <acronym>SQL</acronym> is the language <productname>PostgreSQL</productname>
     and most other relational databases use as query language. It's
     portable and easy to learn. But every <acronym>SQL</acronym>
     statement must be executed individually by the database server.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>被<productname>PostgreSQL</productname>和大多数其他关系数据库用作查询语言。它是可移植的并且容易学习。但是每一个<acronym>SQL</acronym>语句必须由数据库服务器单独执行。
    </para>

<!--==========================orignal english content==========================
    <para>
     That means that your client application must send each query to
     the database server, wait for it to be processed, receive and
     process the results, do some computation, then send further
     queries to the server.  All this incurs interprocess
     communication and will also incur network overhead if your client
     is on a different machine than the database server.
    </para>
____________________________________________________________________________-->
    <para>
     这意味着你的客户端应用必须发送每一个查询到数据库服务器、等待它被处理、接收并处理结果、做一些计算，然后发送更多查询给服务器。如果你的客户端和数据库服务器不在同一台机器上，所有这些会引起进程间通信并且将带来网络负担。
    </para>

<!--==========================orignal english content==========================
    <para>
     With <application>PL/pgSQL</application> you can group a block of
     computation and a series of queries <emphasis>inside</emphasis>
     the database server, thus having the power of a procedural
     language and the ease of use of SQL, but with considerable
     savings of client/server communication overhead.
    </para>
____________________________________________________________________________-->
    <para>
     通过<application>PL/pgSQL</application>，你可以将一整块计算和一系列查询分组在数据库服务器<emphasis>内部</emphasis>，这样就有了一种过程语言的能力并且使 SQL 更易用，但是节省了相当多的客户端/服务器通信开销。
    </para>
    <itemizedlist>

     <listitem><!--==========================orignal english content==========================
<para> Extra round trips between
     client and server are eliminated </para>
____________________________________________________________________________-->
<para> 客户端和服务器之间的额外往返通信被消除 </para></listitem>

     <listitem><!--==========================orignal english content==========================
<para> Intermediate results that the client does not
     need do not have to be marshaled or transferred between server
     and client </para>
____________________________________________________________________________-->
<para> 客户端不需要的中间结果不必被整理或者在服务器和客户端之间传送 </para></listitem>

     <listitem><!--==========================orignal english content==========================
<para> Multiple rounds of query
     parsing can be avoided </para>
____________________________________________________________________________-->
<para> 多轮的查询解析可以被避免 </para></listitem>

    </itemizedlist>
<!--==========================orignal english content==========================
    <para> This can result in a considerable performance increase as
    compared to an application that does not use stored functions.
    </para>
____________________________________________________________________________-->
    <para> 与不使用存储函数的应用相比，这能够导致可观的性能提升。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, with <application>PL/pgSQL</application> you can use all
     the data types, operators and functions of SQL.
    </para>
____________________________________________________________________________-->
    <para>
     还有，通过<application>PL/pgSQL</application>你可以使用 SQL 中所有的数据类型、操作符和函数。
    </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
<!--==========================orignal english content==========================
   <title>Supported Argument and Result Data Types</title>
____________________________________________________________________________-->
   <title>支持的参数和结果数据类型</title>

<!--==========================orignal english content==========================
    <para>
     Functions written in <application>PL/pgSQL</application> can accept
     as arguments any scalar or array data type supported by the server,
     and they can return a result of any of these types.  They can also
     accept or return any composite type (row type) specified by name.
     It is also possible to declare a <application>PL/pgSQL</application>
     function as accepting <type>record</type>, which means that any
     composite type will do as input, or
     as returning <type>record</type>, which means that the result
     is a row type whose columns are determined by specification in the
     calling query, as discussed in <xref linkend="queries-tablefunctions"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>编写的函数可以接受服务器支持的任何标量或数组数据类型作为参数，并且它们能够返回任何这些类型的结果。它们也能接受或返回任何用名称指定的组合类型（行类型）。还可以声明一个<application>PL/pgSQL</application>函数为接受<type>record</type>，这表示任意组合类型都将作为输入，或者声明为返回<type>record</type>，表示结果是一种行类型，它的列由调用查询中的说明确定（如<xref linkend="queries-tablefunctions"/>中所讨论）。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> functions can be declared to accept a variable
     number of arguments by using the <literal>VARIADIC</literal> marker.  This
     works exactly the same way as for SQL functions, as discussed in
     <xref linkend="xfunc-sql-variadic-functions"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数可以通过使用<literal>VARIADIC</literal>标记被声明为接受数量不定的参数。如<xref linkend="xfunc-sql-variadic-functions"/>中所讨论的，它的工作方式和 SQL 函数一样。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> functions can also be declared to accept
     and return the polymorphic types
     <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>,
     <type>anyenum</type>, and <type>anyrange</type>.  The actual
     data types handled by a polymorphic function can vary from call to
     call, as discussed in <xref linkend="extend-types-polymorphic"/>.
     An example is shown in <xref linkend="plpgsql-declaration-parameters"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数也可以被声明为接受并返回多态类型<type>anyelement</type>、<type>anyarray</type>、<type>anynonarray</type>、<type>anyenum</type>以及<type>anyrange</type>。如<xref linkend="extend-types-polymorphic"/>中所讨论的，由一个多态函数处理的实际数据类型会随着调用改变。在<xref linkend="plpgsql-declaration-parameters"/>中展示了一个例子。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> functions can also be declared to return
     a <quote>set</quote> (or table) of any data type that can be returned as
     a single instance.  Such a function generates its output by executing
     <command>RETURN NEXT</command> for each desired element of the result
     set, or by using <command>RETURN QUERY</command> to output the result of
     evaluating a query.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数还能够被声明为返回一个任意（可作为一个单一实例返回的）数据类型的<quote>集合</quote>（或表）。这样的一个函数通过为结果集的每个期望元素执行<command>RETURN NEXT</command>来产生输出，或者通过使用<command>RETURN QUERY</command>来输出一个查询计算的结果。
    </para>

<!--==========================orignal english content==========================
    <para>
     Finally, a <application>PL/pgSQL</application> function can be declared to return
     <type>void</type> if it has no useful return value.  (Alternatively, it
     could be written as a procedure in that case.)
    </para>
____________________________________________________________________________-->
    <para>
     最后，如果一个<application>PL/pgSQL</application>函数没有可用的返回值，它可以被声明为返回<type>void</type>（另外一种选择是，在那种情况下它可以被写作一个过程）。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> functions can also be declared with output
     parameters in place of an explicit specification of the return type.
     This does not add any fundamental capability to the language, but
     it is often convenient, especially for returning multiple values.
     The <literal>RETURNS TABLE</literal> notation can also be used in place
     of <literal>RETURNS SETOF</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数也能够被声明为用输出参数代替返回类型的一个显式说明。这没有为该语言增加任何基础功能，但是它常常很方便，特别是对于要返回多个值的情况。<literal>RETURNS TABLE</literal>符号也可以被用来替代<literal>RETURNS SETOF</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Specific examples appear in
     <xref linkend="plpgsql-declaration-parameters"/> and
     <xref linkend="plpgsql-statements-returning"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在<xref linkend="plpgsql-declaration-parameters"/>和<xref linkend="plpgsql-statements-returning"/>中有详细的例子。
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
<!--==========================orignal english content==========================
  <title>Structure of <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
  <title><application>PL/pgSQL</application>的结构</title>

<!--==========================orignal english content==========================
  <para>
   Functions written in <application>PL/pgSQL</application> are defined
   to the server by executing <xref linkend="sql-createfunction"/> commands.
   Such a command would normally look like, say,
<programlisting>
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>function body text</replaceable>'
LANGUAGE plpgsql;
</programlisting>
   The function body is simply a string literal so far as <command>CREATE
   FUNCTION</command> is concerned.  It is often helpful to use dollar quoting
   (see <xref linkend="sql-syntax-dollar-quoting"/>) to write the function
   body, rather than the normal single quote syntax.  Without dollar quoting,
   any single quotes or backslashes in the function body must be escaped by
   doubling them.  Almost all the examples in this chapter use dollar-quoted
   literals for their function bodies.
  </para>
____________________________________________________________________________-->
  <para>
   通过执行<xref linkend="sql-createfunction"/>命令，以<application>PL/pgSQL</application>写成的函数可以被定义到服务器中。这种命令通常看起来是这样：
<programlisting>
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>function body text</replaceable>'
LANGUAGE plpgsql;
</programlisting>
   就目前<command>CREATE FUNCTION</command>所关心的来说，函数体就是简单的一个字符串。通常在写函数体时，使用美元符号引用（见<xref linkend="sql-syntax-dollar-quoting"/>）通常比使用普通单引号语法更有帮助。如果没有美元引用，函数体中的任何单引号或者反斜线必须通过双写来转义。这一章中几乎所有的例子都在其函数体中使用美元符号引用。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>PL/pgSQL</application> is a block-structured language.
   The complete text of a function body must be a
   <firstterm>block</firstterm>. A block is defined as:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
____________________________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>是一种块结构的语言。一个函数体的完整文本必须是一个<firstterm>块</firstterm>。一个块被定义为：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     Each declaration and each statement within a block is terminated
     by a semicolon.  A block that appears within another block must
     have a semicolon after <literal>END</literal>, as shown above;
     however the final <literal>END</literal> that
     concludes a function body does not require a semicolon.
    </para>
____________________________________________________________________________-->
    <para>
     在一个块中的每一个声明和每一个语句都由一个分号终止。如上所示，出现在另一个块中的块必须有一个分号在<literal>END</literal>之后。不过最后一个结束函数体的<literal>END</literal>不需要一个分号。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      A common mistake is to write a semicolon immediately after
      <literal>BEGIN</literal>.  This is incorrect and will result in a syntax error.
     </para>
____________________________________________________________________________-->
     <para>
      一种常见的错误是直接在<literal>BEGIN</literal>之后写一个分号。这是不正确的并且将会导致一个语法错误。
     </para>
    </tip>

<!--==========================orignal english content==========================
    <para>
     A <replaceable>label</replaceable> is only needed if you want to
     identify the block for use
     in an <literal>EXIT</literal> statement, or to qualify the names of the
     variables declared in the block.  If a label is given after
     <literal>END</literal>, it must match the label at the block's beginning.
    </para>
____________________________________________________________________________-->
    <para>
     如果你想要标识一个块以便在一个<literal>EXIT</literal>语句中使用或者标识在该块中声明的变量名，那么<replaceable>label</replaceable>是你唯一需要的。如果一个标签在<literal>END</literal>之后被给定，它必须匹配在块开始处的标签。
    </para>

<!--==========================orignal english content==========================
    <para>
     All key words are case-insensitive.
     Identifiers are implicitly converted to lower case
     unless double-quoted, just as they are in ordinary SQL commands.
    </para>
____________________________________________________________________________-->
    <para>
     所有的关键词都是大小写无关的。除非被双引号引用，标识符会被隐式地转换为小写形式，就像它们在普通 SQL 命令中。
    </para>

<!--==========================orignal english content==========================
    <para>
     Comments work the same way in <application>PL/pgSQL</application> code as in
     ordinary SQL.  A double dash (<literal>-&minus;</literal>) starts a comment
     that extends to the end of the line. A <literal>/*</literal> starts a
     block comment that extends to the matching occurrence of
     <literal>*/</literal>.  Block comments nest.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>代码中的注释和普通 SQL 中的一样。一个双连字符（<literal>--</literal>）开始一段注释，它延伸到该行的末尾。一个<literal>/*</literal>开始一段块注释，它会延伸到匹配<literal>*/</literal>出现的位置。块注释可以嵌套。
    </para>

<!--==========================orignal english content==========================
    <para>
     Any statement in the statement section of a block
     can be a <firstterm>subblock</firstterm>.  Subblocks can be used for
     logical grouping or to localize variables to a small group
     of statements.  Variables declared in a subblock mask any
     similarly-named variables of outer blocks for the duration
     of the subblock; but you can access the outer variables anyway
     if you qualify their names with their block's label. For example:
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 30
    quantity := 50;
    -&minus;
    -&minus; Create a subblock
    -&minus;
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -&minus; Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一个块的语句节中的任何语句可以是一个<firstterm>子块</firstterm>。子块可以被用来逻辑分组或者将变量局部化为语句的一个小组。在子块的持续期间，在一个子块中声明的变量会掩盖外层块中相同名称的变量。但是如果你用块的标签限定外层变量的名字，你仍然可以访问它们。例如：
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- 创建一个子块
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      There is actually a hidden <quote>outer block</quote> surrounding the body
      of any <application>PL/pgSQL</application> function.  This block provides the
      declarations of the function's parameters (if any), as well as some
      special variables such as <literal>FOUND</literal> (see
      <xref linkend="plpgsql-statements-diagnostics"/>).  The outer block is
      labeled with the function's name, meaning that parameters and special
      variables can be qualified with the function's name.
     </para>
____________________________________________________________________________-->
     <para>
      在任何<application>PL/pgSQL</application>函数体的外部确实有一个隐藏的<quote>外层块</quote>包围着。这个块提供了该函数参数（如果有）的声明，以及某些诸如<literal>FOUND</literal>之类特殊变量（见<xref linkend="plpgsql-statements-diagnostics"/>）。外层块被标上函数的名称，这意味着参数和特殊变量可以用该函数的名称限定。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     It is important not to confuse the use of
     <command>BEGIN</command>/<command>END</command> for grouping statements in
     <application>PL/pgSQL</application> with the similarly-named SQL commands
     for transaction
     control.  <application>PL/pgSQL</application>'s <command>BEGIN</command>/<command>END</command>
     are only for grouping; they do not start or end a transaction.
     See <xref linkend="plpgsql-transactions"/> for information on managing
     transactions in <application>PL/pgSQL</application>.
     Also, a block containing an <literal>EXCEPTION</literal> clause effectively
     forms a subtransaction that can be rolled back without affecting the
     outer transaction.  For more about that see <xref
     linkend="plpgsql-error-trapping"/>.
    </para>
____________________________________________________________________________-->
    <para>
     重要的是不要把<application>PL/pgSQL</application>中用来分组语句的<command>BEGIN</command>/<command>END</command>与用于事务控制的同名 SQL 命令弄混。<application>PL/pgSQL</application>的<command>BEGIN</command>/<command>END</command>只用于分组，它们不会开始或结束一个事务。有关<application>PL/pgSQL</application>中管理事务的信息，请参考<xref linkend="plpgsql-transactions"/>。此外，一个包含<literal>EXCEPTION</literal>子句的块实际上会形成一个子事务，它可以被回滚而不影响外层事务。详见<xref linkend="plpgsql-error-trapping"/>。
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
<!--==========================orignal english content==========================
    <title>Declarations</title>
____________________________________________________________________________-->
    <title>声明</title>

<!--==========================orignal english content==========================
    <para>
     All variables used in a block must be declared in the
     declarations section of the block.
     (The only exceptions are that the loop variable of a <literal>FOR</literal> loop
     iterating over a range of integer values is automatically declared as an
     integer variable, and likewise the loop variable of a <literal>FOR</literal> loop
     iterating over a cursor's result is automatically declared as a
     record variable.)
    </para>
____________________________________________________________________________-->
    <para>
     在一个块中使用的所有变量必须在该块的声明小节中声明（唯一的例外是在一个整数范围上迭代的<literal>FOR</literal>循环变量会被自动声明为一个整数变量，并且相似地在一个游标结果上迭代的<literal>FOR</literal>循环变量会被自动地声明为一个记录变量）。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> variables can have any SQL data type, such as
     <type>integer</type>, <type>varchar</type>, and
     <type>char</type>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>变量可以是任意 SQL 数据类型，例如<type>integer</type>、<type>varchar</type>和<type>char</type>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are some examples of variable declarations:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是变量声明的一些例子：
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The general syntax of a variable declaration is:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      The <literal>DEFAULT</literal> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <literal>DEFAULT</literal> clause
      is not given then the variable is initialized to the
      <acronym>SQL</acronym> null value.
      The <literal>CONSTANT</literal> option prevents the variable from being
      assigned to after initialization, so that its value will remain constant
      for the duration of the block.
      The <literal>COLLATE</literal> option specifies a collation to use for the
      variable (see <xref linkend="plpgsql-declaration-collation"/>).
      If <literal>NOT NULL</literal>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <literal>NOT NULL</literal>
      must have a nonnull default value specified.
      Equal (<literal>=</literal>) can be used instead of PL/SQL-compliant
      <literal>:=</literal>.
     </para>
____________________________________________________________________________-->
    <para>
     一个变量声明的一般语法是：
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      如果给定<literal>DEFAULT</literal>子句，它会指定进入该块时分
      配给该变量的初始值。如果没有给出<literal>DEFAULT</literal>子句，
      则该变量被初始化为<acronym>SQL</acronym>空值。
      <literal>CONSTANT</literal>选项阻止该变量在初始化之后被赋值，
      这样它的值在块的持续期内保持不变。<literal>COLLATE</literal>
      选项指定用于该变量的一个排序规则（见
      <xref linkend="plpgsql-declaration-collation"/>）。如果指
      定了<literal>NOT NULL</literal>，对该变量赋值为空值会导致一个
      运行时错误。所有被声明为<literal>NOT NULL</literal>的变量必须
      被指定一个非空默认值。
      等号（<literal>=</literal>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      A variable's default value is evaluated and assigned to the variable
      each time the block is entered (not just once per function call).
      So, for example, assigning <literal>now()</literal> to a variable of type
      <type>timestamp</type> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
     </para>
____________________________________________________________________________-->
     <para>
      一个变量的默认值会在每次进入该块时被计算并且赋值给该变量（不是每次函数调用只计算一次）。因此，例如将<literal>now()</literal>赋值给类型为<type>timestamp</type>的一个变量将会导致该变量具有当前函数调用的时间，而不是该函数被预编译的时间。
     </para>

<!--==========================orignal english content==========================
     <para>
      Examples:
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
<!--==========================orignal english content==========================
     <title>Declaring Function Parameters</title>
____________________________________________________________________________-->
     <title>声明函数参数</title>

<!--==========================orignal english content==========================
     <para>
      Parameters passed to functions are named with the identifiers
      <literal>$1</literal>, <literal>$2</literal>,
      etc.  Optionally, aliases can be declared for
      <literal>$<replaceable>n</replaceable></literal>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
     </para>
____________________________________________________________________________-->
     <para>
      传递给函数的参数被命名为标识符<literal>$1</literal>、<literal>$2</literal>等等。可选地，能够为<literal>$<replaceable>n</replaceable></literal>参数名声明别名来增加可读性。不管是别名还是数字标识符都能用来引用参数值。
     </para>

<!--==========================orignal english content==========================
     <para>
      There are two ways to create an alias.  The preferred way is to give a
      name to the parameter in the <command>CREATE FUNCTION</command> command,
      for example:
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      The other way is to explicitly declare an alias, using the
      declaration syntax

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      The same example in this style looks like:
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      有两种方式来创建一个别名。比较好的方式是在<command>CREATE FUNCTION</command>命令中为参数给定一个名称。例如：
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      另一种方式是显式地使用声明语法声明一个别名。

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      使用这种风格的同一个例子看起来是：
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      These two examples are not perfectly equivalent.  In the first case,
      <literal>subtotal</literal> could be referenced as
      <literal>sales_tax.subtotal</literal>, but in the second case it could not.
      (Had we attached a label to the inner block, <literal>subtotal</literal> could
      be qualified with that label, instead.)
     </para>
____________________________________________________________________________-->
     <para>
      这两个例子并非完全等效。在第一种情况中，<literal>subtotal</literal>可以被引用为<literal>sales_tax.subtotal</literal>，但在第二种情况中它不能这样引用（如果我们为内层块附加了一个标签，<literal>subtotal</literal>则可以用那个标签限定）。
     </para>
    </note>

<!--==========================orignal english content==========================
     <para>
      Some more examples:
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -&minus; some computations using v_string and index here
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      更多一些例子：
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- 这里是一些使用 v_string 和 index 的计算
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      When a <application>PL/pgSQL</application> function is declared
      with output parameters, the output parameters are given
      <literal>$<replaceable>n</replaceable></literal> names and optional
      aliases in just the same way as the normal input parameters.  An
      output parameter is effectively a variable that starts out NULL;
      it should be assigned to during the execution of the function.
      The final value of the parameter is what is returned.  For instance,
      the sales-tax example could also be done this way:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      Notice that we omitted <literal>RETURNS real</literal> &mdash; we could have
      included it, but it would be redundant.
     </para>
____________________________________________________________________________-->
     <para>
      当一个<application>PL/pgSQL</application>函数被声明为带有输出参数，输出参数可以用普通输入参数相同的方式被给定<literal>$<replaceable>n</replaceable></literal>名称以及可选的别名。一个输出参数实际上是一个最初为 NULL 的变量，它应当在函数的执行期间被赋值。该参数的最终值就是要被返回的东西。例如，sales-tax 例子也可以用这种方式来做：

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      注意我们忽略了<literal>RETURNS real</literal> &mdash; 我们也可以包括它，但是那将是冗余。
     </para>

<!--==========================orignal english content==========================
     <para>
      Output parameters are most useful when returning multiple values.
      A trivial example is:

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      As discussed in <xref linkend="xfunc-output-parameters"/>, this
      effectively creates an anonymous record type for the function's
      results.  If a <literal>RETURNS</literal> clause is given, it must say
      <literal>RETURNS record</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      当返回多个值时，输出参数最有用。一个小例子是：

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      如<xref linkend="xfunc-output-parameters"/>中所讨论的，这实际上为该函数的结果创建了一个匿名记录类型。如果给定了一个<literal>RETURNS</literal>子句，它必须<literal>RETURNS record</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Another way to declare a <application>PL/pgSQL</application> function
      is with <literal>RETURNS TABLE</literal>, for example:

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      This is exactly equivalent to declaring one or more <literal>OUT</literal>
      parameters and specifying <literal>RETURNS SETOF
      <replaceable>sometype</replaceable></literal>.
     </para>
____________________________________________________________________________-->
     <para>
      声明一个<application>PL/pgSQL</application>函数的另一种方式是用<literal>RETURNS TABLE</literal>，例如：

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      这和声明一个或多个<literal>OUT</literal>参数并且指定<literal>RETURNS SETOF <replaceable>sometype</replaceable></literal>完全等效。
     </para>

<!--==========================orignal english content==========================
     <para>
      When the return type of a <application>PL/pgSQL</application>
      function is declared as a polymorphic type (<type>anyelement</type>,
      <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>,
      or <type>anyrange</type>), a special parameter <literal>$0</literal>
      is created.  Its data type is the actual return type of the function,
      as deduced from the actual input types (see <xref
      linkend="extend-types-polymorphic"/>).
      This allows the function to access its actual return type
      as shown in <xref linkend="plpgsql-declaration-type"/>.
      <literal>$0</literal> is initialized to null and can be modified by
      the function, so it can be used to hold the return value if desired,
      though that is not required.  <literal>$0</literal> can also be
      given an alias.  For example, this function works on any data type
      that has a <literal>+</literal> operator:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      当一个<application>PL/pgSQL</application>函数的返回类型被声明为一个多态类型（<type>anyelement</type>、<type>anyarray</type>、<type>anynonarray</type>、<type>anyenum</type>或<type>anyrange</type>），一个特殊参数<literal>$0</literal>会被创建。它的数据类型是该函数的实际返回类型，这是从实际输入类型（<xref linkend="extend-types-polymorphic"/>）推演得来。<literal>$0</literal>被初始化为空并且不能被该函数修改，因此它能够被用来保持可能需要的返回值，不过这不是必须的。<literal>$0</literal>也可以被给定一个别名。例如，这个函数工作在任何具有一个<literal>+</literal>操作符的数据类型上： 

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      The same effect can be obtained by declaring one or more output parameters as
      polymorphic types.  In this case the
      special <literal>$0</literal> parameter is not used; the output
      parameters themselves serve the same purpose.  For example:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      通过声明一个或多个输出参数为多态类型可以得到同样的效果。在这种情况下，不使用特殊的<literal>$0</literal>参数，输出参数本身就用作相同的目的。例如：

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
<!--==========================orignal english content==========================
   <title><literal>ALIAS</literal></title>
____________________________________________________________________________-->
   <title><literal>ALIAS</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <literal>ALIAS</literal> syntax is more general than is suggested in the
    previous section: you can declare an alias for any variable, not just
    function parameters.  The main practical use for this is to assign
    a different name for variables with predetermined names, such as
    <varname>NEW</varname> or <varname>OLD</varname> within
    a trigger function.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>ALIAS</literal>语法比前一节中建议的更一般化：你可以为任意变量声明一个别名，而不只是函数参数。其主要实际用途是为预先决定了名称的变量分配一个不同的名称，例如在一个触发器过程中的<varname>NEW</varname>或<varname>OLD</varname>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Examples:
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Since <literal>ALIAS</literal> creates two different ways to name the same
    object, unrestricted use can be confusing.  It's best to use it only
    for the purpose of overriding predetermined names.
   </para>
____________________________________________________________________________-->
   <para>
    因为<literal>ALIAS</literal>创造了两种不同的方式来命名相同的对象，如果对其使用不加限制就会导致混淆。最好只把它用来覆盖预先决定的名称。
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
<!--==========================orignal english content==========================
   <title>Copying Types</title>
____________________________________________________________________________-->
   <title>复制类型</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

<!--==========================orignal english content==========================
   <para>
    <literal>%TYPE</literal> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <literal>user_id</literal> in your <literal>users</literal>
    table. To declare a variable with the same data type as
    <literal>users.user_id</literal> you write:
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <literal>%TYPE</literal>提供了一个变量或表列的数据类型。你可以用它来声明将保持数据库值的变量。例如，如果你在<literal>users</literal>中有一个名为<literal>user_id</literal>的列。要定义一个与<literal>users.user_id</literal>具有相同数据类型的变量：
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    By using <literal>%TYPE</literal> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <literal>user_id</literal>
    from <type>integer</type> to <type>real</type>), you might not need
    to change your function definition.
   </para>
____________________________________________________________________________-->
   <para>
    通过使用<literal>%TYPE</literal>，你不需要知道你要引用的结构的实际数据类型，而且最重要地，如果被引用项的数据类型在未来被改变（例如你把<literal>user_id</literal>的类型从<type>integer</type>改为<type>real</type>），你不需要改变你的函数定义。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>%TYPE</literal> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables can
    change from one call to the next.  Appropriate variables can be
    created by applying <literal>%TYPE</literal> to the function's
    arguments or result placeholders.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>%TYPE</literal>在多态函数中特别有价值，因为内部变量所需的数据类型能在两次调用时改变。可以把<literal>%TYPE</literal>应用在函数的参数或结果占位符上来创建合适的变量。
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
<!--==========================orignal english content==========================
     <title>Row Types</title>
____________________________________________________________________________-->
     <title>行类型</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
   <para>
    A variable of a composite type is called a <firstterm>row</firstterm>
    variable (or <firstterm>row-type</firstterm> variable).  Such a variable
    can hold a whole row of a <command>SELECT</command> or <command>FOR</command>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <literal>rowvar.field</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    一个组合类型的变量被称为一个<firstterm>行</firstterm>变量（或<firstterm>行类型</firstterm>变量）。这样一个变量可以保持一个<command>SELECT</command>或<command>FOR</command>查询结果的一整行，前提是查询的列集合匹配该变量被声明的类型。该行值的各个域可以使用通常的点号标记访问，例如<literal>rowvar.field</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <productname>PostgreSQL</productname> whether you
    write <literal>%ROWTYPE</literal> or not.  But the form with
    <literal>%ROWTYPE</literal> is more portable.)
   </para>
____________________________________________________________________________-->
   <para>
    通过使用<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>标记，一个行变量可以被声明为具有和一个现有表或视图的行相同的类型。它也可以通过给定一个组合类型名称来声明（因为每一个表都有一个相关联的具有相同名称的组合类型，所以在<productname>PostgreSQL</productname>中实际上写不写<literal>%ROWTYPE</literal>都没有关系。但是带有<literal>%ROWTYPE</literal>的形式可移植性更好）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <literal>$<replaceable>n</replaceable></literal> will be a row variable, and fields can
    be selected from it, for example <literal>$1.user_id</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    一个函数的参数可以是组合类型（完整的表行）。在这种情况下，相应的标识符<literal>$<replaceable>n</replaceable></literal>将是一个行变量，并且可以从中选择域，例如<literal>$1.user_id</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example of using composite types.  <structname>table1</structname>
    and <structname>table2</structname> are existing tables having at least the
    mentioned fields:

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个使用组合类型的例子。<structname>table1</structname>和<structname>table2</structname>是已有的表，它们至少有以下提到的域：

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
<!--==========================orignal english content==========================
   <title>Record Types</title>
____________________________________________________________________________-->
   <title>记录类型</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

<!--==========================orignal english content==========================
   <para>
    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <command>SELECT</command> or <command>FOR</command> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </para>
____________________________________________________________________________-->
   <para>
    记录变量和行类型变量类似，但是它们没有预定义的结构。它们采用在一个<command>SELECT</command>或<command>FOR</command>命令期间为其赋值的行的真实行结构。一个记录变量的子结构能在每次它被赋值时改变。这样的结果是直到一个记录变量第一次被赋值之前，它都没有子结构，并且任何尝试访问其中一个域都会导致一个运行时错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that <literal>RECORD</literal> is not a true data type, only a placeholder.
    One should also realize that when a <application>PL/pgSQL</application>
    function is declared to return type <type>record</type>, this is not quite the
    same concept as a record variable, even though such a function might
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <type>record</type> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
   </para>
____________________________________________________________________________-->
   <para>
    注意<literal>RECORD</literal>并非一个真正的数据类型，只是一个占位符。我们也应该认识到当一个<application>PL/pgSQL</application>函数被声明为返回类型<type>record</type>，这与一个记录变量并不是完全相同的概念，即便这样一个函数可能会用一个记录变量来保持其结果。在两种情况下，编写函数时都不知道真实的行结构，但是对于一个返回<type>record</type>的函数，当调用查询被解析时就已经决定了真正的结构，而一个行变量能够随时改变它的行结构。
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
<!--==========================orignal english content==========================
   <title>Collation of <application>PL/pgSQL</application> Variables</title>
____________________________________________________________________________-->
   <title><application>PL/pgSQL</application>变量的排序规则</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>collation</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>collation</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    When a <application>PL/pgSQL</application> function has one or more
    parameters of collatable data types, a collation is identified for each
    function call depending on the collations assigned to the actual
    arguments, as described in <xref linkend="collation"/>.  If a collation is
    successfully identified (i.e., there are no conflicts of implicit
    collations among the arguments) then all the collatable parameters are
    treated as having that collation implicitly.  This will affect the
    behavior of collation-sensitive operations within the function.
    For example, consider

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    The first use of <function>less_than</function> will use the common collation
    of <structfield>text_field_1</structfield> and <structfield>text_field_2</structfield> for
    the comparison, while the second use will use <literal>C</literal> collation.
   </para>
____________________________________________________________________________-->
   <para>
    当一个<application>PL/pgSQL</application>函数有一个或多个可排序数据类型的参数时，为每一次函数调用都会基于赋值给实参的排序规则来确定出一个排序规则，如<xref linkend="collation"/>中所述。如果一个排序规则被成功地确定（即在参数之间隐式排序规则没有冲突），那么所有的可排序参数会被当做隐式具有那个排序规则。这将在函数中影响行为受到排序规则影响的操作。例如，考虑

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    <function>less_than</function>的第一次使用将会采用<structfield>text_field_1</structfield>和<structfield>text_field_2</structfield>共同的排序规则进行比较，而第二次使用将采用<literal>C</literal>排序规则。
   </para>

<!--==========================orignal english content==========================
   <para>
    Furthermore, the identified collation is also assumed as the collation of
    any local variables that are of collatable types.  Thus this function
    would not work any differently if it were written as

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    此外，被确定的排序规则也被假定为任何可排序数据类型本地变量的排序规则。因此，当这个函数被写为以下形式时，它工作将不会有什么不同

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If there are no parameters of collatable data types, or no common
    collation can be identified for them, then parameters and local variables
    use the default collation of their data type (which is usually the
    database's default collation, but could be different for variables of
    domain types).
   </para>
____________________________________________________________________________-->
   <para>
    如果没有可排序数据类型的参数，或者不能为它们确定共同的排序规则，那么参数和本地变量会使用它们数据类型的默认排序规则（通常是数据库的默认排序规则，但是可能不同于域类型的变量）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A local variable of a collatable data type can have a different collation
    associated with it by including the <literal>COLLATE</literal> option in its
    declaration, for example

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    This option overrides the collation that would otherwise be
    given to the variable according to the rules above.
   </para>
____________________________________________________________________________-->
   <para>
    通过在一个可排序数据类型的本地变量的声明中包括<literal>COLLATE</literal>选项，可以为它指定一个不同的排序规则，例如

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    这个选项会覆盖根据上述规则被给予该变量的排序规则。
   </para>

<!--==========================orignal english content==========================
   <para>
    Also, of course explicit <literal>COLLATE</literal> clauses can be written inside
    a function if it is desired to force a particular collation to be used in
    a particular operation.  For example,

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    This overrides the collations associated with the table columns,
    parameters, or local variables used in the expression, just as would
    happen in a plain SQL command.
   </para>
____________________________________________________________________________-->
   <para>
    还有，如果一个函数想要强制在一个特定操作中使用一个特定排序规则，当然可以在该函数内部写一个显式的<literal>COLLATE</literal>子句。例如：

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    这会覆盖表达式中使用的表列、参数或本地变量相关的排序规则，就像在纯 SQL 命令中发生的一样。
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
<!--==========================orignal english content==========================
  <title>Expressions</title>
____________________________________________________________________________-->
  <title>表达式</title>

<!--==========================orignal english content==========================
    <para>
     All expressions used in <application>PL/pgSQL</application>
     statements are processed using the server's main
     <acronym>SQL</acronym> executor.  For example, when you write
     a <application>PL/pgSQL</application> statement like
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application> will evaluate the expression by
     feeding a query like
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     to the main SQL engine.  While forming the <command>SELECT</command> command,
     any occurrences of <application>PL/pgSQL</application> variable names
     are replaced by parameters, as discussed in detail in
     <xref linkend="plpgsql-var-subst"/>.
     This allows the query plan for the <command>SELECT</command> to
     be prepared just once and then reused for subsequent
     evaluations with different values of the variables.  Thus, what
     really happens on first use of an expression is essentially a
     <command>PREPARE</command> command.  For example, if we have declared
     two integer variables <literal>x</literal> and <literal>y</literal>, and we write
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     what happens behind the scenes is equivalent to
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     and then this prepared statement is <command>EXECUTE</command>d for each
     execution of the <command>IF</command> statement, with the current values
     of the <application>PL/pgSQL</application> variables supplied as
     parameter values.  Normally these details are
     not important to a <application>PL/pgSQL</application> user, but
     they are useful to know when trying to diagnose a problem.
     More information appears in <xref linkend="plpgsql-plan-caching"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>语句中用到的所有表达式会被服务器的主<acronym>SQL</acronym>执行器处理。例如，当你写一个这样的<application>PL/pgSQL</application>语句时
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application>将通过给主 SQL 引擎发送一个查询
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     来计算该表达式。如<xref linkend="plpgsql-var-subst"/>中所详细讨论的，在构造该<command>SELECT</command>命令时，<application>PL/pgSQL</application>变量名的每一次出现会被参数所替换。这允许<command>SELECT</command>的查询计划仅被准备一次并且被重用于之后的对于该变量不同值的计算。因此，在一个表达式第一次被使用时实际发生的本质上是一个<command>PREPARE</command>命令。例如，如果我们已经声明了两个整数变量<literal>x</literal>和<literal>y</literal>，并且我们写了
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     在现象之后发生的等效于
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     并且然后为每一次<command>IF</command>语句的执行，这个预备语句都会被<command>EXECUTE</command>，执行时使用变量的当前值作为参数值。通常这些细节对于一个<application>PL/pgSQL</application>用户并不重要，但是在尝试诊断一个问题时了解它们很有用。更多信息可见<xref linkend="plpgsql-plan-caching"/>。
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
<!--==========================orignal english content==========================
  <title>Basic Statements</title>
____________________________________________________________________________-->
  <title>基本语句</title>

<!--==========================orignal english content==========================
   <para>
    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <application>PL/pgSQL</application>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute,
    as described in <xref linkend="plpgsql-statements-sql-noresult"/>
    and <xref linkend="plpgsql-statements-sql-onerow"/>.
   </para>
____________________________________________________________________________-->
   <para>
    在这一节和接下来的小节中，我们会描述<application>PL/pgSQL</application>能明确理解的所有语句类型。任何不被识别为这些语句类型之一的被假定为是一个 SQL 命令，并且会被发送给主数据库引擎执行，具体如<xref linkend="plpgsql-statements-sql-noresult"/>和<xref linkend="plpgsql-statements-sql-onerow"/>中所述。
   </para>

   <sect2 id="plpgsql-statements-assignment">
<!--==========================orignal english content==========================
    <title>Assignment</title>
____________________________________________________________________________-->
    <title>赋值</title>

<!--==========================orignal english content==========================
    <para>
     An assignment of a value to a <application>PL/pgSQL</application>
     variable is written as:
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</command> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record variable, or an element of an array
     that is a simple variable or field.  Equal (<literal>=</literal>) can be
     used instead of PL/SQL-compliant <literal>:=</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     为一个<application>PL/pgSQL</application>变量赋一个值可以被写为：
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     正如以前所解释的，这样一个语句中的表达式被以一个 SQL
      <command>SELECT</command>命令被发送到主数据库引擎的方式计算。
      该表达式必须得到一个单一值（如果该变量是一个行或记录变量，
      它可能是一个行值）。该目标变量可以是一个简单变量（
      可以选择用一个块名限定）、一个行或记录变量的域或是一个简单
      变量或域的数组元素。
     等号（<literal>=</literal>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the expression's result data type doesn't match the variable's
     data type, the value will be coerced as though by an assignment cast
     (see <xref linkend="typeconv-query"/>).  If no assignment cast is known
     for the pair of data types involved, the <application>PL/pgSQL</application>
     interpreter will attempt to convert the result value textually, that is
     by applying the result type's output function followed by the variable
     type's input function.  Note that this could result in run-time errors
     generated by the input function, if the string form of the result value
     is not acceptable to the input function.
    </para>
____________________________________________________________________________-->
    <para>
     如果该表达式的结果数据类型不匹配变量的数据类型，该值将被强制为变量
     的类型，就好像做了赋值造型一样（见<xref linkend="typeconv-query"/>）。
     如果没有用于所涉及到的数据类型的赋值造型可用，
     <application>PL/pgSQL</application>解释器将尝试以文本的方式转换结果值，也就
     是在应用结果类型的输出函数之后再应用变量类型的输入函数。注意如果结果
     值的字符串形式无法被输入函数所接受，这可能会导致由输入函数产生的运行
     时错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
<!--==========================orignal english content==========================
    <title>Executing a Command With No Result</title>
____________________________________________________________________________-->
    <title>执行一个没有结果的命令</title>

<!--==========================orignal english content==========================
    <para>
     For any SQL command that does not return rows, for example
     <command>INSERT</command> without a <literal>RETURNING</literal> clause, you can
     execute the command within a <application>PL/pgSQL</application> function
     just by writing the command.
    </para>
____________________________________________________________________________-->
    <para>
     对于任何不返回行的 SQL 命令（例如没有一个<literal>RETURNING</literal>子句的<command>INSERT</command>），你可以通过把该命令直接写在一个 <application>PL/pgSQL</application> 函数中执行它。
    </para>

<!--==========================orignal english content==========================
    <para>
     Any <application>PL/pgSQL</application> variable name appearing
     in the command text is treated as a parameter, and then the
     current value of the variable is provided as the parameter value
     at run time.  This is exactly like the processing described earlier
     for expressions; for details see <xref linkend="plpgsql-var-subst"/>.
    </para>
____________________________________________________________________________-->
    <para>
     任何出现在该命令文本中的<application>PL/pgSQL</application>变量名被当作一个参数，并且接着该变量的当前值被提供为运行时该参数的值。这与早前描述的对表达式的处理完全相似，详见<xref linkend="plpgsql-var-subst"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     When executing a SQL command in this way,
     <application>PL/pgSQL</application> may cache and re-use the execution
     plan for the command, as discussed in
     <xref linkend="plpgsql-plan-caching"/>.
    </para>
____________________________________________________________________________-->
    <para>
     当以这种方式执行一个 SQL 命令时，如<xref linkend="plpgsql-plan-caching"/>中讨论的，<application>PL/pgSQL</application>会为该命令缓存并重用执行计划。
    </para>

<!--==========================orignal english content==========================
    <para>
     Sometimes it is useful to evaluate an expression or <command>SELECT</command>
     query but discard the result, for example when calling a function
     that has side-effects but no useful result value.  To do
     this in <application>PL/pgSQL</application>, use the
     <command>PERFORM</command> statement:

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     This executes <replaceable>query</replaceable> and discards the
     result.  Write the <replaceable>query</replaceable> the same
     way you would write an SQL <command>SELECT</command> command, but replace the
     initial keyword <command>SELECT</command> with <command>PERFORM</command>.
     For <command>WITH</command> queries, use <command>PERFORM</command> and then
     place the query in parentheses.  (In this case, the query can only
     return one row.)
     <application>PL/pgSQL</application> variables will be
     substituted into the query just as for commands that return no result,
     and the plan is cached in the same way.  Also, the special variable
     <literal>FOUND</literal> is set to true if the query produced at
     least one row, or false if it produced no rows (see
     <xref linkend="plpgsql-statements-diagnostics"/>).
    </para>
____________________________________________________________________________-->
    <para>
     有时候计算一个表达式或<command>SELECT</command>查询但抛弃其结果是有用的，例如调用一个有副作用但是没有有用的结果值的函数。在<application>PL/pgSQL</application>中要这样做，可使用<command>PERFORM</command>语句：

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     这会执行<replaceable>query</replaceable>并且丢弃掉结果。以写一个SQL <command>SELECT</command>命令相同的方式写该<replaceable>query</replaceable>，并且将初始的关键词<command>SELECT</command>替换为<command>PERFORM</command>。对于<command>WITH</command>查询，使用<command>PERFORM</command>并且接着把该查询放在圆括号中（在这种情况中，该查询只能返回一行）。<application>PL/pgSQL</application>变量将被替换到该查询中，正像对不返回结果的命令所作的那样，并且计划被以相同的方式被缓存。还有，如果该查询产生至少一行，特殊变量<literal>FOUND</literal>会被设置为真，而如果它不产生行则设置为假（见<xref linkend="plpgsql-statements-diagnostics"/>）。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      One might expect that writing <command>SELECT</command> directly
      would accomplish this result, but at
      present the only accepted way to do it is
      <command>PERFORM</command>.  A SQL command that can return rows,
      such as <command>SELECT</command>, will be rejected as an error
      unless it has an <literal>INTO</literal> clause as discussed in the
      next section.
     </para>
____________________________________________________________________________-->
     <para>
      我们可能期望直接写<command>SELECT</command>能实现这个结果，但是当前唯一被接受的方式是<command>PERFORM</command>。一个能返回行的 SQL 命令（例如<command>SELECT</command>）将被当成一个错误拒绝，除非它像下一节中讨论的有一个<literal>INTO</literal>子句。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     An example:
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一个例子：
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
<!--==========================orignal english content==========================
    <title>Executing a Query with a Single-row Result</title>
____________________________________________________________________________-->
    <title>执行一个有单一行结果的查询</title>

<!--==========================orignal english content==========================
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The result of a SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <literal>INTO</literal> clause.  For example,

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     where <replaceable>target</replaceable> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <application>PL/pgSQL</application> variables will be
     substituted into the rest of the query, and the plan is cached,
     just as described above for commands that do not return rows.
     This works for <command>SELECT</command>,
     <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, and utility commands that return row-set
     results (such as <command>EXPLAIN</command>).
     Except for the <literal>INTO</literal> clause, the SQL command is the same
     as it would be written outside <application>PL/pgSQL</application>.
    </para>
____________________________________________________________________________-->
    <para>
     一个产生单一行（可能有多个列）的 SQL 命令的结果可以被赋值给一个记录变量、行类型变量或标量变量列表。这通过书写基础 SQL 命令并增加一个<literal>INTO</literal>子句来达成。例如：

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     其中<replaceable>target</replaceable>可以是一个记录变量、一个行变量或一个有逗号分隔的简单变量和记录/行域列表。<application>PL/pgSQL</application>变量将被替换到该查询的剩余部分中，并且计划会被缓存，正如之前描述的对不返回行的命令所做的。这对<command>SELECT</command>、带有<literal>RETURNING</literal>的<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>以及返回行集结果的工具命令（例如<command>EXPLAIN</command>）。除了<literal>INTO</literal>子句，SQL 命令和它在<application>PL/pgSQL</application>之外的写法一样。
    </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Note that this interpretation of <command>SELECT</command> with <literal>INTO</literal>
     is quite different from <productname>PostgreSQL</productname>'s regular
     <command>SELECT INTO</command> command, wherein the <literal>INTO</literal>
     target is a newly created table.  If you want to create a table from a
     <command>SELECT</command> result inside a
     <application>PL/pgSQL</application> function, use the syntax
     <command>CREATE TABLE ... AS SELECT</command>.
    </para>
____________________________________________________________________________-->
    <para>
     注意带<literal>INTO</literal>的<command>SELECT</command>的这种解释和<productname>PostgreSQL</productname>常规的<command>SELECT INTO</command>命令有很大的不同，后者的<literal>INTO</literal>目标是一个新创建的表。如果你想要在一个<application>PL/pgSQL</application>函数中从一个<command>SELECT</command>的结果创建一个表，请使用语法<command>CREATE TABLE ... AS SELECT</command>。
    </para>
   </tip>

<!--==========================orignal english content==========================
    <para>
     If a row or a variable list is used as target, the query's result columns
     must exactly match the structure of the target as to number and data
     types, or else a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the query result columns.
    </para>
____________________________________________________________________________-->
    <para>
     如果一行或一个变量列表被用作目标，该查询的结果列必须完全匹配该结果的结构，包括数量和数据类型，否则会发生一个运行时错误。当一个记录变量是目标时，它会自动地把自身配置成查询结果列组成的行类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>INTO</literal> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <replaceable>select_expressions</replaceable> in a
     <command>SELECT</command> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <application>PL/pgSQL</application> parser becomes
     stricter in future versions.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>INTO</literal>子句几乎可以出现在 SQL 命令中的任何位置。通常它被写成刚好在<command>SELECT</command>命令中的<replaceable>select_expressions</replaceable>列表之前或之后，或者在其他命令类型的命令最后。我们推荐你遵循这种惯例，以防<application>PL/pgSQL</application>的解析器在未来的版本中变得更严格。
    </para>

<!--==========================orignal english content==========================
    <para>
     If <literal>STRICT</literal> is not specified in the <literal>INTO</literal>
     clause, then <replaceable>target</replaceable> will be set to the first
     row returned by the query, or to nulls if the query returned no rows.
     (Note that <quote>the first row</quote> is not
     well-defined unless you've used <literal>ORDER BY</literal>.)  Any result rows
     after the first row are discarded.
     You can check the special <literal>FOUND</literal> variable (see
     <xref linkend="plpgsql-statements-diagnostics"/>) to
     determine whether a row was returned:

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

     If the <literal>STRICT</literal> option is specified, the query must
     return exactly one row or a run-time error will be reported, either
     <literal>NO_DATA_FOUND</literal> (no rows) or <literal>TOO_MANY_ROWS</literal>
     (more than one row). You can use an exception block if you wish
     to catch the error, for example:

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     Successful execution of a command with <literal>STRICT</literal>
     always sets <literal>FOUND</literal> to true.
    </para>
____________________________________________________________________________-->
    <para>
     如果<literal>STRICT</literal>没有在<literal>INTO</literal>子句中被指定，那么<replaceable>target</replaceable>将被设置为该查询返回的第一个行，或者在该查询不返回行时设置为空（注意除非使用了<literal>ORDER BY</literal>，否则<quote>第一行</quote>的界定并不清楚）。第一行之后的任何结果行都会被抛弃。你可以检查特殊的<literal>FOUND</literal>变量（见<xref linkend="plpgsql-statements-diagnostics"/>）来确定是否返回了一行：

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

     如果指定了<literal>STRICT</literal>选项，该查询必须刚好返回一行或者将会报告一个运行时错误，该错误可能是<literal>NO_DATA_FOUND</literal>（没有行）或<literal>TOO_MANY_ROWS</literal>（多于一行）。如果你希望捕捉该错误，可以使用一个异常块，例如：

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     成功执行一个带<literal>STRICT</literal>的命令总是会将<literal>FOUND</literal>置为真。
    </para>

<!--==========================orignal english content==========================
    <para>
     For <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, <application>PL/pgSQL</application> reports
     an error for more than one returned row, even when
     <literal>STRICT</literal> is not specified.  This is because there
     is no option such as <literal>ORDER BY</literal> with which to determine
     which affected row should be returned.
    </para>
____________________________________________________________________________-->
    <para>
     对于带有<literal>RETURNING</literal>的<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>，即使没有指定<literal>STRICT</literal>，<application>PL/pgSQL</application>也会针对多于一个返回行的情况报告一个错误。这是因为没有类似于<literal>ORDER BY</literal>的选项可以用来决定应该返回哪个被影响的行。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     If <literal>print_strict_params</literal> is enabled for the function,
     then when an error is thrown because the requirements
     of <literal>STRICT</literal> are not met, the <literal>DETAIL</literal> part of
     the error message will include information about the parameters
     passed to the query.
     You can change the <literal>print_strict_params</literal>
     setting for all functions by setting
     <varname>plpgsql.print_strict_params</varname>, though only subsequent
     function compilations will be affected.  You can also enable it
     on a per-function basis by using a compiler option, for example:
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;
</programlisting>
     On failure, this function might produce an error message such as
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     如果为该函数启用了If <literal>print_strict_params</literal>，那么当因为
     <literal>STRICT</literal>的要求没有被满足而抛出一个错误时，该错误消息
     的<literal>DETAIL</literal>将包括传递给该查询的参数信息。可以通过设置
     <varname>plpgsql.print_strict_params</varname>为所有函数更改
     <literal>print_strict_params</literal>设置，但是只有修改后被编译的函数
     才会生效。也可以使用一个编译器选项来为一个函数启用它，例如：
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;
</programlisting>
     失败时，这个函数会产生一个这样的错误消息
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The <literal>STRICT</literal> option matches the behavior of
      Oracle PL/SQL's <command>SELECT INTO</command> and related statements.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>STRICT</literal>选项匹配 Oracle PL/SQL 的<command>SELECT INTO</command>和相关语句的行为。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     To handle cases where you need to process multiple result rows
     from a SQL query, see <xref linkend="plpgsql-records-iterating"/>.
    </para>
____________________________________________________________________________-->
    <para>
     对于要处理来自于一个 SQL 查询的结果行的情况，请见<xref linkend="plpgsql-records-iterating"/>。
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
<!--==========================orignal english content==========================
    <title>Executing Dynamic Commands</title>
____________________________________________________________________________-->
    <title>执行动态命令</title>

<!--==========================orignal english content==========================
    <para>
     Oftentimes you will want to generate dynamic commands inside your
     <application>PL/pgSQL</application> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <application>PL/pgSQL</application>'s
     normal attempts to cache plans for commands (as discussed in
     <xref linkend="plpgsql-plan-caching"/>) will not work in such
     scenarios.  To handle this sort of problem, the
     <command>EXECUTE</command> statement is provided:

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     where <replaceable>command-string</replaceable> is an expression
     yielding a string (of type <type>text</type>) containing the
     command to be executed.  The optional <replaceable>target</replaceable>
     is a record variable, a row variable, or a comma-separated list of
     simple variables and record/row fields, into which the results of
     the command will be stored.  The optional <literal>USING</literal> expressions
     supply values to be inserted into the command.
    </para>
____________________________________________________________________________-->
    <para>
     很多时候你将想要在<application>PL/pgSQL</application>函数中产生动态命令，也就是每次执行中会涉及到不同表或不同数据类型的命令。<application>PL/pgSQL</application>通常对于命令所做的缓存计划尝试（如<xref linkend="plpgsql-plan-caching"/>中讨论）在这种情境下无法工作。要处理这一类问题，需要提供<command>EXECUTE</command>语句：

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     其中<replaceable>command-string</replaceable>是一个能得到一个包含要被执行命令字符串（类型<type>text</type>）的表达式。可选的<replaceable>target</replaceable>是一个记录变量、一个行变量或者一个逗号分隔的简单变量以及记录/行域的列表，该命令的结果将存储在其中。可选的<literal>USING</literal>表达式提供要被插入到该命令中的值。
    </para>

<!--==========================orignal english content==========================
    <para>
     No substitution of <application>PL/pgSQL</application> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
    </para>
____________________________________________________________________________-->
    <para>
     在计算得到的命令字符串中，不会做<application>PL/pgSQL</application>变量的替换。任何所需的变量值必须在命令字符串被构造时被插入其中，或者你可以使用下面描述的参数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, there is no plan caching for commands executed via
     <command>EXECUTE</command>.  Instead, the command is always planned
     each time the statement is run. Thus the command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
    </para>
____________________________________________________________________________-->
    <para>
     还有，对于通过<command>EXECUTE</command>执行的命令不会有计划被缓存。该命令反而在每次运行时都会被做计划。因此，该命令字符串可以在执行不同表和列上动作的函数中被动态创建。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>INTO</literal> clause specifies where the results of
     a SQL command returning rows should be assigned. If a row
     or variable list is provided, it must exactly match the structure
     of the query's results (when a
     record variable is used, it will configure itself to match the
     result structure automatically). If multiple rows are returned,
     only the first will be assigned to the <literal>INTO</literal>
     variable. If no rows are returned, NULL is assigned to the
     <literal>INTO</literal> variable(s). If no <literal>INTO</literal>
     clause is specified, the query results are discarded.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>INTO</literal>子句指定一个返回行的 SQL 命令的结果应该被赋值到哪里。如果提供了一个行或变量列表，它必须完全匹配查询结果的结构（当使用一个记录变量时，它会自动把它自己配置为匹配结果结构）。如果返回多个行，只有第一个行会被赋值给<literal>INTO</literal>变量。如果没有返回行，NULL 会被赋值给<literal>INTO</literal>变量。如果没有指定<literal>INTO</literal>变量，该查询结果会被抛弃。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <literal>STRICT</literal> option is given, an error is reported
     unless the query produces exactly one row.
    </para>
____________________________________________________________________________-->
    <para>
     如果给出了<literal>STRICT</literal>选项，除非该查询刚好产生一行，否则将会报告一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     The command string can use parameter values, which are referenced
     in the command as <literal>$1</literal>, <literal>$2</literal>, etc.
     These symbols refer to values supplied in the <literal>USING</literal>
     clause.  This method is often preferable to inserting data values
     into the command string as text: it avoids run-time overhead of
     converting the values to text and back, and it is much less prone
     to SQL-injection attacks since there is no need for quoting or escaping.
     An example is:
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     命令字符串可以使用参数值，它们在命令中用<literal>$1</literal>、<literal>$2</literal>等引用。这些符号引用在<literal>USING</literal>子句中提供的值。这种方法常常更适合于把数据值作为文本插入到命令字符串中：它避免了将该值转换为文本以及转换回来的运行时负荷，并且它更不容易被 SQL 注入攻击，因为不需要引用或转义。一个例子是：
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that parameter symbols can only be used for data values
     &mdash; if you want to use dynamically determined table or column
     names, you must insert them into the command string textually.
     For example, if the preceding query needed to be done against a
     dynamically selected table, you could do this:
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     A cleaner approach is to use <function>format()</function>'s <literal>%I</literal>
     specification for table or column names (strings separated by a
     newline are concatenated):
<programlisting>
EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;
</programlisting>
     Another restriction on parameter symbols is that they only work in
     <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and
     <command>DELETE</command> commands.  In other statement
     types (generically called utility statements), you must insert
     values textually even if they are just data values.
    </para>
____________________________________________________________________________-->
    <para>
     需要注意的是，参数符号只能用于数据值 &mdash; 如果想要使用动态决定的表名或列名，你必须将它们以文本形式插入到命令字符串中。例如，如果前面的那个查询需要在一个动态选择的表上执行，你可以这么做：
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     一种更干净的方法是为表名或者列名使用<function>format()</function>的
     <literal>%I</literal>规范（被新行分隔的字符串会被串接起来）：
<programlisting>
EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;
</programlisting>
     另一个关于参数符号的限制是，它们只能在<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>命令中工作。在另一种语句类型（通常被称为实用语句）中，即使值是数据值，你也必须将它们以文本形式插入。
    </para>

<!--==========================orignal english content==========================
    <para>
     An <command>EXECUTE</command> with a simple constant command string and some
     <literal>USING</literal> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/pgSQL</application> and allowing replacement of
     <application>PL/pgSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE</command> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/pgSQL</application> may otherwise create a generic plan
     and cache it for re-use.  In situations where the best plan depends
     strongly on the parameter values, it can be helpful to use
     <command>EXECUTE</command> to positively ensure that a generic plan is not
     selected.
    </para>
____________________________________________________________________________-->
    <para>
     在上面第一个例子中，带有一个简单的常量命令字符串和一些<literal>USING</literal>参数的<command>EXECUTE</command>命令在功能上等效于直接用<application>PL/pgSQL</application>写的命令，并且允许自动发生<application>PL/pgSQL</application>变量替换。重要的不同之处在于，<command>EXECUTE</command>会在每一次执行时根据当前的参数值重新规划该命令，而<application>PL/pgSQL</application>则是创建一个通用计划并且将其缓存以便重用。在最佳计划强依赖于参数值的情况中，使用<command>EXECUTE</command>来明确地保证不会选择一个通用计划是很有帮助的。
    </para>

<!--==========================orignal english content==========================
    <para>
     <command>SELECT INTO</command> is not currently supported within
     <command>EXECUTE</command>; instead, execute a plain <command>SELECT</command>
     command and specify <literal>INTO</literal> as part of the <command>EXECUTE</command>
     itself.
    </para>
____________________________________________________________________________-->
    <para>
     <command>EXECUTE</command>目前不支持<command>SELECT INTO</command>。但是可以执行一个纯的<command>SELECT</command>命令并且指定<literal>INTO</literal>作为<command>EXECUTE</command>本身的一部分。
    </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The <application>PL/pgSQL</application>
     <command>EXECUTE</command> statement is not related to the
     <xref linkend="sql-execute"/> SQL
     statement supported by the
     <productname>PostgreSQL</productname> server. The server's
     <command>EXECUTE</command> statement cannot be used directly within
     <application>PL/pgSQL</application> functions (and is not needed).
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>中的<command>EXECUTE</command>语句与<xref linkend="sql-execute"/> <productname>PostgreSQL</productname>服务器支持的 SQL 语句无关。服务器的<command>EXECUTE</command>语句不能直接在<application>PL/pgSQL</application>函数中使用（并且也没有必要）。
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
<!--==========================orignal english content==========================
   <title>Quoting Values In Dynamic Queries</title>
____________________________________________________________________________-->
   <title>在动态查询中引用值</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>quote_ident</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>quote_ident</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>quote_literal</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>quote_literal</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>format</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>format</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     When working with dynamic commands you will often have to handle escaping
     of single quotes.  The recommended method for quoting fixed text in your
     function body is dollar quoting.  (If you have legacy code that does
     not use dollar quoting, please refer to the
     overview in <xref linkend="plpgsql-quote-tips"/>, which can save you
     some effort when translating said code to a more reasonable scheme.)
    </para>
____________________________________________________________________________-->
    <para>
     在使用动态命令时经常不得不处理单引号的转义。我们推荐在函数体中使用美元符号引用来引用固定的文本（如果你有没有使用美元符界定的老代码，请参考<xref linkend="plpgsql-quote-tips"/>中的概述，这样在把上述代码转换成更合理的模式时会省力些）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Dynamic values require careful handling since they might contain
     quote characters.
     An example using <function>format()</function> (this assumes that you are
     dollar quoting the function body so quote marks need not be doubled):
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;
</programlisting>
     It is also possible to call the quoting functions directly:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     动态值需要被小心地处理，因为它们可能包含引号字符。一个使用
     <function>format()</function>的例子（这假设你用美元符号引用了函数
     体，因此引号不需要被双写）：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;
</programlisting>
     还可以直接调用引用函数：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     This example demonstrates the use of the
     <function>quote_ident</function> and
     <function>quote_literal</function> functions (see <xref
     linkend="functions-string"/>).  For safety, expressions containing column
     or table identifiers should be passed through
     <function>quote_ident</function> before insertion in a dynamic query.
     Expressions containing values that should be literal strings in the
     constructed command should be passed through <function>quote_literal</function>.
     These functions take the appropriate steps to return the input text
     enclosed in double or single quotes respectively, with any embedded
     special characters properly escaped.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子展示了<function>quote_ident</function>和<function>quote_literal</function>函数的使用（见<xref linkend="functions-string"/>）。为了安全，在进行一个动态查询中的插入之前，包含列或表标识符的表达式应该通过<function>quote_ident</function>被传递。如果表达式包含在被构造出的命令中应该是字符串的值时，它应该通过<function>quote_literal</function>被传递。这些函数采取适当的步骤来分别返回被封闭在双引号或单引号中的文本，其中任何嵌入的特殊字符都会被正确地转义。
    </para>

<!--==========================orignal english content==========================
    <para>
     Because <function>quote_literal</function> is labeled
     <literal>STRICT</literal>, it will always return null when called with a
     null argument.  In the above example, if <literal>newvalue</literal> or
     <literal>keyvalue</literal> were null, the entire dynamic query string would
     become null, leading to an error from <command>EXECUTE</command>.
     You can avoid this problem by using the <function>quote_nullable</function>
     function, which works the same as <function>quote_literal</function> except that
     when called with a null argument it returns the string <literal>NULL</literal>.
     For example,
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     If you are dealing with values that might be null, you should usually
     use <function>quote_nullable</function> in place of <function>quote_literal</function>.
    </para>
____________________________________________________________________________-->
    <para>
     因为<function>quote_literal</function>被标记为<literal>STRICT</literal>，当用一个空参数调用时，它总是会返回空。在上面的例子中，如果<literal>newvalue</literal>或<literal>keyvalue</literal>为空，整个动态查询字符串会变成空，导致从<command>EXECUTE</command>得到一个错误。可以通过使用<function>quote_nullable</function>函数来避免这种问题，它工作起来和<function>quote_literal</function>相同，除了用空参数调用时会返回一个字符串<literal>NULL</literal>。例如：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     如果正在处理的参数值可能为空，那么通常应该用<function>quote_nullable</function>来代替<function>quote_literal</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
     As always, care must be taken to ensure that null values in a query do
     not deliver unintended results.  For example the <literal>WHERE</literal> clause
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     will never succeed if <literal>keyvalue</literal> is null, because the
     result of using the equality operator <literal>=</literal> with a null operand
     is always null.  If you wish null to work like an ordinary key value,
     you would need to rewrite the above as
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     (At present, <literal>IS NOT DISTINCT FROM</literal> is handled much less
     efficiently than <literal>=</literal>, so don't do this unless you must.
     See <xref linkend="functions-comparison"/> for
     more information on nulls and <literal>IS DISTINCT</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     通常，必须小心地确保查询中的空值不会递送意料之外的结果。例如如果<literal>keyvalue</literal>为空，下面的<literal>WHERE</literal>子句
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     永远不会成功，因为在<literal>=</literal>操作符中使用空操作数得到的结果总是为空。如果想让空和一个普通键值一样工作，你应该将上面的命令重写成
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     （目前，<literal>IS NOT DISTINCT FROM</literal>的处理效率不如<literal>=</literal>，因此只有在非常必要时才这样做。关于空和<literal>IS DISTINCT</literal>的详细信息请见<xref linkend="functions-comparison"/>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that dollar quoting is only useful for quoting fixed text.
     It would be a very bad idea to try to write this example as:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     because it would break if the contents of <literal>newvalue</literal>
     happened to contain <literal>$$</literal>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <emphasis>must</emphasis> use <function>quote_literal</function>,
     <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate.
    </para>
____________________________________________________________________________-->
    <para>
     请注意美元符号引用只对引用固定文本有用。尝试写出下面这个例子是一个非常糟糕的主意：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     因为如果<literal>newvalue</literal>的内容碰巧含有<literal>$$</literal>，那么这段代码就会出问题。同样的缺点可能适用于你选择的任何其他美元符号引用定界符。因此，要想安全地引用事先不知道的文本，<emphasis>必须</emphasis>恰当地使用<function>quote_literal</function>、<function>quote_nullable</function>或<function>quote_ident</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Dynamic SQL statements can also be safely constructed using the
     <function>format</function> function (see <xref
     linkend="functions-string-format"/>). For example:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     <literal>%I</literal> is equivalent to <function>quote_ident</function>, and
     <literal>%L</literal> is equivalent to <function>quote_nullable</function>.
     The <function>format</function> function can be used in conjunction with
     the <literal>USING</literal> clause:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     This form is better because the variables are handled in their native
     data type format, rather than unconditionally converting them to
     text and quoting them via <literal>%L</literal>.  It is also more efficient.
    </para>
____________________________________________________________________________-->
    <para>
     动态 SQL 语句也可以使用<function>format</function>（见<xref linkend="functions-string-format"/>）函数来安全地构造。例如：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     <literal>%I</literal>等效于<function>quote_ident</function>并且
     <literal>%L</literal>等效于<function>quote_nullable</function>。
     <function>format</function>函数可以和
     <literal>USING</literal>子句一起使用：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     这种形式更好，因为变量被以它们天然的数据类型格式处理，而不是无
     条件地把它们转换成文本并且通过<literal>%L</literal>引用它们。这也效率
     更高。
    </para>
   </example>

<!--==========================orignal english content==========================
    <para>
     A much larger example of a dynamic command and
     <command>EXECUTE</command> can be seen in <xref
     linkend="plpgsql-porting-ex2"/>, which builds and executes a
     <command>CREATE FUNCTION</command> command to define a new function.
    </para>
____________________________________________________________________________-->
    <para>
     动态命令和<command>EXECUTE</command>的一个更大的例子可以在<xref linkend="plpgsql-porting-ex2"/>中找到，它会构建并且执行一个<command>CREATE FUNCTION</command>命令来定义一个新的函数。
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
<!--==========================orignal english content==========================
    <title>Obtaining the Result Status</title>
____________________________________________________________________________-->
    <title>获得结果状态</title>

<!--==========================orignal english content==========================
    <para>
     There are several ways to determine the effect of a command. The
     first method is to use the <command>GET DIAGNOSTICS</command>
     command, which has the form:

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     This command allows retrieval of system status indicators.
     <literal>CURRENT</literal> is a noise word (but see also <command>GET STACKED
     DIAGNOSTICS</command> in <xref linkend="plpgsql-exception-diagnostics"/>).
     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-current-diagnostics-values"/>.  Colon-equal
     (<literal>:=</literal>) can be used instead of the SQL-standard <literal>=</literal>
     token.  An example:
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     有好几种方法可以判断一条命令的效果。第一种方法是使用<command>GET DIAGNOSTICS</command>命令，其形式如下：

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     这条命令允许检索系统状态指示符。<literal>CURRENT</literal>是一个噪声词（另见<xref linkend="plpgsql-exception-diagnostics"/>中的<command>GET STACKED DIAGNOSTICS</command>）。每个<replaceable>item</replaceable>是一个关键字， 它标识一个要被赋予给指定<replaceable>变量</replaceable>的状态值（变量应具有正确的数据类型来接收状态值）。<xref linkend="plpgsql-current-diagnostics-values"/>中展示了当前可用的状态项。冒号等号（<literal>:=</literal>）可以被用来取代 SQL 标准的<literal>=</literal>符号。例如：
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>
    
    <table id="plpgsql-current-diagnostics-values">
<!--==========================orignal english content==========================
      <title>Available Diagnostics Items</title>
____________________________________________________________________________-->
      <title>可用的诊断项</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>名称</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
         <entry>the number of rows processed by the most
          recent <acronym>SQL</acronym> command</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
         <entry>最近的<acronym>SQL</acronym>命令处理的行数</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><varname>RESULT_OID</varname></entry>
         <entry><type>oid</type></entry>
         <entry>the OID of the last row inserted by the most
          recent <acronym>SQL</acronym> command (only useful after
          an <command>INSERT</command> command into a table having
          OIDs)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><varname>RESULT_OID</varname></entry>
         <entry><type>oid</type></entry>
         <entry>最近的<acronym>SQL</acronym>命令插入的最后一行的 OID（只有在一条<command>INSERT</command>命令插入到一个具有 OID 的表后才有用）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>line(s) of text describing the current call stack
          (see <xref linkend="plpgsql-call-stack"/>)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>描述当前调用栈的文本行（见<xref linkend="plpgsql-call-stack"/>）</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
    <para>
     The second method to determine the effects of a command is to check the
     special variable named <literal>FOUND</literal>, which is of
     type <type>boolean</type>.  <literal>FOUND</literal> starts out
     false within each <application>PL/pgSQL</application> function call.
     It is set by each of the following types of statements:

         <itemizedlist>
          <listitem>
           <para>
            A <command>SELECT INTO</command> statement sets
            <literal>FOUND</literal> true if a row is assigned, false if no
            row is returned.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>PERFORM</command> statement sets <literal>FOUND</literal>
            true if it produces (and discards) one or more rows, false if
            no row is produced.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>UPDATE</command>, <command>INSERT</command>, and <command>DELETE</command>
            statements set <literal>FOUND</literal> true if at least one
            row is affected, false if no row is affected.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>FETCH</command> statement sets <literal>FOUND</literal>
            true if it returns a row, false if no row is returned.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>MOVE</command> statement sets <literal>FOUND</literal>
            true if it successfully repositions the cursor, false otherwise.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>FOR</command> or <command>FOREACH</command> statement sets
            <literal>FOUND</literal> true
            if it iterates one or more times, else false.
            <literal>FOUND</literal> is set this way when the
            loop exits; inside the execution of the loop,
            <literal>FOUND</literal> is not modified by the
            loop statement, although it might be changed by the
            execution of other statements within the loop body.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>RETURN QUERY</command> and <command>RETURN QUERY
            EXECUTE</command> statements set <literal>FOUND</literal>
            true if the query returns at least one row, false if no row
            is returned.
           </para>
          </listitem>
         </itemizedlist>

     Other <application>PL/pgSQL</application> statements do not change
     the state of <literal>FOUND</literal>.
     Note in particular that <command>EXECUTE</command>
     changes the output of <command>GET DIAGNOSTICS</command>, but
     does not change <literal>FOUND</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     第二种判断命令效果的方法是检查一个名为<literal>FOUND</literal>的<type>boolean</type>类型的特殊变量。在每一次<application>PL/pgSQL</application>函数调用时，<literal>FOUND</literal>开始都为假。它的值会被下面的每一种类型的语句设置：

         <itemizedlist>
          <listitem>
           <para>
            如果一个<command>SELECT INTO</command>语句赋值了一行，它将把<literal>FOUND</literal>设置为真，如果没有返回行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>PERFORM</command>语句生成（并且抛弃）一行或多行，它将把<literal>FOUND</literal>设置为真，如果没有产生行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果<command>UPDATE</command>、<command>INSERT</command>以及<command>DELETE</command>语句影响了至少一行，它们会把<literal>FOUND</literal>设置为真，如果没有影响行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>FETCH</command>语句返回了一行，它将把<literal>FOUND</literal>设置为真，如果没有返回行则将之设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>MOVE</command>语句成功地重定位了游标，它将会把<literal>FOUND</literal>设置为真，否则设置为假。
           </para>
          </listitem>
          <listitem>
           <para>
            如果一个<command>FOR</command>或<command>FOREACH</command>语句迭代了一次或多次，它将会把<literal>FOUND</literal>设置为真，否则设置为假。当循环退出时，<literal>FOUND</literal>用这种方式设置；在循环执行中，尽管<literal>FOUND</literal>可能被循环体中的其他语句的执行所改变，但它不会被循环语句修改。
           </para>
          </listitem>
          <listitem>
           <para>
            如果查询返回至少一行，<command>RETURN QUERY</command>和<command>RETURN QUERY EXECUTE</command>语句会把<literal>FOUND</literal>设为真， 如果没有返回行则设置为假。
           </para>
          </listitem>
         </itemizedlist>

     其他的<application>PL/pgSQL</application>语句不会改变<literal>FOUND</literal>的状态。尤其需要注意的一点是：<command>EXECUTE</command>会修改<command>GET DIAGNOSTICS</command>的输出，但不会修改<literal>FOUND</literal>的输出。
    </para>

<!--==========================orignal english content==========================
    <para>
     <literal>FOUND</literal> is a local variable within each
     <application>PL/pgSQL</application> function; any changes to it
     affect only the current function.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>FOUND</literal>是每个<application>PL/pgSQL</application>函数的局部变量；任何对它的修改只影响当前的函数。
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
<!--==========================orignal english content==========================
    <title>Doing Nothing At All</title>
____________________________________________________________________________-->
    <title>什么也不做</title>

<!--==========================orignal english content==========================
    <para>
     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <command>NULL</command> statement:

<synopsis>
NULL;
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     有时一个什么也不做的占位语句也很有用。例如，它能够指示 if/then/else 链中故意留出的空分支。可以使用<command>NULL</command>语句达到这个目的：

<synopsis>
NULL;
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     For example, the following two fragments of code are equivalent:
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -&minus; ignore the error
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -&minus; ignore the error
END;
</programlisting>
     Which is preferable is a matter of taste.
    </para>
____________________________________________________________________________-->
    <para>
     例如，下面的两段代码是等价的：
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- 忽略错误
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- 忽略错误
END;
</programlisting>
     究竟使用哪一种取决于各人的喜好。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      In Oracle's PL/SQL, empty statement lists are not allowed, and so
      <command>NULL</command> statements are <emphasis>required</emphasis> for situations
      such as this.  <application>PL/pgSQL</application> allows you to
      just write nothing, instead.
     </para>
____________________________________________________________________________-->
     <para>
      在 Oracle 的 PL/SQL 中，不允许出现空语句列表，并且因此在这种情况下<emphasis>必须</emphasis>使用<command>NULL</command>语句。而<application>PL/pgSQL</application>允许你什么也不写。
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
<!--==========================orignal english content==========================
   <title>Control Structures</title>
____________________________________________________________________________-->
   <title>控制结构</title>

<!--==========================orignal english content==========================
   <para>
    Control structures are probably the most useful (and
    important) part of <application>PL/pgSQL</application>. With
    <application>PL/pgSQL</application>'s control structures,
    you can manipulate <productname>PostgreSQL</productname> data in a very
    flexible and powerful way.
   </para>
____________________________________________________________________________-->
   <para>
    控制结构可能是<application>PL/pgSQL</application>中最有用的（以及最重要）的部分了。利用<application>PL/pgSQL</application>的控制结构，你可以以非常灵活而且强大的方法操纵<productname>PostgreSQL</productname>的数据。
   </para>

   <sect2 id="plpgsql-statements-returning">
<!--==========================orignal english content==========================
    <title>Returning From a Function</title>
____________________________________________________________________________-->
    <title>从一个函数返回</title>

<!--==========================orignal english content==========================
    <para>
     There are two commands available that allow you to return data
     from a function: <command>RETURN</command> and <command>RETURN
     NEXT</command>.
    </para>
____________________________________________________________________________-->
    <para>
     有两个命令让我们能够从函数中返回数据：<command>RETURN</command>和<command>RETURN NEXT</command>。
    </para>

    <sect3>
<!--==========================orignal english content==========================
     <title><command>RETURN</command></title>
____________________________________________________________________________-->
     <title><command>RETURN</command></title>

<!--==========================orignal english content==========================
<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
     <para>
      <command>RETURN</command> with an expression terminates the
      function and returns the value of
      <replaceable>expression</replaceable> to the caller.  This form
      is used for <application>PL/pgSQL</application> functions that do
      not return a set.
     </para>
____________________________________________________________________________-->
     <para>
      带有一个表达式的<command>RETURN</command>用于终止函数并把<replaceable>expression</replaceable>的值返回给调用者。这种形式被用于不返回集合的<application>PL/pgSQL</application>函数。
     </para>

<!--==========================orignal english content==========================
     <para>
      In a function that returns a scalar type, the expression's result will
      automatically be cast into the function's return type as described for
      assignments.  But to return a composite (row) value, you must write an
      expression delivering exactly the requested column set.  This may
      require use of explicit casting.
     </para>
____________________________________________________________________________-->
     <para>
      如果一个函数返回一个标量类型，表达式的结果将被自动转换成函数的返回类型。但是要返回一个复合（行）值，你必须写一个正好产生所需列集合的表达式。这可能需要使用显式造型。
     </para>

<!--==========================orignal english content==========================
     <para>
      If you declared the function with output parameters, write just
      <command>RETURN</command> with no expression.  The current values
      of the output parameter variables will be returned.
     </para>
____________________________________________________________________________-->
     <para>
      如果你声明带输出参数的函数，那么就只需要写不带表达式的<command>RETURN</command>。输出参数变量的当前值将被返回。
     </para>

<!--==========================orignal english content==========================
     <para>
      If you declared the function to return <type>void</type>, a
      <command>RETURN</command> statement can be used to exit the function
      early; but do not write an expression following
      <command>RETURN</command>.
     </para>
____________________________________________________________________________-->
     <para>
      如果你声明函数返回<type>void</type>，一个<command>RETURN</command>语句可以被用来提前退出函数；但是不要在<command>RETURN</command>后面写一个表达式。
     </para>

<!--==========================orignal english content==========================
     <para>
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a <command>RETURN</command> statement, a run-time
      error will occur.  This restriction does not apply to functions
      with output parameters and functions returning <type>void</type>,
      however.  In those cases a <command>RETURN</command> statement is
      automatically executed if the top-level block finishes.
     </para>
____________________________________________________________________________-->
     <para>
      一个函数的返回值不能是未定义。如果控制到达了函数最顶层的块而没有碰到一个<command>RETURN</command>语句，那么会发生一个运行时错误。不过，这个限制不适用于带输出参数的函数以及返回<type>void</type>的函数。在这些情况中，如果顶层的块结束，将自动执行一个<command>RETURN</command>语句。
     </para>

<!--==========================orignal english content==========================
     <para>
      Some examples:

<programlisting>
-&minus; functions returning a scalar type
RETURN 1 + 2;
RETURN scalar_var;

-&minus; functions returning a composite type
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -&minus; must cast columns to correct types
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      一些例子：

<programlisting>
-- 返回一个标量类型的函数
RETURN 1 + 2;
RETURN scalar_var;

-- 返回一个组合类型的函数
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- 必须把列造型成正确的类型
</programlisting>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title><command>RETURN NEXT</command> and <command>RETURN QUERY</command></title>
____________________________________________________________________________-->
     <title><command>RETURN NEXT</command>以及<command>RETURN QUERY</command></title>
<!--==========================orignal english content==========================
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!--==========================orignal english content==========================
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

<!--==========================orignal english content==========================
     <para>
      When a <application>PL/pgSQL</application> function is declared to return
      <literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure
      to follow is slightly different.  In that case, the individual
      items to return are specified by a sequence of <command>RETURN
      NEXT</command> or <command>RETURN QUERY</command> commands, and
      then a final <command>RETURN</command> command with no argument
      is used to indicate that the function has finished executing.
      <command>RETURN NEXT</command> can be used with both scalar and
      composite data types; with a composite result type, an entire
      <quote>table</quote> of results will be returned.
      <command>RETURN QUERY</command> appends the results of executing
      a query to the function's result set. <command>RETURN
      NEXT</command> and <command>RETURN QUERY</command> can be freely
      intermixed in a single set-returning function, in which case
      their results will be concatenated.
     </para>
____________________________________________________________________________-->
     <para>
      当一个<application>PL/pgSQL</application>函数被声明为返回<literal>SETOF <replaceable>sometype</replaceable></literal>，那么遵循的过程则略有不同。在这种情况下，要返回的个体项被用一个<command>RETURN NEXT</command>或者<command>RETURN QUERY</command>命令的序列指定，并且接着会用一个不带参数的最终<command>RETURN</command>命令来指示这个函数已经完成执行。<command>RETURN NEXT</command>可以被用于标量和复合数据类型；对于复合类型，将返回一个完整的结果<quote>表</quote>。<command>RETURN QUERY</command>将执行一个查询的结果追加到一个函数的结果集中。在一个单一的返回集合的函数中，<command>RETURN NEXT</command>和<command>RETURN QUERY</command>可以被随意地混合，这样它们的结果将被串接起来。
     </para>

<!--==========================orignal english content==========================
     <para>
      <command>RETURN NEXT</command> and <command>RETURN
      QUERY</command> do not actually return from the function &mdash;
      they simply append zero or more rows to the function's result
      set.  Execution then continues with the next statement in the
      <application>PL/pgSQL</application> function.  As successive
      <command>RETURN NEXT</command> or <command>RETURN
      QUERY</command> commands are executed, the result set is built
      up.  A final <command>RETURN</command>, which should have no
      argument, causes control to exit the function (or you can just
      let control reach the end of the function).
     </para>
____________________________________________________________________________-->
     <para>
      <command>RETURN NEXT</command>和<command>RETURN QUERY</command>实际上不会从函数中返回 &mdash; 它们简单地向函数的结果集中追加零或多行。然后会继续执行<application>PL/pgSQL</application>函数中的下一条语句。随着后继的<command>RETURN NEXT</command>和<command>RETURN QUERY</command>命令的执行，结果集就建立起来了。最后一个<command>RETURN</command>（应该没有参数）会导致控制退出该函数（或者你可以让控制到达函数的结尾）。
     </para>

<!--==========================orignal english content==========================
     <para>
      <command>RETURN QUERY</command> has a variant
      <command>RETURN QUERY EXECUTE</command>, which specifies the
      query to be executed dynamically.  Parameter expressions can
      be inserted into the computed query string via <literal>USING</literal>,
      in just the same way as in the <command>EXECUTE</command> command.
     </para>
____________________________________________________________________________-->
     <para>
      <command>RETURN QUERY</command>有一种变体<command>RETURN QUERY EXECUTE</command>，它可以动态指定要被执行的查询。可以通过<literal>USING</literal>向计算出的查询字符串插入参数表达式，这和在<command>EXECUTE</command>命令中的方式相同。
     </para>

<!--==========================orignal english content==========================
     <para>
      If you declared the function with output parameters, write just
      <command>RETURN NEXT</command> with no expression.  On each
      execution, the current values of the output parameter
      variable(s) will be saved for eventual return as a row of the
      result.  Note that you must declare the function as returning
      <literal>SETOF record</literal> when there are multiple output
      parameters, or <literal>SETOF <replaceable>sometype</replaceable></literal>
      when there is just one output parameter of type
      <replaceable>sometype</replaceable>, in order to create a set-returning
      function with output parameters.
     </para>
____________________________________________________________________________-->
     <para>
      如果你声明函数带有输出参数，只需要写不带表达式的<command>RETURN NEXT</command>。在每一次执行时，输出参数变量的当前值将被保存下来用于最终返回为结果的一行。注意为了创建一个带有输出参数的集合返回函数，在有多个输出参数时，你必须声明函数为返回<literal>SETOF record</literal>；或者如果只有一个类型为<replaceable>sometype</replaceable>的输出参数时，声明函数为<literal>SETOF <replaceable>sometype</replaceable></literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Here is an example of a function using <command>RETURN
      NEXT</command>:

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -&minus; can do some processing here
        RETURN NEXT r; -&minus; return current row of SELECT
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      下面是一个使用<command>RETURN NEXT</command>的函数例子：

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- 这里可以做一些处理
        RETURN NEXT r; -- 返回 SELECT 的当前行
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Here is an example of a function using <command>RETURN
      QUERY</command>:

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

    -&minus; Since execution is not finished, we can check whether rows were returned
    -&minus; and raise exception if not.
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-&minus; Returns available flights or raises exception if there are no
-&minus; available flights.
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      这里是一个使用<command>RETURN QUERY</command>的函数的例子：

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

    -- 因为执行还未结束，我们可以检查是否有行被返回
    -- 如果没有就抛出异常。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- 返回可用的航班或者在没有可用航班时抛出异常。
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>

     <note>
<!--==========================orignal english content==========================
      <para>
       The current implementation of <command>RETURN NEXT</command>
       and <command>RETURN QUERY</command> stores the entire result set
       before returning from the function, as discussed above.  That
       means that if a <application>PL/pgSQL</application> function produces a
       very large result set, performance might be poor: data will be
       written to disk to avoid memory exhaustion, but the function
       itself will not return until the entire result set has been
       generated.  A future version of <application>PL/pgSQL</application> might
       allow users to define set-returning functions
       that do not have this limitation.  Currently, the point at
       which data begins being written to disk is controlled by the
       <xref linkend="guc-work-mem"/>
       configuration variable.  Administrators who have sufficient
       memory to store larger result sets in memory should consider
       increasing this parameter.
      </para>
____________________________________________________________________________-->
      <para>
       如上所述，目前<command>RETURN NEXT</command>和<command>RETURN QUERY</command>的实现在从函数返回之前会把整个结果集都保存起来。这意味着如果一个<application>PL/pgSQL</application>函数生成一个非常大的结果集，性能可能会很差：数据将被写到磁盘上以避免内存耗尽，但是函数本身在整个结果集都生成之前不会退出。将来的<application>PL/pgSQL</application>版本可能会允许用户定义没有这种限制的集合返回函数。目前，数据开始被写入到磁盘的时机由配置变量<xref linkend="guc-work-mem"/>控制。拥有足够内存来存储大型结果集的管理员可以考虑增大这个参数。
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-statements-returning-procedure">
<!--==========================orignal english content==========================
    <title>Returning From a Procedure</title>
____________________________________________________________________________-->
    <title>从过程中返回</title>

<!--==========================orignal english content==========================
    <para>
     A procedure does not have a return value.  A procedure can therefore end
     without a <command>RETURN</command> statement.  If you wish to use
     a <command>RETURN</command> statement to exit the code early, write
     just <command>RETURN</command> with no expression.
    </para>
____________________________________________________________________________-->
    <para>
     过程没有返回值。因此，过程的结束可以不用<command>RETURN</command>语句。
     如果想用一个<command>RETURN</command>语句提前退出代码，只需写一个没有表达式的<command>RETURN</command>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the procedure has output parameters, the final values of the output
     parameter variables will be returned to the caller.
    </para>
____________________________________________________________________________-->
    <para>
     如果过程有输出参数，那么输出参数最终的值会被返回给调用者。
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-calling-procedure">
<!--==========================orignal english content==========================
    <title>Calling a Procedure</title>
____________________________________________________________________________-->
    <title>调用存储过程</title>

<!--==========================orignal english content==========================
    <para>
     A <application>PL/pgSQL</application> function, procedure,
     or <command>DO</command> block can call a procedure
     using <command>CALL</command>.  Output parameters are handled
     differently from the way that <command>CALL</command> works in plain
     SQL.  Each <literal>INOUT</literal> parameter of the procedure must
     correspond to a variable in the <command>CALL</command> statement, and
     whatever the procedure returns is assigned back to that variable after
     it returns.  For example:
<programlisting>
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS $$
BEGIN
    x := x * 3;
END;
$$;

DO $$
DECLARE myvar int := 5;
BEGIN
  CALL triple(myvar);
  RAISE NOTICE 'myvar = %', myvar;  -&minus; prints 15
END
$$;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
<application>PL/pgSQL</application>函数，存储过程或<command>DO</command>块可以使用
<command>CALL</command>调存储用过程。
输出参数的处理方式与纯SQL中<command>CALL</command>的工作方式不同。
存储过程的每个<literal>INOUT</literal>参数必须和<command>CALL</command>语句中的变量对应，
并且无论存储过程返回什么，都会在返回后赋值给该变量。
例如：
<programlisting>
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS $$
BEGIN
    x := x * 3;
END;
$$;

DO $$
DECLARE myvar int := 5;
BEGIN
  CALL triple(myvar);
  RAISE NOTICE 'myvar = %', myvar;  -- prints 15
END
$$;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-conditionals">
<!--==========================orignal english content==========================
    <title>Conditionals</title>
____________________________________________________________________________-->
    <title>条件</title>

<!--==========================orignal english content==========================
    <para>
     <command>IF</command> and <command>CASE</command> statements let you execute
     alternative commands based on certain conditions.
     <application>PL/pgSQL</application> has three forms of <command>IF</command>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

    and two forms of <command>CASE</command>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     <command>IF</command>和<command>CASE</command>语句让你可以根据某种条件执行二选其一的命令。<application>PL/pgSQL</application>有三种形式的<command>IF</command>：
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

    以及两种形式的<command>CASE</command>：
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>IF-THEN</literal></title>
____________________________________________________________________________-->
     <title><literal>IF-THEN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>
____________________________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        <literal>IF-THEN</literal> statements are the simplest form of
        <literal>IF</literal>. The statements between
        <literal>THEN</literal> and <literal>END IF</literal> will be
        executed if the condition is true. Otherwise, they are
        skipped.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>IF-THEN</literal>语句是<command>IF</command>的最简单形式。 如果条件为真，在<literal>THEN</literal>和<literal>END IF</literal>之间的语句将被执行。否则，将忽略它们。
       </para>

<!--==========================orignal english content==========================
       <para>
        Example:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        例子：
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title><literal>IF-THEN-ELSE</literal></title>
____________________________________________________________________________-->
      <title><literal>IF-THEN-ELSE</literal></title>

<!--==========================orignal english content==========================
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>
____________________________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        <literal>IF-THEN-ELSE</literal> statements add to
        <literal>IF-THEN</literal> by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
       </para>
____________________________________________________________________________-->
       <para>
        <literal>IF-THEN-ELSE</literal>语句对<literal>IF-THEN</literal>进行了增加，它让你能够指定一组在条件不为真时应该被执行的语句（注意这也包括条件为 NULL 的情况）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Examples:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
____________________________________________________________________________-->
       <para>
        例子：
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title><literal>IF-THEN-ELSIF</literal></title>
____________________________________________________________________________-->
      <title><literal>IF-THEN-ELSIF</literal></title>

<!--==========================orignal english content==========================
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>
____________________________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        Sometimes there are more than just two alternatives.
        <literal>IF-THEN-ELSIF</literal> provides a convenient
        method of checking several alternatives in turn.
        The <literal>IF</literal> conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after <literal>END IF</literal>.
        (Any subsequent <literal>IF</literal> conditions are <emphasis>not</emphasis>
        tested.)  If none of the <literal>IF</literal> conditions is true,
        then the <literal>ELSE</literal> block (if any) is executed.
       </para>
____________________________________________________________________________-->
       <para>
        有时会有多于两种选择。<literal>IF-THEN-ELSIF</literal>则提供了一个简便的方法来检查多个条件。<literal>IF</literal>条件会被一个接一个测试，直到找到第一个为真的。然后执行相关语句，然后控制会被交给<literal>END IF</literal>之后的下一个语句（后续的任何<literal>IF</literal>条件<emphasis>不会</emphasis>被测试）。如果没有一个<literal>IF</literal>条件为真，那么<literal>ELSE</literal>块（如果有）将被执行。
       </para>

<!--==========================orignal english content==========================
       <para>
        Here is an example:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -&minus; hmm, the only other possibility is that number is null
    result := 'NULL';
END IF;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        这里有一个例子：

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- 嗯，唯一的其他可能性是数字为空
    result := 'NULL';
END IF;
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        The key word <literal>ELSIF</literal> can also be spelled
        <literal>ELSEIF</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        关键词<literal>ELSIF</literal>也可以被拼写成<literal>ELSEIF</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        An alternative way of accomplishing the same task is to nest
        <literal>IF-THEN-ELSE</literal> statements, as in the
        following example:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        另一个可以完成相同任务的方法是嵌套<literal>IF-THEN-ELSE</literal>语句，如下例：

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        However, this method requires writing a matching <literal>END IF</literal>
        for each <literal>IF</literal>, so it is much more cumbersome than
        using <literal>ELSIF</literal> when there are many alternatives.
       </para>
____________________________________________________________________________-->
       <para>
        不过，这种方法需要为每个<literal>IF</literal>都写一个匹配的<literal>END IF</literal>，因此当有很多选择时，这种方法比使用<literal>ELSIF</literal>要麻烦得多。
       </para>
     </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title>Simple <literal>CASE</literal></title>
____________________________________________________________________________-->
      <title>简单<literal>CASE</literal></title>

<!--==========================orignal english content==========================
<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
____________________________________________________________________________-->
<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

<!--==========================orignal english content==========================
      <para>
       The simple form of <command>CASE</command> provides conditional execution
       based on equality of operands.  The <replaceable>search-expression</replaceable>
       is evaluated (once) and successively compared to each
       <replaceable>expression</replaceable> in the <literal>WHEN</literal> clauses.
       If a match is found, then the corresponding
       <replaceable>statements</replaceable> are executed, and then control
       passes to the next statement after <literal>END CASE</literal>.  (Subsequent
       <literal>WHEN</literal> expressions are not evaluated.)  If no match is
       found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are
       executed; but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
____________________________________________________________________________-->
      <para>
       <command>CASE</command>的简单形式提供了基于操作数等值判断的有条件执行。<replaceable>search-expression</replaceable>会被计算（一次）并且一个接一个地与<literal>WHEN</literal>子句中的每个<replaceable>expression</replaceable>比较。如果找到一个匹配，那么相应的<replaceable>statements</replaceable>会被执行，并且接着控制会被交给<literal>END CASE</literal>之后的下一个语句（后续的<literal>WHEN</literal>表达式不会被计算）。如果没有找到匹配，<literal>ELSE</literal> <replaceable>语句</replaceable>会被执行。但是如果<literal>ELSE</literal>不存在，将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>

<!--==========================orignal english content==========================
      <para>
       Here is a simple example:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       这里是一个简单的例子：

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title>Searched <literal>CASE</literal></title>
____________________________________________________________________________-->
      <title>搜索<literal>CASE</literal></title>

<!--==========================orignal english content==========================
<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
____________________________________________________________________________-->
<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

<!--==========================orignal english content==========================
      <para>
       The searched form of <command>CASE</command> provides conditional execution
       based on truth of Boolean expressions.  Each <literal>WHEN</literal> clause's
       <replaceable>boolean-expression</replaceable> is evaluated in turn,
       until one is found that yields <literal>true</literal>.  Then the
       corresponding <replaceable>statements</replaceable> are executed, and
       then control passes to the next statement after <literal>END CASE</literal>.
       (Subsequent <literal>WHEN</literal> expressions are not evaluated.)
       If no true result is found, the <literal>ELSE</literal>
       <replaceable>statements</replaceable> are executed;
       but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
____________________________________________________________________________-->
      <para>
       <command>CASE</command>的搜索形式基于布尔表达式真假的有条件执行。每一个<literal>WHEN</literal>子句的<replaceable>boolean-expression</replaceable>会被依次计算，直到找到一个得到<literal>真</literal>的。然后相应的<replaceable>statements</replaceable>会被执行，并且接下来控制会被传递给<literal>END CASE</literal>之后的下一个语句（后续的<literal>WHEN</literal>表达式不会被计算）。如果没有找到为真的结果，<literal>ELSE</literal> <replaceable>statements</replaceable>会被执行。但是如果<literal>ELSE</literal>不存在，那么将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>

<!--==========================orignal english content==========================
      <para>
       Here is an example:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       这里是一个例子：

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

<!--==========================orignal english content==========================
      <para>
       This form of <command>CASE</command> is entirely equivalent to
       <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching
       an omitted <literal>ELSE</literal> clause results in an error rather
       than doing nothing.
      </para>
____________________________________________________________________________-->
      <para>
       这种形式的<command>CASE</command>整体上等价于<literal>IF-THEN-ELSIF</literal>，不同之处在于<command>CASE</command>到达一个被忽略的<literal>ELSE</literal>子句时会导致一个错误而不是什么也不做。
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
<!--==========================orignal english content==========================
    <title>Simple Loops</title>
____________________________________________________________________________-->
    <title>简单循环</title>

<!--==========================orignal english content==========================
    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>在 PL/pgSQL 中</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     With the <literal>LOOP</literal>, <literal>EXIT</literal>,
     <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>,
     and <literal>FOREACH</literal> statements, you can arrange for your
     <application>PL/pgSQL</application> function to repeat a series of commands.
    </para>
____________________________________________________________________________-->
    <para>
     使用<literal>LOOP</literal>、<literal>EXIT</literal>、<literal>CONTINUE</literal>、<literal>WHILE</literal>、<literal>FOR</literal>和<literal>FOREACH</literal>语句，你可以安排<application>PL/pgSQL</application>重复一系列命令。
    </para>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>LOOP</literal></title>
____________________________________________________________________________-->
     <title><literal>LOOP</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

<!--==========================orignal english content==========================
     <para>
      <literal>LOOP</literal> defines an unconditional loop that is repeated
      indefinitely until terminated by an <literal>EXIT</literal> or
      <command>RETURN</command> statement.  The optional
      <replaceable>label</replaceable> can be used by <literal>EXIT</literal>
      and <literal>CONTINUE</literal> statements within nested loops to
      specify which loop those statements refer to.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>LOOP</literal>定义一个无条件的循环，它会无限重复直到被<literal>EXIT</literal>或<command>RETURN</command>语句终止。可选的<replaceable>label</replaceable>可以被<literal>EXIT</literal>和<literal>CONTINUE</literal>语句用在嵌套循环中指定这些语句引用的是哪一层循环。
     </para>
    </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title><literal>EXIT</literal></title>
____________________________________________________________________________-->
      <title><literal>EXIT</literal></title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>EXIT</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<!--==========================orignal english content==========================
<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        If no <replaceable>label</replaceable> is given, the innermost
        loop is terminated and the statement following <literal>END
        LOOP</literal> is executed next.  If <replaceable>label</replaceable>
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding <literal>END</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果没有给出<replaceable>label</replaceable>，那么最内层的循环会被终止，然后跟在<literal>END LOOP</literal>后面的语句会被执行。如果给出了<replaceable>label</replaceable>，那么它必须是当前或者更高层的嵌套循环或者语句块的标签。然后该命名循环或块就会被终止，并且控制会转移到该循环/块相应的<literal>END</literal>之后的语句上。
       </para>

<!--==========================orignal english content==========================
       <para>
        If <literal>WHEN</literal> is specified, the loop exit occurs only if
        <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes
        to the statement after <literal>EXIT</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果指定了<literal>WHEN</literal>，只有<replaceable>boolean-expression</replaceable>为真时才会发生循环退出。否则，控制会转移到<literal>EXIT</literal>之后的语句。
       </para>

<!--==========================orignal english content==========================
       <para>
        <literal>EXIT</literal> can be used with all types of loops; it is
        not limited to use with unconditional loops.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>EXIT</literal>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>

<!--==========================orignal english content==========================
       <para>
        When used with a
        <literal>BEGIN</literal> block, <literal>EXIT</literal> passes
        control to the next statement after the end of the block.
        Note that a label must be used for this purpose; an unlabeled
        <literal>EXIT</literal> is never considered to match a
        <literal>BEGIN</literal> block.  (This is a change from
        pre-8.4 releases of <productname>PostgreSQL</productname>, which
        would allow an unlabeled <literal>EXIT</literal> to match
        a <literal>BEGIN</literal> block.)
       </para>
____________________________________________________________________________-->
       <para>
        在和<literal>BEGIN</literal>块一起使用时，<literal>EXIT</literal>会把控制交给块结束后的下一个语句。需要注意的是，一个标签必须被用于这个目的；一个没有被标记的<literal>EXIT</literal>永远无法被认为与一个<literal>BEGIN</literal>块匹配（这种状况从<productname>PostgreSQL</productname> 8.4 之前的发布就已经开始改变。这可能允许一个未被标记的<literal>EXIT</literal>匹配一个<literal>BEGIN</literal>块）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Examples:
<programlisting>
LOOP
    -&minus; some computations
    IF count &gt; 0 THEN
        EXIT;  -&minus; exit loop
    END IF;
END LOOP;

LOOP
    -&minus; some computations
    EXIT WHEN count &gt; 0;  -&minus; same result as previous example
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -&minus; some computations
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -&minus; causes exit from the BEGIN block
    END IF;
    -&minus; computations here will be skipped when stocks &gt; 100000
END;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    IF count &gt; 0 THEN
        EXIT;  -- 退出循环
    END IF;
END LOOP;

LOOP
    -- 一些计算
    EXIT WHEN count &gt; 0;  -- 和前一个例子相同的结果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- 一些计算
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- 导致从 BEGIN 块中退出
    END IF;
    -- 当stocks &gt; 100000时，这里的计算将被跳过
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
<!--==========================orignal english content==========================
      <title><literal>CONTINUE</literal></title>
____________________________________________________________________________-->
      <title><literal>CONTINUE</literal></title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<!--==========================orignal english content==========================
<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        If no <replaceable>label</replaceable> is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If <replaceable>label</replaceable> is present, it
        specifies the label of the loop whose execution will be
        continued.
       </para>
____________________________________________________________________________-->
       <para>
        如果没有给出<replaceable>label</replaceable>，最内层循环的下一次迭代会开始。也就是，循环体中剩余的所有语句将被跳过，并且控制会返回到循环控制表达式（如果有）来决定是否需要另一次循环迭代。如果<replaceable>label</replaceable>存在，它指定应该继续执行的循环的标签。
       </para>

<!--==========================orignal english content==========================
       <para>
        If <literal>WHEN</literal> is specified, the next iteration of the
        loop is begun only if <replaceable>boolean-expression</replaceable> is
        true. Otherwise, control passes to the statement after
        <literal>CONTINUE</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果指定了<literal>WHEN</literal>，该循环的下一次迭代只有在<replaceable>boolean-expression</replaceable>为真时才会开始。否则，控制会传递给<literal>CONTINUE</literal>后面的语句。
       </para>

<!--==========================orignal english content==========================
       <para>
        <literal>CONTINUE</literal> can be used with all types of loops; it
        is not limited to use with unconditional loops.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>CONTINUE</literal>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>

<!--==========================orignal english content==========================
       <para>
        Examples:
<programlisting>
LOOP
    -&minus; some computations
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -&minus; some computations for count IN [50 .. 100]
END LOOP;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- 一些用于 count IN [50 .. 100] 的计算
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
<!--==========================orignal english content==========================
      <title><literal>WHILE</literal></title>
____________________________________________________________________________-->
      <title><literal>WHILE</literal></title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>WHILE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        The <literal>WHILE</literal> statement repeats a
        sequence of statements so long as the
        <replaceable>boolean-expression</replaceable>
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
       </para>
____________________________________________________________________________-->
       <para>
        只要<replaceable>boolean-expression</replaceable>被计算为真，<literal>WHILE</literal>语句就会重复一个语句序列。在每次进入到循环体之前都会检查该表达式。
       </para>

<!--==========================orignal english content==========================
       <para>
        For example:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -&minus; some computations here
END LOOP;

WHILE NOT done LOOP
    -&minus; some computations here
END LOOP;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        例如：
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- 这里是一些计算
END LOOP;

WHILE NOT done LOOP
    -- 这里是一些计算
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
<!--==========================orignal english content==========================
      <title><literal>FOR</literal> (Integer Variant)</title>
____________________________________________________________________________-->
      <title><literal>FOR</literal>（整型变体）</title>

<!--==========================orignal english content==========================
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        This form of <literal>FOR</literal> creates a loop that iterates over a range
        of integer values. The variable
        <replaceable>name</replaceable> is automatically defined as type
        <type>integer</type> and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the <literal>BY</literal> clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the <literal>BY</literal>
        clause, which again is evaluated once on loop entry.
        If <literal>REVERSE</literal> is specified then the step value is
        subtracted, rather than added, after each iteration.
       </para>
____________________________________________________________________________-->
       <para>
        这种形式的<literal>FOR</literal>会创建一个在一个整数范围上迭代的循环。变量<replaceable>name</replaceable>会自动定义为类型<type>integer</type>并且只在循环内存在（任何该变量名的现有定义在此循环内都将被忽略）。给出范围上下界的两个表达式在进入循环的时候计算一次。如果没有指定<literal>BY</literal>子句，迭代步长为 1，否则步长是<literal>BY</literal>中指定的值，该值也只在循环进入时计算一次。如果指定了<literal>REVERSE</literal>，那么在每次迭代后步长值会被减除而不是增加。
       </para>

<!--==========================orignal english content==========================
       <para>
        Some examples of integer <literal>FOR</literal> loops:
<programlisting>
FOR i IN 1..10 LOOP
    -&minus; i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -&minus; i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -&minus; i will take on the values 10,8,6,4,2 within the loop
END LOOP;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        整数<literal>FOR</literal>循环的一些例子：
<programlisting>
FOR i IN 1..10 LOOP
    -- 我在循环中将取值 1,2,3,4,5,6,7,8,9,10 
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- 我在循环中将取值 10,9,8,7,6,5,4,3,2,1 
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- 我在循环中将取值 10,8,6,4,2 
END LOOP;
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        If the lower bound is greater than the upper bound (or less than,
        in the <literal>REVERSE</literal> case), the loop body is not
        executed at all.  No error is raised.
       </para>
____________________________________________________________________________-->
       <para>
        如果下界大于上界（或者在<literal>REVERSE</literal>情况下是小于），循环体根本不会被执行。而且不会抛出任何错误。
       </para>

<!--==========================orignal english content==========================
       <para>
        If a <replaceable>label</replaceable> is attached to the
        <literal>FOR</literal> loop then the integer loop variable can be
        referenced with a qualified name, using that
        <replaceable>label</replaceable>.
       </para>
____________________________________________________________________________-->
       <para>
        如果一个<replaceable>label</replaceable>被附加到<literal>FOR</literal>循环，那么整数循环变量可以用一个使用那个<replaceable>label</replaceable>的限定名引用。
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
<!--==========================orignal english content==========================
    <title>Looping Through Query Results</title>
____________________________________________________________________________-->
    <title>通过查询结果循环</title>

<!--==========================orignal english content==========================
    <para>
     Using a different type of <literal>FOR</literal> loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     The <replaceable>target</replaceable> is a record variable, row variable,
     or comma-separated list of scalar variables.
     The <replaceable>target</replaceable> is successively assigned each row
     resulting from the <replaceable>query</replaceable> and the loop body is
     executed for each row. Here is an example:
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -&minus; Now "mviews" has one record from cs_materialized_views

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     If the loop is terminated by an <literal>EXIT</literal> statement, the last
     assigned row value is still accessible after the loop.
    </para>
____________________________________________________________________________-->
    <para>
     使用一种不同类型的<literal>FOR</literal>循环，你可以通过一个查询的结果进行迭代并且操纵相应的数据。语法是：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <replaceable>target</replaceable>是一个记录变量、行变量或者逗号分隔的标量变量列表。<replaceable>target</replaceable>被连续不断被赋予来自<replaceable>query</replaceable>的每一行，并且循环体将为每一行执行一次。下面是一个例子：
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- 现在 "mviews" 有一个来自于 cs_materialized_views 的记录

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     如果循环被一个<literal>EXIT</literal>语句终止，那么在循环之后你仍然可以访问最后被赋予的行值。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <replaceable>query</replaceable> used in this type of <literal>FOR</literal>
     statement can be any SQL command that returns rows to the caller:
     <command>SELECT</command> is the most common case,
     but you can also use <command>INSERT</command>, <command>UPDATE</command>, or
     <command>DELETE</command> with a <literal>RETURNING</literal> clause.  Some utility
     commands such as <command>EXPLAIN</command> will work too.
    </para>
____________________________________________________________________________-->
    <para>
     在这类<literal>FOR</literal>语句中使用的<replaceable>query</replaceable>可以是任何返回行给调用者的 SQL 命令：最常见的是<command>SELECT</command>，但你也可以使用带有<literal>RETURNING</literal>子句的<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>。一些<command>EXPLAIN</command>之类的功能性命令也可以用在这里。
    </para>

<!--==========================orignal english content==========================
    <para>
     <application>PL/pgSQL</application> variables are substituted into the query text,
     and the query plan is cached for possible re-use, as discussed in
     detail in <xref linkend="plpgsql-var-subst"/> and
     <xref linkend="plpgsql-plan-caching"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>变量会被替换到查询文本中，并且如<xref linkend="plpgsql-var-subst"/>和<xref linkend="plpgsql-plan-caching"/>中详细讨论的，查询计划会被缓存以用于可能的重用。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>FOR-IN-EXECUTE</literal> statement is another way to iterate over
     rows:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the <literal>FOR</literal> loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain <command>EXECUTE</command> statement.
     As with <command>EXECUTE</command>, parameter values can be inserted
     into the dynamic command via <literal>USING</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>FOR-IN-EXECUTE</literal>语句是在行上迭代的另一种方式：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     这个例子类似前面的形式，只不过源查询被指定为一个字符串表达式，在每次进入<literal>FOR</literal>循环时都会计算它并且重新规划。这允许程序员在一个预先规划好了的命令的速度和一个动态命令的灵活性之间进行选择，就像一个纯<command>EXECUTE</command>语句那样。在使用<command>EXECUTE</command>时，可以通过<literal>USING</literal>将参数值插入到动态命令中。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     <xref linkend="plpgsql-cursor-for-loop"/>.
    </para>
____________________________________________________________________________-->
    <para>
     另一种指定要对其结果迭代的查询的方式是将它声明为一个游标。这会在<xref linkend="plpgsql-cursor-for-loop"/>中描述。
    </para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
<!--==========================orignal english content==========================
    <title>Looping Through Arrays</title>
____________________________________________________________________________-->
    <title>通过数组循环</title>

<!--==========================orignal english content==========================
    <para>
     The <literal>FOREACH</literal> loop is much like a <literal>FOR</literal> loop,
     but instead of iterating through the rows returned by a SQL query,
     it iterates through the elements of an array value.
     (In general, <literal>FOREACH</literal> is meant for looping through
     components of a composite-valued expression; variants for looping
     through composites besides arrays may be added in future.)
     The <literal>FOREACH</literal> statement to loop over an array is:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     <literal>FOREACH</literal>循环很像一个<literal>FOR</literal>循环，但不是通过一个 SQL 查询返回的行进行迭代，它通过一个数组值的元素来迭代（通常，<literal>FOREACH</literal>意味着通过一个组合值表达式的部件迭代；用于通过除数组之外组合类型进行循环的变体可能会在未来被加入）。在一个数组上循环的<literal>FOREACH</literal>语句是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal> is specified,
     the loop iterates through individual elements of the array produced
     by evaluating the <replaceable>expression</replaceable>.
     The <replaceable>target</replaceable> variable is assigned each
     element value in sequence, and the loop body is executed for each element.
     Here is an example of looping through the elements of an integer
     array:

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     The elements are visited in storage order, regardless of the number of
     array dimensions.  Although the <replaceable>target</replaceable> is
     usually just a single variable, it can be a list of variables when
     looping through an array of composite values (records).  In that case,
     for each array element, the variables are assigned from successive
     columns of the composite value.
    </para>
____________________________________________________________________________-->
    <para>
     如果没有<literal>SLICE</literal>，或者如果没有指定<literal>SLICE 0</literal>，循环会通过计算<replaceable>expression</replaceable>得到的数组的个体元素进行迭代。<replaceable>target</replaceable>变量被逐一赋予每一个元素值，并且循环体会为每一个元素执行。这里是一个通过整数数组的元素循环的例子：

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     元素会被按照存储顺序访问，而不管数组的维度数。尽管<replaceable>target</replaceable>通常只是一个单一变量，当通过一个组合值（记录）的数组循环时，它可以是一个变量列表。在那种情况下，对每一个数组元素，变量会被从组合值的连续列赋值。
    </para>

<!--==========================orignal english content==========================
    <para>
     With a positive <literal>SLICE</literal> value, <literal>FOREACH</literal>
     iterates through slices of the array rather than single elements.
     The <literal>SLICE</literal> value must be an integer constant not larger
     than the number of dimensions of the array.  The
     <replaceable>target</replaceable> variable must be an array,
     and it receives successive slices of the array value, where each slice
     is of the number of dimensions specified by <literal>SLICE</literal>.
     Here is an example of iterating through one-dimensional slices:

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     通过一个正<literal>SLICE</literal>值，<literal>FOREACH</literal>通过数组的切片而不是单一元素迭代。<literal>SLICE</literal>值必须是一个不大于数组维度数的整数常量。<replaceable>target</replaceable>变量必须是一个数组，并且它接收数组值的连续切片，其中每一个切片都有<literal>SLICE</literal>指定的维度数。这里是一个通过一维切片迭代的例子：

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
<!--==========================orignal english content==========================
    <title>Trapping Errors</title>
____________________________________________________________________________-->
    <title>俘获错误</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     By default, any error occurring in a <application>PL/pgSQL</application>
     function aborts execution of the function, and indeed of the
     surrounding transaction as well.  You can trap errors and recover
     from them by using a <command>BEGIN</command> block with an
     <literal>EXCEPTION</literal> clause.  The syntax is an extension of the
     normal syntax for a <command>BEGIN</command> block:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     默认情况下，任何在<application>PL/pgSQL</application>函数中发生的错误会中止该函数的执行，而且实际上会中止其周围的事务。你可以使用一个带有<literal>EXCEPTION</literal>子句的<command>BEGIN</command>块俘获错误并且从中恢复。其语法是<command>BEGIN</command>块通常的语法的一个扩展：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     If no error occurs, this form of block simply executes all the
     <replaceable>statements</replaceable>, and then control passes
     to the next statement after <literal>END</literal>.  But if an error
     occurs within the <replaceable>statements</replaceable>, further
     processing of the <replaceable>statements</replaceable> is
     abandoned, and control passes to the <literal>EXCEPTION</literal> list.
     The list is searched for the first <replaceable>condition</replaceable>
     matching the error that occurred.  If a match is found, the
     corresponding <replaceable>handler_statements</replaceable> are
     executed, and then control passes to the next statement after
     <literal>END</literal>.  If no match is found, the error propagates out
     as though the <literal>EXCEPTION</literal> clause were not there at all:
     the error can be caught by an enclosing block with
     <literal>EXCEPTION</literal>, or if there is none it aborts processing
     of the function.
    </para>
____________________________________________________________________________-->
    <para>
     如果没有发生错误，这种形式的块只是简单地执行所有<replaceable>statements</replaceable>， 并且接着控制转到<literal>END</literal>之后的下一个语句。但是如果在<replaceable>statements</replaceable>内发生了一个错误，则会放弃对<replaceable>statements</replaceable>的进一步处理，然后控制会转到<literal>EXCEPTION</literal>列表。系统会在列表中寻找匹配所发生错误的第一个<replaceable>condition</replaceable>。如果找到一个匹配，则执行对应的<replaceable>handler_statements</replaceable>，并且接着把控制转到<literal>END</literal>之后的下一个语句。如果没有找到匹配，该错误就会传播出去，就好像根本没有<literal>EXCEPTION</literal>一样：错误可以被一个带有<literal>EXCEPTION</literal>的闭合块捕捉，如果没有<literal>EXCEPTION</literal>则中止该函数的处理。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <replaceable>condition</replaceable> names can be any of
     those shown in <xref linkend="errcodes-appendix"/>.  A category
     name matches any error within its category.  The special
     condition name <literal>OTHERS</literal> matches every error type except
     <literal>QUERY_CANCELED</literal> and <literal>ASSERT_FAILURE</literal>.
     (It is possible, but often unwise, to trap those two error types
     by name.)  Condition names are
     not case-sensitive.  Also, an error condition can be specified
     by <literal>SQLSTATE</literal> code; for example these are equivalent:
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>condition</replaceable>的名字可以是<xref linkend="errcodes-appendix"/>中显示的任何名字。一个分类名匹配其中所有的错误。特殊的条件名<literal>OTHERS</literal>匹配除了<literal>QUERY_CANCELED</literal>和<literal>ASSERT_FAILURE</literal>之外的所有错误类型（虽然通常并不明智，还是可以用名字捕获这两种错误类型）。条件名是大小写无关的。一个错误条件也可以通过<literal>SQLSTATE</literal>代码指定，例如以下是等价的：
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     If a new error occurs within the selected
     <replaceable>handler_statements</replaceable>, it cannot be caught
     by this <literal>EXCEPTION</literal> clause, but is propagated out.
     A surrounding <literal>EXCEPTION</literal> clause could catch it.
    </para>
____________________________________________________________________________-->
    <para>
     如果在选中的<replaceable>handler_statements</replaceable>内发生了新的错误，那么它不能被这个<literal>EXCEPTION</literal>子句捕获，而是被传播出去。一个外层的<literal>EXCEPTION</literal>子句可以捕获它。
    </para>

<!--==========================orignal english content==========================
    <para>
     When an error is caught by an <literal>EXCEPTION</literal> clause,
     the local variables of the <application>PL/pgSQL</application> function
     remain as they were when the error occurred, but all changes
     to persistent database state within the block are rolled back.
     As an example, consider this fragment:

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

     When control reaches the assignment to <literal>y</literal>, it will
     fail with a <literal>division_by_zero</literal> error.  This will be caught by
     the <literal>EXCEPTION</literal> clause.  The value returned in the
     <command>RETURN</command> statement will be the incremented value of
     <literal>x</literal>, but the effects of the <command>UPDATE</command> command will
     have been rolled back.  The <command>INSERT</command> command preceding the
     block is not rolled back, however, so the end result is that the database
     contains <literal>Tom Jones</literal> not <literal>Joe Jones</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     当一个错误被<literal>EXCEPTION</literal>捕获时，<application>PL/pgSQL</application>函数的局部变量会保持错误发生时的值，但是该块中所有对持久数据库状态的改变都会被回滚。例如，考虑这个片段：

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

     当控制到达对<literal>y</literal>赋值的地方时，它会带着一个<literal>division_by_zero</literal>错误失败。这个错误将被<literal>EXCEPTION</literal>子句捕获。而在<command>RETURN</command>语句中返回的值将是<literal>x</literal>增加过后的值。但是<command>UPDATE</command>命令的效果将已经被回滚。不过，在该块之前的<command>INSERT</command>将不会被回滚，因此最终的结果是数据库包含<literal>Tom Jones</literal>但不包含<literal>Joe Jones</literal>。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      A block containing an <literal>EXCEPTION</literal> clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use <literal>EXCEPTION</literal> without need.
     </para>
____________________________________________________________________________-->
     <para>
      进入和退出一个包含<literal>EXCEPTION</literal>子句的块要比不包含<literal>EXCEPTION</literal>的块开销大的多。因此，只在必要的时候使用<literal>EXCEPTION</literal>。
     </para>
    </tip>

    <example id="plpgsql-upsert-example">
<!--==========================orignal english content==========================
    <title>Exceptions with <command>UPDATE</command>/<command>INSERT</command></title>
____________________________________________________________________________-->
    <title><command>UPDATE</command>/<command>INSERT</command>的异常</title>
<!--==========================orignal english content==========================
    <para>

    This example uses exception handling to perform either
    <command>UPDATE</command> or <command>INSERT</command>, as appropriate.  It is
    recommended that applications use <command>INSERT</command> with
    <literal>ON CONFLICT DO UPDATE</literal> rather than actually using
    this pattern.  This example serves primarily to illustrate use of
    <application>PL/pgSQL</application> control flow structures:

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -&minus; first try to update the key
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -&minus; not there, so try to insert the key
        -&minus; if someone else inserts the same key concurrently,
        -&minus; we could get a unique-key failure
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -&minus; Do nothing, and loop to try the UPDATE again.
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     This coding assumes the <literal>unique_violation</literal> error is caused by
     the <command>INSERT</command>, and not by, say, an <command>INSERT</command> in a
     trigger function on the table.  It might also misbehave if there is
     more than one unique index on the table, since it will retry the
     operation regardless of which index caused the error.
     More safety could be had by using the
     features discussed next to check that the trapped error was the one
     expected.
    </para>
____________________________________________________________________________-->
    <para>
    这个例子使用异常处理来酌情执行<command>UPDATE</command>或
    <command>INSERT</command>。我们推荐应用使用带有
    <literal>ON CONFLICT DO UPDATE</literal>的<command>INSERT</command>
    而不是真正使用这种模式。下面的例子主要是为了展示
    <application>PL/pgSQL</application>如何控制流程：

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- 首先尝试更新见
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- 不在这里，那么尝试插入该键
        -- 如果其他某人并发地插入同一个键，
        -- 我们可能得到一个唯一键失败
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- 什么也不做，并且循环再次尝试 UPDATE
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     这段代码假定<literal>unique_violation</literal>错误是<command>INSERT</command>造成，并且不是由该表上一个触发器函数中的<command>INSERT</command>导致。如果在该表上有多于一个唯一索引，也可能会发生不正确的行为，因为不管哪个索引导致该错误它都将重试该操作。通过接下来要讨论的特性来检查被捕获的错误是否为所预期的会更安全。
    </para>
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
<!--==========================orignal english content==========================
    <title>Obtaining Information About an Error</title>
____________________________________________________________________________-->
    <title>得到有关一个错误的信息</title>

<!--==========================orignal english content==========================
    <para>
     Exception handlers frequently need to identify the specific error that
     occurred.  There are two ways to get information about the current
     exception in <application>PL/pgSQL</application>: special variables and the
     <command>GET STACKED DIAGNOSTICS</command> command.
    </para>
____________________________________________________________________________-->
    <para>
     异常处理器经常被用来标识发生的特定错误。有两种方法来得到<application>PL/pgSQL</application>中当前异常的信息：特殊变量和<command>GET STACKED DIAGNOSTICS</command>命令。
    </para>

<!--==========================orignal english content==========================
    <para>
     Within an exception handler, the special variable
     <varname>SQLSTATE</varname> contains the error code that corresponds to
     the exception that was raised (refer to <xref linkend="errcodes-table"/>
     for a list of possible error codes). The special variable
     <varname>SQLERRM</varname> contains the error message associated with the
     exception. These variables are undefined outside exception handlers.
    </para>
____________________________________________________________________________-->
    <para>
     在一个异常处理器内，特殊变量<varname>SQLSTATE</varname>包含了对应于被抛出异常的错误代码（可能的错误代码列表见<xref linkend="errcodes-table"/>）。特殊变量<varname>SQLERRM</varname>包含与该异常相关的错误消息。这些变量在异常处理器外是未定义的。
    </para>

<!--==========================orignal english content==========================
    <para>
     Within an exception handler, one may also retrieve
     information about the current exception by using the
     <command>GET STACKED DIAGNOSTICS</command> command, which has the form:

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-exception-diagnostics-values"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在一个异常处理器内，我们也可以用<command>GET STACKED DIAGNOSTICS</command>命令检索有关当前异常的信息，该命令的形式为：

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     每个<replaceable>item</replaceable>是一个关键词，它标识一个被赋予给指定<replaceable>变量</replaceable>（应该具有接收该值的正确数据类型）的状态值。<xref linkend="plpgsql-exception-diagnostics-values"/>中显示了当前可用的状态项。
    </para>

     <table id="plpgsql-exception-diagnostics-values">
<!--==========================orignal english content==========================
      <title>Error Diagnostics Items</title>
____________________________________________________________________________-->
      <title>错误诊断项</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>名称</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
         <entry>the SQLSTATE error code of the exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的 SQLSTATE 错误代码</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the column related to exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的列名</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the constraint related to exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的约束名</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the data type related to exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的数据类型名</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's primary message</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的主要消息的文本</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the table related to exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的表名</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the schema related to exception</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的模式名</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's detail message, if any</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的详细消息文本（如果有）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's hint message, if any</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的提示消息文本（如果有）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>line(s) of text describing the call stack at the time of the
          exception (see <xref linkend="plpgsql-call-stack"/>)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>描述产生异常时调用栈的文本行（见<xref linkend="plpgsql-call-stack"/>）</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
    <para>
     If the exception did not set a value for an item, an empty string
     will be returned.
    </para>
____________________________________________________________________________-->
    <para>
     如果异常没有为一个项设置值，将返回一个空字符串。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example:
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -&minus; some processing which might cause an exception
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- 某些可能导致异常的处理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
   </sect3>
  </sect2>
  
  <sect2 id="plpgsql-call-stack">
<!--==========================orignal english content==========================
   <title>Obtaining Execution Location Information</title>
____________________________________________________________________________-->
   <title>获得执行位置信息</title>

<!--==========================orignal english content==========================
   <para>
    The <command>GET DIAGNOSTICS</command> command, previously described
    in <xref linkend="plpgsql-statements-diagnostics"/>, retrieves information
    about current execution state (whereas the <command>GET STACKED
    DIAGNOSTICS</command> command discussed above reports information about
    the execution state as of a previous error).  Its <literal>PG_CONTEXT</literal>
    status item is useful for identifying the current execution
    location.  <literal>PG_CONTEXT</literal> returns a text string with line(s)
    of text describing the call stack.  The first line refers to the current
    function and currently executing <command>GET DIAGNOSTICS</command>
    command.  The second and any subsequent lines refer to calling functions
    further up the call stack.  For example:

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'-&minus;- Call Stack -&minus;-\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  -&minus;- Call Stack -&minus;-
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 -&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
           1
(1 row)
</programlisting>

   </para>
____________________________________________________________________________-->
   <para>
    <command>GET DIAGNOSTICS</command>（之前在<xref linkend="plpgsql-statements-diagnostics"/>中描述）命令检索有关当前执行状态的信息（反之上文讨论的<command>GET STACKED DIAGNOSTICS</command>命令会把有关执行状态的信息报告成一个以前的错误）。它的<literal>PG_CONTEXT</literal>状态项可用于标识当前执行位置。状态项<literal>PG_CONTEXT</literal>将返回一个文本字符串，其中有描述该调用栈的多行文本。第一行会指向当前函数以及当前正在执行<command>GET DIAGNOSTICS</command>的命令。第二行及其后的行表示调用栈中更上层的调用函数。例如：

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)
</programlisting>

   </para>
   
<!--==========================orignal english content==========================
   <para>
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>
    returns the same sort of stack trace, but describing the location
    at which an error was detected, rather than the current location.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>返回同类的栈跟踪，但是它描述检测到错误的位置而不是当前位置。
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
<!--==========================orignal english content==========================
   <title>Cursors</title>
____________________________________________________________________________-->
   <title>游标</title>

<!--==========================orignal english content==========================
   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Rather than executing a whole query at once, it is possible to set
    up a <firstterm>cursor</firstterm> that encapsulates the query, and then read
    the query result a few rows at a time. One reason for doing this is
    to avoid memory overrun when the result contains a large number of
    rows. (However, <application>PL/pgSQL</application> users do not normally need
    to worry about that, since <literal>FOR</literal> loops automatically use a cursor
    internally to avoid memory problems.) A more interesting usage is to
    return a reference to a cursor that a function has created, allowing the
    caller to read the rows. This provides an efficient way to return
    large row sets from functions.
   </para>
____________________________________________________________________________-->
   <para>
    和一次执行整个查询不同，可以建立一个<firstterm>游标</firstterm>来封装该查询，并且接着一次读取该查询结果的一些行。这样做的原因之一是在结果中包含大量行时避免内存不足（不过，<application>PL/pgSQL</application>用户通常不需要担心这些，因为<literal>FOR</literal>循环在内部会自动使用一个游标来避免内存问题）。一种更有趣的用法是返回一个函数已经创建的游标的引用，允许调用者读取行。这提供了一种有效的方法从函数中返回大型行集。
   </para>

   <sect2 id="plpgsql-cursor-declarations">
<!--==========================orignal english content==========================
    <title>Declaring Cursor Variables</title>
____________________________________________________________________________-->
    <title>声明游标变量</title>

<!--==========================orignal english content==========================
    <para>
     All access to cursors in <application>PL/pgSQL</application> goes through
     cursor variables, which are always of the special data type
     <type>refcursor</type>.  One way to create a cursor variable
     is just to declare it as a variable of type <type>refcursor</type>.
     Another way is to use the cursor declaration syntax,
     which in general is:
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     (<literal>FOR</literal> can be replaced by <literal>IS</literal> for
     <productname>Oracle</productname> compatibility.)
     If <literal>SCROLL</literal> is specified, the cursor will be capable of
     scrolling backward; if <literal>NO SCROLL</literal> is specified, backward
     fetches will be rejected; if neither specification appears, it is
     query-dependent whether backward fetches will be allowed.
     <replaceable>arguments</replaceable>, if specified, is a
     comma-separated list of pairs <literal><replaceable>name</replaceable>
     <replaceable>datatype</replaceable></literal> that define names to be
     replaced by parameter values in the given query.  The actual
     values to substitute for these names will be specified later,
     when the cursor is opened.
    </para>
____________________________________________________________________________-->
    <para>
     所有在<application>PL/pgSQL</application>中对游标的访问都会通过游标变量，它总是特殊的数据类型<type>refcursor</type>。创建游标变量的一种方法是把它声明为一个类型为<type>refcursor</type>的变量。另外一种方法是使用游标声明语法，通常是：
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     （为了对<productname>Oracle</productname>的兼容性，可以用<literal>IS</literal>替代<literal>FOR</literal>）。如果指定了<literal>SCROLL</literal>，那么游标可以反向滚动；如果指定了<literal>NO SCROLL</literal>，那么反向取的动作会被拒绝；如果二者都没有被指定，那么能否进行反向取就取决于查询。如果指定了<replaceable>arguments</replaceable>， 那么它是一个逗号分隔的<literal><replaceable>name</replaceable> <replaceable>datatype</replaceable></literal>对的列表， 它们定义在给定查询中要被参数值替换的名称。实际用于替换这些名字的值将在游标被打开之后指定。
    </para>
<!--==========================orignal english content==========================
    <para>
     Some examples:
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     All three of these variables have the data type <type>refcursor</type>,
     but the first can be used with any query, while the second has
     a fully specified query already <firstterm>bound</firstterm> to it, and the last
     has a parameterized query bound to it.  (<literal>key</literal> will be
     replaced by an integer parameter value when the cursor is opened.)
     The variable <literal>curs1</literal>
     is said to be <firstterm>unbound</firstterm> since it is not bound to
     any particular query.
    </para>
____________________________________________________________________________-->
    <para>
     一些例子：
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     所有这三个变量都是<type>refcursor</type>类型，但是第一个可以用于任何查询，而第二个已经被<firstterm>绑定</firstterm>了一个完全指定的查询，并且最后一个被绑定了一个参数化查询。（游标被打开时，<literal>key</literal>将被一个整数参数值替换）。变量<literal>curs1</literal>被称为<firstterm>未绑定</firstterm>，因为它没有被绑定到任何特定查询。
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
<!--==========================orignal english content==========================
    <title>Opening Cursors</title>
____________________________________________________________________________-->
    <title>打开游标</title>

<!--==========================orignal english content==========================
    <para>
     Before a cursor can be used to retrieve rows, it must be
     <firstterm>opened</firstterm>. (This is the equivalent action to the SQL
     command <command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application> has
     three forms of the <command>OPEN</command> statement, two of which use unbound
     cursor variables while the third uses a bound cursor variable.
    </para>
____________________________________________________________________________-->
    <para>
     在一个游标可以被用来检索行之前，它必需先被<firstterm>打开</firstterm>（这是和 SQL 命令<command>DECLARE CURSOR</command>等效的操作）。<application>PL/pgSQL</application>有三种形式的<command>OPEN</command>命令，其中两种用于未绑定游标变量，另外一种用于已绑定的游标变量。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      Bound cursor variables can also be used without explicitly opening the cursor,
      via the <command>FOR</command> statement described in
      <xref linkend="plpgsql-cursor-for-loop"/>.
     </para>
____________________________________________________________________________-->
     <para>
      可以通过<xref linkend="plpgsql-cursor-for-loop"/>中描述的<command>FOR</command>语句在不显式打开游标的情况下使用已绑定的游标变量。
     </para>
    </note>

    <sect3>
<!--==========================orignal english content==========================
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>
____________________________________________________________________________-->
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<!--==========================orignal english content==========================
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        The cursor variable is opened and given the specified query to
        execute.  The cursor cannot be open already, and it must have been
        declared as an unbound cursor variable (that is, as a simple
        <type>refcursor</type> variable).  The query must be a
        <command>SELECT</command>, or something else that returns rows
        (such as <command>EXPLAIN</command>).  The query
        is treated in the same way as other SQL commands in
        <application>PL/pgSQL</application>: <application>PL/pgSQL</application>
        variable names are substituted, and the query plan is cached for
        possible reuse.  When a <application>PL/pgSQL</application>
        variable is substituted into the cursor query, the value that is
        substituted is the one it has at the time of the <command>OPEN</command>;
        subsequent changes to the variable will not affect the cursor's
        behavior.
        The <literal>SCROLL</literal> and <literal>NO SCROLL</literal>
        options have the same meanings as for a bound cursor.
       </para>
____________________________________________________________________________-->
       <para>
        该游标变量被打开并且被给定要执行的查询。游标不能是已经打开的，并且它必需已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</type>变量）。该查询必须是一条<command>SELECT</command>或者其它返回行的东西（例如<command>EXPLAIN</command>）。该查询会按照其它<application>PL/pgSQL</application>中的 SQL 命令同等的方式对待：先代换<application>PL/pgSQL</application>变量名，并且执行计划会被缓存用于可能的重用。当一个<application>PL/pgSQL</application>变量被替换到游标查询中时，替换的值是在<command>OPEN</command>时它所具有的值。对该变量后续的改变不会影响游标的行为。对于一个已经绑定的游标，<literal>SCROLL</literal>和<literal>NO SCROLL</literal>选项具有相同的含义。
       </para>

<!--==========================orignal english content==========================
       <para>
        An example:
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title><command>OPEN FOR EXECUTE</command></title>
____________________________________________________________________________-->
     <title><command>OPEN FOR EXECUTE</command></title>

<!--==========================orignal english content==========================
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

<!--==========================orignal english content==========================
         <para>
          The cursor variable is opened and given the specified query to
          execute.  The cursor cannot be open already, and it must have been
          declared as an unbound cursor variable (that is, as a simple
          <type>refcursor</type> variable).  The query is specified as a string
          expression, in the same way as in the <command>EXECUTE</command>
          command.  As usual, this gives flexibility so the query plan can vary
          from one run to the next (see <xref linkend="plpgsql-plan-caching"/>),
          and it also means that variable substitution is not done on the
          command string. As with <command>EXECUTE</command>, parameter values
          can be inserted into the dynamic command via
          <literal>format()</literal> and <literal>USING</literal>.
          The <literal>SCROLL</literal> and
          <literal>NO SCROLL</literal> options have the same meanings as for a bound
          cursor.
         </para>
____________________________________________________________________________-->
         <para>
          打开游标变量并且执行指定的查询。该游标不能是已打开的，并且必须已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</type>变量）。该查询以和<command>EXECUTE</command>中相同的方式被指定为一个字符串表达式。照例，这提供了灵活性，因此查询计划可以在两次运行之间变化（见<xref linkend="plpgsql-plan-caching"/>），并且它也意味着在该命令字符串上还没有完成变量替换。正如<command>EXECUTE</command>，可以通过<literal>format()</literal>和<literal>USING</literal>将参数值插入到动态命令中。<literal>SCROLL</literal>和<literal>NO SCROLL</literal>选项具有和已绑定游标相同的含义。
         </para>

<!--==========================orignal english content==========================
       <para>
        An example:
<programlisting>
OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;
</programlisting>
        In this example, the table name is inserted into the query via
        <function>format()</function>.  The comparison value for <literal>col1</literal>
        is inserted via a <literal>USING</literal> parameter, so it needs
        no quoting.
       </para>
____________________________________________________________________________-->
       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;
</programlisting>
        在这个例子中，表名被通过<function>format()</function>插入到查询中。
        <literal>col1</literal>的比较值被通过一个<literal>USING</literal>参数插入，
        所以它不需要引用。
       </para>
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
<!--==========================orignal english content==========================
     <title>Opening a Bound Cursor</title>
____________________________________________________________________________-->
     <title>打开一个已绑定的游标</title>

<!--==========================orignal english content==========================
<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>

<!--==========================orignal english content==========================
         <para>
          This form of <command>OPEN</command> is used to open a cursor
          variable whose query was bound to it when it was declared.  The
          cursor cannot be open already.  A list of actual argument value
          expressions must appear if and only if the cursor was declared to
          take arguments.  These values will be substituted in the query.
         </para>
____________________________________________________________________________-->
         <para>
          这种形式的<command>OPEN</command>被用于打开一个游标变量，它的查询是在声明时绑定的。该游标不能是已经打开的。当且仅当该游标被声明为接收参数时，才必需出现一个实际参数值表达式的列表。这些值将被替换到命令中。
         </para>

<!--==========================orignal english content==========================
         <para>
          The query plan for a bound cursor is always considered cacheable;
          there is no equivalent of <command>EXECUTE</command> in this case.
          Notice that <literal>SCROLL</literal> and <literal>NO SCROLL</literal> cannot be
          specified in <command>OPEN</command>, as the cursor's scrolling
          behavior was already determined.
         </para>
____________________________________________________________________________-->
         <para>
          一个已绑定游标的查询计划总是被认为是可缓存的，在这种情况中没有<command>EXECUTE</command>的等效形式。注意<literal>SCROLL</literal>和<literal>NO SCROLL</literal>不能在<command>OPEN</command>中指定，因为游标的滚动行为已经被确定。
         </para>

<!--==========================orignal english content==========================
         <para>
          Argument values can be passed using either <firstterm>positional</firstterm>
          or <firstterm>named</firstterm> notation.  In positional
          notation, all arguments are specified in order.  In named notation,
          each argument's name is specified using <literal>:=</literal> to
          separate it from the argument expression. Similar to calling
          functions, described in <xref linkend="sql-syntax-calling-funcs"/>, it
          is also allowed to mix positional and named notation.
         </para>
____________________________________________________________________________-->
         <para>
          使用<firstterm>位置</firstterm>或<firstterm>命名</firstterm>记号可以传递参数值。在位置记号中，所有参数都必须按照顺序指定。在命名记号中，每一个参数的名字被使用<literal>:=</literal>指定以将它和参数表达式分隔开。类似于<xref linkend="sql-syntax-calling-funcs"/>中描述的调用函数，也允许混合位置和命名记号。
         </para>

<!--==========================orignal english content==========================
         <para>
          Examples (these use the cursor declaration examples above):
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>
____________________________________________________________________________-->
         <para>
          例子（这些例子使用上面例子中的游标声明）：
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>

<!--==========================orignal english content==========================
         <para>
          Because variable substitution is done on a bound cursor's query,
          there are really two ways to pass values into the cursor: either
          with an explicit argument to <command>OPEN</command>, or implicitly by
          referencing a <application>PL/pgSQL</application> variable in the query.
          However, only variables declared before the bound cursor was
          declared will be substituted into it.  In either case the value to
          be passed is determined at the time of the <command>OPEN</command>.
          For example, another way to get the same effect as the
          <literal>curs3</literal> example above is
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
____________________________________________________________________________-->
         <para>
          因为在一个已绑定游标的查询上已经完成了变量替换，实际有两种方式将值传到游标中：给<command>OPEN</command>一个显式参数，或者在查询中隐式引用一个<application>PL/pgSQL</application>变量。不过，只有在已绑定游标之前声明的变量才将会被替换到游标中。在两种情况下，要被传递的值都是在<command>OPEN</command>时确定的。例如，得到上例中<literal>curs3</literal>相同效果的另一种方式是
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
<!--==========================orignal english content==========================
    <title>Using Cursors</title>
____________________________________________________________________________-->
    <title>使用游标</title>

<!--==========================orignal english content==========================
    <para>
     Once a cursor has been opened, it can be manipulated with the
     statements described here.
    </para>
____________________________________________________________________________-->
    <para>
     一旦一个游标已经被打开，那么就可以用这里描述的语句操作它。
    </para>

<!--==========================orignal english content==========================
    <para>
     These manipulations need not occur in the same function that
     opened the cursor to begin with.  You can return a <type>refcursor</type>
     value out of a function and let the caller operate on the cursor.
     (Internally, a <type>refcursor</type> value is simply the string name
     of a so-called portal containing the active query for the cursor.  This name
     can be passed around, assigned to other <type>refcursor</type> variables,
     and so on, without disturbing the portal.)
    </para>
____________________________________________________________________________-->
    <para>
     这些操作不需要发生在打开该游标开始操作的同一个函数中。你可以从一个函数返回一个<type>refcursor</type>值，并且让调用者在该游标上操作（在内部，<type>refcursor</type>值只是一个包含该游标活动查询的所谓入口的字符串名称。这个名字可以被传递、赋予给其它<type>refcursor</type>变量等等，而不用担心扰乱入口）。
    </para>

<!--==========================orignal english content==========================
    <para>
     All portals are implicitly closed at transaction end.  Therefore
     a <type>refcursor</type> value is usable to reference an open cursor
     only until the end of the transaction.
    </para>
____________________________________________________________________________-->
    <para>
     所有入口会在事务的结尾被隐式地关闭。因此一个<type>refcursor</type>值只能在该事务结束前用于引用一个打开的游标。
    </para>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>FETCH</literal></title>
____________________________________________________________________________-->
     <title><literal>FETCH</literal></title>

<!--==========================orignal english content==========================
<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
    <para>
     <command>FETCH</command> retrieves the next row from the
     cursor into a target, which might be a row variable, a record
     variable, or a comma-separated list of simple variables, just like
     <command>SELECT INTO</command>.  If there is no next row, the
     target is set to NULL(s).  As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether a row was obtained or not.
    </para>
____________________________________________________________________________-->
    <para>
     就像<command>SELECT INTO</command>一样，<command>FETCH</command>从游标中检索下一行到目标中，目标可以是一个行变量、记录变量或者逗号分隔的简单变量列表。如果没有下一行，目标会被设置为 NULL。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看一行是否被获得。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <replaceable>direction</replaceable> clause can be any of the
     variants allowed in the SQL <xref linkend="sql-fetch"/>
     command except the ones that can fetch
     more than one row; namely, it can be
     <literal>NEXT</literal>,
     <literal>PRIOR</literal>,
     <literal>FIRST</literal>,
     <literal>LAST</literal>,
     <literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
     <literal>RELATIVE</literal> <replaceable>count</replaceable>,
     <literal>FORWARD</literal>, or
     <literal>BACKWARD</literal>.
     Omitting <replaceable>direction</replaceable> is the same
     as specifying <literal>NEXT</literal>.
     In the forms using a <replaceable>count</replaceable>,
     the <replaceable>count</replaceable> can be any integer-valued
     expression (unlike the SQL <command>FETCH</command> command,
     which only allows an integer constant).
     <replaceable>direction</replaceable> values that require moving
     backward are likely to fail unless the cursor was declared or opened
     with the <literal>SCROLL</literal> option.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>direction</replaceable>子句可以是 SQL <xref linkend="sql-fetch"/>命令中允许的任何变体，除了那些能够取得多于一行的。即它可以是
     <literal>NEXT</literal>、
     <literal>PRIOR</literal>、
     <literal>FIRST</literal>、
     <literal>LAST</literal>、
     <literal>ABSOLUTE</literal> <replaceable>count</replaceable>、
     <literal>RELATIVE</literal> <replaceable>count</replaceable>、
     <literal>FORWARD</literal>或者
     <literal>BACKWARD</literal>。
     省略<replaceable>direction</replaceable>和指定<literal>NEXT</literal>是一样的。在使用<replaceable>count</replaceable>的形式中，<replaceable>count</replaceable>可以是任意的整数值表达式（与SQL命令<command>FETCH</command>不一样，<command>FETCH</command>仅允许整数常量）。除非游标被使用<literal>SCROLL</literal>选项声明或打开，否则要求反向移动的<replaceable>direction</replaceable>值很可能会失败。
    </para>

<!--==========================orignal english content==========================
    <para>
     <replaceable>cursor</replaceable> must be the name of a <type>refcursor</type>
     variable that references an open cursor portal.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>cursor</replaceable>必须是一个引用已打开游标入口的<type>refcursor</type>变量名。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
____________________________________________________________________________-->
    <para>
     例子：
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>MOVE</literal></title>
____________________________________________________________________________-->
     <title><literal>MOVE</literal></title>

<!--==========================orignal english content==========================
<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
    <para>
     <command>MOVE</command> repositions a cursor without retrieving
     any data. <command>MOVE</command> works exactly like the
     <command>FETCH</command> command, except it only repositions the
     cursor and does not return the row moved to. As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether there was a next row to move to.
    </para>
____________________________________________________________________________-->
    <para>
     <command>MOVE</command>重新定位一个游标而不检索任何数据。<command>MOVE</command>的工作方式与<command>FETCH</command>命令很相似，但是<command>MOVE</command>只是重新定位游标并且不返回至移动到的行。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看要移动到的行是否存在。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
____________________________________________________________________________-->
    <para>
     例子：
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>
____________________________________________________________________________-->
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<!--==========================orignal english content==========================
<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        When a cursor is positioned on a table row, that row can be updated
        or deleted using the cursor to identify the row.  There are
        restrictions on what the cursor's query can be (in particular,
        no grouping) and it's best to use <literal>FOR UPDATE</literal> in the
        cursor.  For more information see the
        <xref linkend="sql-declare"/>
        reference page.
       </para>
____________________________________________________________________________-->
       <para>
        当一个游标被定位到一个表行上时，使用该游标标识该行就可以对它进行更新或删除。对于游标的查询可以是什么是有限制的（尤其是不能有分组），并且最好在游标中使用<literal>FOR UPDATE</literal>。详见<xref linkend="sql-declare"/>参考页。
       </para>

<!--==========================orignal english content==========================
       <para>
        An example:
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        一个例子：
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title><literal>CLOSE</literal></title>
____________________________________________________________________________-->
     <title><literal>CLOSE</literal></title>

<!--==========================orignal english content==========================
<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>
____________________________________________________________________________-->
<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

<!--==========================orignal english content==========================
       <para>
        <command>CLOSE</command> closes the portal underlying an open
        cursor.  This can be used to release resources earlier than end of
        transaction, or to free up the cursor variable to be opened again.
       </para>
____________________________________________________________________________-->
       <para>
        <command>CLOSE</command>关闭一个已打开游标的底层入口。这样就可以在事务结束之前释放资源，或者释放掉该游标变量以便再次打开。
       </para>

<!--==========================orignal english content==========================
       <para>
        An example:
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        一个例子：
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Returning Cursors</title>
____________________________________________________________________________-->
     <title>返回游标</title>

<!--==========================orignal english content==========================
       <para>
        <application>PL/pgSQL</application> functions can return cursors to the
        caller. This is useful to return multiple rows or columns,
        especially with very large result sets.  To do this, the function
        opens the cursor and returns the cursor name to the caller (or simply
        opens the cursor using a portal name specified by or otherwise known
        to the caller).  The caller can then fetch rows from the cursor. The
        cursor can be closed by the caller, or it will be closed automatically
        when the transaction closes.
       </para>
____________________________________________________________________________-->
       <para>
        <application>PL/pgSQL</application>函数可以向调用者返回游标。这对于返回多行或多列（特别是巨大的结果集）很有用。要想这么做，该函数打开游标并且把该游标的名字返回给调用者（或者简单的使用调用者指定的或已知的入口名打开游标）。调用者接着可以从游标中取得行。游标可以由调用者关闭，或者是在事务关闭时自行关闭。
       </para>

<!--==========================orignal english content==========================
       <para>
        The portal name used for a cursor can be specified by the
        programmer or automatically generated.  To specify a portal name,
        simply assign a string to the <type>refcursor</type> variable before
        opening it.  The string value of the <type>refcursor</type> variable
        will be used by <command>OPEN</command> as the name of the underlying portal.
        However, if the <type>refcursor</type> variable is null,
        <command>OPEN</command> automatically generates a name that does not
        conflict with any existing portal, and assigns it to the
        <type>refcursor</type> variable.
       </para>
____________________________________________________________________________-->
       <para>
        用于一个游标的入口名可以由编程者指定或者自动生成。要指定一个入口名，只需要在打开<type>refcursor</type>变量之前简单地为它赋予一个字符串。<command>OPEN</command>将把<type>refcursor</type>变量的字符串值用作底层入口的名字。不过，如果<type>refcursor</type>变量为空，<command>OPEN</command>会自动生成一个与任何现有入口不冲突的名称，并且将它赋予给<type>refcursor</type>变量。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         A bound cursor variable is initialized to the string value
         representing its name, so that the portal name is the same as
         the cursor variable name, unless the programmer overrides it
         by assignment before opening the cursor.  But an unbound cursor
         variable defaults to the null value initially, so it will receive
         an automatically-generated unique name, unless overridden.
        </para>
____________________________________________________________________________-->
        <para>
         一个已绑定的游标变量被初始化为表示其名称的字符串值，因此入口的名字和游标变量名相同，除非程序员在打开游标之前通过赋值覆盖了这个名字。但是一个未绑定的游标变量最初默认为空值，因此它会收到一个自动生成的唯一名字，除非被覆盖。
        </para>
       </note>

<!--==========================orignal english content==========================
       <para>
        The following example shows one way a cursor name can be supplied by
        the caller:

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        下面的例子显示了一个调用者提供游标名字的方法：

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        The following example uses automatic cursor name generation:

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-&minus; need to be in a transaction to use cursors.
BEGIN;
SELECT reffunc2();

      reffunc2
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        下面的例子使用了自动游标名生成：

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        The following example shows one way to return multiple cursors
        from a single function:

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-&minus; need to be in a transaction to use cursors.
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        下面的例子展示了从一个函数中返回多个游标的一种方法：

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
<!--==========================orignal english content==========================
    <title>Looping Through a Cursor's Result</title>
____________________________________________________________________________-->
    <title>通过一个游标的结果循环</title>

<!--==========================orignal english content==========================
    <para>
     There is a variant of the <command>FOR</command> statement that allows
     iterating through the rows returned by a cursor.  The syntax is:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     The cursor variable must have been bound to some query when it was
     declared, and it <emphasis>cannot</emphasis> be open already.  The
     <command>FOR</command> statement automatically opens the cursor, and it closes
     the cursor again when the loop exits.  A list of actual argument value
     expressions must appear if and only if the cursor was declared to take
     arguments.  These values will be substituted in the query, in just
     the same way as during an <command>OPEN</command> (see <xref
     linkend="plpgsql-open-bound-cursor"/>).
   </para>
____________________________________________________________________________-->
    <para>
     有一种<command>FOR</command>语句的变体，它允许通过游标返回的行进行迭代。语法是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     该游标变量必须在声明时已经被绑定到某个查询，并且它<emphasis>不能</emphasis>已经被打开。<command>FOR</command>语句会自动打开游标，并且在退出循环时自动关闭游标。当且仅当游标被声明要使用参数时，才必须出现一个实际参数值表达式的列表。这些值会被替换到查询中，采用<command>OPEN</command>期间的方式（见<xref linkend="plpgsql-open-bound-cursor"/>）。
   </para>

<!--==========================orignal english content==========================
   <para>
     The variable <replaceable>recordvar</replaceable> is automatically
     defined as type <type>record</type> and exists only inside the loop (any
     existing definition of the variable name is ignored within the loop).
     Each row returned by the cursor is successively assigned to this
     record variable and the loop body is executed.
    </para>
____________________________________________________________________________-->
   <para>
     变量<replaceable>recordvar</replaceable>会被自动定义为<type>record</type>类型，并且只存在于循环内部（循环中该变量名任何已有定义都会被忽略）。每一个由游标返回的行都会被陆续地赋值给这个记录变量并且执行循环体。
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-transactions">
<!--==========================orignal english content==========================
   <title>Transaction Management</title>
____________________________________________________________________________-->
   <title>事务管理</title>

<!--==========================orignal english content==========================
   <para>
    In procedures invoked by the <command>CALL</command> command
    as well as in anonymous code blocks (<command>DO</command> command),
    it is possible to end transactions using the
    commands <command>COMMIT</command> and <command>ROLLBACK</command>.  A new
    transaction is started automatically after a transaction is ended using
    these commands, so there is no separate <command>START
    TRANSACTION</command> command.  (Note that <command>BEGIN</command> and
    <command>END</command> have different meanings in PL/pgSQL.)
   </para>
____________________________________________________________________________-->
   <para>
    在由<command>CALL</command>命令调用的过程中以及匿名代码块（<command>DO</command>命令）中，可以用命令<command>COMMIT</command>和<command>ROLLBACK</command>结束事务。在一个事务被使用这些命令结束后，一个新的事务会被自动开始，因此没有单独的<command>START TRANSACTION</command>命令（注意<command>BEGIN</command>和<command>END</command>在PL/pgSQL中有不同的含义）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is a simple example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS $$
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END
$$;

CALL transaction_test1();
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个简单的例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS $$
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END
$$;

CALL transaction_test1();
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Transaction control is only possible in <command>CALL</command> or
    <command>DO</command> invocations from the top level or nested
    <command>CALL</command> or <command>DO</command> invocations without any
    other intervening command.  For example, if the call stack is
    <command>CALL proc1()</command> &rarr; <command>CALL proc2()</command>
    &rarr; <command>CALL proc3()</command>, then the second and third
    procedures can perform transaction control actions.  But if the call stack
    is <command>CALL proc1()</command> &rarr; <command>SELECT
    func2()</command> &rarr; <command>CALL proc3()</command>, then the last
    procedure cannot do transaction control, because of the
    <command>SELECT</command> in between.
   </para>
____________________________________________________________________________-->
   <para>
    只有在从顶层调用的<command>CALL</command>或<command>DO</command>中才能进行事务控制，在没有任何其他中间命令的嵌套<command>CALL</command>或<command>DO</command>调用中也能进行事务控制。例如，如果调用栈是<command>CALL proc1()</command> &rarr; <command>CALL proc2()</command> &rarr; <command>CALL proc3()</command>，那么第二个和第三个过程可以执行事务控制动作。但是如果调用栈是<command>CALL proc1()</command> &rarr; <command>SELECT func2()</command> &rarr; <command>CALL proc3()</command>，则最后一个过程不能做事务控制，因为中间有<command>SELECT</command>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Special considerations apply to cursor loops.  Consider this example:
<programlisting>
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT * FROM test2 ORDER BY x LOOP
        INSERT INTO test1 (a) VALUES (r.x);
        COMMIT;
    END LOOP;
END;
$$;

CALL transaction_test2();
</programlisting>
    Normally, cursors are automatically closed at transaction commit.
    However, a cursor created as part of a loop like this is automatically
    converted to a holdable cursor by the first <command>COMMIT</command> or
    <command>ROLLBACK</command>.  That means that the cursor is fully
    evaluated at the first <command>COMMIT</command> or
    <command>ROLLBACK</command> rather than row by row.  The cursor is still
    removed automatically after the loop, so this is mostly invisible to the
    user.
   </para>
____________________________________________________________________________-->
   <para>
    对于游标循环有特殊的考虑。看看这个例子：
<programlisting>
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT * FROM test2 ORDER BY x LOOP
        INSERT INTO test1 (a) VALUES (r.x);
        COMMIT;
    END LOOP;
END;
$$;

CALL transaction_test2();
</programlisting>
    通常，游标会在事务提交时被自动关闭。但是，一个作为循环的组成部分创建的游标会自动被第一个<command>COMMIT</command>或<command>ROLLBACK</command>转变成一个可保持游标。这意味着该游标在第一个<command>COMMIT</command>或<command>ROLLBACK</command>处会被完全计算出来，而不是逐行被计算。该游标在循环后仍会被自动删除，因此这通常对用户是不可见的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Transaction commands are not allowed in cursor loops driven by commands
    that are not read-only (for example <command>UPDATE
    ... RETURNING</command>).
   </para>
____________________________________________________________________________-->
   <para>
    有非只读命令（<command>UPDATE ... RETURNING</command>）驱动的游标循环中不允许有事务命令。
   </para>

<!--==========================orignal english content==========================
   <para>
    A transaction cannot be ended inside a block with exception handlers.
   </para>
____________________________________________________________________________-->
   <para>
    事务在一个具有异常处理部分的块中不能被结束。
   </para>
  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
<!--==========================orignal english content==========================
   <title>Errors and Messages</title>
____________________________________________________________________________-->
   <title>错误和消息</title>
   
  <sect2 id="plpgsql-statements-raise">
<!--==========================orignal english content==========================
   <title>Reporting Errors and Messages</title>
____________________________________________________________________________-->
   <title>报告错误和消息</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>RAISE</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>RAISE</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>reporting errors</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>报告错误</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Use the <command>RAISE</command> statement to report messages and
    raise errors.

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    The <replaceable class="parameter">level</replaceable> option specifies
    the error severity.  Allowed levels are <literal>DEBUG</literal>,
    <literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal>,
    and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal>
    being the default.
    <literal>EXCEPTION</literal> raises an error (which normally aborts the
    current transaction); the other levels only generate messages of different
    priority levels.
    Whether messages of a particular priority are reported to the client,
    written to the server log, or both is controlled by the
    <xref linkend="guc-log-min-messages"/> and
    <xref linkend="guc-client-min-messages"/> configuration
    variables. See <xref linkend="runtime-config"/> for more
    information.
   </para>
____________________________________________________________________________-->
   <para>
    使用<command>RAISE</command>语句报告消息以及抛出错误。

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    <replaceable class="parameter">level</replaceable>选项指定了错误的严重性。允许的级别有<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>, <literal>WARNING</literal>以及<literal>EXCEPTION</literal>，默认级别是<literal>EXCEPTION</literal>。<literal>EXCEPTION</literal>会抛出一个错误（通常会中止当前事务）。其他级别仅仅是产生不同优先级的消息。不管一个特定优先级的消息是被报告给客户端、还是写到服务器日志、亦或是二者同时都做，这都由<xref linkend="guc-log-min-messages"/>和<xref linkend="guc-client-min-messages"/>配置变量控制。详见<xref linkend="runtime-config"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    After <replaceable class="parameter">level</replaceable> if any,
    you can write a <replaceable class="parameter">format</replaceable>
    (which must be a simple string literal, not an expression).  The
    format string specifies the error message text to be reported.
    The format string can be followed
    by optional argument expressions to be inserted into the message.
    Inside the format string, <literal>%</literal> is replaced by the
    string representation of the next optional argument's value. Write
    <literal>%%</literal> to emit a literal <literal>%</literal>.
    The number of arguments must match the number of <literal>%</literal>
    placeholders in the format string, or an error is raised during
    the compilation of the function.
   </para>
____________________________________________________________________________-->
   <para>
    如果有<replaceable class="parameter">level</replaceable>，
    在它后面可以写一个<replaceable class="parameter">format</replaceable>（
    它必须是一个简单字符串而不是表达式）。该格式字符串指定要被报告的
    错误消息文本。在格式字符串后面可以跟上可选的要被插入到该消息的
    参数表达式。在格式字符串中，<literal>%</literal>会被下一个可选参数
    的值所替换。写<literal>%%</literal>可以发出一个字面的
    <literal>%</literal>。参数的数量必须匹配格式字符串中<literal>%</literal>
    占位符的数量，否则在函数编译期间就会发生错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    In this example, the value of <literal>v_job_id</literal> will replace the
    <literal>%</literal> in the string:
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在这个例子中，<literal>v_job_id</literal>的值将替换字符串中的<literal>%</literal>：
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    You can attach additional information to the error report by writing
    <literal>USING</literal> followed by <replaceable
    class="parameter">option</replaceable> = <replaceable
    class="parameter">expression</replaceable> items.  Each
    <replaceable class="parameter">expression</replaceable> can be any
    string-valued expression.  The allowed <replaceable
    class="parameter">option</replaceable> key words are:

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>Sets the error message text.  This option can't be used in the
        form of <command>RAISE</command> that includes a format string
        before <literal>USING</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>Supplies an error detail message.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>Supplies a hint message.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>Specifies the error code (SQLSTATE) to report, either by condition
        name, as shown in <xref linkend="errcodes-appendix"/>, or directly as a
        five-character SQLSTATE code.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>Supplies the name of a related object.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    通过写一个后面跟着<replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable>项的<literal>USING</literal>，可以为错误报告附加一些额外信息。每一个<replaceable class="parameter">expression</replaceable>可以是任意字符串值的表达式。允许的<replaceable class="parameter">option</replaceable>关键词是：

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>设置错误消息文本。这个选项可以被用于在<literal>USING</literal>之前包括一个格式字符串的<command>RAISE</command>形式。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>提供一个错误的细节消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>提供一个提示消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>指定要报告的错误代码（SQLSTATE），可以用<xref linkend="errcodes-appendix"/>中所示的条件名，或者直接作为一个五字符的 SQLSTATE 代码。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>提供一个相关对象的名称。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    This example will abort the transaction with the given error message
    and hint:
<programlisting>
RAISE EXCEPTION 'Nonexistent ID -&minus;> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这个例子将用给定的错误消息和提示中止事务：
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    These two examples show equivalent ways of setting the SQLSTATE:
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这两个例子展示了设置 SQLSTATE 的两种等价的方法：
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    There is a second <command>RAISE</command> syntax in which the main argument
    is the condition name or SQLSTATE to be reported, for example:
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    In this syntax, <literal>USING</literal> can be used to supply a custom
    error message, detail, or hint.  Another way to do the earlier
    example is
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    还有第二种<command>RAISE</command>语法，在其中主要参数是要被报告的条件名或 SQLSTATE，例如：
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    在这种语法中，<literal>USING</literal>能被用来提供一个自定义的错误消息、细节或提示。另一种做前面的例子的方法是
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Still another variant is to write <literal>RAISE USING</literal> or <literal>RAISE
    <replaceable class="parameter">level</replaceable> USING</literal> and put
    everything else into the <literal>USING</literal> list.
   </para>
____________________________________________________________________________-->
   <para>
    仍有另一种变体是写<literal>RAISE USING</literal>或者<literal>RAISE <replaceable class="parameter">level</replaceable> USING</literal>并且把所有其他东西都放在<literal>USING</literal>列表中。
   </para>

<!--==========================orignal english content==========================
   <para>
    The last variant of <command>RAISE</command> has no parameters at all.
    This form can only be used inside a <literal>BEGIN</literal> block's
    <literal>EXCEPTION</literal> clause;
    it causes the error currently being handled to be re-thrown.
   </para>
____________________________________________________________________________-->
   <para>
    <command>RAISE</command>的最后一种变体根本没有参数。这种形式只能被用在一个<literal>BEGIN</literal>块的<literal>EXCEPTION</literal>子句中，它导致当前正在被处理的错误被重新抛出。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> without
     parameters was interpreted as re-throwing the error from the block
     containing the active exception handler.  Thus an <literal>EXCEPTION</literal>
     clause nested within that handler could not catch it, even if the
     <command>RAISE</command> was within the nested <literal>EXCEPTION</literal> clause's
     block. This was deemed surprising as well as being incompatible with
     Oracle's PL/SQL.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname> 9.1 之前，没有参数的<command>RAISE</command>被解释为重新抛出来自包含活动异常处理器的块的错误。因此一个嵌套在那个处理器中的<literal>EXCEPTION</literal>子句无法捕捉它，即使<command>RAISE</command>位于嵌套<literal>EXCEPTION</literal>子句的块中也是这样。这种行为很奇怪，也并不兼容 Oracle 的 PL/SQL。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    If no condition name nor SQLSTATE is specified in a
    <command>RAISE EXCEPTION</command> command, the default is to use
    <literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>).  If no message
    text is specified, the default is to use the condition name or
    SQLSTATE as message text.
   </para>
____________________________________________________________________________-->
   <para>
    如果在一个<command>RAISE EXCEPTION</command>命令中没有指定条件名以及 SQLSTATE，默认是使用<literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>)。如果没有指定消息文本，默认是使用条件名或 SQLSTATE 作为消息文本。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     When specifying an error code by SQLSTATE code, you are not
     limited to the predefined error codes, but can select any
     error code consisting of five digits and/or upper-case ASCII
     letters, other than <literal>00000</literal>.  It is recommended that
     you avoid throwing error codes that end in three zeroes, because
     these are category codes and can only be trapped by trapping
     the whole category.
    </para>
____________________________________________________________________________-->
    <para>
     当用 SQLSTATE 代码指定一个错误代码时，你不会受到预定义错误代码的限制，而是可以选择任何由五位以及大写 ASCII 字母构成的错误代码，只有<literal>00000</literal>不能使用。我们推荐尽量避免抛出以三个零结尾的错误代码，因为这些是分类代码并且只能用来捕获整个类别。
    </para>
   </note>
   
   </sect2>

  <sect2 id="plpgsql-statements-assert">
<!--==========================orignal english content==========================
   <title>Checking Assertions</title>
____________________________________________________________________________-->
   <title>检查断言</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ASSERT</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ASSERT</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>assertions</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>assertions</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary><varname>plpgsql.check_asserts</varname> configuration parameter</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary><varname>plpgsql.check_asserts</varname>配置参数</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <command>ASSERT</command> statement is a convenient shorthand for
    inserting debugging checks into <application>PL/pgSQL</application>
    functions.

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

    The <replaceable class="parameter">condition</replaceable> is a Boolean
    expression that is expected to always evaluate to true; if it does,
    the <command>ASSERT</command> statement does nothing further.  If the
    result is false or null, then an <literal>ASSERT_FAILURE</literal> exception
    is raised.  (If an error occurs while evaluating
    the <replaceable class="parameter">condition</replaceable>, it is
    reported as a normal error.)
   </para>
____________________________________________________________________________-->
   <para>
    <command>ASSERT</command>语句是一种向
    <application>PL/pgSQL</application>函数中插入调试检查的方便方法。

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

    <replaceable class="parameter">condition</replaceable>是一个布尔
    表达式，它被期望总是计算为真。如果确实如此，
    <command>ASSERT</command>语句不会再做什么。但如果结果是假
    或者空，那么将发生一个<literal>ASSERT_FAILURE</literal>异常（如果在计算
    <replaceable class="parameter">condition</replaceable>时发生错误，
    它会被报告为一个普通错误）。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the optional <replaceable class="parameter">message</replaceable> is
    provided, it is an expression whose result (if not null) replaces the
    default error message text <quote>assertion failed</quote>, should
    the <replaceable class="parameter">condition</replaceable> fail.
    The <replaceable class="parameter">message</replaceable> expression is
    not evaluated in the normal case where the assertion succeeds.
   </para>
____________________________________________________________________________-->
   <para>
    如果提供了可选的<replaceable class="parameter">message</replaceable>，
    它是一个结果（如果非空）被用来替换默认错误消息文本
    <quote>assertion failed</quote>的表达式（如果
    <replaceable class="parameter">condition</replaceable>失败）。
    <replaceable class="parameter">message</replaceable>表达式在
    断言成功的普通情况下不会被计算。
   </para>

<!--==========================orignal english content==========================
   <para>
    Testing of assertions can be enabled or disabled via the configuration
    parameter <literal>plpgsql.check_asserts</literal>, which takes a Boolean
    value; the default is <literal>on</literal>.  If this parameter
    is <literal>off</literal> then <command>ASSERT</command> statements do nothing.
   </para>
____________________________________________________________________________-->
   <para>
    通过配置参数<literal>plpgsql.check_asserts</literal>可以启用或者禁用断言测试，
    这个参数接受布尔值且默认为<literal>on</literal>。如果这个参数为<literal>off</literal>，
    则<command>ASSERT</command>语句什么也不做。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that <command>ASSERT</command> is meant for detecting program
    bugs, not for reporting ordinary error conditions.  Use
    the <command>RAISE</command> statement, described above, for that.
   </para>
____________________________________________________________________________-->
   <para>
    注意<command>ASSERT</command>是为了检测程序的 bug，而不是
    报告普通的错误情况。如果要报告普通错误，请使用前面介绍的
    <command>RAISE</command>语句。
   </para>

  </sect2>
 </sect1>

 <sect1 id="plpgsql-trigger">
<!--==========================orignal english content==========================
  <title>Trigger Functions</title>
____________________________________________________________________________-->
  <title>触发器函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plpgsql-trigger">
   <primary>触发器</primary>
   <secondary>在 PL/pgSQL 中</secondary>
  </indexterm>
  
<!--==========================orignal english content==========================
  <para>
   <application>PL/pgSQL</application> can be used to define trigger
   functions on data changes or database events.
   A trigger function is created with the <command>CREATE FUNCTION</command>
   command, declaring it as a function with no arguments and a return type of
   <type>trigger</type> (for data change triggers) or
   <type>event_trigger</type> (for database event triggers).
   Special local variables named <varname>TG_<replaceable>something</replaceable></varname> are
   automatically defined to describe the condition that triggered the call.
  </para>
____________________________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>可以被用来在数据更改或者数据库事件上定义触发器函数。触发器函数用<command>CREATE FUNCTION</command>命令创建，它被声明为一个没有参数并且返回类型为<type>trigger</type>（对于数据更改触发器）或者<type>event_trigger</type>（对于数据库事件触发器）的函数。名为<varname>PG_<replaceable>something</replaceable></varname>的特殊局部变量将被自动创建用以描述触发该调用的条件。
  </para>

  <sect2 id="plpgsql-dml-trigger">
<!--==========================orignal english content==========================
   <title>Triggers on Data Changes</title>
____________________________________________________________________________-->
   <title>数据改变的触发器</title>

<!--==========================orignal english content==========================
   <para>
   A <link linkend="triggers">data change trigger</link> is declared as a
   function with no arguments and a return type of <type>trigger</type>.
   Note that the function must be declared with no arguments even if it
   expects to receive some arguments specified in <command>CREATE TRIGGER</command>
   &mdash; such arguments are passed via <varname>TG_ARGV</varname>, as described
   below.
  </para>
____________________________________________________________________________-->
   <para>
    一个<link linkend="triggers">数据更改触发器</link>被声明为一个没有参数并且返回类型为<type>trigger</type>的函数。注意，如下所述，即便该函数准备接收一些在<command>CREATE TRIGGER</command>中指定的参数 &mdash; 这类参数通过<varname>TG_ARGV</varname>传递，也必须把它声明为没有参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a <application>PL/pgSQL</application> function is called as a
   trigger, several special variables are created automatically in the
   top-level block. They are:

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       Data type <type>RECORD</type>; variable holding the new
       database row for <command>INSERT</command>/<command>UPDATE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>DELETE</command> operations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       Data type <type>RECORD</type>; variable holding the old
       database row for <command>UPDATE</command>/<command>DELETE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>INSERT</command> operations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; variable that contains the name of the trigger actually
       fired.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
       <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>, depending on the trigger's definition.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of either
       <literal>ROW</literal> or <literal>STATEMENT</literal>
       depending on the trigger's definition.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>
       telling for which operation the trigger was fired.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       Data type <type>oid</type>; the object ID of the table that caused the
       trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the table that caused the trigger
       invocation. This is now deprecated, and could disappear in a future
       release. Use <literal>TG_TABLE_NAME</literal> instead.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the table that
       caused the trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the schema of the
       table that caused the trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       Data type <type>integer</type>; the number of arguments given to the trigger
       function in the <command>CREATE TRIGGER</command> statement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       Data type array of <type>text</type>; the arguments from
       the <command>CREATE TRIGGER</command> statement.
       The index counts from 0. Invalid
       indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>)
       result in a null value.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   当一个<application>PL/pgSQL</application>函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>INSERT</command>/<command>UPDATE</command>操作保持新数据行。在语句级别的触发器以及<command>DELETE</command>操作，这个变量是null。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>UPDATE</command>/<command>DELETE</command>操作保持新数据行。在语句级别的触发器以及<command>INSERT</command>操作，这个变量是null。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；该变量包含实际触发的触发器名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>BEFORE</literal>、<literal>AFTER</literal>或<literal>INSTEAD OF</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>ROW</literal>或<literal>STATEMENT</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或<literal>TRUNCATE</literal>的一个字符串，它说明触发器是为哪个操作引发。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       数据类型是<type>oid</type>；是导致触发器调用的表的对象 ID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用<literal>TG_TABLE_NAME</literal>替代。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表所在的模式名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       数据类型是<type>integer</type>；在<command>CREATE TRIGGER</command>语句中给触发器函数的参数数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>数组；来自<command>CREATE TRIGGER</command>语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于<varname>tg_nargs</varname>）会导致返回一个空值。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
   <para>
    A trigger function must return either <symbol>NULL</symbol> or a
    record/row value having exactly the structure of the table the
    trigger was fired for.
   </para>
____________________________________________________________________________-->
   <para>
    一个触发器函数必须返回<symbol>NULL</symbol>或者是一个与触发器为之引发的表结构完全相同的记录/行值。
   </para>

<!--==========================orignal english content==========================
   <para>
    Row-level triggers fired <literal>BEFORE</literal> can return null to signal the
    trigger manager to skip the rest of the operation for this row
    (i.e., subsequent triggers are not fired, and the
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> does not occur
    for this row).  If a nonnull
    value is returned then the operation proceeds with that row value.
    Returning a row value different from the original value
    of <varname>NEW</varname> alters the row that will be inserted or
    updated.  Thus, if the trigger function wants the triggering
    action to succeed normally without altering the row
    value, <varname>NEW</varname> (or a value equal thereto) has to be
    returned.  To alter the row to be stored, it is possible to
    replace single values directly in <varname>NEW</varname> and return the
    modified <varname>NEW</varname>, or to build a complete new record/row to
    return.  In the case of a before-trigger
    on <command>DELETE</command>, the returned value has no direct
    effect, but it has to be nonnull to allow the trigger action to
    proceed.  Note that <varname>NEW</varname> is null
    in <command>DELETE</command> triggers, so returning that is
    usually not sensible.  The usual idiom in <command>DELETE</command>
    triggers is to return <varname>OLD</varname>.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>BEFORE</literal>引发的行级触发器可以返回一个空来告诉触发器管理器跳过对该行剩下的操作（即后续的触发器将不再被引发，并且不会对该行发生<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>)。如果返回了一个非空值，那么对该行值会继续操作。返回不同于原始<varname>NEW</varname>的行值将修改将要被插入或更新的行。因此，如果该触发器函数想要触发动作正常成功而不修改行值，<varname>NEW</varname>（或者另一个相等的值）必须被返回。要修改将被存储的行，可以直接在<varname>NEW</varname>中替换单一值并且返回修改后的<varname>NEW</varname>，或者构建一个全新的记录/行来返回。在一个<command>DELETE</command>上的前触发器情况下，返回值没有直接效果，但是它必须为非空以允许触发器动作继续下去。注意<varname>NEW</varname>在<command>DELETE</command>触发器中是空值，因此返回它通常没有意义。在<command>DELETE</command>中的常用方法是返回<varname>OLD</varname>.
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>INSTEAD OF</literal> triggers (which are always row-level triggers,
    and may only be used on views) can return null to signal that they did
    not perform any updates, and that the rest of the operation for this
    row should be skipped (i.e., subsequent triggers are not fired, and the
    row is not counted in the rows-affected status for the surrounding
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>).
    Otherwise a nonnull value should be returned, to signal
    that the trigger performed the requested operation. For
    <command>INSERT</command> and <command>UPDATE</command> operations, the return value
    should be <varname>NEW</varname>, which the trigger function may modify to
    support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command>
    (this will also affect the row value passed to any subsequent triggers,
    or passed to a special <varname>EXCLUDED</varname> alias reference within
    an <command>INSERT</command> statement with an <literal>ON CONFLICT DO
    UPDATE</literal> clause).  For <command>DELETE</command> operations, the return
    value should be <varname>OLD</varname>.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>INSTEAD OF</literal>触发器（总是行级触发器，并且可能只被用于视图）能够返回空来表示它们没有执行任何更新，并且对该行剩余的操作可以被跳过（即后续的触发器不会被引发，并且该行不会被计入外围<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>的行影响状态中）。否则一个非空值应该被返回用以表示该触发器执行了所请求的操作。对于<command>INSERT</command> 和<command>UPDATE</command>操作，返回值应该是<varname>NEW</varname>，触发器函数可能对它进行了修改来支持<command>INSERT RETURNING</command>和<command>UPDATE RETURNING</command>（这也将影响被传递给任何后续触发器的行值，或者被传递给带有<literal>ON CONFLICT DO UPDATE</literal>的<command>INSERT</command>语句中一个特殊的<varname>EXCLUDED</varname>别名引用）。对于<command>DELETE</command>操作，返回值应该是<varname>OLD</varname>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The return value of a row-level trigger
    fired <literal>AFTER</literal> or a statement-level trigger
    fired <literal>BEFORE</literal> or <literal>AFTER</literal> is
    always ignored; it might as well be null. However, any of these types of
    triggers might still abort the entire operation by raising an error.
   </para>
____________________________________________________________________________-->
   <para>
    一个<literal>AFTER</literal>行级触发器或一个<literal>BEFORE</literal>或<literal>AFTER</literal>语句级触发器的返回值总是会被忽略，它可能也是空。不过，任何这些类型的触发器可能仍会通过抛出一个错误来中止整个操作。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="plpgsql-trigger-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="plpgsql-trigger-example"/>展示了<application>PL/pgSQL</application>中一个触发器函数的例子。
   </para>

   <example id="plpgsql-trigger-example">
<!--==========================orignal english content==========================
    <title>A <application>PL/pgSQL</application> Trigger Function</title>
____________________________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 触发器函数</title>

<!--==========================orignal english content==========================
    <para>
     This example trigger ensures that any time a row is inserted or updated
     in the table, the current user name and time are stamped into the
     row. And it checks that an employee's name is given and that the
     salary is a positive value.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子触发器保证：任何时候一个行在表中被插入或更新时，当前用户名和时间也会被标记在该行中。并且它会检查给出了一个雇员的姓名以及薪水是一个正值。
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -&minus; Check that empname and salary are given
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -&minus; Who works for us when they must pay for it?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -&minus; Remember who changed the payroll when
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- 检查给出了 empname 以及 salary
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- 谁会倒贴钱为我们工作？
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- 记住谁在什么时候改变了工资单
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</programlisting>
   </example>

<!--==========================orignal english content==========================
   <para>
    Another way to log changes to a table involves creating a new table that
    holds a row for each insert, update, or delete that occurs. This approach
    can be thought of as auditing changes to a table.
    <xref linkend="plpgsql-trigger-audit-example"/> shows an example of an
    audit trigger function in <application>PL/pgSQL</application>.
   </para>
____________________________________________________________________________-->
   <para>
    另一种记录对表的改变的方法涉及到创建一个新表来为每一个发生的插入、更新或删除保持一行。这种方法可以被认为是对一个表的改变的审计。<xref linkend="plpgsql-trigger-audit-example"/>展示了<application>PL/pgSQL</application>中一个审计触发器函数的例子。
   </para>

   <example id="plpgsql-trigger-audit-example">
<!--==========================orignal english content==========================
    <title>A <application>PL/pgSQL</application> Trigger Function For Auditing</title>
____________________________________________________________________________-->
    <title>一个用于审计的 <application>PL/pgSQL</application> 触发器函数</title>

<!--==========================orignal english content==========================
    <para>
     This example trigger ensures that any insert, update or delete of a row
     in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table.
     The current time and user name are stamped into the row, together with
     the type of operation performed on it.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子触发器保证了在<literal>emp</literal>表上的任何插入、更新或删除一行的动作都被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被记录到行中，还有在其上执行的操作类型。
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        -&minus;
        -&minus; Create a row in emp_audit to reflect the operation performed on emp,
        -&minus; making use of the special variable TG_OP to work out the operation.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        END IF;
        RETURN NULL; -&minus; result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- 在 emp_audit 中创建一行来反映 emp 上执行的动作，
        -- 使用特殊变量 TG_OP 来得到操作。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        END IF;
        RETURN NULL; -- 因为这是一个 AFTER 触发器，结果被忽略
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</programlisting>
   </example>

<!--==========================orignal english content==========================
   <para>
    A variation of the previous example uses a view joining the main table
    to the audit table, to show when each entry was last modified. This
    approach still records the full audit trail of changes to the table,
    but also presents a simplified view of the audit trail, showing just
    the last modified timestamp derived from the audit trail for each entry.
    <xref linkend="plpgsql-view-trigger-audit-example"/> shows an example
    of an audit trigger on a view in <application>PL/pgSQL</application>.
   </para>
____________________________________________________________________________-->
   <para>
    前一个例子的一种变体使用一个视图将主表连接到审计表来展示每一项最后被修改是什么时间。这种方法还是记录了对于表修改的完整审查跟踪，但是也提供了审查跟踪的一个简化视图，只为每一个项显示从审查跟踪生成的最后修改时间戳。<xref linkend="plpgsql-view-trigger-audit-example"/>展示了在<application>PL/pgSQL</application>中一个视图上审计触发器的例子。
   </para>

   <example id="plpgsql-view-trigger-audit-example">
<!--==========================orignal english content==========================
    <title>A <application>PL/pgSQL</application> View Trigger Function For Auditing</title>
____________________________________________________________________________-->
    <title>一个用于审计的 <application>PL/pgSQL</application> 视图触发器函数</title>

<!--==========================orignal english content==========================
    <para>
     This example uses a trigger on the view to make it updatable, and
     ensure that any insert, update or delete of a row in the view is
     recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time
     and user name are recorded, together with the type of operation
     performed, and the view displays the last modified time of each row.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子在视图上使用了一个触发器让它变得可更新，并且确保视图中一行的任何插入、更新或删除被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被与执行的操作类型一起记录，并且该视图会显示每一行的最后修改时间。
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        -&minus;
        -&minus; Perform the required operation on emp, and create a row in emp_audit
        -&minus; to reflect the change made to emp.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- 执行 emp 上所要求的操作，并且在 emp_audit 中创建一行来反映对 emp 的改变。
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</programlisting>
   </example>

<!--==========================orignal english content==========================
   <para>
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
   </para>
____________________________________________________________________________-->
   <para>
    触发器的一种用法是维护一个表的另一个汇总表。作为结果的汇总表可以用来在特定查询中替代原始表 &mdash; 通常会大量减少运行时间。这种技术常用于数据仓库中，在其中被度量或被观察数据的表（称为事实表）可能会极度大。<xref linkend="plpgsql-trigger-summary-example"/>展示了<application>PL/pgSQL</application>中一个为数据仓库事实表维护汇总表的触发器函数的例子。
   </para>


   <example id="plpgsql-trigger-summary-example">
<!--==========================orignal english content==========================
    <title>A <application>PL/pgSQL</application> Trigger Function For Maintaining A Summary Table</title>
____________________________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 用于维护汇总表的触发器函数</title>

<!--==========================orignal english content==========================
    <para>
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
    </para>
____________________________________________________________________________-->
    <para>
     这里详述的模式有一部分是基于 Ralph Kimball 所作的<emphasis>The Data Warehouse Toolkit</emphasis>中的<emphasis>Grocery Store</emphasis>例子。
    </para>

<!--==========================orignal english content==========================
<programlisting>
-&minus;
-&minus; Main tables - time dimension and sales fact.
-&minus;
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

-&minus;
-&minus; Summary table - sales by time.
-&minus;
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

-&minus;
-&minus; Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
-&minus;
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -&minus; Work out the increment/decrement amount(s).
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -&minus; forbid updates that change the time_key -
            -&minus; (probably not too onerous, as DELETE + INSERT is how most
            -&minus; changes will be made).
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -&minus; Insert or update the summary row with the new values.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -&minus; do nothing
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
____________________________________________________________________________-->
<programlisting>
--
-- 主表 - 时间维度和销售事实。
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- 汇总表 - 按时间汇总销售
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- 在 UPDATE、INSERT、DELETE 时修改汇总列的函数和触发器。
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- 算出增量/减量数。
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- 禁止更改 the time_key 的更新-
            -- （可能不会太麻烦，因为大部分的更改是用 DELETE + INSERT 完成的）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- 插入或更新带有新值的汇总行。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- 什么也不做
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>

<!--==========================orignal english content==========================
   <para>
    <literal>AFTER</literal> triggers can also make use of <firstterm>transition
    tables</firstterm> to inspect the entire set of rows changed by the triggering
    statement.  The <command>CREATE TRIGGER</command> command assigns names to one
    or both transition tables, and then the function can refer to those names
    as though they were read-only temporary tables.
    <xref linkend="plpgsql-trigger-audit-transition-example"/> shows an example.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>AFTER</literal>也可以利用<firstterm>传递表</firstterm>来观察被触发语句更改的整个行集合。<command>CREATE TRIGGER</command>命令会为一个或者两个传递表分配名字，然后函数可以引用那些名字，就好像它们是只读的临时表一样。<xref linkend="plpgsql-trigger-audit-transition-example"/>展示了一个例子。
   </para>

   <example id="plpgsql-trigger-audit-transition-example">
<!--==========================orignal english content==========================
    <title>Auditing with Transition Tables</title>
____________________________________________________________________________-->
    <title>用传递表进行审计</title>

<!--==========================orignal english content==========================
    <para>
     This example produces the same results as
     <xref linkend="plpgsql-trigger-audit-example"/>, but instead of using a
     trigger that fires for every row, it uses a trigger that fires once
     per statement, after collecting the relevant information in a transition
     table.  This can be significantly faster than the row-trigger approach
     when the invoking statement has modified many rows.  Notice that we must
     make a separate trigger declaration for each kind of event, since the
     <literal>REFERENCING</literal> clauses must be different for each case.  But
     this does not stop us from using a single trigger function if we choose.
     (In practice, it might be better to use three separate functions and
     avoid the run-time tests on <varname>TG_OP</varname>.)
    </para>
____________________________________________________________________________-->
    <para>
     这个例子产生和<xref linkend="plpgsql-trigger-audit-example"/>相同的结果，但并未使用一个为每一行都触发的触发器，而是在把相关信息收集到一个传递表中之后用了一个只为每个语句引发一次的触发器。当调用语句修改了很多行时，这种方法明显比行触发器方法快。注意我们必须为每一种事件建立一个单独的触发器声明，因为每种情况的<literal>REFERENCING</literal>子句必须不同。但是这并不能阻止我们使用单一的触发器函数（实际上，使用三个单独的函数会更好，因为可以避免在<varname>TG_OP</varname>上的运行时测试）。
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        -&minus;
        -&minus; Create rows in emp_audit to reflect the operations performed on emp,
        -&minus; making use of the special variable TG_OP to work out the operation.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), user, n.* FROM new_table n;
        END IF;
        RETURN NULL; -&minus; result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- 在emp_audit中创建行来反映在emp上执行的操作，
        -- 利用特殊变量TG_OP来区分操作。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), user, n.* FROM new_table n;
        END IF;
        RETURN NULL; -- 由于这是一个AFTER触发器，所以结果被忽略
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</programlisting>
   </example>
</sect2>

  <sect2 id="plpgsql-event-trigger">
<!--==========================orignal english content==========================
   <title>Triggers on Events</title>
____________________________________________________________________________-->
   <title>事件触发器</title>

<!--==========================orignal english content==========================
   <para>
    <application>PL/pgSQL</application> can be used to define
    <link linkend="event-triggers">event triggers</link>.
    <productname>PostgreSQL</productname> requires that a function that
    is to be called as an event trigger must be declared as a function with
    no arguments and a return type of <literal>event_trigger</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <application>PL/pgSQL</application>可以被用来定义<link linkend="event-triggers">事件触发器</link>。<productname>PostgreSQL</productname>要求一个可以作为事件触发器调用的函数必须被声明为没有参数并且返回类型为<literal>event_trigger</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a <application>PL/pgSQL</application> function is called as an
    event trigger, several special variables are created automatically
    in the top-level block. They are:

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string representing the event the
       trigger is fired for.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; variable that contains the command tag
       for which the trigger is fired.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
   <para>
    当一个<application>PL/pgSQL</application>函数被作为一个事件触发器调用，在顶层块中会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个表示引发触发器的事件的字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个变量，包含了该触发器为之引发的命令标签。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="plpgsql-event-trigger-example"/> shows an example of an
    event trigger function in <application>PL/pgSQL</application>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="plpgsql-event-trigger-example"/>展示了<application>PL/pgSQL</application>中一个事件触发器函数的例子。
   </para>

   <example id="plpgsql-event-trigger-example">
<!--==========================orignal english content==========================
    <title>A <application>PL/pgSQL</application> Event Trigger Function</title>
____________________________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 事件触发器函数</title>

<!--==========================orignal english content==========================
    <para>
     This example trigger simply raises a <literal>NOTICE</literal> message
     each time a supported command is executed.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子触发器在受支持命令每一次被执行时会简单地抛出一个<literal>NOTICE</literal>消息。
    </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
<!--==========================orignal english content==========================
   <title><application>PL/pgSQL</application> Under the Hood</title>
____________________________________________________________________________-->
   <title><application>PL/pgSQL</application>的内部</title>

<!--==========================orignal english content==========================
   <para>
    This section discusses some implementation details that are
    frequently important for <application>PL/pgSQL</application> users to know.
   </para>
____________________________________________________________________________-->
   <para>
    这一节讨论了一些<application>PL/pgSQL</application>用户应该知道的一些重要的实现细节。
   </para>

  <sect2 id="plpgsql-var-subst">
<!--==========================orignal english content==========================
   <title>Variable Substitution</title>
____________________________________________________________________________-->
   <title>变量替换</title>

<!--==========================orignal english content==========================
   <para>
    SQL statements and expressions within a <application>PL/pgSQL</application> function
    can refer to variables and parameters of the function.  Behind the scenes,
    <application>PL/pgSQL</application> substitutes query parameters for such references.
    Parameters will only be substituted in places where a parameter or
    column reference is syntactically allowed.  As an extreme case, consider
    this example of poor programming style:
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    The first occurrence of <literal>foo</literal> must syntactically be a table
    name, so it will not be substituted, even if the function has a variable
    named <literal>foo</literal>.  The second occurrence must be the name of a
    column of the table, so it will not be substituted either.  Only the
    third occurrence is a candidate to be a reference to the function's
    variable.
   </para>
____________________________________________________________________________-->
   <para>
    一个<application>PL/pgSQL</application>函数中的 SQL 语句和表达式能够引用该函数的变量和参数。在现象背后，<application>PL/pgSQL</application>会为这些引用替换查询参数。只有在语法上允许一个参数或列引用的地方才会替换参数。作为一种极端情况，考虑这个编程风格糟糕的例子：
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    <literal>foo</literal>的第一次出现在语法上必须是一个表名， 因此它将不会被替换，即使该函数有一个名为<literal>foo</literal>的变量。第二次出现必须是该表的一列的名称，因此它也将不会被替换。只有第三次出现是对该函数变量引用的候选。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> versions before 9.0 would try
     to substitute the variable in all three cases, leading to syntax errors.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname> 9.0 之前的版本将尝试替换所有三种情况的变量，这会导致语法错误。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Since the names of variables are syntactically no different from the names
    of table columns, there can be ambiguity in statements that also refer to
    tables: is a given name meant to refer to a table column, or a variable?
    Let's change the previous example to
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    Here, <literal>dest</literal> and <literal>src</literal> must be table names, and
    <literal>col</literal> must be a column of <literal>dest</literal>, but <literal>foo</literal>
    and <literal>bar</literal> might reasonably be either variables of the function
    or columns of <literal>src</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    因为变量名在语法上与表列的名字没什么区别，在也引用表的语句中会有歧义：一个给定的名字意味着一个表列或一个变量？让我们把前一个例子改成：
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    这里，<literal>dest</literal>和<literal>src</literal>必须是表名，并且<literal>col</literal>必须是<literal>dest</literal>的一列，但是<literal>foo</literal>和<literal>bar</literal>可能该函数的变量或者<literal>src</literal>的列。
   </para>

<!--==========================orignal english content==========================
   <para>
    By default, <application>PL/pgSQL</application> will report an error if a name
    in a SQL statement could refer to either a variable or a table column.
    You can fix such a problem by renaming the variable or column,
    or by qualifying the ambiguous reference, or by telling
    <application>PL/pgSQL</application> which interpretation to prefer.
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，如果一个 SQL 语句中的名称可能引用一个变量或者一个表列，<application>PL/pgSQL</application>将报告一个错误。修复这种问题的方法很多：你可以重命名变量或列来，或者对有歧义的引用加以限定，或者告诉<application>PL/pgSQL</application>要引用哪种解释。
   </para>

<!--==========================orignal english content==========================
   <para>
    The simplest solution is to rename the variable or column.
    A common coding rule is to use a
    different naming convention for <application>PL/pgSQL</application>
    variables than you use for column names.  For example,
    if you consistently name function variables
    <literal>v_<replaceable>something</replaceable></literal> while none of your
    column names start with <literal>v_</literal>, no conflicts will occur.
   </para>
____________________________________________________________________________-->
   <para>
    最简单的解决方案是重命名变量或列。一种常用的编码规则是为<application>PL/pgSQL</application>变量使用一种不同于列名的命名习惯。例如，如果你将函数变量统一地命名为<literal>v_<replaceable>something</replaceable></literal>，而你的列名不会开始于<literal>v_</literal>，就不会发生冲突。
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively you can qualify ambiguous references to make them clear.
    In the above example, <literal>src.foo</literal> would be an unambiguous reference
    to the table column.  To create an unambiguous reference to a variable,
    declare it in a labeled block and use the block's label
    (see <xref linkend="plpgsql-structure"/>).  For example,
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    Here <literal>block.foo</literal> means the variable even if there is a column
    <literal>foo</literal> in <literal>src</literal>.  Function parameters, as well as
    special variables such as <literal>FOUND</literal>, can be qualified by the
    function's name, because they are implicitly declared in an outer block
    labeled with the function's name.
   </para>
____________________________________________________________________________-->
   <para>
    另外你可以限定有歧义的引用让它们变清晰。在上面的例子中，<literal>src.foo</literal>将是对表列的一种无歧义的引用。要创建对一个变量的无歧义引用，在一个被标记的块中声明它并且使用块的标签（见<xref linkend="plpgsql-structure"/>）。例如
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    这里<literal>block.foo</literal>表示变量，即使在<literal>src</literal>中有一个列<literal>foo</literal>。函数参数以及诸如<literal>FOUND</literal>的特殊变量，都能通过函数的名称被限定，因为它们被隐式地声明在一个带有该函数名称的外层块中。
   </para>

<!--==========================orignal english content==========================
   <para>
    Sometimes it is impractical to fix all the ambiguous references in a
    large body of <application>PL/pgSQL</application> code.  In such cases you can
    specify that <application>PL/pgSQL</application> should resolve ambiguous references
    as the variable (which is compatible with <application>PL/pgSQL</application>'s
    behavior before <productname>PostgreSQL</productname> 9.0), or as the
    table column (which is compatible with some other systems such as
    <productname>Oracle</productname>).
   </para>
____________________________________________________________________________-->
   <para>
    有时候在一个大型的<application>PL/pgSQL</application>代码体中修复所有的有歧义引用是不现实的。在这种情况下，你可以指定<application>PL/pgSQL</application>应该将有歧义的引用作为变量（这与<application>PL/pgSQL</application>在 <productname>PostgreSQL</productname> 9.0 之前的行为兼容）或表列（这与某些其他系统兼容，例如<productname>Oracle</productname>）解决。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
     <primary><varname>plpgsql.variable_conflict</varname> configuration parameter</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary><varname>plpgsql.variable_conflict</varname>配置参数</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To change this behavior on a system-wide basis, set the configuration
    parameter <literal>plpgsql.variable_conflict</literal> to one of
    <literal>error</literal>, <literal>use_variable</literal>, or
    <literal>use_column</literal> (where <literal>error</literal> is the factory default).
    This parameter affects subsequent compilations
    of statements in <application>PL/pgSQL</application> functions, but not statements
    already compiled in the current session.
    Because changing this setting
    can cause unexpected changes in the behavior of <application>PL/pgSQL</application>
    functions, it can only be changed by a superuser.
   </para>
____________________________________________________________________________-->
   <para>
    要在系统范围内改变这种行为，将配置参数<literal>plpgsql.variable_conflict</literal>设置为<literal>error</literal>、<literal>use_variable</literal>或者<literal>use_column</literal>（这里<literal>error</literal>是出厂设置）之一。这个参数会影响<application>PL/pgSQL</application>函数中语句的后续编译，但是不会影响在当前会话中已经编译过的语句。因为改变这个设置能够导致<application>PL/pgSQL</application>函数中行为的意想不到的改变，所以只能由一个超级用户来更改它。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can also set the behavior on a function-by-function basis, by
    inserting one of these special commands at the start of the function
    text:
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    These commands affect only the function they are written in, and override
    the setting of <literal>plpgsql.variable_conflict</literal>.  An example is
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    In the <literal>UPDATE</literal> command, <literal>curtime</literal>, <literal>comment</literal>,
    and <literal>id</literal> will refer to the function's variable and parameters
    whether or not <literal>users</literal> has columns of those names.  Notice
    that we had to qualify the reference to <literal>users.id</literal> in the
    <literal>WHERE</literal> clause to make it refer to the table column.
    But we did not have to qualify the reference to <literal>comment</literal>
    as a target in the <literal>UPDATE</literal> list, because syntactically
    that must be a column of <literal>users</literal>.  We could write the same
    function without depending on the <literal>variable_conflict</literal> setting
    in this way:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    你也可以对逐个函数设置该行为，做法是在函数文本的开始插入这些特殊命令之一：
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    这些命令只影响它们所属的函数，并且会覆盖<literal>plpgsql.variable_conflict</literal>的设置。一个例子是：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    在<literal>UPDATE</literal>命令中，<literal>curtime</literal>、<literal>comment</literal>以及<literal>id</literal>将引用该函数的变量和参数，不管<literal>users</literal>有没有这些名称的列。注意，我们不得不在<literal>WHERE</literal>子句中对<literal>users.id</literal>的引用加以限定，以便让它引用表列。但是我们不需要在<literal>UPDATE</literal>列表中把对<literal>comment</literal>的引用限定为一个目标，因为语法上那必须是<literal>users</literal>的一列。我们可以用下面的方式写一个相同的不依赖于<literal>variable_conflict</literal>设置的函数：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Variable substitution does not happen in the command string given
    to <command>EXECUTE</command> or one of its variants.  If you need to
    insert a varying value into such a command, do so as part of
    constructing the string value, or use <literal>USING</literal>, as illustrated in
    <xref linkend="plpgsql-statements-executing-dyn"/>.
   </para>
____________________________________________________________________________-->
   <para>
    被交给<command>EXECUTE</command>或其变体的命令字符串中不会发生变量替换。如果你需要插入一个变化值到这样一个命令中，在构建该字符串值时就这样做，或者使用<literal>USING</literal>，如<xref linkend="plpgsql-statements-executing-dyn"/>中所阐明的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Variable substitution currently works only in <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands,
    because the main SQL engine allows query parameters only in these
    commands.  To use a non-constant name or value in other statement
    types (generically called utility statements), you must construct
    the utility statement as a string and <command>EXECUTE</command> it.
   </para>
____________________________________________________________________________-->
   <para>
    当前变量替换只能在<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>命令中工作，因为主 SQL 引擎只允许查询参数在这些命令中。要在其他语句类型（通常被称为实用语句）中使用一个非常量名称或值，你必须将实用语句构建为一个字符串并且<command>EXECUTE</command>它。
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
<!--==========================orignal english content==========================
   <title>Plan Caching</title>
____________________________________________________________________________-->
   <title>计划缓存</title>

<!--==========================orignal english content==========================
   <para>
    The <application>PL/pgSQL</application> interpreter parses the function's source
    text and produces an internal binary instruction tree the first time the
    function is called (within each session).  The instruction tree
    fully translates the
    <application>PL/pgSQL</application> statement structure, but individual
    <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands
    used in the function are not translated immediately.
   </para>
____________________________________________________________________________-->
   <para>
    在函数被第一次调用时（在每个会话中），<application>PL/pgSQL</application>解释器解析函数的源文本并且产生一个内部的二进制指令树。该指令树完全翻译了<application>PL/pgSQL</application>语句结构，但是该函数中使用的<acronym>SQL</acronym>表达式以及<acronym>SQL</acronym>命令并没有被立即翻译。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>preparing a query</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
    As each expression and <acronym>SQL</acronym> command is first
    executed in the function, the <application>PL/pgSQL</application> interpreter
    parses and analyzes the command to create a prepared statement,
    using the <acronym>SPI</acronym> manager's
    <function>SPI_prepare</function> function.
    Subsequent visits to that expression or command
    reuse the prepared statement.  Thus, a function with conditional code
    paths that are seldom visited will never incur the overhead of
    analyzing those commands that are never executed within the current
    session.  A disadvantage is that errors
    in a specific expression or command cannot be detected until that
    part of the function is reached in execution.  (Trivial syntax
    errors will be detected during the initial parsing pass, but
    anything deeper will not be detected until execution.)
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>准备一个查询</primary>
     <secondary>在 PL/pgSQL 中</secondary>
    </indexterm>
    作为该函数中每一个表达式和第一次被执行的<acronym>SQL</acronym>命令，<application>PL/pgSQL</application>解释器使用<acronym>SPI</acronym>管理器的<function>SPI_prepare</function>函数解析并且分析该命令来创建一个预备语句。对于那个表达式或命令的后续访问将会重用该预备语句。因此，一个带有很少被访问的条件性代码路径的函数将永远不会发生分析那些在当前会话中永远不被执行的命令的开销。一个缺点是在一个特定表达式或命令中的错误将不能被检测到，直到函数的该部分在执行时被到达（不重要的语法错误在初始的解析中就会被检测到，但是任何更深层次的东西将只有在执行时才能检测到）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <application>PL/pgSQL</application> (or more precisely, the SPI manager) can
    furthermore attempt to cache the execution plan associated with any
    particular prepared statement.  If a cached plan is not used, then
    a fresh execution plan is generated on each visit to the statement,
    and the current parameter values (that is, <application>PL/pgSQL</application>
    variable values) can be used to optimize the selected plan.  If the
    statement has no parameters, or is executed many times, the SPI manager
    will consider creating a <firstterm>generic</firstterm> plan that is not dependent
    on specific parameter values, and caching that for re-use.  Typically
    this will happen only if the execution plan is not very sensitive to
    the values of the <application>PL/pgSQL</application> variables referenced in it.
    If it is, generating a plan each time is a net win.  See <xref
    linkend="sql-prepare"/> for more information about the behavior of
    prepared statements.
   </para>
____________________________________________________________________________-->
   <para>
    <application>PL/pgSQL</application>（或者更准确地说是 SPI 管理器）能进一步尝试缓冲与任何特定预备语句相关的执行计划。如果没有使用一个已缓存的计划，那么每次访问该语句时都会生成一个新的执行计划，并且当前的参数值（也就是<application>PL/pgSQL</application>的变量值）可以被用来优化被选中的计划。如果该语句没有参数，或者要被执行很多次，SPI 管理器将考虑创建一个不依赖特定参数值的<firstterm>一般</firstterm>计划并且将其缓存用于重用。通常只有在执行计划对其中引用的<application>PL/pgSQL</application>变量值不那么敏感时，才会这样做。如果这样做，每一次生成的计划就是纯利。关于预备语句的行为请详见<xref linkend="sql-prepare"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Because <application>PL/pgSQL</application> saves prepared statements
    and sometimes execution plans in this way,
    SQL commands that appear directly in a
    <application>PL/pgSQL</application> function must refer to the
    same tables and columns on every execution; that is, you cannot use
    a parameter as the name of a table or column in an SQL command.  To get
    around this restriction, you can construct dynamic commands using
    the <application>PL/pgSQL</application> <command>EXECUTE</command>
    statement &mdash; at the price of performing new parse analysis and
    constructing a new execution plan on every execution.
   </para>
____________________________________________________________________________-->
   <para>
    由于<application>PL/pgSQL</application>保存预备语句并且有时候以这种方式保存执行计划，直接出现在一个<application>PL/pgSQL</application>函数中的 SQL 命令必须在每次执行时引用相同的表和列。也就是说，你不能在一个 SQL 命令中把一个参数用作表或列的名字。要绕过这种限制，你可以构建<application>PL/pgSQL</application> <command>EXECUTE</command>使用的动态命令，但是会付出在每次执行时需要执行新解析分析以及构建新执行计划的代价。
   </para>

<!--==========================orignal english content==========================
    <para>
     The mutable nature of record variables presents another problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change from one call of the function to the next, since each
     expression will be analyzed using the data type that is present
     when the expression is first reached.  <command>EXECUTE</command> can be
     used to get around this problem when necessary.
    </para>
____________________________________________________________________________-->
    <para>
     记录变量的易变天性在这个关系中带来了另一个问题。当一个记录变量的域被用在表达式或语句中时，域的数据类型不能在该函数的调用之间改变，因为每一个表达式被分析时都将使用第一次到达该表达式时存在的数据类型。必要时，可以用<command>EXECUTE</command>来绕过这个问题。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the same function is used as a trigger for more than one table,
     <application>PL/pgSQL</application> prepares and caches statements
     independently for each such table &mdash; that is, there is a cache
     for each trigger function and table combination, not just for each
     function.  This alleviates some of the problems with varying
     data types; for instance, a trigger function will be able to work
     successfully with a column named <literal>key</literal> even if it happens
     to have different types in different tables.
    </para>
____________________________________________________________________________-->
    <para>
     如果同一个函数被用作一个服务于多个表的触发器，<application>PL/pgSQL</application>会为每一个这样的表独立地准备并缓存语句 &mdash; 也就是对每一种触发器函数和表的组合都会有一个缓存，而不是每个函数一个缓存。这减轻了数据类型变化带来的问题。例如，一个触发器函数将能够成功地使用一个名为<literal>key</literal>的列工作，即使该列正好在不同的表中有不同的类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Likewise, functions having polymorphic argument types have a separate
     statement cache for each combination of actual argument types they have
     been invoked for, so that data type differences do not cause unexpected
     failures.
    </para>
____________________________________________________________________________-->
    <para>
     同样，具有多态参数类型的函数也会为它们已经被调用的每一种实参类型组合都保留一个独立的缓存，这样数据类型差异不会导致意想不到的失败。
    </para>

<!--==========================orignal english content==========================
   <para>
    Statement caching can sometimes have surprising effects on the
    interpretation of time-sensitive values.  For example there
    is a difference between what these two functions do:

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     and:

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
    语句缓存有时可能在解释时间敏感的值时产生令人惊讶的效果。例如这两个函数做的事情就有区别：

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     以及：

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     In the case of <function>logfunc1</function>, the
     <productname>PostgreSQL</productname> main parser knows when
     analyzing the <command>INSERT</command> that the
     string <literal>'now'</literal> should be interpreted as
     <type>timestamp</type>, because the target column of
     <classname>logtable</classname> is of that type. Thus,
     <literal>'now'</literal> will be converted to a <type>timestamp</type>
     constant when the
     <command>INSERT</command> is analyzed, and then used in all
     invocations of <function>logfunc1</function> during the lifetime
     of the session. Needless to say, this isn't what the programmer
     wanted.  A better idea is to use the <literal>now()</literal> or
     <literal>current_timestamp</literal> function.
    </para>
____________________________________________________________________________-->
    <para>
     在<function>logfunc1</function>中，<productname>PostgreSQL</productname>的主解析器在分析<command>INSERT</command>时就知道字符串<literal>'now'</literal>应该被解释为<type>timestamp</type>，因为<classname>logtable</classname>的目标列是这种类型。因此，在<command>INSERT</command>被分析时<literal>'now'</literal>将被转换为一个<type>timestamp</type>常量，并且在该会话的生命周期内被用于所有对<function>logfunc1</function>的调用。不用说，这不是程序员想要的。一个更好的主意是使用<literal>now()</literal>或<literal>current_timestamp</literal>函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the case of <function>logfunc2</function>, the
     <productname>PostgreSQL</productname> main parser does not know
     what type <literal>'now'</literal> should become and therefore
     it returns a data value of type <type>text</type> containing the string
     <literal>now</literal>. During the ensuing assignment
     to the local variable <varname>curtime</varname>, the
     <application>PL/pgSQL</application> interpreter casts this
     string to the <type>timestamp</type> type by calling the
     <function>text_out</function> and <function>timestamp_in</function>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.  Even though this
     happens to work as expected, it's not terribly efficient, so
     use of the <literal>now()</literal> function would still be a better idea.
    </para>
____________________________________________________________________________-->
    <para>
     在<function>logfunc2</function>中，<productname>PostgreSQL</productname>的主解析器不知道<literal>'now'</literal>应该变成什么类型并且因此返回一个<type>text</type>类型的包含字符串<literal>now</literal>的数据值。在确定对本地变量<varname>curtime</varname>的赋值期间，<application>PL/pgSQL</application>解释器通过调用用于转换的<function>text_out</function>以及<function>timestamp_in</function>函数将这个字符串造型为<type>timestamp</type>类型。因此，计算出来的时间戳会按照程序员的期待在每次执行时更新。虽然这正好符合预期，但是它的效率很糟糕，因此使用<literal>now()</literal>函数仍然是一种更好的方案。
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
<!--==========================orignal english content==========================
  <title>Tips for Developing in <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
  <title><application>PL/pgSQL</application>开发提示</title>

<!--==========================orignal english content==========================
   <para>
    One good way to develop in
    <application>PL/pgSQL</application> is to use the text editor of your
    choice to create your functions, and in another window, use
    <application>psql</application> to load and test those functions.
    If you are doing it this way, it
    is a good idea to write the function using <command>CREATE OR
    REPLACE FUNCTION</command>. That way you can just reload the file to update
    the function definition.  For example:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在<application>PL/pgSQL</application>中进行开发的一种好方法是使用你自己选择的文本编辑器来创建函数，并且在另一个窗口中使用<application>psql</application>来载入并且测试那些函数。如果你正在这样做，使用<command>CREATE OR REPLACE FUNCTION</command>来编写函数是一个好主意。用那种方式你只需要重载该文件来更新函数的定义。例如：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    While running <application>psql</application>, you can load or reload such
    a function definition file with:
<programlisting>
\i filename.sql
</programlisting>
    and then immediately issue SQL commands to test the function.
   </para>
____________________________________________________________________________-->
   <para>
    在运行<application>psql</application>期间，你可以用下面的命令载入或者重载这样一个函数定义文件：
<programlisting>
\i filename.sql
</programlisting>
    并且接着立即发出 SQL 命令来测试该函数。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another good way to develop in <application>PL/pgSQL</application> is with a
    GUI database access tool that facilitates development in a
    procedural language. One example of such a tool is
    <application>pgAdmin</application>, although others exist. These tools often
    provide convenient features such as escaping single quotes and
    making it easier to recreate and debug functions.
   </para>
____________________________________________________________________________-->
   <para>
    另一种在<application>PL/pgSQL</application>中开发的方式是用一个 GUI 数据库访问工具，它能方便对过程语言的开发。这种工具的一个例子是<application>pgAdmin</application>。这些工具通常提供方便的特性，例如转义单引号以及便于重新创建和调试函数。
   </para>

  <sect2 id="plpgsql-quote-tips">
<!--==========================orignal english content==========================
   <title>Handling of Quotation Marks</title>
____________________________________________________________________________-->
   <title>处理引号</title>

<!--==========================orignal english content==========================
   <para>
    The code of a <application>PL/pgSQL</application> function is specified in
    <command>CREATE FUNCTION</command> as a string literal.  If you
    write the string literal in the ordinary way with surrounding
    single quotes, then any single quotes inside the function body
    must be doubled; likewise any backslashes must be doubled (assuming
    escape string syntax is used).
    Doubling quotes is at best tedious, and in more complicated cases
    the code can become downright incomprehensible, because you can
    easily find yourself needing half a dozen or more adjacent quote marks.
    It's recommended that you instead write the function body as a
    <quote>dollar-quoted</quote> string literal (see <xref
    linkend="sql-syntax-dollar-quoting"/>).  In the dollar-quoting
    approach, you never double any quote marks, but instead take care to
    choose a different dollar-quoting delimiter for each level of
    nesting you need.  For example, you might write the <command>CREATE
    FUNCTION</command> command as:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    Within this, you might use quote marks for simple literal strings in
    SQL commands and <literal>$$</literal> to delimit fragments of SQL commands
    that you are assembling as strings.  If you need to quote text that
    includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on.
   </para>
____________________________________________________________________________-->
   <para>
    一个<application>PL/pgSQL</application>函数的代码在一个<command>CREATE FUNCTION</command>中被指定为一个字符串。如果你用通常的方式把该字符串写在单引号中间，那么该函数体中的任何单引号都必须被双写；同样任何反斜线也必须被双写（假定使用了转义字符串语法）。双写引号最多有点冗长，并且在更复杂的情况中代码会变得完全无法理解，因为你很容易发现你需要半打或者更多相邻的引号。我们推荐你转而把函数体写成一个<quote>美元引用</quote>的字符串（见<xref linkend="sql-syntax-dollar-quoting"/>）。在美元引用方法中，你从不需要双写任何引号。但是要注意为你需要的每一层嵌套选择一个不同的美元引用定界符。例如，你可能把<command>CREATE FUNCTION</command>命令写成：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    在这里面，你可以在 SQL 命令中为简单字符串使用引号并且用<literal>$$</literal>来界定被你组装成字符串的 SQL 命令片段。如果你需要引用包括<literal>$$</literal>的文本，你可以使用<literal>$Q$</literal>等等。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following chart shows what you have to do when writing quote
    marks without dollar quoting.  It might be useful when translating
    pre-dollar quoting code into something more comprehensible.
  </para>
____________________________________________________________________________-->
   <para>
    下列图表展示了在写没有美元引用的引号时需要做什么。在将之前用美元引用的代码翻译成更容易理解的代码时，它们会有所帮助。
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term>1 quotation mark</term>
____________________________________________________________________________-->
    <term>1 个引号</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      To begin and end the function body, for example:
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      Anywhere within a single-quoted function body, quote marks
      <emphasis>must</emphasis> appear in pairs.
     </para>
____________________________________________________________________________-->
     <para>
      用来开始和结束函数体，例如：
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      在一个单引号引用的函数体中的任何位置，引号<emphasis>必须</emphasis>成对出现。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>2 quotation marks</term>
____________________________________________________________________________-->
    <term>2 个引号</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      For string literals inside the function body, for example:
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      In the dollar-quoting approach, you'd just write:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      which is exactly what the <application>PL/pgSQL</application> parser would see
      in either case.
     </para>
____________________________________________________________________________-->
     <para>
      用于函数体内的字符串，例如：
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      在美元引用方法中，你只需要写：
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      这恰好就是<application>PL/pgSQL</application>在两种情况中会看到的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>4 quotation marks</term>
____________________________________________________________________________-->
    <term>4 个引号</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      When you need a single quotation mark in a string constant inside the
      function body, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      The value actually appended to <literal>a_output</literal> would be:
      <literal> AND name LIKE 'foobar' AND xyz</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      当你在函数内的一个字符串常量中需要一个单引号时，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      实际会被追加到<literal>a_output</literal>的值将是：<literal> AND name LIKE 'foobar' AND xyz</literal>。
     </para>
<!--==========================orignal english content==========================
     <para>
      In the dollar-quoting approach, you'd write:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      being careful that any dollar-quote delimiters around this are not
      just <literal>$$</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      在美元引用方法中，你可以写：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      要小心在这周围的任何美元引用定界符不只是<literal>$$</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>6 quotation marks</term>
____________________________________________________________________________-->
    <term>6 个引号</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      When a single quotation mark in a string inside the function body is
      adjacent to the end of that string constant, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      The value appended to <literal>a_output</literal> would then be:
      <literal> AND name LIKE 'foobar'</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      当在函数体内的一个字符串中的一个单引号与该字符串常量末尾相邻，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      被追加到<literal>a_output</literal>的值则将是：<literal> AND name LIKE 'foobar'</literal>。
     </para>
<!--==========================orignal english content==========================
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>10 quotation marks</term>
____________________________________________________________________________-->
    <term>10 个引号</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2"/>.
      For example:
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      The value of <literal>a_output</literal> would then be:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      当你想在一个字符串常量（占 8 个引号）中有两个单引号时并且这会挨着该字符串常量的末尾（另外 2 个）。如果你正在写一个产生其他函数的函数（如<xref linkend="plpgsql-porting-ex2"/>中），你将很可能只需要这种。例如：
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      <literal>a_output</literal>的值将是：
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
<!--==========================orignal english content==========================
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      where we assume we only need to put single quote marks into
      <literal>a_output</literal>, because it will be re-quoted before use.
     </para>
____________________________________________________________________________-->
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      这里我们假定我们只需要把单引号放在<literal>a_output</literal>中，因为在使用前它将被再引用。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
  
  <sect2 id="plpgsql-extra-checks">
<!--==========================orignal english content==========================
   <title>Additional Compile-time Checks</title>
____________________________________________________________________________-->
   <title>额外的编译时检查</title>

<!--==========================orignal english content==========================
   <para>
    To aid the user in finding instances of simple but common problems before
    they cause harm, <application>PL/pgSQL</application> provides additional
    <replaceable>checks</replaceable>. When enabled, depending on the configuration, they
    can be used to emit either a <literal>WARNING</literal> or an <literal>ERROR</literal>
    during the compilation of a function. A function which has received
    a <literal>WARNING</literal> can be executed without producing further messages,
    so you are advised to test in a separate development environment.
   </para>
____________________________________________________________________________-->
   <para>
    为了辅助用户在一些简单但常见的问题产生危害之前找到它们，
    <application>PL/pgSQL</application>提供了额外的<replaceable>检查</replaceable>。当被启用时，
    根据配置，它们可以在一个函数的编译期间被用来发出
    <literal>WARNING</literal>或者<literal>ERROR</literal>。一个已经收到了
    <literal>WARNING</literal>的函数可以被继续执行而不会产生进一步的消息，
    因此建议你在一个单独的开发环境中进行测试。
   </para>

<!--==========================orignal english content==========================
 <para>
  These additional checks are enabled through the configuration variables
  <varname>plpgsql.extra_warnings</varname> for warnings and
  <varname>plpgsql.extra_errors</varname> for errors. Both can be set either to
  a comma-separated list of checks, <literal>"none"</literal> or <literal>"all"</literal>.
  The default is <literal>"none"</literal>. Currently the list of available checks
  includes only one:
  <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>
      Checks if a declaration shadows a previously defined variable.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  The following example shows the effect of <varname>plpgsql.extra_warnings</varname>
  set to <varname>shadowed_variables</varname>:
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  这些额外的检查通过配置变量<varname>plpgsql.extra_warnings</varname>
  和<varname>plpgsql.extra_errors</varname>启用，其中前者用于警告而后者用
  于错误。两者都可以被设置为一个用逗号分隔的检查列表、
  <literal>"none"</literal>或者<literal>"all"</literal>。默认值是<literal>"none"</literal>。
  当前列表中可用的检查只有一种：
  <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>
      检查一个声明是否遮盖了另一个之前定义的变量。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  下面的例子展示了将<varname>plpgsql.extra_warnings</varname>
  设置为<varname>shadowed_variables</varname>的效果：
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
 </para>
 </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
<!--==========================orignal english content==========================
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>
____________________________________________________________________________-->
  <title>从<productname>Oracle</productname> PL/SQL 移植</title>

<!--==========================orignal english content==========================
  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>从 PL/SQL 移植到 PL/pgSQL</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting to PL/pgSQL</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>移植到 PL/pgSQL</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section explains differences between
   <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application>
   language and Oracle's <application>PL/SQL</application> language,
   to help developers who port applications from
   <trademark class="registered">Oracle</trademark> to <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   这一节解释了<productname>PostgreSQL</productname>的<application>PL/pgSQL</application>语言和 Oracle 的<application>PL/SQL</application>语言之间的差别，用以帮助那些从<trademark class="registered">Oracle</trademark>向<productname>PostgreSQL</productname>移植应用的人。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>PL/pgSQL</application> is similar to PL/SQL in many
   aspects. It is a block-structured, imperative language, and all
   variables have to be declared.  Assignments, loops, and conditionals
   are similar.  The main differences you should keep in mind when
   porting from <application>PL/SQL</application> to
   <application>PL/pgSQL</application> are:

    <itemizedlist>
     <listitem>
      <para>
       If a name used in a SQL command could be either a column name of a
       table or a reference to a variable of the function,
       <application>PL/SQL</application> treats it as a column name.  This corresponds
       to <application>PL/pgSQL</application>'s
       <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>
       behavior, which is not the default,
       as explained in <xref linkend="plpgsql-var-subst"/>.
       It's often best to avoid such ambiguities in the first place,
       but if you have to port a large amount of code that depends on
       this behavior, setting <literal>variable_conflict</literal> may be the
       best solution.
      </para>
     </listitem>

     <listitem>
      <para>
       In <productname>PostgreSQL</productname> the function body must be written as
       a string literal.  Therefore you need to use dollar quoting or escape
       single quotes in the function body. (See <xref
       linkend="plpgsql-quote-tips"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       Data type names often need translation.  For example, in Oracle string
       values are commonly declared as being of type <type>varchar2</type>, which
       is a non-SQL-standard type.  In <productname>PostgreSQL</productname>,
       use type <type>varchar</type> or <type>text</type> instead.  Similarly, replace
       type <type>number</type> with <type>numeric</type>, or use some other numeric
       data type if there's a more appropriate one.
      </para>
     </listitem>

     <listitem>
      <para>
       Instead of packages, use schemas to organize your functions
       into groups.
      </para>
     </listitem>

     <listitem>
      <para>
       Since there are no packages, there are no package-level variables
       either. This is somewhat annoying.  You can keep per-session state
       in temporary tables instead.
      </para>
     </listitem>

     <listitem>
      <para>
       Integer <command>FOR</command> loops with <literal>REVERSE</literal> work
       differently: <application>PL/SQL</application> counts down from the second
       number to the first, while <application>PL/pgSQL</application> counts down
       from the first number to the second, requiring the loop bounds
       to be swapped when porting.  This incompatibility is unfortunate
       but is unlikely to be changed. (See <xref
       linkend="plpgsql-integer-for"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       <command>FOR</command> loops over queries (other than cursors) also work
       differently: the target variable(s) must have been declared,
       whereas <application>PL/SQL</application> always declares them implicitly.
       An advantage of this is that the variable values are still accessible
       after the loop exits.
      </para>
     </listitem>

     <listitem>
      <para>
       There are various notational differences for the use of cursor
       variables.
      </para>
     </listitem>

    </itemizedlist>
   </para>
____________________________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>与 PL/SQL 在许多方面都非常类似。它是一种块结构的、命令式的语言并且所有变量必须先被声明。赋值、循环和条件则很类似。在从<application>PL/SQL</application>向<application>PL/pgSQL</application>移植时必须记住一些事情：

    <itemizedlist>
     <listitem>
      <para>
       如果一个 SQL 命令中使用的名字可能是一个表的列名或者是对一个函数中变量的引用，那么<application>PL/SQL</application>会将它当作一个列名。如<xref linkend="plpgsql-var-subst"/>中所述，这对应的是<application>PL/pgSQL</application>的 <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>行为（不是默认行为）。通常最好是首先避免这种歧义，但如果不得不移植依赖于该行为的大量代码，那么设置<literal>variable_conflict</literal>将是最好的方案。
      </para>
     </listitem>

     <listitem>
      <para>
       在<productname>PostgreSQL</productname>中，函数体必须写成字符串文本。因此你需要使用美元符引用或者转义函数体中的单引号（见<xref linkend="plpgsql-quote-tips"/>）。
      </para>
     </listitem>
     
     <listitem>
      <para>
       数据类型名称常常需要翻译。例如，在 Oracle 中字符串值通常被声明为类型<type>varchar2</type>，这并非 SQL 标准类型。在<productname>PostgreSQL</productname>中则要使用类型<type>varchar</type>或者<type>text</type>来替代。类似地，要把类型<type>number</type>替换成<type>numeric</type>，或者在适当的时候使用某种其他数字数据类型。
      </para>
     </listitem>

     <listitem>
      <para>
       应该用模式把函数组织成不同的分组，而不是用包。
      </para>
     </listitem>

     <listitem>
      <para>
       因为没有包，所以也没有包级别的变量。这一点有时候挺讨厌。你可以在临时表里保存会话级别的状态。
      </para>
     </listitem>

     <listitem>
      <para>
       带有<literal>REVERSE</literal>的整数<command>FOR</command>循环的工作方式不同：<application>PL/SQL</application>中是从第二个数向第一个数倒数，而<application>PL/pgSQL</application>是从第一个数向第二个数倒数，因此在移植时需要交换循环边界。不幸的是这种不兼容性是不太可能改变的（见<xref linkend="plpgsql-integer-for"/>）。
      </para>
     </listitem>

     <listitem>
      <para>
       查询上的<command>FOR</command>循环（不是游标）的工作方式同样不同：目标变量必须已经被声明，而<application>PL/SQL</application>总是会隐式地声明它们。但是这样做的优点是在退出循环后，变量值仍然可以访问。
      </para>
     </listitem>

     <listitem>
      <para>
       在使用游标变量方面，存在一些记法差异。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
<!--==========================orignal english content==========================
   <title>Porting Examples</title>
____________________________________________________________________________-->
   <title>移植示例</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="pgsql-porting-ex1"/> shows how to port a simple
    function from <application>PL/SQL</application> to <application>PL/pgSQL</application>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="pgsql-porting-ex1"/>展示了如何从<application>PL/SQL</application>移植一个简单的函数到<application>PL/pgSQL</application>中。
   </para>

   <example id="pgsql-porting-ex1">
<!--==========================orignal english content==========================
    <title>Porting a Simple Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个简单的函数到<application>PL/pgSQL</application></title>

<!--==========================orignal english content==========================
    <para>
     Here is an <productname>Oracle</productname> <application>PL/SQL</application> function:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里有一个<productname>Oracle</productname> <application>PL/SQL</application>函数：
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Let's go through this function and see the differences compared to
     <application>PL/pgSQL</application>:

     <itemizedlist>
      <listitem>
       <para>
        The type name <type>varchar2</type> has to be changed to <type>varchar</type>
        or <type>text</type>.  In the examples in this section, we'll
        use <type>varchar</type>, but <type>text</type> is often a better choice if
        you do not need specific string length limits.
       </para>
      </listitem>

      <listitem>
       <para>
        The <literal>RETURN</literal> key word in the function
        prototype (not the function body) becomes
        <literal>RETURNS</literal> in
        <productname>PostgreSQL</productname>.
        Also, <literal>IS</literal> becomes <literal>AS</literal>, and you need to
        add a <literal>LANGUAGE</literal> clause because <application>PL/pgSQL</application>
        is not the only possible function language.
       </para>
      </listitem>

      <listitem>
       <para>
        In <productname>PostgreSQL</productname>, the function body is considered
        to be a string literal, so you need to use quote marks or dollar
        quotes around it.  This substitutes for the terminating <literal>/</literal>
        in the Oracle approach.
       </para>
      </listitem>

      <listitem>
       <para>
        The <literal>show errors</literal> command does not exist in
        <productname>PostgreSQL</productname>, and is not needed since errors are
        reported automatically.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     让我们过一遍这个函数并且看看与<application>PL/pgSQL</application>相比有什么样的不同：

     <itemizedlist>
      <listitem>
       <para>
        类型名称<type>varchar2</type>被改成了<type>varchar</type>或者<type>text</type>。在这一节的例子中，我们将使用<type>varchar</type>，但如果不需要特定的字符串长度限制，<type>text</type>常常是更好的选择。
       </para>
      </listitem>
      
      <listitem>
       <para>
        在函数原型中（不是函数体中）的<literal>RETURN</literal>关键字在<productname>PostgreSQL</productname>中变成了<literal>RETURNS</literal>。还有，<literal>IS</literal>变成了<literal>AS</literal>，并且你还需要增加一个<literal>LANGUAGE</literal>子句，因为<application>PL/pgSQL</application>并非唯一可用的函数语言。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</productname>中，函数体被认为是一个字符串，所以你需要使用引号或者美元符号包围它。这代替了Oracle 方法中的用于终止的<literal>/</literal>。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</productname>中没有<literal>show errors</literal>命令, 并且也不需要这个命令，因为错误是自动报告的。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     This is how this function would look when ported to
     <productname>PostgreSQL</productname>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这个函数被移植到<productname>PostgreSQL</productname>后看起来会是这样：

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="plpgsql-porting-ex2"/> shows how to port a
    function that creates another function and how to handle the
    ensuing quoting problems.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex2"/>展示了如何移植一个会创建另一个函数的函数，以及如何处理引号问题。
   </para>

   <example id="plpgsql-porting-ex2">
<!--==========================orignal english content==========================
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个创建另一个函数的函数到<application>PL/pgSQL</application></title>

<!--==========================orignal english content==========================
    <para>
     The following procedure grabs rows from a
     <command>SELECT</command> statement and builds a large function
     with the results in <literal>IF</literal> statements, for the
     sake of efficiency.
    </para>
____________________________________________________________________________-->
    <para>
     下面的过程从一个<command>SELECT</command>语句抓取行，并且为了效率而构建一个带有<literal>IF</literal>语句中结果的大型函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';
                 
    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is how this function would end up in <productname>PostgreSQL</productname>:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     Notice how the body of the function is built separately and passed
     through <literal>quote_literal</literal> to double any quote marks in it.  This
     technique is needed because we cannot safely use dollar quoting for
     defining the new function: we do not know for sure what strings will
     be interpolated from the <structfield>referrer_key.key_string</structfield> field.
     (We are assuming here that <structfield>referrer_key.kind</structfield> can be
     trusted to always be <literal>host</literal>, <literal>domain</literal>, or
     <literal>url</literal>, but <structfield>referrer_key.key_string</structfield> might be
     anything, in particular it might contain dollar signs.) This function
     is actually an improvement on the Oracle original, because it will
     not generate broken code when <structfield>referrer_key.key_string</structfield> or
     <structfield>referrer_key.referrer_type</structfield> contain quote marks.
    </para>
____________________________________________________________________________-->
    <para>
     这里是<productname>PostgreSQL</productname>的版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     请注意函数体是如何被单独构建并且通过<literal>quote_literal</literal>被传递以双写其中的任何引号。需要这个技术是因为无法安全地使用美元引用定义新函数：我们不确定从<structfield>referrer_key.key_string</structfield>域中来的什么字符串会被插入（我们这里假定<structfield>referrer_key.kind</structfield>可以确信总是为<literal>host</literal>、<literal>domain</literal>或者<literal>url</literal>，但是<structfield>referrer_key.key_string</structfield>可能是任何东西，特别是它可能包含美元符号）。这个函数实际上是在 Oracle 的原版上的改进，因为当<structfield>referrer_key.key_string</structfield>或者<structfield>referrer_key.referrer_type</structfield>包含引号时，它将不会生成坏掉的代码。
    </para>
   </example>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="plpgsql-porting-ex3"/> shows how to port a function
    with <literal>OUT</literal> parameters and string manipulation.
    <productname>PostgreSQL</productname> does not have a built-in
    <function>instr</function> function, but you can create one
    using a combination of other
    functions. In <xref linkend="plpgsql-porting-appendix"/> there is a
    <application>PL/pgSQL</application> implementation of
    <function>instr</function> that you can use to make your porting
    easier.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex3"/>展示了如何移植一个带有<literal>OUT</literal>参数和字符串处理的函数。<productname>PostgreSQL</productname>没有内建的<function>instr</function>函数，但是你可以用其它函数的组合来创建一个。在<xref linkend="plpgsql-porting-appendix"/>中有一个<function>instr</function>的<application>PL/pgSQL</application>实现，你可以用它让你的移植变得更容易。
   </para>

   <example id="plpgsql-porting-ex3">
<!--==========================orignal english content==========================
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</literal> Parameters from <application>PL/SQL</application> to
    <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个带有字符串操作以及<literal>OUT</literal>参数的过程到<application>PL/pgSQL</application></title>

<!--==========================orignal english content==========================
    <para>
     The following <productname>Oracle</productname> PL/SQL procedure is used
     to parse a URL and return several elements (host, path, and query).
    </para>
____________________________________________________________________________-->
    <para>
     下面的<productname>Oracle</productname> PL/SQL 过程被用来解析一个 URL 并且返回一些元素（主机、路径和查询）。
    </para>

<!--==========================orignal english content==========================
    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
    v_host OUT VARCHAR2,  -&minus; This will be passed back
    v_path OUT VARCHAR2,  -&minus; This one too
    v_query OUT VARCHAR2) -&minus; And this one
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
    v_host OUT VARCHAR2,  -- 这将被传回去
    v_path OUT VARCHAR2,  -- 这个也是
    v_query OUT VARCHAR2) -- 还有这个
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is a possible translation into <application>PL/pgSQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -&minus; This will be passed back
    v_path OUT VARCHAR,  -&minus; This one too
    v_query OUT VARCHAR) -&minus; And this one
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     This function could be used like this:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一种到<application>PL/pgSQL</application>的可能翻译：
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- 这将被传递回去
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 以及这个
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     这个函数可以这样使用：
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="plpgsql-porting-ex4"/> shows how to port a procedure
    that uses numerous features that are specific to Oracle.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex4"/>展示了如何移植一个使用了多种 Oracle 特性的过程。
   </para>

   <example id="plpgsql-porting-ex4">
<!--==========================orignal english content==========================
    <title>Porting a Procedure from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
____________________________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个过程到<application>PL/pgSQL</application></title>

<!--==========================orignal english content==========================
    <para>
     The Oracle version:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -&minus; free lock
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -&minus; don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>
____________________________________________________________________________-->
    <para>
     Oracle 版本：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- 释放锁
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- 如果已经存在也不用担心
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    This is how we could port this procedure to <application>PL/pgSQL</application>:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -&minus; free lock
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -&minus; <co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN -&minus; <co id="co.plpgsql-porting-exception"/>
            -&minus; don't worry if it already exists
    END;
    COMMIT;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       The syntax of <literal>RAISE</literal> is considerably different from
       Oracle's statement, although the basic case <literal>RAISE</literal>
       <replaceable class="parameter">exception_name</replaceable> works
       similarly.
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       The exception names supported by <application>PL/pgSQL</application> are
       different from Oracle's.  The set of built-in exception names
       is much larger (see <xref linkend="errcodes-appendix"/>).  There
       is not currently a way to declare user-defined exception names,
       although you can throw user-chosen SQLSTATE values instead.
      </para>
     </callout>
    </calloutlist>
   </para>
____________________________________________________________________________-->
   <para>
    这是我们如何将这个过程移植到<application>PL/pgSQL</application>：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- 释放锁
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -- <co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN -- <co id="co.plpgsql-porting-exception"/>
            -- 如果已经存在不要担心
    END;
    COMMIT;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       <literal>RAISE</literal>的语法与 Oracle 的语句相当不同，尽管基本的形式<literal>RAISE</literal> <replaceable class="parameter">exception_name</replaceable>工作起来是相似的。
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       <application>PL/pgSQL</application>所支持的异常名称不同于 Oracle。内建的异常名称集合要更大（见<xref linkend="errcodes-appendix"/>）。目前没有办法声明用户定义的异常名称，尽管你能够抛出用户选择的 SQLSTATE 值。
      </para>
     </callout>
    </calloutlist>
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
<!--==========================orignal english content==========================
   <title>Other Things to Watch For</title>
____________________________________________________________________________-->
   <title>其他要关注的事项</title>

<!--==========================orignal english content==========================
   <para>
    This section explains a few other things to watch for when porting
    Oracle <application>PL/SQL</application> functions to
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    这一节解释了在移植 Oracle <application>PL/SQL</application>函数到<productname>PostgreSQL</productname>中时要关注的一些其他问题。
   </para>

   <sect3 id="plpgsql-porting-exceptions">
<!--==========================orignal english content==========================
    <title>Implicit Rollback after Exceptions</title>
____________________________________________________________________________-->
    <title>异常后隐式回滚</title>

<!--==========================orignal english content==========================
    <para>
     In <application>PL/pgSQL</application>, when an exception is caught by an
     <literal>EXCEPTION</literal> clause, all database changes since the block's
     <literal>BEGIN</literal> are automatically rolled back.  That is, the behavior
     is equivalent to what you'd get in Oracle with:

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>

     If you are translating an Oracle procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in this style,
     your task is easy: just omit the <command>SAVEPOINT</command> and
     <command>ROLLBACK TO</command>.  If you have a procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in a different way
     then some actual thought will be required.
    </para>
____________________________________________________________________________-->
    <para>
     在<application>PL/pgSQL</application>，当一个异常被<literal>EXCEPTION</literal>子句捕获之后，从该块的<literal>BEGIN</literal>以来的所有数据库改变都会被自动回滚。也就是，该行为等效于你在 Oracle 中用下面的代码得到的效果：

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... 代码 ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
END;
</programlisting>

     如果你正在翻译一个使用这种风格的<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>的 Oracle 过程，你的工作比较简单：只要忽略掉<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>。如果你的 Oracle 过程是以不同的方法使用<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>，那么就要真正地动一番脑筋了。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><command>EXECUTE</command></title>
____________________________________________________________________________-->
    <title><command>EXECUTE</command></title>

<!--==========================orignal english content==========================
    <para>
     The <application>PL/pgSQL</application> version of
     <command>EXECUTE</command> works similarly to the
     <application>PL/SQL</application> version, but you have to remember to use
     <function>quote_literal</function> and
     <function>quote_ident</function> as described in <xref
     linkend="plpgsql-statements-executing-dyn"/>.  Constructs of the
     type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work
     reliably unless you use these functions.
    </para>
____________________________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>的<command>EXECUTE</command>与<application>PL/SQL</application>中的工作相似，但是必须要记住按照<xref linkend="plpgsql-statements-executing-dyn"/>中所述地使用<function>quote_literal</function>以及<function>quote_ident</function>。<literal>EXECUTE 'SELECT * FROM $1';</literal>类型的结构将无法可靠地工作除非你使用这些函数。
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
<!--==========================orignal english content==========================
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>
____________________________________________________________________________-->
    <title>优化 <application>PL/pgSQL</application> 函数</title>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> gives you two function creation
     modifiers to optimize execution: <quote>volatility</quote> (whether
     the function always returns the same result when given the same
     arguments) and <quote>strictness</quote> (whether the function
     returns null if any argument is null).  Consult the <xref
     linkend="sql-createfunction"/>
     reference page for details.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>提供了两种函数创建修饰符来优化执行：<quote>volatility</quote>（对于给定的相同参数，函数是否总是返回相同的结果）以及<quote>strictness</quote> （如果任何参数为空，函数是否返回空）。详见<xref linkend="sql-createfunction"/>参考页。
    </para>

<!--==========================orignal english content==========================
    <para>
     When making use of these optimization attributes, your
     <command>CREATE FUNCTION</command> statement might look something
     like this:

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在利用这些优化属性时，你的<command>CREATE FUNCTION</command>语句应该看起来像这样：

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
<!--==========================orignal english content==========================
   <title>Appendix</title>
____________________________________________________________________________-->
   <title>附录</title>

<!--==========================orignal english content==========================
   <para>
    This section contains the code for a set of Oracle-compatible
    <function>instr</function> functions that you can use to simplify
    your porting efforts.
   </para>
____________________________________________________________________________-->
   <para>
    这一节包含了一组 Oracle 兼容的<function>instr</function>函数代码，你可以用它来简化你的移植工作。
   </para>
   
<!--==========================orignal english content==========================
   <indexterm>
    <primary><function>instr</function> function</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary><function>instr</function> 函数</primary>
   </indexterm>

<!--==========================orignal english content==========================
<programlisting><![CDATA[
-&minus;
-&minus; instr functions that mimic Oracle's counterpart
-&minus; Syntax: instr(string1, string2 [, n [, m]])
-&minus; where [] denotes optional parameters.
-&minus;
-&minus; Search string1, beginning at the nth character, for the mth occurrence
-&minus; of string2.  If n is negative, search backwards, starting at the abs(n)'th
-&minus; character from the end of string1.
-&minus; If n is not passed, assume 1 (search starts at first character).
-&minus; If m is not passed, assume 1 (find first occurrence).
-&minus; Returns starting index of string2 in string1, or 0 if string2 is not found.
-&minus;

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
BEGIN
    RETURN instr($1, $2, 1);
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search_for IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF occur_index <= 0 THEN
        RAISE 'argument ''%'' is out of range', occur_index
          USING ERRCODE = '22003';
    END IF;

    IF beg_index > 0 THEN
        beg := beg_index - 1;
        FOR i IN 1..occur_index LOOP
            temp_str := substring(string FROM beg + 1);
            pos := position(string_to_search_for IN temp_str);
            IF pos = 0 THEN
                RETURN 0;
            END IF;
            beg := beg + pos;
        END LOOP;

        RETURN beg;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                occur_number := occur_number + 1;
                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting><![CDATA[
--
-- instr 函数模仿 Oracle 的对应函数
-- 语法: instr(string1, string2 [, n [, m]])
-- 其中 [] 表示可选参数。
--
-- 从第n个字符开始搜索string1，要求找到string2的第m次出现。
-- 如果n为负，则从后向前搜索，从string1的末尾开始的第abs(n)个字符开始。
-- 如果没有传n，假定它为1（从第1个字符开始搜索）。
-- 如果没有传m，假定它为1（找第1次出现）。
-- 在string1中返回string2的开始索引，如果没有找到string2则为0。
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
BEGIN
    RETURN instr($1, $2, 1);
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search_for IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF occur_index <= 0 THEN
        RAISE 'argument ''%'' is out of range', occur_index
          USING ERRCODE = '22003';
    END IF;

    IF beg_index > 0 THEN
        beg := beg_index - 1;
        FOR i IN 1..occur_index LOOP
            temp_str := substring(string FROM beg + 1);
            pos := position(string_to_search_for IN temp_str);
            IF pos = 0 THEN
                RETURN 0;
            END IF;
            beg := beg + pos;
        END LOOP;

        RETURN beg;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                occur_number := occur_number + 1;
                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
]]>
</programlisting>
  </sect2>

 </sect1>

</chapter>
