<!-- doc/src/sgml/ltree.sgml -->

<sect1 id="ltree" xreflabel="ltree">
<!--==========================orignal english content==========================
 <title>ltree</title>
____________________________________________________________________________-->
 <title>ltree</title>

<!--==========================orignal english content==========================
 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  This module implements a data type <type>ltree</> for representing
  labels of data stored in a hierarchical tree-like structure.
  Extensive facilities for searching through label trees are provided.
 </para>
____________________________________________________________________________-->
 <para>
  这个模块实现了一种数据类型<type>ltree</type>用于表示存储在一个层次树状结构中的数据的标签。还提供了在标签树中搜索的扩展功能。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>Definitions</title>
____________________________________________________________________________-->
  <title>定义</title>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>label</firstterm> is a sequence of alphanumeric characters
   and underscores (for example, in C locale the characters
   <literal>A-Za-z0-9_</> are allowed).  Labels must be less than 256 bytes
   long.
  </para>
____________________________________________________________________________-->
  <para>
   一个<firstterm>标签</firstterm>是一个字母数字字符和下划线的序列（例如，在 C 区域中允许字符<literal>A-Za-z0-9_</literal>）。标签长度必须少于 256 字节。
  </para>

<!--==========================orignal english content==========================
  <para>
   Examples: <literal>42</>, <literal>Personal_Services</>
  </para>
____________________________________________________________________________-->
  <para>
   例子： <literal>42</literal>, <literal>Personal_Services</literal>
  </para>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>label path</firstterm> is a sequence of zero or more
   labels separated by dots, for example <literal>L1.L2.L3</>, representing
   a path from the root of a hierarchical tree to a particular node.  The
   length of a label path must be less than 65kB, but keeping it under 2kB is
   preferable.  In practice this is not a major limitation; for example,
   the longest label path in the DMOZ catalog (<ulink
   url="http://www.dmoz.org"></ulink>) is about 240 bytes.
  </para>
____________________________________________________________________________-->
  <para>
   一个<firstterm>标签路径</firstterm>是由点号分隔的零个或者更多个标签的序列，例如<literal>L1.L2.L3</literal>，它表示一个从层次树的根到一个特定节点的路径。一个标签路径的长度必须小于 65kB，但是最好将它保持在 2kB 以下。实际上这不是一个主要限制，例如在 DMOZ 目录（<ulink
   url="http://www.dmoz.org"></ulink>）中最长的标签路径大约是 240 字节。
  </para>

<!--==========================orignal english content==========================
  <para>
   Example: <literal>Top.Countries.Europe.Russia</literal>
  </para>
____________________________________________________________________________-->
  <para>
   例子：<literal>Top.Countries.Europe.Russia</literal>
  </para>

<!--==========================orignal english content==========================
  <para>
   The <filename>ltree</> module provides several data types:
  </para>
____________________________________________________________________________-->
  <para>
   <filename>ltree</filename>模块提供多种数据类型：
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     <type>ltree</type> stores a label path.
    </para>
____________________________________________________________________________-->
    <para>
     <type>ltree</type>存储一个标签路径。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     <type>lquery</type> represents a regular-expression-like pattern
     for matching <type>ltree</> values.  A simple word matches that
     label within a path.  A star symbol (<literal>*</>) matches zero
     or more labels.  For example:
<synopsis>
foo         <lineannotation>Match the exact label path <literal>foo</></lineannotation>
*.foo.*     <lineannotation>Match any label path containing the label <literal>foo</></lineannotation>
*.foo       <lineannotation>Match any label path whose last label is <literal>foo</></lineannotation>
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     <type>lquery</type>表示一个用于匹配<type>ltree</type>值的类正则表达式的模式。一个简单词匹配一个路径中的那个标签。一个星号（<literal>*</literal>）匹配零个或更多个标签。例如：
<synopsis>
foo         <lineannotation>正好匹配标签路径<literal>foo</literal></lineannotation>
*.foo.*     <lineannotation>匹配任何包含标签<literal>foo</literal>的标签路径</lineannotation>
*.foo       <lineannotation>匹配任何最后一个标签是<literal>foo</literal>的标签路径</lineannotation>
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     Star symbols can also be quantified to restrict how many labels
     they can match:
<synopsis>
*{<replaceable>n</>}        <lineannotation>Match exactly <replaceable>n</> labels</lineannotation>
*{<replaceable>n</>,}       <lineannotation>Match at least <replaceable>n</> labels</lineannotation>
*{<replaceable>n</>,<replaceable>m</>}      <lineannotation>Match at least <replaceable>n</> but not more than <replaceable>m</> labels</lineannotation>
*{,<replaceable>m</>}       <lineannotation>Match at most <replaceable>m</> labels &mdash; same as </lineannotation> *{0,<replaceable>m</>}
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     星号也可以被限定来限制它能匹配多少标签：
<synopsis>
*{<replaceable>n</replaceable>}        <lineannotation>匹配正好<replaceable>n</replaceable>个标签</lineannotation>
*{<replaceable>n</replaceable>,}       <lineannotation>匹配至少<replaceable>n</replaceable>个标签</lineannotation>
*{<replaceable>n</replaceable>,<replaceable>m</replaceable>}      <lineannotation>匹配至少<replaceable>n</replaceable>个但是最多<replaceable>m</replaceable>个标签</lineannotation>
*{,<replaceable>m</replaceable>}       <lineannotation>匹配最多<replaceable>m</replaceable>个标签 &mdash; 与*{0,<replaceable>m</replaceable>}相同</lineannotation> 
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     There are several modifiers that can be put at the end of a non-star
     label in <type>lquery</> to make it match more than just the exact match:
<synopsis>
@           <lineannotation>Match case-insensitively, for example <literal>a@</> matches <literal>A</></lineannotation>
*           <lineannotation>Match any label with this prefix, for example <literal>foo*</> matches <literal>foobar</></lineannotation>
%           <lineannotation>Match initial underscore-separated words</lineannotation>
</synopsis>
     The behavior of <literal>%</> is a bit complicated.  It tries to match
     words rather than the entire label.  For example
     <literal>foo_bar%</> matches <literal>foo_bar_baz</> but not
     <literal>foo_barbaz</>.  If combined with <literal>*</>, prefix
     matching applies to each word separately, for example
     <literal>foo_bar%*</> matches <literal>foo1_bar2_baz</> but
     not <literal>foo1_br2_baz</>.
    </para>
____________________________________________________________________________-->
    <para>
     在<type>lquery</type>中，有多种修饰符可以被放在一个非星号标签的末尾来让它不仅仅能准确匹配：
<synopsis>
@           <lineannotation>不区分大小写匹配，例如<literal>a@</literal>匹配<literal>A</literal></lineannotation>
*           <lineannotation>匹配带此前缀的任何标签，例如<literal>foo*</literal>匹配<literal>foobar</literal></lineannotation>
%           <lineannotation>匹配开头以下划线分隔的词</lineannotation>
</synopsis>
     <literal>%</literal>的行为有点复杂。它尝试匹配词而不是整个标签。例如，<literal>foo_bar%</literal>匹配<literal>foo_bar_baz</literal>但是不匹配<literal>foo_barbaz</literal>。如果和<literal>*</literal>组合，前缀匹配可以单独应用于每一个词，例如<literal>foo_bar%*</literal>匹配<literal>foo1_bar2_baz</literal>但不匹配<literal>foo1_br2_baz</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, you can write several possibly-modified labels separated with
     <literal>|</> (OR) to match any of those labels, and you can put
     <literal>!</> (NOT) at the start to match any label that doesn't
     match any of the alternatives.
    </para>
____________________________________________________________________________-->
    <para>
     此外，你可以写多个带有<literal>|</literal>（OR）的可能改过的标签来匹配那些标签中的任何一个（或几个），并且你可以在最前面放上<literal>!</literal>（NOT）来匹配任何不匹配那些分支的标签。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here's an annotated example of <type>lquery</type>:
<programlisting>
Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
a.  b.     c.      d.               e.
</programlisting>
     This query will match any label path that:
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个<type>lquery</type>的例子：
<programlisting>
Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
a.  b.     c.      d.               e.
</programlisting>
     这个查询将匹配任何这样的标签路径：
    </para>
    <orderedlist numeration="loweralpha">
     <listitem>
<!--==========================orignal english content==========================
      <para>
       begins with the label <literal>Top</literal>
      </para>
____________________________________________________________________________-->
      <para>
       开始于标签<literal>Top</literal>
      </para>
     </listitem>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       and next has zero to two labels before
      </para>
____________________________________________________________________________-->
      <para>
       并且接着具有 0 到 2 个标签
      </para>
     </listitem>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       a label beginning with the case-insensitive prefix <literal>sport</literal>
      </para>
____________________________________________________________________________-->
      <para>
       之后是一个开始于大小写无关的前缀<literal>sport</literal>的标签
      </para>
     </listitem>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       then a label not matching <literal>football</literal> nor
       <literal>tennis</literal>
      </para>
____________________________________________________________________________-->
      <para>
       再后是一个不匹配<literal>football</literal>和<literal>tennis</literal>的标签
      </para>
     </listitem>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       and then ends with a label beginning with <literal>Russ</literal> or
       exactly matching <literal>Spain</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       并且结尾是一个开始于<literal>Russ</literal>的标签，或者完全匹配<literal>Spain</literal>的标签。
      </para>
     </listitem>
    </orderedlist>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para><type>ltxtquery</type> represents a full-text-search-like
    pattern for matching <type>ltree</> values.  An
    <type>ltxtquery</type> value contains words, possibly with the
    modifiers <literal>@</>, <literal>*</>, <literal>%</> at the end;
    the modifiers have the same meanings as in <type>lquery</>.
    Words can be combined with <literal>&amp;</> (AND),
    <literal>|</> (OR), <literal>!</> (NOT), and parentheses.
    The key difference from
    <type>lquery</> is that <type>ltxtquery</type> matches words without
    regard to their position in the label path.
    </para>
____________________________________________________________________________-->
    <para><type>ltxtquery</type>表示一种用于匹配<type>ltree</type>值的类全文搜索的模式。一个<type>ltxtquery</type>值包含词，也可能在末尾带有修饰符<literal>@</literal>、<literal>*</literal>、<literal>%</literal>，修饰符具有和<type>lquery</type>中相同的含义。词可以用<literal>&amp;</literal>（AND）、<literal>|</literal>（OR）、<literal>!</literal>（NOT）以及圆括号组合。<type>lquery</type>和<type>ltxtquery</type>的关键区别是前者匹配词时不考虑它们在标签路径中的位置。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here's an example <type>ltxtquery</type>:
<programlisting>
Europe &amp; Russia*@ &amp; !Transportation
</programlisting>
     This will match paths that contain the label <literal>Europe</literal> and
     any label beginning with <literal>Russia</literal> (case-insensitive),
     but not paths containing the label <literal>Transportation</literal>.
     The location of these words within the path is not important.
     Also, when <literal>%</> is used, the word can be matched to any
     underscore-separated word within a label, regardless of position.
    </para>
____________________________________________________________________________-->
    <para>
     这是一个<type>ltxtquery</type>的例子：
<programlisting>
Europe &amp; Russia*@ &amp; !Transportation
</programlisting>
     这将匹配包含标签<literal>Europe</literal>以及任何以<literal>Russia</literal>开始（大小写不敏感）的标签的路径，但是不匹配包含标签<literal>Transportation</literal>的路径。这些词在路径中的位置并不重要。还有，当使用<literal>%</literal>时，该次可以与一个标签中任何下划线分隔的词匹配，而不管它们的位置如何。
    </para>
   </listitem>

  </itemizedlist>

<!--==========================orignal english content==========================
  <para>
   Note: <type>ltxtquery</> allows whitespace between symbols, but
   <type>ltree</> and <type>lquery</> do not.
  </para>
____________________________________________________________________________-->
  <para>
   注意：<type>ltxtquery</type>允许符号之间的空白，但是<type>ltree</type>和<type>lquery</type>不允许。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Operators and Functions</title>
____________________________________________________________________________-->
  <title>操作符和函数</title>

<!--==========================orignal english content==========================
  <para>
   Type <type>ltree</> has the usual comparison operators
   <literal>=</>, <literal>&lt;&gt;</literal>,
   <literal>&lt;</>, <literal>&gt;</>, <literal>&lt;=</>, <literal>&gt;=</>.
   Comparison sorts in the order of a tree traversal, with the children
   of a node sorted by label text.  In addition, the specialized
   operators shown in <xref linkend="ltree-op-table"> are available.
  </para>
____________________________________________________________________________-->
  <para>
   类型<type>ltree</type>有普通比较操作符
   <literal>=</literal>、<literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、<literal>&gt;</literal>、<literal>&lt;=</literal>、<literal>&gt;=</literal>。
   比较会按照树遍历的顺序排序，一个节点的子女按照标签文本排序。另外，还有<xref linkend="ltree-op-table"/>中显示的特殊操作符。
  </para>

  <table id="ltree-op-table">
<!--==========================orignal english content==========================
   <title><type>ltree</> Operators</title>
____________________________________________________________________________-->
   <title><type>ltree</type> 操作符</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Operator</entry>
      <entry>Returns</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>操作符</entry>
      <entry>返回值</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>@&gt;</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>is left argument an ancestor of right (or equal)?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>@&gt;</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry>左参数是不是右参数的一个祖先（或者相等）？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>&lt;@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>is left argument a descendant of right (or equal)?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>&lt;@</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry>左参数是不是右参数的一个后代（或者相等）？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>~</> <type>lquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>~</literal> <type>lquery</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配<type>lquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>lquery</> <literal>~</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>lquery</type> <literal>~</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配<type>lquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>?</> <type>lquery[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match any <type>lquery</> in array?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>?</literal> <type>lquery[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配数组中的任意<type>lquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>lquery[]</> <literal>?</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match any <type>lquery</> in array?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>lquery[]</type> <literal>?</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配数组中的任意<type>lquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>@</> <type>ltxtquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match <type>ltxtquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>@</literal> <type>ltxtquery</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配<type>ltxtquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltxtquery</> <literal>@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> match <type>ltxtquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltxtquery</type> <literal>@</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>匹配<type>ltxtquery</type>吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>||</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>concatenate <type>ltree</> paths</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>||</literal> <type>ltree</type></entry>
      <entry><type>ltree</type></entry>
      <entry>串接<type>ltree</type>路径</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>||</> <type>text</></entry>
      <entry><type>ltree</type></entry>
      <entry>convert text to <type>ltree</> and concatenate</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>||</literal> <type>text</type></entry>
      <entry><type>ltree</type></entry>
      <entry>把文本转换成<type>ltree</type>并且串接</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>text</> <literal>||</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>convert text to <type>ltree</> and concatenate</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>text</type> <literal>||</literal> <type>ltree</type></entry>
      <entry><type>ltree</type></entry>
      <entry>把文本转换成<type>ltree</type>并且串接</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>@&gt;</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain an ancestor of <type>ltree</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>@&gt;</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</type>的一个祖先？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>&lt;@</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain an ancestor of <type>ltree</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>&lt;@</literal> <type>ltree[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</type>的一个祖先？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>&lt;@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain a descendant of <type>ltree</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>&lt;@</literal> <type>ltree</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</type>的一个后代？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree</> <literal>@&gt;</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain a descendant of <type>ltree</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree</type> <literal>@&gt;</literal> <type>ltree[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</type>的一个后代？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>~</> <type>lquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain any path matching <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>~</literal> <type>lquery</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>lquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>lquery</> <literal>~</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain any path matching <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>lquery</type> <literal>~</literal> <type>ltree[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>lquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>?</> <type>lquery[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> array contain any path matching any <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>?</literal> <type>lquery[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>数组是否包含匹配任意<type>lquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>lquery[]</> <literal>?</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does <type>ltree</> array contain any path matching any <type>lquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>lquery[]</type> <literal>?</literal> <type>ltree[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</type>数组是否包含匹配任意<type>lquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>@</> <type>ltxtquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain any path matching <type>ltxtquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>@</literal> <type>ltxtquery</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>ltxtquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltxtquery</> <literal>@</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>does array contain any path matching <type>ltxtquery</>?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltxtquery</type> <literal>@</literal> <type>ltree[]</type></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>ltxtquery</type>的路径？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>?@&gt;</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>first array entry that is an ancestor of <type>ltree</>; NULL if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>?@&gt;</literal> <type>ltree</type></entry>
      <entry><type>ltree</type></entry>
      <entry>是<type>ltree</type>祖先的第一个数组项；如果没有则是 NULL</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>?&lt;@</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>first array entry that is a descendant of <type>ltree</>; NULL if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>?&lt;@</literal> <type>ltree</type></entry>
      <entry><type>ltree</type></entry>
      <entry>是<type>ltree</type>祖先的第一个数组项；如果没有则是 NULL</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>?~</> <type>lquery</></entry>
      <entry><type>ltree</type></entry>
      <entry>first array entry that matches <type>lquery</>; NULL if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>?~</literal> <type>lquery</type></entry>
      <entry><type>ltree</type></entry>
      <entry>匹配<type>lquery</type>的第一个数组项；如果没有则是 NULL</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><type>ltree[]</> <literal>?@</> <type>ltxtquery</></entry>
      <entry><type>ltree</type></entry>
      <entry>first array entry that matches <type>ltxtquery</>; NULL if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><type>ltree[]</type> <literal>?@</literal> <type>ltxtquery</type></entry>
      <entry><type>ltree</type></entry>
      <entry>匹配<type>lquery</type>的第一个数组项；如果没有则是 NULL</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The operators <literal>&lt;@</literal>, <literal>@&gt;</literal>,
   <literal>@</literal> and <literal>~</literal> have analogues
   <literal>^&lt;@</>, <literal>^@&gt;</>, <literal>^@</>,
   <literal>^~</literal>, which are the same except they do not use
   indexes.  These are useful only for testing purposes.
  </para>
____________________________________________________________________________-->
  <para>
   操作符<literal>&lt;@</literal>、<literal>@&gt;</literal>、
   <literal>@</literal>以及<literal>~</literal>有类似的、
   <literal>^&lt;@</literal>、<literal>^@&gt;</literal>、<literal>^@</literal>、
   <literal>^~</literal>，只是它们不适用索引。它们只对测试目的有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The available functions are shown in <xref linkend="ltree-func-table">.
  </para>
____________________________________________________________________________-->
  <para>
   可用的函数在<xref linkend="ltree-func-table"/>中。
  </para>

  <table id="ltree-func-table">
<!--==========================orignal english content==========================
   <title><type>ltree</> Functions</title>
____________________________________________________________________________-->
   <title><type>ltree</type> 函数</title>

   <tgroup cols="5">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      <entry>Example</entry>
      <entry>Result</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
      <entry>例子</entry>
      <entry>结果</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><function>subltree(ltree, int start, int end)</function><indexterm><primary>subltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>subpath of <type>ltree</> from position <parameter>start</> to
       position <parameter>end</>-1 (counting from 0)</entry>
      <entry><literal>subltree('Top.Child1.Child2',1,2)</literal></entry>
      <entry><literal>Child1</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>subltree(ltree, int start, int end)</function><indexterm><primary>subltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</type>的从位置<parameter>start</parameter>到位置<parameter>end</parameter>-1（从 0 开始计）的子路径</entry>
      <entry><literal>subltree('Top.Child1.Child2',1,2)</literal></entry>
      <entry><literal>Child1</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>subpath(ltree, int offset, int len)</function><indexterm><primary>subpath</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>subpath of <type>ltree</> starting at position
       <parameter>offset</>, length <parameter>len</>.
       If <parameter>offset</> is negative, subpath starts that far from the
       end of the path.  If <parameter>len</> is negative, leaves that many
       labels off the end of the path.</entry>
      <entry><literal>subpath('Top.Child1.Child2',0,2)</literal></entry>
      <entry><literal>Top.Child1</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>subpath(ltree, int offset, int len)</function><indexterm><primary>subpath</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</type>从位置<parameter>offset</parameter>开始长度为<parameter>len</parameter>的子路径。如果<parameter>offset</parameter>为负，则子路径开始于距离路径尾部那么远的位置。如果<parameter>len</parameter>为负，则从路径的尾部开始丢掉那么多个标签。</entry>
      <entry><literal>subpath('Top.Child1.Child2',0,2)</literal></entry>
      <entry><literal>Top.Child1</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>subpath(ltree, int offset)</function></entry>
      <entry><type>ltree</type></entry>
      <entry>subpath of <type>ltree</> starting at position
       <parameter>offset</>, extending to end of path.
       If <parameter>offset</> is negative, subpath starts that far from the
       end of the path.</entry>
      <entry><literal>subpath('Top.Child1.Child2',1)</literal></entry>
      <entry><literal>Child1.Child2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>subpath(ltree, int offset)</function></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</type>从位置<parameter>offset</parameter>开始一直延伸到路径末尾的子路径。如果<parameter>offset</parameter>为负，则子路径开始于距离路径尾部那么远的位置。</entry>
      <entry><literal>subpath('Top.Child1.Child2',1)</literal></entry>
      <entry><literal>Child1.Child2</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>nlevel(ltree)</function><indexterm><primary>nlevel</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry>number of labels in path</entry>
      <entry><literal>nlevel('Top.Child1.Child2')</literal></entry>
      <entry><literal>3</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>nlevel(ltree)</function><indexterm><primary>nlevel</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry>路径中标签的数量</entry>
      <entry><literal>nlevel('Top.Child1.Child2')</literal></entry>
      <entry><literal>3</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>index(ltree a, ltree b)</function><indexterm><primary>index</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry>position of first occurrence of <parameter>b</> in
       <parameter>a</>; -1 if not found</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6')</literal></entry>
      <entry><literal>6</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>index(ltree a, ltree b)</function><indexterm><primary>index</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry><parameter>a</parameter>中第一次出现<parameter>b</parameter>的位置，如果没有找到则为 -1</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6')</literal></entry>
      <entry><literal>6</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>index(ltree a, ltree b, int offset)</function></entry>
      <entry><type>integer</type></entry>
      <entry>position of first occurrence of <parameter>b</> in
       <parameter>a</>, searching starting at <parameter>offset</>;
       negative <parameter>offset</> means start <parameter>-offset</>
       labels from the end of the path</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4)</literal></entry>
      <entry><literal>9</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>index(ltree a, ltree b, int offset)</function></entry>
      <entry><type>integer</type></entry>
      <entry><parameter>a</parameter>中第一次出现<parameter>b</parameter>的位置，搜索从<parameter>offset</parameter>开始。负的<parameter>offset</parameter>表示从距路径尾部<parameter>-offset</parameter>个标签的位置开始</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4)</literal></entry>
      <entry><literal>9</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>text2ltree(text)</function><indexterm><primary>text2ltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>cast <type>text</> to <type>ltree</></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>text2ltree(text)</function><indexterm><primary>text2ltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>把<type>text</type>转换成<type>ltree</type></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>ltree2text(ltree)</function><indexterm><primary>ltree2text</primary></indexterm></entry>
      <entry><type>text</type></entry>
      <entry>cast <type>ltree</> to <type>text</></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>ltree2text(ltree)</function><indexterm><primary>ltree2text</primary></indexterm></entry>
      <entry><type>text</type></entry>
      <entry>把<type>ltree</type>转换成<type>text</type></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>lca(ltree, ltree, ...)</function><indexterm><primary>lca</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>lowest common ancestor, i.e., longest common prefix of paths
       (up to 8 arguments supported)</entry>
      <entry><literal>lca('1.2.2.3','1.2.3.4.5.6')</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>lca(ltree, ltree, ...)</function><indexterm><primary>lca</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>最低公共祖先，即最长的公共路径前缀（最多支持 8 个参数）</entry>
      <entry><literal>lca('1.2.2.3','1.2.3.4.5.6')</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><function>lca(ltree[])</function></entry>
      <entry><type>ltree</type></entry>
      <entry>lowest common ancestor, i.e., longest common prefix of paths</entry>
      <entry><literal>lca(array['1.2.2.3'::ltree,'1.2.3'])</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><function>lca(ltree[])</function></entry>
      <entry><type>ltree</type></entry>
      <entry>最低公共祖先，即最长的公共路径前缀</entry>
      <entry><literal>lca(array['1.2.2.3'::ltree,'1.2.3'])</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Indexes</title>
____________________________________________________________________________-->
  <title>索引</title>
<!--==========================orignal english content==========================
  <para>
   <filename>ltree</> supports several types of indexes that can speed
   up the indicated operators:
  </para>
____________________________________________________________________________-->
  <para>
   <filename>ltree</filename>支持一些能加速上述操作符的索引类型：
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     B-tree index over <type>ltree</>:
     <literal>&lt;</>, <literal>&lt;=</>, <literal>=</>,
     <literal>&gt;=</>, <literal>&gt;</literal>
    </para>
____________________________________________________________________________-->
    <para>
     <type>ltree</type>上的 B-树索引：
     <literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、
     <literal>&gt;=</literal>、<literal>&gt;</literal>
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     GiST index over <type>ltree</>:
     <literal>&lt;</>, <literal>&lt;=</>, <literal>=</>,
     <literal>&gt;=</>, <literal>&gt;</>,
     <literal>@&gt;</>, <literal>&lt;@</>,
     <literal>@</>, <literal>~</>, <literal>?</literal>
    </para>
____________________________________________________________________________-->
    <para>
     <type>ltree</type>上的 GiST 索引：
     <literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、
     <literal>&gt;=</literal>、<literal>&gt;</literal>、
     <literal>@&gt;</literal>、<literal>&lt;@</literal>、
     <literal>@</literal>、<literal>~</literal>、<literal>?</literal>
    </para>
<!--==========================orignal english content==========================
    <para>
     Example of creating such an index:
    </para>
____________________________________________________________________________-->
    <para>
     创建这样一个索引的例子：
    </para>
<!--==========================orignal english content==========================
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path);
</programlisting>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     GiST index over <type>ltree[]</>:
     <literal>ltree[] &lt;@ ltree</>, <literal>ltree @&gt; ltree[]</>,
     <literal>@</>, <literal>~</>, <literal>?</literal>
    </para>
____________________________________________________________________________-->
    <para>
     <type>ltree[]</type>上的 GiST 索引：
     <literal>ltree[] &lt;@ ltree</literal>、<literal>ltree @&gt; ltree[]</literal>、
     <literal>@</literal>、<literal>~</literal>、<literal>?</literal>
    </para>
<!--==========================orignal english content==========================
    <para>
     Example of creating such an index:
    </para>
____________________________________________________________________________-->
    <para>
     创建这样一个索引的例子：
    </para>
<!--==========================orignal english content==========================
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
</programlisting>
<!--==========================orignal english content==========================
    <para>
     Note: This index type is lossy.
    </para>
____________________________________________________________________________-->
    <para>
     注意：这种索引类型是有损的。
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Example</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   This example uses the following data (also available in file
   <filename>contrib/ltree/ltreetest.sql</> in the source distribution):
  </para>
____________________________________________________________________________-->
  <para>
   这个例子使用下列数据（在源代码发布的<filename>contrib/ltree/ltreetest.sql</filename>文件中也有）：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING GIST (path);
CREATE INDEX path_idx ON test USING BTREE (path);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING GIST (path);
CREATE INDEX path_idx ON test USING BTREE (path);
</programlisting>

<!--==========================orignal english content==========================
  <para>
   Now, we have a table <structname>test</> populated with data describing
   the hierarchy shown below:
  </para>
____________________________________________________________________________-->
  <para>
   现在，我们有一个表<structname>test</structname>，它被填充了描述下列层次的数据：
  </para>

<!--==========================orignal english content==========================
<literallayout class="monospaced">
                        Top
                     /   |  \
             Science Hobbies Collections
                 /       |              \
        Astronomy   Amateurs_Astronomy Pictures
           /  \                            |
Astrophysics  Cosmology                Astronomy
                                        /  |    \
                                 Galaxies Stars Astronauts
</literallayout>
____________________________________________________________________________-->
<literallayout class="monospaced">
                        Top
                     /   |  \
             Science Hobbies Collections
                 /       |              \
        Astronomy   Amateurs_Astronomy Pictures
           /  \                            |
Astrophysics  Cosmology                Astronomy
                                        /  |    \
                                 Galaxies Stars Astronauts
</literallayout>

<!--==========================orignal english content==========================
  <para>
   We can do inheritance:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   我们可以做继承：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
------------------------------------
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here are some examples of path matching:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.*.Astronomy.*';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   这里是一些路径匹配的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-----------------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.*.Astronomy.*';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here are some examples of full text search:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   这里是一些全文搜索的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   Path construction using functions:
<screen>
ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   使用函数的路径构建：
<screen>
ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   We could simplify this by creating a SQL function that inserts a label
   at a specified position in a path:
<screen>
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   我们可以通过常见一个在路径中指定位置插入标签的 SQL 函数来简化：
<screen>
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
 </sect2>
 
 <sect2>
<!--==========================orignal english content==========================
  <title>Transforms</title>
____________________________________________________________________________-->
  <title>转换</title>

<!--==========================orignal english content==========================
  <para>
   Additional extensions are available that implement transforms for
   the <type>ltree</type> type for PL/Python.  The extensions are
   called <literal>ltree_plpythonu</literal>, <literal>ltree_plpython2u</literal>,
   and <literal>ltree_plpython3u</literal>
   (see <xref linkend="plpython-python23"> for the PL/Python naming
   convention).  If you install these transforms and specify them when
   creating a function, <type>ltree</type> values are mapped to Python lists.
   (The reverse is currently not supported, however.)
  </para>
____________________________________________________________________________-->
  <para>
   有一些额外的扩展为 PL/Python 实现了<type>ltree</type>类型的转换。
   这些扩展是<literal>ltree_plpythonu</literal>、<literal>ltree_plpython2u</literal>
   以及<literal>ltree_plpython3u</literal>（PL/Python 命名习惯请见
   <xref linkend="plpython-python23"/>）。如果安装了这些转换并且在
   创建函数时指定了它们，<type>ltree</type>值会被映射为 Python 列表（
   不过，当前并不支持逆向的转换）。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Authors</title>
____________________________________________________________________________-->
  <title>作者</title>

<!--==========================orignal english content==========================
  <para>
   All work was done by Teodor Sigaev (<email>teodor@stack.net</email>) and
   Oleg Bartunov (<email>oleg@sai.msu.su</email>). See
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"></ulink> for
   additional information. Authors would like to thank Eugeny Rodichev for
   helpful discussions. Comments and bug reports are welcome.
  </para>
____________________________________________________________________________-->
  <para>
   所有工作都是 Teodor Sigaev（<email>teodor@stack.net</email>）和
   Oleg Bartunov（<email>oleg@sai.msu.su</email>）完成的。额外信息可见
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"></ulink>。作者还要感谢 Eugeny Rodichev 参与讨论。欢迎评论和缺陷报告。
  </para>
 </sect2>

</sect1>
