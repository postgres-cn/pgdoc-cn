<!-- doc/src/sgml/bki.sgml -->

<chapter id="bki">
<!--==========================orignal english content==========================
 <title>System Catalog Declarations and Initial Contents</title>
____________________________________________________________________________-->
 <title>系统目录声明和初始内容</title>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> uses many different system catalogs
  to keep track of the existence and properties of database objects, such as
  tables and functions.  Physically there is no difference between a system
  catalog and a plain user table, but the backend C code knows the structure
  and properties of each catalog, and can manipulate it directly at a low
  level.  Thus, for example, it is inadvisable to attempt to alter the
  structure of a catalog on-the-fly; that would break assumptions built into
  the C code about how rows of the catalog are laid out.  But the structure
  of the catalogs can change between major versions.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>使用很多不同的系统目录来跟踪数据库对象（例如表和函数）的存在以及属性。系统目录和普通用户表之间在物理上没有什么不同，但是后端的C代码知道每一个目录的结构和属性，并且能够在较低的层次上直接操纵它们。因此，不建议尝试在运行中修改目录的结构，那样做会破坏内建在C代码中对目录行如何放置的设想。但是目录的结构可能会在主版本之间发生变化。
 </para>

<!--==========================orignal english content==========================
 <para>
  The structures of the catalogs are declared in specially formatted C
  header files in the <filename>src/include/catalog/</filename> directory of
  the source tree.  In particular, for each catalog there is a header file
  named after the catalog (e.g., <filename>pg_class.h</filename>
  for <structname>pg_class</structname>), which defines the set of columns
  the catalog has, as well as some other basic properties such as its OID.
  Other critical files defining the catalog structure
  include <filename>indexing.h</filename>, which defines the indexes present
  on all the system catalogs, and <filename>toasting.h</filename>, which
  defines TOAST tables for catalogs that need one.
 </para>
____________________________________________________________________________-->
 <para>
  目录的结构声明在特殊格式的C头文件中，它们位于源码树的<filename>src/include/catalog/</filename>目录中。特别地，对每一个目录都有一个以其名称命名的头文件（例如，<structname>pg_class</structname>的头文件是<filename>pg_class.h</filename>），头文件定义了目录具有的列集合，以及一些其他的基本属性（例如OID）。其他定义目录结构的重要文件包括<filename>indexing.h</filename>和<filename>toasting.h</filename>，前者定义所有系统目录上的索引，而后者为需要TOAST表的目录定义TOAST表。
 </para>

<!--==========================orignal english content==========================
 <para>
  Many of the catalogs have initial data that must be loaded into them
  during the <quote>bootstrap</quote> phase
  of <application>initdb</application>, to bring the system up to a point
  where it is capable of executing SQL commands.  (For
  example, <filename>pg_class.h</filename> must contain an entry for itself,
  as well as one for each other system catalog and index.)  This
  initial data is kept in editable form in data files that are also stored
  in the <filename>src/include/catalog/</filename> directory.  For example,
  <filename>pg_proc.dat</filename> describes all the initial rows that must
  be inserted into the <structname>pg_proc</structname> catalog.
 </para>
____________________________________________________________________________-->
 <para>
  很多目录都有初始数据，这些数据必须在<application>initdb</application>的<quote>bootstrap</quote>阶段装载到对应的目录中，这样才能让系统达到能够执行SQL命令的状态点（例如，<filename>pg_class.h</filename>必须包含表示其自身的一个项，还要为每个系统目录和索引都分别包含一项）。这些初始数据以可编辑的形式保存在<filename>src/include/catalog/</filename>目录下的数据文件中。例如，<filename>pg_proc.dat</filename>描述了所有必须被插入到<structname>pg_proc</structname>目录的初始行。
 </para>

<!--==========================orignal english content==========================
 <para>
  To create the catalog files and load this initial data into them, a
  backend running in bootstrap mode reads a <acronym>BKI</acronym>
  (Backend Interface) file containing commands and initial data.
  The <filename>postgres.bki</filename> file used in this mode is prepared
  from the aforementioned header and data files, while building
  a <productname>PostgreSQL</productname> distribution, by a Perl script
  named <filename>genbki.pl</filename>.
  Although it's specific to a particular <productname>PostgreSQL</productname>
  release, <filename>postgres.bki</filename> is platform-independent and is
  installed in the <filename>share</filename> subdirectory of the
  installation tree.
 </para>
____________________________________________________________________________-->
 <para>
  为了创建目录文件并且将这些初始数据载入其中，一个以bootstrap模式运行的后端会读取包含着命令和初始数据的<acronym>BKI</acronym>（后端接口）文件。这种模式中用到的<filename>postgres.bki</filename>文件正是在编译<productname>PostgreSQL</productname>时从前述的头文件和数据文件准备而来，这一过程由名为<filename>genbki.pl</filename>的Perl脚本负责。尽管<filename>postgres.bki</filename>与特定<productname>PostgreSQL</productname>发行版相关，但它是平台无关的并且被安装在安装树的<filename>share</filename>子目录中。
 </para>

<!--==========================orignal english content==========================
 <para>
  <filename>genbki.pl</filename> also produces a derived header file for
  each catalog, for example <filename>pg_class_d.h</filename> for
  the <structname>pg_class</structname> catalog.  This file contains
  automatically-generated macro definitions, and may contain other macros,
  enum declarations, and so on that can be useful for client C code that
  reads a particular catalog.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>genbki.pl</filename>还会为每个目录产生一个头文件，例如为<structname>pg_class</structname>生成的头文件是<filename>pg_class_d.h</filename>。这个文件含有自动生成的宏定义，并且可能包含其他的宏、枚举声明，因此对于读取特定目录的客户端C代码很有用。
 </para>

<!--==========================orignal english content==========================
 <para>
  Most Postgres developers don't need to be directly concerned with
  the <acronym>BKI</acronym> file, but almost any nontrivial feature
  addition in the backend will require modifying the catalog header files
  and/or initial data files.  The rest of this chapter gives some
  information about that, and for completeness describes
  the <acronym>BKI</acronym> file format.
 </para>
____________________________________________________________________________-->
 <para>
  大部分Postgres的开发者不需要直接与<acronym>BKI</acronym>文件打交道，但是几乎在后端中增加任何非平凡的特性都需要修改目录头文件或者初始数据文件。本章的剩余部分会给出一些相关的信息，并且将会完整地描述<acronym>BKI</acronym>文件格式。
 </para>

 <sect1 id="system-catalog-declarations">
<!--==========================orignal english content==========================
  <title>System Catalog Declaration Rules</title>
____________________________________________________________________________-->
  <title>系统目录声明规则</title>

<!--==========================orignal english content==========================
  <para>
   The key part of a catalog header file is a C structure definition
   describing the layout of each row of the catalog.  This begins with
   a <literal>CATALOG</literal> macro, which so far as the C compiler is
   concerned is just shorthand for <literal>typedef struct
   FormData_<replaceable>catalogname</replaceable></literal>.
   Each field in the struct gives rise to a catalog column.
   Fields can be annotated using the BKI property macros described
   in <filename>genbki.h</filename>, for example to define a default value
   for a field or mark it as nullable or not nullable.
   The <literal>CATALOG</literal> line can also be annotated, with some
   other BKI property macros described in <filename>genbki.h</filename>, to
   define other properties of the catalog as a whole, such as whether
   it has OIDs (by default, it does).
  </para>
____________________________________________________________________________-->
  <para>
   一个目录头文件的关键部分是一个C的结构定义，它描述该目录中每一行的布局。这个结构开始于一个<literal>CATALOG</literal>宏，它对于C编译器而言只不过是<literal>typedef struct FormData_<replaceable>catalogname</replaceable></literal>的一个简写。该结构中的每一个域会导致出现一个目录列。域可以用<filename>genbki.h</filename>中描述的BKI属性宏进行标注，例如可以为域定义默认值或者把域标记为可以为空或者不能为空。<literal>CATALOG</literal>行也可以用<filename>genbki.h</filename>中描述的一些其他BKI属性宏标注，用于定义该目录整体的其他属性，例如是否有OID（默认是有的）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The system catalog cache code (and most catalog-munging code in general)
   assumes that the fixed-length portions of all system catalog tuples are
   in fact present, because it maps this C struct declaration onto them.
   Thus, all variable-length fields and nullable fields must be placed at
   the end, and they cannot be accessed as struct fields.
   For example, if you tried to
   set <structname>pg_type</structname>.<structfield>typrelid</structfield>
   to be NULL, it would fail when some piece of code tried to reference
   <literal>typetup-&gt;typrelid</literal> (or worse,
   <literal>typetup-&gt;typelem</literal>, because that follows
   <structfield>typrelid</structfield>).  This would result in
   random errors or even segmentation violations.
  </para>
____________________________________________________________________________-->
  <para>
   系统目录缓冲代码（以及大部分目录功能代码）假定所有的系统目录元组的定长部分是实际的存在形式，因为它会把这个C结构声明映射到定长部分之上。因此，所有变长域和可以为空的域必须被放置在最后，并且不能够以结构的域的方式访问。例如，如果尝试设置<structname>pg_type</structname>.<structfield>typrelid</structfield>为NULL，当某段代码尝试引用<literal>typetup-&gt;typrelid</literal>（或者更糟糕的是引用<literal>typetup-&gt;typelem</literal>，因为它跟随在<structfield>typrelid</structfield>之后）时将会出现失败。这会导致随机错误乃至段错误。
  </para>

<!--==========================orignal english content==========================
  <para>
   As a partial guard against this type of error, variable-length or
   nullable fields should not be made directly visible to the C compiler.
   This is accomplished by wrapping them in <literal>#ifdef
   CATALOG_VARLEN</literal> ... <literal>#endif</literal> (where
   <literal>CATALOG_VARLEN</literal> is a symbol that is never defined).
   This prevents C code from carelessly trying to access fields that might
   not be there or might be at some other offset.
   As an independent guard against creating incorrect rows, we
   require all columns that should be non-nullable to be marked so
   in <structname>pg_attribute</structname>.  The bootstrap code will
   automatically mark catalog columns as <literal>NOT NULL</literal>
   if they are fixed-width and are not preceded by any nullable column.
   Where this rule is inadequate, you can force correct marking by using
   <literal>BKI_FORCE_NOT_NULL</literal>
   and <literal>BKI_FORCE_NULL</literal> annotations as needed.  But note
   that <literal>NOT NULL</literal> constraints are only enforced in the
   executor, not against tuples that are generated by random C code,
   so care is still needed when manually creating or updating catalog rows.
  </para>
____________________________________________________________________________-->
  <para>
   作为对这类错误的一种部分保护，变长或可以为空的域不应该对C编译器可见。通过将它们包裹在<literal>#ifdef CATALOG_VARLEN</literal> ... <literal>#endif</literal>（其中<literal>CATALOG_VARLEN</literal>是一个永不被定义的符号）中可以实现这一点。这能防止C代码不小心尝试访问可能不在那里或者可能在其他某个偏移位置的域。作为一种防止创建不正确行的措施，我们要求所有应该为非空的列在<structname>pg_attribute</structname>中也被标记为非空。如果目录列是定长的并且前面没有任何可以为空的列，bootstrap代码将自动把它标记为<literal>NOT NULL</literal>。在这一规则不适用的地方，可以根据需要使用<literal>BKI_FORCE_NOT_NULL</literal>和<literal>BKI_FORCE_NULL</literal>标注强制正确的标记。但是要注意的是，<literal>NOT NULL</literal>约束仅在执行器中被强制，而不会针对随机C代码产生的元组进行强制，因此在手工创建或者更新目录行时仍需谨慎。
  </para>

<!--==========================orignal english content==========================
  <para>
   Frontend code should not include any <filename>pg_xxx.h</filename>
   catalog header file, as these files may contain C code that won't compile
   outside the backend.  (Typically, that happens because these files also
   contain declarations for functions
   in <filename>src/backend/catalog/</filename> files.)
   Instead, frontend code may include the corresponding
   generated <filename>pg_xxx_d.h</filename> header, which will contain
   OID <literal>#define</literal>s and any other data that might be of use
   on the client side.  If you want macros or other code in a catalog header
   to be visible to frontend code, write <literal>#ifdef
   EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal> around that
   section to instruct <filename>genbki.pl</filename> to copy that section
   to the <filename>pg_xxx_d.h</filename> header.
  </para>
____________________________________________________________________________-->
  <para>
   前端代码不应该包括任何<filename>pg_xxx.h</filename>目录头文件，因为这些文件可能包含在后端之外无法编译的C代码（通常，这是因为这些文件还包含<filename>src/backend/catalog/</filename>文件中函数的声明）。不过，前端代码可以包括相应的<filename>pg_xxx_d.h</filename>头文件，它将包含OID <literal>#define</literal>以及任何其他可能要在客户端使用的数据。如果希望前端代码能看到目录头文件中的宏或者其他代码，可以在相应部分的周围写上<literal>#ifdef EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal>，这样会指示<filename>genbki.pl</filename>把相应的部分拷贝到<filename>pg_xxx_d.h</filename>头文件中。
  </para>

<!--==========================orignal english content==========================
  <para>
   A few of the catalogs are so fundamental that they can't even be created
   by the <acronym>BKI</acronym> <literal>create</literal> command that's
   used for most catalogs, because that command needs to write information
   into these catalogs to describe the new catalog.  These are
   called <firstterm>bootstrap</firstterm> catalogs, and defining one takes
   a lot of extra work: you have to manually prepare appropriate entries for
   them in the pre-loaded contents of <structname>pg_class</structname>
   and <structname>pg_type</structname>, and those entries will need to be
   updated for subsequent changes to the catalog's structure.
   (Bootstrap catalogs also need pre-loaded entries
   in <structname>pg_attribute</structname>, but
   fortunately <filename>genbki.pl</filename> handles that chore nowadays.)
   Avoid making new catalogs be bootstrap catalogs if at all possible.
  </para>
____________________________________________________________________________-->
  <para>
   少数目录是非常基础的，以至于它们无法用大部分目录采用的<acronym>BKI</acronym> <literal>create</literal>命令来创建，因为那个命令需要在这些目录中写入信息来描述新的目录。这些目录被称为<firstterm>bootstrap</firstterm>目录，定义一个这样的目录需要一些额外的工作：开发者必须为它在<structname>pg_class</structname>和<structname>pg_type</structname>的预装载内容中手工准备合适的项，并且后续对该目录结构的更改将会更新那些项（bootstrap目录还需要<structname>pg_attribute</structname>中的预装载项，但是幸运地是现如今的<filename>genbki.pl</filename>会处理这些杂务）。如果可能，一定避免将新目录创建为bootstrap目录。
  </para>
 </sect1>

 <sect1 id="system-catalog-initial-data">
<!--==========================orignal english content==========================
  <title>System Catalog Initial Data</title>
____________________________________________________________________________-->
  <title>系统目录初始数据</title>

<!--==========================orignal english content==========================
  <para>
   Each catalog that has any manually-created initial data (some do not)
   has a corresponding <literal>.dat</literal> file that contains its
   initial data in an editable format.
  </para>
____________________________________________________________________________-->
  <para>
   每个有手工创建的初始数据（有些没有）的目录都有一个相应的<literal>.dat</literal>文件，其中以可编辑的格式包含着该目录的初始数据。
  </para>

  <sect2 id="system-catalog-initial-data-format">
<!--==========================orignal english content==========================
   <title>Data File Format</title>
____________________________________________________________________________-->
   <title>数据文件格式</title>

<!--==========================orignal english content==========================
   <para>
    Each <literal>.dat</literal> file contains Perl data structure literals
    that are simply eval'd to produce an in-memory data structure consisting
    of an array of hash references, one per catalog row.
    A slightly modified excerpt from <filename>pg_database.dat</filename>
    will demonstrate the key features:
   </para>
____________________________________________________________________________-->
   <para>
    每个<literal>.dat</literal>文件含有Perl数据结构文本，它可以简单地通过eval产生由一个哈希引用数组构成的内存数据结构，每个目录行一个。从<filename>pg_database.dat</filename>摘出的经过略微修改的一小部分可以展示关键特性：
   </para>

<!--==========================orignal english content==========================
<programlisting>
[

# A comment could appear here.
{ oid =&gt; '1', oid_symbol =&gt; 'TemplateDbOid',
  descr =&gt; 'database\'s default template',
  datname =&gt; 'template1', datdba =&gt; 'PGUID', encoding =&gt; 'ENCODING',
  datcollate =&gt; 'LC_COLLATE', datctype =&gt; 'LC_CTYPE', datistemplate =&gt; 't',
  datallowconn =&gt; 't', datconnlimit =&gt; '-1', datlastsysoid =&gt; '0',
  datfrozenxid =&gt; '0', datminmxid =&gt; '1', dattablespace =&gt; '1663',
  datacl =&gt; '_null_' },

]
</programlisting>
____________________________________________________________________________-->
<programlisting>
[

# A comment could appear here.
{ oid =&gt; '1', oid_symbol =&gt; 'TemplateDbOid',
  descr =&gt; 'database\'s default template',
  datname =&gt; 'template1', datdba =&gt; 'PGUID', encoding =&gt; 'ENCODING',
  datcollate =&gt; 'LC_COLLATE', datctype =&gt; 'LC_CTYPE', datistemplate =&gt; 't',
  datallowconn =&gt; 't', datconnlimit =&gt; '-1', datlastsysoid =&gt; '0',
  datfrozenxid =&gt; '0', datminmxid =&gt; '1', dattablespace =&gt; '1663',
  datacl =&gt; '_null_' },

]
</programlisting>

<!--==========================orignal english content==========================
   <para>
    Points to note:
   </para>
____________________________________________________________________________-->
   <para>
    需要注意的点：
   </para>

   <itemizedlist>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The overall file layout is: open square bracket, one or more sets of
      curly braces each of which represents a catalog row, close square
      bracket.  Write a comma after each closing curly brace.
     </para>
____________________________________________________________________________-->
     <para>
      总体的文件布局是：开方括号，一个或者多个花括号集合（每一个表示一个目录行），闭方括号。在每一个闭花括号之后写一个逗号。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Within each catalog row, write comma-separated
      <replaceable>key</replaceable> <literal>=&gt;</literal>
      <replaceable>value</replaceable> pairs.  The
      allowed <replaceable>key</replaceable>s are the names of the catalog's
      columns, plus the metadata keys <literal>oid</literal>,
      <literal>oid_symbol</literal>, and <literal>descr</literal>.
      (The use of <literal>oid</literal> and <literal>oid_symbol</literal>
      is described in <xref linkend="system-catalog-oid-assignment"/>
      below.  <literal>descr</literal> supplies a description string for
      the object, which will be inserted
      into <structname>pg_description</structname>
      or <structname>pg_shdescription</structname> as appropriate.)
      While the metadata keys are optional, the catalog's defined columns
      must all be provided, except when the catalog's <literal>.h</literal>
      file specifies a default value for the column.
     </para>
____________________________________________________________________________-->
     <para>
      在每个目录行内，写成逗号分隔的<replaceable>key</replaceable> <literal>=&gt;</literal> <replaceable>value</replaceable>对。允许的<replaceable>key</replaceable>是该目录的列名，外加上元数据键<literal>oid</literal>、<literal>oid_symbol</literal>以及<literal>descr</literal>（<literal>oid</literal>和<literal>oid_symbol</literal>的使用在下文的<xref linkend="system-catalog-oid-assignment"/>中描述。<literal>descr</literal>为该对象提供一个描述字符串，它将被插入到<structname>pg_description</structname>或<structname>pg_shdescription</structname>中）。虽然元数据键是可选的，但是目录中定义的列必须全部被提供，除非目录的<literal>.h</literal>文件为该列指定了默认值。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      All values must be single-quoted.  Escape single quotes used within a
      value with a backslash.  Backslashes meant as data can, but need not,
      be doubled; this follows Perl's rules for simple quoted literals.
      Note that backslashes appearing as data will be treated as escapes by
      the bootstrap scanner, according to the same rules as for escape string
      constants (see <xref linkend="sql-syntax-strings-escape"/>); for
      example <literal>\t</literal> converts to a tab character.  If you
      actually want a backslash in the final value, you will need to write
      four of them: Perl strips two, leaving <literal>\\</literal> for the
      bootstrap scanner to see.
     </para>
____________________________________________________________________________-->
     <para>
      所有的值都必须被放在单引号中。用反斜线可以转义值中用到的单引号。作为数据的反斜线可以（但是不必）被双写，这遵循的是Perl对简单引用文本的规则。注意，作为数据出现的反斜线将被bootstrap扫描器根据转义字符串常量的相同规则（见<xref linkend="sql-syntax-strings-escape"/>）当作转义处理。例如<literal>\t</literal>转换为一个制表符。如果在最终值中确实想要一个反斜线，则需要写成四个：Perl会剥离掉两个，留下<literal>\\</literal>给bootstrap扫描器。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Null values are represented by <literal>_null_</literal>.
      (Note that there is no way to create a value that is just that
      string.)
     </para>
____________________________________________________________________________-->
     <para>
      空值被表示为<literal>_null_</literal>（注意没有办法创建就是该字符串的值）。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Comments are preceded by <literal>#</literal>, and must be on their
      own lines.
     </para>
____________________________________________________________________________-->
     <para>
      注释以<literal>#</literal>开头，并且必须位于它们自己的行上。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      To aid readability, field values that are OIDs of other catalog
      entries can be represented by names rather than numeric OIDs.
      This is described in <xref linkend="system-catalog-oid-references"/>
      below.
     </para>
____________________________________________________________________________-->
     <para>
      为了帮助可读性，是其他目录项OID的域值可以用名称而不是数字的OID表示。这会在下文的<xref linkend="system-catalog-oid-references"/>中描述。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Since hashes are unordered data structures, field order and line
      layout aren't semantically significant.  However, to maintain a
      consistent appearance, we set a few rules that are applied by the
      formatting script <filename>reformat_dat_file.pl</filename>:

      <itemizedlist>

       <listitem>
        <para>
         Within each pair of curly braces, the metadata
         fields <literal>oid</literal>, <literal>oid_symbol</literal>,
         and <literal>descr</literal> (if present) come first, in that
         order, then the catalog's own fields appear in their defined order.
        </para>
       </listitem>

       <listitem>
        <para>
         Newlines are inserted between fields as needed to limit line length
         to 80 characters, if possible.  A newline is also inserted between
         the metadata fields and the regular fields.
        </para>
       </listitem>

       <listitem>
        <para>
         If the catalog's <literal>.h</literal> file specifies a default
         value for a column, and a data entry has that same
         value, <filename>reformat_dat_file.pl</filename> will omit it from
         the data file.  This keeps the data representation compact.
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename> preserves blank lines
         and comment lines as-is.
        </para>
       </listitem>

      </itemizedlist>

      It's recommended to run <filename>reformat_dat_file.pl</filename>
      before submitting catalog data patches.  For convenience, you can
      simply change to <filename>src/include/catalog/</filename> and
      run <literal>make reformat-dat-files</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      因为哈希是无序的数据结构，域顺序和行布局并不重要。不过，为了维持一种一致的外貌，我们设定了一些规则，它们由格式化脚本<filename>reformat_dat_file.pl</filename>实施：

      <itemizedlist>

       <listitem>
        <para>
         在每一对花括号内，元数据域<literal>oid</literal>、<literal>oid_symbol</literal>和<literal>descr</literal>（如果存在）按照这个顺序放在最前面，然后以定义时的顺序放上该目录自己的域。
        </para>
       </listitem>

       <listitem>
        <para>
         如果可能，根据需要在域之间插入新行以限制行的长度低于80字符。在元数据域和普通域之间也插入一个新行。
        </para>
       </listitem>

       <listitem>
        <para>
         如果目录的<literal>.h</literal>文件为一个列指定了默认值并且一个数据项具有相同的值，<filename>reformat_dat_file.pl</filename>将从数据文件中省去它。这能使得数据表达紧凑。
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename>原样保留空行和注释行。
        </para>
       </listitem>

      </itemizedlist>

      推荐在提交目录数据补丁前运行<filename>reformat_dat_file.pl</filename>。为了方便起见，可以简单地更改<filename>src/include/catalog/</filename>并且运行<literal>make reformat-dat-files</literal>。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      If you want to add a new method of making the data representation
      smaller, you must implement it
      in <filename>reformat_dat_file.pl</filename> and also
      teach <function>Catalog::ParseData()</function> how to expand the
      data back into the full representation.
     </para>
____________________________________________________________________________-->
     <para>
      如果想要增加一种新方法让数据表达更小，必须在<filename>reformat_dat_file.pl</filename>中实现该方法并且还要教会<function>Catalog::ParseData()</function>如何将数据展开回完整的表达。
     </para>
    </listitem>

   </itemizedlist>
  </sect2>

  <sect2 id="system-catalog-oid-assignment">
<!--==========================orignal english content==========================
   <title>OID Assignment</title>
____________________________________________________________________________-->
   <title>OID分配</title>

<!--==========================orignal english content==========================
   <para>
    A catalog row appearing in the initial data can be given a
    manually-assigned OID by writing an <literal>oid
    =&gt; <replaceable>nnnn</replaceable></literal> metadata field.
    Furthermore, if an OID is assigned, a C macro for that OID can be
    created by writing an <literal>oid_symbol
    =&gt; <replaceable>name</replaceable></literal> metadata field.
   </para>
____________________________________________________________________________-->
   <para>
    通过写一个<literal>oid =&gt; <replaceable>nnnn</replaceable></literal>元数据域，出现在初始数据中的目录行可以被给予一个手工分配的OID。此外，如果分配一个OID，可以通过书写一个<literal>oid_symbol =&gt; <replaceable>name</replaceable></literal>元数据域为该OID创建一个C宏。
   </para>

<!--==========================orignal english content==========================
   <para>
    Pre-loaded catalog rows must have preassigned OIDs if there are OID
    references to them in other pre-loaded rows.  A preassigned OID is
    also needed if the row's OID must be referenced from C code.
    If neither case applies, the <literal>oid</literal> metadata field can
    be omitted, in which case the bootstrap code assigns an OID
    automatically, or leaves it zero in a catalog that has no OIDs.
    In practice we usually preassign OIDs for all or none of the pre-loaded
    rows in a given catalog, even if only some of them are actually
    cross-referenced.
   </para>
____________________________________________________________________________-->
   <para>
    如果预装载的目录行被其他预装载行用OID引用，则必须给它们预先分配OID。如果行的OID必须被C代码引用，也需要预分配的OID。如果两种情况都不符合，则<literal>oid</literal>元数据域可以被省略，在这种情况下bootstrap代码会自动分配OID，如果是一个没有OID的目录则将OID留为零。实际上对于一个给定的目录，即便其中某些行实际并没有被交叉引用，我们也通常会为其中预装载的行全部预分配OID或者全部不分配OID。
   </para>

<!--==========================orignal english content==========================
   <para>
    Writing the actual numeric value of any OID in C code is considered
    very bad form; always use a macro, instead.  Direct references
    to <structname>pg_proc</structname> OIDs are common enough that there's
    a special mechanism to create the necessary macros automatically;
    see <filename>src/backend/utils/Gen_fmgrtab.pl</filename>.  Similarly
    &mdash; but, for historical reasons, not done the same way &mdash;
    there's an automatic method for creating macros
    for <structname>pg_type</structname>
    OIDs.  <literal>oid_symbol</literal> entries are therefore not
    necessary in those two catalogs.  Likewise, macros for
    the <structname>pg_class</structname> OIDs of system catalogs and
    indexes are set up automatically.  For all other system catalogs, you
    have to manually specify any macros you need
    via <literal>oid_symbol</literal> entries.
   </para>
____________________________________________________________________________-->
   <para>
    在C代码中写出任何OID的实际数字值是一种非常糟糕的形式，通常应该使用宏。对<structname>pg_proc</structname> OID的直接引用太常见了，因此有一种特别的机制自动创建必需的宏，见<filename>src/backend/utils/Gen_fmgrtab.pl</filename>。类似地 &mdash; 但是由于历史原因，实现的方式不同 &mdash; 也有一种自动的为<structname>pg_type</structname> OID创建宏的方法。因此在这两个目录中，<literal>oid_symbol</literal>项不是必需的。同样，系统目录和索引的<structname>pg_class</structname> OID的宏是自动设置的。对于所有其他系统目录，开发者必需通过<literal>oid_symbol</literal>项手动指定所需的宏。
   </para>

<!--==========================orignal english content==========================
   <para>
    To find an available OID for a new pre-loaded row, run the
    script <filename>src/include/catalog/unused_oids</filename>.
    It prints inclusive ranges of unused OIDs (e.g., the output
    line <quote>45-900</quote> means OIDs 45 through 900 have not been
    allocated yet).  Currently, OIDs 1-9999 are reserved for manual
    assignment; the <filename>unused_oids</filename> script simply looks
    through the catalog headers and <filename>.dat</filename> files
    to see which ones do not appear.  You can also use
    the <filename>duplicate_oids</filename> script to check for mistakes.
    (<filename>genbki.pl</filename> will also detect duplicate OIDs
    at compile time.)
   </para>
____________________________________________________________________________-->
   <para>
    要为一个新的预装载行找到一个可用的OID，可以运行脚本<filename>src/include/catalog/unused_oids</filename>。它能打印出未被使用的OID的闭区间范围（例如，输出行<quote>45-900</quote>表示OID 45到900都还没有被分配出去）。当前，OID 1-9999被保留给手工分配，<filename>unused_oids</filename>脚本会简单地查看目录头部以及<filename>.dat</filename>文件来看看哪些OID没有出现。也可以使用<filename>duplicate_oids</filename>脚本来检查错误（<filename>genbki.pl</filename>还会在编译时检测重复的OID）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The OID counter starts at 10000 at the beginning of a bootstrap run.
    If a catalog row is in a table that requires OIDs, but no OID was
    preassigned by an <literal>oid</literal> field, then it will
    receive an OID of 10000 or above.
   </para>
____________________________________________________________________________-->
   <para>
    在bootstrap运行开始时，OID计数器从10000开始。如果表中的一个目录行要求OID但没有通过<literal>oid</literal>域预分配OID，那么它将得到一个大于等于10000的OID。
   </para>
  </sect2>

  <sect2 id="system-catalog-oid-references">
<!--==========================orignal english content==========================
   <title>OID Reference Lookup</title>
____________________________________________________________________________-->
   <title>OID引用查找</title>

<!--==========================orignal english content==========================
   <para>
    Cross-references from one initial catalog row to another can be written
    by just writing the preassigned OID of the referenced row.  But
    that's error-prone and hard to understand, so for frequently-referenced
    catalogs, <filename>genbki.pl</filename> provides mechanisms to write
    symbolic references instead.  Currently this is possible for references
    to access methods, functions, operators, opclasses, opfamilies, and
    types.  The rules are as follows:
   </para>
____________________________________________________________________________-->
   <para>
    从一个初始目录行到另一个初始目录行的交叉引用只需要在引用行中写上被引用行的预分配OID就可以实现。但这种方式容易出错并且难于理解，因此对于频繁引用的目录，<filename>genbki.pl</filename>提供了机制支持符号化的引用。当前这些机制可以用来引用访问方法、函数、操作符、操作符类、操作符族以及类型。规则如下：
   </para>

   <itemizedlist>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Use of symbolic references is enabled in a particular catalog column
      by attaching <literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>
      to the column's definition, where <replaceable>lookuprule</replaceable>
      is <literal>pg_am</literal>, <literal>pg_proc</literal>,
      <literal>pg_operator</literal>, <literal>pg_opclass</literal>,
      <literal>pg_opfamily</literal>, or <literal>pg_type</literal>.
      <literal>BKI_LOOKUP</literal> can be attached to columns of
      type <type>Oid</type>, <type>regproc</type>, <type>oidvector</type>,
      or <type>Oid[]</type>; in the latter two cases it implies performing a
      lookup on each element of the array.
     </para>
____________________________________________________________________________-->
     <para>
      通过对特定的目录列定义附加<literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>来开启对符号化引用的使用，其中<replaceable>lookuprule</replaceable>是<literal>pg_am</literal>、<literal>pg_proc</literal>、<literal>pg_operator</literal>、<literal>pg_opclass</literal>、<literal>pg_opfamily</literal>或者<literal>pg_type</literal>。<literal>BKI_LOOKUP</literal>可以被附加到类型为<type>oid</type>、<type>regproc</type>、<type>oidvector</type>或者<type>Oid[]</type>的列上，在后两种情况中它意味着在数组的每个元素上执行查找。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      In such a column, all entries must use the symbolic format except
      when writing <literal>0</literal> for InvalidOid.  (If the column is
      declared <type>regproc</type>, you can optionally
      write <literal>-</literal> instead of <literal>0</literal>.)
      <filename>genbki.pl</filename> will warn about unrecognized names.
     </para>
____________________________________________________________________________-->
     <para>
      在这样的一个列中，所有的项必须使用符号化格式，不过写成<literal>0</literal>（表示InvalidOid）除外（如果列被声明为<type>regproc</type>，可以选择用<literal>-</literal>代替<literal>0</literal>）。对于无法识别的名称，<filename>genbki.pl</filename>将会告警。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Access methods are just represented by their names, as are types.
      Type names must match the referenced <structname>pg_type</structname>
      entry's <structfield>typname</structfield>; you do not get to use any
      aliases such as <literal>integer</literal>
      for <literal>int4</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      访问方法就用它们的名称表示，这和类型一样。类型的名称必须匹配被引用的<structname>pg_type</structname>项的<structfield>typname</structfield>，不能使用任何别名，例如用<literal>integer</literal>来替代<literal>int4</literal>。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      A function can be represented by
      its <structfield>proname</structfield>, if that is unique among
      the <filename>pg_proc.dat</filename> entries (this works like regproc
      input).  Otherwise, write it
      as <replaceable>proname(argtypename,argtypename,...)</replaceable>,
      like regprocedure.  The argument type names must be spelled exactly as
      they are in the <filename>pg_proc.dat</filename> entry's
      <structfield>proargtypes</structfield> field.  Do not insert any
      spaces.
     </para>
____________________________________________________________________________-->
     <para>
      函数可以用其<structfield>proname</structfield>来表示，前提是它在<filename>pg_proc.dat</filename>项中是唯一的（这和regproc输入类似）。否则，要将函数写成<replaceable>proname(argtypename,argtypename,...)</replaceable>，就像regprocedure那样。参数的类型名称必须被拼写准确，和它们在<filename>pg_proc.dat</filename>项的<structfield>proargtypes</structfield>域中的值一致。不要插入任何空白。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Operators are represented
      by <replaceable>oprname(lefttype,righttype)</replaceable>,
      writing the type names exactly as they appear in
      the <filename>pg_operator.dat</filename>
      entry's <structfield>oprleft</structfield>
      and <structfield>oprright</structfield> fields.
      (Write <literal>0</literal> for the omitted operand of a unary
      operator.)
     </para>
____________________________________________________________________________-->
     <para>
      操作符的名称由<replaceable>oprname(lefttype,righttype)</replaceable>表示，类型的名称要写得准确，与它们出现在<filename>pg_operator.dat</filename>项的<structfield>oprleft</structfield>和<structfield>oprright</structfield>域中的值一样（对于一元操作符省略的操作数，可以写成<literal>0</literal>）。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The names of opclasses and opfamilies are only unique within an
      access method, so they are represented
      by <replaceable>access_method_name</replaceable><literal>/</literal><replaceable>object_name</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      操作符类和操作符族的名称仅在一个访问方法中唯一，因此它们用<replaceable>access_method_name</replaceable><literal>/</literal><replaceable>object_name</replaceable>表示。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      In none of these cases is there any provision for
      schema-qualification; all objects created during bootstrap are
      expected to be in the pg_catalog schema.
     </para>
____________________________________________________________________________-->
     <para>
      在这些情况中都不能有方案限定，所有在bootstrap期间创建的对象都应该出现在pg_catalog方案中。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
   <para>
    <filename>genbki.pl</filename> resolves all symbolic references while it
    runs, and puts simple numeric OIDs into the emitted BKI file.  There is
    therefore no need for the bootstrap backend to deal with symbolic
    references.
   </para>
____________________________________________________________________________-->
   <para>
    <filename>genbki.pl</filename>在运行时会解决所有符号化引用并且把简单的数字OID放到输出的BKI文件中。因此不需要bootstrap后端处理符号化引用。
   </para>
  </sect2>

  <sect2 id="system-catalog-recipes">
<!--==========================orignal english content==========================
   <title>Recipes for Editing Data Files</title>
____________________________________________________________________________-->
   <title>编辑数据文件的方法</title>

<!--==========================orignal english content==========================
   <para>
    Here are some suggestions about the easiest ways to perform common tasks
    when updating catalog data files.
   </para>
____________________________________________________________________________-->
   <para>
    在更新目录数据文件时，对于执行常用任务的简便方法，这里有一些建议。
   </para>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Add a new column with a default to a catalog:</title>
____________________________________________________________________________-->
    <title>向一个目录增加一个带有默认值的新列：</title>
<!--==========================orignal english content==========================
    <para>
     Add the column to the header file with
     a <literal>BKI_DEFAULT(<replaceable>value</replaceable>)</literal>
     annotation.  The data file need only be adjusted by adding the field
     in existing rows where a non-default value is needed.
    </para>
____________________________________________________________________________-->
    <para>
     用<literal>BKI_DEFAULT(<replaceable>value</replaceable>)</literal>标注将列增加到头文件中。数据文件的调整仅需要在要求非默认值的现有行中增加该域即可。
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Add a default value to an existing column that doesn't have
     one:</title>
____________________________________________________________________________-->
    <title>为没有默认值的现有列增加默认值：</title>
<!--==========================orignal english content==========================
    <para>
     Add a <literal>BKI_DEFAULT</literal> annotation to the header file,
     then run <literal>make reformat-dat-files</literal> to remove
     now-redundant field entries.
    </para>
____________________________________________________________________________-->
    <para>
     在头文件中增加一个<literal>BKI_DEFAULT</literal>标注，然后运行<literal>make reformat-dat-files</literal>以移除现在变得冗余的域项。
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Remove a column, whether it has a default or not:</title>
____________________________________________________________________________-->
    <title>移除一列（不管有默认值还是没有）：</title>
<!--==========================orignal english content==========================
    <para>
     Remove the column from the header, then run <literal>make
     reformat-dat-files</literal> to remove now-useless field entries.
    </para>
____________________________________________________________________________-->
    <para>
     从头文件中移除该列，然后运行<literal>make reformat-dat-files</literal>以移除现在无用的域项。
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Change or remove an existing default value:</title>
____________________________________________________________________________-->
    <title>更改或者移除现有的默认值：</title>
<!--==========================orignal english content==========================
    <para>
     You cannot simply change the header file, since that will cause the
     current data to be interpreted incorrectly.  First run <literal>make
     expand-dat-files</literal> to rewrite the data files with all
     default values inserted explicitly, then change or remove
     the <literal>BKI_DEFAULT</literal> annotation, then run <literal>make
     reformat-dat-files</literal> to remove superfluous fields again.
    </para>
____________________________________________________________________________-->
    <para>
     不能简单地更改头文件，因为这将会导致当前的数据被不正确地解读。首先运行<literal>make
     expand-dat-files</literal>用显式插入所有默认值的形式重写数据文件，然后更改或者移除<literal>BKI_DEFAULT</literal>标注，然后运行<literal>make reformat-dat-files</literal>移除多余的域。
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Ad-hoc bulk editing:</title>
____________________________________________________________________________-->
    <title>临时批量编辑：</title>
<!--==========================orignal english content==========================
    <para>
     <filename>reformat_dat_file.pl</filename> can be adapted to perform
     many kinds of bulk changes.  Look for its block comments showing where
     one-off code can be inserted.  In the following example, we are going
     to consolidate two boolean fields in <structname>pg_proc</structname>
     into a char field:

     <orderedlist>
      <listitem>
       <para>
        Add the new column, with a default,
        to <filename>pg_proc.h</filename>:
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Create a new script based on <filename>reformat_dat_file.pl</filename>
        to insert appropriate values on-the-fly:
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Run the new script:
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        At this point <filename>pg_proc.dat</filename> has all three
        columns, <structfield>prokind</structfield>,
        <structfield>proisagg</structfield>,
        and <structfield>proiswindow</structfield>, though they will appear
        only in rows where they have non-default values.
       </para>
      </listitem>

      <listitem>
       <para>
        Remove the old columns from <filename>pg_proc.h</filename>:
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Finally, run <literal>make reformat-dat-files</literal> to remove
        the useless old entries from <filename>pg_proc.dat</filename>.
       </para>
      </listitem>
     </orderedlist>

     For further examples of scripts used for bulk editing, see
     <filename>convert_oid2name.pl</filename>
     and <filename>remove_pg_type_oid_symbols.pl</filename> attached to this
     message:
     <ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>
    </para>
____________________________________________________________________________-->
    <para>
     可以修改<filename>reformat_dat_file.pl</filename>执行很多种批量更改。寻找其中展示可以插入一次性代码的注释块。在下面的例子中，我们将把<structname>pg_proc</structname>中的两个boolean域联合成一个char域：

     <orderedlist>
      <listitem>
       <para>
        在<filename>pg_proc.h</filename>中增加一个带有默认值的新列：
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        基于<filename>reformat_dat_file.pl</filename>创建一个新脚本以插入合适的值：
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        运行新的脚本：
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        到这里<filename>pg_proc.dat</filename>拥有所有三个列<structfield>prokind</structfield>、<structfield>proisagg</structfield>以及<structfield>proiswindow</structfield>，不过它们将只出现在它们有非默认值的行中。
       </para>
      </listitem>

      <listitem>
       <para>
        从<filename>pg_proc.h</filename>移除旧的列：
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        最后，运行<literal>make reformat-dat-files</literal>从<filename>pg_proc.dat</filename>中移除无用的旧项。
       </para>
      </listitem>
     </orderedlist>

     用于批量编辑的脚本的更多例子，请参考这个消息<ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>的附件<filename>convert_oid2name.pl</filename>和<filename>remove_pg_type_oid_symbols.pl</filename>。
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="bki-format">
<!--==========================orignal english content==========================
  <title><acronym>BKI</acronym> File Format</title>
____________________________________________________________________________-->
  <title><acronym>BKI</acronym>文件格式</title>

<!--==========================orignal english content==========================
  <para>
   This section describes how the <productname>PostgreSQL</productname>
   backend interprets <acronym>BKI</acronym> files.  This description
   will be easier to understand if the <filename>postgres.bki</filename>
   file is at hand as an example.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述<productname>PostgreSQL</productname>后端如何解释<acronym>BKI</acronym>文件。结合一份实际的<filename>postgres.bki</filename>文件，本节的内容将会更容易理解。
  </para>

<!--==========================orignal english content==========================
  <para>
   <acronym>BKI</acronym> input consists of a sequence of commands.  Commands are made up
   of a number of tokens, depending on the syntax of the command.
   Tokens are usually separated by whitespace, but need not be if
   there is no ambiguity.  There is no special command separator; the
   next token that syntactically cannot belong to the preceding
   command starts a new one.  (Usually you would put a new command on
   a new line, for clarity.)  Tokens can be certain key words, special
   characters (parentheses, commas, etc.), numbers, or double-quoted
   strings.  Everything is case sensitive.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>BKI</acronym>输入由一个命令序列组成。根据命令的语法，命令由一系列记号构成。记号之间通常由空白分隔，但是在没有歧义时也可不用。没有什么特殊的命令分隔符；语法上无法属于前一命令的记号将开始新的一条命令（通常你会把一个新命令放在一个新行上以保持清晰）。 记号可以是某些关键字、特殊字符（圆括弧，逗号等）、数字或者双引号字串。 所有东西都是大小写敏感的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Lines starting with <literal>#</literal> are ignored.
  </para>
____________________________________________________________________________-->
  <para>
   以<literal>#</literal>开头的行会被忽略。
  </para>

 </sect1>

 <sect1 id="bki-commands">
<!--==========================orignal english content==========================
  <title><acronym>BKI</acronym> Commands</title>
____________________________________________________________________________-->
  <title><acronym>BKI</acronym>命令</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>without_oids</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional>,
     ...</optional>)
    </term>
____________________________________________________________________________-->
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>without_oids</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional>,
     ...</optional>)
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Create a table named <replaceable
      class="parameter">tablename</replaceable>, and having the OID
      <replaceable class="parameter">tableoid</replaceable>,
      with the columns given in parentheses.
     </para>
____________________________________________________________________________-->
     <para>
      创建一个叫做<replaceable class="parameter">tablename</replaceable>，OID为<replaceable class="parameter">tableoid</replaceable>的表，它的列在圆括弧中给出。
     </para>

<!--==========================orignal english content==========================
     <para>
      The following column types are supported directly by
      <filename>bootstrap.c</filename>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_oid</type> (array), <type>_char</type> (array),
      <type>_aclitem</type> (array).  Although it is possible to create
      tables containing columns of other types, this cannot be done until
      after <structname>pg_type</structname> has been created and filled with
      appropriate entries.  (That effectively means that only these
      column types can be used in bootstrap catalogs, but non-bootstrap
      catalogs can contain any built-in type.)
     </para>
____________________________________________________________________________-->
     <para>
      <filename>bootstrap.c</filename>直接支持下列列类型：<type>bool</type>、<type>bytea</type>、<type>char</type>（1 字节）、<type>name</type>、<type>int2</type>、<type>int4</type>、<type>regproc</type>、<type>regclass</type>、<type>regtype</type>、<type>text</type>、<type>oid</type>、<type>tid</type>、<type>xid</type>、<type>cid</type>、<type>int2vector</type>、<type>oidvector</type>、<type>_int4</type>（数组）、<type>_text</type>（数组）、<type>_oid</type>（数组）、<type>_char</type>（数组）、<type>_aclitem</type>（数组）。尽管我们可以创建包含其它类型列的表， 但是我们只有在创建完<structname>pg_type</structname>并且填充了合适的记录之后才行（这实际上就意味着在自举目录中，只能使用这些列类型，而非自举目录可以使用任意内置类型）。
     </para>

<!--==========================orignal english content==========================
     <para>
      When <literal>bootstrap</literal> is specified,
      the table will only be created on disk; nothing is entered into
      <structname>pg_class</structname>,
      <structname>pg_attribute</structname>, etc, for it.  Thus the
      table will not be accessible by ordinary SQL operations until
      such entries are made the hard way (with <literal>insert</literal>
      commands).  This option is used for creating
      <structname>pg_class</structname> etc themselves.
     </para>
____________________________________________________________________________-->
     <para>
      如果声明了<literal>bootstrap</literal>，那么该表将只在磁盘上创建；不会向<structname>pg_class</structname>、<structname>pg_attribute</structname>等表里面输入任何与该表相关的东西。因此这样的表将无法被普通的SQL操作访问，直到那些记录被用硬办法（用<literal>insert</literal>命令）建立。 这个选项用于创建<structname>pg_class</structname>等表本身。
     </para>

<!--==========================orignal english content==========================
     <para>
      The table is created as shared if <literal>shared_relation</literal> is
      specified.
      It will have OIDs unless <literal>without_oids</literal> is specified.
      The table's row type OID (<structname>pg_type</structname> OID) can optionally
      be specified via the <literal>rowtype_oid</literal> clause; if not specified,
      an OID is automatically generated for it.  (The <literal>rowtype_oid</literal>
      clause is useless if <literal>bootstrap</literal> is specified, but it can be
      provided anyway for documentation.)
     </para>
____________________________________________________________________________-->
     <para>
      如果声明了<literal>shared_relation</literal>，那么表就作为共享表创建。除非声明了<literal>without_oids</literal>，否则表将会有OID。表的行类型OID（<structname>pg_type</structname>的OID）可以有选择性地通过<literal>rowtype_oid</literal>子句指定。如果没有指定，会为之自产生一个OID（如果<literal>bootstrap</literal>被指定，则<literal>rowtype_oid</literal>是无效的，但不管怎样它还是被写在了文档中）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>open</literal> <replaceable class="parameter">tablename</replaceable>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>open</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Open the table named
      <replaceable class="parameter">tablename</replaceable>
      for insertion of data.  Any currently open table is closed.
     </para>
____________________________________________________________________________-->
     <para>
      打开名为<replaceable class="parameter">tablename</replaceable>的表进行数据插入。任何当前打开的表将被关闭。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>close</literal> <replaceable class="parameter">tablename</replaceable>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>close</literal> <optional><replaceable class="parameter">tablename</replaceable></optional>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Close the open table.  The name of the table must be given as a
      cross-check.
     </para>
____________________________________________________________________________-->
     <para>
      关闭打开着的表。给出的表名用于交叉检查，但并不是必须的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>insert</literal> <optional><literal>OID =</literal> <replaceable class="parameter">oid_value</replaceable></optional> <literal>(</literal> <replaceable class="parameter">value1</replaceable> <replaceable class="parameter">value2</replaceable> ... <literal>)</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>insert</literal> <optional><literal>OID =</literal> <replaceable class="parameter">oid_value</replaceable></optional> <literal>(</literal> <replaceable class="parameter">value1</replaceable> <replaceable class="parameter">value2</replaceable> ... <literal>)</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Insert a new row into the open table using <replaceable
      class="parameter">value1</replaceable>, <replaceable
      class="parameter">value2</replaceable>, etc., for its column
      values and <replaceable
      class="parameter">oid_value</replaceable> for its OID.  If
      <replaceable class="parameter">oid_value</replaceable> is zero
      (0) or the clause is omitted, and the table has OIDs, then the
      next available OID is assigned.
     </para>
____________________________________________________________________________-->
     <para>
      用<replaceable class="parameter">value1</replaceable>、<replaceable class="parameter">value2</replaceable> 等作为列值以及<replaceable class="parameter">oid_value</replaceable>作为其 OID向打开的表插入一条新记录。如果<replaceable class="parameter">oid_value</replaceable>为零（0）或者该子句被忽略而表可以具有OID，则会为之赋予下一个可用的OID。
     </para>

<!--==========================orignal english content==========================
     <para>
      NULL values can be specified using the special key word
      <literal>_null_</literal>.  Values that do not look like
      identifiers or digit strings must be double quoted.
     </para>
____________________________________________________________________________-->
     <para>
      NULL 可以用特殊的关键字<literal>_null_</literal>指定。看起来不像标识符或者数字字符串的值必须被加上双引号。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">indexname</replaceable>
     <replaceable class="parameter">indexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
     <literal>using</literal> <replaceable class="parameter">amname</replaceable>
     <literal>(</literal> <replaceable class="parameter">opclass1</replaceable>
     <replaceable class="parameter">name1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">indexname</replaceable>
     <replaceable class="parameter">indexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
     <literal>using</literal> <replaceable class="parameter">amname</replaceable>
     <literal>(</literal> <replaceable class="parameter">opclass1</replaceable>
     <replaceable class="parameter">name1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Create an index named <replaceable
      class="parameter">indexname</replaceable>, having OID
      <replaceable class="parameter">indexoid</replaceable>,
      on the table named
      <replaceable class="parameter">tablename</replaceable>, using the
      <replaceable class="parameter">amname</replaceable> access
      method.  The fields to index are called <replaceable
      class="parameter">name1</replaceable>, <replaceable
      class="parameter">name2</replaceable> etc., and the operator
      classes to use are <replaceable
      class="parameter">opclass1</replaceable>, <replaceable
      class="parameter">opclass2</replaceable> etc., respectively.
      The index file is created and appropriate catalog entries are
      made for it, but the index contents are not initialized by this command.
     </para>
____________________________________________________________________________-->
     <para>
      在名为<replaceable class="parameter">tablename</replaceable>的表上用<replaceable class="parameter">amname</replaceable>访问方法创建一个OID为<replaceable class="parameter">indexoid</replaceable>的名为<replaceable class="parameter">indexname</replaceable>的索引。 索引的域被称为<replaceable class="parameter">name1</replaceable>、<replaceable class="parameter">name2</replaceable>等，而使用的操作符类分别是<replaceable class="parameter">opclass1</replaceable>, <replaceable class="parameter">opclass2</replaceable>等。 该命令将会创建索引文件和适当的系统目录项，但是索引内容不会被此命令初始化。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Create a TOAST table for the table named
      <replaceable class="parameter">tablename</replaceable>.
      The TOAST table is assigned OID
      <replaceable class="parameter">toasttableoid</replaceable>
      and its index is assigned OID
      <replaceable class="parameter">toastindexoid</replaceable>.
      As with <literal>declare index</literal>, filling of the index
      is postponed.
     </para>
____________________________________________________________________________-->
     <para>
      为名为<replaceable class="parameter">tablename</replaceable>的表创建一个TOAST表。该TOAST表将被赋予由<replaceable class="parameter">toasttableoid</replaceable>表示的OID，且它的索引将被赋予由<replaceable class="parameter">toastindexoid</replaceable>表示的OID。和<literal>declare index</literal>一样，索引的填充将被推迟。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>build indices</literal></term>
____________________________________________________________________________-->
    <term><literal>build indices</literal></term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Fill in the indices that have previously been declared.
     </para>
____________________________________________________________________________-->
     <para>
      填充之前声明的索引。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-structure">
<!--==========================orignal english content==========================
  <title>Structure of the Bootstrap <acronym>BKI</acronym> File</title>
____________________________________________________________________________-->
  <title>自举<acronym>BKI</acronym>文件的结构</title>

<!--==========================orignal english content==========================
  <para>
   The <literal>open</literal> command cannot be used until the tables it uses
   exist and have entries for the table that is to be opened.
   (These minimum tables are <structname>pg_class</structname>,
   <structname>pg_attribute</structname>, <structname>pg_proc</structname>, and
   <structname>pg_type</structname>.)   To allow those tables themselves to be filled,
   <literal>create</literal> with the <literal>bootstrap</literal> option implicitly opens
   the created table for data insertion.
  </para>
____________________________________________________________________________-->
  <para>
   在<literal>open</literal>命令打开某个表时，它需要系统中已经存在一些表并且其中要具有与被打开表相关的项，在这些先决条件满足之前，<literal>open</literal>命令不能被使用（这些至少应该存在的表是<structname>pg_class</structname>、<structname>pg_attribute</structname>、<structname>pg_proc</structname>和<structname>pg_type</structname>）。 为了允许这些表本身被填充，带着<literal>bootstrap</literal>选项的<literal>create</literal>将会隐式打开所创建的表用于插入数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   Also, the <literal>declare index</literal> and <literal>declare toast</literal>
   commands cannot be used until the system catalogs they need have been
   created and filled in.
  </para>
____________________________________________________________________________-->
  <para>
   同样，<literal>declare index</literal>和<literal>declare toast</literal>命令也必须在相关系统目录被创建和填充之后才能被使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Thus, the structure of the <filename>postgres.bki</filename> file has to
   be:
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal> one of the critical tables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> data describing at least the critical tables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Repeat for the other critical tables.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal> (without <literal>bootstrap</literal>) a noncritical table
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> desired data
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Repeat for the other noncritical tables.
     </para>
    </listitem>
    <listitem>
     <para>
      Define indexes and toast tables.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>
____________________________________________________________________________-->
  <para>
   因此，<filename>postgres.bki</filename>文件的结构必须是：
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal>其中一个关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal>数据，这些数据至少要能描述这些关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      重复创建其他关键表。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal>（不带<literal>bootstrap</literal>）一个非关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal>需要的数据
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      重复创建其他非关键表。
     </para>
    </listitem>
    <listitem>
     <para>
      定义索引和TOAST表。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   There are doubtless other, undocumented ordering dependencies.
  </para>
____________________________________________________________________________-->
  <para>
   无疑还有其它未被文档记录的顺序依赖关系。
  </para>
 </sect1>

 <sect1 id="bki-example">
<!--==========================orignal english content==========================
  <title>BKI Example</title>
____________________________________________________________________________-->
  <title>BKI例子</title>

<!--==========================orignal english content==========================
  <para>
   The following sequence of commands will create the
   table <literal>test_table</literal> with OID 420, having two columns
   <literal>cola</literal> and <literal>colb</literal> of type
   <type>int4</type> and <type>text</type>, respectively, and insert
   two rows into the table:
<programlisting>
create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 "value1" )
insert OID=422 ( 2 _null_ )
close test_table
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下面的命令集将创建名为<literal>test_table</literal>的表，它有两个列<literal>cola</literal>和<literal>colb</literal>，类型分别为<type>int4</type>和<type>text</type>的表，且表的OID为420， 然后向该表插入两行：
<programlisting>
create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 "value1" )
insert OID=422 ( 2 _null_ )
close test_table
</programlisting>
  </para>
 </sect1>
</chapter>
