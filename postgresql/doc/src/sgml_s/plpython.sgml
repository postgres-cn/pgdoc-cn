<!-- doc/src/sgml/plpython.sgml -->

<chapter id="plpython">
<!--==========================orignal english content==========================
 <title>PL/Python - Python Procedural Language</title>
____________________________________________________________________________-->
 <title>PL/Python - Python 过程语言</title>

<!--==========================orignal english content==========================
 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm zone="plpython"><primary>Python</primary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

<!--==========================orignal english content==========================
 <para>
  The <application>PL/Python</application> procedural language allows
  <productname>PostgreSQL</productname> functions to be written in the
  <ulink url="https://www.python.org">Python language</ulink>.
 </para>
____________________________________________________________________________-->
 <para>
  <application>PL/Python</application>过程语言允许用<ulink url="http://www.python.org">Python 语言</ulink>编写<productname>PostgreSQL</productname>函数。
 </para>

<!--==========================orignal english content==========================
 <para>
  To install PL/Python in a particular database, use
  <literal>CREATE EXTENSION plpythonu</literal> (but
  see also <xref linkend="plpython-python23"/>).
 </para>
____________________________________________________________________________-->
 <para>
  要在一个特定数据库中安装 PL/Python，请使用<literal>CREATE EXTENSION plpythonu</literal>（另见<xref linkend="plpython-python23"/>）。
 </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    If a language is installed into <literal>template1</literal>, all subsequently
    created databases will have the language installed automatically.
   </para>
____________________________________________________________________________-->
   <para>
    如果把一种语言安装在<literal>template1</literal>中，所有后续创建的数据库都会自动安装该语言。
   </para>
  </tip>

<!--==========================orignal english content==========================
 <para>
  PL/Python is only available as an <quote>untrusted</quote> language, meaning
  it does not offer any way of restricting what users can do in it and
  is therefore named <literal>plpythonu</literal>.  A trusted
  variant <literal>plpython</literal> might become available in the future
  if a secure execution mechanism is developed in Python.  The
  writer of a function in untrusted PL/Python must take care that the
  function cannot be used to do anything unwanted, since it will be
  able to do anything that could be done by a user logged in as the
  database administrator.  Only superusers can create functions in
  untrusted languages such as <literal>plpythonu</literal>.
 </para>
____________________________________________________________________________-->
 <para>
  PL/Python 只是一种<quote>不可信</quote>语言，这意味着它没有提供任何方法来限制用户在其中的所作所为，并且因此被命名为<literal>plpythonu</literal>。如果未来开发出在 Python 中的安全执行机制，可能会出现一种可信的变体<literal>plpython</literal>。不可信 PL/Python 中函数的编写者必须注意该函数不能被用来做任何它不应该做的事情，因为它将能做以数据库管理员用户登录能做的事情。只有超级用户能够创建<literal>plpythonu</literal>等不可信语言中的函数。
 </para>

 <note>
<!--==========================orignal english content==========================
  <para>
   Users of source packages must specially enable the build of
   PL/Python during the installation process.  (Refer to the
   installation instructions for more information.)  Users of binary
   packages might find PL/Python in a separate subpackage.
  </para>
____________________________________________________________________________-->
  <para>
   源码包的用户必须在安装过程中特别地启用 PL/Python 的编译（更多信息请参考安装指导）。二进制包的用户可以在一个单独的子包中找到 PL/Python。
  </para>
 </note>

 <sect1 id="plpython-python23">
<!--==========================orignal english content==========================
  <title>Python 2 vs. Python 3</title>
____________________________________________________________________________-->
  <title>Python 2 vs. Python 3</title>

<!--==========================orignal english content==========================
  <para>
   PL/Python supports both the Python 2 and Python 3 language
   variants.  (The PostgreSQL installation instructions might contain
   more precise information about the exact supported minor versions
   of Python.)  Because the Python 2 and Python 3 language variants
   are incompatible in some important aspects, the following naming
   and transitioning scheme is used by PL/Python to avoid mixing them:

   <itemizedlist>
    <listitem>
     <para>
      The PostgreSQL language named <literal>plpython2u</literal>
      implements PL/Python based on the Python 2 language variant.
     </para>
    </listitem>

    <listitem>
     <para>
      The PostgreSQL language named <literal>plpython3u</literal>
      implements PL/Python based on the Python 3 language variant.
     </para>
    </listitem>

    <listitem>
     <para>
      The language named <literal>plpythonu</literal> implements
      PL/Python based on the default Python language variant, which is
      currently Python 2.  (This default is independent of what any
      local Python installations might consider to be
      their <quote>default</quote>, for example,
      what <filename>/usr/bin/python</filename> might be.)  The
      default will probably be changed to Python 3 in a distant future
      release of PostgreSQL, depending on the progress of the
      migration to Python 3 in the Python community.
     </para>
    </listitem>
   </itemizedlist>

   This scheme is analogous to the recommendations in <ulink
   url="https://www.python.org/dev/peps/pep-0394/">PEP 394</ulink> regarding the
   naming and transitioning of the <command>python</command> command.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Python 同时支持 Python 2 和 Python 3 两种语言变体（PostgreSQL 安装指导可能包含了所支持的 Python 次版本的更精确的信息）。因为 Python 2 和 Python 3 语言变体在某些重要的方面并不兼容，PL/Python 使用了下列命名和转换模式以避免混淆它们：

   <itemizedlist>
    <listitem>
     <para>
      名为<literal>plpython2u</literal>的 PostgreSQL 语言实现了基于 Python 2 语言变体的 PL/Python。
     </para>
    </listitem>

    <listitem>
     <para>
      名为<literal>plpython3u</literal>的 PostgreSQL 语言实现了基于 Python 3 语言变体的 PL/Python。
     </para>
    </listitem>

    <listitem>
     <para>
      名为<literal>plpythonu</literal>的语言实现了基于默认 Python语言变体（当前是 Python 2）的 PL/Python（这种默认与任何本地 Python 安装所认为的<quote>默认</quote>无关，例如<filename>/usr/bin/python</filename>）。在遥远的未来，PostgreSQL 的发布中可能会把这种默认语言变体改成 Python 3，这取决于 Python 社区迁移到 Python 3 的进度。
     </para>
    </listitem>
   </itemizedlist>

   这种模式类似于<ulink url="https://www.python.org/dev/peps/pep-0394/">PEP 394</ulink>中关于<command>python</command>命令的命名和转换的推荐。
  </para>

<!--==========================orignal english content==========================
  <para>
   It depends on the build configuration or the installed packages
   whether PL/Python for Python 2 or Python 3 or both are available.
  </para>
____________________________________________________________________________-->
  <para>
   到底是 Python 2 还是 Python 3 的 PL/Python 可用或是两者都可用，取决于编译配置或者被安装的包。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    The built variant depends on which Python version was found during
    the installation or which version was explicitly set using
    the <envar>PYTHON</envar> environment variable;
    see <xref linkend="install-procedure"/>.  To make both variants of
    PL/Python available in one installation, the source tree has to be
    configured and built twice.
   </para>
____________________________________________________________________________-->
   <para>
    如果是编译安装，则取决于在安装期间找到的 Python 版本或者用<envar>PYTHON</envar>环境变量显式设置的版本，见<xref linkend="install-procedure"/>。要在一个安装中让两种变体的 PL/Python 都可用，源代码树必须被配置和编译两次。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   This results in the following usage and migration strategy:

   <itemizedlist>
    <listitem>
     <para>
      Existing users and users who are currently not interested in
      Python 3 use the language name <literal>plpythonu</literal> and
      don't have to change anything for the foreseeable future.  It is
      recommended to gradually <quote>future-proof</quote> the code
      via migration to Python 2.6/2.7 to simplify the eventual
      migration to Python 3.
     </para>

     <para>
      In practice, many PL/Python functions will migrate to Python 3
      with few or no changes.
     </para>
    </listitem>

    <listitem>
     <para>
      Users who know that they have heavily Python 2 dependent code
      and don't plan to ever change it can make use of
      the <literal>plpython2u</literal> language name.  This will
      continue to work into the very distant future, until Python 2
      support might be completely dropped by PostgreSQL.
     </para>
    </listitem>

    <listitem>
     <para>
      Users who want to dive into Python 3 can use
      the <literal>plpython3u</literal> language name, which will keep
      working forever by today's standards.  In the distant future,
      when Python 3 might become the default, they might like to
      remove the <quote>3</quote> for aesthetic reasons.
     </para>
    </listitem>

    <listitem>
     <para>
      Daredevils, who want to build a Python-3-only operating system
      environment, can change the contents of
      <link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>
      to make <literal>plpythonu</literal> be equivalent
      to <literal>plpython3u</literal>, keeping in mind that this
      would make their installation incompatible with most of the rest
      of the world.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   这产生了下列的使用和迁移策略：

   <itemizedlist>
    <listitem>
     <para>
      现有用户以及对 Python 3 不感兴趣的用户使用<literal>plpythonu</literal>语言并且在可预见的未来不必做出任何改变。我们推荐通过迁移到 Python 2.6/2.7 逐步地让代码<quote>经得起未来的考验</quote>以简化最终迁移到 Python 3 的工作。
     </para>

     <para>
      实际上，很多 PL/Python 函数可以用很少或者不做修改就迁移到 Python 3。
     </para>
    </listitem>

    <listitem>
     <para>
      对于代码严重依赖于 Python 2 并且不打算做改变的用户可以使用<literal>plpython2u</literal>语言。这将在很长时间内都有效，直到 PostgreSQL 完全删除掉对 Python 2 的支持。
     </para>
    </listitem>

    <listitem>
     <para>
      想投入 Python 3 的怀抱的用户可以使用<literal>plpython3u</literal>语言，在当前的标准下这将一直有效。在遥远的未来，当 Python 3 成为默认以后，出于审美的原因，<quote>3</quote>可能会被移除。
     </para>
    </listitem>

    <listitem>
     <para>
      想要构建一个只有 Python 3 的操作系统环境的冒险者们，可以更改<link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>的内容让<literal>plpythonu</literal>等价于<literal>plpython3u</literal>，记住这将会让他们的安装与世界的其他大部分东西都不兼容。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   See also the
   document <ulink url="https://docs.python.org/3/whatsnew/3.0.html">What's
   New In Python 3.0</ulink> for more information about porting to
   Python 3.
  </para>
____________________________________________________________________________-->
  <para>
   有关移植到 Python 3 的更多信息还可见文档<ulink url="https://docs.python.org/3/whatsnew/3.0.html">What's
   New In Python 3.0</ulink>。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is not allowed to use PL/Python based on Python 2 and PL/Python
   based on Python 3 in the same session, because the symbols in the
   dynamic modules would clash, which could result in crashes of the
   PostgreSQL server process.  There is a check that prevents mixing
   Python major versions in a session, which will abort the session if
   a mismatch is detected.  It is possible, however, to use both
   PL/Python variants in the same database, from separate sessions.
  </para>
____________________________________________________________________________-->
  <para>
   不允许在同一个会话中使用基于 Python 2 的 PL/Python 以及基于 Python 3 的 PL/Python，因为动态模块中的符号会冲突，这会导致 PostgreSQL 服务器进程的崩溃。在一个会话中有一个检查来阻止混淆 Python 的主版本，如果检测到不匹配会中断会话。不过，可以在同一个数据库中对不同的会话使用两种 PL/Python 变体。
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
<!--==========================orignal english content==========================
  <title>PL/Python Functions</title>
____________________________________________________________________________-->
  <title>PL/Python 函数</title>

<!--==========================orignal english content==========================
  <para>
   Functions in PL/Python are declared via the
   standard <xref linkend="sql-createfunction"/> syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   PL/Python 中的函数通过标准的<xref linkend="sql-createfunction"/>语法声明：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python 函数体
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The body of a function is simply a Python script. When the function
   is called, its arguments are passed as elements of the list
   <varname>args</varname>; named arguments are also passed as
   ordinary variables to the Python script.  Use of named arguments is
   usually more readable.  The result is returned from the Python code
   in the usual way, with <literal>return</literal> or
   <literal>yield</literal> (in case of a result-set statement).  If
   you do not provide a return value, Python returns the default
   <symbol>None</symbol>. <application>PL/Python</application> translates
   Python's <symbol>None</symbol> into the SQL null value.  In a procedure,
   the result from the Python code must be <symbol>None</symbol> (typically
   achieved by ending the procedure without a <literal>return</literal>
   statement or by using a <literal>return</literal> statement without
   argument); otherwise, an error will be raised.
  </para>
____________________________________________________________________________-->
  <para>
   函数体就是一个 Python 脚本。当函数被调用时，它的参数被当做列表<varname>args</varname>的元素传递，命名参数也被作为普通变量传递给 Python 脚本。使用命名参数通常可读性更好。Python 代码会以通常的方式返回结果，即使用<literal>return</literal>或者<literal>yield</literal>（在结果集合语句的情况中）。如果没有提供一个返回值，Python 会返回默认的<symbol>None</symbol>。<application>PL/Python</application>会把 Python 的<symbol>None</symbol>翻译成 SQL 空值。在一个过程中，Python代码的结果必须是<symbol>None</symbol>（通常实现为结束过程时不写<literal>return</literal>语句或者使用不带参数的<literal>return</literal>），否则将会发生错误。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, a function to return the greater of two integers can be
   defined as:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   The Python code that is given as the body of the function definition
   is transformed into a Python function. For example, the above results in:

<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

   assuming that 23456 is the OID assigned to the function by
   <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   例如，一个返回两个整数中较大的整数的函数可以定义为：

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   作为该函数定义给出的 Python 代码会被转换成一个 Python 函数。例如上面的代码会得到：

<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

   假定 23456 是<productname>PostgreSQL</productname>分配给这个函数的 OID。
  </para>

<!--==========================orignal english content==========================
  <para>
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only.
  </para>
____________________________________________________________________________-->
  <para>
   参数被设置为全局变量。由于 Python 的可见范围规则，这会导致一种后果：在函数内不能把一个参数变量重新赋予给一个涉及该变量名称本身的表达式的值，除非在该代码块中重新声明该变量为全局的。例如，下面的代码无法工作：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # 错误
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   因为对<varname>x</varname>的赋值让<varname>x</varname>成为了整个代码块的一个局部变量，并且因此该赋值操作右边的<varname>x</varname>引用的是一个还未赋值的局部变量<varname>x</varname>，而不是 PL/Python 函数的参数。通过使用<literal>global</literal>语句，可以让上面的代码正常工作：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # 现在好了
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   但是不建议依赖于这类 PL/Python 的实现细节。最好把函数参数当作是只读。
  </para>
 </sect1>

 <sect1 id="plpython-data">
<!--==========================orignal english content==========================
  <title>Data Values</title>
____________________________________________________________________________-->
  <title>数据值</title>
<!--==========================orignal english content==========================
  <para>
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
  </para>
____________________________________________________________________________-->
  <para>
   一般来讲，PL/Python 的目标是提供在 PostgreSQL 和 Python 世界之间的一种<quote>自然的</quote>映射。这包括下面介绍的数据映射规则。
  </para>

  <sect2>
<!--==========================orignal english content==========================
   <title>Data Type Mapping</title>
____________________________________________________________________________-->
   <title>数据类型映射</title>
<!--==========================orignal english content==========================
   <para>
    When a PL/Python function is called, its arguments are converted from
    their PostgreSQL data type to a corresponding Python type:

    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>smallint</type> and <type>int</type> are
       converted to Python <type>int</type>.
       PostgreSQL <type>bigint</type> and <type>oid</type> are converted
       to <type>long</type> in Python 2 and to <type>int</type> in
       Python 3.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>real</type> and <type>double</type> are converted to
       Python <type>float</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>numeric</type> is converted to
       Python <type>Decimal</type>.  This type is imported from
       the <literal>cdecimal</literal> package if that is available.
       Otherwise,
       <literal>decimal.Decimal</literal> from the standard library will be
       used.  <literal>cdecimal</literal> is significantly faster
       than <literal>decimal</literal>.  In Python 3.3 and up,
       however, <literal>cdecimal</literal> has been integrated into the
       standard library under the name <literal>decimal</literal>, so there is
       no longer any difference.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>bytea</type> is converted to
       Python <type>str</type> in Python 2 and to <type>bytes</type>
       in Python 3.  In Python 2, the string should be treated as a
       byte sequence without any character encoding.
      </para>
     </listitem>

     <listitem>
      <para>
       All other data types, including the PostgreSQL character string
       types, are converted to a Python <type>str</type>.  In Python
       2, this string will be in the PostgreSQL server encoding; in
       Python 3, it will be a Unicode string like all strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在调用一个 PL/Python 函数时，它的参数会被从 PostgreSQL 的数据类型转换成相应的 Python 类型：

    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL 的<type>boolean</type>被转换成 Python 的<type>bool</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL 的<type>smallint</type>和<type>int</type>被转换成 Python 的<type>int</type>。 PostgreSQL 的<type>bigint</type>和<type>oid</type>被转换成 Python 2 的<type>long</type>或者 Python 3 的<type>int</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL 的<type>real</type>和<type>double</type>被转换成 Python 的<type>float</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL 的<type>numeric</type>被转换成 Python 的<type>Decimal</type>。如果存在<literal>cdecimal</literal>包，则会从其中导入该类型。否则将使用来自标准库的<literal>decimal.Decimal</literal>。<literal>cdecimal</literal>比<literal>decimal</literal>要更快。不过，在 Python 3.3 以及更高的版本中，<literal>cdecimal</literal>已经被整合到了标准库中（也是用<literal>decimal</literal>这个名字），因此也就不再有什么区别。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL 的<type>bytea</type>被转换成 Python 的<type>str</type>（Python 2）和<type>bytes</type>（Python 3）。在 Python 2 中，串应该被当做没有任何字符编码的字节序列对待。
      </para>
     </listitem>

     <listitem>
      <para>
       包括 PostgreSQL 字符串类型在内的所有其他数据类型会被转换成一个 Python 的<type>str</type>。在 Python 2 中，这个串将用 PostgreSQL 服务器编码；在 Python 3 中，它将和所有串一样使用 Unicode。
      </para>
     </listitem>

     <listitem>
      <para>
       对于非标量数据类型，请见下文。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    When a PL/Python function returns, its return value is converted to the
    function's declared PostgreSQL return data type as follows:

    <itemizedlist>
     <listitem>
      <para>
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
      </para>
     </listitem>

     <listitem>
      <para>
       When the PostgreSQL return type is <type>bytea</type>, the
       return value will be converted to a string (Python 2) or bytes
       (Python 3) using the respective Python built-ins, with the
       result being converted to <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       For all other PostgreSQL return types, the return value is converted
       to a string using the Python built-in <literal>str</literal>, and the
       result is passed to the input function of the PostgreSQL data type.
       (If the Python value is a <type>float</type>, it is converted using
       the <literal>repr</literal> built-in instead of <literal>str</literal>, to
       avoid loss of precision.)
      </para>

      <para>
       Strings in Python 2 are required to be in the PostgreSQL server
       encoding when they are passed to PostgreSQL.  Strings that are
       not valid in the current server encoding will raise an error,
       but not all encoding mismatches can be detected, so garbage
       data can still result when this is not done correctly.  Unicode
       strings are converted to the correct encoding automatically, so
       it can be safer and more convenient to use those.  In Python 3,
       all strings are Unicode strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>

    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case.
   </para>
____________________________________________________________________________-->
   <para>
    当一个 PL/Python 函数返回时，会按照下列规则把它的返回值转换成该函数声明的 PostgreSQL 返回数据类型：

    <itemizedlist>
     <listitem>
      <para>
       当 PostgreSQL 返回类型是<type>boolean</type>时，返回值会被根据<emphasis>Python</emphasis>规则计算真假。也就是说，0 和空串是假，但是要特别注意<literal>'f'</literal>是真。
      </para>
     </listitem>

     <listitem>
      <para>
       当 PostgreSQL 返回类型是<type>bytea</type>时，返回值会被使用相应的 Python 内建机制转换成串（Python 2）或者字节（Python 3），结果将被转换成<type>bytea</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       对于所有其他 PostgreSQL 返回类型，返回值被使用 Python 内建的<literal>str</literal>转换成一个串，并且结果会被传递给 PostgreSQL 数据类型的输入函数（如果该 Python 值是一个<type>float</type>，它会被用内建的<literal>repr</literal>而不是<literal>str</literal>转换，这是为了避免精度损失）。
      </para>

      <para>
       当 Python 2 的串被传递给 PostgreSQL 时，它们被要求是 PostgreSQL 服务器编码。在当前服务器编码中不可用的串将会产生错误，但是并非所有的编码失配都能被检测到，因此当没有正确地将串编码时，垃圾数据仍然会产生。Unicode 串会被自动地转换为正确的编码，因此使用 Unicode 串更加安全并且更加方便。在 Python 3 中，所有串都是 Unicode 串。
      </para>
     </listitem>

     <listitem>
      <para>
       对于非标量数据类型，请见下文。
      </para>
     </listitem>
    </itemizedlist>

    注意所声明的 PostgreSQL 返回类型和实际返回对象的 Python 数据类型之间的逻辑失配不会被标志，无论怎样该值都会被转换。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Null, None</title>
____________________________________________________________________________-->
   <title>Null, None</title>
<!--==========================orignal english content==========================
  <para>
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">in PL/Python</secondary></indexterm> is passed to a
   function, the argument value will appear as <symbol>None</symbol> in
   Python. For example, the function definition of <function>pymax</function>
   shown in <xref linkend="plpython-funcs"/> will return the wrong answer for null
   inputs. We could add <literal>STRICT</literal> to the function definition
   to make <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically. Alternatively,
   we could check for null inputs in the function body:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   As shown above, to return an SQL null value from a PL/Python
   function, return the value <symbol>None</symbol>. This can be done whether the
   function is strict or not.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个 SQL 空值<indexterm><primary>null value</primary><secondary sortas="PL/Python">in PL/Python</secondary></indexterm>被传递给一个函数，该参数值将作为 Python 中的<symbol>None</symbol>出现。例如，<xref linkend="plpython-funcs"/>中展示的<function>pymax</function>的函数定义对于空值输入将会返回错误的回答。我们可以为函数定义增加<literal>STRICT</literal>让<productname>PostgreSQL</productname>做得更加合理：如果一个空值被传入，该函数将根本不会被调用，而只是自动地返回一个空结果。此外，我们可以在函数体中检查空输入：

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   如前所示，要从一个 PL/Python 函数返回一个 SQL 空值，可返回值<symbol>None</symbol>。不管该函数严格与否都可以这样做。
  </para>
  </sect2>

  <sect2 id="plpython-arrays">
<!--==========================orignal english content==========================
   <title>Arrays, Lists</title>
____________________________________________________________________________-->
   <title>数组、列表</title>
<!--==========================orignal english content==========================
  <para>
   SQL array values are passed into PL/Python as a Python list.  To
   return an SQL array value out of a PL/Python function, return a
   Python list:

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4,5}
(1 row)
</programlisting>

   Multidimensional arrays are passed into PL/Python as nested Python lists.
   A 2-dimensional array is a list of lists, for example. When returning
   a multi-dimensional SQL array out of a PL/Python function, the inner
   lists at each level must all be of the same size. For example:

<programlisting>
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpythonu;

SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
 test_type_conversion_array_int4 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2,3},{4,5,6}}
(1 row)
</programlisting>

   Other Python sequences, like tuples, are also accepted for
   backwards-compatibility with PostgreSQL versions 9.6 and below, when
   multi-dimensional arrays were not supported. However, they are always
   treated as one-dimensional arrays, because they are ambiguous with
   composite types. For the same reason, when a composite type is used in a
   multi-dimensional array, it must be represented by a tuple, rather than a
   list.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 数组会被作为一个 Python 列表传递到 PL/Python 中。要从一个 PL/Python 函数中返回出一个 SQL 数组值，可返回一个Python列表：

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

   多维数组被当做嵌套的Python列表传入PL/Python。例如，一个2维数组是一个列表的列表。在把一个多维SQL数组从PL/Python函数返回出去时，每一层的内层列表都必须是相同的尺寸。例如：

<programlisting>
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpythonu;

SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
 test_type_conversion_array_int4 
---------------------------------
 {{1,2,3},{4,5,6}}
(1 row)
</programlisting>

   为了与PostgreSQL的9.6以及更低版本的向后兼容性，当不支持多维数组时，也接受元组之类的其他Python序列。不过，它们总是被当做一维数组，因为它们会和组合类型混淆。出于同样的原因，当一个组合类型被用在多维数组中时，它必须被表示为一个元组而不是一个列表。
  </para>
<!--==========================orignal english content==========================
  <para>
   Note that in Python, strings are sequences, which can have
   undesirable effects that might be familiar to Python programmers:

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   注意在 Python 中，串是序列，这可能产生与 Python 程序员所熟悉的不同的效果：

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Composite Types</title>
____________________________________________________________________________-->
   <title>组合类型</title>
<!--==========================orignal english content==========================
  <para>
   Composite-type arguments are passed to the function as Python mappings. The
   element names of the mapping are the attribute names of the composite type.
   If an attribute in the passed row has the null value, it has the value
   <symbol>None</symbol> in the mapping. Here is an example:

<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   组合类型参数被作为 Python 映射传递给函数。映射的元素名称就是组合类型的属性名。如果被传递的行中有一个属性是空值，在映射中它的值是<symbol>None</symbol>。这里是一个例子：

<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   There are multiple ways to return row or composite types from a Python
   function. The following examples assume we have:

<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

   A composite result can be returned as a:

   <variablelist>
    <varlistentry>
     <term>Sequence type (a tuple or list, but not a set because
     it is not indexable)</term>
     <listitem>
      <para>
       Returned sequence objects must have the same number of items as the
       composite result type has fields. The item with index 0 is assigned to
       the first field of the composite type, 1 to the second and so on. For
       example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return ( name, value )
  # or alternatively, as tuple: return [ name, value ]
$$ LANGUAGE plpythonu;
</programlisting>

       To return a SQL null for any column, insert <symbol>None</symbol> at
       the corresponding position.
      </para>
      <para>
       When an array of composite types is returned, it cannot be returned as a list,
       because it is ambiguous whether the Python list represents a composite type,
       or another array dimension.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Mapping (dictionary)</term>
     <listitem>
      <para>
       The value for each result type column is retrieved from the mapping
       with the column name as key. Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;
</programlisting>

       Any extra dictionary key/value pairs are ignored. Missing keys are
       treated as errors.
       To return a SQL null value for any column, insert
       <symbol>None</symbol> with the corresponding column name as the key.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Object (any object providing method <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       This works the same as a mapping.
       Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   有多种方式从一个 Python 函数返回行或者组合类型。下面的例子假设我们有：

<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

   一个组合结果可以被返回为：

   <variablelist>
    <varlistentry>
     <term>序列类型（一个元组或者列表，但不是集合，因为
     集合不能被索引）</term>
     <listitem>
      <para>
       被返回的序列对象必须具有和组合结果类型的域个数相同的项。索引号为 0 的项被分配给组合类型的第一个域，为 1 的项给第二个域，以此类推。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return ( name, value )
  # or alternatively, as tuple: return [ name, value ]
$$ LANGUAGE plpythonu;
</programlisting>

       要为任意列返回一个 SQL 空，应在对应的位置插入<symbol>None</symbol>。
      </para>
      <para>
       当一个组合类型的数组被返回时，它不能被返回为列表，因为会弄不清该Python列表究竟是表示一个组合类型还是另一个数组维度。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>映射（字典）</term>
     <listitem>
      <para>
       用列名作为键从映射中检索每一个结果类型列的值。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;
</programlisting>

       任何额外的字典键/值对都会被忽略。丢失的键会被当做错误。要为任意列返回一个 SQL 空，应用相应的列名作为键插入<symbol>None</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>对象（任何提供方法<literal>__getattr__</literal>的对象）</term>
     <listitem>
      <para>
       这和映射的运作方式相同。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # 或简单地
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
   <para>
    Functions with <literal>OUT</literal> parameters are also supported.  For example:
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    也支持具有<literal>OUT</literal>参数的函数。例如：
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Output parameters of procedures are passed back the same way.  For example:
<programlisting>
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpythonu;

CALL python_triple(5, 10);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    过程的输出参数会以同样的方式传回。例如：
<programlisting>
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpythonu;

CALL python_triple(5, 10);
</programlisting>
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Set-returning Functions</title>
____________________________________________________________________________-->
   <title>集合返回函数</title>
<!--==========================orignal english content==========================
  <para>
   A <application>PL/Python</application> function can also return sets of
   scalar or composite types. There are several ways to achieve this because
   the returned object is internally turned into an iterator. The following
   examples assume we have composite type:

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

   A set result can be returned from a:

   <variablelist>
    <varlistentry>
     <term>Sequence type (tuple, list, set)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Iterator (any object providing <symbol>__iter__</symbol> and
      <symbol>next</symbol> methods)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Generator (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <application>PL/Python</application>函数也能返回标量类型或者组合类型的集合。有多种方法可以做到这一点，因为被返回的对象在内部会被转变成一个迭代器。下面的例子假设我们有组合类型：

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

   可从以下类型返回集合结果：

   <variablelist>
    <varlistentry>
     <term>序列类型（元组、列表、集合）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # 把包含列表的元组返回为组合类型
  # 所有其他组合也能行
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>迭代器（任何提供<symbol>__iter__</symbol>以及
      <symbol>next</symbol>方法的对象）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>发生器（<literal>yield</literal>）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
   <para>
    Set-returning functions with <literal>OUT</literal> parameters
    (using <literal>RETURNS SETOF record</literal>) are also
    supported.  For example:
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    也支持有<literal>OUT</literal>参数的集合返回函数（使用<literal>RETURNS SETOF record</literal>）。例如：
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
<!--==========================orignal english content==========================
  <title>Sharing Data</title>
____________________________________________________________________________-->
  <title>共享数据</title>
<!--==========================orignal english content==========================
  <para>
   The global dictionary <varname>SD</varname> is available to store
   private data between repeated calls to the same function.
   The global dictionary <varname>GD</varname> is public data,
   that is available to all Python functions within a session;  use with
   care.<indexterm><primary>global data</primary>
   <secondary>in PL/Python</secondary></indexterm>
  </para>
____________________________________________________________________________-->
  <para>
   在对同一个函数的重复调用之间可用全局字典<varname>SD</varname>来存储私有数据。全局字典<varname>GD</varname>是公共数据，它对一个会话中的所有 Python 函数都可用，使用起来要小心。
   <indexterm><primary>全局数据</primary>
   <secondary>in PL/Python</secondary></indexterm>
  </para>

<!--==========================orignal english content==========================
  <para>
   Each function gets its own execution environment in the
   Python interpreter, so that global data and function arguments from
   <function>myfunc</function> are not available to
   <function>myfunc2</function>.  The exception is the data in the
   <varname>GD</varname> dictionary, as mentioned above.
  </para>
____________________________________________________________________________-->
  <para>
   在 Python 解释器中每一个函数都会得到自己的执行环境，因此来自<function>myfunc</function>的全局数据和函数参数对<function>myfunc2</function>不可用。例外是<varname>GD</varname>字典中的数据。
  </para>
 </sect1>

 <sect1 id="plpython-do">
<!--==========================orignal english content==========================
  <title>Anonymous Code Blocks</title>
____________________________________________________________________________-->
  <title>匿名代码块</title>

<!--==========================orignal english content==========================
  <para>
   PL/Python also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpythonu;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Python 也支持用<xref linkend="sql-do"/>语句调用的匿名代码块：

<programlisting>
DO $$
    # PL/Python 代码
$$ LANGUAGE plpythonu;
</programlisting>

   匿名代码块没有参数，并且任何可能返回的值都会被丢弃。否则，其行为就像一个函数。
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
<!--==========================orignal english content==========================
  <title>Trigger Functions</title>
____________________________________________________________________________-->
  <title>触发器函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="plpython-trigger">
   <primary>trigger</primary>
   <secondary>in PL/Python</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plpython-trigger">
   <primary>触发器</primary>
   <secondary>in PL/Python</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When a function is used as a trigger, the dictionary
   <literal>TD</literal> contains trigger-related values:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contains the event as a string:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contains one of <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contains <literal>ROW</literal> or <literal>STATEMENT</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       For a row-level trigger, one or both of these fields contain
       the respective trigger rows, depending on the trigger event.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contains the trigger name.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contains the name of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contains the schema of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contains the OID of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       If the <command>CREATE TRIGGER</command> command
       included arguments, they are available in <literal>TD["args"][0]</literal> to
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   当函数被用作触发器时，字典<literal>TD</literal>包含触发器相关的值：
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       包含字符串型的事件：<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或者<literal>TRUNCATE</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       包含<literal>BEFORE</literal>、<literal>AFTER</literal>或者<literal>INSTEAD OF</literal>之一。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       包含<literal>ROW</literal>或者<literal>STATEMENT</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       对于行级触发器，这些域的一个或者两个包含相应的触发器行，这取决于触发器事件是什么。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       包含触发器的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表所属的模式名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表的 OID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       如果<command>CREATE TRIGGER</command>命令包括参数，它们可以通过<literal>TD["args"][0]</literal>至<literal>TD["args"][<replaceable>n</replaceable>-1]</literal>使用。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   If <literal>TD["when"]</literal> is <literal>BEFORE</literal> or
   <literal>INSTEAD OF</literal> and
   <literal>TD["level"]</literal> is <literal>ROW</literal>, you can
   return <literal>None</literal> or <literal>"OK"</literal> from the
   Python function to indicate the row is unmodified,
   <literal>"SKIP"</literal> to abort the event, or if <literal>TD["event"]</literal>
   is <command>INSERT</command> or <command>UPDATE</command> you can return
   <literal>"MODIFY"</literal> to indicate you've modified the new row.
   Otherwise the return value is ignored.
  </para>
____________________________________________________________________________-->
  <para>
   如果<literal>TD["when"]</literal>是<literal>BEFORE</literal>或者<literal>INSTEAD OF</literal>并且<literal>TD["level"]</literal>是<literal>ROW</literal>，可以从 Python 函数返回<literal>None</literal>或者<literal>"OK"</literal>来表示行没有被修改。返回<literal>"SKIP"</literal>可以中止事件，或者在<literal>TD["event"]</literal>为<command>INSERT</command>或<command>UPDATE</command>时可以返回<literal>"MODIFY"</literal>以表示已经修改了新行。否则返回值会被忽略。
  </para>
 </sect1>

 <sect1 id="plpython-database">
<!--==========================orignal english content==========================
  <title>Database Access</title>
____________________________________________________________________________-->
  <title>数据库访问</title>

<!--==========================orignal english content==========================
  <para>
   The PL/Python language module automatically imports a Python module
   called <literal>plpy</literal>.  The functions and constants in
   this module are available to you in the Python code as
   <literal>plpy.<replaceable>foo</replaceable></literal>.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Python 语言模块会自动导入一个被称为<literal>plpy</literal>的 Python 模块。这个模块中的函数和常量在 Python 代码中可以用<literal>plpy.<replaceable>foo</replaceable></literal>这样的方式访问。
  </para>

  <sect2>
<!--==========================orignal english content==========================
    <title>Database Access Functions</title>
____________________________________________________________________________-->
    <title>数据库访问函数</title>

<!--==========================orignal english content==========================
  <para>
   The <literal>plpy</literal> module provides several functions to execute
   database commands:
  </para>
____________________________________________________________________________-->
  <para>
   <literal>plpy</literal>模块提供了几个函数来执行数据库命令：
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
____________________________________________________________________________-->
    <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Calling <function>plpy.execute</function> with a query string and an
      optional row limit argument causes that query to be run and the result to
      be returned in a result object.
     </para>
____________________________________________________________________________-->
     <para>
      用一个查询字符串和一个可选的行限制参数调用<function>plpy.execute</function>会让该查询运行并且其结果会被以一个结果对象返回。
     </para>

<!--==========================orignal english content==========================
     <para>
      The result object emulates a list or dictionary object.  The result
      object can be accessed by row number and column name.  For example:
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
      returns up to 5 rows from <literal>my_table</literal>.  If
      <literal>my_table</literal> has a column
      <literal>my_column</literal>, it would be accessed as:
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
      The number of rows returned can be obtained using the built-in
      <function>len</function> function.
     </para>
____________________________________________________________________________-->
     <para>
      结果对象模拟一个列表或者字典对象。可以用行号和列名来访问结果对象。例如：
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
      会从<literal>my_table</literal>中返回 5 行。如果<literal>my_table</literal>有一列是<literal>my_column</literal>，可以这样来访问它：
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
      可以用内建的<function>len</function>函数获得返回的行数。
     </para>

<!--==========================orignal english content==========================
     <para>
      The result object has these additional methods:
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
         <para>
          Returns the number of rows processed by the command.  Note that this
          is not necessarily the same as the number of rows returned.  For
          example, an <command>UPDATE</command> command will set this value but
          won't return any rows (unless <literal>RETURNING</literal> is used).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <para>
          The <function>SPI_execute()</function> return value.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <para>
          Return a list of column names, list of column type OIDs, and list of
          type-specific type modifiers for the columns, respectively.
         </para>

         <para>
          These methods raise an exception when called on a result object from
          a command that did not produce a result set, e.g.,
          <command>UPDATE</command> without <literal>RETURNING</literal>, or
          <command>DROP TABLE</command>.  But it is OK to use these methods on
          a result set containing zero rows.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>__str__</function>()</literal></term>
        <listitem>
         <para>
          The standard <literal>__str__</literal> method is defined so that it
          is possible for example to debug query execution results
          using <literal>plpy.debug(rv)</literal>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      结果对象有这些额外的方法：
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
         <para>
          返回被该命令处理的行数。注意这不一定与返回的行数相同。例如，<command>UPDATE</command>命令将会设置这个值但是不返回任何行（除非使用<literal>RETURNING</literal>）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <para>
          <function>SPI_execute()</function>的返回值。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <para>
          分别返回一个列名列表、列类型 OID 列表以及列的类型相关的类型修饰符列表。
         </para>

         <para>
          在来自于不产生结果集合的命令的结果对象上调用这些方法会产生异常，例如不带<literal>RETURNING</literal>的<command>UPDATE</command>或者<command>DROP TABLE</command>。但是在包含的行数为零的结果集合上使用这些方法是 OK 的。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>__str__</function>()</literal></term>
        <listitem>
         <para>
          也定义了标准的<literal>__str__</literal>方法，例如可以使用<literal>plpy.debug(rv)</literal>来调试查询执行结果。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

<!--==========================orignal english content==========================
     <para>
      The result object can be modified.
     </para>
____________________________________________________________________________-->
     <para>
      结果对象可以被修改。
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that calling <literal>plpy.execute</literal> will cause the entire
      result set to be read into memory.  Only use that function when you are
      sure that the result set will be relatively small.  If you don't want to
      risk excessive memory usage when fetching large results,
      use <literal>plpy.cursor</literal> rather
      than <literal>plpy.execute</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      注意调用<literal>plpy.execute</literal>将会导致整个结果集合被读入到内存中。只有当确信结果集相对比较小时才应使用这个函数。在取得大型结果时，如果不想冒着耗尽内存的风险，应使用<literal>plpy.cursor</literal>而不是<literal>plpy.execute</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
____________________________________________________________________________-->
    <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
<!--==========================orignal english content==========================
    <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>max-rows</replaceable>]])</literal></term>
____________________________________________________________________________-->
    <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>max-rows</replaceable>]])</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <indexterm><primary>preparing a query</primary><secondary>in PL/Python</secondary></indexterm>
      <function>plpy.prepare</function> prepares the execution plan for a
      query.  It is called with a query string and a list of parameter types,
      if you have parameter references in the query.  For example:
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
      <literal>text</literal> is the type of the variable you will be passing
      for <literal>$1</literal>.  The second argument is optional if you don't
      want to pass any parameters to the query.
     </para>
____________________________________________________________________________-->
     <para>
      <indexterm><primary>准备一个查询</primary><secondary>in PL/Python</secondary></indexterm>
      <function>plpy.prepare</function>为一个查询准备执行计划。它的参数是一个查询串和一个参数类型列表（如果查询中有参数引用）。例如：
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
      <literal>text</literal>是要为<literal>$1</literal>传递的变量的类型。如果不想给查询传递任何参数，第二个参数就是可选的。
     </para>
<!--==========================orignal english content==========================
     <para>
      After preparing a statement, you use a variant of the
      function <function>plpy.execute</function> to run it:
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
      Pass the plan as the first argument (instead of the query string), and a
      list of values to substitute into the query as the second argument.  The
      second argument is optional if the query does not expect any parameters.
      The third argument is the optional row limit as before.
     </para>
____________________________________________________________________________-->
     <para>
      在准备好一个语句后，可以使用函数<function>plpy.execute</function>的一种变体来运行它：
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
      把计划作为第一个参数传递（而不是查询字符串），并且把要替换到查询中的值列表作为第二个参数传递。如果查询不需要任何参数，则第二个参数是可选的。和前面一样，第三个参数是可选的，它用来指定行数限制。
     </para>

<!--==========================orignal english content==========================
     <para>
      Alternatively, you can call the <function>execute</function> method on
      the plan object:
<programlisting>
rv = plan.execute(["name"], 5)
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      另外，你可以在计划对象上调用<function>execute</function>方法：
<programlisting>
rv = plan.execute(["name"], 5)
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Query parameters and result row fields are converted between PostgreSQL
      and Python data types as described in <xref linkend="plpython-data"/>.
     </para>
____________________________________________________________________________-->
     <para>
      查询参数以及结果行域会按照<xref linkend="plpython-data"/>中所述在 PostgreSQL 和 Python 数据类型之间转换。
     </para>

<!--==========================orignal english content==========================
     <para>
      When you prepare a plan using the PL/Python module it is automatically
      saved.  Read the SPI documentation (<xref linkend="spi"/>) for a
      description of what this means.  In order to make effective use of this
      across function calls one needs to use one of the persistent storage
      dictionaries <literal>SD</literal> or <literal>GD</literal> (see
      <xref linkend="plpython-sharing"/>). For example:
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpythonu;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      在使用 PL/Python 模块准备一个计划时，它会被自动保存。其含义可以阅读 SPI 文档（<xref linkend="spi"/>）。为了有效在函数调用之间利用这种特性，需要使用一种持久化存储字典<literal>SD</literal>或者<literal>GD</literal>（见<xref linkend="plpython-sharing"/>）。例如：
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # 函数的剩余部分
$$ LANGUAGE plpythonu;
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
____________________________________________________________________________-->
    <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
<!--==========================orignal english content==========================
    <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
____________________________________________________________________________-->
    <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>plpy.cursor</literal> function accepts the same arguments
      as <literal>plpy.execute</literal> (except for the row limit) and returns
      a cursor object, which allows you to process large result sets in smaller
      chunks.  As with <literal>plpy.execute</literal>, either a query string
      or a plan object along with a list of arguments can be used, or
      the <function>cursor</function> function can be called as a method of
      the plan object.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>plpy.cursor</literal>函数接受和<literal>plpy.execute</literal>相同的参数（行数限制除外）并且返回一个游标对象，它允许以较小的块来处理大型的结果集合。和<literal>plpy.execute</literal>一样（行数限制除外），既可以使用一个查询字符串，也可以使用带有参数列表的计划对象，或者<function>cursor</function>函数可以作为计划对象的一个方法来调用。
     </para>

<!--==========================orignal english content==========================
     <para>
      The cursor object provides a <literal>fetch</literal> method that accepts
      an integer parameter and returns a result object.  Each time you
      call <literal>fetch</literal>, the returned object will contain the next
      batch of rows, never larger than the parameter value.  Once all rows are
      exhausted, <literal>fetch</literal> starts returning an empty result
      object.  Cursor objects also provide an
      <ulink url="https://docs.python.org/library/stdtypes.html#iterator-types">iterator
      interface</ulink>, yielding one row at a time until all rows are
      exhausted.  Data fetched that way is not returned as result objects, but
      rather as dictionaries, each dictionary corresponding to a single result
      row.
     </para>
____________________________________________________________________________-->
     <para>
      游标对象提供了一种<literal>fetch</literal>方法，它接受一个整数参数并返回一个结果对象。每次调用<literal>fetch</literal>，返回的对象将包含下一批行，行数不会超过参数值。一旦所有的行都被消耗掉，<literal>fetch</literal>会开始返回一个空的结果对象。游标对象也提供一种<ulink url="https://docs.python.org/library/stdtypes.html#iterator-types">迭代器接口</ulink>，它一次得到一行直到所有行被耗尽。用这种方法取得的数据不会被作为结果对象返回，而是以字典的形式返回，每一个字典对应于一个结果行。
     </para>

<!--==========================orignal english content==========================
     <para>
      An example of two ways of processing data from a large table is:
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpythonu;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      从一个大型表中以上述两种方式处理数据的例子：
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpythonu;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Cursors are automatically disposed of.  But if you want to explicitly
      release all resources held by a cursor, use the <literal>close</literal>
      method.  Once closed, a cursor cannot be fetched from anymore.
     </para>
____________________________________________________________________________-->
     <para>
      游标会被自动丢弃掉。但是如果想要显式地释放游标所持有的所有资源，可使用<literal>close</literal>方法。一旦被关闭，就再也不能从游标中取得数据。
     </para>

     <tip>
<!--==========================orignal english content==========================
      <para>
        Do not confuse objects created by <literal>plpy.cursor</literal> with
        DB-API cursors as defined by
        the <ulink url="https://www.python.org/dev/peps/pep-0249/">Python
        Database API specification</ulink>.  They don't have anything in common
        except for the name.
      </para>
____________________________________________________________________________-->
      <para>
        不要把<literal>plpy.cursor</literal>创建的游标对象与<ulink url="https://www.python.org/dev/peps/pep-0249/">Python Database API specification</ulink>定义的 DB-API 游标弄混。除了名字之外，它们之间没有任何共同点。
      </para>
     </tip>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>

  <sect2 id="plpython-trapping">
<!--==========================orignal english content==========================
   <title>Trapping Errors</title>
____________________________________________________________________________-->
   <title>捕捉错误</title>

<!--==========================orignal english content==========================
   <para>
    Functions accessing the database might encounter errors, which
    will cause them to abort and raise an exception.  Both
    <function>plpy.execute</function> and
    <function>plpy.prepare</function> can raise an instance of a subclass of
    <literal>plpy.SPIError</literal>, which by default will terminate
    the function.  This error can be handled just like any other
    Python exception, by using the <literal>try/except</literal>
    construct.  For example:
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpythonu;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    访问数据库的函数可能会碰到错误，这将导致函数中止并且产生异常。<function>plpy.execute</function>和<function>plpy.prepare</function>都能产生<literal>plpy.SPIError</literal>的一个子类的实例，这默认将终止该函数。通过使用<literal>try/except</literal>结构，这种错误可以像其他 Python 异常一样被处理。例如：
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The actual class of the exception being raised corresponds to the
    specific condition that caused the error.  Refer
    to <xref linkend="errcodes-table"/> for a list of possible
    conditions.  The module
    <literal>plpy.spiexceptions</literal> defines an exception class
    for each <productname>PostgreSQL</productname> condition, deriving
    their names from the condition name.  For
    instance, <literal>division_by_zero</literal>
    becomes <literal>DivisionByZero</literal>, <literal>unique_violation</literal>
    becomes <literal>UniqueViolation</literal>, <literal>fdw_error</literal>
    becomes <literal>FdwError</literal>, and so on.  Each of these
    exception classes inherits from <literal>SPIError</literal>.  This
    separation makes it easier to handle specific errors, for
    instance:
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;
</programlisting>
    Note that because all exceptions from
    the <literal>plpy.spiexceptions</literal> module inherit
    from <literal>SPIError</literal>, an <literal>except</literal>
    clause handling it will catch any database access error.
   </para>
____________________________________________________________________________-->
   <para>
    产生的异常的实际类对应于特定的导致该错误的情况。可能的情况列表请参考<xref linkend="errcodes-table"/>。模块<literal>plpy.spiexceptions</literal>为每一种<productname>PostgreSQL</productname>情况定义了一个异常类，并且根据情况的名称命名。例如：<literal>division_by_zero</literal>变成<literal>DivisionByZero</literal>，<literal>unique_violation</literal>变成<literal>UniqueViolation</literal>，<literal>fdw_error</literal>变成<literal>FdwError</literal>，等等等等。这些异常类的每一种都是从<literal>SPIError</literal>继承而来。这种分离让处理特定错误更加容易，例如：
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;
</programlisting>
    注意因为所有来自于<literal>plpy.spiexceptions</literal>模块的异常都继承自<literal>SPIError</literal>，一个处理它的<literal>except</literal>子句将捕捉任何数据库访问错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    As an alternative way of handling different error conditions, you
    can catch the <literal>SPIError</literal> exception and determine
    the specific error condition inside the <literal>except</literal>
    block by looking at the <literal>sqlstate</literal> attribute of
    the exception object.  This attribute is a string value containing
    the <quote>SQLSTATE</quote> error code.  This approach provides
    approximately the same functionality
   </para>
____________________________________________________________________________-->
   <para>
    作为另一种处理不同错误情况的方法，可以捕捉<literal>SPIError</literal>异常并且在<literal>except</literal>块中通过查看异常对象的<literal>sqlstate</literal>属性来判断错误情况。这种属性是包含着<quote>SQLSTATE</quote>错误代码的一个字符串值。这种方法提供了近乎相同的功能
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-subtransaction">
<!--==========================orignal english content==========================
  <title>Explicit Subtransactions</title>
____________________________________________________________________________-->
  <title>显式子事务</title>

<!--==========================orignal english content==========================
  <para>
   Recovering from errors caused by database access as described in
   <xref linkend="plpython-trapping"/> can lead to an undesirable
   situation where some operations succeed before one of them fails,
   and after recovering from that error the data is left in an
   inconsistent state.  PL/Python offers a solution to this problem in
   the form of explicit subtransactions.
  </para>
____________________________________________________________________________-->
  <para>
   按<xref linkend="plpython-trapping"/>中所述的从数据库访问导致的错误中恢复可能导致不好的情况：某些操作在其中一个操作失败之前已经成功，并且在从错误中恢复后这些操作的数据形成了一种不一致的状态。PL/Python 通过显式子事务的形式为这种问题提供了一套解决方案。
  </para>

  <sect2>
<!--==========================orignal english content==========================
   <title>Subtransaction Context Managers</title>
____________________________________________________________________________-->
   <title>子事务上下文管理器</title>

<!--==========================orignal english content==========================
   <para>
    Consider a function that implements a transfer between two
    accounts:
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
    If the second <literal>UPDATE</literal> statement results in an
    exception being raised, this function will report the error, but
    the result of the first <literal>UPDATE</literal> will
    nevertheless be committed.  In other words, the funds will be
    withdrawn from Joe's account, but will not be transferred to
    Mary's account.
   </para>
____________________________________________________________________________-->
   <para>
    考虑一个实现在两个账户间进行转账的函数：
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
    如果第二个<literal>UPDATE</literal>语句导致产生一个异常，这个函数将会报告该错误，但是第一个<literal>UPDATE</literal>的结果却不会被提交。换句话说，资金将从 Joe 的账户中收回，而不会转移到 Mary 的账户中。
   </para>

<!--==========================orignal english content==========================
   <para>
    To avoid such issues, you can wrap your
    <literal>plpy.execute</literal> calls in an explicit
    subtransaction.  The <literal>plpy</literal> module provides a
    helper object to manage explicit subtransactions that gets created
    with the <literal>plpy.subtransaction()</literal> function.
    Objects created by this function implement the
    <ulink url="https://docs.python.org/library/stdtypes.html#context-manager-types">
    context manager interface</ulink>.  Using explicit subtransactions
    we can rewrite our function as:
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
    Note that the use of <literal>try/catch</literal> is still
    required.  Otherwise the exception would propagate to the top of
    the Python stack and would cause the whole function to abort with
    a <productname>PostgreSQL</productname> error, so that the
    <literal>operations</literal> table would not have any row
    inserted into it.  The subtransaction context manager does not
    trap errors, it only assures that all database operations executed
    inside its scope will be atomically committed or rolled back.  A
    rollback of the subtransaction block occurs on any kind of
    exception exit, not only ones caused by errors originating from
    database access.  A regular Python exception raised inside an
    explicit subtransaction block would also cause the subtransaction
    to be rolled back.
   </para>
____________________________________________________________________________-->
   <para>
    为了避免这类问题，可以把<literal>plpy.execute</literal>包裹在显式子事务中。<literal>plpy</literal>模块提供了一种助手对象来管理用<literal>plpy.subtransaction()</literal>函数创建的显式子事务。这个函数创建的对象实现了<ulink url="https://docs.python.org/library/stdtypes.html#context-manager-types">上下文管理器接口</ulink>。通过使用显式子事务，我们可以把函数写成：
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
    注意仍需使用<literal>try/catch</literal>。否则异常会传播到 Python 栈的顶层并且将导致整个函数以一个<productname>PostgreSQL</productname>错误中止，这样不会有任何行被插入到<literal>operations</literal>表。子事务上下文管理器不会捕捉错误，它只确保在其范围内执行的所有数据库操作将被原子性地提交或者回滚。在任何类型的异常（并非只是数据库访问产生的错误）退出时，会发生子事务块回滚。在显式子事务块内部产生的常规 Python 异常也会导致子事务被回滚。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Older Python Versions</title>
____________________________________________________________________________-->
   <title>更旧的 Python 版本</title>

<!--==========================orignal english content==========================
   <para>
    Context managers syntax using the <literal>with</literal> keyword
    is available by default in Python 2.6.  If using PL/Python with an
    older Python version, it is still possible to use explicit
    subtransactions, although not as transparently.  You can call the
    subtransaction manager's <literal>__enter__</literal> and
    <literal>__exit__</literal> functions using the
    <literal>enter</literal> and <literal>exit</literal> convenience
    aliases.  The example function that transfers funds could be
    written as:
<programlisting>
CREATE FUNCTION transfer_funds_old() RETURNS void AS $$
try:
    subxact = plpy.subtransaction()
    subxact.enter()
    try:
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
    except:
        import sys
        subxact.exit(*sys.exc_info())
        raise
    else:
        subxact.exit(None, None, None)
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"

plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    Python 2.6 中默认可用的是使用<literal>with</literal>关键词的上下文管理器语法。如果 PL/Python 用的是一种较老的 Python 版本，仍然可以使用显式子事务，尽管不是那么透明。你可以使用别名<literal>enter</literal>和<literal>exit</literal>调用子事务管理器的<literal>__enter__</literal>和<literal>__exit__</literal>函数。转移资金的例子函数可以写成：
<programlisting>
CREATE FUNCTION transfer_funds_old() RETURNS void AS $$
try:
    subxact = plpy.subtransaction()
    subxact.enter()
    try:
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
    except:
        import sys
        subxact.exit(*sys.exc_info())
        raise
    else:
        subxact.exit(None, None, None)
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"

plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Although context managers were implemented in Python 2.5, to use
     the <literal>with</literal> syntax in that version you need to
     use a <ulink
     url="https://docs.python.org/release/2.5/ref/future.html">future
     statement</ulink>.  Because of implementation details, however,
     you cannot use future statements in PL/Python functions.
    </para>
____________________________________________________________________________-->
    <para>
     尽管 Python 2.5 中实现了上下文管理器，要在那个版本中使用<literal>with</literal>语法，需要使用一个<ulink url="https://docs.python.org/release/2.5/ref/future.html">future 语句</ulink>。不过，由于实现细节的原因，不能在 PL/Python 函数中使用 future 语句。
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="plpython-transactions">
<!--==========================orignal english content==========================
  <title>Transaction Management</title>
____________________________________________________________________________-->
  <title>事务管理</title>

<!--==========================orignal english content==========================
  <para>
   In a procedure called from the top level or an anonymous code block
   (<command>DO</command> command) called from the top level it is possible to
   control transactions.  To commit the current transaction, call
   <literal>plpy.commit()</literal>.  To roll back the current transaction,
   call <literal>plpy.rollback()</literal>.  (Note that it is not possible to
   run the SQL commands <command>COMMIT</command> or
   <command>ROLLBACK</command> via <function>plpy.execute</function> or
   similar.  It has to be done using these functions.)  After a transaction is
   ended, a new transaction is automatically started, so there is no separate
   function for that.
  </para>
____________________________________________________________________________-->
  <para>
   在从顶层调用的过程中或者从顶层调用的匿名代码块（<command>DO</command>命令）中，可以控制事务。要提交当前的事务，可调用<literal>plpy.commit()</literal>。要回滚当前事务，可调用<literal>plpy.rollback()</literal>（注意不能通过<function>plpy.execute</function>或类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这类工作必须用这些函数完成）。在事务结束以后，一个新的事务会自动开始，因此没有独立的函数用来开始新事务。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS $$
for i in range(0, 10):
    plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
    if i % 2 == 0:
        plpy.commit()
    else:
        plpy.rollback()
$$;

CALL transaction_test1();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS $$
for i in range(0, 10):
    plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
    if i % 2 == 0:
        plpy.commit()
    else:
        plpy.rollback()
$$;

CALL transaction_test1();
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Transactions cannot be ended when an explicit subtransaction is active.
  </para>
____________________________________________________________________________-->
  <para>
   当一个显式的子事务处于活跃状态时，事务不能被结束。
  </para>
 </sect1>

 <sect1 id="plpython-util">
<!--==========================orignal english content==========================
  <title>Utility Functions</title>
____________________________________________________________________________-->
  <title>实用函数</title>
<!--==========================orignal english content==========================
  <para>
   The <literal>plpy</literal> module also provides the functions
   <simplelist>
    <member><literal>plpy.debug(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.log(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.info(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.notice(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.warning(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.error(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.fatal(<replaceable>msg, **kwargs</replaceable>)</literal></member>
   </simplelist>
   <indexterm><primary>elog</primary><secondary>in PL/Python</secondary></indexterm>
   <function>plpy.error</function> and <function>plpy.fatal</function>
   actually raise a Python exception which, if uncaught, propagates out to
   the calling query, causing the current transaction or subtransaction to
   be aborted.  <literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal> and
   <literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal> are
   equivalent to calling <literal>plpy.error(<replaceable>msg</replaceable>)</literal> and
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>, respectively but
   the <literal>raise</literal> form does not allow passing keyword arguments.
   The other functions only generate messages of different priority levels.
   Whether messages of a particular priority are reported to the client,
   written to the server log, or both is controlled by the
   <xref linkend="guc-log-min-messages"/> and
   <xref linkend="guc-client-min-messages"/> configuration
   variables. See <xref linkend="runtime-config"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>plpy</literal>模块也提供了函数
   <simplelist>
    <member><literal>plpy.debug(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.log(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.info(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.notice(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.warning(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.error(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.fatal(<replaceable>msg, **kwargs</replaceable>)</literal></member>
   </simplelist>
   <indexterm><primary>elog</primary><secondary>in PL/Python</secondary></indexterm>
   <function>plpy.error</function>和<function>plpy.fatal</function>实际上会产生一个 Python 异常（如果没被捕捉），它会被传播到调用查询中导致当前事务或者子事务被中止。<literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal>和<literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal>分别等效于调用<literal>plpy.error(<replaceable>msg</replaceable>)</literal>和<literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>，不过<literal>raise</literal>形式不允许传递关键词参数。其他函数只生成不同优先级的消息。一个特定优先级的消息是被报告给客户端、写入服务器日志还是两者都做，由<xref linkend="guc-log-min-messages"/>和<xref linkend="guc-client-min-messages"/>配置变量控制。详见<xref linkend="runtime-config"/>。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   The <replaceable>msg</replaceable> argument is given as a positional argument.  For
   backward compatibility, more than one positional argument can be given. In
   that case, the string representation of the tuple of positional arguments
   becomes the message reported to the client.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable>msg</replaceable>参数被给定位一个位置参数。为了向后兼容，可以给出多于一个位置参数。在那种情况下， 位置参数形成的元组的字符串表达将会变成报告给客户端的消息。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following keyword-only arguments are accepted:
   <simplelist>
    <member><literal>detail</literal></member>
    <member><literal>hint</literal></member>
    <member><literal>sqlstate</literal></member>
    <member><literal>schema_name</literal></member>
    <member><literal>table_name</literal></member>
    <member><literal>column_name</literal></member>
    <member><literal>datatype_name</literal></member>
    <member><literal>constraint_name</literal></member>
   </simplelist>
   The string representation of the objects passed as keyword-only arguments
   is used to enrich the messages reported to the client. For example:

<programlisting>
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
           detail="some info about exception",
           hint="hint for users")
$$ LANGUAGE plpythonu;

=# SELECT raise_custom_exception();
ERROR:  plpy.Error: custom exception message
DETAIL:  some info about exception
HINT:  hint for users
CONTEXT:  Traceback (most recent call last):
  PL/Python function "raise_custom_exception", line 4, in &lt;module&gt;
    hint="hint for users")
PL/Python function "raise_custom_exception"
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下列 keyword-only 参数会被接受：
   <simplelist>
    <member><literal>detail</literal></member>
    <member><literal>hint</literal></member>
    <member><literal>sqlstate</literal></member>
    <member><literal>schema_name</literal></member>
    <member><literal>table_name</literal></member>
    <member><literal>column_name</literal></member>
    <member><literal>datatype_name</literal></member>
    <member><literal>constraint_name</literal></member>
   </simplelist>
   作为 keyword-only 参数传递的对象的字符串表达可以用来丰富报告给客户端的消息。例如：

<programlisting>
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
           detail="some info about exception",
           hint="hint for users")
$$ LANGUAGE plpythonu;

=# SELECT raise_custom_exception();
ERROR:  plpy.Error: custom exception message
DETAIL:  some info about exception
HINT:  hint for users
CONTEXT:  Traceback (most recent call last):
  PL/Python function "raise_custom_exception", line 4, in &lt;module&gt;
    hint="hint for users")
PL/Python function "raise_custom_exception"
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Another set of utility functions are
   <literal>plpy.quote_literal(<replaceable>string</replaceable>)</literal>,
   <literal>plpy.quote_nullable(<replaceable>string</replaceable>)</literal>, and
   <literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>.  They
   are equivalent to the built-in quoting functions described in <xref
   linkend="functions-string"/>.  They are useful when constructing
   ad-hoc queries.  A PL/Python equivalent of dynamic SQL from <xref
   linkend="plpgsql-quote-literal-example"/> would be:
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   另一组工具函数是<literal>plpy.quote_literal(<replaceable>string</replaceable>)</literal>、<literal>plpy.quote_nullable(<replaceable>string</replaceable>)</literal>以及<literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>。它们等效于<xref linkend="functions-string"/>中描述的内建引用函数。在构建临时查询时它们能派上用场。<xref linkend="plpgsql-quote-literal-example"/>中动态 SQL 的 PL/Python 等效体是：
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-envar">
<!--==========================orignal english content==========================
  <title>Environment Variables</title>
____________________________________________________________________________-->
  <title>环境变量</title>

<!--==========================orignal english content==========================
  <para>
   Some of the environment variables that are accepted by the Python
   interpreter can also be used to affect PL/Python behavior.  They
   would need to be set in the environment of the main PostgreSQL
   server process, for example in a start script.  The available
   environment variables depend on the version of Python; see the
   Python documentation for details.  At the time of this writing, the
   following environment variables have an affect on PL/Python,
   assuming an adequate Python version:
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

   (It appears to be a Python implementation detail beyond the control
   of PL/Python that some of the environment variables listed on
   the <command>python</command> man page are only effective in a
   command-line interpreter and not an embedded Python interpreter.)
  </para>
____________________________________________________________________________-->
  <para>
   某些 Python 解释器接受的环境变量也能被用来影响 PL/Python 行为。它们需要在主 PostgreSQL 服务器进程的环境中设置，例如在一个启动脚本中设置。可用的环境变量取决于 Python 的版本，细节可见 Python 文档。在编写这份文档时，下面的环境变量可以对 PL/Python 产生影响（假定有一个合适的 Python 版本）：
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

   （Python 的实现细节似乎超出了 PL/Python 的控制范围，某些列在<command>python</command>手册页上的环境变量只在命令行解释器中有效，但在嵌入式 Python 解释器中无效）。
  </para>
 </sect1>
</chapter>
