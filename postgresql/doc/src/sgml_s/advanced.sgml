<!-- doc/src/sgml/advanced.sgml -->

 <chapter id="tutorial-advanced">
<!--==========================orignal english content==========================
  <title>Advanced Features</title>
____________________________________________________________________________-->
  <title>高级特性</title>

  <sect1 id="tutorial-advanced-intro">
<!--==========================orignal english content==========================
   <title>Introduction</title>
____________________________________________________________________________-->
   <title>简介</title>

<!--==========================orignal english content==========================
   <para>
    In the previous chapter we have covered the basics of using
    <acronym>SQL</acronym> to store and access your data in
    <productname>PostgreSQL</productname>.  We will now discuss some
    more advanced features of <acronym>SQL</acronym> that simplify
    management and prevent loss or corruption of your data.  Finally,
    we will look at some <productname>PostgreSQL</productname>
    extensions.
   </para>
____________________________________________________________________________-->
   <para>
    在之前的章节里我们已经涉及了使用<acronym>SQL</acronym>在<productname>PostgreSQL</productname>中存储和访问数据的基础知识。现在我们将要讨论<acronym>SQL</acronym>中一些更高级的特性，这些特性有助于简化管理和防止数据丢失或损坏。最后，我们还将介绍一些<productname>PostgreSQL</productname>扩展。
   </para>

<!--==========================orignal english content==========================
   <para>
    This chapter will on occasion refer to examples found in <xref
    linkend="tutorial-sql"> to change or improve them, so it will be
    useful to have read that chapter.  Some examples from
    this chapter can also be found in
    <filename>advanced.sql</filename> in the tutorial directory.  This
    file also contains some sample data to load, which is not
    repeated here.  (Refer to <xref linkend="tutorial-sql-intro"> for
    how to use the file.)
   </para>
____________________________________________________________________________-->
   <para>
    本章有时将引用<xref
    linkend="tutorial-sql"/>中的例子并对其进行改变或改进以便于阅读本章。本章中的某些例子可以在教程目录的<filename>advanced.sql</filename>文件中找到。该文件也包含一些样例数据，在这里就不在赘述（查看<xref linkend="tutorial-sql-intro"/>了解如何使用该文件）。
   </para>
  </sect1>


  <sect1 id="tutorial-views">
<!--==========================orignal english content==========================
   <title>Views</title>
____________________________________________________________________________-->
   <title>视图</title>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-views">
    <primary>view</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-views">
    <primary>view</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Refer back to the queries in <xref linkend="tutorial-join">.
    Suppose the combined listing of weather records and city location
    is of particular interest to your application, but you do not want
    to type the query each time you need it.  You can create a
    <firstterm>view</firstterm> over the query, which gives a name to
    the query that you can refer to like an ordinary table:

<programlisting>
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    回想一下<xref linkend="tutorial-join"/>中的查询。假设天气记录和城市为止的组合列表对我们的应用有用，但我们又不想每次需要使用它时都敲入整个查询。我们可以在该查询上创建一个<firstterm>视图</firstterm>，这会给该查询一个名字，我们可以像使用一个普通表一样来使用它：

<programlisting>
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Making liberal use of views is a key aspect of good SQL database
    design.  Views allow you to encapsulate the details of the
    structure of your tables, which might change as your application
    evolves, behind consistent interfaces.
   </para>
____________________________________________________________________________-->
   <para>
    对视图的使用是成就一个好的SQL数据库设计的关键方面。视图允许用户通过始终如一的接口封装表的结构细节，这样可以避免表结构随着应用的进化而改变。
   </para>

<!--==========================orignal english content==========================
   <para>
    Views can be used in almost any place a real table can be used.
    Building views upon other views is not uncommon.
   </para>
____________________________________________________________________________-->
   <para>
    视图几乎可以用在任何可以使用表的地方。在其他视图基础上创建视图也并不少见。
   </para>
  </sect1>


  <sect1 id="tutorial-fk">
<!--==========================orignal english content==========================
   <title>Foreign Keys</title>
____________________________________________________________________________-->
   <title>外键</title>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-fk">
    <primary>foreign key</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-fk">
    <primary>foreign key</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-fk">
    <primary>referential integrity</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-fk">
    <primary>referential integrity</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Recall the <classname>weather</classname> and
    <classname>cities</classname> tables from <xref
    linkend="tutorial-sql">.  Consider the following problem:  You
    want to make sure that no one can insert rows in the
    <classname>weather</classname> table that do not have a matching
    entry in the <classname>cities</classname> table.  This is called
    maintaining the <firstterm>referential integrity</firstterm> of
    your data.  In simplistic database systems this would be
    implemented (if at all) by first looking at the
    <classname>cities</classname> table to check if a matching record
    exists, and then inserting or rejecting the new
    <classname>weather</classname> records.  This approach has a
    number of problems and is very inconvenient, so
    <productname>PostgreSQL</productname> can do this for you.
   </para>
____________________________________________________________________________-->
   <para>
    回想第2章中的<classname>weather</classname>和<classname>cities</classname>表。考虑以下问题：我们希望确保在<classname>cities</classname>表中有相应项之前任何人都不能在<classname>weather</classname>表中插入行。这叫做维持数据的<firstterm>引用完整性</firstterm>。在过分简化的数据库系统中，可以通过先检查<classname>cities</classname>表中是否有匹配的记录存在，然后决定应该接受还是拒绝即将插入<classname>weather</classname>表的行。这种方法有一些问题且并不方便，于是<productname>PostgreSQL</productname>可以为我们来解决：
   </para>

<!--==========================orignal english content==========================
   <para>
    The new declaration of the tables would look like this:

<programlisting>
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</programlisting>

    Now try inserting an invalid record:

<programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>

<screen>
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    新的表定义如下：

<programlisting>
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</programlisting>

    现在尝试插入一个非法的记录：

<programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>

<screen>
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    The behavior of foreign keys can be finely tuned to your
    application.  We will not go beyond this simple example in this
    tutorial, but just refer you to <xref linkend="ddl">
    for more information.  Making correct use of
    foreign keys will definitely improve the quality of your database
    applications, so you are strongly encouraged to learn about them.
   </para>
____________________________________________________________________________-->
   <para>
    外键的行为可以很好地根据应用来调整。我们不会在这个教程里更深入地介绍，读者可以参考<xref linkend="ddl"/>中的信息。正确使用外键无疑会提高数据库应用的质量，因此强烈建议用户学会如何使用它们。
   </para>
  </sect1>


  <sect1 id="tutorial-transactions">
<!--==========================orignal english content==========================
   <title>Transactions</title>
____________________________________________________________________________-->
   <title>事务</title>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-transactions">
    <primary>transaction</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-transactions">
    <primary>transaction</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Transactions</> are a fundamental concept of all database
    systems.  The essential point of a transaction is that it bundles
    multiple steps into a single, all-or-nothing operation.  The intermediate
    states between the steps are not visible to other concurrent transactions,
    and if some failure occurs that prevents the transaction from completing,
    then none of the steps affect the database at all.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>事务</firstterm>是所有数据库系统的基础概念。事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果有某些错误发生导致事务不能完成，则其中任何一个步骤都不会对数据库造成影响。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, consider a bank database that contains balances for various
    customer accounts, as well as total deposit balances for branches.
    Suppose that we want to record a payment of $100.00 from Alice's account
    to Bob's account.  Simplifying outrageously, the SQL commands for this
    might look like:

<programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，考虑一个保存着多个客户账户余额和支行总存款额的银行数据库。假设我们希望记录一笔从Alice的账户到Bob的账户的额度为100.00美元的转账。在最大程度地简化后，涉及到的SQL命令是：

<programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The details of these commands are not important here; the important
    point is that there are several separate updates involved to accomplish
    this rather simple operation.  Our bank's officers will want to be
    assured that either all these updates happen, or none of them happen.
    It would certainly not do for a system failure to result in Bob
    receiving $100.00 that was not debited from Alice.  Nor would Alice long
    remain a happy customer if she was debited without Bob being credited.
    We need a guarantee that if something goes wrong partway through the
    operation, none of the steps executed so far will take effect.  Grouping
    the updates into a <firstterm>transaction</> gives us this guarantee.
    A transaction is said to be <firstterm>atomic</>: from the point of
    view of other transactions, it either happens completely or not at all.
   </para>
____________________________________________________________________________-->
   <para>
    这些命令的细节在这里并不重要，关键点是为了完成这个相当简单的操作涉及到多个独立的更新。我们的银行职员希望确保这些更新要么全部发生，或者全部不发生。当然不能发生因为系统错误导致Bob收到100美元而Alice并未被扣款的情况。Alice当然也不希望自己被扣款而Bob没有收到钱。我们需要一种保障，当操作中途某些错误发生时已经执行的步骤不会产生效果。将这些更新组织成一个<firstterm>事务</firstterm>就可以给我们这种保障。一个事务被称为是<firstterm>原子的</firstterm>：从其他事务的角度来看，它要么整个发生要么完全不发生。
   </para>

<!--==========================orignal english content==========================
   <para>
    We also want a
    guarantee that once a transaction is completed and acknowledged by
    the database system, it has indeed been permanently recorded
    and won't be lost even if a crash ensues shortly thereafter.
    For example, if we are recording a cash withdrawal by Bob,
    we do not want any chance that the debit to his account will
    disappear in a crash just after he walks out the bank door.
    A transactional database guarantees that all the updates made by
    a transaction are logged in permanent storage (i.e., on disk) before
    the transaction is reported complete.
   </para>
____________________________________________________________________________-->
   <para>
    我们同样希望能保证一旦一个事务被数据库系统完成并认可，它就被永久地记录下来且即便其后发生崩溃也不会被丢失。例如，如果我们正在记录Bob的一次现金提款，我们当然不希望他刚走出银行大门，对他账户的扣款就消失。一个事务型数据库保证一个事务在被报告为完成之前它所做的所有更新都被记录在持久存储（即磁盘）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another important property of transactional databases is closely
    related to the notion of atomic updates: when multiple transactions
    are running concurrently, each one should not be able to see the
    incomplete changes made by others.  For example, if one transaction
    is busy totalling all the branch balances, it would not do for it
    to include the debit from Alice's branch but not the credit to
    Bob's branch, nor vice versa.  So transactions must be all-or-nothing
    not only in terms of their permanent effect on the database, but
    also in terms of their visibility as they happen.  The updates made
    so far by an open transaction are invisible to other transactions
    until the transaction completes, whereupon all the updates become
    visible simultaneously.
   </para>
____________________________________________________________________________-->
   <para>
    事务型数据库的另一个重要性质与原子更新的概念紧密相关：当多个事务并发运行时，每一个都不能看到其他事务未完成的修改。例如，如果一个事务正忙着总计所有支行的余额，它不会只包括Alice的支行的扣款而不包括Bob的支行的存款，或者反之。所以事务的全做或全不做并不只体现在它们对数据库的持久影响，也体现在它们发生时的可见性。一个事务所做的更新在它完成之前对于其他事务是不可见的，而之后所有的更新将同时变得可见。
   </para>

<!--==========================orignal english content==========================
   <para>
    In <productname>PostgreSQL</>, a transaction is set up by surrounding
    the SQL commands of the transaction with
    <command>BEGIN</> and <command>COMMIT</> commands.  So our banking
    transaction would actually look like:

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-&minus; etc etc
COMMIT;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中，开启一个事务需要将SQL命令用<command>BEGIN</command>和<command>COMMIT</command>命令包围起来。因此我们的银行事务看起来会是这样：

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- etc etc
COMMIT;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If, partway through the transaction, we decide we do not want to
    commit (perhaps we just noticed that Alice's balance went negative),
    we can issue the command <command>ROLLBACK</> instead of
    <command>COMMIT</>, and all our updates so far will be canceled.
   </para>
____________________________________________________________________________-->
   <para>
    如果，在事务执行中我们并不想提交（或许是我们注意到Alice的余额不足），我们可以发出<command>ROLLBACK</command>命令而不是<command>COMMIT</command>命令，这样所有目前的更新将会被取消。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</> actually treats every SQL statement as being
    executed within a transaction.  If you do not issue a <command>BEGIN</>
    command,
    then each individual statement has an implicit <command>BEGIN</> and
    (if successful) <command>COMMIT</> wrapped around it.  A group of
    statements surrounded by <command>BEGIN</> and <command>COMMIT</>
    is sometimes called a <firstterm>transaction block</>.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>实际上将每一个SQL语句都作为一个事务来执行。如果我们没有发出<command>BEGIN</command>命令，则每个独立的语句都会被加上一个隐式的<command>BEGIN</command>以及（如果成功）<command>COMMIT</command>来包围它。一组被<command>BEGIN</command>和<command>COMMIT</command>包围的语句也被称为一个<firstterm>事务块</firstterm>。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Some client libraries issue <command>BEGIN</> and <command>COMMIT</>
     commands automatically, so that you might get the effect of transaction
     blocks without asking.  Check the documentation for the interface
     you are using.
    </para>
____________________________________________________________________________-->
    <para>
     某些客户端库会自动发出<command>BEGIN</command>和<command>COMMIT</command>命令，因此我们可能会在不被告知的情况下得到事务块的效果。具体请查看所使用的接口文档。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    It's possible to control the statements in a transaction in a more
    granular fashion through the use of <firstterm>savepoints</>.  Savepoints
    allow you to selectively discard parts of the transaction, while
    committing the rest.  After defining a savepoint with
    <command>SAVEPOINT</>, you can if needed roll back to the savepoint
    with <command>ROLLBACK TO</>.  All the transaction's database changes
    between defining the savepoint and rolling back to it are discarded, but
    changes earlier than the savepoint are kept.
   </para>
____________________________________________________________________________-->
   <para>
    也可以利用<firstterm>保存点</firstterm>来以更细的粒度来控制一个事务中的语句。保存点允许我们有选择性地放弃事务的一部分而提交剩下的部分。在使用<command>SAVEPOINT</command>定义一个保存点后，我们可以在必要时利用<command>ROLLBACK TO</command>回滚到该保存点。该事务中位于保存点和回滚点之间的数据库修改都会被放弃，但是早于该保存点的修改则会被保存。
   </para>

<!--==========================orignal english content==========================
   <para>
    After rolling back to a savepoint, it continues to be defined, so you can
    roll back to it several times.  Conversely, if you are sure you won't need
    to roll back to a particular savepoint again, it can be released, so the
    system can free some resources.  Keep in mind that either releasing or
    rolling back to a savepoint
    will automatically release all savepoints that were defined after it.
   </para>
____________________________________________________________________________-->
   <para>
    在回滚到保存点之后，它的定义依然存在，因此我们可以多次回滚到它。反过来，如果确定不再需要回滚到特定的保存点，它可以被释放以便系统释放一些资源。记住不管是释放保存点还是回滚到保存点都会释放定义在该保存点之后的所有其他保存点。
   </para>

<!--==========================orignal english content==========================
   <para>
    All this is happening within the transaction block, so none of it
    is visible to other database sessions.  When and if you commit the
    transaction block, the committed actions become visible as a unit
    to other sessions, while the rolled-back actions never become visible
    at all.
   </para>
____________________________________________________________________________-->
   <para>
    所有这些都发生在一个事务块内，因此这些对于其他数据库会话都不可见。当提交整个事务块时，被提交的动作将作为一个单元变得对其他会话可见，而被回滚的动作则永远不会变得可见。
   </para>

<!--==========================orignal english content==========================
   <para>
    Remembering the bank database, suppose we debit $100.00 from Alice's
    account, and credit Bob's account, only to find later that we should
    have credited Wally's account.  We could do it using savepoints like
    this:

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-&minus; oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    记住那个银行数据库，假设我们从Alice的账户扣款100美元，然后存款到Bob的账户，结果直到最后才发现我们应该存到Wally的账户。我们可以通过使用保存点来做这件事：

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    This example is, of course, oversimplified, but there's a lot of control
    possible in a transaction block through the use of savepoints.
    Moreover, <command>ROLLBACK TO</> is the only way to regain control of a
    transaction block that was put in aborted state by the
    system due to an error, short of rolling it back completely and starting
    again.
   </para>
____________________________________________________________________________-->
   <para>
    当然，这个例子是被过度简化的，但是在一个事务块中使用保存点存在很多种控制可能性。此外，<command>ROLLBACK TO</command>是唯一的途径来重新控制一个由于错误被系统置为中断状态的事务块，而不是完全回滚它并重新启动。
   </para>

  </sect1>


  <sect1 id="tutorial-window">
<!--==========================orignal english content==========================
   <title>Window Functions</title>
____________________________________________________________________________-->
   <title>窗口函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-window">
    <primary>window function</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-window">
    <primary>window function</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>window function</> performs a calculation across a set of
    table rows that are somehow related to the current row.  This is comparable
    to the type of calculation that can be done with an aggregate function.
    However, window functions do not cause rows to become grouped into a single
    output row like non-window aggregate calls would.  Instead, the
    rows retain their separate identities.  Behind the scenes, the window
    function is able to access more than just the current row of the query
    result.
   </para>
____________________________________________________________________________-->
   <para>
    一个<firstterm>窗口函数</firstterm>在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is an example that shows how to compare each employee's salary
    with the average salary in his or her department:

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg          
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

    The first three output columns come directly from the table
    <structname>empsalary</>, and there is one output row for each row in the
    table.  The fourth column represents an average taken across all the table
    rows that have the same <structfield>depname</> value as the current row.
    (This actually is the same function as the non-window <function>avg</>
    aggregate, but the <literal>OVER</> clause causes it to be
    treated as a window function and computed across the window frame.)
   </para>
____________________________________________________________________________-->
   <para>
    下面是一个例子用于展示如何将每一个员工的薪水与他/她所在部门的平均薪水进行比较：

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

    最开始的三个输出列直接来自于表<structname>empsalary</structname>，并且表中每一行都有一个输出行。第四列表示对与当前行具有相同<structfield>depname</structfield>值的所有表行取得平均值（这实际和非窗口<function>avg</function>聚集函数是相同的函数，但是<literal>OVER</literal>子句使得它被当做一个窗口函数处理并在一个合适的窗口帧上计算。）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A window function call always contains an <literal>OVER</> clause
    directly following the window function's name and argument(s).  This is what
    syntactically distinguishes it from a normal function or non-window
    aggregate.  The <literal>OVER</> clause determines exactly how the
    rows of the query are split up for processing by the window function.
    The <literal>PARTITION BY</> clause within <literal>OVER</> specifies
    divides the rows into groups, or partitions, that share the same
    values of the <literal>PARTITION BY</> expression(s).  For each row,
    the window function is computed across the rows that fall into the
    same partition as the current row.
   </para>
____________________________________________________________________________-->
   <para>
    一个窗口函数调用总是包含一个直接跟在窗口函数名及其参数之后的<literal>OVER</literal>子句。这使得它从句法上和一个普通函数或非窗口函数区分开来。<literal>OVER</literal>子句决定究竟查询中的哪些行被分离出来由窗口函数处理。<literal>OVER</literal>子句中的<literal>PARTITION BY</literal>子句指定了将具有相同<literal>PARTITION BY</literal>表达式值的行分到组或者分区。对于每一行，窗口函数都会在当前行同一分区的行上进行计算。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can also control the order in which rows are processed by
    window functions using <literal>ORDER BY</> within <literal>OVER</>.
    (The window <literal>ORDER BY</> does not even have to match the
    order in which the rows are output.)  Here is an example:

<programlisting>
SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank 
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

    As shown here, the <function>rank</> function produces a numerical rank
    for each distinct <literal>ORDER BY</> value in the current row's
    partition, using the order defined by the <literal>ORDER BY</> clause.
    <function>rank</> needs no explicit parameter, because its behavior
    is entirely determined by the <literal>OVER</> clause.
   </para>
____________________________________________________________________________-->
   <para>
    我们可以通过<literal>OVER</literal>上的<literal>ORDER BY</literal>控制窗口函数处理行的顺序（窗口的<literal>ORDER BY</literal>并不一定要符合行输出的顺序。）。下面是一个例子：

<programlisting>
SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

    如上所示，<function>rank</function>函数在当前行的分区内按照<literal>ORDER BY</literal>子句的顺序为每一个可区分的<literal>ORDER BY</literal>值产生了一个数字等级。<function>rank</function>不需要显式的参数，因为它的行为完全决定于<literal>OVER</literal>子句。
   </para>

<!--==========================orignal english content==========================
   <para>
    The rows considered by a window function are those of the <quote>virtual
    table</> produced by the query's <literal>FROM</> clause as filtered by its
    <literal>WHERE</>, <literal>GROUP BY</>, and <literal>HAVING</> clauses
    if any.  For example, a row removed because it does not meet the
    <literal>WHERE</> condition is not seen by any window function.
    A query can contain multiple window functions that slice up the data
    in different ways using different <literal>OVER</> clauses, but
    they all act on the same collection of rows defined by this virtual table.
   </para>
____________________________________________________________________________-->
   <para>
    一个窗口函数所考虑的行属于那些通过查询的<literal>FROM</literal>子句产生并通过<literal>WHERE</literal>、<literal>GROUP BY</literal>、<literal>HAVING</literal>过滤的<quote>虚拟表</quote>。例如，一个由于不满足<literal>WHERE</literal>条件被删除的行是不会被任何窗口函数所见的。在一个查询中可以包含多个窗口函数，每个窗口函数都可以用不同的<literal>OVER</literal>子句来按不同方式划分数据，但是它们都作用在由虚拟表定义的同一个行集上。
   </para>

<!--==========================orignal english content==========================
   <para>
    We already saw that <literal>ORDER BY</> can be omitted if the ordering
    of rows is not important.  It is also possible to omit <literal>PARTITION
    BY</>, in which case there is a single partition containing all rows.
   </para>
____________________________________________________________________________-->
   <para>
    我们已经看到如果行的顺序不重要时<literal>ORDER BY</literal>可以忽略。<literal>PARTITION BY</literal>同样也可以被忽略，在这种情况下会产生一个包含所有行的分区。
   </para>

<!--==========================orignal english content==========================
   <para>
    There is another important concept associated with window functions:
    for each row, there is a set of rows within its partition called its
    <firstterm>window frame</>.  Some window functions act only
    on the rows of the window frame, rather than of the whole partition.
    By default, if <literal>ORDER BY</> is supplied then the frame consists of
    all rows from the start of the partition up through the current row, plus
    any following rows that are equal to the current row according to the
    <literal>ORDER BY</> clause.  When <literal>ORDER BY</> is omitted the
    default frame consists of all rows in the partition.
     <footnote>
      <para>
       There are options to define the window frame in other ways, but
       this tutorial does not cover them.  See
       <xref linkend="syntax-window-functions"> for details.
      </para>
     </footnote>
    Here is an example using <function>sum</>:
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个与窗口函数相关的重要概念：对于每一行，在它的分区中的行集被称为它的窗口帧。 一些窗口函数只作用在<firstterm>窗口帧</firstterm>中的行上，而不是整个分区。默认情况下，如果使用<literal>ORDER BY</literal>，则帧包括从分区开始到当前行的所有行，以及后续任何与当前行在<literal>ORDER BY</literal>子句上相等的行。如果<literal>ORDER BY</literal>被忽略，则默认帧包含整个分区中所有的行。
     <footnote>
      <para>
       还有些选项用于以其他方式定义窗口帧，但是这不包括在本教程内。详见<xref linkend="syntax-window-functions"/>。
      </para>
     </footnote>
    下面是使用<function>sum</function>的例子：
   </para>

<!--==========================orignal english content==========================
<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>

<!--==========================orignal english content==========================
<screen>
 salary |  sum  
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>
____________________________________________________________________________-->
<screen>
 salary |  sum
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>

<!--==========================orignal english content==========================
   <para>
    Above, since there is no <literal>ORDER BY</> in the <literal>OVER</>
    clause, the window frame is the same as the partition, which for lack of
    <literal>PARTITION BY</> is the whole table; in other words each sum is
    taken over the whole table and so we get the same result for each output
    row.  But if we add an <literal>ORDER BY</> clause, we get very different
    results:
   </para>
____________________________________________________________________________-->
   <para>
    如上所示，由于在<literal>OVER</literal>子句中没有<literal>ORDER BY</literal>，窗口帧和分区一样，而如果缺少<literal>PARTITION BY</literal>则和整个表一样。换句话说，每个合计都会在整个表上进行，这样我们为每一个输出行得到的都是相同的结果。但是如果我们加上一个<literal>ORDER BY</literal>子句，我们会得到非常不同的结果：
   </para>

<!--==========================orignal english content==========================
<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>
____________________________________________________________________________-->
<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>

<!--==========================orignal english content==========================
<screen>
 salary |  sum  
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>
____________________________________________________________________________-->
<screen>
 salary |  sum
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>

<!--==========================orignal english content==========================
   <para>
    Here the sum is taken from the first (lowest) salary up through the
    current one, including any duplicates of the current one (notice the
    results for the duplicated salaries).
   </para>
____________________________________________________________________________-->
   <para>
    这里的合计是从第一个（最低的）薪水一直到当前行，包括任何与当前行相同的行（注意相同薪水行的结果）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Window functions are permitted only in the <literal>SELECT</literal> list
    and the <literal>ORDER BY</> clause of the query. They are forbidden
    elsewhere, such as in <literal>GROUP BY</>, <literal>HAVING</>
    and <literal>WHERE</literal> clauses.  This is because they logically
    execute after the processing of those clauses.  Also, window functions
    execute after non-window aggregate functions.  This means it is valid to
    include an aggregate function call in the arguments of a window function,
    but not vice versa.
   </para>
____________________________________________________________________________-->
   <para>
    窗口函数只允许出现在查询的<literal>SELECT</literal>列表和<literal>ORDER BY</literal>子句中。它们不允许出现在其他地方，例如<literal>GROUP BY</literal>、<literal>HAVING</literal>和<literal>WHERE</literal>子句中。这是因为窗口函数的执行逻辑是在处理完这些子句之后。另外，窗口函数在非窗口聚集函数之后执行。这意味着可以在窗口函数的参数中包括一个聚集函数，但反过来不行。
   </para>

<!--==========================orignal english content==========================
   <para>
    If there is a need to filter or group rows after the window calculations
    are performed, you can use a sub-select.  For example:

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

    The above query only shows the rows from the inner query having
    <literal>rank</> less than 3.
   </para>
____________________________________________________________________________-->
   <para>
    如果需要在窗口计算执行后进行过滤或者分组，我们可以使用子查询。例如：

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

    上述查询仅仅显示了内层查询中<literal>rank</literal>低于3的结果。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a query involves multiple window functions, it is possible to write
    out each one with a separate <literal>OVER</> clause, but this is
    duplicative and error-prone if the same windowing behavior is wanted
    for several functions.  Instead, each windowing behavior can be named
    in a <literal>WINDOW</> clause and then referenced in <literal>OVER</>.
    For example:

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    当一个查询涉及到多个窗口函数时，可以将每一个分别写在一个独立的<literal>OVER</literal>子句中。但如果多个函数要求同一个窗口行为时，这种做法是冗余的而且容易出错的。替代方案是，每一个窗口行为可以被放在一个命名的<literal>WINDOW</literal>子句中，然后在<literal>OVER</literal>中引用它。例如：

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    More details about window functions can be found in
    <xref linkend="syntax-window-functions">,
    <xref linkend="functions-window">,
    <xref linkend="queries-window">, and the
    <xref linkend="sql-select"> reference page.
   </para>
____________________________________________________________________________-->
   <para>
    关于窗口函数的更多细节可以在<xref linkend="syntax-window-functions"/>、<xref linkend="functions-window"/>、<xref linkend="queries-window"/>以及<xref linkend="sql-select"/>参考页中找到。
   </para>
  </sect1>


  <sect1 id="tutorial-inheritance">
<!--==========================orignal english content==========================
   <title>Inheritance</title>
____________________________________________________________________________-->
   <title>继承</title>

<!--==========================orignal english content==========================
   <indexterm zone="tutorial-inheritance">
    <primary>inheritance</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="tutorial-inheritance">
    <primary>inheritance</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Inheritance is a concept from object-oriented databases.  It opens
    up interesting new possibilities of database design.
   </para>
____________________________________________________________________________-->
   <para>
    继承是面向对象数据库中的概念。它展示了数据库设计的新的可能性。
   </para>

<!--==========================orignal english content==========================
   <para>
    Let's create two tables:  A table <classname>cities</classname>
    and a table <classname>capitals</classname>.  Naturally, capitals
    are also cities, so you want some way to show the capitals
    implicitly when you list all cities.  If you're really clever you
    might invent some scheme like this:

<programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
  altitude   int,    -&minus; (in ft)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  altitude   int     -&minus; (in ft)
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;
</programlisting>

    This works OK as far as querying goes, but it gets ugly when you
    need to update several rows, for one thing.
   </para>
____________________________________________________________________________-->
   <para>
    让我们创建两个表：表<classname>cities</classname>和表<classname>capitals</classname>。自然地，首都也是城市，所以我们需要有某种方式能够在列举所有城市的时候也隐式地包含首都。如果真的聪明，我们会设计如下的模式：

<programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
  altitude   int,    -- (in ft)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  altitude   int     -- (in ft)
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;
</programlisting>

    这个模式对于查询而言工作正常，但是当我们需要更新一些行时它就变得不好用了。
   </para>

<!--==========================orignal english content==========================
   <para>
    A better solution is this:

<programlisting>
CREATE TABLE cities (
  name       text,
  population real,
  altitude   int     -&minus; (in ft)
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    更好的方案是：

<programlisting>
CREATE TABLE cities (
  name       text,
  population real,
  altitude   int     -- (in ft)
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    In this case, a row of <classname>capitals</classname>
    <firstterm>inherits</firstterm> all columns (<structfield>name</>,
    <structfield>population</>, and <structfield>altitude</>) from its
    <firstterm>parent</firstterm>, <classname>cities</classname>.  The
    type of the column <structfield>name</structfield> is
    <type>text</type>, a native <productname>PostgreSQL</productname>
    type for variable length character strings.  State capitals have
    an extra column, <structfield>state</>, that shows their state.  In
    <productname>PostgreSQL</productname>, a table can inherit from
    zero or more other tables.
   </para>
____________________________________________________________________________-->
   <para>
    在这种情况下，一个<classname>capitals</classname>的行从它的<firstterm>父亲</firstterm><classname>cities</classname><firstterm>继承</firstterm>了所有列（<structfield>name</structfield>、<structfield>population</structfield>和<structfield>altitude</structfield>）。列<structfield>name</structfield>的类型是<type>text</type>，一种用于变长字符串的本地<productname>PostgreSQL</productname>类型。州首都有一个附加列<structfield>state</structfield>用于显示它们的州。在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个表继承。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, the  following  query finds the  names  of  all  cities,
    including  state capitals, that are located at an altitude
    over 500 feet:

<programlisting>
SELECT name, altitude
  FROM cities
  WHERE altitude &gt; 500;
</programlisting>

    which returns:

<screen>
   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    例如，如下查询可以寻找所有海拔500尺以上的城市名称，包括州首都：

<programlisting>
SELECT name, altitude
  FROM cities
  WHERE altitude &gt; 500;
</programlisting>

    它的返回为：

<screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    On the other hand, the  following  query  finds
    all  the cities that are not state capitals and
    are situated at an altitude over 500 feet:

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;
</programlisting>

<screen>
   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    在另一方面，下面的查询可以查找所有海拔高于500尺且不是州首府的城市：

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;
</programlisting>

<screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    Here the <literal>ONLY</literal> before <literal>cities</literal>
    indicates that the query should be run over only the
    <classname>cities</classname> table, and not tables below
    <classname>cities</classname> in the inheritance hierarchy.  Many
    of the commands that we have already discussed &mdash;
    <command>SELECT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> &mdash; support this <literal>ONLY</literal>
    notation.
   </para>
____________________________________________________________________________-->
   <para>
    其中<classname>cities</classname>之前的<literal>ONLY</literal>用于指示查询只在<classname>cities</classname>表上进行而不会涉及到继承层次中位于<classname>cities</classname>之下的其他表。很多我们已经讨论过的命令 &mdash; <command>SELECT</command>、<command>UPDATE</command> 和<command>DELETE</command> &mdash; 都支持这个<literal>ONLY</literal>记号。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Although inheritance is frequently useful, it has not been integrated
     with unique constraints or foreign keys, which limits its usefulness.
     See <xref linkend="ddl-inherit"> for more detail.
    </para>
____________________________________________________________________________-->
    <para>
     尽管继承很有用，但是它还未与唯一约束或外键集成，这也限制了它的可用性。更多详情见<xref linkend="ddl-inherit"/>。
    </para>
   </note>
  </sect1>


  <sect1 id="tutorial-conclusion">
<!--==========================orignal english content==========================
   <title>Conclusion</title>
____________________________________________________________________________-->
   <title>小结</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> has many features not
    touched upon in this tutorial introduction, which has been
    oriented toward newer users of <acronym>SQL</acronym>.  These
    features are discussed in more detail in the remainder of this
    book.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>中有很多特性在这个面向<acronym>SQL</acronym>新用户的教程中并未触及。有关这些特性的更多详情将在本书的后续部分进行讨论。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you feel you need more introductory material, please visit the PostgreSQL
    <ulink url="https://www.postgresql.org">web site</ulink>
    for links to more resources.
   </para>
____________________________________________________________________________-->
   <para>
    如果需要更多介绍材料，请访问 PostgreSQL <ulink url="https://www.postgresql.org">官方网站</ulink>来获得更多资源链接。
   </para>
  </sect1>
 </chapter>
